<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><author/><title>فصل چهارم: مباحث پیشرفته on زبان گو فارسی</title><link>https://book.gofarsi.ir/chapter-4/</link><description>Recent content in فصل چهارم: مباحث پیشرفته on زبان گو فارسی</description><generator>Hugo -- gohugo.io</generator><language>fa</language><copyright>2023 GoFarsi All rights reserved</copyright><atom:link href="https://book.gofarsi.ir/chapter-4/feed.xml" rel="self" type="application/rss+xml"/><item><author/><title>4.1 آموزش Build پروژه</title><link>https://book.gofarsi.ir/chapter-4/build-go-file/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/build-go-file/</guid><description>&lt;p>برای build یک پروژه شما باید از کامند go build استفاده کنید که این کامند دارای یکسری سوییچ می باشد که در زیر ما معرفی خواهیم کرد.&lt;/p>
&lt;h2 id="411-نحوه-build-یک-فایل-گو">
4.1.1 نحوه build یک فایل گو
&lt;a class="anchor" href="#411-%d9%86%d8%ad%d9%88%d9%87-build-%db%8c%da%a9-%d9%81%d8%a7%db%8c%d9%84-%da%af%d9%88">#&lt;/a>
&lt;/h2>
&lt;p>معمولا شما باید برای build فایلی که دارای package main هست را برای build استفاده کنید مانند مثال زیر :&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go build main.go
&lt;/code>&lt;/pre>
&lt;p>پس از build در محل همان فایل یک فایل با نام main ایجاد می شود.&lt;/p>
&lt;blockquote class="book-hint info">
&lt;p>اگر فایل main شما در روت پروژه باشد نیازی نیست به دستور go build نام فایل را بدهید کافیه مانند دستور زیر پروژه را build کنید.&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go build .
&lt;/code>&lt;/pre>
&lt;p>خروجی یک فایل با نام پروژه ایجاد می شود.&lt;/p>
&lt;/blockquote>
&lt;h2 id="412-استفاده-از-gcflags-برای-build">
4.1.2 استفاده از gcflags برای build
&lt;a class="anchor" href="#412-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-gcflags-%d8%a8%d8%b1%d8%a7%db%8c-build">#&lt;/a>
&lt;/h2>
&lt;p>همانطور که گفتیم کامند build دارای یکسری سوییچ می باشد که یکی از سوییچ هایش &lt;code>gcflags&lt;/code> می باشد که می توانید هنگام build یکسری اطلاعات مربوط به دیباگ به فایل خروجی اضافه می شود.&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go build -gcflags &amp;quot;-N -l&amp;quot; main.go
&lt;/code>&lt;/pre>
&lt;p>توجه کنید این نوع build گرفتن برای انجام Remote Debugging که در بخش بعدی آموزش می دهیم خیلی کاربردی می باشد.&lt;/p>
&lt;h2 id="413-تعیین-نام-خروجی-فایل-معماری-و-سیستم-عامل">
4.1.3 تعیین نام خروجی فایل, معماری و سیستم عامل
&lt;a class="anchor" href="#413-%d8%aa%d8%b9%db%8c%db%8c%d9%86-%d9%86%d8%a7%d9%85-%d8%ae%d8%b1%d9%88%d8%ac%db%8c-%d9%81%d8%a7%db%8c%d9%84-%d9%85%d8%b9%d9%85%d8%a7%d8%b1%db%8c-%d9%88-%d8%b3%db%8c%d8%b3%d8%aa%d9%85-%d8%b9%d8%a7%d9%85%d9%84">#&lt;/a>
&lt;/h2>
&lt;p>اگر یادتان باشد در بخش تاریخچه زبان گو یکی از ویژگی های بارزی که در خصوص زبان گو گفتیم بحث Cross-Platform Build بود که شما می توانید در همان سیستم عاملی که هستید برای سایر پلت فرم ها و سیستم عامل ها خروجی بگیرید.&lt;/p>
&lt;pre>&lt;code class="language-shell">$ GOOS=linux GOARCH=amd64 go build -o myproject main.go
&lt;/code>&lt;/pre>
&lt;p>کامند فوق در لینوکس و سیستم عامل های یونیکسی کاربردی است که شما می توانید قبل از فرمان اصلی یکسری environment variables تعیین کنید. که در کامند فوق ما ۲ تا environment قرار دادیم اولی برای تعیین سیستم عامل هست و دومی معماری هست که ۳۲ بیت یا ۶۴ بیت و همچنین از نوع arm باشد. سپس فرمان go build را قرار دادیم حال خروجی فایل مناسب برای هر سیستم عامل لینوکس با معماری amd64 (۶۴ بیت) می باشد. و در انتهای کامند یک سوییچ &lt;code>o-&lt;/code> قرار دادیم که نام خروجی فایل build شده چی باشد.&lt;/p>
&lt;h2 id="414-گرفتن-build-به-همراه-race-detector">
4.1.4 گرفتن build به همراه race detector
&lt;a class="anchor" href="#414-%da%af%d8%b1%d9%81%d8%aa%d9%86-build-%d8%a8%d9%87-%d9%87%d9%85%d8%b1%d8%a7%d9%87-race-detector">#&lt;/a>
&lt;/h2>
&lt;p>در فصل سوم یک بخشی داشتیم به نام &lt;a href="../../chapter-3/goroutine-data-race/">data race&lt;/a> که در خصوصش توضیح دادیم چطور جلوی این اتفاق را در همزمانی بگیریم. حال یک سوییچ در کامند build داریم به نام &lt;code>race-&lt;/code> برای تشخیص data race کمک می کند.&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go build -race
&lt;/code>&lt;/pre>
&lt;h2 id="415-مقدار-دهی-متغیر-هنگام-build">
4.1.5 مقدار دهی متغیر هنگام build
&lt;a class="anchor" href="#415-%d9%85%d9%82%d8%af%d8%a7%d8%b1-%d8%af%d9%87%db%8c-%d9%85%d8%aa%d8%ba%db%8c%d8%b1-%d9%87%d9%86%da%af%d8%a7%d9%85-build">#&lt;/a>
&lt;/h2>
&lt;p>اما یکی از سوییچ های خیلی جالب در زبان گو هست که هنگام build پروژه می تواند متغیری را در هرجای پروژه مقدار دهی کند و از کاربردهای آن می توان برای تعیین ورژن پروژه و&amp;hellip; می باشد.&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import &amp;quot;fmt&amp;quot;
var (
Version string
BuildTime string
)
func main() {
fmt.Printf(&amp;quot;version %s, build time %s&amp;quot;, Version, BuildTime)
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-shell">$ go build -ldflags &amp;quot;-X main.Version=1.0.0 -X main.BuildTime=`date -u +%Y-%m-%dT%H:%M:%SZ`&amp;quot; main.go
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-shell">$ ./main
version 1.0.0, build time 2023-01-27T14:19:23Z
&lt;/code>&lt;/pre>
&lt;p>در کد فوق ما ۲ متغیر ایجاد کردیم که هنگام build مقدار دهی کنیم و به کامند build ما یک سوییچ &lt;code>ldflags-&lt;/code> اضافه کردیم و آدرس متغیرها را جهت مقدار دهی به این کامند داده‌ایم.&lt;/p>
&lt;blockquote class="book-hint info">
&lt;p>توجه کنید اگر متغیرهایتان داخل پکیج (پوشه ای) مانند configs بود آدرس متغییر بصورت زیر می شود :&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go build -ldflags &amp;quot;-X configs.Version=1.0.0 -X configs.BuildTime=`date -u +%Y-%m-%dT%H:%M:%SZ`&amp;quot; main.go
&lt;/code>&lt;/pre>
&lt;/blockquote></description></item><item><author/><title>4.2 آموزش کار با Debugging</title><link>https://book.gofarsi.ir/chapter-4/debugging-go-code/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/debugging-go-code/</guid><description>&lt;p>برای بحث debugging در زبان گو روش های مختلفی وجود دارد که محبوبترین روش ها به شرح زیر می باشد :&lt;/p>
&lt;ol>
&lt;li>با استفاده پکیج &lt;code>fmt&lt;/code> : شما با استفاده از تابع &lt;code>fmt.Println&lt;/code> می توانید مقادیر برخی از متغیرها را چاپ کنید و یکی از روش های ساده برای بحث دیباگ هستش.&lt;/li>
&lt;li>با استفاده از پکیج &lt;code>log&lt;/code> : یکی از کاربردی ترین روش ها بحث لاگ کردن هستش که شما می توانید هر بخش از کدهای خود را لاگ کنید و بصورت زنده در console یا داخل فایل ببینید و از همه مهمتر شما می توانید لاگ های خود را سطح بندی کنید تا بهتر بتوانید دیباگ کنید.&lt;/li>
&lt;li>استفاده از پکیج &lt;code>pprof&lt;/code> : پکیج pprof به شما کمک می کند تا راحتر مشکلات عملکردی برنامه خود را بیابید و همچنین خروجی profile از عملکرد برنامه با CPU و Memory را آنالیز کنید.&lt;/li>
&lt;li>با استفاده از IDE ها: اکثر IDE هایی (Goland, Vscode) که قبلا معرفی کردیم دارای دیباگر داخلی می باشند که شما می توانید در هر بخش از کد خود breakpoint بزارید و خط به خط کد را دیباگ کنید و مشکلات را برطرف کنید.&lt;/li>
&lt;li>با استفاده از دیباگر &lt;code>dlv&lt;/code> : یکی از محبوبترین دیباگرهایی بصورت متن باز در حال توسعه است &lt;a href="https://github.com/go-delve/delve">delve&lt;/a> می باشد که به شما برای دیباگ کردن بصورت تعاملی هنگام اجرا کمک می کند.&lt;/li>
&lt;/ol>
&lt;p>حال در ادامه ما با مثال هایی نحوه کار با این شیوه هایی که معرفی کردیم آموزش می دهیم.&lt;/p>
&lt;h2 id="421-نحوه-دیباگ-با-fmt">
4.2.1 نحوه دیباگ با fmt
&lt;a class="anchor" href="#421-%d9%86%d8%ad%d9%88%d9%87-%d8%af%db%8c%d8%a8%d8%a7%da%af-%d8%a8%d8%a7-fmt">#&lt;/a>
&lt;/h2>
&lt;p>شما با استفاده از تابع &lt;code>fmt.Println&lt;/code> می توانید مقادیر برخی از متغیرها را چاپ کنید و برای اینکار به مثال ساده زیر توجه کنید :&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func fibonacci(n uint) uint {
if n &lt; 2 {
return n
}
var a, b uint
b = 1
for n--; n > 0; n-- {
a += b
a, b = b, a
fmt.Println("this is example debugging value a is ", a, " value b is ", b)
}
return b
}
func main() {
fmt.Println(fibonacci(100))
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در کد فوق برای اینکه مقدار a, b را ببینیم از تابع Println استفاده کردیم تا مقدار داخل این دو متغیر را ببینیم.&lt;/p>
&lt;h2 id="422-نحوه-دیباگ-با-استفاده-log">
4.2.2 نحوه دیباگ با استفاده log
&lt;a class="anchor" href="#422-%d9%86%d8%ad%d9%88%d9%87-%d8%af%db%8c%d8%a8%d8%a7%da%af-%d8%a8%d8%a7-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-log">#&lt;/a>
&lt;/h2>
&lt;p>یکی از کاربردی ترین روش ها بحث لاگ کردن هستش که شما می توانید هر بخش از کدهای خود را لاگ کنید و بصورت زنده در console یا داخل فایل ببینید و از همه مهمتر شما می توانید لاگ های خود را سطح بندی کنید تا بهتر بتوانید دیباگ کنید. حال برای اینکه با log دیباگ کنید یک پکیج استاندارد به نام log داریم که می توانید بسته به نیازتان تغییرات دهید و هچنین پکیج هایی نظیر zap, logrus و &amp;hellip; هست برای بحث لاگ به شما خیلی کمک می کنند.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"log"
"os"
)
func main() {
// Set the log level to Info
log.SetFlags(0)
log.SetPrefix("[Info] ")
log.SetOutput(os.Stdout)
log.Println("This is an informational message")
// Set the log level to Warning
log.SetPrefix("[Warn] ")
log.SetOutput(os.Stdout)
log.Println("This is a warning message")
// Set the log level to Error
log.SetPrefix("[Error] ")
log.SetOutput(os.Stderr)
log.Println("This is an error message")
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در کد فوق ما با استفاده از تابع SetPrefix یک پیشوند برای لاگ ها اضافه کردیم تا بتوانیم لاگ با سطح های مختلف ایجاد کنیم. و با استفاده از log.Println لاگ را چاپ کردیم. در ادامه این فصل به بحث آموزش کار به log میپردازیم.&lt;/p>
&lt;h2 id="423-دیباگ-عملکرد-با-استفاده-از-pprof">
4.2.3 دیباگ عملکرد با استفاده از pprof
&lt;a class="anchor" href="#423-%d8%af%db%8c%d8%a8%d8%a7%da%af-%d8%b9%d9%85%d9%84%da%a9%d8%b1%d8%af-%d8%a8%d8%a7-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-pprof">#&lt;/a>
&lt;/h2>
&lt;p>زبان گو یک ابزار داخلی دارد جهت آنالیز و دیباگ عملکرد به نام pprof که با استفاده از آن می توانید یکسری اطلاعات در خصوص عملکرد برنامه تهیه کنید و براساس آنالیز اطلاعات مشکلات عملکردی را می توانید برطرف کنید.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"log"
"net/http"
_ "net/http/pprof"
)
func main() {
log.Println(http.ListenAndServe("localhost:6060", nil))
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در کد فوق ما از پکیج مسیر &lt;code>net/http/pprof&lt;/code> استفاده کردیم تا عملکرد برنامه را در وب سرور زبان گو را آنالیز و دیباگ کنیم. حال اگر به آدرس http://localhost:6060/debug/pprof/ بروید می توانید وضعیت عملکرد وب سرور را در لحظه ببینید و آنالیز کنید.&lt;/p>
&lt;center>&lt;a href="#">
&lt;img src="../../assets/img/content/chapter4/debugging/1.png" alt="pprof">
&lt;/a>&lt;/center>
&lt;h3 id="4231-آنالیز-وضعیت-cpu">
4.2.3.1 آنالیز وضعیت CPU
&lt;a class="anchor" href="#4231-%d8%a2%d9%86%d8%a7%d9%84%db%8c%d8%b2-%d9%88%d8%b6%d8%b9%db%8c%d8%aa-cpu">#&lt;/a>
&lt;/h3>
&lt;p>برای آنالیز وضعیت CPU کافیه کامند زیر را بزنید :&lt;/p>
&lt;pre>&lt;code class="language-shell">go tool pprof http://localhost:6060/debug/pprof/profile
&lt;/code>&lt;/pre>
&lt;h3 id="4232-آنالیز-وضعیت-heap-memory">
4.2.3.2 آنالیز وضعیت heap memory
&lt;a class="anchor" href="#4232-%d8%a2%d9%86%d8%a7%d9%84%db%8c%d8%b2-%d9%88%d8%b6%d8%b9%db%8c%d8%aa-heap-memory">#&lt;/a>
&lt;/h3>
&lt;p>برای آنالیز حافظه heap کافیه کامند زیر را بزنید :&lt;/p>
&lt;pre>&lt;code class="language-shell">go tool pprof http://localhost:6060/debug/pprof/heap
Fetching profile over HTTP from http://localhost:6060/debug/pprof/heap
Saved profile in /home/javad/pprof/pprof.main.alloc_objects.alloc_space.inuse_objects.inuse_space.001.pb.gz
File: main
Type: inuse_space
Time: Jan 27, 2023 at 6:46pm (+0330)
Entering interactive mode (type &amp;quot;help&amp;quot; for commands, &amp;quot;o&amp;quot; for options)
(pprof) pdf
&lt;/code>&lt;/pre>
&lt;p>زمانیکه کامند فوق را بزنید وارد شل pprof خواهید شد که می توانید با زدن help کامندهای کاربردی را جهت آنالیز ببینید. به عنوان مثال pdf را بزنید یک خروجی pdf بصورت گراف از وضعیت حافظه heap ارائه می دهد که می توانید وضعیت را آنالیز کنید (&lt;a href="https://git.io/JfYMW">جهت خواندن گراف این آموزش را مطالعه کنید&lt;/a>).&lt;/p>
&lt;h2 id="424-دیباگ-با-استفاده-از--gdb">
4.2.4 دیباگ با استفاده از GDB
&lt;a class="anchor" href="#424-%d8%af%db%8c%d8%a8%d8%a7%da%af-%d8%a8%d8%a7-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2--gdb">#&lt;/a>
&lt;/h2>
&lt;p>این قسمت با استفاده از مستندات رسمی GO در مورد 1. &lt;a href="https://go.dev/doc/gdb">Debugging Go Code with GDB&lt;/a> نوشته شده است.
دستورالعمل های زیر برای استاندارد toolchain (کامپایلر و ابزارهای gc Go) اعمال می شود. Gccgo دارای پشتیبانی از native gdb به صورت پیش فرض است.&lt;/p>
&lt;p>توجه داشته باشید که هنگام اشکال زدایی برنامه های Go که باstandard toolchain ساخته شده اند، &lt;a href="https://github.com/go-delve/delve">Delve&lt;/a> جایگزین بهتری برای GDB است. زیرا Go runtime را بهتر تشخیص می‌دهد و ساختارهای داده و عبارات را بهتر از GDB درک می کند. Delve در حال حاضر از Linux، OSX و Windows در amd64 پشتیبانی می کند. برای به روزترین لیست پلتفرم های پشتیبانی شده، لطفاً به &lt;a href="https://github.com/go-delve/delve/tree/master/Documentation/installation">Delve documentation&lt;/a> مراجعه کنید.&lt;/p>
&lt;p>GDB برنامه های Go را به خوبی درک نمی کند. مدیریت stack و threading و runtime شامل جنبه هایی هستند که به اندازه کافی با مدل اجرایی متفاوت است که GDB انتظار دارد که می توانند debugger را اشتباه گرفته و نتایج نادرستی را حتی زمانی که برنامه با gccgo کامپایل می شود ایجاد کنند. در نتیجه، اگرچه GDB می‌تواند در برخی موقعیت‌ها مفید باشد (به عنوان مثال، اشکال‌زدایی کد Cgo، یا اشکال‌زدایی خود زمان اجرا)، اما برای برنامه‌های Go، به‌ویژه برنامه‌های به‌شدت همزمان هستند، اشکال‌زدایی با این روش چندان قابل اعتمادی نیست. علاوه بر این، پرداختن به این مسائل که دشوار هستند، برای پروژه Go در اولویت نیست.&lt;/p>
&lt;p>به طور خلاصه، دستورالعمل‌های زیر باید تنها به‌عنوان راهنمای نحوه استفاده از GDB در هنگام کارکرد آن در نظر گرفته شود، نه به عنوان تضمین موفقیت اجرای درست برنامه. علاوه بر این نمای کلی، ممکن است بخواهید به &lt;a href="https://sourceware.org/gdb/current/onlinedocs/gdb/">GDB manual&lt;/a> مراجعه کنید.&lt;/p>
&lt;h3 id="4241-مقدمه-اولیه-gdb">
4.2.4.1 مقدمه اولیه GDB
&lt;a class="anchor" href="#4241-%d9%85%d9%82%d8%af%d9%85%d9%87-%d8%a7%d9%88%d9%84%db%8c%d9%87-gdb">#&lt;/a>
&lt;/h3>
&lt;p>وقتی برنامه‌های Go را با toolchain مربوط gc در Linux، macOS، FreeBSD یا NetBSD کامپایل و link می‌دهید، باینری‌های به دست آمده حاوی اطلاعات اشکال‌زدایی DWARFv4 هستند که نسخه‌های اخیر (≥7.5) اشکال‌زدای GDB می‌توانند از آن برای بازرسی یک live process یا یک core dump استفاده کنند. .&lt;/p>
&lt;p>پرچم &amp;lsquo;-w&amp;rsquo; را به linker ارسال کنید تا اطلاعات debug را حذف کنید (به عنوان مثال، &lt;code>go build -ldflags=-w prog.go&lt;/code>).&lt;/p>
&lt;p>کد تولید شده توسط کامپایلر gc شامل درون خطی کردن فراخوانی تابع و ثبت متغیرها است. این بهینه سازی ها گاهی اوقات می تواند اشکال زدایی با gdb را سخت تر کند. اگر متوجه شدید که باید این بهینه سازی ها را غیرفعال کنید، برنامه خود را با استفاده از &lt;code>go build -gcflags=all=-N -l&lt;/code> بسازید.&lt;/p>
&lt;p>اگر می‌خواهید از gdb برای بررسی یک core dump استفاده کنید، می توانید یک Dump را در یک program crash راه اندازی کنید و برای این کار باید GOTRACEBACK=crash در environment تنظیم کنید (برای اطلاعات بیشتر به  &lt;a href="https://go.dev/pkg/runtime/#hdr-Environment_Variables">runtime package documentation&lt;/a> مراجعه کنید).&lt;/p>
&lt;h3 id="4242--common-operations">
4.2.4.2 Common Operations
&lt;a class="anchor" href="#4242--common-operations">#&lt;/a>
&lt;/h3>
&lt;p>نمایش فایل و شماره خط برای کد، تعیین breakpoints و disassemble:&lt;/p>
&lt;pre>&lt;code class="language-shell">(gdb) list
(gdb) list _line_
(gdb) list _file.go_:_line_
(gdb) break _line_
(gdb) break _file.go_:_line_
(gdb) disas
&lt;/code>&lt;/pre>
&lt;p>نمایش backtraces و باز کردن stack frames:&lt;/p>
&lt;pre>&lt;code class="language-shell">(gdb) bt
(gdb) frame _n_
&lt;/code>&lt;/pre>
&lt;p>نمایش نام، type و location در stack frame و local variables، آرگومان ها و مقادیر بازگشتی:&lt;/p>
&lt;pre>&lt;code class="language-shell">(gdb) info locals
(gdb) info args
(gdb) p variable
(gdb) whatis variable
&lt;/code>&lt;/pre>
&lt;p>نمایش نام، type و location و global variables:&lt;/p>
&lt;pre>&lt;code class="language-shell">(gdb) info variables _regexp_
&lt;/code>&lt;/pre>
&lt;h3 id="4243---go-extensions">
4.2.4.3 Go Extensions
&lt;a class="anchor" href="#4243---go-extensions">#&lt;/a>
&lt;/h3>
&lt;p>اخیرا یک نوع extension به GDB اجازه می دهد تا extension scripts را برای یک باینری معین load کند. این toolchain برای extend GDB با تعداد انگشت شماری از command ها برای بررسی داخلی runtime code (مانند گوروتین ها) و pretty print the built-in map و slice وchannel types استفاده می کند.&lt;/p>
&lt;pre>&lt;code class="language-shell">Pretty printing a string, slice, map, channel or interface:(gdb) p var
A $len() and $cap() function for strings, slices and maps: (gdb) p $len(var)
A function to cast interfaces to their dynamic types:
(gdb) p $dtype(var)
(gdb) iface var
&lt;/code>&lt;/pre>
&lt;p>مشکلات شناخته شده:
GDB نمی تواند به طور خودکار dynamic type یک interface value را پیدا کند اگر نام طولانی آن با نام کوتاه آن متفاوت باشد (در هنگام printing stacktraces آزاردهنده است، pretty printer به نمایش نام short type و اشاره گر بازمی گردد).&lt;/p>
&lt;p>بررسی گوروتین ها:&lt;/p>
&lt;pre>&lt;code class="language-shell">(gdb) info goroutines
(gdb) goroutine _n_ _cmd_
(gdb) help goroutine
&lt;/code>&lt;/pre>
&lt;p>به عنوان مثال:&lt;/p>
&lt;pre>&lt;code class="language-shell">(gdb) goroutine 12 bt
&lt;/code>&lt;/pre>
&lt;p>می توانید همه گوروتین ها را با pass کردن همه به جای goroutine&amp;rsquo;s ID خاص بررسی کنید. مثلا:&lt;/p>
&lt;pre>&lt;code class="language-shell"> (gdb) goroutine all bt
&lt;/code>&lt;/pre>
&lt;p>اگر می‌خواهید ببینید که این حالت چگونه کار می‌کند یا می‌خواهید آن را گسترش دهید، به &lt;a href="https://go.dev/src/runtime/runtime-gdb.py">src/runtime/runtime-gdb.py&lt;/a> در توزیع Go source نگاهی بیندازید. این به برخی از type های جادویی خاص (&lt;code>hash&amp;lt;T,U&amp;gt;&lt;/code>) و متغیرهایی (runtime.m و runtime.g) بستگی دارد کهlinker (&lt;a href="https://go.dev/src/cmd/link/internal/ld/dwarf.go">src/cmd/link/internal/ld/dwarf.go&lt;/a>) اطمینان حاصل می کند که در کد DWARF توضیح داده شده اند.&lt;/p>
&lt;p>اگر به debugging information علاقه دارید، objdump -W a.out را اجرا کنید و در بخش های مرتبط با .debug_* مرور کنید.&lt;/p>
&lt;h4 id="مشکلات-شناخته-شده">
مشکلات شناخته شده:
&lt;a class="anchor" href="#%d9%85%d8%b4%da%a9%d9%84%d8%a7%d8%aa-%d8%b4%d9%86%d8%a7%d8%ae%d8%aa%d9%87-%d8%b4%d8%af%d9%87">#&lt;/a>
&lt;/h4>
&lt;p>۱- حالت String pretty printing فقط برای type string فعال می شود، نه برای انواع مشتق شده از آن.
۲-Type information برای قسمت های C که در runtime library هستند، وجود ندارد.
۳- GDB شرایط Go’s name را نمی‌فهمد و «fmt.Print» را به‌عنوان یک کلمه بدون ساختار با یک «» در نظر می‌گیرد. که باید نقل شود. حتی با شدت بیشتری به method names فرم &lt;code>pkg.(*MyType).Meth&lt;/code>. برخورد می کند.
۴- از Go 1.11، قسمت debug information به طور پیش فرض فشرده شده است. نسخه‌های قدیمی‌تر gdb، مانند نسخه‌ای که به‌طور پیش‌فرض در MacOS موجود است، فشرده‌سازی را درک نمی‌کنند. شما می توانید با استفاده از &lt;code>go build -ldflags=-compressdwarf=false‍&lt;/code> اطلاعات اشکال زدایی فشرده نشده تولید کنید. (برای راحتی می توانید گزینه -ldflags را در  &lt;a href="https://go.dev/cmd/go/#hdr-Environment_variables">&lt;code>GOFLAGS&lt;/code> environment variable&lt;/a> قرار دهید تا مجبور نباشید هر بار آدرس آن را مشخص کنید.)&lt;/p>
&lt;h3 id="4244---مثال-های-gdb">
4.2.4.4 مثال های GDB
&lt;a class="anchor" href="#4244---%d9%85%d8%ab%d8%a7%d9%84-%d9%87%d8%a7%db%8c-gdb">#&lt;/a>
&lt;/h3>
&lt;p>در این آموزش ما باینری unit tests پکیج &lt;a href="https://go.dev/pkg/regexp/">regexp&lt;/a> را بررسی می کنیم. برای ساخت باینری، به  &lt;code>GOROOT/src/regexp$&lt;/code> تغییر دهید و &lt;code>go test -c&lt;/code> را اجرا کنید. این باید یک فایل اجرایی به نام &lt;code>regexp.test&lt;/code> تولید کند.&lt;/p>
&lt;h4 id="شروع-دیباگ">
شروع دیباگ
&lt;a class="anchor" href="#%d8%b4%d8%b1%d9%88%d8%b9-%d8%af%db%8c%d8%a8%d8%a7%da%af">#&lt;/a>
&lt;/h4>
&lt;p>Launch GDB, debugging &lt;code>regexp.test&lt;/code>:&lt;/p>
&lt;pre>&lt;code class="language-shell">$ gdb regexp.test
GNU gdb (GDB) 7.2-gg8
Copyright (C) 2010 Free Software Foundation, Inc.
License GPLv 3+: GNU GPL version 3 or later &amp;lt;http://gnu.org/licenses/gpl.html&amp;gt;
Type &amp;quot;show copying&amp;quot; and &amp;quot;show warranty&amp;quot; for licensing/warranty details.
This GDB was configured as &amp;quot;x86_64-linux&amp;quot;.
Reading symbols from /home/user/go/src/regexp/regexp.test...
done.
Loading Go Runtime support.
(gdb)
&lt;/code>&lt;/pre>
&lt;p>پیام &amp;lsquo;Loading Go Runtime Support&amp;rsquo; به این معنی است که GDB برنامه extension را از مسیر &lt;code>GOROOT/src/runtime/runtime-gdb.py$&lt;/code> بارگیری کرده است.&lt;/p>
&lt;p>برای کمک به GDB در یافتن آدرس Go runtime sources و سایر اسکریپت‌های همراه، &lt;code>$GOROOT&lt;/code> را با پرچم &amp;lsquo;-d&amp;rsquo; ارسال کنید:&lt;/p>
&lt;p>&lt;code>gdb regexp.test -d $GOROOT$ &lt;/code>&lt;/p>
&lt;p>اگر به دلایلی هنوز GDB نمی تواند آن دایرکتوری یا آن اسکریپت را پیدا کند، می توانید آن را دستی load کنید (با فرض اینکه  go sources در آدرس ~/go/ باشد):&lt;/p>
&lt;pre>&lt;code class="language-shell">(gdb) source ~/go/src/runtime/runtime-gdb.py
Loading Go Runtime support.
&lt;/code>&lt;/pre>
&lt;h4 id="بررسی-کردن-source">
بررسی کردن source
&lt;a class="anchor" href="#%d8%a8%d8%b1%d8%b1%d8%b3%db%8c-%da%a9%d8%b1%d8%af%d9%86-source">#&lt;/a>
&lt;/h4>
&lt;p>از دستور &amp;rsquo;l&amp;rsquo; یا &amp;rsquo;list&amp;rsquo; برای بررسی source code استفاده کنید.&lt;/p>
&lt;pre>&lt;code class="language-shell">(gdb) l
&lt;/code>&lt;/pre>
&lt;p>بخش خاصی از منبع را که &amp;rsquo;list&amp;rsquo; را پارامتر می کند با نام تابع فهرست کنید (باید با نام بسته آن مرتبط باشد).&lt;/p>
&lt;pre>&lt;code class="language-shell">(gdb) l main.main
&lt;/code>&lt;/pre>
&lt;p>یک file خاص و line number را فهرست کنید:&lt;/p>
&lt;pre>&lt;code class="language-shell">(gdb) l regexp.go:1
(gdb) _# Hit enter to repeat last command. Here, this lists next 10 lines._
&lt;/code>&lt;/pre>
&lt;h4 id="naming">
Naming
&lt;a class="anchor" href="#naming">#&lt;/a>
&lt;/h4>
&lt;p>نام متغیرها و توابع باید با نام package هایی که به آنها تعلق دارند قابل بازیابی باشند. به عنوان مثال تابع Compile از بسته regexp برای GDB به عنوان &amp;lsquo;regexp.Compile&amp;rsquo; شناخته می شود.&lt;/p>
&lt;p>متدها باید با نام receiver types خود قابل بازیابی باشند. به عنوان مثال، &lt;code>*Regexp&lt;/code> type’s &lt;code>String&lt;/code> به عنوان &lt;code>'regexp.(*Regexp).String'&lt;/code> شناخته می شود.&lt;/p>
&lt;p>متغیرهایی که سایر متغیرها را تحت shadow قرار می دهند، به صورت جادویی با یک عدد در debug info پسوند می شوند. متغیرهایی که توسط بسته‌ها ارجاع می‌شوند به‌عنوان اشاره‌گرهایی با پیشوند جادویی «&amp;amp;» ظاهر می‌شوند.&lt;/p>
&lt;h4 id="قراردادن---breakpoints">
قراردادن breakpoints
&lt;a class="anchor" href="#%d9%82%d8%b1%d8%a7%d8%b1%d8%af%d8%a7%d8%af%d9%86---breakpoints">#&lt;/a>
&lt;/h4>
&lt;p>یک breakpoint در تابع TestFind تنظیم کنید:
‍‍&lt;/p>
&lt;pre>&lt;code class="language-shell">(gdb) b 'regexp.TestFind'
Breakpoint 1 at 0x424908: file /home/user/go/src/regexp/find_test.go, line 148.
&lt;/code>&lt;/pre>
&lt;p>اجرا کردن برنامه:&lt;/p>
&lt;pre>&lt;code class="language-shell">(gdb) run
Starting program: /home/user/go/src/regexp/regexp.test
Breakpoint 1, regexp.TestFind (t=0xf8404a89c0) at /home/user/go/src/regexp/find_test.go:148
148 func TestFind(t *testing.T) {
&lt;/code>&lt;/pre>
&lt;p>اجرا در breakpoint متوقف شده است. ببینید کدام گوروتین ها در حال اجرا هستند و چه کار می کنند:&lt;/p>
&lt;pre>&lt;code class="language-shell">(gdb) info goroutines
1 waiting runtime.gosched
* 13 running runtime.goexit
&lt;/code>&lt;/pre>
&lt;p>موردی که با * مشخص شده است، گوروتین فعلی است.&lt;/p>
&lt;h4 id="بررسی-کردن-stack">
بررسی کردن stack
&lt;a class="anchor" href="#%d8%a8%d8%b1%d8%b1%d8%b3%db%8c-%da%a9%d8%b1%d8%af%d9%86-stack">#&lt;/a>
&lt;/h4>
&lt;p>به خروجی از stack برای جایی که برنامه را متوقف کرده ایم نگاه کنید:&lt;/p>
&lt;pre>&lt;code class="language-shell">(gdb) bt _# backtrace_
#0 regexp.TestFind (t=0xf8404a89c0) at /home/user/go/src/regexp/find_test.go:148
#1 0x000000000042f60b in testing.tRunner (t=0xf8404a89c0, test=0x573720) at /home/user/go/src/testing/testing.go:156
#2 0x000000000040df64 in runtime.initdone () at /home/user/go/src/runtime/proc.c:242
#3 0x000000f8404a89c0 in ?? ()
#4 0x0000000000573720 in ?? ()
#5 0x0000000000000000 in ?? ()
&lt;/code>&lt;/pre>
&lt;p>گوروتین دیگر، شماره 1، در runtime.gosched گیر کرده و در channel receive مسدود شده است:&lt;/p>
&lt;pre>&lt;code class="language-shell">(gdb) goroutine 1 bt
#0 0x000000000040facb in runtime.gosched () at /home/user/go/src/runtime/proc.c:873
#1 0x00000000004031c9 in runtime.chanrecv (c=void, ep=void, selected=void, received=void)
at /home/user/go/src/runtime/chan.c:342
#2 0x0000000000403299 in runtime.chanrecv1 (t=void, c=void) at/home/user/go/src/runtime/chan.c:423
#3 0x000000000043075b in testing.RunTests (matchString={void (struct string, struct string, bool *, error *)}
0x7ffff7f9ef60, tests= []testing.InternalTest = {...}) at /home/user/go/src/testing/testing.go:201
#4 0x00000000004302b1 in testing.Main (matchString={void (struct string, struct string, bool *, error *)}
0x7ffff7f9ef80, tests= []testing.InternalTest = {...}, benchmarks= []testing.InternalBenchmark = {...})
at /home/user/go/src/testing/testing.go:168
#5 0x0000000000400dc1 in main.main () at /home/user/go/src/regexp/_testmain.go:98
#6 0x00000000004022e7 in runtime.mainstart () at /home/user/go/src/runtime/amd64/asm.s:78
#7 0x000000000040ea6f in runtime.initdone () at /home/user/go/src/runtime/proc.c:243
#8 0x0000000000000000 in ?? ()
&lt;/code>&lt;/pre>
&lt;p>همانطور که stack frame نشان می دهد، انتظار می رود الان باید در حال اجرای تابع regexp.TestFind باشیم.&lt;/p>
&lt;pre>&lt;code class="language-shell">(gdb) info frame
Stack level 0, frame at 0x7ffff7f9ff88:
rip = 0x425530 in regexp.TestFind (/home/user/go/src/regexp/find_test.go:148);
saved rip 0x430233
called by frame at 0x7ffff7f9ffa8
source language minimal.
Arglist at 0x7ffff7f9ff78, args: t=0xf840688b60
Locals at 0x7ffff7f9ff78, Previous frame's sp is 0x7ffff7f9ff88
Saved registers:
rip at 0x7ffff7f9ff80
&lt;/code>&lt;/pre>
&lt;p>دستور info locals همه متغیرهای محلی تابع و مقادیر آنها را فهرست می‌کند، اما استفاده از آن کمی خطرناک است، زیرا سعی می‌کند متغیرهای اولیه را نیز چاپ کند. برش‌های بدون مقدار اولیه ممکن است باعث شوند که gdb سعی کند آرایه‌های بزرگ دلخواه را چاپ کند.&lt;/p>
&lt;p>آرگومان های تابع:&lt;/p>
&lt;pre>&lt;code class="language-shell">(gdb) info args
t = 0xf840688b60
&lt;/code>&lt;/pre>
&lt;p>هنگام چاپ آرگومان، توجه کنید که نشانگر یک مقدار Regexp است. توجه داشته باشید که GDB به اشتباه * را در سمت راست نام تایپ قرار داده و یک کلمه کلیدی &amp;lsquo;struct&amp;rsquo; به سبک سنتی C ساخته است.&lt;/p>
&lt;pre>&lt;code class="language-shell">(gdb) p re
(gdb) p t
$1 = (struct testing.T *) 0xf840688b60
(gdb) p t
$1 = (struct testing.T *) 0xf840688b60
(gdb) p *t
$2 = {errors = &amp;quot;&amp;quot;, failed = false, ch = 0xf8406f5690}
(gdb) p *t-&amp;gt;ch
$3 = struct hchan&amp;lt;*testing.T&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>که ساختار  &lt;code>hchan&amp;lt;*testing.T&amp;gt;&lt;/code> نمایش  runtime-internal یک کانال است و در حال حاضر خالی است، وگرنه gdb محتویات آن را به زیبایی چاپ می کرد.
حالا به قسمت مهم پیمایش دیباگر میرسیم که با حرف n صورت می‌گیرد.&lt;/p>
&lt;p>پیمایش دیباگر :&lt;/p>
&lt;pre>&lt;code class="language-shell">(gdb) n _# execute next line_
149 for _, test := range findTests {
(gdb) _# enter is repeat_
150 re := MustCompile(test.pat)
(gdb) p test.pat
$4 = &amp;quot;&amp;quot;
(gdb) p re
$5 = (struct regexp.Regexp *) 0xf84068d070
(gdb) p *re
$6 = {expr = &amp;quot;&amp;quot;, prog = 0xf840688b80, prefix = &amp;quot;&amp;quot;, prefixBytes = []uint8, prefixComplete = true,
prefixRune = 0, cond = 0 '\000', numSubexp = 0, longest = false, mu = {state = 0, sema = 0},
machine = []*regexp.machine}
(gdb) p *re-&amp;gt;prog
$7 = {Inst = []regexp/syntax.Inst = {{Op = 5 '\005', Out = 0, Arg = 0, Rune = []int}, {Op =
6 '\006', Out = 2, Arg = 0, Rune = []int}, {Op = 4 '\004', Out = 0, Arg = 0, Rune = []int}},
Start = 1, NumCap = 2}
&lt;/code>&lt;/pre>
&lt;p>می توانیم با حرف &amp;rsquo;s&amp;rsquo; وارد فراخوانی Stringfunction شویم:&lt;/p>
&lt;pre>&lt;code class="language-shell">(gdb) s
regexp.(*Regexp).String (re=0xf84068d070, noname=void) at /home/user/go/src/regexp/regexp.go:97
97 func (re *Regexp) String() string {
&lt;/code>&lt;/pre>
&lt;p>یک stack trace بگیرید تا ببینید کجا هستیم:&lt;/p>
&lt;pre>&lt;code class="language-shell">(gdb) bt
#0 regexp.(*Regexp).String (re=0xf84068d070, noname=void)
at /home/user/go/src/regexp/regexp.go:97
#1 0x0000000000425615 in regexp.TestFind (t=0xf840688b60)
at /home/user/go/src/regexp/find_test.go:151
#2 0x0000000000430233 in testing.tRunner (t=0xf840688b60, test=0x5747b8)
at /home/user/go/src/testing/testing.go:156
#3 0x000000000040ea6f in runtime.initdone () at /home/user/go/src/runtime/proc.c:243
....
&lt;/code>&lt;/pre>
&lt;p>به source code نگاه کنید:&lt;/p>
&lt;pre>&lt;code class="language-shell">(gdb) l
92 mu sync.Mutex
93 machine []*machine
94 }
95
96 // String returns the source text used to compile the regular expression.
97 func (re *Regexp) String() string {
98 return re.expr
99 }
100
101 // Compile parses a regular expression and returns, if successful,
&lt;/code>&lt;/pre>
&lt;p>Pretty Printing&lt;/p>
&lt;p>مکانیسم چاپ زیبا GDB توسط regexp matches به صورت زیر می‌باشد:&lt;/p>
&lt;pre>&lt;code class="language-shell">(gdb) p utf
$22 = []uint8 = {0 '\000', 0 '\000', 0 '\000', 0 '\000'}
&lt;/code>&lt;/pre>
&lt;p>از آنجایی که slice ها، آرایه ها و رشته ها اصلا اشاره‌گرهای C نیستند در نتیجه GDB نمی تواند عملیات subscripting را برای شما تفسیر کند، اما می توانید برای انجام این کار به نمایش runtime نگاه کنید (tab completion در اینجا کاربرد دارد):&lt;/p>
&lt;pre>&lt;code class="language-shell">(gdb) p slc
$11 = []int = {0, 0}
(gdb) p slc-&amp;gt;* _&amp;lt;TAB&amp;gt;_
array slc len
(gdb) p slc-&amp;gt;array
$12 = (int *) 0xf84057af00
(gdb) p slc-&amp;gt;array[1]
$13 = 0
&lt;/code>&lt;/pre>
&lt;p>توابع extension یا افزونه &lt;code>$len&lt;/code> و &lt;code>$cap&lt;/code> روی strings, arrays , slices کار می‌کنند:&lt;/p>
&lt;pre>&lt;code class="language-shell">(gdb) p $len(utf)
$23 = 4
(gdb) p $cap(utf)
$24 = 4
&lt;/code>&lt;/pre>
&lt;p>Channelها و mapها در واقع typeهایی از جنس «reference» هستند که gdb آن‌ها را به‌عنوان اشاره‌گر به C++ like types مانند &lt;code>&amp;lt;hash&amp;lt;int,string&amp;gt;*&lt;/code> نشان می‌دهد.
Interface ها در runtime به عنوان یک اشاره گر به یک توصیفگر(descriptor) و یک اشاره گر به یک مقدار نشان داده می شوند. پسوند Go GDB در runtime این را رمزگشایی می کند و به طور خودکار pretty printing را برای runtime type ایجاد می کند. تابع افزونه dtype$ درنهایت یک  dynamic type را برای شما رمزگشایی می‌کند (مثال‌هایی از یک breakpoint در خط 293 regexp.go گرفته شده‌اند.)&lt;/p>
&lt;pre>&lt;code class="language-shell">(gdb) p i
$4 = {str = &amp;quot;cbb&amp;quot;}
(gdb) whatis i
type = regexp.input
(gdb) p $dtype(i)
$26 = (struct regexp.inputBytes *) 0xf8400b4930
(gdb) iface i
regexp.input: struct regexp.inputBytes *
&lt;/code>&lt;/pre>
&lt;h2 id="425---معرفی-دیباگر--delve">
4.2.5 معرفی دیباگر DELVE
&lt;a class="anchor" href="#425---%d9%85%d8%b9%d8%b1%d9%81%db%8c-%d8%af%db%8c%d8%a8%d8%a7%da%af%d8%b1--delve">#&lt;/a>
&lt;/h2>
&lt;p>&lt;a href="https://github.com/go-delve/delve">delve&lt;/a> یک debugger برای زبان برنامه نویسی GO است. هدف این پروژه ارائه یک ابزار ساده و کامل debugger برای GO است. DeLve باید به راحتی استفاده می‌شود و استفاده از آن آسان بسیار آسان می‌باشد.&lt;/p>
&lt;h3 id="4251--راهنمای-نصب-delve">
4.2.5.1 راهنمای نصب DELVE
&lt;a class="anchor" href="#4251--%d8%b1%d8%a7%d9%87%d9%86%d9%85%d8%a7%db%8c-%d9%86%d8%b5%d8%a8-delve">#&lt;/a>
&lt;/h3>
&lt;p>دستورالعمل های زیر برای کار بر روی Linux، macOS، Windows و FreeBSD مورد استفاده قرار می‌گیرد.&lt;/p>
&lt;p>برای Clone و build دستورات زیر رو داریم&lt;/p>
&lt;pre>&lt;code class="language-shell"> git clone https://github.com/go-delve/delve
cd delve
go install github.com/go-delve/delve/cmd/dlv
&lt;/code>&lt;/pre>
&lt;p>برای Go version 1.16 و بالاتر هم داریم:&lt;/p>
&lt;pre>&lt;code class="language-shell"># Install the latest release:
$ go install github.com/go-delve/delve/cmd/dlv@latest
# Install at tree head:
$ go install github.com/go-delve/delve/cmd/dlv@master
# Install at a specific version or pseudo-version:
$ go install github.com/go-delve/delve/cmd/dlv@v1.7.3
$ go install github.com/go-delve/delve/cmd/dlv@v1.7.4-0.20211208103735-2f13672765fe
&lt;/code>&lt;/pre>
&lt;p>برای جزئیات در مورد محل ذخیره فایل اجرایی  &lt;code>dlv&lt;/code> به راهنمای نصب یا دستور &lt;code>go help install&lt;/code> مراجعه کنید.&lt;/p>
&lt;p>اگر در مرحله نصب با خطای مشابه زیر مواجه شدید:
2&lt;/p>
&lt;pre>&lt;code class="language-shell">found packages native (proc.go) and your_operating_system_and_architecture_combination_is_not_supported_by_delve (support_sentinel.go) in /home/pi/go/src/github.com/go-delve/delve/pkg/proc/native
&lt;/code>&lt;/pre>
&lt;p>یعنی از سیستم عامل یا معماری CPU شما پشتیبانی نمی شود، خروجی &lt;code>go version&lt;/code> را بررسی کنید.&lt;/p>
&lt;p>برای نصب در macOS از لینک &lt;a href="https://github.com/go-delve/delve/tree/master/Documentation/installation#macos-considerations">macOS&lt;/a> استفاده کنید.&lt;/p>
&lt;h3 id="4252-شروع-استفاده-از-delve">
4.2.5.2 شروع استفاده از DELVE
&lt;a class="anchor" href="#4252-%d8%b4%d8%b1%d9%88%d8%b9-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-delve">#&lt;/a>
&lt;/h3>
&lt;p>هدف Delve یک ابزار بسیار ساده و قدرتمند است، اما اگر به استفاده از source level debugger در یک زبان کامپایل شده عادت ندارید این ابزار می‌تواند گیج‌کننده باشد. البته این سند تمام اطلاعاتی را که برای شروع اشکال زدایی برنامه های Go خود نیاز دارید را ارائه می دهد.&lt;/p>
&lt;h3 id="4253-debugging-main-packages">
4.2.5.3 Debugging &amp;lsquo;main&amp;rsquo; packages
&lt;a class="anchor" href="#4253-debugging-main-packages">#&lt;/a>
&lt;/h3>
&lt;p>اولین CLI subcommand که بررسی خواهیم کرد کلیدواژه debug است. این subcommand را می توان بدون آرگومان اجرا کرد اگر شما در همان دایرکتوری &lt;code>main&lt;/code> package خود هستید، در غیر این صورت به صورت اختیاری یک package path را می پذیرد.&lt;/p>
&lt;p>به عنوان مثال با توجه به این  project layout داریم:&lt;/p>
&lt;pre>&lt;code class="language-shell">github.com/me/foo
├── cmd
│   └── foo
│   └── main.go
└── pkg
└── baz
├── bar.go
└── bar_test.go
&lt;/code>&lt;/pre>
&lt;p>اگر در دایرکتوری &lt;code>github.com/me/foo/cmd/foo&lt;/code> هستید، می توانید به سادگی &lt;code>dlv debug &lt;/code>را از command line اجرا کنید. از هر جای دیگری، مثلاً project root، می توانید به سادگی package را معرفی کنید، به عنوان مثال: &lt;code>dlv debug github.com/me/foo/cmd/foo &lt;/code> . برای ارسال flag‌ها به برنامه خود، آنها را به صورت زیر جدا سازی کنید:&lt;/p>
&lt;p>&lt;code>--&lt;/code>: &lt;code>dlv debug github.com/me/foo/cmd/foo -- -arg1 value&lt;/code>&lt;/p>
&lt;p>فراخوانی آن دستور باعث می شود که Delve برنامه را به روشی مناسب برای اشکال زدایی کامپایل کند و سپس برنامه اجرا شده و دیباگر به برنامه attach می شود و debug session را شروع می کند. حالا، هنگامی که جلسه  debug session برای اولین بار شروع شده است، شما در ابتدای شروع اولیه برنامه هستید. برای رسیدن به جایی که مورد نظر هست باید یک یا دو breakpoint تعیین کنید و اجرا را تا آن نقطه ادامه دهید.&lt;/p>
&lt;p>به عنوان مثال، برای ادامه اجرا به تابع  &lt;code>main&lt;/code> برنامه:&lt;/p>
&lt;pre>&lt;code class="language-shell">$ dlv debug github.com/me/foo/cmd/foo
Type 'help' for list of commands.
(dlv) break main.main
Breakpoint 1 set at 0x49ecf3 for main.main() ./test.go:5
(dlv) continue
&amp;gt; main.main() ./test.go:5 (hits goroutine(1):1 total:1) (PC: 0x49ecf3)
1: package main
2:
3: import &amp;quot;fmt&amp;quot;
4:
=&amp;gt; 5: func main() {
6: fmt.Println(&amp;quot;delve test&amp;quot;)
7: }
(dlv)
&lt;/code>&lt;/pre>
&lt;h3 id="4254-debugging-tests">
4.2.5.4 Debugging tests
&lt;a class="anchor" href="#4254-debugging-tests">#&lt;/a>
&lt;/h3>
&lt;p>با توجه به ساختار دایرکتوری مشابه با بالا، می توانید کد خود را با اجرای مجموعه آزمایشی خود اشکال زدایی کنید. برای این کار می توانید از subcommand یا دستور &lt;code> dlv test&lt;/code> استفاده کنید، که همان package path اختیاری را به عنوان  &lt;code>dlv debug&lt;/code> طی می کند و در صورت عدم ارائه آرگومان، package فعلی را نیز می سازد.&lt;/p>
&lt;pre>&lt;code class="language-shell">$ dlv test github.com/me/foo/pkg/baz
Type 'help' for list of commands.
(dlv) funcs test.Test*
/home/me/go/src/github.com/me/foo/pkg/baz/test.TestHi
(dlv) break TestHi
Breakpoint 1 set at 0x536513 for /home/me/go/src/github.com/me/foo/pkg/baz/test.TestHi() ./test_test.go:5
(dlv) continue
&amp;gt; /home/me/go/src/github.com/me/foo/pkg/baz/test.TestHi() ./bar_test.go:5 (hits goroutine(5):1 total:1) (PC: 0x536513)
1: package baz
2:
3: import &amp;quot;testing&amp;quot;
4:
=&amp;gt; 5: func TestHi(t *testing.T) {
6: t.Fatal(&amp;quot;implement me!&amp;quot;)
7: }
(dlv)
&lt;/code>&lt;/pre>
&lt;p>همانطور که می بینید، ما شروع به دیباگ کردن یک test binary کردیم، تابع تست خود را از طریق دستور  &lt;code>funcs&lt;/code> پیدا کردیم که یک regexp برای فیلتر کردن لیست توابع می گیرد، حالا یک breakpoint تعیین می کنیم و سپس اجرا را ادامه می دهیم تا زمانی که به آن breakpoint رسیدیم.&lt;/p>
&lt;p>برای اطلاعات بیشتر در مورد subcommands که می‌توانید استفاده کنید،  &lt;code>dlv help&lt;/code> را تایپ کنید، و یک بار در debug session می‌توانید با تایپ help در هر زمانی، تمام دستورات موجود را مشاهده کنید.&lt;/p>
&lt;h3 id="4255-synopsis-و-گزینه-های-command-line-options">
4.2.5.5 Synopsis و گزینه های Command line options
&lt;a class="anchor" href="#4255-synopsis-%d9%88-%da%af%d8%b2%db%8c%d9%86%d9%87-%d9%87%d8%a7%db%8c-command-line-options">#&lt;/a>
&lt;/h3>
&lt;p>Delve شما را قادر می سازد تا با کنترل اجرای فرآیند، ارزیابی متغیرها و ارائه اطلاعات state thread / goroutine، همینطور CPU register state و موارد دیگر، با برنامه خود تعامل داشته باشید.&lt;/p>
&lt;p>هدف این ابزار ارائه یک رابط ساده و در عین حال قدرتمند برای اشکال زدایی برنامه های Go است.
flagبرای استفاده از قابلیت های delve باید flagها را به برنامه‌ای که با استفاده از آن اشکال‌زدایی می‌کنید ارسال کنید، به کمک دستور  &lt;code>--&lt;/code>
برای مثال:&lt;/p>
&lt;p>&lt;code>dlv exec ./hello -- server --config conf/config.toml&lt;/code>&lt;/p>
&lt;p>در سایر گزینه ها داریم:&lt;/p>
&lt;pre>&lt;code class="language-shell">
--accept-multiclient Allows a headless server to accept multiple client connections via JSON-RPC or DAP.
--allow-non-terminal-interactive Allows interactive sessions of Delve that don't have a terminal as stdin, stdout and stderr
--api-version int Selects JSON-RPC API version when headless. New clients should use v2. Can be reset via RPCServer.SetApiVersion. See Documentation/api/json-rpc/README.md. (default 1)
--backend string Backend selection (see 'dlv help backend'). (default &amp;quot;default&amp;quot;)
--build-flags string Build flags, to be passed to the compiler. For example: --build-flags=&amp;quot;-tags=integration -mod=vendor -cover -v&amp;quot;
--check-go-version Exits if the version of Go in use is not compatible (too old or too new) with the version of Delve. (default true)
--disable-aslr Disables address space randomization
--headless Run debug server only, in headless mode. Server will accept both JSON-RPC or DAP client connections.
-h, --help help for dlv
--init string Init file, executed by the terminal client.
-l, --listen string Debugging server listen address. (default &amp;quot;127.0.0.1:0&amp;quot;)
--log Enable debugging server logging.
--log-dest string Writes logs to the specified file or file descriptor (see 'dlv help log').
--log-output string Comma separated list of components that should produce debug output (see 'dlv help log')
--only-same-user Only connections from the same user that started this instance of Delve are allowed to connect. (default true)
-r, --redirect stringArray Specifies redirect rules for target process (see 'dlv help redirect')
--wd string Working directory for running the program.
&lt;/code>&lt;/pre>
&lt;p>همینطور دستورات زیر را داریم:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://github.com/go-delve/delve/blob/master/Documentation/usage/dlv_attach.md">dlv attach&lt;/a> - Attach to running process and begin debugging.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/go-delve/delve/blob/master/Documentation/usage/dlv_connect.md">dlv connect&lt;/a> - Connect to a headless debug server with a terminal client.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/go-delve/delve/blob/master/Documentation/usage/dlv_core.md">dlv core&lt;/a> - Examine a core dump.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/go-delve/delve/blob/master/Documentation/usage/dlv_dap.md">dlv dap&lt;/a> - Starts a headless TCP server communicating via Debug Adaptor Protocol (DAP).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/go-delve/delve/blob/master/Documentation/usage/dlv_debug.md">dlv debug&lt;/a> - Compile and begin debugging main package in current directory, or the package specified.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/go-delve/delve/blob/master/Documentation/usage/dlv_exec.md">dlv exec&lt;/a> - Execute a precompiled binary, and begin a debug session.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/go-delve/delve/blob/master/Documentation/usage/dlv_replay.md">dlv replay&lt;/a> - Replays a rr trace.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/go-delve/delve/blob/master/Documentation/usage/dlv_run.md">dlv run&lt;/a> - Deprecated command. Use &amp;lsquo;debug&amp;rsquo; instead.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/go-delve/delve/blob/master/Documentation/usage/dlv_test.md">dlv test&lt;/a> - Compile test binary and begin debugging program.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/go-delve/delve/blob/master/Documentation/usage/dlv_trace.md">dlv trace&lt;/a> - Compile and begin tracing program.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/go-delve/delve/blob/master/Documentation/usage/dlv_version.md">dlv version&lt;/a> - Prints version.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/go-delve/delve/blob/master/Documentation/usage/dlv_log.md">dlv log&lt;/a> - Help about logging flags&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/go-delve/delve/blob/master/Documentation/usage/dlv_backend.md">dlv backend&lt;/a> - Help about the &lt;code>--backend&lt;/code> flag&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><author/><title>4.3 آموزش کار با go mod</title><link>https://book.gofarsi.ir/chapter-4/go-mod/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/go-mod/</guid><description>&lt;p>از نسخه 1.11 زبان گو مفهوم جدیدی برای مدیریت &lt;span class="tooltip" data-tooltip="dependencies" ontouchend="toggleTooltip(this)">وابستگی ها&lt;/span>
آمد و جایگزین GOPATH شد. ماژول های گو این امکان را می دهد خیلی راحت ماژول های مختلف را به پروژه اضافه کنید و نسخه های هر ماژول را مدیریت کنید. با استفاده از ماژول گو برنامه نویسان گو محدود به GOPATH برای توسعه نخواهد بود و در جایی می توانند پروژه خود را ایجاد و ماژول های پروژه را به آسانی مدیریت کند.&lt;/p>
&lt;p>در زیر یک نمونه از محتوای داخل فایل go.mod را قرار دادیم :&lt;/p>
&lt;pre>&lt;code class="language-go">module github.com/user/repo
go 1.20
require (
github.com/sirupsen/logrus v1.8.1
github.com/spf13/cobra v1.2.1
)
&lt;/code>&lt;/pre>
&lt;ol>
&lt;li>در خط اول نام ماژول می باشد که داخل کد هرجایی که import انجام می دهید نام ماژول اولش قرار می گیرد مانند :&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-go">package cmd
import &amp;quot;github.com/user/repo/internal/app&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>علت اینکه نام ماژول را آدرس یک مخزن گیت را قرار می دهیم جهت قابل استفاده بودن ماژول می باشد که خیلی ساده بتوانید به پروژه های دیگر ماژولی که نوشتید را اضافه کنید.&lt;/p>
&lt;ol start="2">
&lt;li>در خط سوم نسخه زبان گو وجود دارد که شما هر نسخه ای را که تعیین میکنید فقط از ویژگی های همان نسخه به قبل را می توانید استفاده کنید.&lt;/li>
&lt;/ol>
&lt;p>مثلا شما اگر نسخه 1.17 را گذاشته باشید و قصد داشته باشید از ویژگی جنریک که مربوط به نسخه 1.18 است استفاده کنید, هنگام کامپایل خطا می خورید.&lt;/p>
&lt;p>پس توجه کنید در اینجا سعی کنید از نسخه متناسب با نیاز خود را تعیین کنید هرچند هنگام ایجاد فایل go.mod زبان گو پیش فرض نسخه ای که نصب کرده اید را قرار می دهد.&lt;/p>
&lt;ol start="3">
&lt;li>در قسمت require ماژول های خارجی قرار میگیرد که داخل پروژه استفاده کردید. نظیر :&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>github.com/sirupsen/logrus&lt;/li>
&lt;li>github.com/spf13/cobra&lt;/li>
&lt;/ul>
&lt;p>به همراه نسخه مشخص اون ماژول.&lt;/p>
&lt;p>اما ماژول گو یک خوبی دارد خیلی راحت می توانید نسخه ماژول ها را به آسانی مدیریت کنید و ارتقا دهید.&lt;/p>
&lt;p>برای مدیریت ماژول های گو یک کامند داریم به نام mod که یک سری دستورات کمکی برای مدیریت ماژول ها دارد که در ادامه آموزش می دهیم :&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go mod
Go mod provides access to operations on modules.
Note that support for modules is built into all the go commands,
not just 'go mod'. For example, day-to-day adding, removing, upgrading,
and downgrading of dependencies should be done using 'go get'.
See 'go help modules' for an overview of module functionality.
Usage:
go mod &amp;lt;command&amp;gt; [arguments]
The commands are:
download download modules to local cache
edit edit go.mod from tools or scripts
graph print module requirement graph
init initialize new module in current directory
tidy add missing and remove unused modules
vendor make vendored copy of dependencies
verify verify dependencies have expected content
why explain why packages or modules are needed
Use &amp;quot;go help mod &amp;lt;command&amp;gt;&amp;quot; for more information about a command.
&lt;/code>&lt;/pre>
&lt;p>برای اینکه اطلاعات بیشتری در خصوص کامند های go mod کسب کنید کافیه go help mod را قبل از کامند بزارید تا توضیحات بیشتری را ببینید.&lt;/p>
&lt;h2 id="431-ایجاد-gomod">
4.3.1 ایجاد go.mod
&lt;a class="anchor" href="#431-%d8%a7%db%8c%d8%ac%d8%a7%d8%af-gomod">#&lt;/a>
&lt;/h2>
&lt;p>برای ایجاد فایل go.mod کافیه دستور زیر را در ریشه پروژه بزنید :&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go mod init github.com/user/repo
&lt;/code>&lt;/pre>
&lt;p>پس از اینکه دستور فوق را زدید یک فایل go.mod ایجاد می شود داخلش محتوای زیر بدون ماژول خارجی می باشد :&lt;/p>
&lt;pre>&lt;code class="language-go">module github.com/user/repo
go 1.20
&lt;/code>&lt;/pre>
&lt;h2 id="432-افزودن-ماژول-خارجی-به-gomod">
4.3.2 افزودن ماژول خارجی به go.mod
&lt;a class="anchor" href="#432-%d8%a7%d9%81%d8%b2%d9%88%d8%af%d9%86-%d9%85%d8%a7%da%98%d9%88%d9%84-%d8%ae%d8%a7%d8%b1%d8%ac%db%8c-%d8%a8%d9%87-gomod">#&lt;/a>
&lt;/h2>
&lt;p>برای افزودن یک ماژول خارجی به پروژه کافیه دستور زیر را در محل فایل go.mod بزنید :&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go get github.com/spf13/cobra
&lt;/code>&lt;/pre>
&lt;p>زمانیکه دستور فوق را می زنید آخرین نسخه ماژول github.com/spf13/cobra را دریافت و به پروژه اضافه می کند.&lt;/p>
&lt;blockquote class="book-hint info">
دقت کنید وقتی ماژول جدیدی را دریافت می کنید یک فایل go.sum در کنار فایل go.mod ایجاد می شود که داخل این فایل اطلاعات ماژول های خارجی به همراه ساب ماژول ها قرار دارد. که برای اطمینان از یکپارچگی و امنیت وابستگی های مورد استفاده در پروژه Go طراحی شده است. این فایل بصورت خودکار ایجاد و بروز می شود پس بهتر است تغییری در این فایل ندهید.
&lt;/blockquote>
&lt;h2 id="433-افزودن-ماژول-خارجی-با-تعیین-نسخه">
4.3.3 افزودن ماژول خارجی با تعیین نسخه
&lt;a class="anchor" href="#433-%d8%a7%d9%81%d8%b2%d9%88%d8%af%d9%86-%d9%85%d8%a7%da%98%d9%88%d9%84-%d8%ae%d8%a7%d8%b1%d8%ac%db%8c-%d8%a8%d8%a7-%d8%aa%d8%b9%db%8c%db%8c%d9%86-%d9%86%d8%b3%d8%ae%d9%87">#&lt;/a>
&lt;/h2>
&lt;p>با دستور زیر می توانید یک ماژول خارجی با تعیین نسخه به پروژه خود اضافه کنید :&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go get github.com/spf13/cobra@v1.8.1
&lt;/code>&lt;/pre>
&lt;p>زمانیکه دستور فوق را می زنید نسخه v1.8.1 ماژول github.com/spf13/cobra را دریافت خواهید کرد.&lt;/p>
&lt;h2 id="434-آپدیت-یک-ماژول-خارجی-به-آخرین-نسخه">
4.3.4 آپدیت یک ماژول خارجی به آخرین نسخه
&lt;a class="anchor" href="#434-%d8%a2%d9%be%d8%af%db%8c%d8%aa-%db%8c%da%a9-%d9%85%d8%a7%da%98%d9%88%d9%84-%d8%ae%d8%a7%d8%b1%d8%ac%db%8c-%d8%a8%d9%87-%d8%a2%d8%ae%d8%b1%db%8c%d9%86-%d9%86%d8%b3%d8%ae%d9%87">#&lt;/a>
&lt;/h2>
&lt;p>برای آپدیت یک ماژول خارجی به آخرین نسخه کافیه دستور زیر را بزنید :&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go get -u github.com/spf13/cobra
&lt;/code>&lt;/pre>
&lt;p>در دستور فوق ما سوییچ &lt;code>u-&lt;/code> را اضافه کردیم تا آخرین نسخه ماژول github.com/spf13/cobra به پروژه اضافه و جایگزین نسخه های قدیمی شود.&lt;/p>
&lt;h2 id="435-دستور-go-mod-tidy">
4.3.5 دستور go mod tidy
&lt;a class="anchor" href="#435-%d8%af%d8%b3%d8%aa%d9%88%d8%b1-go-mod-tidy">#&lt;/a>
&lt;/h2>
&lt;p>یک کامند پر کاربرد به نام tidy داریم که هر زمانی که اجرا می کنید کدهایی که در محل فایل go.mod قرار دارد بررسی می کند و ماژول های ایمپورت شده را به پروژه اضافه می کند و در صورتیکه شما ماژولی را حذف کردید و به هیچ عنوان در پروژه خود استفاده نکردید را از go.mod حذف می کند.&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go mod tidy
&lt;/code>&lt;/pre>
&lt;p>اگر ماژول خارجی را استفاده کرده باشید در کدهای خود و هنوز به فایل go.mod اضافه نکرده باشید کامند tidy بصورت خودکار آخرین نسخه ماژول خارجی را دریافت و به فایل go.mod اضافه میکند.&lt;/p>
&lt;h2 id="436-دستور-go-mod-download">
4.3.6 دستور go mod download
&lt;a class="anchor" href="#436-%d8%af%d8%b3%d8%aa%d9%88%d8%b1-go-mod-download">#&lt;/a>
&lt;/h2>
&lt;p>با استفاده از این کامند می توانید ماژول های خارجی داخل فایل go.mod را دریافت کرده و در لوکال خود کش کنید. تا بعدا از آن ماژول استفاده کنید.&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go mod download
&lt;/code>&lt;/pre>
&lt;p>زمانیکه این دستور را بزنید شروع به دانلود ماژول های خارجی می شود و در لوکال شما این ماژول ها ذخیره می شود.&lt;/p>
&lt;blockquote class="book-hint info">
&lt;p>برای اینکه بتوانید ببینید وضعیت دانلود تا چه پیشرفته است می توانید سوییچ &lt;code>x-&lt;/code> را اضافه کنید تا به شما وضعیت ماژول های در حال دریافت را نمایش دهد :&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go mod download -x
&lt;/code>&lt;/pre>
&lt;/blockquote>
&lt;h2 id="437-دستور-go-mod-verify">
4.3.7 دستور go mod verify
&lt;a class="anchor" href="#437-%d8%af%d8%b3%d8%aa%d9%88%d8%b1-go-mod-verify">#&lt;/a>
&lt;/h2>
&lt;p>با این دستور شما می توانید وضعیت ماژول ها را بررسی کنید که مورد تایید هست یا نه.&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go mod verify
&lt;/code>&lt;/pre></description></item><item><author/><title>4.4 آموزش کار با workspace</title><link>https://book.gofarsi.ir/chapter-4/workspace/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/workspace/</guid><description>&lt;p>با استفاده از workspace می توانید همزمان چندین ماژول در یک محل داشته باشید و هر ماژول را به راحتی مدیریت کنید و همچنین همزمان به آسانی این ماژول ها را build و اجرا کنید.&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go help work
Work provides access to operations on workspaces.
Note that support for workspaces is built into many other commands, not
just 'go work'.
See 'go help modules' for information about Go's module system of which
workspaces are a part.
See https://go.dev/ref/mod#workspaces for an in-depth reference on
workspaces.
See https://go.dev/doc/tutorial/workspaces for an introductory
tutorial on workspaces.
A workspace is specified by a go.work file that specifies a set of
module directories with the &amp;quot;use&amp;quot; directive. These modules are used as
root modules by the go command for builds and related operations. A
workspace that does not specify modules to be used cannot be used to do
builds from local modules.
go.work files are line-oriented. Each line holds a single directive,
made up of a keyword followed by arguments. For example:
go 1.18
use ../foo/bar
use ./baz
replace example.com/foo v1.2.3 =&amp;gt; example.com/bar v1.4.5
The leading keyword can be factored out of adjacent lines to create a block,
like in Go imports.
use (
../foo/bar
./baz
)
The use directive specifies a module to be included in the workspace's
set of main modules. The argument to the use directive is the directory
containing the module's go.mod file.
The go directive specifies the version of Go the file was written at. It
is possible there may be future changes in the semantics of workspaces
that could be controlled by this version, but for now the version
specified has no effect.
The replace directive has the same syntax as the replace directive in a
go.mod file and takes precedence over replaces in go.mod files. It is
primarily intended to override conflicting replaces in different workspace
modules.
To determine whether the go command is operating in workspace mode, use
the &amp;quot;go env GOWORK&amp;quot; command. This will specify the workspace file being
used.
Usage:
go work &amp;lt;command&amp;gt; [arguments]
The commands are:
edit edit go.work from tools or scripts
init initialize workspace file
sync sync workspace build list to modules
use add modules to workspace file
Use &amp;quot;go help work &amp;lt;command&amp;gt;&amp;quot; for more information about a command.
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>پیش نیاز ها&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>برای استفاده از workspace حتما باید از نسخه 1.18 گو استفاده کنید.&lt;/li>
&lt;li>یک ابزار ادیت برای کار باید داشته باشید&lt;/li>
&lt;li>یک ترمینال مناسب جهت اجرا دستورات&lt;/li>
&lt;/ul>
&lt;h2 id="441-ایجاد-workspace">
4.4.1 ایجاد workspace
&lt;a class="anchor" href="#441-%d8%a7%db%8c%d8%ac%d8%a7%d8%af-workspace">#&lt;/a>
&lt;/h2>
&lt;p>برای ایجاد یک workspace کافیه دستور زیر را بزنید تا در محل پروژه یک فایل go.work ایجاد شود.&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go work init
&lt;/code>&lt;/pre>
&lt;h2 id="442-افزودن-ماژول-به-workspace">
4.4.2 افزودن ماژول به workspace
&lt;a class="anchor" href="#442-%d8%a7%d9%81%d8%b2%d9%88%d8%af%d9%86-%d9%85%d8%a7%da%98%d9%88%d9%84-%d8%a8%d9%87-workspace">#&lt;/a>
&lt;/h2>
&lt;p>در محل workspace یک پوشه ایجاد کنید و دستور go mod init را بزنید تا ماژول ایجاد شود و داخل این محل کدهای ماژول خود را قرار دهید. سپس با دستور go work use می توانید ماژول خود را به workspace اضافه کنید.&lt;/p>
&lt;pre>&lt;code class="language-shell">go work use ./module1
&lt;/code>&lt;/pre>
&lt;p>زمانیکه دستور فوق را بزنید پوشه module1 که داخلش ماژول از قبل ایجاد شده به فایل go.work اضافه می شود.&lt;/p>
&lt;p>حال اگر دستور زیر را بزنید می توانید آن ماژول را اگر پکیج main داشته باشد را می تواند اجرا کند :&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go run ./module1
&lt;/code>&lt;/pre></description></item><item><author/><title>4.5 آموزش کار با Vendor</title><link>https://book.gofarsi.ir/chapter-4/vendor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/vendor/</guid><description>&lt;p>در زبان گو یک کامند کاربردی در go mod به نام vendor داریم که ماژول هایی که داخل پروژه استفاده شده و مورد نیاز برای اجرا و بیلد می باشد را در محل پروژه کش می کند و به شما این امکان را می دهد خیلی سریع و راحت بدون نیاز به دانلود مجدد ماژول پروژه را بیلد و اجرا کنید.&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go help mod vendor
usage: go mod vendor [-e] [-v] [-o outdir]
Vendor resets the main module's vendor directory to include all packages
needed to build and test all the main module's packages.
It does not include test code for vendored packages.
The -v flag causes vendor to print the names of vendored
modules and packages to standard error.
The -e flag causes vendor to attempt to proceed despite errors
encountered while loading packages.
The -o flag causes vendor to create the vendor directory at the given
path instead of &amp;quot;vendor&amp;quot;. The go command can only use a vendor directory
named &amp;quot;vendor&amp;quot; within the module root directory, so this flag is
primarily useful for other tools.
See https://golang.org/ref/mod#go-mod-vendor for more about 'go mod vendor'.
&lt;/code>&lt;/pre>
&lt;h2 id="451-ایجاد-vendor">
4.5.1 ایجاد vendor
&lt;a class="anchor" href="#451-%d8%a7%db%8c%d8%ac%d8%a7%d8%af-vendor">#&lt;/a>
&lt;/h2>
&lt;p>با دستور زیر می توانید در محل پروژه خود پوشه vendor ایجاد کنید و ماژول های استفاده شده را داخل این پوشه کش کنید.&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go mod vendor
&lt;/code>&lt;/pre>
&lt;h2 id="452-افزودن-ماژول-های-جدید-به-vendor">
4.5.2 افزودن ماژول های جدید به vendor
&lt;a class="anchor" href="#452-%d8%a7%d9%81%d8%b2%d9%88%d8%af%d9%86-%d9%85%d8%a7%da%98%d9%88%d9%84-%d9%87%d8%a7%db%8c-%d8%ac%d8%af%db%8c%d8%af-%d8%a8%d9%87-vendor">#&lt;/a>
&lt;/h2>
&lt;p>در صورتیکه ماژول جدیدی را به پروژه اضافه کردید حتما باید بصورت دستی vendor را بروز کنید و کافیه دستور زیر را بزنید :&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go mod vendor
&lt;/code>&lt;/pre>
&lt;h2 id="453-اجرا-و-بیلد-پروژه-با-vendor">
4.5.3 اجرا و بیلد پروژه با vendor
&lt;a class="anchor" href="#453-%d8%a7%d8%ac%d8%b1%d8%a7-%d9%88-%d8%a8%db%8c%d9%84%d8%af-%d9%be%d8%b1%d9%88%da%98%d9%87-%d8%a8%d8%a7-vendor">#&lt;/a>
&lt;/h2>
&lt;p>شما می توانید پروژه خود را با ماژول های کش شده داخل vendor اجرا و بیلد کنید و دیگر نیازی به دریافت ماژول ها و کش کردن محلی نمی باشد.&lt;/p>
&lt;p>&lt;strong>نحوه بیلد&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go build -mod vendor -o main cmd/main.go
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>نحوه اجرا&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go run -mod vendor main.go
&lt;/code>&lt;/pre>
&lt;h2 id="454-نکات-کاربردی">
4.5.4 نکات کاربردی
&lt;a class="anchor" href="#454-%d9%86%da%a9%d8%a7%d8%aa-%da%a9%d8%a7%d8%b1%d8%a8%d8%b1%d8%af%db%8c">#&lt;/a>
&lt;/h2>
&lt;p>یکسری نکات در خصوص استفاده از vendor قرار دادم که به شما می کند تا از vendor به درستی استفاده کنید.&lt;/p>
&lt;ol>
&lt;li>از vendor فقط برای پروژه ای استفاده کنید که می خواهد در محیط های مختلف اجرا شود.&lt;/li>
&lt;li>استفاده از vendor باعث افزایش سریع روند CI/CD هنگام بیلد و تست می شود.&lt;/li>
&lt;li>زمانیکه vendor ایجاد می کنید فایل بخش های استفاده شده هر ماژول خارجی قرار میگیرد و باعث می شود حجم vendor خیلی کم باشد (پس نگران اینکه vendor مانند npm_module است نباشید)&lt;/li>
&lt;li>استفاده vendor به IDE گولند کمک می کند در زمان باز کردن پروژه با سرعت بیشتری ماژول ها را index کرده و کدها را سریعتر اسکن کند&lt;/li>
&lt;/ol></description></item><item><author/><title>4.6 آموزش نوشتن برنامه command line</title><link>https://book.gofarsi.ir/chapter-4/command-line-go/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/command-line-go/</guid><description>&lt;h2 id="461-مقدمه">
4.6.1 مقدمه
&lt;a class="anchor" href="#461-%d9%85%d9%82%d8%af%d9%85%d9%87">#&lt;/a>
&lt;/h2>
&lt;p>هنگامی که می‌خواهید نرم‌افزاری بنویسید، ممکن است بخواهید از محیط Command Line یا خط فرمان استفاده کنید. خط فرمان، رابط کاربری ساده‌تری نسبت به محیط گرافیکی دارد و در برخی موارد، سرعت بخش بسیار قابل توجهی است. برای آموزش نوشتن برنامه در خط فرمان، شما به یک زبان برنامه‌نویسی نیاز دارید که از بسیاری از کانسپت‌هایی که در برنامه‌نویسی استفاده می‌شوند، پشتیبانی کند. ما به شما پیشنهاد می‌دهیم که از زبان برنامه‌نویسی Go استفاده کنید زیرا برای کار با Command Line بسیار مناسب است.&lt;/p>
&lt;p>آموزش نوشتن برنامه Command Line به کمک زبان برنامه‌نویسی گو:&lt;/p>
&lt;p>در اینجا، ما یک مثال ساده از برنامه Hello World با استفاده از Go و Command Line ارائه می‌دهیم. این برنامه، یک پیام ساده را به صفحه نمایش خط فرمان چاپ می‌کند.&lt;/p>
&lt;p>اولین چیزی که شما باید در نظر داشته باشید این است که برنامه‌ی شما باید یک فایل با پسوند .go باشد. برای مثال، می‌توانید یک فایل با نام helloworld.go ایجاد کنید.&lt;/p>
&lt;p>بعد از ایجاد فایل، شما باید کد زیر را به فایل خود اضافه کنید:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
fmt.Println("Hello, World!")
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>اگر کد بالا را به فایل helloworld.go اضافه کردید، می‌توانید با استفاده از Command Line، فایل را اجرا کنید. برای اجرای فایل، ابتدا باید به دایرکتوری فایل برید. سپس می‌توانید دستور برای اجرای فایل را وارد کنید.&lt;/p>
&lt;p>برای مثال، فرض کنید فایل helloworld.go در دایرکتوری Documents قرار دارد. به عنوان نوشته، این دستورات را در Command Line وارد کنید:&lt;/p>
&lt;p>$ cd Documents
$ go run helloworld.go&lt;/p>
&lt;p>با اجرای دستور بالا، برنامه شما اجرا خواهد شد و پیام &amp;ldquo;Hello, World!&amp;rdquo; را در Command Line چاپ می‌کند.&lt;/p>
&lt;p>نتیجه‌گیری:&lt;/p>
&lt;p>استفاده از خط فرمان برای نوشتن برنامه‌های شما می‌تواند بسیار مفید باشد، اگر یادگیری زبان برنامه‌نویسی Go و چگونگی کار با Command Line را یاد بگیرید. در این مقاله، به شما یک مثال ساده از نوشتن برنامه Command Line با استفاده از Go برای شروع ارائه شد. با ادامه‌ی یادگیری زبان برنامه نویسی Go، شما می‌توانید برنامه‌های پیچیده‌تر را با استفاده از Command Line بسازید.&lt;/p>
&lt;h2 id="462-نحوه-گرفتن-arguments-به-عنوان-ورودی-از-ترمینال">
4.6.2 نحوه گرفتن arguments به عنوان ورودی از ترمینال
&lt;a class="anchor" href="#462-%d9%86%d8%ad%d9%88%d9%87-%da%af%d8%b1%d9%81%d8%aa%d9%86-arguments-%d8%a8%d9%87-%d8%b9%d9%86%d9%88%d8%a7%d9%86-%d9%88%d8%b1%d9%88%d8%af%db%8c-%d8%a7%d8%b2-%d8%aa%d8%b1%d9%85%db%8c%d9%86%d8%a7%d9%84">#&lt;/a>
&lt;/h2>
&lt;p>برای گرفتن ورودی از Command Line به عنوان Argument در یک برنامه Go، شما می‌توانید از پایگاه‌داده os در Go استفاده کنید. برای دسترسی به Argumentها، شما می‌توانید متغیرهای os.Args را استفاده کنید. آرایه‌ی os.Args شامل تمامی Argumentهایی است که در Command Line به برنامه شما داده شده است. در زیر، یک مثال ساده از گرفتن دو Argument از Command Line در یک برنامه Go آورده شده است:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"fmt"
"os"
)
func main() {
args := os.Args
fmt.Println("First Argument:", args[1])
fmt.Println("Second Argument:", args[2])
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در کد بالا، ابتدا، ما متغیر os.Args را به متغیر args اختصاص داده‌ایم. سپس، با استفاده از این متغیر، ما مقادیر دو Argument اول را چاپ کرده‌ایم. در اینجا، args[0] نام برنامه Go در Command Line است، بنابراین اولین Argument بعد از آن در args[1] و دومین Argument در args[2] قرار دارد. با تغییر این شماره‌ها، شما می‌توانید به Argument‌های دیگر در Command Line دسترسی داشته باشید.&lt;/p>
&lt;h2 id="463-کار-با-flag-در-زبان-گو">
4.6.3 کار با flag در زبان گو
&lt;a class="anchor" href="#463-%da%a9%d8%a7%d8%b1-%d8%a8%d8%a7-flag-%d8%af%d8%b1-%d8%b2%d8%a8%d8%a7%d9%86-%da%af%d9%88">#&lt;/a>
&lt;/h2>
&lt;p>در زبان Go، شما می‌توانید از پکیج flag برای ایجاد و مدیریت Flagها در Command Line استفاده کنید. با استفاده از قابلیت Flag، شما می‌توانید به آرگومان های اختیاری و پارامترهای Command Line برنامه خود دسترسی پیدا کنید.&lt;/p>
&lt;p>در پکیج flag، سه نوع Flag مختلف وجود دارند: string، bool و int. برای ایجاد یک Flag از هر نوع، می‌توانید از توابع flag.String، flag.Bool و flag.Int استفاده کنید.&lt;/p>
&lt;p>در مثال زیر، ما به کمک Flag یک رشته، یک boolean و یک integer را تعریف و مقداردهی اولیه آن‌ها را انجام می‌دهیم:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"flag"
"fmt"
)
func main() {
// تعریف یک Flag رشته برای نام کاربری
userName := flag.String("username", "", "نام کاربری")
// تعریف یک Flag boolean برای پرینت نتیجه
printResult := flag.Bool("print", false, "پرینت نتیجه؟")
// تعریف یک Flag integer برای تعداد تکرار
repeatCount := flag.Int("count", 1, "تعداد تکرار")
flag.Parse()
// استفاده از Flag ها
fmt.Println("نام کاربری:", *userName)
fmt.Println("پرینت نتیجه؟", *printResult)
fmt.Println("تعداد تکرار:", *repeatCount)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در مثال بالا، ما سه Flag ایجاد کرده‌ایم: username، print و count که به ترتیب متناظر با یک رشته، یک boolean و یک integer هستند. پارامتر اول تابع هر Flag نام آن است، پارامتر دوم مقدار پیش‌فرض و پارامتر سوم توضیحاتی در مورد Flag است.&lt;/p>
&lt;p>در انتهای برنامه، با استفاده از تابع flag.Parse()، مقدار داده‌شده به Flagها از Command Line دریافت و مقداردهی به متغیرهای var استفاده شده در Flagها انجام می‌گیرد. در مثال بالا، ما با استفاده از اپراتور * به مقدار داده‌شده به هر Flag دریافت شده از Command Line دسترسی پیدا می‌کنیم.&lt;/p>
&lt;p>با اجرای برنامه و وارد کردن یک Command Line مخصوص مثل زیر، می‌توانید مقدارهای مختلفی به Flagهای برنامه خود اختصاص دهید.&lt;/p>
&lt;p>در این مثال، مقدار Flag username برابر با &amp;ldquo;John&amp;rdquo;، print برابر با true و count برابر با ۵ می‌باشد.&lt;/p></description></item><item><author/><title>4.7 آموزش کار با فایل</title><link>https://book.gofarsi.ir/chapter-4/work-with-file-in-go/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/work-with-file-in-go/</guid><description>&lt;h2 id="471-مقدمه">
4.7.1 مقدمه
&lt;a class="anchor" href="#471-%d9%85%d9%82%d8%af%d9%85%d9%87">#&lt;/a>
&lt;/h2>
&lt;p>توسعه دهندگان Go می‌توانند از پکیج‌های built-in مانند &amp;ldquo;os&amp;rdquo; و &amp;ldquo;io&amp;rdquo; برای کار با فایل‌ها استفاده کنند. همچنین، پکیج‌های دیگری نیز برای کار با فایل وجود دارند که می‌توان به عنوان پکیج استاندارد نامید. نمونه ای از این پکیج‌ها، پکیج &amp;ldquo;bufio&amp;rdquo; است که برای کار با بافرهای ورودی/خروجی استفاده شده و به توسعه دهندگان اجازه می‌دهد تا برنامه‌هایی با عملکرد بهتر و با کارایی بالاتر ایجاد کنند.&lt;/p>
&lt;h2 id="472-باز-کردن-فایل-و-خواندن-محتوای-فایل-با-پکیج-os">
4.7.2 باز کردن فایل و خواندن محتوای فایل با پکیج os
&lt;a class="anchor" href="#472-%d8%a8%d8%a7%d8%b2-%da%a9%d8%b1%d8%af%d9%86-%d9%81%d8%a7%db%8c%d9%84-%d9%88-%d8%ae%d9%88%d8%a7%d9%86%d8%af%d9%86-%d9%85%d8%ad%d8%aa%d9%88%d8%a7%db%8c-%d9%81%d8%a7%db%8c%d9%84-%d8%a8%d8%a7-%d9%be%da%a9%db%8c%d8%ac-os">#&lt;/a>
&lt;/h2>
&lt;p>برای باز کردن یک فایل متنی و خواندن محتوای آن، می‌توانیم از پکیج &amp;ldquo;os&amp;rdquo; و متد &amp;ldquo;Open&amp;rdquo; استفاده کنیم. در کد زیر، ما یک فایل به نام &amp;ldquo;example.txt&amp;rdquo; باز می‌کنیم و محتوای آن را به صورت خط به خط خوانده و به صفحه کنسول چاپ می‌کنیم:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"bufio"
"fmt"
"log"
"os"
)
func main() {
// باز کردن فایل برای خواندن
file, err := os.Open("example.txt")
if err != nil {
log.Fatal(err)
}
defer file.Close()
// خواندن خط به خط از فایل
scanner := bufio.NewScanner(file)
for scanner.Scan() {
fmt.Println(scanner.Text())
}
if err := scanner.Err(); err != nil {
log.Fatal(err)
}
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در کد بالا، با استفاده از متد &amp;ldquo;os.Open&amp;rdquo;، فایل &amp;ldquo;example.txt&amp;rdquo; برای خواندن به صورت فایل شیء باز می‌شود. سپس، با استفاده از متد &amp;ldquo;bufio.NewScanner&amp;rdquo; محتوای فایل به شیء &amp;ldquo;scanner&amp;rdquo; انتقال داده می‌شود و در نهایت با استفاده از حلقه، محتوای فایل خوانده شده خط به خط و به صورت متنی چاپ می‌شود.&lt;/p>
&lt;p>در نهایت، با استفاده از &amp;ldquo;scanner.Err&amp;rdquo;، خطاهایی که در پروسه خواندن ممکن است بوجود آیند، بررسی شده و مورد احتیاط قرار می‌گیرند.&lt;/p>
&lt;h2 id="473-نحوه-ایجاد-فایل-و-نوشتن-محتوا-داخل-فایل-با-os">
4.7.3 نحوه ایجاد فایل و نوشتن محتوا داخل فایل با os
&lt;a class="anchor" href="#473-%d9%86%d8%ad%d9%88%d9%87-%d8%a7%db%8c%d8%ac%d8%a7%d8%af-%d9%81%d8%a7%db%8c%d9%84-%d9%88-%d9%86%d9%88%d8%b4%d8%aa%d9%86-%d9%85%d8%ad%d8%aa%d9%88%d8%a7-%d8%af%d8%a7%d8%ae%d9%84-%d9%81%d8%a7%db%8c%d9%84-%d8%a8%d8%a7-os">#&lt;/a>
&lt;/h2>
&lt;p>برای ایجاد یک فایل جدید و نوشتن محتوای دلخواه در آن، می‌توانیم از پکیج &amp;ldquo;os&amp;rdquo; و متدهای آن استفاده کنیم. در کد زیر، یک فایل با نام &amp;ldquo;example.txt&amp;rdquo; ساخته شده و پس از باز شدن، متن &amp;ldquo;Hello, World!&amp;rdquo; در داخل آن نوشته می‌شود:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"fmt"
"os"
)
func main() {
// ساخت فایل با نام example.txt
file, err := os.Create("example.txt")
if err != nil {
fmt.Println(err)
return
}
defer file.Close()
// نوشتن محتوا در فایل
fmt.Fprintln(file, "Hello, World!")
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در کد بالا، با استفاده از متد &amp;ldquo;os.Create&amp;rdquo;، یک فایل با نام &amp;ldquo;example.txt&amp;rdquo; ایجاد شده و به عنوان یک فایل شیء باز شده است. سپس با استفاده از متد &amp;ldquo;fmt.Fprintln&amp;rdquo;، متن &amp;ldquo;Hello, World!&amp;rdquo; در داخل فایل نوشته می‌شود.&lt;/p>
&lt;p>در نهایت، با استفاده از &amp;ldquo;file.Close&amp;rdquo;، فایل بسته شده و تمام تغییرات آن ذخیره می‌شود.&lt;/p>
&lt;h2 id="474-خواندن-و-نوشتن-فایل-با-استفاده-از-پکیج-io">
4.7.4 خواندن و نوشتن فایل با استفاده از پکیج io
&lt;a class="anchor" href="#474-%d8%ae%d9%88%d8%a7%d9%86%d8%af%d9%86-%d9%88-%d9%86%d9%88%d8%b4%d8%aa%d9%86-%d9%81%d8%a7%db%8c%d9%84-%d8%a8%d8%a7-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-%d9%be%da%a9%db%8c%d8%ac-io">#&lt;/a>
&lt;/h2>
&lt;p>برای خواندن و نوشتن فایل‌ها می‌توان از پکیج &amp;ldquo;io&amp;rdquo; استفاده کرد. این پکیج امکانات بسیاری را برای کار با بیت‌ها و داده‌های ورودی/خروجی فراهم می‌کند. در کد زیر، یک فایل با نام &amp;ldquo;example.txt&amp;rdquo; باز شده و محتوای آن خوانده شده و به فایل دیگری با نام &amp;ldquo;output.txt&amp;rdquo; کپی می‌شود:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"io"
"log"
"os"
)
func main() {
// باز کردن فایل برای خواندن
inputFile, err := os.Open("example.txt")
if err != nil {
log.Fatal(err)
}
defer inputFile.Close()
// باز کردن فایل برای نوشتن
outputFile, err := os.Create("output.txt")
if err != nil {
log.Fatal(err)
}
defer outputFile.Close()
// کپی کردن اطلاعات از فایل ورودی به فایل خروجی
_, err = io.Copy(outputFile, inputFile)
if err != nil {
log.Fatal(err)
}
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در کد بالا، با استفاده از متدهای &amp;ldquo;os.Open&amp;rdquo; و &amp;ldquo;os.Create&amp;rdquo;، فایل‌های ورودی و خروجی باز شده و به عنوان فایل شیء به برنامه اضافه شده‌اند. سپس با استفاده از متد &amp;ldquo;io.Copy&amp;rdquo;، اطلاعات از فایل ورودی، به فایل خروجی کپی شده‌اند.&lt;/p>
&lt;p>در نهایت، با استفاده از &amp;ldquo;defer&amp;rdquo; و &amp;ldquo;Close&amp;rdquo;، فایل‌ها بسته شده‌اند و تغییرات آن‌ها ذخیره شده‌اند.&lt;/p></description></item><item><author/><title>4.8 آموزش کار با json</title><link>https://book.gofarsi.ir/chapter-4/work-with-json-file-in-go/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/work-with-json-file-in-go/</guid><description>&lt;h2 id="481-مقدمه">
4.8.1 مقدمه
&lt;a class="anchor" href="#481-%d9%85%d9%82%d8%af%d9%85%d9%87">#&lt;/a>
&lt;/h2>
&lt;p>JSON یک فرمت متنی است که برای مبادله و ذخیره داده‌ها استفاده می‌شود. نام JSON مخفف عبارت JavaScript Object Notation است و در ابتدا به عنوان یک زبان مبتنی بر جاوااسکریپت توسعه یافته است. با این حال، در حال حاضر JSON به راحتی با بیشتر زبان‌های برنامه‌نویسی سازگار است.&lt;/p>
&lt;p>JSON یک مجموعه از جفت‌های «key: value» است که با کاما از یکدیگر جدا شده‌اند و بین آنها با «:» ارتباط دارند. JSON در بین برنامه‌نویسان به عنوان یک ساختار داده‌ای محبوب است و به راحتی داده‌ها را به صورت ساختاردهی شده در برنامه‌های کاربردی مختلف به کار می‌رود. این فرمت دیتا استاندارد و مستقل از زبان‌ها و پلتفرم‌های برنامه‌نویسی است و برای برنامه‌های تحت وب، موبایل، دسکتاپ و سرور قابل استفاده است.&lt;/p>
&lt;p>ساختار یک فایل JSON شامل تعدادی از آبجکت‌ها و آرایه‌ها می‌باشد. به عبارتی داده‌های JSON می‌توانند در سه نوع اصلی “جسم آرکی”(object) ، “کالکشن آرای”(array) و “مقادیر اولیه”(values) تعریف شوند. آبجکت یک گروه از خصوصیات است که دارای یک کلید منحصر به فرد به عنوان “عنوان شی” می‌باشد. همچنین، آرایه نیز به مشابه یک لیست یا آرایه از خصوصیات است.&lt;/p>
&lt;p>یک مثال ساده JSON:&lt;/p>
&lt;pre>&lt;code class="language-json">{
&amp;quot;name&amp;quot;: &amp;quot;John Doe&amp;quot;,
&amp;quot;age&amp;quot;: 30,
&amp;quot;email&amp;quot;: &amp;quot;johndoe@example.com&amp;quot;,
&amp;quot;address&amp;quot;: {
&amp;quot;street&amp;quot;: &amp;quot;123 Main St&amp;quot;,
&amp;quot;city&amp;quot;: &amp;quot;Anytown&amp;quot;,
&amp;quot;state&amp;quot;: &amp;quot;CA&amp;quot;,
&amp;quot;zip&amp;quot;: &amp;quot;12345&amp;quot;
},
&amp;quot;phone&amp;quot;: [
{
&amp;quot;type&amp;quot;: &amp;quot;home&amp;quot;,
&amp;quot;number&amp;quot;: &amp;quot;555-555-1234&amp;quot;
},
{
&amp;quot;type&amp;quot;: &amp;quot;work&amp;quot;,
&amp;quot;number&amp;quot;: &amp;quot;555-555-5678&amp;quot;
}
]
}
&lt;/code>&lt;/pre>
&lt;p>در این مثال، یک شیء با عنوان &amp;ldquo;John Doe&amp;rdquo; تعریف شده است. این شیء دارای خصوصیاتی همچون نام، سن، ایمیل، آدرس و تلفن است. آدرس نیز یک شیء است که شامل خصوصیاتی همچون خیابان، شهر، ایالت و کد پستی است. همچنین، تلفن به عنوان یک آرایه از شیء‌ها تعریف شده است که شامل نوع تلفن و شماره تلفن است.&lt;/p>
&lt;h2 id="482-کار-با-marshal-و-unmarshal-پکیج-json">
4.8.2 کار با marshal و unmarshal پکیج json
&lt;a class="anchor" href="#482-%da%a9%d8%a7%d8%b1-%d8%a8%d8%a7-marshal-%d9%88-unmarshal-%d9%be%da%a9%db%8c%d8%ac-json">#&lt;/a>
&lt;/h2>
&lt;p>در زبان برنامه‌نویسی Go، پکیج &amp;ldquo;encoding/json&amp;rdquo; برای کار با داده‌های JSON بسیار مفید است. این پکیج امکاناتی برای تبدیل داده‌های Go به فرمت JSON (marshal) و برعکس (unmarshal) در اختیار برنامه‌نویسان قرار می‌دهد.&lt;/p>
&lt;h3 id="4821-کار-با-marshal">
4.8.2.1 کار با marshal
&lt;a class="anchor" href="#4821-%da%a9%d8%a7%d8%b1-%d8%a8%d8%a7-marshal">#&lt;/a>
&lt;/h3>
&lt;p>با استفاده از تابع &amp;ldquo;Marshal&amp;rdquo;، برای مثال، می‌توان یک شیء با فرمت JSON تولید کرد. در کد زیر، یک شیء از نوع &amp;ldquo;person&amp;rdquo; تعریف شده است و با استفاده از تابع &amp;ldquo;Marshal&amp;rdquo; به فرمت JSON تبدیل شده است:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"encoding/json"
"fmt"
)
type person struct {
Name string `json:"name"`
Age int `json:"age"`
Email string `json:"email"`
}
func main() {
p := &amp;person{Name: "John Doe", Age: 30, Email: "john.doe@example.com"}
b, err := json.Marshal(p)
if err != nil {
fmt.Println("error:", err)
}
fmt.Println(string(b))
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در کد بالا، ابتدا یک شیء از نوع &amp;ldquo;person&amp;rdquo; با مقادیر مشخص تعریف شده است. سپس از تابع &amp;ldquo;Marshal&amp;rdquo; برای تبدیل این شیء به فرمت JSON استفاده شده است. خروجی تابع &amp;ldquo;Marshal&amp;rdquo; یک بایت‌آرایه است که به عنوان یک رشته و با استفاده از تبدیل به &amp;ldquo;string&amp;rdquo; چاپ شده است.&lt;/p>
&lt;h3 id="4822-کار-با-unmarshal">
4.8.2.2 کار با unmarshal
&lt;a class="anchor" href="#4822-%da%a9%d8%a7%d8%b1-%d8%a8%d8%a7-unmarshal">#&lt;/a>
&lt;/h3>
&lt;p>با استفاده از تابع &amp;ldquo;Unmarshal&amp;rdquo; نیز می‌توان یک رشته JSON را به شیء Go تبدیل کرد. در کد زیر، یک رشته JSON با نام &amp;ldquo;data&amp;rdquo; تعریف شده است و با استفاده از تابع &amp;ldquo;Unmarshal&amp;rdquo; به یک شیء از نوع &amp;ldquo;person&amp;rdquo; تبدیل شده است:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"encoding/json"
"fmt"
)
type person struct {
Name string `json:"name"`
Age int `json:"age"`
Email string `json:"email"`
}
func main() {
data := `{"name":"John Doe","age":30,"email":"john.doe@example.com"}`
var p person
err := json.Unmarshal([]byte(data), &amp;p)
if err != nil {
fmt.Println("error:", err)
}
fmt.Println(p.Name, p.Age, p.Email)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در کد بالا، ابتدا یک رشته JSON با نام &amp;ldquo;data&amp;rdquo; تعریف شده است. سپس یک شیء از نوع &amp;ldquo;person&amp;rdquo; با استفاده از تابع &amp;ldquo;Unmarshal&amp;rdquo; و با این رشته JSON به شکل مقداردهی شده است. خروجی تابع &amp;ldquo;Unmarshal&amp;rdquo;، شیء &amp;ldquo;person&amp;rdquo; است که بعداً در کد چاپ شده است. توجه داشته باشید که در اینجا از &amp;ldquo;[]byte&amp;rdquo; برای تبدیل رشته به بایت‌آرایه استفاده شده است.&lt;/p>
&lt;h2 id="483-تبدیل-آرایه-و-slice-به-json">
4.8.3 تبدیل آرایه و slice به json
&lt;a class="anchor" href="#483-%d8%aa%d8%a8%d8%af%db%8c%d9%84-%d8%a2%d8%b1%d8%a7%db%8c%d9%87-%d9%88-slice-%d8%a8%d9%87-json">#&lt;/a>
&lt;/h2>
&lt;p>در Go، می‌توان آرایه‌ها و slice‌ها را به فرمت JSON تبدیل کرد. برای این کار، از تابع &amp;ldquo;Marshal&amp;rdquo; پکیج &amp;ldquo;encoding/json&amp;rdquo; استفاده می‌شود.&lt;/p>
&lt;p>برای مثال، فرض کنید یک slice‌ از اعداد صحیح داشته باشیم. برای تبدیل این slice به فرمت JSON، کد زیر نمونه‌ای از چگونگی استفاده از تابع &amp;ldquo;Marshal&amp;rdquo; را نشان می‌دهد:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"encoding/json"
"fmt"
)
func main() {
numbers := []int{1, 2, 3, 4, 5}
data, err := json.Marshal(numbers)
if err != nil {
fmt.Println("error:", err)
}
fmt.Println(string(data))
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در این کد، ابتدا یک slice‌ از اعداد صحیح تعریف شده است. سپس با استفاده از تابع &amp;ldquo;Marshal&amp;rdquo; این slice‌ به فرمت JSON تبدیل شده و در متغیر &amp;ldquo;data&amp;rdquo; ذخیره شده است. در نهایت، با استفاده از تبدیل به &amp;ldquo;string&amp;rdquo;، خروجی تابع &amp;ldquo;Marshal&amp;rdquo; به صورت یک رشته چاپ شده است.&lt;/p>
&lt;p>همچنین، می‌توان آرایه‌های چند بعدی را نیز به فرمت JSON تبدیل کرد. در کد زیر، یک آرایه دوبعدی از اعداد صحیح تعریف شده است و به فرمت JSON تبدیل می‌شود:&lt;/p>
&lt;p>&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"encoding/json"
"fmt"
)
func main() {
var matrix [2][3]int = [2][3]int{{1, 2, 3}, {4, 5, 6}}
data, err := json.Marshal(matrix)
if err != nil {
fmt.Println("error:", err)
}
fmt.Println(string(data))
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
در این کد نیز، بعد از تعریف یک آرایه دوبعدی از اعداد صحیح، با استفاده از تابع &amp;ldquo;Marshal&amp;rdquo; آن را به فرمت JSON تبدیل شده و در متغیر &amp;ldquo;data&amp;rdquo; ذخیره شده است. خروجی تابع &amp;ldquo;Marshal&amp;rdquo; نیز به صورت یک رشته چاپ می‌شود.&lt;/p>
&lt;h2 id="484-تبدیل-map-به-json">
4.8.4 تبدیل map به json
&lt;a class="anchor" href="#484-%d8%aa%d8%a8%d8%af%db%8c%d9%84-map-%d8%a8%d9%87-json">#&lt;/a>
&lt;/h2>
&lt;p>در Go، می‌توان map را به فرمت JSON تبدیل کرد با استفاده از تابع &amp;ldquo;Marshal&amp;rdquo; در پکیج &amp;ldquo;encoding/json&amp;rdquo; میتوان این کار را انجام داد.&lt;/p>
&lt;p>برای مثال، فرض کنید یک map از داده‌های شخصی داشته باشیم که شامل نام، سن و ایمیل است. برای تبدیل این map به فرمت JSON، کد زیر نمونه‌ای از چگونگی استفاده از تابع &amp;ldquo;Marshal&amp;rdquo; را نشان می‌دهد:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"encoding/json"
"fmt"
)
func main() {
data := map[string]interface{}{
"name": "John Doe",
"age": 30,
"email": "john.doe@example.com",
}
output, err := json.Marshal(data)
if err != nil {
fmt.Println("error:", err)
}
fmt.Println(string(output))
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در کد بالا، یک map از داده‌های شخصی با نام &amp;ldquo;data&amp;rdquo; تعریف شده است و سپس با استفاده از تابع &amp;ldquo;Marshal&amp;rdquo; به فرمت JSON تبدیل شده است. خروجی تابع &amp;ldquo;Marshal&amp;rdquo; نیز به صورت یک رشته چاپ شده است.&lt;/p>
&lt;p>توجه داشته باشید که در این نمونه، نوع داده‌ی مقدارهای مپ از نوع خاصی استفاده نشده است و به جای آن، از نوع &amp;ldquo;interface{}&amp;rdquo; برای مقادیر استفاده شده است. این به این دلیل است که ممکن است مقادیر مختلفی در map وجود داشته باشد ولی نوعشان کاملاً شناخته شده نباشد. با استفاده از &amp;ldquo;interface{}&amp;quot;، مقادیر به صورت پویا تعریف شده و برنامه قادر است به درستی تبدیل را انجام دهد.&lt;/p>
&lt;h2 id="485-کتابخانه-gjson">
4.8.5 کتابخانه GJSON
&lt;a class="anchor" href="#485-%da%a9%d8%aa%d8%a7%d8%a8%d8%ae%d8%a7%d9%86%d9%87-gjson">#&lt;/a>
&lt;/h2>
&lt;p>استفاده از فرمت json در زبان برنامه نویسی گو به راحتی استفاده از این فرمت در سایر زبان های برنامه نویسی دیگر مثل پایتون نیست و برای اینکه این مورد ساده‌تر شود توصیه میشود از کتابخانه GJSON استفاده شود.&lt;/p>
&lt;p>کتابخانه GJSON یک بسته Go است که راهی سریع و ساده برای دریافت مقادیر از یک سند json ارائه می دهد. دارای ویژگی هایی&lt;a href="https://github.com/tidwall/gjson#get-a-value">one line retrieval&lt;/a>, &lt;a href="https://github.com/tidwall/gjson#path-syntax">dot notation paths&lt;/a>, &lt;a href="https://github.com/tidwall/gjson#iterate-through-an-object-or-array">iteration&lt;/a>,، و &lt;a href="https://github.com/tidwall/gjson#json-lines">parsing json lines&lt;/a> است.&lt;/p>
&lt;p>این توضیحات یک نمای کلی از نحوه استفاده از GJSON است، برای اطلاعات بیشتر،&lt;a href="https://github.com/tidwall/gjson/blob/master/SYNTAX.md">GJSON Syntax&lt;/a> را بررسی کنید.&lt;/p>
&lt;h3 id="4851-راه-اندازی-و-نصب-gjson">
4.8.5.1 راه اندازی و نصب GJSON
&lt;a class="anchor" href="#4851-%d8%b1%d8%a7%d9%87-%d8%a7%d9%86%d8%af%d8%a7%d8%b2%db%8c-%d9%88-%d9%86%d8%b5%d8%a8-gjson">#&lt;/a>
&lt;/h3>
&lt;p>برای نصب می توانیم از کد زیر استفاده کنیم.&lt;/p>
&lt;pre>&lt;code class="language-shell">go get -u github.com/tidwall/gjson
&lt;/code>&lt;/pre>
&lt;p>با این کار کتابخانه نصب می شود.&lt;/p>
&lt;h3 id="4852-خواندن-مقادیر-با-gjson">
4.8.5.2 خواندن مقادیر با GJSON
&lt;a class="anchor" href="#4852-%d8%ae%d9%88%d8%a7%d9%86%d8%af%d9%86-%d9%85%d9%82%d8%a7%d8%af%db%8c%d8%b1-%d8%a8%d8%a7-gjson">#&lt;/a>
&lt;/h3>
&lt;p>برای جستجوی مقدار مورد نظر json را برای آدرس یا فایل مشخص شده دریافت کنید. کافیست کلید های تو در تو را تنها توسط یک نقطه، مانند &amp;rsquo;name.last&amp;rsquo; یا &amp;lsquo;age&amp;rsquo; فراخوانی کرده و مقدار درون آن را بدست آورید. به عنوان مثال در کد زیر:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "github.com/tidwall/gjson"
const json = `{"name":{"first":"Janet","last":"Prichard"},"age":47}`
func main() {
value := gjson.Get(json, "name.last")
println(value.String())
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>خروجی به صورت زیر خواهد بود:&lt;/p>
&lt;pre>&lt;code class="language-shell">Prichard
&lt;/code>&lt;/pre>
&lt;p>همچنین تابع &lt;em>&lt;a href="https://github.com/tidwall/gjson#get-multiple-values-at-once">GetMany&lt;/a>&lt;/em> برای دریافت چندین مقدار در یک زمان و &lt;em>&lt;a href="https://github.com/tidwall/gjson#working-with-bytes">GetBytes&lt;/a>&lt;/em> برای کار با &lt;em>slices&lt;/em> بایت JSON وجود دارد.&lt;/p>
&lt;h3 id="4853-path-syntax">
4.8.5.3 Path Syntax
&lt;a class="anchor" href="#4853-path-syntax">#&lt;/a>
&lt;/h3>
&lt;p>در زیر یک نمای کلی از path syntax ارائه شده است، برای اطلاعات کامل تر لطفاً &lt;a href="https://github.com/tidwall/gjson/blob/master/SYNTAX.md">GJSON Syntax&lt;/a> را بررسی کنید.&lt;/p>
&lt;p>یک path مجموعه ای از کلیدها است که با یک نقطه از هم جدا شده اند. یک کلید ممکن است حاوی کاراکترهای ویژه &amp;lsquo;*&amp;rsquo; و &amp;lsquo;؟&amp;rsquo; باشد. برای دسترسی به مقدار آرایه از شاخص به عنوان کلید استفاده کنید. برای به دست آوردن تعداد عناصر در یک آرایه یا دسترسی به یک path فرزند، از کاراکتر &amp;lsquo;#&amp;rsquo; استفاده کنید. کاراکترهای dot و wildcard را می توان با &amp;rsquo;&amp;rsquo; escape کرد.&lt;/p>
&lt;p>‍‍&lt;/p>
&lt;pre>&lt;code class="language-go">{
&amp;quot;name&amp;quot;: {&amp;quot;first&amp;quot;: &amp;quot;Tom&amp;quot;, &amp;quot;last&amp;quot;: &amp;quot;Anderson&amp;quot;},
&amp;quot;age&amp;quot;:37,
&amp;quot;children&amp;quot;: [&amp;quot;Sara&amp;quot;,&amp;quot;Alex&amp;quot;,&amp;quot;Jack&amp;quot;],
&amp;quot;fav.movie&amp;quot;: &amp;quot;Deer Hunter&amp;quot;,
&amp;quot;friends&amp;quot;: [
{&amp;quot;first&amp;quot;: &amp;quot;Dale&amp;quot;, &amp;quot;last&amp;quot;: &amp;quot;Murphy&amp;quot;, &amp;quot;age&amp;quot;: 44, &amp;quot;nets&amp;quot;: [&amp;quot;ig&amp;quot;, &amp;quot;fb&amp;quot;, &amp;quot;tw&amp;quot;]},
{&amp;quot;first&amp;quot;: &amp;quot;Roger&amp;quot;, &amp;quot;last&amp;quot;: &amp;quot;Craig&amp;quot;, &amp;quot;age&amp;quot;: 68, &amp;quot;nets&amp;quot;: [&amp;quot;fb&amp;quot;, &amp;quot;tw&amp;quot;]},
{&amp;quot;first&amp;quot;: &amp;quot;Jane&amp;quot;, &amp;quot;last&amp;quot;: &amp;quot;Murphy&amp;quot;, &amp;quot;age&amp;quot;: 47, &amp;quot;nets&amp;quot;: [&amp;quot;ig&amp;quot;, &amp;quot;tw&amp;quot;]}
]
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-shell">&amp;quot;name.last&amp;quot; &amp;gt;&amp;gt; &amp;quot;Anderson&amp;quot;
&amp;quot;age&amp;quot; &amp;gt;&amp;gt; 37
&amp;quot;children&amp;quot; &amp;gt;&amp;gt; [&amp;quot;Sara&amp;quot;,&amp;quot;Alex&amp;quot;,&amp;quot;Jack&amp;quot;]
&amp;quot;children.#&amp;quot; &amp;gt;&amp;gt; 3
&amp;quot;children.1&amp;quot; &amp;gt;&amp;gt; &amp;quot;Alex&amp;quot;
&amp;quot;child*.2&amp;quot; &amp;gt;&amp;gt; &amp;quot;Jack&amp;quot;
&amp;quot;c?ildren.0&amp;quot; &amp;gt;&amp;gt; &amp;quot;Sara&amp;quot;
&amp;quot;fav\.movie&amp;quot; &amp;gt;&amp;gt; &amp;quot;Deer Hunter&amp;quot;
&amp;quot;friends.#.first&amp;quot; &amp;gt;&amp;gt; [&amp;quot;Dale&amp;quot;,&amp;quot;Roger&amp;quot;,&amp;quot;Jane&amp;quot;]
&amp;quot;friends.1.last&amp;quot; &amp;gt;&amp;gt; &amp;quot;Craig&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>همچنین می‌توانید با استفاده از &lt;code>#(...)&lt;/code>, آرایه‌ای را برای پیدا کردن اولین match یا تطابق مورد نظر بررسی کنید، یا همه موارد مورد نظر را با &lt;code>#(...)#&lt;/code> را پیدا کنید. کوئری ها از عملگرهای مقایسه &lt;code>==&lt;/code>, &lt;code>!=&lt;/code>, &lt;code>&amp;lt;&lt;/code>, &lt;code>&amp;lt;=&lt;/code>, &lt;code>&amp;gt;&lt;/code>, &lt;code>&amp;gt;=&lt;/code> و الگوی ساده تطبیق عملگرهای  &lt;code>%&lt;/code> (like) و  &lt;code>!%&lt;/code> (not like) پشتیبانی می کنند.&lt;/p>
&lt;p>‍‍‍‍‍&lt;/p>
&lt;pre>&lt;code class="language-shell">friends.#(last==&amp;quot;Murphy&amp;quot;).first &amp;gt;&amp;gt; &amp;quot;Dale&amp;quot;
friends.#(last==&amp;quot;Murphy&amp;quot;)#.first &amp;gt;&amp;gt; [&amp;quot;Dale&amp;quot;,&amp;quot;Jane&amp;quot;]
friends.#(age&amp;gt;45)#.last &amp;gt;&amp;gt; [&amp;quot;Craig&amp;quot;,&amp;quot;Murphy&amp;quot;]
friends.#(first%&amp;quot;D*&amp;quot;).last &amp;gt;&amp;gt; &amp;quot;Murphy&amp;quot;
friends.#(first!%&amp;quot;D*&amp;quot;).last &amp;gt;&amp;gt; &amp;quot;Craig&amp;quot;
friends.#(nets.#(==&amp;quot;fb&amp;quot;))#.first &amp;gt;&amp;gt; [&amp;quot;Dale&amp;quot;,&amp;quot;Roger&amp;quot;]
&lt;/code>&lt;/pre>
&lt;p>لطفاً توجه داشته باشید که قبل از نسخه 1.3.0، کوئری ها از براکت های #[&amp;hellip;] استفاده می کردند. این در نسخه 1.3.0 تغییر کرد تا از سردرگمی با سینتکس چند مسیری جدید جلوگیری شود. برای &lt;em>backwards compatibility&lt;/em> ، #[&amp;hellip;] تا نسخه اصلی بعدی به کار خود ادامه خواهد داد.&lt;/p>
&lt;h3 id="4854-result-type">
4.8.5.4 Result Type
&lt;a class="anchor" href="#4854-result-type">#&lt;/a>
&lt;/h3>
&lt;p>کتابخانه GJSON از انواع json string، number، bool و null پشتیبانی می کند. آرایه ها و اشیاء به عنوان نوع خام json خود برگردانده می شوند.&lt;/p>
&lt;p>نوع Result یکی از این موارد را دارد:&lt;/p>
&lt;p>‍‍‍&lt;/p>
&lt;pre>&lt;code class="language-shell">bool, for JSON booleans
float64, for JSON numbers
string, for JSON string literals
nil, for JSON null
&lt;/code>&lt;/pre>
&lt;p>برای دسترسی مستقیم به مقدار مورد نظر:&lt;/p>
&lt;pre>&lt;code class="language-shell">result.Type // can be String, Number, True, False, Null, or JSON
result.Str // holds the string
result.Num // holds the float64 number
result.Raw // holds the raw json
result.Index // index of raw value in original json, zero means index unknown
result.Indexes // indexes of all the elements that match on a path containing the '#' query character.
&lt;/code>&lt;/pre>
&lt;p>انواع مختلفی از توابع مفید وجود دارد که بر روی یک نتیجه کار می کنند:&lt;/p>
&lt;pre>&lt;code class="language-shell">result.Exists() bool
result.Value() interface{}
result.Int() int64
result.Uint() uint64
result.Float() float64
result.String() string
result.Bool() bool
result.Time() time.Time
result.Array() []gjson.Result
result.Map() map[string]gjson.Result
result.Get(path string) Result
result.ForEach(iterator func(key, value Result) bool)
result.Less(token Result, caseSensitive bool) bool
&lt;/code>&lt;/pre>
&lt;p>تابع  &lt;code>result.Value()&lt;/code> یک &lt;code>interface{}&lt;/code> را برمی‌گرداند که به  &lt;a href="https://go.dev/tour/methods/15"> type assertion&lt;/a> نیاز دارد و که یکی از type های Go به صورت زیر است:&lt;/p>
&lt;pre>&lt;code class="language-shell">boolean &amp;gt;&amp;gt; bool
number &amp;gt;&amp;gt; float64
string &amp;gt;&amp;gt; string
null &amp;gt;&amp;gt; nil
array &amp;gt;&amp;gt; []interface{}
object &amp;gt;&amp;gt; map[string]interface{}
&lt;/code>&lt;/pre>
&lt;p>تابع &lt;code>result.Array()&lt;/code> آرایه ای از مقادیر را برمی گرداند. اگر نتیجه یک مقدار غیر موجود را نشان دهد، یک آرایه خالی برگردانده می شود. اگر نتیجه یک آرایه JSON نباشد، مقدار بازگشتی یک آرایه حاوی یک نتیجه خواهد بود.&lt;/p>
&lt;h4 id="64-bit-integers">
64-bit integers
&lt;a class="anchor" href="#64-bit-integers">#&lt;/a>
&lt;/h4>
&lt;p>فراخوانی های &lt;code>result.Int()&lt;/code> و  &lt;code>result.Uint()&lt;/code> قادر به خواندن تمام 64 بیت هستند و امکان کار با اعداد صحیح JSON را فراهم می کنند.&lt;/p>
&lt;pre>&lt;code class="language-shell">result.Int() int64 // -9223372036854775808 to 9223372036854775807
result.Uint() uint64 // 0 to 18446744073709551615
&lt;/code>&lt;/pre>
&lt;h3 id="4855-modifiers-and-path-chaining">
4.8.5.5 Modifiers and path chaining
&lt;a class="anchor" href="#4855-modifiers-and-path-chaining">#&lt;/a>
&lt;/h3>
&lt;p>اصلاح کننده یک جزء مسیر است که پردازش custom شده‌ای را روی json انجام می دهد.&lt;/p>
&lt;p>چندین مسیر را می توان با استفاده از pipe character به هم «chained» کرد. این برای دریافت نتایج از یک query اصلاح شده مفید است.&lt;/p>
&lt;p>به عنوان مثال، با استفاده از اصلاح‌کننده  &lt;code>@reverse&lt;/code> داخلی در سند json بالا، آرایه فرزندان را دریافت می‌کنیم و ترتیب را برعکس می‌کنیم:&lt;/p>
&lt;p>‍&lt;/p>
&lt;pre>&lt;code class="language-shell">&amp;quot;children|@reverse&amp;quot; &amp;gt;&amp;gt; [&amp;quot;Jack&amp;quot;,&amp;quot;Alex&amp;quot;,&amp;quot;Sara&amp;quot;]
&amp;quot;children|@reverse|0&amp;quot; &amp;gt;&amp;gt; &amp;quot;Jack&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>در حال حاضر اصلاح کننده های داخلی زیر وجود دارد:&lt;/p>
&lt;ul>
&lt;li>@reverse: یک آرایه یا اعضای یک شی را معکوس کنید.&lt;/li>
&lt;li>@ugly: تمام فضای خالی را از یک سند json حذف کنید.&lt;/li>
&lt;li>@pretty: سند json را برای انسان قابل خواندن تر کنید.&lt;/li>
&lt;li>@this: عنصر فعلی را برمی‌گرداند. می توان از آن برای بازیابی عنصر ریشه استفاده کرد.&lt;/li>
&lt;li>@valid: مطمئن شوید که سند json معتبر است.&lt;/li>
&lt;li>@flatten: یک آرایه را صاف می کند.&lt;/li>
&lt;li>@join: چندین شی را به یک شیء متصل می کند.&lt;/li>
&lt;li>@keys: آرایه ای از کلیدها را برای یک شی برمی گرداند.&lt;/li>
&lt;li>@values: آرایه ای از مقادیر را برای یک شی برمی گرداند.&lt;/li>
&lt;li>@tostr: json را به یک رشته تبدیل می کند. یک رشته json را می پیچد.&lt;/li>
&lt;li>@fromstr: یک رشته را از json تبدیل می کند. یک رشته json را باز می کند.&lt;/li>
&lt;li>@group: آرایه های اشیاء را گروه بندی می کند.  &lt;a href="https://github.com/tidwall/gjson/commit/e4fc67c92aeebf2089fabc7872f010e340d105db">e4fc67c&lt;/a>. را ببینید.&lt;/li>
&lt;/ul>
&lt;p>Modifier arguments&lt;/p>
&lt;p>یک اصلاح کننده ممکن است یک آرگومان اختیاری را بپذیرد. آرگومان می تواند یک سند JSON معتبر یا فقط کاراکتر باشد.&lt;/p>
&lt;p>به عنوان مثال، اصلاح کننده  &lt;code>@pretty&lt;/code> یک شی json را به عنوان آرگومان خود می گیرد.&lt;/p>
&lt;pre>&lt;code>@pretty:{&amp;quot;sortKeys&amp;quot;:true}
&lt;/code>&lt;/pre>
&lt;p>که json را زیبا می کند و تمام کلیدهای آن را سفارش می دهد.&lt;/p>
&lt;pre>&lt;code class="language-go">{
&amp;quot;age&amp;quot;:37,
&amp;quot;children&amp;quot;: [&amp;quot;Sara&amp;quot;,&amp;quot;Alex&amp;quot;,&amp;quot;Jack&amp;quot;],
&amp;quot;fav.movie&amp;quot;: &amp;quot;Deer Hunter&amp;quot;,
&amp;quot;friends&amp;quot;: [
{&amp;quot;age&amp;quot;: 44, &amp;quot;first&amp;quot;: &amp;quot;Dale&amp;quot;, &amp;quot;last&amp;quot;: &amp;quot;Murphy&amp;quot;},
{&amp;quot;age&amp;quot;: 68, &amp;quot;first&amp;quot;: &amp;quot;Roger&amp;quot;, &amp;quot;last&amp;quot;: &amp;quot;Craig&amp;quot;},
{&amp;quot;age&amp;quot;: 47, &amp;quot;first&amp;quot;: &amp;quot;Jane&amp;quot;, &amp;quot;last&amp;quot;: &amp;quot;Murphy&amp;quot;}
],
&amp;quot;name&amp;quot;: {&amp;quot;first&amp;quot;: &amp;quot;Tom&amp;quot;, &amp;quot;last&amp;quot;: &amp;quot;Anderson&amp;quot;}
}
&lt;/code>&lt;/pre>
&lt;p>لیست کامل گزینه های  &lt;em>&lt;code>@pretty&lt;/code>&lt;/em> عبارتند از  &lt;em>&lt;code>sortKeys&lt;/code>, &lt;code>indent&lt;/code>, &lt;code>prefix&lt;/code>, و &lt;code>width&lt;/code>&lt;/em>. لطفاً برای اطلاعات بیشتر به _&lt;a href="https://github.com/tidwall/pretty#customized-output">Pretty Options&lt;/a>_مراجعه کنید.&lt;/p>
&lt;h4 id="custom-modifiers">
Custom modifiers
&lt;a class="anchor" href="#custom-modifiers">#&lt;/a>
&lt;/h4>
&lt;p>همچنین می توانید اصلاح کننده های سفارشی اضافه کنید. به عنوان مثال، در اینجا ما یک اصلاح کننده ایجاد می کنیم که کل سند json را upper case یا lower case می کند.&lt;/p>
&lt;pre>&lt;code class="language-go">gjson.AddModifier(&amp;quot;case&amp;quot;, func(json, arg string) string {
if arg == &amp;quot;upper&amp;quot; {
return strings.ToUpper(json)
}
if arg == &amp;quot;lower&amp;quot; {
return strings.ToLower(json)
}
return json
})
&lt;/code>&lt;/pre>
&lt;pre>&lt;code>&amp;quot;children|@case:upper&amp;quot; &amp;gt;&amp;gt; [&amp;quot;SARA&amp;quot;,&amp;quot;ALEX&amp;quot;,&amp;quot;JACK&amp;quot;]
&amp;quot;children|@case:lower|@reverse&amp;quot; &amp;gt;&amp;gt; [&amp;quot;jack&amp;quot;,&amp;quot;alex&amp;quot;,&amp;quot;sara&amp;quot;]
&lt;/code>&lt;/pre>
&lt;h3 id="4856-json-lines">
4.8.5.6 JSON Lines
&lt;a class="anchor" href="#4856-json-lines">#&lt;/a>
&lt;/h3>
&lt;p>پشتیبانی از &lt;a href="http://jsonlines.org/">JSON Lines&lt;/a> با استفاده از پیشوند &lt;code>..&lt;/code> وجود دارد که یک سند چند خطی را به عنوان یک آرایه در نظر می گیرد.&lt;/p>
&lt;p>به عنوان مثال:&lt;/p>
&lt;pre>&lt;code>{&amp;quot;name&amp;quot;: &amp;quot;Gilbert&amp;quot;, &amp;quot;age&amp;quot;: 61}
{&amp;quot;name&amp;quot;: &amp;quot;Alexa&amp;quot;, &amp;quot;age&amp;quot;: 34}
{&amp;quot;name&amp;quot;: &amp;quot;May&amp;quot;, &amp;quot;age&amp;quot;: 57}
{&amp;quot;name&amp;quot;: &amp;quot;Deloise&amp;quot;, &amp;quot;age&amp;quot;: 44}
&lt;/code>&lt;/pre>
&lt;p>تابع  &lt;code>ForEachLines&lt;/code> از طریق خطوط JSON تکرار می شود.&lt;/p>
&lt;pre>&lt;code class="language-go">gjson.ForEachLine(json, func(line gjson.Result) bool{
println(line.String())
return true
})
&lt;/code>&lt;/pre>
&lt;h3 id="4857-خواندن-مقدارهای-تو-در-تو-یا-nested">
4.8.5.7 خواندن مقدارهای تو در تو یا nested
&lt;a class="anchor" href="#4857-%d8%ae%d9%88%d8%a7%d9%86%d8%af%d9%86-%d9%85%d9%82%d8%af%d8%a7%d8%b1%d9%87%d8%a7%db%8c-%d8%aa%d9%88-%d8%af%d8%b1-%d8%aa%d9%88-%db%8c%d8%a7-nested">#&lt;/a>
&lt;/h3>
&lt;p>فرض کنید همه نام‌های خانوادگی را از json زیر می‌خواهید:&lt;/p>
&lt;p>‍‍&lt;/p>
&lt;pre>&lt;code class="language-json">{
&amp;quot;programmers&amp;quot;: [
{
&amp;quot;firstName&amp;quot;: &amp;quot;Janet&amp;quot;,
&amp;quot;lastName&amp;quot;: &amp;quot;McLaughlin&amp;quot;,
}, {
&amp;quot;firstName&amp;quot;: &amp;quot;Elliotte&amp;quot;,
&amp;quot;lastName&amp;quot;: &amp;quot;Hunter&amp;quot;,
}, {
&amp;quot;firstName&amp;quot;: &amp;quot;Jason&amp;quot;,
&amp;quot;lastName&amp;quot;: &amp;quot;Harold&amp;quot;,
}
]
}
&lt;/code>&lt;/pre>
&lt;p>شما می توانید از مسیر &amp;lsquo;programmers.#.lastName&amp;rsquo; مانند این استفاده کنید:&lt;/p>
&lt;p>‍‍&lt;/p>
&lt;pre>&lt;code class="language-go">result := gjson.Get(json, &amp;quot;programmers.#.lastName&amp;quot;)
for _, name := range result.Array() {
println(name.String())
}
&lt;/code>&lt;/pre>
&lt;p>همچنین می توانید یک شی در داخل یک آرایه را پرس و جو کنید:&lt;/p>
&lt;pre>&lt;code class="language-go">name := gjson.Get(json, `programmers.#(lastName=&amp;quot;Hunter&amp;quot;).firstName`)
println(name.String()) // prints &amp;quot;Elliotte&amp;quot;
&lt;/code>&lt;/pre>
&lt;h3 id="4858-پیمایش-یک-شی-یا-آرایه">
4.8.5.8 پیمایش یک شی یا آرایه
&lt;a class="anchor" href="#4858-%d9%be%db%8c%d9%85%d8%a7%db%8c%d8%b4-%db%8c%da%a9-%d8%b4%db%8c-%db%8c%d8%a7-%d8%a2%d8%b1%d8%a7%db%8c%d9%87">#&lt;/a>
&lt;/h3>
&lt;p>تابع  &lt;code>ForEach&lt;/code> امکان تکرار سریع از طریق یک شی یا آرایه را فراهم می کند. کلید و مقدار برای اشیا به تابع تکرار کننده ارسال می شود. فقط مقدار برای آرایه ها ارسال می شود. برگرداندن false از یک تکرار کننده، تکرار را متوقف می کند.&lt;/p>
&lt;pre>&lt;code class="language-go">result := gjson.Get(json, &amp;quot;programmers&amp;quot;)
result.ForEach(func(key, value gjson.Result) bool {
println(value.String())
return true // keep iterating
})
&lt;/code>&lt;/pre>
&lt;h3 id="4859-simple-parse-and-get">
4.8.5.9 Simple Parse and Get
&lt;a class="anchor" href="#4859-simple-parse-and-get">#&lt;/a>
&lt;/h3>
&lt;p>یک تابع  &lt;code>Parse(json)&lt;/code> وجود دارد که یک تجزیه ساده را انجام می دهد و  &lt;code>result.Get(path)&lt;/code> که یک نتیجه را جستجو می کند. به عنوان مثال، همه اینها نتیجه یکسانی را نشان می دهند:&lt;/p>
&lt;pre>&lt;code class="language-go">gjson.Parse(json).Get(&amp;quot;name&amp;quot;).Get(&amp;quot;last&amp;quot;)
gjson.Get(json, &amp;quot;name&amp;quot;).Get(&amp;quot;last&amp;quot;)
gjson.Get(json, &amp;quot;name.last&amp;quot;)
&lt;/code>&lt;/pre>
&lt;h3 id="48510-بررسی-جهت-وجود-یک-value-خاص">
4.8.5.10 بررسی جهت وجود یک value خاص
&lt;a class="anchor" href="#48510-%d8%a8%d8%b1%d8%b1%d8%b3%db%8c-%d8%ac%d9%87%d8%aa-%d9%88%d8%ac%d9%88%d8%af-%db%8c%da%a9-value-%d8%ae%d8%a7%d8%b5">#&lt;/a>
&lt;/h3>
&lt;p>گاهی اوقات فقط می خواهیم بدانیم که آیا یک مقدار وجود دارد یا خیر.&lt;/p>
&lt;pre>&lt;code class="language-go">value := gjson.Get(json, &amp;quot;name.last&amp;quot;)
if !value.Exists() {
println(&amp;quot;no last name&amp;quot;)
} else {
println(value.String())
}
// Or as one step
if gjson.Get(json, &amp;quot;name.last&amp;quot;).Exists() {
println(&amp;quot;has a last name&amp;quot;)
}
&lt;/code>&lt;/pre>
&lt;h4 id="48511-اعتبار-سنجی-json">
4.8.5.11 اعتبار سنجی JSON
&lt;a class="anchor" href="#48511-%d8%a7%d8%b9%d8%aa%d8%a8%d8%a7%d8%b1-%d8%b3%d9%86%d8%ac%db%8c-json">#&lt;/a>
&lt;/h4>
&lt;p>توابع  &lt;code>Get*&lt;/code> و &lt;code>Parse*&lt;/code> انتظار دارند که فایل حاوی json به سالم و استاندارد باشد. خطا در فایل json باعث حالت panic نمی‌شود، اما ممکن است نتایج غیرمنتظره را بازگرداند.&lt;/p>
&lt;p>اگر JSON را از یک منبع غیرقابل نامشخص استفاده کنید، ممکن است بخواهید قبل از استفاده از GJSON اعتبار سنجی کنید.&lt;/p>
&lt;p>‍&lt;/p>
&lt;pre>&lt;code class="language-go">if !gjson.Valid(json) {
return errors.New(&amp;quot;invalid json&amp;quot;)
}
value := gjson.Get(json, &amp;quot;name.last&amp;quot;)
&lt;/code>&lt;/pre>
&lt;h3 id="48512-unmarshal-به-یک-map">
4.8.5.12 Unmarshal به یک map
&lt;a class="anchor" href="#48512-unmarshal-%d8%a8%d9%87-%db%8c%da%a9-map">#&lt;/a>
&lt;/h3>
&lt;p>برای unmarshal به مپ به صورت  &lt;code>map[string]interface{}&lt;/code>:&lt;/p>
&lt;p>‍‍&lt;/p>
&lt;pre>&lt;code class="language-go">m, ok := gjson.Parse(json).Value().(map[string]interface{})
if !ok {
// not a map
}
&lt;/code>&lt;/pre>
&lt;h3 id="48513-کار-با-byte-ها">
4.8.5.13 کار با byte ها
&lt;a class="anchor" href="#48513-%da%a9%d8%a7%d8%b1-%d8%a8%d8%a7-byte-%d9%87%d8%a7">#&lt;/a>
&lt;/h3>
&lt;p>اگر درJSON فایل مورد نظر شما  &lt;code>[]byte&lt;/code> slice وجود دارد، تابع  &lt;a href="https://godoc.org/github.com/tidwall/gjson#GetBytes">GetBytes&lt;/a> برای این حالت وجود دارد. این تابع در استفاده از  &lt;code>Get(string(data), path)&lt;/code> ترجیح داده می شود.&lt;/p>
&lt;p>‍‍&lt;/p>
&lt;pre>&lt;code class="language-go">var json []byte = ...
result := gjson.GetBytes(json, path)
&lt;/code>&lt;/pre>
&lt;p>اگر از تابع  &lt;code>gjson.GetBytes(json, path)&lt;/code> استفاده می کنید و می خواهید از تبدیل &lt;code>result.Raw&lt;/code> به &lt;code>[]byte&lt;/code> اجتناب کنید، می توانید از این الگو استفاده کنید:&lt;/p>
&lt;pre>&lt;code class="language-go">var json []byte = ...
result := gjson.GetBytes(json, path)
var raw []byte
if result.Index &amp;gt; 0 {
raw = json[result.Index:result.Index+len(result.Raw)]
} else {
raw = []byte(result.Raw)
}
&lt;/code>&lt;/pre>
&lt;p>این روش از فیلد &lt;code>result.Index&lt;/code> استفاده می‌کند که موقعیت داده‌های خام در json فایل است. ممکن است که مقدار &lt;code>result.Index&lt;/code> برابر با صفر باشد، در این صورت &lt;code>result.Raw&lt;/code> به یک &lt;code>[]byte&lt;/code> تبدیل می‌شود.&lt;/p>
&lt;h3 id="48514-خواندن-چندین-value">
4.8.5.14 خواندن چندین value
&lt;a class="anchor" href="#48514-%d8%ae%d9%88%d8%a7%d9%86%d8%af%d9%86-%da%86%d9%86%d8%af%db%8c%d9%86-value">#&lt;/a>
&lt;/h3>
&lt;p>تابع  &lt;code>GetMany&lt;/code> می تواند برای دریافت چندین مقدار به طور همزمان استفاده شود.&lt;/p>
&lt;p>‍‍&lt;/p>
&lt;pre>&lt;code class="language-go">results := gjson.GetMany(json, &amp;quot;name.first&amp;quot;, &amp;quot;name.last&amp;quot;, &amp;quot;age&amp;quot;)
&lt;/code>&lt;/pre>
&lt;p>مقدار بازگشتی یک  &lt;code>[]Result&lt;/code> است، که همیشه دارای دقیقاً همان تعداد آیتم‌هایی است که مسیرهای ورودی دارند.&lt;/p>
&lt;h3 id="486-کتابخانه-sjson">
4.8.6 کتابخانه SJSON
&lt;a class="anchor" href="#486-%da%a9%d8%aa%d8%a7%d8%a8%d8%ae%d8%a7%d9%86%d9%87-sjson">#&lt;/a>
&lt;/h3>
&lt;p>در واقع SJSON یک کتابخانه‌ای است که یک راه بسیار سریع و ساده برای تنظیم یک value در یک سند json ارائه می دهد. در بخش قبلی فقط می‌توانستیم مقادیر موجود در یک سند json بازخوانی کنیم ولی به کمک sjson می توانیم مقادیر مورد نظر را در یک سند json وارد کرده یا به روزرسانی و حذف دهیم.&lt;/p>
&lt;h3 id="4861-راه-اندازی-و-نصب-sjson">
4.8.6.1 راه اندازی و نصب SJSON
&lt;a class="anchor" href="#4861-%d8%b1%d8%a7%d9%87-%d8%a7%d9%86%d8%af%d8%a7%d8%b2%db%8c-%d9%88-%d9%86%d8%b5%d8%a8-sjson">#&lt;/a>
&lt;/h3>
&lt;p>برای شروع استفاده از SJSON باید آن را نصب کنید و &lt;code>go get&lt;/code> را اجرا کنید:&lt;/p>
&lt;pre>&lt;code class="language-sh">$ go get -u github.com/tidwall/sjson
&lt;/code>&lt;/pre>
&lt;p>با این کار کتابخانه نصب می شود.&lt;/p>
&lt;h3 id="4862--set-a-value">
4.8.6.2 Set a value
&lt;a class="anchor" href="#4862--set-a-value">#&lt;/a>
&lt;/h3>
&lt;hr>
&lt;p>دستور Set مقدار یا value ای را برای path مشخص شده اجرا می کند. یک path در یک dot syntax مشخص می‌شود، مانند &amp;rsquo;name.last&amp;rsquo; یا &amp;lsquo;age&amp;rsquo;. در این عملکرد انتظار می‌رود که ساختار کلی json صحیح و valid باشد. در صورت اشکال در ساختار json فایل و Invalid بودن آن، حالت panic رخ نمی‌دهد، اما ممکن است نتایج غیرمنتظره‌ای را برگرداند. البته pathهای نامعتبر ممکن است ایجاد خطا کند.
به عنوان مثال کد زیر:&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import &amp;quot;github.com/tidwall/sjson&amp;quot;
const json = `{&amp;quot;name&amp;quot;:{&amp;quot;first&amp;quot;:&amp;quot;Janet&amp;quot;,&amp;quot;last&amp;quot;:&amp;quot;Prichard&amp;quot;},&amp;quot;age&amp;quot;:47}`
func main() {
value, _ := sjson.Set(json, &amp;quot;name.last&amp;quot;, &amp;quot;Anderson&amp;quot;)
println(value)
}
&lt;/code>&lt;/pre>
&lt;p>خروجی به شکل زیر خواهد بود:&lt;/p>
&lt;pre>&lt;code class="language-json">{&amp;quot;name&amp;quot;:{&amp;quot;first&amp;quot;:&amp;quot;Janet&amp;quot;,&amp;quot;last&amp;quot;:&amp;quot;Anderson&amp;quot;},&amp;quot;age&amp;quot;:47}
&lt;/code>&lt;/pre>
&lt;h3 id="4863-----path-syntax">
4.8.6.3 Path syntax
&lt;a class="anchor" href="#4863-----path-syntax">#&lt;/a>
&lt;/h3>
&lt;hr>
&lt;p>در واقع path یا مسیر مجموعه ای از کلیدها است که با یک نقطه از هم جدا شده اند. کاراکترهای dot و colon را می توان با کاراکتر &lt;code>\&lt;/code> به راحتی escape کرد.&lt;/p>
&lt;pre>&lt;code class="language-json">{
&amp;quot;name&amp;quot;: {&amp;quot;first&amp;quot;: &amp;quot;Tom&amp;quot;, &amp;quot;last&amp;quot;: &amp;quot;Anderson&amp;quot;},
&amp;quot;age&amp;quot;:37,
&amp;quot;children&amp;quot;: [&amp;quot;Sara&amp;quot;,&amp;quot;Alex&amp;quot;,&amp;quot;Jack&amp;quot;],
&amp;quot;fav.movie&amp;quot;: &amp;quot;Deer Hunter&amp;quot;,
&amp;quot;friends&amp;quot;: [
{&amp;quot;first&amp;quot;: &amp;quot;James&amp;quot;, &amp;quot;last&amp;quot;: &amp;quot;Murphy&amp;quot;},
{&amp;quot;first&amp;quot;: &amp;quot;Roger&amp;quot;, &amp;quot;last&amp;quot;: &amp;quot;Craig&amp;quot;}
]
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code>&amp;quot;name.last&amp;quot; &amp;gt;&amp;gt; &amp;quot;Anderson&amp;quot;
&amp;quot;age&amp;quot; &amp;gt;&amp;gt; 37
&amp;quot;children.1&amp;quot; &amp;gt;&amp;gt; &amp;quot;Alex&amp;quot;
&amp;quot;friends.1.last&amp;quot; &amp;gt;&amp;gt; &amp;quot;Craig&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>از کلید &lt;code>-1&lt;/code> می توان برای افزودن یک مقدار به آرایه موجود استفاده کرد:&lt;/p>
&lt;pre>&lt;code>&amp;quot;children.-1&amp;quot; &amp;gt;&amp;gt; appends a new value to the end of the children array
&lt;/code>&lt;/pre>
&lt;p>معمولاً از کلیدهای عددی برای اصلاح آرایه ها استفاده می شود، اما می توان با استفاده از کاراکتر دو نقطه، یک کلید شی عددی را اجرا کرد:&lt;/p>
&lt;pre>&lt;code class="language-json">{
&amp;quot;users&amp;quot;:{
&amp;quot;2313&amp;quot;:{&amp;quot;name&amp;quot;:&amp;quot;Sara&amp;quot;},
&amp;quot;7839&amp;quot;:{&amp;quot;name&amp;quot;:&amp;quot;Andy&amp;quot;}
}
}
&lt;/code>&lt;/pre>
&lt;p>همینطور colon path به صورت زیر است:&lt;/p>
&lt;pre>&lt;code>&amp;quot;users.:2313.name&amp;quot; &amp;gt;&amp;gt; &amp;quot;Sara&amp;quot;
&lt;/code>&lt;/pre>
&lt;h3 id="4864-----supported-types">
4.8.6.4 Supported types
&lt;a class="anchor" href="#4864-----supported-types">#&lt;/a>
&lt;/h3>
&lt;hr>
&lt;p>در کتابخانه SJSON تقریباً هر نوع متغیر یا type ای پشتیبانی می شود:&lt;/p>
&lt;pre>&lt;code class="language-go">sjson.Set(`{&amp;quot;key&amp;quot;:true}`, &amp;quot;key&amp;quot;, nil)
sjson.Set(`{&amp;quot;key&amp;quot;:true}`, &amp;quot;key&amp;quot;, false)
sjson.Set(`{&amp;quot;key&amp;quot;:true}`, &amp;quot;key&amp;quot;, 1)
sjson.Set(`{&amp;quot;key&amp;quot;:true}`, &amp;quot;key&amp;quot;, 10.5)
sjson.Set(`{&amp;quot;key&amp;quot;:true}`, &amp;quot;key&amp;quot;, &amp;quot;hello&amp;quot;)
sjson.Set(`{&amp;quot;key&amp;quot;:true}`, &amp;quot;key&amp;quot;, []string{&amp;quot;hello&amp;quot;, &amp;quot;world&amp;quot;})
sjson.Set(`{&amp;quot;key&amp;quot;:true}`, &amp;quot;key&amp;quot;, map[string]interface{}{&amp;quot;hello&amp;quot;:&amp;quot;world&amp;quot;})
&lt;/code>&lt;/pre>
&lt;p>هنگامی که یک type شناسایی نمی شود، SJSON به رمزگذاری &lt;code>encoding/json&lt;/code> باز می گردد.&lt;/p>
&lt;h3 id="4865----مثال-sjson">
4.8.6.5 مثال SJSON
&lt;a class="anchor" href="#4865----%d9%85%d8%ab%d8%a7%d9%84-sjson">#&lt;/a>
&lt;/h3>
&lt;hr>
&lt;p>در این بخش به بررسی چند مثال از SJSON می پردازیم:&lt;/p>
&lt;p>وارد کردن یک مقدار در یک json document خالی.&lt;/p>
&lt;pre>&lt;code class="language-go">value, _ := sjson.Set(&amp;quot;&amp;quot;, &amp;quot;name&amp;quot;, &amp;quot;Tom&amp;quot;)
println(value)
// Output:
// {&amp;quot;name&amp;quot;:&amp;quot;Tom&amp;quot;}
&lt;/code>&lt;/pre>
&lt;p>وارد کردن یک مقادیر تو در تو یا nested در یک json document خالی.&lt;/p>
&lt;pre>&lt;code class="language-go">value, _ := sjson.Set(&amp;quot;&amp;quot;, &amp;quot;name.last&amp;quot;, &amp;quot;Anderson&amp;quot;)
println(value)
// Output:
// {&amp;quot;name&amp;quot;:{&amp;quot;last&amp;quot;:&amp;quot;Anderson&amp;quot;}}
&lt;/code>&lt;/pre>
&lt;p>وارد کردن مقدار جدید در سند:&lt;/p>
&lt;pre>&lt;code class="language-go">value, _ := sjson.Set(`{&amp;quot;name&amp;quot;:{&amp;quot;last&amp;quot;:&amp;quot;Anderson&amp;quot;}}`, &amp;quot;name.first&amp;quot;, &amp;quot;Sara&amp;quot;)
println(value)
// Output:
// {&amp;quot;name&amp;quot;:{&amp;quot;first&amp;quot;:&amp;quot;Sara&amp;quot;,&amp;quot;last&amp;quot;:&amp;quot;Anderson&amp;quot;}}
&lt;/code>&lt;/pre>
&lt;p>بروزرسانی و آپدیت یک سند:&lt;/p>
&lt;pre>&lt;code class="language-go">value, _ := sjson.Set(`{&amp;quot;name&amp;quot;:{&amp;quot;last&amp;quot;:&amp;quot;Anderson&amp;quot;}}`, &amp;quot;name.last&amp;quot;, &amp;quot;Smith&amp;quot;)
println(value)
// Output:
// {&amp;quot;name&amp;quot;:{&amp;quot;last&amp;quot;:&amp;quot;Smith&amp;quot;}}
&lt;/code>&lt;/pre>
&lt;p>وارد کردن مقدار آرایه جدید:&lt;/p>
&lt;pre>&lt;code class="language-go">value, _ := sjson.Set(`{&amp;quot;friends&amp;quot;:[&amp;quot;Andy&amp;quot;,&amp;quot;Carol&amp;quot;]}`, &amp;quot;friends.2&amp;quot;, &amp;quot;Sara&amp;quot;)
println(value)
// Output:
// {&amp;quot;friends&amp;quot;:[&amp;quot;Andy&amp;quot;,&amp;quot;Carol&amp;quot;,&amp;quot;Sara&amp;quot;]
&lt;/code>&lt;/pre>
&lt;p>اضافه کردن مقدار جدید به انتهای آرایه با استفاده از گزینه &lt;code>1-&lt;/code> :&lt;/p>
&lt;pre>&lt;code class="language-go">value, _ := sjson.Set(`{&amp;quot;friends&amp;quot;:[&amp;quot;Andy&amp;quot;,&amp;quot;Carol&amp;quot;]}`, &amp;quot;friends.-1&amp;quot;, &amp;quot;Sara&amp;quot;)
println(value)
// Output:
// {&amp;quot;friends&amp;quot;:[&amp;quot;Andy&amp;quot;,&amp;quot;Carol&amp;quot;,&amp;quot;Sara&amp;quot;]
&lt;/code>&lt;/pre>
&lt;p>اضافه کردن مقدار جدید به انتهای آرایه و null کردن سایر سلول‌های آرایه که بین انتهای آرایه و آخرین سلولی که دارای مقدار مشخص بوده است :&lt;/p>
&lt;pre>&lt;code class="language-go">value, _ := sjson.Set(`{&amp;quot;friends&amp;quot;:[&amp;quot;Andy&amp;quot;,&amp;quot;Carol&amp;quot;]}`, &amp;quot;friends.4&amp;quot;, &amp;quot;Sara&amp;quot;)
println(value)
// Output:
// {&amp;quot;friends&amp;quot;:[&amp;quot;Andy&amp;quot;,&amp;quot;Carol&amp;quot;,null,null,&amp;quot;Sara&amp;quot;]
&lt;/code>&lt;/pre>
&lt;p>حذف کردن یک مقدار:&lt;/p>
&lt;pre>&lt;code class="language-go">value, _ := sjson.Delete(`{&amp;quot;name&amp;quot;:{&amp;quot;first&amp;quot;:&amp;quot;Sara&amp;quot;,&amp;quot;last&amp;quot;:&amp;quot;Anderson&amp;quot;}}`, &amp;quot;name.first&amp;quot;)
println(value)
// Output:
// {&amp;quot;name&amp;quot;:{&amp;quot;last&amp;quot;:&amp;quot;Anderson&amp;quot;}}
&lt;/code>&lt;/pre>
&lt;p>حذف کردن مقادیر آرایه ای:&lt;/p>
&lt;pre>&lt;code class="language-go">value, _ := sjson.Delete(`{&amp;quot;friends&amp;quot;:[&amp;quot;Andy&amp;quot;,&amp;quot;Carol&amp;quot;]}`, &amp;quot;friends.1&amp;quot;)
println(value)
// Output:
// {&amp;quot;friends&amp;quot;:[&amp;quot;Andy&amp;quot;]}
&lt;/code>&lt;/pre>
&lt;p>حذف کردن انتهای آرایه:&lt;/p>
&lt;pre>&lt;code class="language-go">value, _ := sjson.Delete(`{&amp;quot;friends&amp;quot;:[&amp;quot;Andy&amp;quot;,&amp;quot;Carol&amp;quot;]}`, &amp;quot;friends.-1&amp;quot;)
println(value)
// Output:
// {&amp;quot;friends&amp;quot;:[&amp;quot;Andy&amp;quot;]}
&lt;/code>&lt;/pre></description></item><item><author/><title>4.9 آموزش کار با toml</title><link>https://book.gofarsi.ir/chapter-4/work-with-toml-file-in-go/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/work-with-toml-file-in-go/</guid><description>&lt;h2 id="491-مقدمه">
4.9.1 مقدمه
&lt;a class="anchor" href="#491-%d9%85%d9%82%d8%af%d9%85%d9%87">#&lt;/a>
&lt;/h2>
&lt;p>فایل‌های TOML یک نمونه از فایل‌های پیکربندی هستند که در سیستم‌های مدرن مورد استفاده قرار می‌گیرند، این فایل‌ها به صورت متنی و قابل خواندن برای انسان و در عین حال قابل پردازش برای ماشین طراحی شده‌اند.&lt;/p>
&lt;p>TOML مخفف کلمات (Tom&amp;rsquo;s Obvious, Minimal Language) می‌باشد. جمعیت بزرگتری از افراد آن را مفسرند به این شکل که TOML ابزاری ساده برای پیکربندی بسیار درون‌فرمانی است. این فرمت فایل متنی دارای مقادیر شبیه به دیکشنری بوده و در بسیاری از نرم‌افزارها، به‌طور خاص در نرم‌افزارهای ساخته شده با golang بسیار به‌کار می‌رود.&lt;/p>
&lt;p>مثال زیر یک فایل TOML معتبر را نمایش می‌دهد:&lt;/p>
&lt;pre>&lt;code class="language-toml">[database]
server = &amp;quot;localhost&amp;quot;
port = 3306
user = &amp;quot;username&amp;quot;
password = &amp;quot;password&amp;quot;
database = &amp;quot;myDB&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>در این مثال، تمام اطلاعات پیکربندی مربوط به یک پایگاه‌داده وجود دارد (server، port، user و غیره)، و به صورت مشخصی تعریف شده‌اند، به طوری که برای برنامه‌نویسی با استفاده از این پیکربندی بسیار سرعت‌بخش خواهد بود. از آنجا که فایل TOML قابل‌خواندی و ویرایش توسط انسان است، برنامه‌نویسی با این نوع فایل‌ها آسان و قابل فهم خواهد بود.&lt;/p>
&lt;h2 id="492-کار-با-marshal-و-unmarshal-پکیج-toml">
4.9.2 کار با marshal و unmarshal پکیج toml
&lt;a class="anchor" href="#492-%da%a9%d8%a7%d8%b1-%d8%a8%d8%a7-marshal-%d9%88-unmarshal-%d9%be%da%a9%db%8c%d8%ac-toml">#&lt;/a>
&lt;/h2>
&lt;p>پکیج &lt;code>toml&lt;/code> در زبان Go، حاوی توابع &lt;code>Marshal&lt;/code> و &lt;code>Unmarshal&lt;/code> برای تبدیل داده‌های Go به فرمت TOML و برعکس می‌باشد.&lt;/p>
&lt;h3 id="4921-marshal">
4.9.2.1 Marshal
&lt;a class="anchor" href="#4921-marshal">#&lt;/a>
&lt;/h3>
&lt;p>تابع &lt;code>Marshal&lt;/code> برای تبدیل یک متغیر ساخته شده در Go به فرمت TOML مورد استفاده قرار می‌گیرد. برای استفاده از این تابع، باید داده‌های خود را به یک متغیر با نوع &lt;code>interface{}&lt;/code> تبدیل کنید و سپس این متغیر را به تابع &lt;code>Marshal&lt;/code> بدهید.&lt;/p>
&lt;p>به عنوان مثال، برای تبدیل داده‌های &lt;code>map[string]interface{}&lt;/code> به فرمت TOML، می‌توانید این کد را به کار ببرید:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"github.com/BurntSushi/toml"
"fmt"
)
func main() {
data := map[string]interface{}{
"name": "John",
"email": "john@example.com",
"age": 22,
}
tomlData, err := toml.Marshal(data)
if err != nil {
panic(err)
}
fmt.Println(string(tomlData))
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>این کد یک دیکشنری ساده را تعریف می‌کند و سپس آن را به فرمت TOML تبدیل می‌کند. خروجی به صورت زیر خواهد بود:&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go run main.go
age = 22
email = &amp;quot;john@example.com&amp;quot;
name = &amp;quot;John&amp;quot;
&lt;/code>&lt;/pre>
&lt;h3 id="4922-unmarshal">
4.9.2.2 Unmarshal
&lt;a class="anchor" href="#4922-unmarshal">#&lt;/a>
&lt;/h3>
&lt;p>تابع &lt;code>Unmarshal&lt;/code>، برای تبدیل یک رشته فرمت TOML به داده‌های Go استفاده می‌شود. برای استفاده از این تابع، باید با استفاده از تابع &lt;code>ioutil.ReadFile&lt;/code>، فایل TOML مورد نظر را بخوانید و سپس رشته خوانده‌شده را به تابع &lt;code>Unmarshal&lt;/code> بدهید.&lt;/p>
&lt;p>به عنوان مثال، برای خواندن یک فایل TOML و تبدیل آن به یک دیکشنری در Go، می‌توانید این کد را به کار ببرید:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"github.com/BurntSushi/toml"
"fmt"
"io/ioutil"
)
type Person struct {
Name string
Email string
Age int
}
func main() {
data, err := ioutil.ReadFile("file.toml")
if err != nil {
panic(err)
}
var person Person
if _, err := toml.Decode(string(data), &amp;person); err != nil {
panic(err)
}
fmt.Printf("%#v\n", person)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>این کد یک فایل TOML با فرمت زیر را می‌خواند و مقادیر موجود در آن را به داده‌های Go مناسب تبدیل می‌کند:&lt;/p>
&lt;pre>&lt;code class="language-toml">name = &amp;quot;John&amp;quot;
email = &amp;quot;john@example.com&amp;quot;
age = 22
&lt;/code>&lt;/pre>
&lt;p>خروجی به صورت زیر خواهد بود:&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go run main.go
main.Person{Name:&amp;quot;John&amp;quot;, Email:&amp;quot;john@example.com&amp;quot;, Age:22}
&lt;/code>&lt;/pre>
&lt;h2 id="493-تبدیل-struct-به-toml-و-بلعکس">
4.9.3 تبدیل struct به toml و بلعکس
&lt;a class="anchor" href="#493-%d8%aa%d8%a8%d8%af%db%8c%d9%84-struct-%d8%a8%d9%87-toml-%d9%88-%d8%a8%d9%84%d8%b9%da%a9%d8%b3">#&lt;/a>
&lt;/h2>
&lt;p>برای تبدیل یک &lt;code>struct&lt;/code> به فرمت TOML و بلعکس، می‌توان از تابع‌های &lt;code>Marshal&lt;/code> و &lt;code>Unmarshal&lt;/code> پکیج &lt;code>toml&lt;/code> استفاده کرد. در این روش، فیلدهای &lt;code>struct&lt;/code> بر اساس نام آن‌ها و به صورت حروف کوچک در فایل TOML با نام فیلد متناظر ذخیره می‌شوند.&lt;/p>
&lt;p>همچنین می‌توان از تگ‌ها در داخل &lt;code>struct&lt;/code> برای تعیین نام فیلد در فایل TOML استفاده کرد. با استفاده از تگ &lt;code>toml:&amp;quot;name&amp;quot;&lt;/code> می‌توان نامی دلخواه برای فیلد در فایل TOML مشخص کرد. همچنین می‌توان از تگ‌های دیگری مانند &lt;code>toml:&amp;quot;omitempty&amp;quot;&lt;/code> برای اجباری نبودن یک فیلد در فایل TOML استفاده کرد.&lt;/p>
&lt;p>به عنوان مثال، فرض کنید یک &lt;code>struct&lt;/code> به نام &lt;code>Person&lt;/code> با فیلدهای &lt;code>Name&lt;/code>، &lt;code>Email&lt;/code>و &lt;code>Age&lt;/code> داریم. با استفاده از تگ‌ها، نام فیلدها در فایل TOML و پیش‌فرض برای آن‌ها مشخص می‌شود.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"github.com/BurntSushi/toml"
"fmt"
)
type Person struct {
Name string `toml:"name"`
Email string `toml:"email,omitempty"`
Age int `toml:"age"`
}
func main() {
// Marshaling from struct to TOML
person := Person{Name: "John", Age: 30}
tomlData, err := toml.Marshal(person)
if err != nil {
panic(err)
}
fmt.Println(string(tomlData))
// Unmarshaling from TOML to struct
var p Person
if _, err := toml.Decode(string(tomlData), &amp;p); err != nil {
panic(err)
}
fmt.Printf("%#v\n", p)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در این مثال، &lt;code>struct&lt;/code> با نام &lt;code>Person&lt;/code> تعریف شده و از تگ برای نام‌گذاری فیلدها استفاده شده است. در تابع &lt;code>main&lt;/code>، ابتدا از متد &lt;code>Marshal&lt;/code> پکیج &lt;code>toml&lt;/code> برای تبدیل یک شیء &lt;code>Person&lt;/code> به فرمت TOML استفاده شده است. سپس با استفاده از متد &lt;code>Decode&lt;/code> از پکیج &lt;code>toml&lt;/code>، فایل TOML به داخل شیء &lt;code>Person&lt;/code> تبدیل می‌شود.&lt;/p>
&lt;p>خروجی کد بالا به صورت زیر است:&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go run main.go
name = &amp;quot;John&amp;quot;
age = 30
main.Person{Name:&amp;quot;John&amp;quot;, Email:&amp;quot;&amp;quot;, Age:30}
&lt;/code>&lt;/pre>
&lt;p>همان‌طور که مشاهده می‌کنید، نام فیلدها در فایل TOML با تگ‏های تعیین‌شده در &lt;code>struct&lt;/code> مطابقت می‌کند. همچنین با توجه به تگ &lt;code>omitempty&lt;/code> که در فیلد &lt;code>Email&lt;/code> وجود دارد، این فیلد در فایل TOML نمایش داده نشده است، چرا که در شی &lt;code>person&lt;/code> مقداری برای آن تعریف نشده بود.&lt;/p></description></item><item><author/><title>4.10 آموزش کار با yaml</title><link>https://book.gofarsi.ir/chapter-4/work-with-yaml-file-in-go/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/work-with-yaml-file-in-go/</guid><description>&lt;h2 id="4101-مقدمه">
4.10.1 مقدمه
&lt;a class="anchor" href="#4101-%d9%85%d9%82%d8%af%d9%85%d9%87">#&lt;/a>
&lt;/h2>
&lt;p>YAML یک زبان فراهم کننده ساختار پذیر برای نمایش اطلاعات است که در قالب متن موجود می‌باشد. این زبان ابتدا برای نوشتن سند‌های XML توسعه یافت که با پیشرفت کاربردهای آن به محل جایگزینی برای فرمت‌های رایجی همچون JSON و اقلیتاً TOML تبدیل شده است.&lt;/p>
&lt;p>این فرمت در صنعت‌های مختلف مورد استفاده و ستوده شده ‌است، مانند ذخیره سازی تنظیمات سیستمی، فایل‌های کانفیگ مختلف، فایل‌های داده و &amp;hellip; . همچنین به خاطر قابل خواندن بودن برای انسان، استفاده از YAML در فایل‌هایی که باید توسط بشر خوانده شوند مانند فایل‌های خودرو، پروژه و&amp;hellip; صورت گرفته است.&lt;/p>
&lt;p>یکی از نمونه‌های کاربردی YAML، استفاده از آن در فایل‌های کانفیگ ‌Docker است. در فایل &lt;code>docker-compose.yaml&lt;/code>، بخش‌های مختلفی از یک سرویس در قالب Block mapping و با کلید‌های خاصی مانند &lt;code>version&lt;/code>، &lt;code>services&lt;/code>، &lt;code>ports&lt;/code> و غیره تعریف شده است. این فرمت به طور کل شرکت‌های بزرگی مانند مایکروسافت، ای‌بی‌ای و گوگل، در محصولات خود به صورت فایل‌های YAML استفاده می‌کنند.&lt;/p>
&lt;p>بنابراین، می‌توان گفت YAML یک فرمت متنی ساده و پذیرفتنی است که در بسیاری از پروژه‌های نرم‌افزاری استفاده می‌شود، به خاطر پشتیبانی از انواع داده‌ها و ساختارهای مختلف، قابلیت خواندن و نوشتن آسان برای انسان و قابل استفاده در زبان‌های مختلفی استفاده از YAML در صنایع مختلفی از جمله فناوری‌های اطلاعات، اینترنت اشیا و&amp;hellip; رایج است.&lt;/p>
&lt;h2 id="4102-کار-با-marshal-و-unmarshal-پکیج-yaml">
4.10.2 کار با marshal و unmarshal پکیج yaml
&lt;a class="anchor" href="#4102-%da%a9%d8%a7%d8%b1-%d8%a8%d8%a7-marshal-%d9%88-unmarshal-%d9%be%da%a9%db%8c%d8%ac-yaml">#&lt;/a>
&lt;/h2>
&lt;p>پکیج YAML در زبان Go شامل توابع Marshal و Unmarshal برای تبدیل داده‌های Go به فرمت YAML و بالعکس می‌شود. استفاده از این توابع بسیار ساده است و می‌توان به سرعت با استفاده از ویژگی‌های زبان Go به داده‌ها دسترسی پیدا کرد.&lt;/p>
&lt;p>برای مثال، فرض کنید یک پرونده YAML با محتوای زیر داریم:&lt;/p>
&lt;pre>&lt;code class="language-yaml">name: John
age: 25
isStudent: true
&lt;/code>&lt;/pre>
&lt;h3 id="41021-marshal">
4.10.2.1 Marshal
&lt;a class="anchor" href="#41021-marshal">#&lt;/a>
&lt;/h3>
&lt;p>همچنین، می‌توان از تابع Marshal برای تبدیل ساختار داده‌ای Go به فرمت YAML استفاده کرد. به عنوان مثال، برای تبدیل ساختار Person به فرمت YAML می‌توان از کد زیر استفاده کرد:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"fmt"
"gopkg.in/yaml.v2"
"log"
)
func main() {
person := Person{
Name: "John",
Age: 25,
IsStudent: true,
}
yamlData, err := yaml.Marshal(&amp;person)
if err != nil {
log.Fatalf("error: %v", err)
}
fmt.Printf("%s", string(yamlData))
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در این کد، یک شیء از ساختار Person را ایجاد می کنیم و سپس از تابع Marshal برای تبدیل آن به فرمت YAML استفاده می کنیم. سپس محتوای YAML را به کمک تابع Printf چاپ می کنیم.&lt;/p>
&lt;p>به این ترتیب پکیج YAML از امکانات و قابلیت بالایی برای کد نویسی و کار با فرمت YAML در زبان Go برخوردار می‌باشد.&lt;/p>
&lt;h3 id="41022-unmarshal">
4.10.2.2 Unmarshal
&lt;a class="anchor" href="#41022-unmarshal">#&lt;/a>
&lt;/h3>
&lt;p>می‌توانیم این پرونده را به کمک تابع Unmarshal به یک ساختار Go تبدیل کنیم. برای این کار، ابتدا نیاز است که یک ساختار داده‌ای برای ذخیره اطلاعات YAML تعریف کنیم. در این حالت، می‌توانیم از ساختار زیر استفاده کنیم:&lt;/p>
&lt;pre>&lt;code class="language-go">type Person struct {
Name string `yaml:&amp;quot;name&amp;quot;`
Age int `yaml:&amp;quot;age&amp;quot;`
IsStudent bool `yaml:&amp;quot;isStudent&amp;quot;`
}
&lt;/code>&lt;/pre>
&lt;p>حالا می توانیم از تابع Unmarshal برای تبدیل داده‌ی YAML به ساختار Go استفاده کنیم:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"fmt"
"gopkg.in/yaml.v2"
"log"
)
type Person struct {
Name string `yaml:"name"`
Age int `yaml:"age"`
IsStudent bool `yaml:"isStudent"`
}
func main() {
yamlData := `
name: John
age: 25
isStudent: true
`
var person Person
err := yaml.Unmarshal([]byte(yamlData), &amp;person)
if err != nil {
log.Fatalf("error: %v", err)
}
fmt.Printf("Name: %s\nAge: %d\nIsStudent: %v", person.Name, person.Age, person.IsStudent)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>این کد پرونده YAML را به متغیر yamlData منتسب کرده، از تابع Unmarshal برای تجزیه و تحلیل داده‌های YAML استفاده و ساختار Person را با مقادیر معادل پر کرده‌است. سپس جزئیات این ساختار را چاپ می‌کنیم.&lt;/p></description></item><item><author/><title>4.11 آموزش کار با csv</title><link>https://book.gofarsi.ir/chapter-4/work-with-csv-file-in-go/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/work-with-csv-file-in-go/</guid><description>&lt;h2 id="4111-مقدمه">
4.11.1 مقدمه
&lt;a class="anchor" href="#4111-%d9%85%d9%82%d8%af%d9%85%d9%87">#&lt;/a>
&lt;/h2>
&lt;p>CSV یکی از فرمت‌های متداول برای ذخیره داده‌های جدولی است. خروجی اکثر برنامه‌های قابلیت دستکاری داده، همراه با نرم‌افزار‌های آفیس، به فرمت CSV تولید می‌شود. فرمت CSV چندین ستون در یک ردیف را با استفاده از کاما (,) جدا کرده و هر ردیف را با استفاده از عبارت جدید (newline) جدا می‌کند.&lt;/p>
&lt;p>در زبان برنامه‌نویسی Go نیز پکیج encoding/csv وجود دارد که در آن، توابع مربوط به خواندن و نوشتن داده‌های CSV به صورت دستی یا از طریق پرونده‌ها فراهم شده است. با استفاده از این پکیج، می‌توان داده‌های CSV را به داده‌های جدولی تبدیل کرد و برعکس.&lt;/p>
&lt;p>به عنوان مثال، در ادامه یک فایل CSV به نام &amp;ldquo;data.csv&amp;rdquo; حاوی اطلاعات چند شخص را در نظر بگیرید:&lt;/p>
&lt;pre>&lt;code class="language-csv">Name,Age,City
John,25,New York
Jane,30,San Francisco
Bob,40,Los Angeles
&lt;/code>&lt;/pre>
&lt;h2 id="4112-نحوه-خواندن-فایل-csv">
4.11.2 نحوه خواندن فایل csv
&lt;a class="anchor" href="#4112-%d9%86%d8%ad%d9%88%d9%87-%d8%ae%d9%88%d8%a7%d9%86%d8%af%d9%86-%d9%81%d8%a7%db%8c%d9%84-csv">#&lt;/a>
&lt;/h2>
&lt;p>برای خواندن فایل csv می‌توان با استفاده از پکیج encoding/csv پرونده CSV را باز کرد:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"encoding/csv"
"fmt"
"os"
)
func main() {
f, err := os.Open("data.csv")
if err != nil {
panic(err)
}
r := csv.NewReader(f)
records, err := r.ReadAll()
if err != nil {
panic(err)
}
for _, row := range records {
for _, col := range row {
fmt.Print(col, "\t")
}
fmt.Println()
}
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در این کد، تابع os.Open برای باز کردن پرونده CSV استفاده می‌شود. یک رابط csv.Reader ایجاد شده و یک رشته ساختارمند، پرونده CSV را می‌خواند. سپس با استفاده از یک حلقه، داده‌های جدولی چاپ می‌شود.&lt;/p>
&lt;p>فراداده‌های CSV بسیار گسترده هستند و می‌توانند شامل شماره دسته، توضیحات، یادداشت‌های شخصی و غیره باشند. برای کار با این نوع داده‌ها، پکیج encoding/csv امکاناتی مانند تنظیمات csv.Reader را فراهم می‌کند، که در آن، می‌توانیم تنظیماتی مانند علامت‌گذاری مناسب فایل CSV و دیگر علامت‌گذاری‌ها را بهبود ببخشیم.&lt;/p>
&lt;h2 id="4113--readall-فایل-csv">
4.11.3 ReadAll فایل csv
&lt;a class="anchor" href="#4113--readall-%d9%81%d8%a7%db%8c%d9%84-csv">#&lt;/a>
&lt;/h2>
&lt;p>تابع ReadAll تمام رکوردهای باقی مانده را از reader می خواند. هر رکورد یک قسمتی از fieldها است.&lt;/p>
&lt;pre>&lt;code class="language-csv">first_name,last_name,occupation
John,Doe,gardener
Lucy,Smith,teacher
Brian,Bethamy,programmer
&lt;/code>&lt;/pre>
&lt;p>نام این فایل users.csv است. خط اول نام ستون ها هستند.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"encoding/csv"
"fmt"
"log"
"os"
)
type User struct {
firstName string
lastName string
occupation string
}
func main() {
records, err := readData("users.csv")
if err != nil {
log.Fatal(err)
}
for _, record := range records {
user := User{
firstName: record[0],
lastName: record[1],
occupation: record[2],
}
fmt.Printf("%s %s is a %s\n", user.firstName, user.lastName,
user.occupation)
}
}
func readData(fileName string) ([][]string, error) {
f, err := os.Open(fileName)
if err != nil {
return [][]string{}, err
}
defer f.Close()
r := csv.NewReader(f)
// skip first line
if _, err := r.Read(); err != nil {
return [][]string{}, err
}
records, err := r.ReadAll()
if err != nil {
return [][]string{}, err
}
return records, nil
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>اسم فایل بالا read_all.go می‌باشد و این مثال فایل users.csv را می خواند. هر line به یک &lt;code>User&lt;/code> type را بر می‌گرداند.&lt;/p>
&lt;pre>&lt;code class="language-go">// skip first line
if _, err := r.Read(); err != nil {
return [][]string{}, err
}
&lt;/code>&lt;/pre>
&lt;p>در اینجا از خط اول که شامل نام ستون هاست می گذریم.&lt;/p>
&lt;pre>&lt;code class="language-go">records, err := r.ReadAll()
&lt;/code>&lt;/pre>
&lt;p>در نهایت همه رکوردها را یک جا با ReadAll دریافت می کنیم.&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go run read_all.go
John Doe is a gardener
Lucy Smith is a teacher
Brian Bethamy is a programmer
&lt;/code>&lt;/pre>
&lt;h2 id="4114--delimiter-csv-دلخواه">
4.11.4 delimiter CSV دلخواه
&lt;a class="anchor" href="#4114--delimiter-csv-%d8%af%d9%84%d8%ae%d9%88%d8%a7%d9%87">#&lt;/a>
&lt;/h2>
&lt;p>علیرغم نام CSV ، CSV ممکن است دارای جداکننده های دیگری غیر از کاما باشد. این به دلیل استاندارد نبودن قالب CSV است.&lt;/p>
&lt;pre>&lt;code class="language-csv"># user.csv
# this is users.csv file
John;Doe;gardener
Lucy;Smith;teacher
Brian;Bethamy;programmer
&lt;/code>&lt;/pre>
&lt;p>در فایل users.csv فیلدها با نقطه ویرگول از هم جدا شده اند. این فایل حاوی یک comment نیز می‌باشد.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">//different_delimiter.go//
package main
import (
"encoding/csv"
"fmt"
"log"
"os"
)
func main() {
f, err := os.Open("users.csv")
if err != nil {
log.Fatal(err)
}
r := csv.NewReader(f)
r.Comma = ';'
r.Comment = '#'
records, err := r.ReadAll()
if err != nil {
log.Fatal(err)
}
fmt.Print(records)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>این مثال تمام داده های این فایل را می خواند.&lt;/p>
&lt;pre>&lt;code class="language-go">r := csv.NewReader(f)
r.Comma = ';'
r.Comment = '#'
&lt;/code>&lt;/pre>
&lt;p>در اینجا separator و کاراکتر comment را تنظیم می کنیم تا package بداند چگونه فایل را parse یا تجریه تحلیل کند.&lt;/p>
&lt;h2 id="4115-نوشتن-csv">
4.11.5 نوشتن CSV
&lt;a class="anchor" href="#4115-%d9%86%d9%88%d8%b4%d8%aa%d9%86-csv">#&lt;/a>
&lt;/h2>
&lt;p>تابع Write یک رکورد CSV را برای writer می نویسد. رکورد برشی از strings است که هر string یک فیلد است. write ها buffer شده هستند، بنابراین باید Flush فراخوانی شود تا اطمینان حاصل شود که رکورد برای writer اصلی نوشته شده است.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">//write_fun.go//
package main
import (
"encoding/csv"
"log"
"os"
)
func main() {
records := [][]string{
{"first_name", "last_name", "occupation"},
{"John", "Doe", "gardener"},
{"Lucy", "Smith", "teacher"},
{"Brian", "Bethamy", "programmer"},
}
f, err := os.Create("users.csv")
defer f.Close()
if err != nil {
log.Fatalln("failed to open file", err)
}
w := csv.NewWriter(f)
defer w.Flush()
for _, record := range records {
if err := w.Write(record); err != nil {
log.Fatalln("error writing record to file", err)
}
}
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در مثال بالا، چند رکورد را با تابع Write در فایل users.csv نوشتیم.&lt;/p>
&lt;h2 id="4116-نوشتن-writeall-csv">
4.11.6 نوشتن WriteAll CSV
&lt;a class="anchor" href="#4116-%d9%86%d9%88%d8%b4%d8%aa%d9%86-writeall-csv">#&lt;/a>
&lt;/h2>
&lt;p>تابع WriteAll چندین رکورد CSV را با استفاده از Write برای writer می‌نویسد و سپس Flush را فراخوانی می‌کند.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">//write_all.go//
package main
import (
"encoding/csv"
"log"
"os"
)
func main() {
records := [][]string{
{"first_name", "last_name", "occupation"},
{"John", "Doe", "gardener"},
{"Lucy", "Smith", "teacher"},
{"Brian", "Bethamy", "programmer"},
}
f, err := os.Create("users.csv")
defer f.Close()
if err != nil {
log.Fatalln("failed to open file", err)
}
w := csv.NewWriter(f)
err = w.WriteAll(records) // calls Flush internally
if err != nil {
log.Fatal(err)
}
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در نهایت ما چند رکورد را در یک لحظه با WriteAll می نویسیم.&lt;/p></description></item><item><author/><title>4.12 آموزش کار با ini</title><link>https://book.gofarsi.ir/chapter-4/work-with-ini-file-in-go/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/work-with-ini-file-in-go/</guid><description>&lt;p>بطور خلاصه فایل های ini.* جهت ذخیره تنظیمات مختلف استفاده می شود تنظیماتی مثل: آدرس خاص در شبکه، اطلاعات ورود به سیستم های مختلف و موارد از این قبیل.&lt;/p>
&lt;p>برای شروع ساختار پروژه ما به این شکل است&lt;/p>
&lt;pre>&lt;code class="language-shell">$ mkdir -p /tmp/ini
$ cd /tmp/ini
$ touch my.ini main.go
$ tree . .
├── main.go
└── my.ini
&lt;/code>&lt;/pre>
&lt;p>در پروژه دو فایل ایجاد کردیم یکی فایل اصلی برنامه main.go و دیگری my.ini که می خواهیم تنظیمات برنامه را در آن نگهداری کنیم. محتوای داخل فایل ini را بصورت ذیل تعریف کرده ایم&lt;/p>
&lt;pre>&lt;code class="language-shell"># possible values : production, development
app_mode = development
[paths]
# Path to where grafana can store temp files, sessions, and the sqlite3 db (if that is used)
data = /home/git/grafana
[server]
# Protocol (http or https)
protocol = http
# The http port to use
http_port = 9999
# Redirect to correct domain if host header does not match domain # Prevents DNS rebinding attacks
enforce_domain = true
&lt;/code>&lt;/pre>
&lt;p>همانطور که در توصیف کد آمده است 5 مقدار مختلف داخل فایل آمده است برخی را توضیح می دهیم&lt;/p>
&lt;ol>
&lt;li>مقدار app_mode که در واقع میخواهیم جهت تشخیص مود توسعه استفاده کنیم برای مثال به کمک این مقدار میخواهیم لاگ های برنامه در پروداکشن نمایش داده نشود ولی در زمان توسعه دهنده بتوانیم لاگ هایم مختلف را مشاهده کنیم.&lt;/li>
&lt;li>قسمت بعد protocol است که کاملا مشخص می باشد و در واقع میخواهیم پروتکل استفاده شده را مشخص کنیم&lt;/li>
&lt;li>حط بعد شماره پورت مورد استفاده برنامه است که مقدار 9999 می باشد&lt;/li>
&lt;/ol>
&lt;p>مقادیر وارد شده صرفا برای مثال می باشد و می توان هر مقداری را که در برنامه نیاز دارید ایجاد کنید.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"fmt"
"os"
"gopkg.in/ini.v1"
)
func main() {
cfg, err := ini.Load("my.ini")
if err != nil {
fmt.Printf("Fail to read file: %v", err)
os.Exit(1)
}
// Classic read of values, default section can be represented as empty string
fmt.Println("App Mode:", cfg.Section("").Key("app_mode").String())
fmt.Println("Data Path:", cfg.Section("paths").Key("data").String())
// Let's do some candidate value limitation
fmt.Println("Server Protocol:",
cfg.Section("server").Key("protocol").In("http", []string{"http", "https"}))
// Value read that is not in candidates will be discarded and fall back to given default value
fmt.Println("Email Protocol:", cfg.Section("server").Key("protocol").In("smtp", []string{"imap", "smtp"}))
// Try out auto-type conversion
fmt.Printf("Port Number: (%[1]T) %[1]d\n", cfg.Section("server").Key("http_port").MustInt(9999))
fmt.Printf("Enforce Domain: (%[1]T) %[1]v\n", cfg.Section("server").Key("enforce_domain").MustBool(false))
// Now, make some changes and save it
cfg.Section("").Key("app_mode").SetValue("production") cfg.SaveTo("my.ini.local")
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>کد بالا به اندازه کافی شفاف و ساده است که نیازی به توضیح بیشتر ندارد در ابتدا نیاز است تا بسته &amp;ldquo;gopkg.in/ini.v1&amp;rdquo; را به برنامه اضافه کنیم سپس با متد load فایل کانفیگ موجود را به حافظه بارگذاری می کنیم تا محتوای آن را بخوانیم و خط های بعد مقادیر آن را میخوانیم در خط پایانی نیز مقدار app_mode را به production تغییر دادیم و در فایل جدیدی به نام my.ini.local ذخیره کردیم .&lt;/p>
&lt;p>می توانیم به شکل های مختلف یک فایل را بارگذاری یا ایجاد کنیم به مثال ذیل توجه کنید:&lt;/p>
&lt;pre>&lt;code class="language-go">cfg, err := ini.Load( []byte(&amp;quot;raw data&amp;quot;), // Raw data
&amp;quot;filename&amp;quot;, // File
ioutil.NopCloser(bytes.NewReader([]byte(&amp;quot;some other data&amp;quot;))),
)
&lt;/code>&lt;/pre>
&lt;p>در این قطعه کد ما تنظیمات خود را به 3 شکل می توانیم فراخوانی کنیم رشته، فایل و io.ReadCloser البته در صورت نیاز می توانیم یک فایل خالی در فضای حافظه بشکل ذیل نیز ایجاد کنیم.&lt;/p>
&lt;pre>&lt;code class="language-go">cfg := ini.Empty()
&lt;/code>&lt;/pre>
&lt;p>در ابتدا می توانید هر تعداد فایل ini را بارگذاری و یا فرخوانی کنید ولیکن مواقعی نیاز دارید که یک منبع دیگر به آنها اضافه کنید که برای این منظور می توانید از دستور Append استفاده نمائید&lt;/p>
&lt;pre>&lt;code class="language-go">err := cfg.Append(&amp;quot;other file&amp;quot;, []byte(&amp;quot;other raw data&amp;quot;))
&lt;/code>&lt;/pre>
&lt;p>و یا مواقعی از چند منبع اقدام به بارگذاری می نمائید که احتمال دارد برخی از آن منابع خطا در بارگذاری دهد در این شرایط بهتر از تابع   ()LooseLoadd استفاده کنید&lt;/p>
&lt;pre>&lt;code class="language-go">cfg, err := ini.LooseLoad(&amp;quot;filename&amp;quot;, &amp;quot;filename_404&amp;quot;)
&lt;/code>&lt;/pre>
&lt;p>و در نهایت می توانید پس از تغییرات دلخواه فایل را بصورت ذیل ذخیره نمائید&lt;/p>
&lt;pre>&lt;code class="language-go">// ...
err = cfg.SaveTo(&amp;quot;my.ini&amp;quot;)
err = cfg.SaveToIndent(&amp;quot;my.ini&amp;quot;, &amp;quot;\t&amp;quot;)
&lt;/code>&lt;/pre>
&lt;p>همانطور که در بالا دید برای دسترسی به یک قسمت از فایل ما از تابع Section بصورت ذیل استفاده می کنیم&lt;/p>
&lt;pre>&lt;code class="language-go">sec, err := cfg.GetSection(&amp;quot;section name&amp;quot;)
&lt;/code>&lt;/pre>
&lt;p>که در اینجا &amp;ldquo;section name&amp;rdquo; نام قطعه کد ما در فایل تنظیمات است.
برخی از توابع مهم این بسته عبارت اند از :
1.&lt;/p>
&lt;pre>&lt;code class="language-go">err := cfg.NewSection(&amp;quot;new section&amp;quot;)
&lt;/code>&lt;/pre>
&lt;p>جهت ایجاد قطعه جدید
2.&lt;/p>
&lt;pre>&lt;code class="language-go">secs := cfg.Sections()
names := cfg.SectionStrings()
&lt;/code>&lt;/pre>
&lt;p>برای بدست آوردن تمامی قطعات داخل فایل
3.&lt;/p>
&lt;pre>&lt;code class="language-go">key, err := cfg.Section(&amp;quot;&amp;quot;).GetKey(&amp;quot;app_mode&amp;quot;)
&lt;/code>&lt;/pre>
&lt;p>برای بدست آوردن key یک section بطور مثال &amp;ldquo;app_mode&amp;rdquo;
4.&lt;/p>
&lt;pre>&lt;code class="language-go">key, err := cfg.Section(&amp;quot;&amp;quot;).HasKey(&amp;quot;app_mode&amp;quot;)
&lt;/code>&lt;/pre>
&lt;p>برای بررسی وجود یک key
5.&lt;/p>
&lt;pre>&lt;code class="language-go">key, err := cfg.Section(&amp;quot;&amp;quot;).NewKey(&amp;quot;name&amp;quot;, &amp;quot;value&amp;quot;)
&lt;/code>&lt;/pre>
&lt;p>برای ایجاد یک key جدید&lt;/p></description></item><item><author/><title>4.13 آموزش کار با environment variable</title><link>https://book.gofarsi.ir/chapter-4/work-with-environment-variable/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/work-with-environment-variable/</guid><description>&lt;p>Environment Variables یا متغیرهای محیطی، متغیرهایی هستند که در فضای محیطی سیستم عامل مشخص شده‌اند. این متغیرها، شامل اطلاعاتی مانند مسیر فایل‌ها، تنظیمات سیستم، ترجیحات و تعیینات ساده و دیگر اطلاعات مورد استفاده توسط برنامه‌ها هستند.&lt;/p>
&lt;p>به عنوان مثال، در سیستم عامل لینوکس، PATH یک متغیر محیطی است که شامل یک فهرست از دایرکتوری‌هایی است که سیستم به دنبال فایل‌ها و برنامه‌ها می‌گردد. برای دسترسی به این متغیر، می‌توان از دستور زیر در خط فرمان استفاده کرد:&lt;/p>
&lt;pre>&lt;code>echo $PATH
&lt;/code>&lt;/pre>
&lt;p>همچنین، در زبان برنامه‌نویسی Go نیز استفاده از Environment Variables بسیار رایج است. برای نمونه، تنظیمات پایگاه داده را می‌توان با استفاده از Environment Variables در برنامه اصلی تنظیم کرد. در این مثال بسیار کوتاه، متصل شدن به پایگاه داده با استفاده از متغیرهای محیطی بیان شده است:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"database/sql"
"os"
)
func main() {
db, err := sql.Open("postgres", os.Getenv("DATABASE_URL"))
if err != nil {
panic(err)
}
defer db.Close()
// Do something with the database
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در این مثال، پایگاه داده PostgreSQL از طریق پارامتر DATABASE_URL قابل تنظیم است. با استفاده از os.Getenv مقدار متغیر محیطی با همین نام به دست می‌آید و سپس به عنوان آرگومان به sql.Open ارائه می‌شود.&lt;/p>
&lt;p>استفاده از Environment Variables یک روش مدیریتی عالی برای محیط برنامه است. این روش، به برنامه‌ها امکان می‌دهد که بدون اینکه برای هر برنامه یک سری تنظیمات خاص وجود داشته باشد، با یک سری تنظیمات کلی کار کنند و به صورت پویا و گسترده پاسخگو باشند.&lt;/p>
&lt;h2 id="4131-نحوه-set-کردن">
4.13.1 نحوه set کردن
&lt;a class="anchor" href="#4131-%d9%86%d8%ad%d9%88%d9%87-set-%da%a9%d8%b1%d8%af%d9%86">#&lt;/a>
&lt;/h2>
&lt;p>در زبان برنامه‌نویسی Go، برای set کردن Environment Variables می‌توان از پکیج os استفاده کرد. برای مثال، برای تعیین متغیر محیطی با نام &amp;ldquo;DATABASE_URL&amp;rdquo; به مقدار &amp;ldquo;postgresql://localhost/mydb&amp;rdquo; می‌توانید از تابع os.Setenv استفاده کنید:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"fmt"
"os"
)
func main() {
err := os.Setenv("DATABASE_URL", "postgresql://localhost/mydb")
if err != nil {
panic(err)
}
fmt.Println("Environment variable set successfully")
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در این مثال، با استفاده از تابع os.Setenv، متغیر محیطی با نام DATABASE_URL و مقدار postgresql://localhost/mydb تنظیم شده است. اگر خطا رخ دهد، با استفاده از تابع panic خطا ثبت می‌شود. سپس یک پیام تاییدی برای نشان دادن موفقیت set کردن متغیر محیطی نمایش داده می‌شود.&lt;/p>
&lt;p>اگر بخواهید یک Environment Variable را به یک مقدار خالی تنظیم کنید، می‌توانید از تابع os.Unsetenv استفاده کنید. برای مثال، برای حذف متغیر محیطی DATABASE_URL، کد زیر را می‌توانید استفاده کنید:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"fmt"
"os"
)
func main() {
err := os.Unsetenv("DATABASE_URL")
if err != nil {
panic(err)
}
fmt.Println("Environment variable unset successfully")
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در این مثال، با استفاده از تابع os.Unsetenv، متغیر محیطی با نام DATABASE_URL حذف شده است. اگر خطا رخ دهد، با استفاده از تابع panic خطا ثبت می‌شود. سپس یک پیام تاییدی برای نشان دادن موفقیت unset کردن متغیر محیطی نمایش داده می‌شود.&lt;/p>
&lt;h2 id="4132-نحوه-get-کردن">
4.13.2 نحوه get کردن
&lt;a class="anchor" href="#4132-%d9%86%d8%ad%d9%88%d9%87-get-%da%a9%d8%b1%d8%af%d9%86">#&lt;/a>
&lt;/h2>
&lt;p>در زبان برنامه‌نویسی Go، برای get کردن Environment Variables می‌توان از پکیج os استفاده کرد. برای مثال، برای به دست آوردن مقدار متغیر محیطی با نام &amp;ldquo;DATABASE_URL&amp;rdquo; می‌توانید از تابع os.Getenv استفاده کنید:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"fmt"
"os"
)
func main() {
dbUrl := os.Getenv("DATABASE_URL")
fmt.Printf("Database URL: %s\n", dbUrl)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در این مثال، با استفاده از تابع os.Getenv، متغیر محیطی با نام DATABASE_URL به عنوان پارامتر به تابع ارسال شده و مقدار آن در یک متغیر به نام dbUrl ذخیره شده است. سپس با استفاده از تابع fmt.Printf، مقدار dbUrl به همراه یک پیام مشابه &amp;ldquo;Database URL: postgresql://localhost/mydb&amp;rdquo; نمایش داده می‌شود.&lt;/p>
&lt;p>اگر مقدار متغیر محیطی مورد نظر وجود نداشته باشد، تابع os.Getenv مقدار خالی برمی‌گرداند. لذا برای اطمینان از وجود مقدار متغیر محیطی، می‌توانید از تابع os.LookupEnv استفاده کنید. برای مثال، کد زیر چک می‌کند که آیا متغیر محیطی EMAIL تنظیم شده است یا خیر:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"fmt"
"os"
)
func main() {
email, ok := os.LookupEnv("EMAIL")
if ok {
fmt.Printf("Email address: %s\n", email)
} else {
fmt.Println("Email address is not set")
}
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در این مثال، با استفاده از تابع os.LookupEnv، متغیر محیطی با نام EMAIL برای وجود مقدار بررسی شده است. اگر مقدار موجود بود، با استفاده از تابع fmt.Printf، مقدار این متغیر به همراه یک پیام مشابه &amp;ldquo;Email address: &lt;a href="mailto:user@example.com">user@example.com&lt;/a>&amp;rdquo; نمایش داده می‌شود. در صورتی که مقداری برای این متغیر وجود نداشته باشد، با استفاده از تابع fmt.Println، یک پیام مشابه &amp;ldquo;Email address is not set&amp;rdquo; نمایش داده می‌شود.&lt;/p>
&lt;h2 id="4133-کار-با-فایل-env">
4.13.3 کار با فایل env.
&lt;a class="anchor" href="#4133-%da%a9%d8%a7%d8%b1-%d8%a8%d8%a7-%d9%81%d8%a7%db%8c%d9%84-env">#&lt;/a>
&lt;/h2>
&lt;p>فایل .env یک فایل متنی است که حاوی متغیرهای محیطی برای برنامه شما است. در Go، می‌توانیم از پکیج godotenv استفاده کنیم تا مقادیر متغیرهای محیطی را از فایل .env بخوانیم و در متغیرهای خود بارگذاری کنیم.&lt;/p>
&lt;p>برای استفاده از پکیج godotenv، ابتدا باید آن را با استفاده از دستور زیر نصب کنید:&lt;/p>
&lt;pre>&lt;code>go get github.com/joho/godotenv
&lt;/code>&lt;/pre>
&lt;p>سپس می‌توانید از تابع godotenv.Load() استفاده کنید تا متغیرهای محیطی از فایل .env خوانده شود. در زیر یک مثال برای استفاده از پکیج godotenv به همراه فایل .env نشان داده شده است:&lt;/p>
&lt;p>فرض کنید فایل .env شما به شکل زیر باشد:&lt;/p>
&lt;pre>&lt;code>DATABASE_URL=postgresql://localhost/mydb
API_KEY=AbCdEfGhIjKlMnOp
&lt;/code>&lt;/pre>
&lt;p>حال در کد Go خود، پکیج godotenv را import کرده و با استفاده از تابع godotenv.Load()، متغیرهای محیطی از فایل .env خوانده شده و در متغیرهای خود بارگذاری کنید:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"fmt"
"github.com/joho/godotenv"
"os"
)
func main() {
// Load environment variables from .env file
err := godotenv.Load()
if err != nil {
fmt.Println("Error loading .env file")
os.Exit(1)
}
// Get values of environment variables
dbUrl := os.Getenv("DATABASE_URL")
apiKey := os.Getenv("API_KEY")
// Print the values
fmt.Printf("Database URL: %s\n", dbUrl)
fmt.Printf("API Key: %s\n", apiKey)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در این مثال، با استفاده از تابع godotenv.Load()، متغیرهای محیطی از فایل .env خوانده شده و در متغیرهای خود بارگذاری شده‌اند. سپس با استفاده از تابع os.Getenv()، مقادیر این متغیرها به دست آمده و با استفاده از تابع fmt.Printf نمایش داده شده‌اند.&lt;/p>
&lt;p>با استفاده از این روش، مقادیری که در فایل .env تعریف شده‌اند، در زمان اجرای برنامه به راحتی قابل دسترس خواهند بود و این اجازه را به شما می‌دهد که مقادیر مورد نیاز را به راحتی تغییر دهید و حتی بدون تغییر کد، برنامه خود را در محیط‌های مختلف اجرا کنید.&lt;/p></description></item><item><author/><title>4.14 آموزش کار با regexp</title><link>https://book.gofarsi.ir/chapter-4/go-regular-expressions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/go-regular-expressions/</guid><description>&lt;p>مواقعی در کد نویسی دارید که نیاز هست تا یک عبارتی مثل شماره تلفن،کد پستی و یا شماره پاسپورت وارد شده را بصورت قاعده مند بررسی کنید به عبارتی کاربر نتواند برای فیلد شماره تلفن، کاراکتر غیر عددی وارد کند. در این مواقع بهتر است داده وارد شده بصورت قاعده مند بررسی شود. برای درک بهتر موضوع به رشته وارد شده توسط کاربر که می تواند سهوا باشد دقت کنید&lt;/p>
&lt;pre>&lt;code>+989121234#566
&lt;/code>&lt;/pre>
&lt;p>در این رشته کاربر مرتکب دو اشتباه شده است.&lt;/p>
&lt;ol>
&lt;li>شماره موبایل یک رقم بیشتر وارد شده است&lt;/li>
&lt;li>کاربر بجای رقم از علامت # استفاده کرده است&lt;/li>
&lt;/ol>
&lt;p>در چنین شرایطی روش های بررسی مرسوم داده پاسخگو نیست و بهتر است از &lt;span class="tooltip" data-tooltip="regular expression" ontouchend="toggleTooltip(this)"> عبارات با قاعده&lt;/span>
استفاده کنیم.&lt;/p>
&lt;p>در زبان برنامه نویسی Go بسته از پیش تعریف شده regexp برای اینکار وجود دارد.&lt;/p>
&lt;pre>&lt;code class="language-go">import (
&amp;quot;regexp&amp;quot;
)
&lt;/code>&lt;/pre>
&lt;p>برای شروع و درک بهتر مطلب اجازه دهید از یک مثال ساده شروع کنیم. میخواهیم بررسی کنیم آیا کاربر کارکتر نقطه [.] را وارد کرده است یا خیر .&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"fmt"
"regexp"
)
func main() {
sampleRegex := regexp.MustCompile("[.]")
match := sampleRegex.Match([]byte("."))
fmt.Println(match)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در کد فوق به کمک تابع MustCompile عبارت قاعده مند را دریافت می کنیم در صورتیکه عبارت وارد شده قابل قبول یا معتبر نباشد panic اتفاق خواهد افتاد . دقت داشته باشید که خود عبارت قاعده مند دارای استاندارد و چارچوب های مشخص است که بهتر است درصورت عدم اطلاع از ابتدا آن را &lt;a href="https://regexlearn.com/">بیاموزید&lt;/a>.&lt;/p>
&lt;p>دقت کنید که در کد فوق عبارت مد نظر خود را داخل [] قرار داده ایم و در خط بعد با تابع Match که مقدار مورد نظر را بصورت رشته ای از بایت ها به آن معرفی کرده ایم بررسی می کنیم که &amp;ldquo;.&amp;rdquo; در رشته وجود دارد یا خیر که خروجی این بررسی یک مقدار بولین بصورت ذیل است.&lt;/p>
&lt;pre>&lt;code>true
&lt;/code>&lt;/pre>
&lt;p>در واقع می توانید رشته های ساده را نیز با این روش مقایسه کنید بطور مثال :&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"fmt"
"regexp"
)
func main() {
first := "abc"
second := "xyz"
third := "123"
sampleRegex := regexp.MustCompile(first + second + third)
match := sampleRegex.Match([]byte("abcxyz123"))
fmt.Println(match)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>اگر به کد فوق دقت کنید متوجه خواهید شد که مقادیر بررسی شده بصورت کامل بوده و چنانچه بررسی شما شامل بخشی از عبارت وارد شده باشد باز نتیجه بررسی اشتباه خواهد بود برای مثال ما قسمتی از کد را تغییر می دهیم&lt;/p>
&lt;pre>&lt;code class="language-go">package main
...
func main() {
...
    match := sampleRegex.Match([]byte(&amp;quot;abcxyz&amp;quot;))
    fmt.Println(match)
}
&lt;/code>&lt;/pre>
&lt;p>در اینجا نتیجه بررسی برای عبارت &amp;ldquo;abcxyz&amp;rdquo; که در عبارت اصلی یعنی &amp;ldquo;abcxyz123&amp;rdquo; قرار دارد مقدار false نمایش داده خواهد شد که این به معنای بررسی کل عبارت است. برای رفع این اشتباه می بایست از ساختار عبارات قاعده مند بهر بگیریم و به این شکل به برنامه اطلاع دهیم که عبارت مد نظر ما می تواند بخشی از عبارت وارد شده باشد.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"fmt"
"regexp"
)
func main() {
sampleRegex := regexp.MustCompile("[abc]")
match := sampleRegex.Match([]byte("abcd"))
fmt.Printf("For abcd: %t\n", match)
match = sampleRegex.Match([]byte("1abc23"))
fmt.Printf("For 1abc23: %t\n", match)
match = sampleRegex.Match([]byte("abc"))
fmt.Printf("For abc: %t\n", match)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در کد فوق کارکترهای [] به این معنا است که عبارت مورد نظر می تواند شامل عبارت مورد مقایسه نیز باشد.
به چند تا از علائم و معانی پرکاربرد در عبارات قاعده مند توجه کنید.&lt;/p>
&lt;ol>
&lt;li>\w فقط شامل حروف باشد&lt;/li>
&lt;li>\W شامل حروف نباشد&lt;/li>
&lt;li>\d شامل اعداد باشد&lt;/li>
&lt;li>\Dشامل اعداد نباشد&lt;/li>
&lt;li>\s شامل فضای خالی باشد&lt;/li>
&lt;li>\S شامل فضای خالی نباشد&lt;/li>
&lt;li>\+ شامل حداقل یک یا بیشتر باشد&lt;/li>
&lt;li>\* شامل صفر یا بیشتر باشد&lt;/li>
&lt;li>\| شامل عبارت مورد نظر و یا مورد دیگر باشد&lt;/li>
&lt;/ol>
&lt;p>لیست کامل این عبارات را می توانید در &lt;a href="https://regexlearn.com/cheatsheet">اینجا&lt;/a> مشاهده کنید.&lt;/p>
&lt;p>در مواقعی مایل هستیم که عبارت مورد نظر در رشته را جستجو و نمایش دهیم بطور مثال:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"fmt"
"regexp"
)
func main() {
sampleRegexp := regexp.MustCompile(`(ab){2}`)
matches := sampleRegexp.FindString("abab")
fmt.Println(matches)
matches = sampleRegexp.FindString("ababbc")
fmt.Println(matches)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در اینجا از برنامه خواسته ایم که به دنبال ترکیبی از ab با تکرار دوبار متوالی باشد و در انتها عبارت پیدا شده توسط تابع FindString را نمایش دهد که علامت () تاکید روی عبارت مورد نظر است و {2} به معنی تکرار حداقل دوبار متوالی است.&lt;/p>
&lt;p>خروجی کد بالا&lt;/p>
&lt;pre>&lt;code class="language-shell">$go run main.go
abab
abab
&lt;/code>&lt;/pre>
&lt;p>در پایان می خواهیم یک مثال سختر را که در ابتدا به آن اشاره کردیم بنویسیم و آن بررسی شماره تلفن است.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"fmt"
"regexp"
)
func main() {
sampleRegexp := regexp.MustCompile(`^\+989(1[0-9]|3[1-9]|2[1-9])?[0-9]{7}$`)
matches := sampleRegexp.Match([]byte("+989121234#566"))
fmt.Println(matches)
matches = sampleRegexp.Match([]byte("+989121234567"))
fmt.Println(matches)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در کد فوق علامت ^ در عبارات با قاعده به معنی شروع ساختار عبارت است و علامت $ به معنای پایان عبارت. درواقع تمامی رشته های که قرار است عتبار سنجی شوند باید در ساختار بین این تو کاراکتر تطبیق شوند.
در ادامه نیاز است تا با کمک کاراکتر \ اثر کارکتر + را خنثی کنیم به این معنی که تمامی شماره های وارد شده باید علامت + در ابتدا داشته باشند سپس قید شده است که 989 که پیش شمار ایران و موبایل است را قید کرده ایم .
از آنجا که شماره موبایلهای ایران 911|912|913 شروع می شود با این عبارت &amp;ldquo;(1[0-9]|3[1-9]|2[1-9])&amp;rdquo; مشخص کرده ایم.
علامت ؟ به معنی حداقل یکبار تکرار شده عبارت قبل خودش است و در انتها کاربر می بایست هفت رقم وارد که به این صورت مشخص شده است &amp;ldquo;[0-9]{7}&amp;rdquo;.
همانطور مشاهده می کنید رشته اول معتبر نبوده ولی رشته دوم صحیح است.&lt;/p></description></item><item><author/><title>4.15 آموزش reflection</title><link>https://book.gofarsi.ir/chapter-4/go-reflection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/go-reflection/</guid><description>&lt;p>پکیج &lt;a href="https://pkg.go.dev/reflect">reflect&lt;/a> در زبان Go، امکانات reflection زمان اجرا را فراهم می‌کند که به یک برنامه اجازه می‌دهد تا با اشیاءی با انواع دلخواه کار کند. استفاده اصلی این پکیج، گرفتن اطلاعات نوع پویای یک مقدار با نوع استاتیک interface{} با فراخوانی تابع TypeOf است که یک مقدار Type را برمی‌گرداند.&lt;/p>
&lt;p>با فراخوانی تابع ValueOf، یک شیء Value که حاوی دادهٔ زمان اجراست، برمی‌گرداند. تابع Zero یک مقدار Type دریافت کرده و یک شیء Value را که مقدار صفر برای آن نوع است، برمی‌گرداند.&lt;/p>
&lt;h2 id="4151-تعریف-reflection-و-metaprogramming">
4.15.1 تعریف reflection و metaprogramming
&lt;a class="anchor" href="#4151-%d8%aa%d8%b9%d8%b1%db%8c%d9%81-reflection-%d9%88-metaprogramming">#&lt;/a>
&lt;/h2>
&lt;p>قبل از شروع آموزش، باید مفاهیم metaprogramming و reflection زمان اجرا را بفهمیم. می‌توانیم کدهای منبع خود را به دو شکل کد و داده در نظر بگیریم.&lt;/p>
&lt;p>اگر کدهای منبع را به عنوان کد در نظر بگیریم، می‌توانیم آن‌ها را روی CPU اجرا کنیم.&lt;/p>
&lt;p>از طرف دیگر، اگر کدهای منبع را به عنوان داده در نظر بگیریم، می‌توانیم مانند داده‌های معمولی فرآیند برنامه را برای آن‌ها بررسی و به‌روزرسانی کنیم. به عنوان مثال، می‌توانید تمام خصوصیات یک ساختار را بدون داشتن همه خصوصیات آن بدانید.&lt;/p>
&lt;p>metaprogramming به تکنیکی از برنامه نویسی گفته می‌شود که برنامه را به عنوان داده مورد بررسی قرار می‌دهد. تکنیک‌های metaprogramming می‌توانند برنامه‌های دیگر را بررسی و پردازش کنند، یا حتی در حین اجرای برنامه به خود برنامه دسترسی داشته باشند.&lt;/p>
&lt;p>reflection زمان اجرا زیر مجموعه‌ای از الگوی metaprogramming است. تقریباً تمام زبان‌های محبوب، API داخلی را برای مدیریت metaprogramming برای زبان برنامه‌نویسی خود ارائه می‌دهند. این API ها به عنوان امکانات reflection زمان اجرا شناخته می‌شوند و به عنوان قابلیت زبان برنامه‌نویسی خاصی برای بررسی، تغییر و اجرای ساختار کد عمل می‌کنند.&lt;/p>
&lt;p>بنابراین، ما می‌توانیم کارهایی مانند:&lt;/p>
&lt;ul>
&lt;li>بررسی خصوصیات یک ساختار&lt;/li>
&lt;li>بررسی وجود یک تابع در یک نمونه ساختار&lt;/li>
&lt;li>بررسی نوع اتمی یک متغیر ناشناخته با API های reflection زمان اجرا را انجام دهیم.&lt;/li>
&lt;/ul>
&lt;p>حال به بررسی بیشتر اینکه این چگونه در زبان برنامه نویسی Go کار می‌کند، می‌پردازیم.&lt;/p>
&lt;h2 id="4152-کاربردهای-reflection">
4.15.2 کاربردهای reflection
&lt;a class="anchor" href="#4152-%da%a9%d8%a7%d8%b1%d8%a8%d8%b1%d8%af%d9%87%d8%a7%db%8c-reflection">#&lt;/a>
&lt;/h2>
&lt;p>مفهوم reflection به طور معمول یک API اصلی را برای بررسی یا تغییر برنامه فعلی ارائه می‌دهد. ممکن است فکر کنید که در مورد کد منبع برنامه خود آگاه هستید، پس چرا نیاز به بررسی کد نوشته شده خود با استفاده از reflection دارید؟ اما reflection دارای موارد کاربرد مفید زیادی است، که در زیر ذکر شده است:&lt;/p>
&lt;ul>
&lt;li>برنامه‌نویسان می‌توانند از reflection استفاده کنند تا با کمترین کد، مشکلات برنامه‌نویسی را حل کنند. به عنوان مثال، اگر از یک نمونه ساختاری برای ساخت یک پرس و جوی SQL استفاده می‌کنید، می‌توانید با استفاده از reflection، فیلدهای ساختار را بدون هاردکد کردن نام هر فیلد ساختاری استخراج کنید.&lt;/li>
&lt;li>با توجه به اینکه reflection یک روش برای بررسی ساختار برنامه ارائه می‌دهد، ممکن است با استفاده از آن، تحلیلگرهای کد استاتیکی ساخته شود.&lt;/li>
&lt;li>با استفاده از API reflection، ما می‌توانیم کد را به صورت پویا اجرا کنیم. به عنوان مثال، شما می‌توانید متدهای موجود یک ساختار را پیدا کرده و با نام آن‌ها تماس بگیرید.&lt;/li>
&lt;/ul>
&lt;p>بخش آموزشی زیر همه اصول مورد نیاز برای پیاده‌سازی موارد کاربرد فوق را پوشش خواهد داد. همچنین، به شما نشان خواهم داد که چگونه می‌توانید یک برنامه shell ساده با API reflection بسازید.&lt;/p>
&lt;p>اکنون که مفهوم reflection را پوشش دادیم، با مثال‌های عملی شروع کنیم.&lt;/p>
&lt;p>پکیج reflection Go به ما reflect در زمان اجرا را ارائه می‌دهد، لذا این مثال‌ها ساختار برنامه را در طول زمان اجرا بررسی یا تغییر می‌دهند. با توجه به اینکه Go یک زبان کامپایل شده با نوع استاتیک است، API reflection آن بر اساس دو عنصر کلیدی، نوع reflection و مقدار reflection، ساخته شده است.&lt;/p>
&lt;h2 id="5153-بررسی-تایپ-های-متغیرها">
5.15.3 بررسی تایپ های متغیرها
&lt;a class="anchor" href="#5153-%d8%a8%d8%b1%d8%b1%d8%b3%db%8c-%d8%aa%d8%a7%db%8c%d9%be-%d9%87%d8%a7%db%8c-%d9%85%d8%aa%d8%ba%db%8c%d8%b1%d9%87%d8%a7">#&lt;/a>
&lt;/h2>
&lt;p>در ابتدا، می‌توانیم با پکیج reflect، از بررسی نوع متغیرها برای شروع استفاده کنیم. کد زیر را ببینید که نوع چندین متغیر را چاپ می‌کند.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"fmt"
"reflect"
)
func main() {
x := 10
name := "Go Lang"
type Book struct {
name string
author string
}
sampleBook := Book{"Reflection in Go", "John"}
fmt.Println(reflect.TypeOf(x)) // int
fmt.Println(reflect.TypeOf(name)) // string
fmt.Println(reflect.TypeOf(sampleBook)) // main.Book
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>کد بالا نوع داده‌های متغیرها را با استفاده از تابع reflect.TypeOf چاپ می‌کند. تابع TypeOf یک نمونه reflection Type بازگردانده می‌کند که توابعی برای دسترسی به اطلاعات بیشتر درباره نوع فعلی فراهم می‌کند. برای مثال، می‌توانیم از تابع Kind برای بدست آوردن نوع ابتدایی یک متغیر استفاده کنیم. به خاطر داشته باشید که کد بالا نوع داده ساختار اختصاصی main.Book برای متغیر sampleBook را نشان می‌دهد - نه نوع ساختار ابتدایی.&lt;/p>
&lt;p>برای بدست آوردن نوع ابتدایی، کد بالا را به صورت زیر تغییر دهید:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"fmt"
"reflect"
)
func main() {
var (
str = "Hello, world!"
num = 42
flt = 3.14
boo = true
slice = []int{1, 2, 3}
mymap = map[string]int{"foo": 1, "bar": 2}
structure = struct{ Name string }{Name: "John Doe"}
interface1 interface{} = "hello"
interface2 interface{} = &amp;structure
)
fmt.Println(reflect.TypeOf(str).Kind())
fmt.Println(reflect.TypeOf(num).Kind())
fmt.Println(reflect.TypeOf(flt).Kind())
fmt.Println(reflect.TypeOf(boo).Kind())
fmt.Println(reflect.TypeOf(slice).Kind())
fmt.Println(reflect.TypeOf(mymap).Kind())
fmt.Println(reflect.TypeOf(structure).Kind())
fmt.Println(reflect.TypeOf(interface1).Kind())
fmt.Println(reflect.TypeOf(interface2).Kind())
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>دلیلی که در کد بالا برای سومین دستور چاپ، struct چاپ می‌شود، این است که تابع Kind reflection Type یک reflection Kind بازگردانده که اطلاعات نوع اولیه را نگه می‌دارد. در این حالت، reflection Kind نوع اولیه ساختار است.&lt;/p>
&lt;h3 id="51531-اندازه-تایپ-های-مقداردهی-شده">
5.15.3.1 اندازه تایپ های مقداردهی شده
&lt;a class="anchor" href="#51531-%d8%a7%d9%86%d8%af%d8%a7%d8%b2%d9%87-%d8%aa%d8%a7%db%8c%d9%be-%d9%87%d8%a7%db%8c-%d9%85%d9%82%d8%af%d8%a7%d8%b1%d8%af%d9%87%db%8c-%d8%b4%d8%af%d9%87">#&lt;/a>
&lt;/h3>
&lt;p>همچنین می‌توانیم از تابع Size reflection Type استفاده کنیم تا تعداد بایت‌های مورد نیاز برای ذخیره نوع فعلی را بدست آوریم. کد زیر را ببینید:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"fmt"
"reflect"
)
func main() {
var (
str = "Hello, world!"
num = 42
flt = 3.14
boo = true
slice = []int{1, 2, 3}
mymap = map[string]int{"foo": 1, "bar": 2}
structure = struct{ Name string }{Name: "John Doe"}
)
fmt.Printf("Size of str: %d\n", reflect.TypeOf(str).Size())
fmt.Printf("Size of num: %d\n", reflect.TypeOf(num).Size())
fmt.Printf("Size of flt: %d\n", reflect.TypeOf(flt).Size())
fmt.Printf("Size of boo: %d\n", reflect.TypeOf(boo).Size())
fmt.Printf("Size of slice: %d\n", reflect.TypeOf(slice).Size())
fmt.Printf("Size of mymap: %d\n", reflect.TypeOf(mymap).Size())
fmt.Printf("Size of structure: %d\n", reflect.TypeOf(structure).Size())
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>این کد، با استفاده از تابع Size reflection Type، تعداد بایت‌های مورد نیاز برای ذخیره هر نوع را چاپ می‌کند. با اجرای این کد، خروجی زیر را خواهید داشت:&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go run main.go
Size of str: 16
Size of num: 8
Size of flt: 8
Size of boo: 1
Size of slice: 24
Size of mymap: 8
Size of structure: 0
&lt;/code>&lt;/pre>
&lt;p>در این کد، تعداد بایت‌های مورد نیاز برای نوع string 16 بایت، برای نوع int 8 بایت، برای نوع float64 8 بایت، برای نوع bool 1 بایت، برای نوع slice 24 بایت و برای نوع map 8 بایت است. برای نوع ساختاری structure بایتی نیاز نیست و برابر با صفر است.&lt;/p>
&lt;h2 id="5154-بررسی-مقدار-یک-متغیر">
5.15.4 بررسی مقدار یک متغیر
&lt;a class="anchor" href="#5154-%d8%a8%d8%b1%d8%b1%d8%b3%db%8c-%d9%85%d9%82%d8%af%d8%a7%d8%b1-%db%8c%da%a9-%d9%85%d8%aa%d8%ba%db%8c%d8%b1">#&lt;/a>
&lt;/h2>
&lt;p>قبلاً، اطلاعات نوع داده‌ها را بررسی کردیم. همچنین با استفاده از پکیج reflect، می‌توانیم مقادیر متغیرها را استخراج کنیم. کد زیر، مقادیر متغیرها را با استفاده از تابع reflect.ValueOf چاپ می‌کند:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"fmt"
"reflect"
)
func main() {
var (
str = "Hello, world!"
num = 42
flt = 3.14
boo = true
slice = []int{1, 2, 3}
mymap = map[string]int{"foo": 1, "bar": 2}
structure = struct{ Name string }{Name: "John Doe"}
)
fmt.Printf("Value of str: %v\n", reflect.ValueOf(str))
fmt.Printf("Value of num: %v\n", reflect.ValueOf(num))
fmt.Printf("Value of flt: %v\n", reflect.ValueOf(flt))
fmt.Printf("Value of boo: %v\n", reflect.ValueOf(boo))
fmt.Printf("Value of slice: %v\n", reflect.ValueOf(slice))
fmt.Printf("Value of mymap: %v\n", reflect.ValueOf(mymap))
fmt.Printf("Value of structure: %v\n", reflect.ValueOf(structure))
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>این کد، با استفاده از تابع reflect.ValueOf، مقادیر متغیرها را چاپ می‌کند. با اجرای این کد، خروجی زیر را خواهید داشت:&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go run main.go
Value of str: Hello, world!
Value of num: 42
Value of flt: 3.14
Value of boo: true
Value of slice: [1 2 3]
Value of mymap: map[bar:2 foo:1]
Value of structure: {John Doe}
&lt;/code>&lt;/pre>
&lt;p>در این کد، مقادیر متغیرها با استفاده از تابع reflect.ValueOf چاپ می‌شوند. به خاطر داشته باشید که تابع ValueOf یک نمونه reflection Value بازگردانده می‌کند، که اطلاعات مربوط به مقدار و نوع متغیر را نگه‌داری می‌کند. برای چاپ مقدار واقعی، باید از توابع مربوط به reflection Value استفاده کنیم.&lt;/p>
&lt;h2 id="5155-تغییر-مقدار-یک-متغیر">
5.15.5 تغییر مقدار یک متغیر
&lt;a class="anchor" href="#5155-%d8%aa%d8%ba%db%8c%db%8c%d8%b1-%d9%85%d9%82%d8%af%d8%a7%d8%b1-%db%8c%da%a9-%d9%85%d8%aa%d8%ba%db%8c%d8%b1">#&lt;/a>
&lt;/h2>
&lt;p>قبلاً، ساختار کد را با استفاده از چندین تابع در پکیج reflect بررسی کردیم. همچنین با استفاده از API بازتاب Go، امکان تغییر کد در حین اجرا وجود دارد. در کد زیر، نحوه به‌روزرسانی یک فیلد رشته‌ای در یک ساختار را مشاهده می‌کنید:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"fmt"
"reflect"
)
type Person struct {
Name string
Age int
}
func main() {
p := Person{Name: "John", Age: 30}
fmt.Println("Before update:", p)
v := reflect.ValueOf(&amp;p)
if v.Kind() == reflect.Ptr {
v = v.Elem()
}
f := v.FieldByName("Name")
if f.IsValid() &amp;&amp; f.CanSet() {
f.SetString("Jane")
}
fmt.Println("After update:", p)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در این کد، یک ساختار به نام Person تعریف شده است که دو فیلد Name و Age دارد. در تابع main، یک نمونه از ساختار Person با مقدار پیش‌فرض Name: &amp;ldquo;John&amp;rdquo; و Age: 30 ایجاد شده است. سپس با استفاده از تابع reflect.ValueOf، نمونه ساختار Person به یک reflection Value تبدیل شده و با استفاده از تابع Kind، نوع آن بررسی می‌شود. اگر نوع نمونه یک اشاره‌گر باشد، با استفاده از تابع Elem، به مقدار اشاره شده تبدیل می‌شود.&lt;/p>
&lt;p>در ادامه، با استفاده از تابع FieldByName، فیلد Name در نمونه ساختار Person بدست آورده می‌شود. سپس با استفاده از تابع IsValid بررسی می‌شود که آیا فیلد موجود است یا خیر. در صورت وجود، با استفاده از تابع CanSet بررسی می‌شود که آیا می‌توان آن را تغییر داد یا خیر. در صورت امکان تغییر، با استفاده از تابع SetString، مقدار فیلد Name به &amp;ldquo;Jane&amp;rdquo; تغییر می‌یابد.&lt;/p>
&lt;p>در نهایت، با چاپ دوباره مقدار نمونه ساختار Person، تغییر در فیلد Name را مشاهده می‌کنیم. با اجرای این کد، خروجی زیر را خواهید داشت:&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go run main.go
Before update: {John 30}
After update: {Jane 30}
&lt;/code>&lt;/pre>
&lt;p>در این حالت، با استفاده از پکیج reflect، می‌توانیم برنامه را در حین اجرا تغییر داده و به داده‌های موجود در حافظه دسترسی پیدا کنیم.&lt;/p>
&lt;h2 id="5156-بررسی-اطلاعات-یک-struct">
5.15.6 بررسی اطلاعات یک struct
&lt;a class="anchor" href="#5156-%d8%a8%d8%b1%d8%b1%d8%b3%db%8c-%d8%a7%d8%b7%d9%84%d8%a7%d8%b9%d8%a7%d8%aa-%db%8c%da%a9-struct">#&lt;/a>
&lt;/h2>
&lt;p>بیایید یک کد نمونه برای بررسی همه فیلدهای یک ساختار بنویسیم. در طول بررسی، می‌توانیم نام و مقدار هر فیلد ساختار را نمایش دهیم. کد زیر این کار را انجام می‌دهد:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"fmt"
"reflect"
)
type Person struct {
Name string
Age int
Address string
}
func main() {
p := Person{Name: "John", Age: 30, Address: "123 Main St."}
v := reflect.ValueOf(p)
if v.Kind() == reflect.Ptr {
v = v.Elem()
}
for i := 0; i &lt; v.NumField(); i++ {
field := v.Field(i)
fmt.Printf("Field %d: %s = %v\n", i, v.Type().Field(i).Name, field.Interface())
}
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در این کد، یک ساختار به نام Person تعریف شده است که دارای سه فیلد Name، Age و Address است. در تابع main، یک نمونه از ساختار Person با مقدار پیش‌فرض Name: &amp;ldquo;John&amp;rdquo;، Age: 30 و Address: &amp;ldquo;123 Main St.&amp;rdquo; ایجاد شده است.&lt;/p>
&lt;p>سپس با استفاده از تابع reflect.ValueOf، نمونه ساختار Person به یک reflection Value تبدیل شده و با استفاده از تابع Kind، نوع آن بررسی می‌شود. اگر نوع نمونه یک اشاره‌گر باشد، با استفاده از تابع Elem، به مقدار اشاره شده تبدیل می‌شود.&lt;/p>
&lt;p>در ادامه، با استفاده از تابع NumField، تعداد فیلدهای موجود در نمونه ساختار Person بدست آورده می‌شود. سپس در یک حلقه، با استفاده از تابع Field، مقدار هر فیلد به همراه نام آن چاپ می‌شود. با استفاده از تابع Type، نوع نمونه ساختار Person به دست می‌آید، و با استفاده از تابع Field(i).Name، نام فیلد در ایندکس i بدست می‌آید. در نهایت، با استفاده از تابع Interface، مقدار فیلد به صورت یک interface{} برگردانده می‌شود و چاپ می‌شود.&lt;/p>
&lt;p>با اجرای این کد، خروجی زیر را خواهید داشت:&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go run main.go
Field 0: Name = John
Field 1: Age = 30
Field 2: Address = 123 Main St.
&lt;/code>&lt;/pre>
&lt;p>در این حالت، با استفاده از پکیج reflect، می‌توانیم برای هر ساختار، همه فیلدها را بررسی کرده و نام و مقدار هر فیلد را چاپ کنیم.&lt;/p>
&lt;h2 id="5157-بررسی-متدها-methods">
5.15.7 بررسی متدها (Methods)
&lt;a class="anchor" href="#5157-%d8%a8%d8%b1%d8%b1%d8%b3%db%8c-%d9%85%d8%aa%d8%af%d9%87%d8%a7-methods">#&lt;/a>
&lt;/h2>
&lt;p>فرض کنید شما یک موتور دستور سفارشی برای یک برنامه شل پیاده‌سازی می‌کنید و برای اجرای توابع Go بر اساس دستورات ورودی کاربر، نیاز دارید دستورات را به توابع مرتبط تخصیص دهید. اگر تعداد توابع کم باشد، می‌توانید از یک switch-case statement استفاده کنید. اما اگر تعداد توابع صد‌ها نفر باشد؟ در این صورت، ما می‌توانیم توابع Go را براساس نام آن‌ها به صورت پویا فراخوانی کنیم. برنامه شل پایه‌ای زیر با استفاده از بازتاب این کار را انجام می‌دهد:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"fmt"
"reflect"
"bufio"
"os"
)
type NativeCommandEngine struct{}
func (nse NativeCommandEngine) Method1() {
fmt.Println("INFO: Method1 executed!")
}
func (nse NativeCommandEngine) Method2() {
fmt.Println("INFO: Method2 executed!")
}
func (nse NativeCommandEngine) callMethodByName(methodName string) {
method := reflect.ValueOf(nse).MethodByName(methodName)
if !method.IsValid() {
fmt.Println("ERROR: \"" + methodName + "\" is not implemented")
return
}
method.Call(nil)
}
func (nse NativeCommandEngine) ShowCommands() {
val := reflect.TypeOf(nse)
for i := 0; i &lt; val.NumMethod(); i++ {
fmt.Println(val.Method(i).Name)
}
}
func main() {
nse := NativeCommandEngine{}
fmt.Println("A simple Shell v1.0.0")
fmt.Println("Supported commands:")
nse.ShowCommands()
scanner := bufio.NewScanner(os.Stdin)
fmt.Print("$ ")
for scanner.Scan() {
nse.callMethodByName(scanner.Text())
fmt.Print("$ ")
}
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>برنامه شلی که پیشتر نوشتیم، ابتدا تمام دستورات پشتیبانی شده را نشان می‌دهد. سپس کاربر می‌تواند دستورات را به دلخواه خود وارد کند. هر دستور شل یک متد متناظر دارد، و اگر یک متد خاص وجود نداشته باشد، شل پیام خطا چاپ می‌کند.&lt;/p>
&lt;h2 id="5158-نوشتن-custom-tag-برای-فیلد-های-ساختار">
5.15.8 نوشتن custom tag برای فیلد های ساختار
&lt;a class="anchor" href="#5158-%d9%86%d9%88%d8%b4%d8%aa%d9%86-custom-tag-%d8%a8%d8%b1%d8%a7%db%8c-%d9%81%db%8c%d9%84%d8%af-%d9%87%d8%a7%db%8c-%d8%b3%d8%a7%d8%ae%d8%aa%d8%a7%d8%b1">#&lt;/a>
&lt;/h2>
&lt;p>تگ سفارشی مانند &lt;code>json:&amp;quot;name&amp;quot;&lt;/code> در گو، برای اتصال متاداده به فیلدهای یک ساختار استفاده می‌شود. بسته &lt;code>reflect&lt;/code> در گو، یک راه برای دسترسی به این تگ‌ها در زمان اجرا فراهم می‌کند. برای ایجاد یک تگ سفارشی در گو، می‌توان از بسته &lt;code>reflect&lt;/code> برای دسترسی به تگ‌ها بر روی یک فیلد ساختار استفاده کرد.&lt;/p>
&lt;p>در ادامه مثالی از چگونگی ایجاد یک تگ سفارشی با بسته &lt;code>reflect&lt;/code> در گو آورده شده است:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"fmt"
"reflect"
)
type Person struct {
Name string `customtag:"myname"`
Age int `customtag:"myage"`
}
func main() {
p := Person{"John", 30}
t := reflect.TypeOf(p)
v := reflect.ValueOf(p)
for i := 0; i &lt; t.NumField(); i++ {
field := t.Field(i)
value := v.Field(i)
tag := field.Tag.Get("customtag")
fmt.Printf("Field: %s, Value: %v, Tag: %s\n", field.Name, value.Interface(), tag)
}
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در این مثال، یک ساختار Person با دو فیلد Name و Age تعریف شده است. هر یک از این فیلدها با استفاده از کلید &lt;code>customtag&lt;/code> یک تگ سفارشی دارند.&lt;/p>
&lt;p>برای دسترسی به تگ‌ها در زمان اجرا، از بسته &lt;code>reflect&lt;/code> استفاده می‌شود. با استفاده از &lt;code>reflect.TypeOf&lt;/code> و &lt;code>reflect.ValueOf&lt;/code> نوع و مقدار ساختار Person بدست می‌آیند. سپس با استفاده از حلقه &lt;code>for&lt;/code> و توابع &lt;code>t.NumField()&lt;/code> و &lt;code>t.Field(i)&lt;/code> بر روی فیلدهای ساختار حرکت می‌کنیم. برای هر فیلد، با استفاده از &lt;code>v.Field(i)&lt;/code> مقدار آن را و با استفاده از &lt;code>field.Tag.Get(&amp;quot;customtag&amp;quot;)&lt;/code> تگ سفارشی آن را بدست می‌آوریم.&lt;/p>
&lt;p>در نهایت با استفاده از &lt;code>fmt.Printf&lt;/code> نام فیلد، مقدار آن و تگ سفارشی آن را چاپ می‌کنیم. خروجی این برنامه به شکل زیر خواهد بود:&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go run main.go
Field: Name, Value: John, Tag: myname
Field: Age, Value: 30, Tag: myage
&lt;/code>&lt;/pre>
&lt;p>این نشان می‌دهد که چگونه می‌توان با استفاده از بسته &lt;code>reflect&lt;/code> در گو تگ‌های سفارشی را ایجاد کرد.&lt;/p></description></item><item><author/><title>4.16 آموزش generator</title><link>https://book.gofarsi.ir/chapter-4/go-generator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/go-generator/</guid><description>&lt;p>کد generator در گو، یک ابزار است که برای تولید کد خودکار استفاده می‌شود. برای ایجاد یک کد generator در گو، می‌توان از قابلیت‌هایی که در زبان گو موجود است، مانند بسته‌های &lt;code>go/ast&lt;/code> و &lt;code>go/parser&lt;/code> استفاده کرد.&lt;/p>
&lt;p>با استفاده از بسته &lt;code>go/ast&lt;/code> می‌توانید ساختار داده‌های AST (Abstract Syntax Tree) را برای کد خود بسازید. AST، ساختار درختی از کدهای گو است که به طور معمول برای بررسی و تحلیل کد استفاده می‌شود.&lt;/p>
&lt;p>با استفاده از بسته &lt;code>go/parser&lt;/code> می‌توانید کد منبع گو را به عنوان ورودی بگیرید و برای آن AST بسازید.&lt;/p>
&lt;p>با استفاده از این دو بسته، می‌توانید یک کد generator بسازید که برای تولید کد خودکار، کد منبع گو را تحلیل کرده و براساس آن، کد جدیدی را ایجاد کند. برای مثال، می‌توانید یک کد generator بسازید که برای تولید کد تست، کد منبع گو را تحلیل کرده و برای هر تابع یا متد، تست مربوطه را بسازد.&lt;/p>
&lt;p>با توجه به این که کد generator‌ها برای تولید کد خودکار استفاده می‌شوند، باید دقت شود که کد تولید شده باید قابل خواندن و تصحیح باشد. همچنین، باید از بهبود کیفیت کد تولید شده نیز اطمینان حاصل شود.&lt;/p>
&lt;p>در کل، با استفاده از بسته‌های &lt;code>go/ast&lt;/code> و &lt;code>go/parser&lt;/code> می‌توانید یک کد generator قدرتمند در گو بسازید که برای تولید کد خودکار بسیار مفید است.&lt;/p>
&lt;p>این بخش ادامه دارد&amp;hellip;&lt;/p></description></item><item><author/><title>4.17 آموزش stringer</title><link>https://book.gofarsi.ir/chapter-4/go-stringer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/go-stringer/</guid><description>&lt;p>Stringer به طور کلی برای پیاده‌سازی مفهوم شمارشی (enumeration) استفاده می‌شود در حالی که از برنامه‌نویسی ثابت رشته‌های مقدار استفاده نمی‌کند. شمارشی یا enum زمانی استفاده می‌شود که می‌خواهید مجموعه‌ای متناهی و ثابتی از مقادیر یک نوع داده‌ای را تعریف کنید. به عنوان مثال، انواع غذا در منو (پیش غذا، اصلی، دسر)، انواع پوکمون (گیاهی، آبی، آتشی، و غیره).&lt;/p>
&lt;p>بنابراین، زمانی که می‌خواهیم از این مجموعه‌های تعریف شده استفاده کنیم، باید از برنامه‌نویسی ثابت رشته‌های مقدار استفاده کنیم زیرا ممکن است به خطاهای انسانی مانند اشتباهات املایی منجر شود. اگر از Stringer استفاده کنیم، مقادیر را یکبار تولید می‌کنیم و مطمئن می‌شویم که هیچ خطایی ایجاد نمی‌شود. پس از آن، می‌توانیم از آن‌ها بدون نگرانی از خطاهای انسانی استفاده کنیم.&lt;/p>
&lt;h2 id="4171-پیاده-سازی-متد-string-برای-آبجکت-ها">
4.17.1 پیاده سازی متد String برای آبجکت ها
&lt;a class="anchor" href="#4171-%d9%be%db%8c%d8%a7%d8%af%d9%87-%d8%b3%d8%a7%d8%b2%db%8c-%d9%85%d8%aa%d8%af-string-%d8%a8%d8%b1%d8%a7%db%8c-%d8%a2%d8%a8%d8%ac%da%a9%d8%aa-%d9%87%d8%a7">#&lt;/a>
&lt;/h2>
&lt;p>شما می توانید برای هر یک از آبجکت ها متد String را پیاده سازی کنید و یک خروجی استرینگ در خصوص مقادیر آبجکت داشته باشید.&lt;/p>
&lt;p>به مثال کاربردی زیر توجه کنید:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
type Age int
const (
CHILDERN Age = iota
ADOLESCENTS
ADULTS
)
func (a Age) String() string {
switch a {
case CHILDERN:
return "childern"
case ADOLESCENTS:
return "adolescents"
case ADULTS:
return "adults"
default:
return ""
}
}
func main() {
fmt.Println(CHILDERN.String())
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در مثال فوق ما یک تایپ Age تعریف کردیم و سپس یکسری enum با همان تایپ قرار دادیم پس از آن متد String را پیاده سازی کردیم که بتوانیم رشته هرکدام از enum ها را بگیریم.&lt;/p>
&lt;h2 id="4172-استفاده-از-ابزار-stringer">
4.17.2 استفاده از ابزار stringer
&lt;a class="anchor" href="#4172-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-%d8%a7%d8%a8%d8%b2%d8%a7%d8%b1-stringer">#&lt;/a>
&lt;/h2>
&lt;p>شما با استفاده از ابزار stringer می توانید به راحتی برای enum های خود رشته را بصورت خودکار ایجاد کنید.&lt;/p>
&lt;p>برای نصب این ابزار در ابتدا باید دستور زیر را بزنید تا داخل go bin نصب شود:&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go install golang.org/x/tools/cmd/stringer@latest
&lt;/code>&lt;/pre>
&lt;p>اکنون بخواهیم با استفاده از ابزار stringer متد استرینگ جنریت کنیم کافیه مثال زیر توجه کنید:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
//go:generate stringer -type=Age
type Age int
const (
CHILDERN Age = iota
ADOLESCENTS
ADULTS
)
func main() {
fmt.Println(CHILDERN.String())
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در کد فوق ما یک directive comment اضافه کردیم حال کافیه با استفاده از دستور go generate متد استرینگ تایپ را جنریت کنیم.&lt;/p>
&lt;pre>&lt;code>go generate ./...
&lt;/code>&lt;/pre></description></item><item><author/><title>4.18 تکنیک های کدنویسی زبان گو</title><link>https://book.gofarsi.ir/chapter-4/effective-go/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/effective-go/</guid><description>&lt;p>در این بخش به موارد زیر می پردازیم.&lt;/p>
&lt;ul>
&lt;li>کارآمدی (effective)&lt;/li>
&lt;li>استایل اوبر&lt;/li>
&lt;li>تکنیک ها&lt;/li>
&lt;li>نکات فنی&lt;/li>
&lt;li>بهینه سازی&lt;/li>
&lt;/ul>
&lt;h2 id="4181-کارآمدی-effective">
4.18.1 کارآمدی (Effective)
&lt;a class="anchor" href="#4181-%da%a9%d8%a7%d8%b1%d8%a2%d9%85%d8%af%db%8c-effective">#&lt;/a>
&lt;/h2>
&lt;p>در زیر به کارآمدی زبان گو می پردازیم.&lt;/p>
&lt;h3 id="41811-نام-پکیج-ها">
4.18.1.1 نام پکیج ها
&lt;a class="anchor" href="#41811-%d9%86%d8%a7%d9%85-%d9%be%da%a9%db%8c%d8%ac-%d9%87%d8%a7">#&lt;/a>
&lt;/h3>
&lt;p>زمانیکه شما یک پکیج را ایمپورت میکنید نام پکیج در بالای بدنه فایل گو قرار میگیرد مانند :&lt;/p>
&lt;pre>&lt;code class="language-go">import &amp;quot;bytes&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>حال وقتی که پکیج ایمپورت می شود و نام اش در بالای بدنه فایل کد شما قرار میگیرد می توانید در ادامه نام پکیج توابع, تایپ ها و یا متغیر و const ها را مانند &lt;code>bytes.Buffer&lt;/code> فراخوانی کنید.&lt;/p>
&lt;p>انتخاب یک نام خوب برای پکیج خیلی قابل اهمیت است و شما برای انتخاب یک نام خوب بهتر است موارد زیر را رعایت کنید :&lt;/p>
&lt;ul>
&lt;li>نام کوتاه باشد.&lt;/li>
&lt;li>مختصر باشد.&lt;/li>
&lt;li>نام پکیج طوری باشد که به آسانی بتوان بهش دسترسی داشت&lt;/li>
&lt;li>نام پکیج باشد تماما حروف کوچک باشد.&lt;/li>
&lt;li>تک کلمه ای باشد.&lt;/li>
&lt;/ul>
&lt;h3 id="41812-پیاده-سازی-gettersetter">
4.18.1.2 پیاده سازی Getter/Setter
&lt;a class="anchor" href="#41812-%d9%be%db%8c%d8%a7%d8%af%d9%87-%d8%b3%d8%a7%d8%b2%db%8c-gettersetter">#&lt;/a>
&lt;/h3>
&lt;p>در زبان گو هیچ Getter یا Setter خودکاری وجود ندارد. به همین منظور شما باید Getter/Setter را در قالب متد یک آبجکت پیاده سازی کنید.&lt;/p>
&lt;pre>&lt;code class="language-go">owner := obj.GetOwner()
if owner != user {
obj.SetOwner(user)
}
&lt;/code>&lt;/pre>
&lt;h3 id="41813-نام-اینترفیس">
4.18.1.3 نام اینترفیس
&lt;a class="anchor" href="#41813-%d9%86%d8%a7%d9%85-%d8%a7%db%8c%d9%86%d8%aa%d8%b1%d9%81%db%8c%d8%b3">#&lt;/a>
&lt;/h3>
&lt;p>نام اینترفیس یک حالت قراردادی دارد که بهتر است این حالت قرار دادی را رعایت کنید. نام اینترفیس با مشخصه یک رفتار کلی باشد که برپایه متدهای اینترفیس تعیین می شود و در نهایت در انتهای نام اینترفیس دو حرف &lt;code>er&lt;/code> اضافه می شود. مانند : &lt;code>Reader&lt;/code> , &lt;code>Writer&lt;/code>, &lt;code>Formmater&lt;/code>&lt;/p>
&lt;pre>&lt;code class="language-go">type Writer interface {
Write([]byte) error
}
&lt;/code>&lt;/pre>
&lt;h3 id="41814-نوع-نام-گذاری-متغیر-تابع-تایپ-و-">
4.18.1.4 نوع نام گذاری متغیر, تابع, تایپ و &amp;hellip;
&lt;a class="anchor" href="#41814-%d9%86%d9%88%d8%b9-%d9%86%d8%a7%d9%85-%da%af%d8%b0%d8%a7%d8%b1%db%8c-%d9%85%d8%aa%d8%ba%db%8c%d8%b1-%d8%aa%d8%a7%d8%a8%d8%b9-%d8%aa%d8%a7%db%8c%d9%be-%d9%88-">#&lt;/a>
&lt;/h3>
&lt;p>در زبان گو نام گذاری حالت قراردادی دارد که کامپایلر نسبت به نوع نام گذاری شما رفتار نشان می دهد. بطوری که شما می توانید نام ها را بصورت MixedCaps یا mixedCaps بنویسید که این حالت نام گذاری را camleCase و PascalCase می گویند.&lt;/p>
&lt;ul>
&lt;li>زمانیکه شما نام را بصورت PascalCase می نویسید در واقع حالت شما آن متغیر, تابع, تایپ و &amp;hellip; را بصورت Public در نظر گرفتید.&lt;/li>
&lt;li>اگر شما نام را بصورت camleCase بنویسید در واقع شما متغیر, تابع, تایپ و &amp;hellip; را بصورت Private در نظر گرفتید وفقط در پکیج لول شما در دسترس می باشد.&lt;/li>
&lt;/ul>
&lt;h3 id="41815-نقطه-ویرگول-semicolons">
4.18.1.5 نقطه ویرگول (Semicolons)
&lt;a class="anchor" href="#41815-%d9%86%d9%82%d8%b7%d9%87-%d9%88%db%8c%d8%b1%da%af%d9%88%d9%84-semicolons">#&lt;/a>
&lt;/h3>
&lt;p>مانند C، گرامر رسمی Go از نقطه ویرگول برای پایان دادن به عبارات استفاده می کند، اما برخلاف C، این نقطه ویرگول ها در منبع ظاهر نمی شوند. در عوض، lexer از یک قانون ساده برای درج خودکار نقطه ویرگول ها در حین اسکن استفاده می کند، بنابراین متن ورودی عمدتاً فاقد آنها است.&lt;/p>
&lt;h3 id="41816-ساختارهای-کنترلی-if-for-switch">
4.18.1.6 ساختارهای کنترلی if, for, switch
&lt;a class="anchor" href="#41816-%d8%b3%d8%a7%d8%ae%d8%aa%d8%a7%d8%b1%d9%87%d8%a7%db%8c-%da%a9%d9%86%d8%aa%d8%b1%d9%84%db%8c-if-for-switch">#&lt;/a>
&lt;/h3>
&lt;p>در زبان گو همانند سایر زبان ها ساختارهای کنترلی نظیر if, for, switch داریم که در زیر می توانید با حالت های کارآمد استفاده از این کنترل ها آن ها آشنا شوید.&lt;/p>
&lt;p>&lt;strong>if&lt;/strong>&lt;/p>
&lt;p>در زبان گو حالت ساده شرط به شکل زیر است :&lt;/p>
&lt;pre>&lt;code class="language-go">if x &amp;gt; 0 {
return y
}
&lt;/code>&lt;/pre>
&lt;p>حال اگر شما یک تابعی داشته باشید که یک مقدار مانند خطا برگرداند می توانید داخل عبارت شرط یک متغییر راه اندازی کنید و تابع را داخلش قرار دهید سپس با قرار دادن نقطه ویرگول شرط را بررسی کرده.&lt;/p>
&lt;pre>&lt;code class="language-go">if err := file.Chmod(0664); err != nil {
log.Print(err)
return err
}
&lt;/code>&lt;/pre>
&lt;p>اما اگر تابع شما ۲ تا خروجی داشته باشد بهتر است داخل دو متغییر خروجی را بگیرید و در خط بعدی شرط را جهت بررسی هریک از متغیرها قرار دهید:&lt;/p>
&lt;pre>&lt;code class="language-go">f, err := os.Open(name)
if err != nil {
return err
}
codeUsing(f)
&lt;/code>&lt;/pre>
&lt;h2 id="4182-استایل-اوبر-uber">
4.18.2 استایل اوبر (Uber)
&lt;a class="anchor" href="#4182-%d8%a7%d8%b3%d8%aa%d8%a7%db%8c%d9%84-%d8%a7%d9%88%d8%a8%d8%b1-uber">#&lt;/a>
&lt;/h2>
&lt;p>در زیر استایل کدنویسی که تیم مهندسی شرکت اوبر تهیه کردند می پردازیم.&lt;/p>
&lt;h2 id="4183-تکنیک-ها">
4.18.3 تکنیک ها
&lt;a class="anchor" href="#4183-%d8%aa%da%a9%d9%86%db%8c%da%a9-%d9%87%d8%a7">#&lt;/a>
&lt;/h2>
&lt;p>در زیر به تکنیک های زبان گو می پردازیم.&lt;/p>
&lt;h2 id="4184-نکات-فنی">
4.18.4 نکات فنی
&lt;a class="anchor" href="#4184-%d9%86%da%a9%d8%a7%d8%aa-%d9%81%d9%86%db%8c">#&lt;/a>
&lt;/h2>
&lt;p>در زیر چندین نکات فنی قرار دادم که کاربردی می باشد.&lt;/p>
&lt;h3 id="41841-مقدار-صفر-تایپ-ها-و-مقادیر">
4.18.4.1 مقدار صفر تایپ ها و مقادیر
&lt;a class="anchor" href="#41841-%d9%85%d9%82%d8%af%d8%a7%d8%b1-%d8%b5%d9%81%d8%b1-%d8%aa%d8%a7%db%8c%d9%be-%d9%87%d8%a7-%d9%88-%d9%85%d9%82%d8%a7%d8%af%db%8c%d8%b1">#&lt;/a>
&lt;/h3>
&lt;p>همانطور در فصل های قبل اشاره کردیم تایپ ساختار (struct) بدون فیلد مقدارش در حافظه کاملا صفر است. اندازه تایپ آرایه بدون هیچ المنتی صفر است. حال در زیر یک مثال میزنیم تا ببینید:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "unsafe"
type A [0][256]int
type S struct {
x A
y [1 &lt;&lt; 30]A
z [1 &lt;&lt; 30]struct{}
}
type T [1 &lt;&lt; 30]S
func main() {
var a A
var s S
var t T
println(unsafe.Sizeof(a)) // 0
println(unsafe.Sizeof(s)) // 0
println(unsafe.Sizeof(t)) // 0
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در Go، اندازه ها اغلب به عنوان مقادیر int نشان داده می شوند. این به این معنی است که بزرگترین طول ممکن یک آرایه MaxInt است که مقدار آن در سیستم عامل های 64 بیتی &lt;span dir="ltr">2^63-1&lt;/span> است. با این حال، طول آرایه با اندازه عناصر غیر صفر به سختی توسط کامپایلر استاندارد رسمی Go و زمان اجرا محدود می شود.&lt;/p>
&lt;pre>&lt;code class="language-go">var x [1&amp;lt;&amp;lt;63 - 1]struct{} // okay
var y [2000000000 + 1]byte // compilation error
var z = make([]byte, 1&amp;lt;&amp;lt;49) // panic: runtime error: makeslice: len out of range
&lt;/code>&lt;/pre>
&lt;h3 id="41842-نحوه-تخصیص-مقادیر-اندازه-صفر-به-کامپایلر-بستگی-دارد">
4.18.4.2 نحوه تخصیص مقادیر اندازه صفر به کامپایلر بستگی دارد
&lt;a class="anchor" href="#41842-%d9%86%d8%ad%d9%88%d9%87-%d8%aa%d8%ae%d8%b5%db%8c%d8%b5-%d9%85%d9%82%d8%a7%d8%af%db%8c%d8%b1-%d8%a7%d9%86%d8%af%d8%a7%d8%b2%d9%87-%d8%b5%d9%81%d8%b1-%d8%a8%d9%87-%da%a9%d8%a7%d9%85%d9%be%d8%a7%db%8c%d9%84%d8%b1-%d8%a8%d8%b3%d8%aa%da%af%db%8c-%d8%af%d8%a7%d8%b1%d8%af">#&lt;/a>
&lt;/h3>
&lt;p>در اجرای استاندارد رسمی فعلی کامپایلر Go (نسخه 1.20)، همه مقادیر محلی صفر تخصیص داده شده روی heap و آدرس یکسانی دارند. به عنوان مثال، موارد زیر دو بار false را چاپ می کنند، سپس دو بار true را چاپ می کنند.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
var g *[0]int
var a, b [0]int
//go:noinline
func f() *[0]int {
return new([0]int)
}
func main() {
// x and y are allocated on stack.
var x, y, z, w [0]int
// Make z and w escape to heap.
g = &amp;z
g = &amp;w
println(&amp;b == &amp;a) // false
println(&amp;x == &amp;y) // false
println(&amp;z == &amp;w) // true
println(&amp;z == f()) // true
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;blockquote class="book-hint info">
لطفا توجه داشته باشید که خروجی های برنامه فوق به کامپایلرهای خاصی بستگی دارد. خروجی ها ممکن است برای نسخه های کامپایلر استاندارد رسمی Go در آینده متفاوت باشند.
&lt;/blockquote>
&lt;h3 id="41843-فیلد-با-اندازه-صفر-را-به-عنوان-فیلد-نهایی-یک-نوع-ساختار-قرار-ندهید">
4.18.4.3 فیلد با اندازه صفر را به عنوان فیلد نهایی یک نوع ساختار قرار ندهید
&lt;a class="anchor" href="#41843-%d9%81%db%8c%d9%84%d8%af-%d8%a8%d8%a7-%d8%a7%d9%86%d8%af%d8%a7%d8%b2%d9%87-%d8%b5%d9%81%d8%b1-%d8%b1%d8%a7-%d8%a8%d9%87-%d8%b9%d9%86%d9%88%d8%a7%d9%86-%d9%81%db%8c%d9%84%d8%af-%d9%86%d9%87%d8%a7%db%8c%db%8c-%db%8c%da%a9-%d9%86%d9%88%d8%b9-%d8%b3%d8%a7%d8%ae%d8%aa%d8%a7%d8%b1-%d9%82%d8%b1%d8%a7%d8%b1-%d9%86%d8%af%d9%87%db%8c%d8%af">#&lt;/a>
&lt;/h3>
&lt;p>در کد زیر اندازه تایپ Tz از تایپ Ty بزرگتر است.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "unsafe"
type Ty struct {
_ [0]func()
y int64
}
type Tz struct {
z int64
_ [0]func()
}
func main() {
var y Ty
var z Tz
println(unsafe.Sizeof(y)) // 8
println(unsafe.Sizeof(z)) // 16
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>چرا اندازه نوع Tz بیشتر است؟&lt;/p>
&lt;p>در پیاده‌سازی runtime Go استاندارد کنونی، تا زمانی که یک بلوک حافظه توسط حداقل یک اشاره‌گر زنده مشارکت شود، آن بلوک حافظه به عنوان زباله در نظر گرفته نمی‌شود و جمع‌آوری نمی‌شود. همه فیلدهای یک مقدار ساختار قابل دسترسی می‌توانند آدرس‌گرفته شوند. اگر اندازه فیلد نهایی در یک مقدار ساختار با اندازه غیر صفر صفر باشد، آنگاه گرفتن آدرس فیلد نهایی در مقدار ساختاری، آدرسی را که خارج از بلوک حافظه اختصاص داده شده برای مقدار ساختاری است باز خواهد گرداند. آدرس بازگردانده شده ممکن است به بلوک حافظه دیگری که به طور نزدیکی پس از بلوک حافظه اختصاص داده شده برای مقدار ساختاری با اندازه غیر صفر قرار دارد، اشاره کند. تا زمانی که آدرس بازگردانده شده در یک مقدار اشاره‌گر زنده ذخیره شود، بلوک حافظه دیگری که به جمع‌آوری زباله می‌روید جمع‌آوری نخواهد شد که ممکن است باعث نشت حافظه شود. برای جلوگیری از این نوع مشکلات نشت حافظه، کامپایلر Go استاندارد تضمین می‌کند که دریافت آدرس فیلد نهایی در یک ساختار با اندازه غیر صفر هرگز آدرسی را که خارج از بلوک حافظه اختصاص داده شده برای ساختار نیست را بازنخواهد گرداند. کامپایلر Go استاندارد این کار را با وارد کردن برخی بایت‌ها پس از فیلد صفر آخرین انجام می‌دهد. بنابراین، حداقل یک بایت پس از فیلد نهایی (صفر) نوع Tz وجود دارد. به همین دلیل اندازه نوع Tz بزرگتر از Ty است. در واقع، در سیستم عامل‌های ۶۴ بیتی، ۸ بایت پس از فیلد نهایی (صفر) Tz وجود دارد. برای توضیح این موضوع، باید دو حقیقت را در پیاده‌سازی کامپایلر استاندارد رسمی بدانیم:&lt;/p>
&lt;ol>
&lt;li>تضمین ترازبندی یک نوع ساختاری، بزرگترین تضمین ترازبندی فیلدهای آن است.&lt;/li>
&lt;li>اندازه یک نوع همیشه یک ضریبی از تضمین ترازبندی آن است. حقیقت اول، علت برابری تضمین ترازبندی نوع Tz با ۸ (که تضمین ترازبندی نوع int64 است) را توضیح می‌دهد. حقیقت دوم، علت برابری اندازه نوع Tz با ۱۶ را توضیح می‌دهد.&lt;/li>
&lt;/ol>
&lt;p>منبع : &lt;a href="https://github.com/golang/go/issues/9401">https://github.com/golang/go/issues/9401&lt;/a>&lt;/p>
&lt;h2 id="4185-بهینه-سازی">
4.18.5 بهینه سازی
&lt;a class="anchor" href="#4185-%d8%a8%d9%87%db%8c%d9%86%d9%87-%d8%b3%d8%a7%d8%b2%db%8c">#&lt;/a>
&lt;/h2>
&lt;p>در زیر به بهینه سازی در زبان گو می پردازیم.&lt;/p></description></item><item><author/><title>4.19 اصول کامنت نویسی</title><link>https://book.gofarsi.ir/chapter-4/go-commentry/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/go-commentry/</guid><description>&lt;p>اصول کامنت‌نویسی در زبان گو&lt;/p>
&lt;h2 id="4191-تعریف">
4.19.1 تعریف
&lt;a class="anchor" href="#4191-%d8%aa%d8%b9%d8%b1%db%8c%d9%81">#&lt;/a>
&lt;/h2>
&lt;p>«کامنت» به توضیحات‌ی گفته می‌شود که داخل کد، به‌قصد «یادآوری»، «جلب‌توجه مخاطب به موضوع‌(ها)ی خاص»، کمک به onboard شدن اعضاء جدید تیم و مانند اون نگارش می‌شود. در زبان گو، به شیوه‌های زیر کامنت می‌گذاریم:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>قرار دادن &lt;code>//&lt;/code> در ابتدای سطر.&lt;/p>
&lt;pre>&lt;code class="language-go">// defined to store multi string (see below why this is not a good comment)
var sliceVar []string
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>قراردادن متن کامنت داخل یک بلوک که با &lt;code>*/&lt;/code> شروع می‌شود و &lt;code>/*&lt;/code> تمام می‌شود.&lt;/p>
&lt;pre>&lt;code class="language-go">for index, row := range sliceVar {
row /* for loop lifetime */ = &amp;quot;new_val&amp;quot;
sliceVar[index] /* apply to sliceVar out of loop */ = &amp;quot;new_val&amp;quot;
fmt.Println(row) // hint to sliceVar large len
}
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;blockquote class="book-hint info">
&lt;p>دستور ‍&lt;code>gofmt&lt;/code> کامنت‌ها را مانند سایر فرمت‌ها، مرتب می‌نماید. اما روش بهتر درصورت امکان، نظم آنها توسط خود توسعه‌دهنده جهت رعایت الگوها و ساختار خاص هر پروژه است.&lt;/p>
&lt;pre>&lt;code class="language-go">gofmt -w main.go
&lt;/code>&lt;/pre>
&lt;/blockquote>
&lt;h2 id="4192-دیدگاهها-درباره-کامنت">
4.19.2 دیدگاه‌ها درباره «کامنت»
&lt;a class="anchor" href="#4192-%d8%af%db%8c%d8%af%da%af%d8%a7%d9%87%d9%87%d8%a7-%d8%af%d8%b1%d8%a8%d8%a7%d8%b1%d9%87-%da%a9%d8%a7%d9%85%d9%86%d8%aa">#&lt;/a>
&lt;/h2>
&lt;p>با توجه به این موضوع که در جوامع‌تخصصی توسعه نرم‌افزار، درارتباط با اصل وجود کامنت، مزایا/معایب و چگونگی استفاده از آن، مطالب گوناگون و بعضاً متضادی، حتی از جانب متخصصین، وجود دارد، در این قسمت سعی خواهیم کرد، تاجای‌ممکن پاسخ حساب‌شده‌ای به نیازمندی‌های مختلف در ارتباط با «کامنت‌گذاری» بدهیم.&lt;/p>
&lt;h2 id="4193-کامنت-خوب-بد-زشت">
4.19.3 کامنت؛ خوب، بد، زشت
&lt;a class="anchor" href="#4193-%da%a9%d8%a7%d9%85%d9%86%d8%aa-%d8%ae%d9%88%d8%a8-%d8%a8%d8%af-%d8%b2%d8%b4%d8%aa">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>&lt;code>در کدهایی که بارها نسخه‌های متفاوتی از آن ایجاد شده و در طول زمان، نیازمندی‌ها عوض شده، کیفیت، کارایی و سرعت اجرا بهبود پیدا کرده، «کامنت» گزارش «چرایی» کد هست برای این: نیاز/کیفیت/کارایی/سرعت اجرا، برای اینکه همه این‌ها رو دوباره تجربه نکنند ...&lt;/code>&lt;/li>
&lt;li>&lt;code>یک کد خوب، هیچ نیازی به کامنت ندارد، به‌زبان‌دیگر، اگر نیاز می‌بینید که برای کدی «کامنت» بنویسید، احتمالاً، کد خوبی ننوشتید ...&lt;/code>&lt;/li>
&lt;li>&lt;code>یک ساختار جدید، ناشناخته و احتمالاً حجیم، به‌قدر‌کافی ماهیتاً اینقدر پیچیدگی دارد که اضافه شدن، یک توضیح به زبان کاملاً انسانی (داخل زبان کامپایلر/مفسری برای زبان ماشین)، نه‌تنها باعث روشن‌تر شدن آن نمی‌شود بلکه مسئله‌ی فهم منظور نگارنده «کامنت» به مجموعه مسائل قبلی اضافه می‌گردد. هیچ‌چیز بیشتر از یک کد پیچیده با کلی «کامنت‌های» پیچیده برای مخاطبی که انتظار روشن بودن چرایی و چگونگی کد را دارد، عذاب‌آور نیست ... &lt;/code>&lt;/li>
&lt;/ul>
&lt;p>همه این‌ها پاسخ‌های متفاوت‌ی است که توسعه‌دهندگان به موضوع «کامنت» می‌دهند. اما «اصولاً» کامنت پرفایده است یا بی‌فایده؟&lt;/p>
&lt;h2 id="4194-آنالیز-محصول-و-محیط-توسعه">
4.19.4 آنالیز محصول و محیط توسعه
&lt;a class="anchor" href="#4194-%d8%a2%d9%86%d8%a7%d9%84%db%8c%d8%b2-%d9%85%d8%ad%d8%b5%d9%88%d9%84-%d9%88-%d9%85%d8%ad%db%8c%d8%b7-%d8%aa%d9%88%d8%b3%d8%b9%d9%87">#&lt;/a>
&lt;/h2>
&lt;p>وقتی در ارتباط با کامنت صحبت می‌کنیم این خیلی مهم است که ما به‌تنهایی مشغول توسعه یک محصول هستیم یا در یک دپارتمان کوچک یا در یک ابَرپروژه &amp;hellip; آیا ما مجبور به تبعیت از یک‌سری دستورالعمل‌های کدنویسی هستیم یا می‌توانیم سلیقه‌شخصی خود را داشته باشیم؟ &amp;hellip;&lt;/p>
&lt;ul>
&lt;li>&lt;strong>شرایط تیم توسعه&lt;/strong>.
&lt;ul>
&lt;li>نحوه مدیریت(افراد/روش‌ها) پروژه در فرآیند توسعه کد.&lt;/li>
&lt;li>تعداد زیرمجموعه‌ها و تعداد توسعه‌دهندگان در بخش‌های مختلف.&lt;/li>
&lt;li>میزان &lt;strong>ارتباط&lt;/strong> و &lt;strong>حساسیت&lt;/strong> کدها بین واحدها و توسعه‌دهندگان.&lt;/li>
&lt;li>سرعت تغییرات جابجایی توسعه‌دهندگان در پروژه.&lt;/li>
&lt;li>و موارد مشابه دیگر.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>تحلیل نیازمندی‌های محصول&lt;/strong>.
&lt;ul>
&lt;li>مقیاس پروژه.&lt;/li>
&lt;li>زمان توسعه پروژه.&lt;/li>
&lt;li>زمان تغییرات همزمان با نسخه‌های ریلیز شده.&lt;/li>
&lt;li>پیچیدگی و ماهیت نیازهای محصول.&lt;/li>
&lt;li>و موارد مانند این‌ها.
&lt;blockquote class="book-hint warning">
نتیجه اینکه: ابتدا نیازمندی، توانایی و شرایط تیم/محصول را مشخص کنیم، و بعد تصمیم به چرایی و چگونگی کامنت‌نویسی اصولی بگیریم.
&lt;/blockquote>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="4195-انواع-کامنت">
4.19.5 انواع کامنت
&lt;a class="anchor" href="#4195-%d8%a7%d9%86%d9%88%d8%a7%d8%b9-%da%a9%d8%a7%d9%85%d9%86%d8%aa">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>کامنت فایل/پکیج (Doc Comment)&lt;/li>
&lt;/ul>
&lt;p>این‌نوع کامنت‌ها درباره «چیستی» کل فایل یا پکیج توضیح دارد.&lt;/p>
&lt;pre>&lt;code class="language-go">// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
/*
Package builtin provides documentation for Go's predeclared identifiers.
The items documented here are not actually in package builtin
but their descriptions here allow godoc to present documentation
for the language's special identifiers.
*/
package builtin
&lt;/code>&lt;/pre>
&lt;p>مثال بالا از پکیج &lt;code>builtin&lt;/code> درباره حق‌چاپ / تعریف اولیه پکیج و اینکه مستندات در &lt;code>godoc&lt;/code> ارائه می‌شود، توضیح داده است.&lt;/p>
&lt;ul>
&lt;li>کامنت داخلی فانکشن/متد/بلوک/تایپ/متغیر/دستور و مانند آن (Ordinary Comments)
این‌نوع کامنت درباره «چرایی» آن قسمتِ خاص اشاره دارد.&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-go">// The delete built-in function deletes the element with the specified key
// (m[key]) from the map. If m is nil or there is no such element, delete
// is a no-op.
func delete(m map[Type]Type1, key Type)
&lt;/code>&lt;/pre>
&lt;p>در مثال بالا، توسط کامنت توضیح داده شده که وظیفه فانکشن-داخلی &lt;code>delete&lt;/code> حذف المنت با کلید مشخص هست، و توضیح دقیق‌تر اینکه اگر المنت مربوط به کلید &lt;code>nil&lt;/code> باشد یا وجود نداشته باشد، فانکشن &lt;code>delete&lt;/code> هیچ عملیاتی انجام نمی‌دهد. (مثلاً خطا باز نمی‌گرداند − گزارش نمی‌کند و &amp;hellip;)&lt;/p>
&lt;h2 id="4196-اصول-کامنتنویسی">
4.19.6 اصول کامنت‌نویسی
&lt;a class="anchor" href="#4196-%d8%a7%d8%b5%d9%88%d9%84-%da%a9%d8%a7%d9%85%d9%86%d8%aa%d9%86%d9%88%db%8c%d8%b3%db%8c">#&lt;/a>
&lt;/h2>
&lt;p>یک کامنت خوب:&lt;/p>
&lt;ol>
&lt;li>توضیح واضحات را نمی‌دهد.&lt;/li>
&lt;li>در حداقل مقدار «لازم» و «کافی» نگارش می‌شود.&lt;/li>
&lt;li>بیشتر درباره «چیستی/چرایی» اشاره دارد و نه «چگونگی».&lt;/li>
&lt;li>دارای یک الگو و دستورالعمل نگارشی واحد برای نظم و سرعت ارتباط مخاطب است.&lt;/li>
&lt;li>وجودش آگاه‌کننده موضوع بااهمیت بالاست.&lt;/li>
&lt;li>مربوط به موضوعی است که اکنون وجود دارد (بروزرسانی کامنت‌ها-حذف کامنت‌های اضافی)&lt;/li>
&lt;li>ادبیات کامنت، بسته به تیم و دستورالعمل‌ها، بهتر است رسمی نگارش شود تا عمومی بماند. البته گاهی کمی شوخ‌طبعی هم اگر کنترل‌شده باشد، باعث انتقال‌مطلب بهتر می‌شود.&lt;/li>
&lt;li>درصورت لازم بودن یک یا چند منبع مرتبط با کد، حاوی لینک url خواهد بود.
&lt;pre>&lt;code class="language-go"> // flip the buffer for this connection if we need to drain it.
// note that for a successful query (i.e. one where rows.next()
// has been called until it returns false), `rows.mc` will be nil
// by the time the user calls `(*Rows).Close`, so we won't reach this
// see: https://github.com/golang/go/commit/651ddbdb5056ded455f47f9c494c67b389622a47
mc.buf.flip()
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ol>
&lt;h2 id="4197-به-پرتگاه-نزدیک-میشوید">
4.19.7 به پرتگاه نزدیک می‌شوید!
&lt;a class="anchor" href="#4197-%d8%a8%d9%87-%d9%be%d8%b1%d8%aa%da%af%d8%a7%d9%87-%d9%86%d8%b2%d8%af%db%8c%da%a9-%d9%85%db%8c%d8%b4%d9%88%db%8c%d8%af">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>زامبی کد: به کدی می‌گویند که به دلیل عدم کارایی، اصلاح با کد جدید، و یا مشابه این موارد، بجای «حذف»، «کامنت» می‌شوند.&lt;/li>
&lt;li>کامنت اسپاگتی کد: به کامنت‌های دنباله‌داری گفته می‌شود که برای توضیح یک کدی که ساختار منظم و مشخصی ندارد، نگارش می‌شود.&lt;/li>
&lt;li>یکی دیگر از استفاده‌های کامنت، &lt;span class="tooltip" data-tooltip="ToDo" ontouchend="toggleTooltip(this)">وظیفه‌ی برنامه‌ریزی‌شده&lt;/span>
می‌باشد که اگر کنترل نشود، یکی دیگر از عذاب‌های عظیم خواهد بود.&lt;/li>
&lt;li>جای کلمات عبور و مقادیر امنیتی در کامنت نیست.&lt;/li>
&lt;li>اگر دائماً نیاز می‌بینید که در مراحل مختلف به همکاران بصورت کامنت «هشدار» بنویسید، شاید باید به‌فکر اصلاح معماری نرم‌افزار باشید.&lt;/li>
&lt;li>کامنت‌های شما، نباید تبدیل به «نویز» درکدنویسی دیگران شود. تعدد کامنت‌ها کد را تبدیل به کد کثیف می‌کند که خوانایی ضعیفی خواهد داشت.&lt;/li>
&lt;li>کامنت، جای دردل کردن، شکایت از مدیرپروژه، تعریف از خود و گفتگو نیست.&lt;/li>
&lt;/ul>
&lt;h2 id="4198-انواع-directive-comment">
4.19.8 انواع directive comment
&lt;a class="anchor" href="#4198-%d8%a7%d9%86%d9%88%d8%a7%d8%b9-directive-comment">#&lt;/a>
&lt;/h2>
&lt;p>&lt;span dir="ltr">&lt;strong>//go:generate&lt;/strong>&lt;/span>: این کامنت برای مشخص کردن یک دستور است که باید توسط ابزار go generate اجرا شود. این کامنت معمولاً قبل از یک دستور تولید کد قرار داده می‌شود که به شما اجازه می‌دهد کد Go را به صورت خودکار تولید کنید.&lt;/p>
&lt;p>&lt;span dir="ltr">&lt;strong>//go:binary-only-package&lt;/strong>&lt;/span>: این کامنت برای اعلام این استفاده می‌شود که یک بسته باید به عنوان یک بسته فقط دودویی در کامنت گرفته شود، به معنای این است که کد منبع بسته در دسترس نیست. این برای بسته‌هایی استفاده می‌شود که شامل کد‌های محصولی یا بسته‌های مشخص سیستم‌عامل هستند.&lt;/p>
&lt;p>&lt;span dir="ltr">&lt;strong>//go:build&lt;/strong>&lt;/span>: این کامنت برایمحدودیت‌های ساخت استفاده می‌شود. این به شما امکان می‌دهد که کنترل کنید که یک فایل باید بر اساس شرایط خاصی مانند سیستم عامل، معماری یا برچسب ساخت، در ساخت شامل شود یا خیر.&lt;/p>
&lt;p>&lt;span dir="ltr">&lt;strong>//go:cgo_&amp;hellip;&lt;/strong>&lt;/span>: چندین کامنت دستوری وجود دارد که با cgo_ شروع می‌شوند، مانند //go:cgo_import_dynamic و //go:cgo_export_dynamic. این کامنتات همراه با cgo استفاده می‌شوند، ابزاری که به کد Go اجازه می‌دهد تا به کد C و بالعکس برای فراخوانی دستورات استفاده شود. آن‌ها دستوراتی را به ابزار cgo ارائه می‌دهند که نحوه برخورد کد C را مشخص می‌کنند.&lt;/p>
&lt;p>&lt;span dir="ltr">&lt;strong>//go:noinline:&lt;/strong>&lt;/span> این کامنت برای مشخص کردن این استفاده می‌شود که یک تابع توسط کامپایلر به صورت inline نباید درج شود. Inline کردن یک تابع یک تکنیک بهینه‌سازی است که کد یک تابع به طور مستقیم در کد فراخواننده آن قرار می‌گیرد و هزینه فراخوانی تابع را حذف می‌کند. استفاده از این کامنت از کامپایلر جلوگیری می‌کند تا برای تابع مشخص شده inline کردن انجام دهد.&lt;/p>
&lt;p>&lt;span dir="ltr">&lt;strong>//go:nosplit&lt;/strong>&lt;/span>: این کامنت برای مشخص کردن این استفاده می‌شود که یک تابع باید توسط برنامه‌ریز Go runtime اجرا شده (split) نشود. این معمولاً برای توابع سطح پایین استفاده می‌شود که نیاز به کنترل دقیق بر روی اجرای آن‌ها دارند و نباید وقفه داده شوند.&lt;/p>
&lt;p>&lt;span dir="ltr">&lt;strong>//go:linkname&lt;/strong>&lt;/span>: این کامنت برای برقراری ارتباط بین کد Go و نمادهای خارجی یا کد غیر Go استفاده می‌شود. این به شما اجازه می‌دهد تا به یک نماد با نام متفاوت یا از بسته‌ای دیگر ارجاع دهید.&lt;/p>
&lt;p>&lt;span dir="ltr">&lt;strong>//go:noescape&lt;/strong>&lt;/span>: این کامنت برای مشخص کردن این استفاده می‌شود که آرگومان‌های اشاره گر تابع escape نمی‌کنند، به معنایی که در طول عمر تابع ذخیره یاستفاده نمی‌شوند یا استفاده نمی‌شوند. این اطلاعات به کامپایلر اجازه می‌دهند که بهینه‌سازی‌های حافظه تابع را انجام دهد.&lt;/p>
&lt;p>&lt;span dir="ltr">&lt;strong>//go:embed&lt;/strong>&lt;/span>: این کامنت برای اضافه کردن فایل‌های استاتیک یا دایرکتوری‌ها به طور مستقیم به باینری Go در زمان کامپایل استفاده می‌شود. این فرآیند از جمله فرآیند بسته‌بندی و توزیع منابع با برنامه‌های Go خود است.&lt;/p>
&lt;p>&lt;span dir="ltr">&lt;strong>//go:generate go run&lt;/strong>&lt;/span>: این کامنت یک نوع دیگر از کامنت //go:generate است. این کامنت مشخص می‌کند که دستور زیر کامنت باید توسط اجرای برنامه Go با استفاده از دستور go run اجرا شود.&lt;/p>
&lt;p>&lt;span dir="ltr">&lt;strong>//go:build &amp;hellip;&lt;/strong>&lt;/span>: این کامنت یک فرم گسترده‌تر از کامنت build است. این به شما امکان می‌دهد شرایط ساخت را با استفاده از اپراتورهای منطقی بولی، پرانتز و نفی مشخص کنید. این امکانات بیشتری در کنترل کردن فایل‌هایی که در ساخت شامل می‌شوند، فراهم می‌کند.&lt;/p>
&lt;p>&lt;span dir="ltr">&lt;strong>//go:protofile&lt;/strong>&lt;/span>: این کامنت برای مشخص کردن پروتوباف فایل مرتبط با یک فایل منبع Go استفاده می‌شود. این معمولاً در کد Go استفاده می‌شود که شامل کد پروتوباف تولید شده است، اجازه می‌دهد که کامپایلر فایل‌های Go و پروتوباف رابه درستی به هم پیوند دهد.&lt;/p>
&lt;p>&lt;span dir="ltr">&lt;strong>//go:nowritebarrier&lt;/strong>&lt;/span>: این کامنت برای مشخص کردن این استفاده می‌شود که یک تابع بدون write barrier باید اجرا شود. Write barrier برای تعقیب و به‌روزرسانی اشاره‌گرها در زمان تخصیص و آزادسازی حافظه توسط garbage collector استفاده می‌شود. استفاده از این کامنت ممکن است خطرناک باشد و تنها در موارد خاصی که مدیریت دستی حافظه لازم است، باید استفاده شود.&lt;/p>
&lt;p>&lt;span dir="ltr">&lt;strong>//go:norace&lt;/strong>&lt;/span>: این کامنت دستوری برای غیرفعال کردن ردیابی race برای یک تابع خاص است. ردیاب race یک ابزار در Go است که به شناسایی دسترسی همزمان به متغیرهای مشترک که ممکن است منجر به دور زدن داده‌ها (race condition) بشود، کمک می‌کند. این دستور می‌تواند هنگامی استفاده شود که از عدم وجود شرایط race برای یک تابع خاص اطمینان دارید.&lt;/p>
&lt;p>&lt;span dir="ltr">&lt;strong>//go:buildignore&lt;/strong>&lt;/span>: این کامنت دستوری برای حذف یک فایل از فرآیند ساخت استفاده می‌شود. این به سیستم ساخت Go می‌گوید که این فایل را نادیده بگیرد و در هنگام کامپایل بسته، شامل نشود.&lt;/p>
&lt;p>&lt;span dir="ltr">&lt;strong>//go:generate goimports&lt;/strong>&lt;/span>: این کامنت دستوری برای استفاده در ارتباط با دستور //go:generate استفاده می‌شود تا به صورت خودکار ابزار goimports اجرا شود. goimports به طور خودکار import statements را به روزرسانی و فرمت دهی می‌کند، اطمینان حاصل می‌کند که import های بسته درست هستند و import های بی‌استفاده را حذف می‌کند.&lt;/p>
&lt;p>&lt;span dir="ltr">&lt;strong>//go:embed pattern&lt;/strong>&lt;/span>: این کامنت دستوری یک فرم گسترده‌تر از //go:embed است و به شما اجازه می‌دهد الگویی را برای تطبیق با فایل‌ها یا دایرکتوری‌ها برای جاسازی در حالت تعبیه شده مشخص کنید. این امکانات، در انتخاب فایل‌ها یا دایرکتوری‌های خاص بیشتری ارائه می‌دهد.&lt;/p>
&lt;p>&lt;span dir="ltr">&lt;strong>//go:nolint&lt;/strong>&lt;/span>: این کامنت دستوری برای سرکوب خطاها و هشدارهای خاص لینتر برای یک خط کد خاص استفاده می‌شود. این اغلب هنگامی استفاده می‌شود که یک قانون لینتر یک false positive را سیگنال می‌دهد یا وقتی دلیل معتبری برای نادیده گرفتن یک مسئله لینتینگ موقتا وجود دارد.&lt;/p>
&lt;p>&lt;span dir="ltr">&lt;strong>//go:generate go test&lt;/strong>&lt;/span>: این کامنت دستوری برای استفاده در ارتباط با دستور //go:generate استفاده می‌شود تا به صورت خودکار دستور go test اجرا شود. این دستور معمولاً برای تولید و اجرای کد آزمایشی برای یک بسته استفاده می‌شود.&lt;/p>
&lt;p>&lt;span dir="ltr">&lt;strong>//go:uintptrescapes&lt;/strong>&lt;/span>: این کامنت دستوری برای نشان دادن این است که یک مقدار uintptr ممکن است به حافظه heap فرار کند. به طور پیش فرض، کامپایلر فرض می‌کند که مقدارهای uintptr فرار نمی‌کنند، اما استفاده از این دستور اجازه تجزیه و تحلیل فرار دقیق‌تر را می‌دهد.&lt;/p>
&lt;p>&lt;span dir="ltr">&lt;strong>//go:build !constraint&lt;/strong>&lt;/span>: این کامنت دستوری برای حذف یک فایل از فرآیند ساخت بر اساس شرط ساخت خاص استفاده می‌شود. این به شما اجازه می‌دهد یک شرط را مشخص کنید که برای شامل شدن فایل در فرآیند ساخت باید برآورده نشود.&lt;/p>
&lt;p>&lt;span dir="ltr">&lt;strong>//go:checkptr&lt;/strong>&lt;/span>: این کامنت دستوری برای فعال کردن بررسی‌های ایمنی اضافی برای اشاره‌گرها در کد استفاده می‌شود. این دستور به کامپایلر دستور می‌دهد تا بررسی‌های رانتایم اضافی را برای شناسایی عملیات اشاره‌گر ناموفق و مسائل امنیتی حافظه انجام دهد.&lt;/p>
&lt;p>&lt;span dir="ltr">&lt;strong>//go:nosplitcheck&lt;/strong>&lt;/span>: این کامنت دستوری برای غیرفعال کردن بررسی nosplit برای یک تابع استفاده می‌شود. بررسی nosplit بررسی می‌کند که یک تابع بدون پیش‌بینی از برنامه‌ای که در آینده اجرا می‌شود، بدون توقف توسط برنامه اجرا شود.استفاده از این دستور ممکن است خطرناک باشد و فقط در صورت ضرورت باید استفاده شود.&lt;/p>
&lt;p>&lt;span dir="ltr">&lt;strong>//go:noruntime&lt;/strong>&lt;/span>: این کامنت دستوری برای نشان دادن این است که یک بسته به Go runtime وابسته نیست. این به کامپایلر اطلاع می‌دهد که بسته می‌تواند در یک محیط استفاده شود که Go runtime در دسترس نیست یا نیاز نیست.&lt;/p>
&lt;p>&lt;strong>مثال استفاده از directive comment:&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import &amp;quot;fmt&amp;quot;
//go:generate stringer -type=Age
type Age int
const (
CHILDERN Age = iota
ADOLESCENTS
ADULTS
)
func main() {
fmt.Println(CHILDERN.String())
}
&lt;/code>&lt;/pre>
&lt;p>در کد فوق ما یک directive comment اضافه کردیم حال کافیه با استفاده از دستور go generate متد استرینگ تایپ را جنریت کنیم.&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go generate ./...
&lt;/code>&lt;/pre></description></item><item><author/><title>4.20 قوانین کدنویسی در گو</title><link>https://book.gofarsi.ir/chapter-4/go-code-rules/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/go-code-rules/</guid><description>&lt;p>قوانین در زبان گو همانند دیگر زبان های برنامه نویسی به دو دسته تقسیم می شود. بخشی از قوانین در سطح &lt;span class="tooltip" data-tooltip="Syntax" ontouchend="toggleTooltip(this)">سینتکس&lt;/span>
زبان مطرح می شوند، لذا رعایت آنها مهم هست، در غیر اینصورت کامپایلر قادر به کامپایل درست کدهای شما نخواهد بود و در بعضی شرایط ممکن است به صورت خاموش خطا به محیط اجرا (runtime) نیز برده شود. بخشی از قوانین به عنوان پیشنهاد و ترجیح مطرح هستند که عموما توسط لینتر بررسی می شوند و تاثیر اصلی بر خوانایی منطق کدها دارند. یعنی رعایت آنها الزام قطعی ندارد. به طور مثال استفاده از &lt;code>_&lt;/code> در نام گذاری ها در گو توصیه نمی شود ولی در کتابخانه استاندارد (الحاقی به زبان گو) به وفور عدم رعایت این موضوع دیده می شود.&lt;/p>
&lt;p>لازم به ذکر است که سازمان ها می توانند قوانین پیشنهادی خود را توسعه دهند و با توسعه لینتر اختصاصی در فرآیند توسعه نرم افزار خود با روش هایی مانند CI/CD از رعایت قوانین خود توسط توسعه دهندگان پروژه های نرم‌افزاری خود اطمینان حاصل نمایند.&lt;/p>
&lt;h2 id="4201-قوانین-نام-گذاری">
4.20.1 قوانین نام گذاری
&lt;a class="anchor" href="#4201-%d9%82%d9%88%d8%a7%d9%86%db%8c%d9%86-%d9%86%d8%a7%d9%85-%da%af%d8%b0%d8%a7%d8%b1%db%8c">#&lt;/a>
&lt;/h2>
&lt;p>در زبان برنامه‌نویسی Go برای نامگذاری توابع، همان گونه که در بالا نیز توضیح داده شد دو مدل قوانین (اجباری و اختیاری) وجود دارد. قوانین اجباری باید رعایت شوند و قوانین اختیاری بهتر است رعایت شوند تا کد هم خوانایی بیشتری داشته باشد و هم از نظر تعاریف و نام‌گذاری مطابق رویه های (پروتکل های) معرفی شده توسط تیم توسعه زبان، به صورت استاندارد باشند.&lt;/p>
&lt;h3 id="42011-نام-توابع">
4.20.1.1 نام توابع
&lt;a class="anchor" href="#42011-%d9%86%d8%a7%d9%85-%d8%aa%d9%88%d8%a7%d8%a8%d8%b9">#&lt;/a>
&lt;/h3>
&lt;p>نام توابع باید با حروف بزرگ یا کوچک شروع شود. توابعی که با حروف بزرگ شروع می‌شوند، به عنوان public تلقی می‌شوند و از سمت بیرون پکیج برای دیگران قابل دسترس هستند. توابعی که با حروف کوچک شروع می‌شوند، به عنوان private تلقی می‌شوند و فقط در داخل پکیج موجود هستند.&lt;/p>
&lt;ul>
&lt;li>نام توابع public بصورت Pascal Case هستند مانند: ()CalculateInterestRate&lt;/li>
&lt;li>نام توابع private بصورت camel Case هستند مانند: ()calculateInterestRate&lt;/li>
&lt;/ul>
&lt;p>برای اطلاعات بیشتر درخصوص public یا private میتوانید به بخش &lt;a href="https://book.gofarsi.ir/chapter-4/oop/go-encapsulation/">Encapsulation&lt;/a> مراجعه کنید.&lt;/p>
&lt;h3 id="42012-نام-فایل-های-پسوند-go">
4.20.1.2 نام فایل های پسوند go.
&lt;a class="anchor" href="#42012-%d9%86%d8%a7%d9%85-%d9%81%d8%a7%db%8c%d9%84-%d9%87%d8%a7%db%8c-%d9%be%d8%b3%d9%88%d9%86%d8%af-go">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>نام فایل باید با حرف کوچک شروع شود.&lt;/li>
&lt;li>نام فایل باید از حروف بزرگ و خط تیره (-) استفاده نکند.&lt;/li>
&lt;li>نام فایل باید با نام پکیج مطابقت داشته باشد.&lt;/li>
&lt;li>نام فایل باید از جمله معانی آن و بخشی از توضیح فایل باشد. برای مثال: database_connection.go، calculator_test.go&lt;/li>
&lt;/ul>
&lt;h3 id="42013-نام-interface">
4.20.1.3 نام interface
&lt;a class="anchor" href="#42013-%d9%86%d8%a7%d9%85-interface">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>نام اینترفیس باید با I شروع نشود.&lt;/li>
&lt;li>نام اینترفیس باید با camelCase باشد.&lt;/li>
&lt;li>نام اینترفیس باید صفت یا اسم باشد و معمولاً با حرف I شروع نمی‌شود. برای مثال: Reader، Writer&lt;/li>
&lt;li>در انتهای نام حتما er داشته باشد.&lt;/li>
&lt;/ul>
&lt;h3 id="42014-نام-پارامترهای-توابع">
4.20.1.4 نام پارامترهای توابع
&lt;a class="anchor" href="#42014-%d9%86%d8%a7%d9%85-%d9%be%d8%a7%d8%b1%d8%a7%d9%85%d8%aa%d8%b1%d9%87%d8%a7%db%8c-%d8%aa%d9%88%d8%a7%d8%a8%d8%b9">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>نام پارامترها باید با حروف کوچک شروع شود.&lt;/li>
&lt;li>نام پارامترها باید با camelCase باشد.&lt;/li>
&lt;/ul>
&lt;p>برای مثال، تابع زیر درست نام‌گذاری شده است:&lt;/p>
&lt;pre>&lt;code class="language-go">func CalculateInterestRate(principal float64, interestRate float64, termInYears int) float64 {
// function code here
}
&lt;/code>&lt;/pre>
&lt;p>در این مثال، تمامی پارامترهای تابع با حروف کوچک، با CamelCase نام‌گذاری شده‌اند.&lt;/p>
&lt;p>به طور کلی، هدف از این قوانین نام‌گذاری، رعایت استانداردهایی برای نام‌گذاری است تا کد خواناتر و قابل فهم باشد و همچنین قابلیت نگهداری و توسعه را بهتری داشته باشد.&lt;/p>
&lt;h3 id="42015-نام-پکیج">
4.20.1.5 نام پکیج
&lt;a class="anchor" href="#42015-%d9%86%d8%a7%d9%85-%d9%be%da%a9%db%8c%d8%ac">#&lt;/a>
&lt;/h3>
&lt;p>نام پکیج در Go باید با حرف کوچک شروع شود و نام پکیج باید شامل تنها حروف کوچک انگلیسی، اعداد و خط فاصله (-) باشد. همچنین در نام پکیج از حروف بزرگ استفاده نشود، همچنین اسم پکیج باید توصیفی از محتوای آن باشد. برای نام‌گذاری پکیج، معمولاً از نام اصلی محصول یا سرویسی که پیاده‌سازی می‌شود، یا نام ماژول یا قسمتی از نرم‌افزار استفاده می‌شود.&lt;/p>
&lt;p>مثلاً اگر یک پروژه برای پردازش تصویر داریم، نام پکیج می‌تواند &amp;ldquo;imageprocessing&amp;rdquo; باشد. همچنین اگر می‌خواهیم یک کتابخانه بخشی از پروژه خود را به اشتراک بگذاریم، می‌توانیم از نام پروژه یا نام ماژول استفاده کنیم.&lt;/p>
&lt;p>توجه داشته باشید که نام پکیج باید با نام پوشه‌ای که فایل‌های پروژه در آن هستند همخوانی داشته باشد. برای مثال، اگر فایل‌های پروژه در پوشه imageprocessing قرار دارند، نام پکیج باید imageprocessing باشد.&lt;/p>
&lt;h3 id="42016-نام-متغیر-و-const">
4.20.1.6 نام متغیر و const
&lt;a class="anchor" href="#42016-%d9%86%d8%a7%d9%85-%d9%85%d8%aa%d8%ba%db%8c%d8%b1-%d9%88-const">#&lt;/a>
&lt;/h3>
&lt;p>برای متغیرها و ثابت‌ها در زبان برنامه‌نویسی Go نیز نام‌های خاصی وجود دارد که برای آن‌ها پیشنهاد می‌شود. در ادامه به برخی از قوانین نام‌گذاری برای متغیرها و ثابت‌ها در Go اشاره می‌شود:&lt;/p>
&lt;p>&lt;strong>متغیر&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>نام متغیر باید با حرف کوچک شروع شود.&lt;/li>
&lt;li>نام متغیر باید جهت نمایش نوع متغیر در نام آن و حاوی توضیح مختصر در مورد نام متغیر باشد.&lt;/li>
&lt;li>نام متغیر باید با camelCase باشد.&lt;/li>
&lt;li>نام متغیر باید کاملاً توصیفی باشد و نیازی به توضیحات اضافی در مورد آن نباشد.&lt;/li>
&lt;/ul>
&lt;p>برای مثال، به جای تعریف متغیر x برای نگهداری مقدار سن، می‌توان از نام age استفاده کرد:&lt;/p>
&lt;pre>&lt;code class="language-go">var age int // تعریف متغیر برای سن شخص
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>const&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>نام ثابت باید با حروف بزرگ شروع شود.&lt;/li>
&lt;li>نام ثابت باید جهت نمایش نوع ثابت در نام آن و حاوی توضیح مختصر در مورد مقدار ثابت باشد.&lt;/li>
&lt;li>نام ثابت باید با Snake_case باشد.&lt;/li>
&lt;li>نام ثابت باید کاملاً توصیفی باشد و نیازی به توضیحات اضافی در مورد آن نباشد.&lt;/li>
&lt;/ul>
&lt;p>برای مثال، برای تعریف ثابت مقدار پاییز در فصل های سال، می‌توانیم از نام SEASON_AUTUMN استفاده کنیم:&lt;/p>
&lt;pre>&lt;code class="language-go">const SEASON_AUTUMN = &amp;quot;پاییز&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>توجه داشته باشید که برای نام‌گذاری متغیرها و ثابت‌ها در Go، پیشنهاد می‌شود از نام‌هایی استفاده کنید که بهره بیشتری از خوانایی و قابلیت نگهداری کد برداشته شود. و نام‌هایی که توصیف کننده‌تر و صحیح‌تر هستند برای این منظور بهتر استفاده می‌شوند.&lt;/p></description></item><item><author/><title>4.21 زباله جمع کن (garbage collector)</title><link>https://book.gofarsi.ir/chapter-4/go-garbage-collector/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/go-garbage-collector/</guid><description>&lt;p>یکی از جذابیت های زبان های برنامه نویسی جدید قابلیت زباله جمع کن (garbage collector) ایجاد شده در آنها است. بطور خلاصه مدیریت و آزاد سازی منابع اختصاص داده شده از حافظه را که بصورت خودکار در زبان های برنامه نویسی مدرن انجام می شود را garbage collector می شناسیم.&lt;/p>
&lt;p>مدیریت منابع حافظه که بسیار حساس و در مواقعی زمان بر است توسط برخی زبان ها بصورت توکار پشتیبانی می شود و این کار به افزایش سرعت و همچنین کاهش خطا در زمان و پروسه تولید نرم افزار می شود. با تمام این تفاسیر مواقعی است که برنامه نویس می باید خودش مدیریت حافظه را در دست گرفته و پیش از بروز شرایط بحرانی اقدام به آزاد سازی حافظه و یا منابع اختصاص یافته نماید. خبر خوب اینکه در زبان Go مدیریت منابع حافظه نسبت به زبان های دیگر ساده تر و راحتر است ولی در این نوشته سعی می کنیم تا درک خوبی از مدیریت منابع و نحوه عملکرد آن داشته باشید بنابر این در ادامه با یک مثال که نیاز به بررسی کد در سطوح پایین دارد می پردازیم.&lt;/p>
&lt;h2 id="استفاده-از-uprobes">
استفاده از uprobes
&lt;a class="anchor" href="#%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-uprobes">#&lt;/a>
&lt;/h2>
&lt;p>برای بررسی وضعیت حافظه ما از &lt;a href="https://jvns.ca/blog/2017/07/05/linux-tracing-systems/#uprobes">uprobes&lt;/a> استفاده می کنیم این بسته امکان بسیاری در اختیارمان قرار می دهد برای مثال نیازی به تغییر کد برنامه نمی باشد و برای برنامه های درحال اجرا نیز می توان استفاده نمود.&lt;/p>
&lt;h2 id="مراحل-garbage-collection">
مراحل garbage collection
&lt;a class="anchor" href="#%d9%85%d8%b1%d8%a7%d8%ad%d9%84-garbage-collection">#&lt;/a>
&lt;/h2>
&lt;p>مکانیزم garbage collection در زبان go بصورت هم رونده یا concurrent در کنار برنامه ما اجرا می شود که همین قابلیت دلیل عدم توقف یا مکث برنامه در زمان پاکسازی حافظه است و دو مرحله کلی را برای پاکسازی حافظه اجرا می کند.&lt;/p>
&lt;p>1- &lt;strong>مرحله Mark phase&lt;/strong>
در این مرحله GC اشیاء و متغیرهای مرده دربرنامه که بخشی از حافظه را اشغال کرده‌اند را جستجو و شناسایی می کند.&lt;/p>
&lt;p>2- &lt;strong>مرحله Sweep phase&lt;/strong>
در این مرحله اشیائی که در فاز قبل نشانه گذاری شده‌اند بصورت فیزیکی از حافظه دور ریخته می شود.&lt;/p>
&lt;p>&lt;center>&lt;a href="#">
&lt;img src="../../assets/img/content/chapter4/gc/GC.jpg" alt="GC">
&lt;/a>&lt;/center>
تصویر بالا مراحل مختلف شناسایی و پاکسازی را نشان می دهد&lt;/p>
&lt;p>در ادامه قطعه کد ذیل را داریم که در واقع یک عمل ساده درخواست و پاسخ به یک آدرس وب است&lt;/p>
&lt;pre>&lt;code class="language-GO">http.HandleFunc(&amp;quot;/allocate-memory-and-run-gc&amp;quot;, func(w http.ResponseWriter, r *http.Request) {
arrayLength, bytesPerElement := parseArrayArgs(r)
arr := generateRandomStringArray(arrayLength, bytesPerElement)
fmt.Fprintf(w, fmt.Sprintf(&amp;quot;Generated string array with %d bytes of data\n&amp;quot;, len(arr) * len(arr[0])))
runtime.GC()
fmt.Fprintf(w, &amp;quot;Ran garbage collector\n&amp;quot;)
})
&lt;/code>&lt;/pre>
&lt;p>در این قطعه کد یک متغیر که محتوای آن آرایه‌ای از رشته ها است تولید می شود و در پایان با صدا زدن تابع runtime.GC از GC درخواست می کنیم که حافظه را پاکسازی کند دقت کنید که در این قسمت از کد شی arr دیگر مورد استفاده قرار نمی گیرد و از نظر طول عمر مرده به حساب می آید و GC اقدام به پاکسازی فظای اشغال شده توسط این متغیر را می کند.&lt;/p>
&lt;p>اما داستان به این سادگی هم نیست برای مثال مهمترین ویژگی GC این است که بصورت خودکار در زمان های مناسب وارد عمل می شود و اقدام به رها سازی حافظه می نماید باید توجه داشته باشیم که خود عملیات GC بدون سربار به سیستم نیست و شامل موارد ذیل است&lt;/p>
&lt;p>&lt;strong>GC Pause Time:&lt;/strong>
عملیات پاکسازی بصورت همزمان با اجرای برنامه انجام می شود ولیکن در برنامه های سنگین بصورت لحظه ای می شود متوجه سربار زمان توقف برنامه برای عملیات پاکسازی شد. هرچند که برای کاربران عادی مشهود نباشد.&lt;/p>
&lt;p>&lt;strong>Memory Allocation:&lt;/strong>
جهت نشانه گذاری اشیاء مرده نیز نیاز به تخصیص حافظه است.&lt;/p>
&lt;p>&lt;strong>CPU usage:&lt;/strong>
تمامی فعالیت های انجام شده نیاز به پردازش دارد که قاعدتا به پردازنده سربار اضافی تحمیل خواهد کرد.&lt;/p>
&lt;p>&lt;strong>GC trigger threshold&lt;/strong>
این قابلیت در زبان go قابل تنظیم است و اجازه می دهد تا یک آستانه برای عملیات پاکسازی در نظر بگیریم که به بصورت درصد مشخص می شود. چنانچه درصد استفاده از حافظه از مقدار تعیین شده در متغیر آستانه بیشتر شود عملیات پاکسازی اجرا خواهد شد که این به نوبه خود چالش برانگیز است برای مثال اگر مقدار آستانه را زیاد تعریف کنیم ممکن است برنامه با کمبود منابع روبرو شود و یا درصورت تعیین مقدار پایین منابعی مانند پردازنده بیش از حد درگیر خواهند شد.
&lt;strong>Memory Pressure:&lt;/strong>
مواقعی که برنامه به لحاظ منابع حافظه تحت فشار و محدودیت است در این زمان GC بطور متوالی اجرا خواهد شد که می تواند دلیل توقف برنامه اصلی شود&lt;/p>
&lt;h2 id="مانیتور-نحوه-کار-gc">
مانیتور نحوه کار GC
&lt;a class="anchor" href="#%d9%85%d8%a7%d9%86%db%8c%d8%aa%d9%88%d8%b1-%d9%86%d8%ad%d9%88%d9%87-%da%a9%d8%a7%d8%b1-gc">#&lt;/a>
&lt;/h2>
&lt;p>در ادامه میخواهیم توابع ذیل که در runtime موجود است را به کمک uprobes زیر نظر بگیریم تا علاوه بر مقادیر تولید شده در آنها، فرآیند آنها نیز برایمان قابل درک باشد.&lt;/p>
&lt;ol>
&lt;li>GC
تابع اجرای عملیات پاکسازی&lt;/li>
&lt;li>gcWaitOnMark
تابع تشخیص اشیا جهت رها سازی&lt;/li>
&lt;li>gcSweep
تابع رها سازی منابع&lt;/li>
&lt;/ol>
&lt;p>دقت داشته باشید که تنظیم و اجرا uprobes نیاز به اطلاع بیشتر دارد که در حوصله این نوشتار نیست و متوانید با جستجو در اینترنت به منابع مورد نیاز دسترسی داشته باشید&lt;/p>
&lt;pre>&lt;code class="language-shell">$ curl '127.0.0.1/allocate-memory-and-run-gc?arrayLength=10&amp;amp;bytesPerElement=20'
Generated string array with 200 bytes of data
Ran garbage collector
&lt;/code>&lt;/pre>
&lt;p>پس از اجرای کوئری بالا بر روی آدرس برنامه خود نتایج ذیل حاصل می شود
&lt;center>&lt;a href="#">
&lt;img src="../../assets/img/content/chapter4/gc/gcevents.png" alt="table">
&lt;/a>&lt;/center>
&lt;/p>
&lt;p>نکته قابل توجه اینجاست که تابع gcWaitOnMark دو بار در طول عملیات پاکسازی اجار می شود که بار اول جهت اعتبار سنجی منابع نشانه گذاری شده قسمت قبل است.&lt;/p>
&lt;p>با این توضیحات حال می خواهیم به بررسی چند مثال ساده بپردازیم تا ببینیم در چه مواقعی بهتر است برنامه نویس در بخش های مناسب خود اقدام به پاکسازی حافظه نماید&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"fmt"
"runtime"
)
func main() {
// Allocate some memory for the program to use
s := make([]string, 0, 100000)
for i := 0; i &lt; 100000; i++ {
s = append(s, "hello, world")
}
// Print the initial memory usage
var m runtime.MemStats
runtime.ReadMemStats(&amp;m)
fmt.Println("Initial HeapAlloc: ", m.HeapAlloc)
// Trigger the garbage collector
runtime.GC()
// Print the memory usage after the garbage collector has run
runtime.ReadMemStats(&amp;m)
fmt.Println("After GC HeapAlloc: ", m.HeapAlloc)
// Release the memory
s = nil
// Trigger the garbage collector
runtime.GC()
// Print the memory usage after the garbage collector has run
runtime.ReadMemStats(&amp;m)
fmt.Println("After release HeapAlloc: ", m.HeapAlloc)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در کد بالا به کمک یک حلقه در هربار اجرای آن مقداری را به رشته قبلی خود اضافه نموده ایم و بعد از آن مقدار فضای اشغال شده توسط رشته ما در حافظه را نمایش می دهیم در ادامه به کمک runtime.GC حافظه را تخلیه می کنیم و در انتها بررسی می کنیم که آیا مقدار متغیر ما بصورت واقعی تخلیه شده است که نتایج خروجی موارد فوق را تائید می نماید. به یاد داشته باشید که منابع سیستم همواره محدود می باشد و در شرایط این چنینی می بایست خود برنامه نویس با تشخیص درست اقدام به تخلیه حافظه نماید.&lt;/p>
&lt;h2 id="استفاده-از-godebug">
استفاده از GODEBUG
&lt;a class="anchor" href="#%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-godebug">#&lt;/a>
&lt;/h2>
&lt;p>در مواقعی نیاز است تا GC را بدونه کتابخانه و ابزار اضافی و فقط با قابلیت‌های داخلی خود زبان go بررسی نمائیم که در چنین شرایطی بهتر است از GODEBUG استفاده کنیم.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"fmt"
"runtime"
"time"
)
func printStats(mem runtime.MemStats) {
runtime.ReadMemStats(&amp;mem)
fmt.Println("mem.Alloc:", mem.Alloc)
fmt.Println("mem.TotalAlloc:", mem.TotalAlloc)
fmt.Println("mem.HeapAlloc:", mem.HeapAlloc)
fmt.Println("mem.NumGC:", mem.NumGC)
fmt.Println("-----")
}
func main() {
var mem runtime.MemStats
printStats(mem)
for i := 0; i &lt; 10; i++ {
s := make([]byte, 100000000)
if s == nil {
fmt.Println("Operation failed!")
}
}
printStats(mem)
for i := 0; i &lt; 10; i++ {
s := make([]byte, 100000000)
if s == nil {
fmt.Println("Operation failed!")
}
time.Sleep(5 * time.Second)
}
printStats(mem)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در کد فوق برنامه بدون دیباگ خروجی فوق را تولید نموده است که مقدار منابع مصرف شده در هر چرخه را نمایش می دهد اما اگر بخواهیم برنامه را با دستور GODEBUG اجرا کنیم خروجی متفاوت خواهد بود به یاد داشته باشید ما در اینجا میخواهیم مقادیر تولید شده که بصورت key-value است و با علامت کاما از هم جدا شده اند و فقط برای GC را بررسی کنیم درحالی که می توان بخش های دیگر برنامه را نیز با سوئیچ های مختلف دیباگ کرد بنابراین اینبار برنامه را با دستور ذیل اجرا می کنیم&lt;/p>
&lt;pre>&lt;code class="language-bash"># GODEBUG=gctrace=1 go run main.go a
gc 1 @0.019s 1%: 0.014+2.4+0.001 ms clock, 0.014+0.33/0/0+0.001 ms cpu, 4-&amp;gt;4-&amp;gt;0 MB, 5 MB goal, 1 P
gc 2 @0.050s 3%: 0.027+5.1+0.002 ms clock, 0.027+0.37/1.0/0+0.002 ms cpu, 4-&amp;gt;4-&amp;gt;1 MB, 5 MB goal, 1 P
gc 3 @0.089s 2%: 0.067+3.3+0.002 ms clock, 0.067+0.66/0/0+0.002 ms cpu, 4-&amp;gt;4-&amp;gt;1 MB, 5 MB goal, 1 P
gc 4 @0.128s 2%: 0.032+2.6+0.003 ms clock, 0.032+0.82/0/0+0.003 ms cpu, 4-&amp;gt;4-&amp;gt;1 MB, 5 MB goal, 1 P
gc 5 @0.153s 2%: 0.046+5.1+0.002 ms clock, 0.046+0.81/0/0+0.002 ms cpu, 4-&amp;gt;5-&amp;gt;1 MB, 5 MB goal, 1 P
gc 6 @0.175s 3%: 0.030+11+0.002 ms clock, 0.030+1.4/0.16/0+0.002 ms cpu, 4-&amp;gt;5-&amp;gt;1 MB, 5 MB goal, 1 P
gc 7 @0.224s 2%: 0.027+2.4+0.003 ms clock, 0.027+0.63/0/0+0.003 ms cpu, 4-&amp;gt;5-&amp;gt;2 MB, 5 MB goal, 1 P
# command-line-arguments
gc 1 @0.004s 17%: 0.009+2.4+0.002 ms clock, 0.009+1.3/0/0+0.002 ms cpu, 4-&amp;gt;6-&amp;gt;5 MB, 5 MB goal, 1 P
gc 2 @0.036s 16%: 0.014+8.7+0.004 ms clock, 0.014+4.0/2.2/0+0.004 ms cpu, 9-&amp;gt;9-&amp;gt;8 MB, 11 MB goal, 1 P
mem.Alloc: 48128
mem.TotalAlloc: 48128
mem.HeapAlloc: 48128
mem.NumGC: 0
-----
gc 1 @0.007s 1%: 0.011+0.11+0.002 ms clock, 0.011+0.10/0/0+0.002 ms cpu, 95-&amp;gt;95-&amp;gt;0 MB, 96 MB goal, 1 P
gc 2 @0.054s 0%: 0.030+0.13+0.002 ms clock, 0.030+0.12/0/0+0.002 ms cpu, 95-&amp;gt;95-&amp;gt;0 MB, 96 MB goal, 1 P
gc 3 @0.106s 0%: 0.023+0.12+0.002 ms clock, 0.023+0.12/0/0+0.002 ms cpu, 95-&amp;gt;95-&amp;gt;0 MB, 96 MB goal, 1 P
gc 4 @0.141s 0%: 0.023+0.15+0.004 ms clock, 0.023+0.15/0/0+0.004 ms cpu, 95-&amp;gt;95-&amp;gt;0 MB, 96 MB goal, 1 P
gc 5 @0.185s 0%: 0.021+0.12+0.001 ms clock, 0.021+0.11/0/0+0.001 ms cpu, 95-&amp;gt;95-&amp;gt;0 MB, 96 MB goal, 1 P
gc 6 @0.221s 0%: 0.023+0.22+0.002 ms clock, 0.023+0.22/0/0+0.002 ms cpu, 95-&amp;gt;95-&amp;gt;0 MB, 96 MB goal, 1 P
gc 7 @0.269s 0%: 0.025+0.12+0.001 ms clock, 0.025+0.12/0/0+0.001 ms cpu, 95-&amp;gt;95-&amp;gt;0 MB, 96 MB goal, 1 P
gc 8 @0.311s 0%: 0.032+0.33+0.002 ms clock, 0.032+0.32/0/0+0.002 ms cpu, 95-&amp;gt;95-&amp;gt;0 MB, 96 MB goal, 1 P
gc 9 @0.350s 0%: 0.022+0.10+0.006 ms clock, 0.022+0.097/0/0+0.006 ms cpu, 95-&amp;gt;95-&amp;gt;0 MB, 96 MB goal, 1 P
gc 10 @0.390s 0%: 0.021+0.11+0.005 ms clock, 0.021+0.10/0/0+0.005 ms cpu, 95-&amp;gt;95-&amp;gt;0 MB, 96 MB goal, 1 P
mem.Alloc: 100045256
mem.TotalAlloc: 1000128368
mem.HeapAlloc: 100045256
mem.NumGC: 9
-----
&lt;/code>&lt;/pre>
&lt;p>در نگاه اول خروجی کد بالا کمی گند به نظر می رسد که سعی می کنیم در ذیل آنها را توضیح دهیم&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>خروجی&lt;/th>
&lt;th>توضیح&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>gc 1&lt;/td>
&lt;td>شماره پاکسازی که در هربار اجرای عملیات پاکسازی بصورت خودکار به آن اضافه می شود&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>@0.007s&lt;/td>
&lt;td>زمان اجرای پاکسازی بعد از شروع به کار برنامه&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0%&lt;/td>
&lt;td>درصد منابع پردازشی استفاده شده بعد از اجرای برنامه&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0.011+0.11+0.002 ms clock&lt;/td>
&lt;td>مقدار این متغیر متشکل از چند مقدار است که بصورت ذیل محاسبه می شود Tgc = Tseq + Tmark + Tsweep&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>95-&amp;gt;95-&amp;gt;0 MB&lt;/td>
&lt;td>این متغیر نیز چند مقداری است و مقادیر اول نشانگر عملکرد حافظه قبل از اجرای پاکسازی ، دوم بعد از اجرای پاکسازی و سوم مقدار پشته است&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>96 MB goal&lt;/td>
&lt;td>اندازه پشته برنامه مورد نظر&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1 P&lt;/td>
&lt;td>تعداد پردازنده مورد استفاده شده&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>Tseq&lt;/strong>: زمان توقف گوروتین های کاربر
&lt;strong>Tmark&lt;/strong>: زمان مورد استفاده جهت فاز mark
&lt;strong>Tsweep&lt;/strong>: زمان مورد استفاده جهت فاز sweep&lt;/p></description></item><item><author/><title>4.22 کتابخانه Plugin</title><link>https://book.gofarsi.ir/chapter-4/go-plugin/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/go-plugin/</guid><description>&lt;p>در میان ویژگی‌های قابل توجه Go نسخه 1.8، سیستم جدید پلاگین‌های Go قرار دارد. این ویژگی به برنامه‌نویسان اجازه می‌دهد تا برنامه‌های ماژولار بدون ارتباط زنجیره‌ای با هم، با استفاده از بسته‌هایی که به صورت کتابخانه‌های اشیا شیء‌گرا کامپایل شده‌اند، ساخته شوند و به‌صورت پویا در زمان اجرا بارگذاری و به‌صورت پیوسته به آن‌ها پیوند داده شوند.&lt;/p>
&lt;p>این تغییر بزرگی است! چرا که توسعه‌دهندگان نرم‌افزارهای سیستمی بزرگ در Go، بدون شک، نیاز به ماژولارسازی کد خود دارند. ما برای دستیابی به ماژولارسازی کد، از طراحی‌های متعدد out-of-process، مانند &lt;a href="https://kubernetes.io/docs/admin/network-plugins/">OS exec calls&lt;/a>، &lt;a href="https://docs.docker.com/engine/extend/plugin_api/">سوکت&lt;/a> و &lt;a href="https://github.com/hashicorp/go-plugin">RPC/gRPC&lt;/a> (و غیره) استفاده کرده‌ایم. این روش‌ها ممکن است به خوبی کار کنند، اما در بسیاری از زمینه‌ها به‌عنوان پایانه‌ای برای پردازش با قبل نبود یک سیستم پلاگین‌ای ناتیو در Go بکار رفته‌اند.&lt;/p>
&lt;p>در این بخش از کتاب، من بررسی می‌کنم که ایجاد نرم‌افزار ماژولار با استفاده از سیستم پلاگین‌های Go (plugin) چه تبعاتی دارد.&lt;/p>
&lt;blockquote class="book-hint warning">
از نسخه 1.8، plugin فقط در لینوکس کار می‌کند. با توجه به سطح علاقمندی به این ویژگی، این احتمالا در نسخه‌های آینده تغییر خواهد کرد.
&lt;/blockquote>
&lt;h2 id="4221-طراحی-ماژولار-با-go">
4.22.1 طراحی ماژولار با Go
&lt;a class="anchor" href="#4221-%d8%b7%d8%b1%d8%a7%d8%ad%db%8c-%d9%85%d8%a7%da%98%d9%88%d9%84%d8%a7%d8%b1-%d8%a8%d8%a7-go">#&lt;/a>
&lt;/h2>
&lt;p>ایجاد برنامه‌های ماژولار با پلاگین﻿‌های Go، نیاز به همان شیوه کار قابل اعتماد نرم‌افزاری دارد که به بسته‌های Go رایج اعمال می‌شود. با این‌حال، پلاگین‌ها نگرانی‌های طراحی جدید را با توجه به اتصالشان به دیگر اجزای برنامه، بیشتر کرده‌اند.&lt;/p>
&lt;ol>
&lt;li>در هنگام ساخت سیستم نرم‌افزاری قابل پلاگین‌گذاری، بسیار مهم است که قابلیت‌های واضحی برای اجزای سیستم تعریف شوند. سیستم باید رابط‌های ساده و شفافی برای یکپارچه‌سازی پلاگین فراهم کند. از سوی دیگر، توسعه‌دهندگان پلاگین باید به عنوان یک جعبه سیاه برای سیستم در نظر گرفته شوند و علاوه بر قراردادهای ارائه‌شده، هیچ فرضیاتی را انجام ندهند.&lt;/li>
&lt;li>پلاگین باید به عنوان یک اجزای مستقل در نظر گرفته شود که از دیگر اجزا جدا شده است. این باعث می‌شود که پلاگین‌ها بتوانند دوره‌ی life cycle توسعه و استقرار خود را بدون وابستگی به مصرف‌کنندگانشان دنبال کنند.&lt;/li>
&lt;li>کد پلاگین باید طراحی شود تا تمرکز خود را فقط بر روی یکی از مسائل عملکردی داشته باشد و نه بیشتر از آن.&lt;/li>
&lt;li>از آنجایی که پلاگین‌ها اجزای مستقل‌ای هستند که در زمان اجرا بارگیری می‌شوند، مهم این است که از مستندات خوبی برخوردار باشند. به عنوان مثال، نام توابع و متغیرهای پیاده سازی باید به طور واضح مشخص شوند تا خطاهای جستجوی symbol ها را جلوگیری کنند.&lt;/li>
&lt;li>پلاگین‌های Go می‌توانند تابع‌های بسته و متغیرهایی از هر نوع را به‌صورت خروجی دهند. می‌توانید پلاگین‌تان را طراحی کنید تا قابلیت‌های خود را به‌صورت یک مجموعه‌ی تابع‌های آزاد گروه‌بندی کند. سردرگمی، این است که شما باید به‌صورت جداگانه هر symbol تابع را جستجو و به آن متصل شوید. راهکار بهتر این است که از انواع interface استفاده کنید. ایجاد یک interface برای صادرکردن قابلیت‌ها، یک سطح تعاملی یکنواخت و مختصر با نشانگرهای عملیاتی واضح فراهم می‌کند. جستجو و متصل کردن به‌نمادی که به یک رابط حل می‌شود، دسترسی به کل مجموعه شیوه های تابعی برای قابلیت‌ها را فراهم می‌کند، نه فقط یکی از آن‌ها.&lt;/li>
&lt;/ol>
&lt;h2 id="4222-کتابخانه-plugin">
4.22.2 کتابخانه plugin
&lt;a class="anchor" href="#4222-%da%a9%d8%aa%d8%a7%d8%a8%d8%ae%d8%a7%d9%86%d9%87-plugin">#&lt;/a>
&lt;/h2>
&lt;p>کتابخانه plugin، یک کتابخانه خیلی ساده و آسان است و فقط یک تابع Open و یک متد Lookup دارد که به شما برای بازکردن فایل so. و استفاده ازinterface های پیاده سازی شده کمک می کند.&lt;/p>
&lt;pre>&lt;code class="language-go">type Plugin
func Open(path string) (*Plugin, error)
func (p *Plugin) Lookup(symName string) (Symbol, error)
type Symbol
&lt;/code>&lt;/pre>
&lt;p>کتابخانه plugin، یک پکیج اصلی Go با توابع و متغیرهای صادرشده است که با استفاده از دستور زیر برای کامپایل ساخته شده است:&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go build -buildmode=plugin
&lt;/code>&lt;/pre>
&lt;p>وقتی که یک plugin برای اولین بار باز می‌شود، تابع init تمام بسته‌هایی که هنوز قسمت برنامه نیستند فراخوانی می‌شوند. تابع اصلی اجرا نمی‌شود. یک plugin تنها یکبار مقداردهی اولیه می‌شود و نمی‌تواند بسته شود.&lt;/p>
&lt;h2 id="4223-پیاده-سازی-قدم-به-قدم-یک-برنامه-ماژولار-با-plugin">
4.22.3 پیاده سازی قدم به قدم یک برنامه ماژولار با plugin
&lt;a class="anchor" href="#4223-%d9%be%db%8c%d8%a7%d8%af%d9%87-%d8%b3%d8%a7%d8%b2%db%8c-%d9%82%d8%af%d9%85-%d8%a8%d9%87-%d9%82%d8%af%d9%85-%db%8c%da%a9-%d8%a8%d8%b1%d9%86%d8%a7%d9%85%d9%87-%d9%85%d8%a7%da%98%d9%88%d9%84%d8%a7%d8%b1-%d8%a8%d8%a7-plugin">#&lt;/a>
&lt;/h2>
&lt;p>فرض کنید قصد یک پروژه بنویسیم که hello world را به زبان های مختلف در خروجی terminal چاپ کنیم.&lt;/p>
&lt;h3 id="42231-نمونه-ساختار-پروژه">
4.22.3.1 نمونه ساختار پروژه
&lt;a class="anchor" href="#42231-%d9%86%d9%85%d9%88%d9%86%d9%87-%d8%b3%d8%a7%d8%ae%d8%aa%d8%a7%d8%b1-%d9%be%d8%b1%d9%88%da%98%d9%87">#&lt;/a>
&lt;/h3>
&lt;p>در ابتدا نیاز داریم یک پروژه با ساختار زیر پیاده سازی کنیم:&lt;/p>
&lt;pre>&lt;code class="language-shell">├── [ 22] go.mod
├── [ 779] main.go
└── [ 224] plugin
├── [ 240] en
│   └── [ 152] en.go
└── [ 240] fa
├── [ 155] fa.go
&lt;/code>&lt;/pre>
&lt;h3 id="42232-نوشتن-پلاگین">
4.22.3.2 نوشتن پلاگین
&lt;a class="anchor" href="#42232-%d9%86%d9%88%d8%b4%d8%aa%d9%86-%d9%be%d9%84%d8%a7%da%af%db%8c%d9%86">#&lt;/a>
&lt;/h3>
&lt;p>در ابتدا یک دایرکتوری plugin ایجاد کنید سپس براساس زبان مورد نظر خود یک یا چند sub directory ایجاد کنید.&lt;/p>
&lt;p>حال برای زبان فارسی و انگلیسی از کد زیر استفاده کنید:&lt;/p>
&lt;p>&lt;strong>English&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import &amp;quot;fmt&amp;quot;
type hello string
func (h hello) Hello() {
fmt.Println(&amp;quot;Hello 🌎&amp;quot;)
}
// Hello exported as symbol named
var Hello hello
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>Persian&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import &amp;quot;fmt&amp;quot;
type hello string
func (h hello) Hello() {
fmt.Println(&amp;quot;سلام 🌎&amp;quot;)
}
// Hello exported as symbol named
var Hello hello
&lt;/code>&lt;/pre>
&lt;p>در کد فوق ما به ازای هر زبان یک فایل go ایجاد کردیم که با پکیج main شروع می شود و داخلش یک type مشخص قرار دادیم و متد Hello را پیاده سازی کردیم.
سپس یک متغییر با نام Hello تعریف کردیم تا به عنوان symbol برای پلاگین در دسترس باشد.&lt;/p>
&lt;blockquote class="book-hint warning">
&lt;p>اگر package شما نام دیگری غیر از main باشد با خطا مواجه خواهید شد به دلیل build شدن ماژول هستش.&lt;/p>
&lt;pre>&lt;code class="language-shell">-buildmode=plugin requires exactly one main package
&lt;/code>&lt;/pre>
&lt;/blockquote>
&lt;h3 id="42233-بیلد-پلاگین-ها">
4.22.3.3 بیلد پلاگین ها
&lt;a class="anchor" href="#42233-%d8%a8%db%8c%d9%84%d8%af-%d9%be%d9%84%d8%a7%da%af%db%8c%d9%86-%d9%87%d8%a7">#&lt;/a>
&lt;/h3>
&lt;p>برای بیلد گرفتن پلاگین ها باید از دستورات زیر استفاده کنید:&lt;/p>
&lt;pre>&lt;code class="language-shell">go build -buildmode=plugin -o plugin/en/en.so plugin/en/en.go
go build -buildmode=plugin -o plugin/fa/fa.so plugin/fa/fa.go
&lt;/code>&lt;/pre>
&lt;p>زمانیکه بیلد میگیرید فایل پلاگین ها در محل &lt;code>plugin/en&lt;/code> یا &lt;code>plugin/fa&lt;/code> با پسوند &lt;code>so.&lt;/code> قرار میگیرد.&lt;/p>
&lt;p>حال با استفاده از ابزار file در لینوکس می توانید اطلاعات ماژول بیلد شده را ببینید که به عنوان dynamic shared object شناخته می شود:&lt;/p>
&lt;pre>&lt;code class="language-shell">$ file plugin/en/en.so
plugin/en/en.so: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, BuildID[sha1]=d23f35974563f658267b158466cbb551a97fb049, with debug_info, not stripped
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>ساختار پروژه پس از بیلد پلاگین ها&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-shell">├── [ 22] go.mod
├── [ 779] main.go
└── [ 224] plugin
├── [ 240] en
│   ├── [ 152] en.go
│   └── [ 3.5M] en.so
└── [ 240] fa
├── [ 155] fa.go
└── [ 3.5M] fa.so
&lt;/code>&lt;/pre>
&lt;h3 id="42234-استفاده-از-پلاگین-ها">
4.22.3.4 استفاده از پلاگین ها
&lt;a class="anchor" href="#42234-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-%d9%be%d9%84%d8%a7%da%af%db%8c%d9%86-%d9%87%d8%a7">#&lt;/a>
&lt;/h3>
&lt;p>داخل روت پروژه یک فایل main.go ایجاد کنید و کد زیر را قرار دهید.&lt;/p>
&lt;p>توجه کنید نیاز دارید فایل های پلاگین را در هر محلی هست load کنید.&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;fmt&amp;quot;
&amp;quot;os&amp;quot;
&amp;quot;plugin&amp;quot;
)
type Greeter interface {
Hello()
}
func main() {
// determine plugin to load
lang := &amp;quot;english&amp;quot;
if len(os.Args) == 2 {
lang = os.Args[1]
}
var mod string
switch lang {
case &amp;quot;english&amp;quot;:
mod = &amp;quot;./plugin/en/en.so&amp;quot;
case &amp;quot;persian&amp;quot;:
mod = &amp;quot;./plugin/fa/fa.so&amp;quot;
default:
fmt.Println(&amp;quot;don't support your language&amp;quot;)
os.Exit(1)
}
// load module
plug, err := plugin.Open(mod)
if err != nil {
fmt.Println(err)
os.Exit(1)
}
// lookup for symbol
symbol, err := plug.Lookup(&amp;quot;Hello&amp;quot;)
if err != nil {
fmt.Println(err)
os.Exit(1)
}
// assert symbol with interface
p, ok := symbol.(Greeter)
if !ok {
fmt.Println(&amp;quot;unexpected type from module symbol&amp;quot;)
os.Exit(1)
}
// call interface method
p.Hello()
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-shell">$ go run main.go english
Hello 🌎
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>در ابتدا یک interface به همراه متد مشابه داخل پلاگین قرار دادیم.&lt;/li>
&lt;li>سپس داخل main یک زبان پیش فرض را داخل متغیر lang تعیین کردیم سپس از طریق os.Args زبان از طریق os.Stdin گرفتیم و داخل lang قرار دادیم پس از آن با استفاده از switch چک کردیم براساس زبان یک پلاگین یا ماژول مشخص را داخل متغیر mod مسیر دهی کنیم.&lt;/li>
&lt;li>سپس تابع Open کتابخانه plugin را فراخوانی کردیم و مسیر پلاگین را قرار دادیم.&lt;/li>
&lt;li>حال پس از باز شدن پلاگین متد Lookup را برای پیدا کردن symbol فراخوانی کردیم که ما نام symbol را Hello گذاشتیم.&lt;/li>
&lt;li>پس از اینکه symbol بدون خطا load شد ما symbol را با اینترفیس Greeter گرفتیم Assert کردیم تا بتوانیم از متدهای پیاده سازی شده استفاده کنیم.&lt;/li>
&lt;/ul>
&lt;h2 id="4224-پروژه-هایی-که-از-plugin-استفاده-کرده-اند">
4.22.4 پروژه هایی که از plugin استفاده کرده اند
&lt;a class="anchor" href="#4224-%d9%be%d8%b1%d9%88%da%98%d9%87-%d9%87%d8%a7%db%8c%db%8c-%da%a9%d9%87-%d8%a7%d8%b2-plugin-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%da%a9%d8%b1%d8%af%d9%87-%d8%a7%d9%86%d8%af">#&lt;/a>
&lt;/h2>
&lt;p>در زیر ما لیستی از پروژه های فعالی که از پلاگین استفاده کرده اند را قرار دادیم تا بتوانید برای پیاده سازی پروژه های ماژولار ایده بگیرید:&lt;/p>
&lt;ol>
&lt;li>&lt;a href="https://github.com/hashicorp/go-plugin">https://github.com/hashicorp/go-plugin&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/luraproject/lura">https://github.com/luraproject/lura&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/smartcontractkit/chainlink-starknet">https://github.com/smartcontractkit/chainlink-starknet&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/ava-labs/blobvm">https://github.com/ava-labs/blobvm&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/easysoft/zentaoatf">https://github.com/easysoft/zentaoatf&lt;/a>&lt;/li>
&lt;/ol>
&lt;h2 id="4225-کلام-آخر">
4.22.5 کلام آخر
&lt;a class="anchor" href="#4225-%da%a9%d9%84%d8%a7%d9%85-%d8%a2%d8%ae%d8%b1">#&lt;/a>
&lt;/h2>
&lt;p>ماژولارنویسی یکی از مهم ترین عناوین توسعه و طراحی نرم افزار بوده که شما با اینکار می توانید پلاگین های reusable بنویسید و در هر پروژه ای بسته به نیازتان استفاده کنید.
شرکت های بزرگی نظیر hashicorp برای اکثر پروژهایش نظیر terraform یا consul از این قابلیت استفاده کرده است.&lt;/p></description></item><item><author/><title>4.23 شی گرایی در زبان گو</title><link>https://book.gofarsi.ir/chapter-4/oop/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/oop/</guid><description>&lt;p>گو یک زبان statically-typed است و بطور کلی امکانات شی گرایی را به شیوه قدیم و مرسوم پشتیبانی نمی کند. اما در عوض یک شیوه قرار دادی وجود دارد که به شما کمک می کند برخی از مفاهیم شی گرایی را با کمک اینترفیس, composition, متد و type embedding پیاده سازی کنید.&lt;/p>
&lt;p>&lt;strong>این مفاهیم شامل :&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="go-encapsulation">کپسوله سازی&lt;/a>&lt;/li>
&lt;li>&lt;a href="go-inheritance">ارث بری&lt;/a>&lt;/li>
&lt;li>&lt;a href="go-polymorphism">پلی مورفیسم&lt;/a>&lt;/li>
&lt;li>&lt;a href="go-overriding">overriding&lt;/a>&lt;/li>
&lt;li>&lt;a href="go-abstraction">abstraction&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="تعریف-شی-گرایی-به-زبان-ساده">
تعریف شی گرایی به زبان ساده
&lt;a class="anchor" href="#%d8%aa%d8%b9%d8%b1%db%8c%d9%81-%d8%b4%db%8c-%da%af%d8%b1%d8%a7%db%8c%db%8c-%d8%a8%d9%87-%d8%b2%d8%a8%d8%a7%d9%86-%d8%b3%d8%a7%d8%af%d9%87">#&lt;/a>
&lt;/h2>
&lt;p>بیاید با چند تا مثال ساده، سوا از اینکه با چه زبانی کار می کنیم، با مفهوم شی گرایی آشنا شویم.&lt;/p>
&lt;center>&lt;a href="#">
&lt;img src="../../assets/img/content/chapter4/oop/oop.jpeg" alt="pprof">
&lt;/a>&lt;/center>
&lt;p>قراره با یه سری مثال از دنیای واقعی شی گرایی رو براتون توضیح بدم.
ما موجودی داریم به اسم گربه (class) که این موجود ویژگی (Attribute) و رفتار (Method) هایی رو داره. برای مثال گربه ویژگی هایی مثل رنگ چشم، وزن و &amp;hellip; داره. همچنین رفتار هایی رو داره مثل راه رفتن،‌ میو میو کردن.&lt;/p>
&lt;p>خب تا الان گربه رو به صورت انتزاعی گفتیم که فلان ویژگی ها و رفتار هارو داره.
به یک نمونه واقعی از گربه object و یا instance میگیم.&lt;/p>
&lt;p>گربه خودش از یک کلاس والد ارث بری (Inheritance) کرده. مثلا کلاسی داریم به اسم حیوان. کلاس حیوان یه سری ویژگی ها و رفتار هایی رو داره. حالا که گربه از کلاس حیوان ارث بری کرده رفتار ها و ویژگی های والدش رو ارث میگیره.&lt;/p>
&lt;p>خب اینجا یه سوالی پیش میاد! ما کلی موجود داریم که کلاس والدشون حیوان هستش ولی آیا همشون شبیه به همدیگه رفتار می کنن؟ برای مثال همشون یه شکلی راه میرن و صدا در میارن؟
جواب قطعا خیر هستش. اینجاس که چند ریختگی (Polymorphism) اتفاق میوفته. درسته که هم سگ و هم گربه صدا دارن ولی یکیش میو میکنه یکیش هاپ هاپ&lt;/p>
&lt;center>&lt;a href="#">
&lt;img src="../../assets/img/content/chapter4/oop/encapsulation.png" alt="polymorphism">
&lt;/a>&lt;/center>
&lt;p>بعضی وقتا نیازه که ما یک سری ویژگی ها و متد هایی رو تعریف کنیم اما از بیرون قابل دسترس نباشه.
مثلا attribute به اسم score داریم که امتیاز رو نگه میداریم. بقیه قسمت های کد نباید بصورت مستقیم بتونن مقدار score رو تغییر بدن پس میایم socre رو مخفی می کنیم تا از بیرون دسترسی نداشته باشن و برای تغییر دادن socre یک متد به اسم increase_score می نویسیم که هربار صدا زده بشه به امتیاز کاربر اضافه بشه.&lt;/p>
&lt;p>مثال دوم:
فرض کن یه پکیجی رو داری مینویسی که قراره یه سری کارهایی رو انجام بده.
نمیخوای برنامه نویسی که قراره از پکیجت استفاده کنه یه سری رفتار و ویژگی هارو ببینه.
مثلا متد get_response رو داری که خود این متد چند تا متد دیگه رو صدا میزنه تا بتونه پاسخ مناسب رو نشون بده.&lt;/p>
&lt;p>این متد هایی که توی get_response استفاده کردیم فقط برای استفاده داخلی نوشته شدن و نمیخوایم برنامه نویس بهشون دسترسی داشته باشه. پس میایم مخفی میکنیمشون و از encapsulation استفاده می کنیم&lt;/p>
&lt;center>&lt;a href="#">
&lt;img src="../../assets/img/content/chapter4/oop/abstraction.jpeg" alt="abstraction">
&lt;/a>&lt;/center>
&lt;p>هر ساله ماشین ها از نظر فنی کلی تغییر می کنن اما شخصی که با یک ماشین چند سال پیش رانندگی کرده باشه با ماشین الانم میتونه رانندگی کنه. اینجاست که abstraction باعث میشه این اتفاق بیوفته.
اومدن بصورت انتزاعی تعریف کردن که ماشین دنده داره، پدال گاز داره و فرمون داره و هر کدومشون به چه صورت عمل می کنن.&lt;/p>
&lt;p>به همین دلیل با اینکه از نظر فنی و داخلی کلی تغییر میکنن اما طرز استفاده ازش تغییر خاصی نمیکنه.&lt;/p>
&lt;p>بیاید یه مثال دیگه بزنیم:
فرض کنید شما یک وب سایت طراحی کردید. یه سری دکمه ها و قابلیت ها قرار دادید تا کاربر بتونه ازش استفاده کنه.
با اینکه سبد خرید برای کاربر همونه اما پشت صحنه کلی تغییر دادید و بروزرسانیش کردید.&lt;/p>
&lt;p>همچنین شما هم برای طراحی وب سایت از یک سری ابزار ها استفاده کردید که این ابزار ها همش در حال بروز رسانی هستند اما نحوه استفاده شما تغییری نمیکنه.&lt;/p>
&lt;p>به این مفهوم Abstraction میگن.&lt;/p>
&lt;p>در ادامه این بخش بررسی می کنیم که در زبان گولنگ آیا مفاهیم شی گرایی رو داریم یا نه. اگه داریم به چه صورت قابل پیاده سازی هستند.&lt;/p></description></item><item><author/><title>4.24 آموزش tracing</title><link>https://book.gofarsi.ir/chapter-4/tracing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/tracing/</guid><description>&lt;p>در این فصل، این مورد را یاد خواهیم گرفت که چگونه یک برنامه در حال اجرا را ردیابی کنیم و آن را با ابزار ردیابی مشاهده کنیم. در این حالت با استفاده از کتابخانه استاندارد، یک ردیابی ایجاد خواهیم کرد.&lt;/p>
&lt;h2 id="4241--مثال-از-tracing">
4.24.1 مثال از tracing
&lt;a class="anchor" href="#4241--%d9%85%d8%ab%d8%a7%d9%84-%d8%a7%d8%b2-tracing">#&lt;/a>
&lt;/h2>
&lt;p>ما برنامه ای داریم که تعداد دفعات یافتن یک topic را در collection ای ازRSS news feed document را می شمارد. این برنامه از یک threaded algorithm به نام freq استفاده می کند که روی collection تکرار می شود و هر سند را یک به یک پردازش می کند و تعداد دفعاتی که topic پیدا شده است را برمی‌گرداند.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">func freq(topic string, docs []string) int {
var found int
for _, doc := range docs {
file := fmt.Sprintf("%s.xml", doc[:8])
f, err := os.OpenFile(file, os.O_RDONLY, 0)
if err != nil {
log.Printf("Opening Document [%s] : ERROR : %v", doc, err)
return 0
}
data, err := io.ReadAll(f)
f.Close()
if err != nil {
log.Printf("Reading Document [%s] : ERROR : %v", doc, err)
return 0
}
var d document
if err := xml.Unmarshal(data, &amp;d); err != nil {
log.Printf("Decoding Document [%s] : ERROR : %v", doc, err)
return 0
}
for _, item := range d.Channel.Items {
if strings.Contains(item.Title, topic) {
found++
continue
}
if strings.Contains(item.Description, topic) {
found++
}
}
}
return found
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>تابع Freq کار را به چهار مرحله تقسیم می کند: باز کردن، خواندن، باز کردن و جستجو. برای تست تابع freq، تابع main مجموعه ای از فایل های 4k را می سازد و freq را فراخوانی می کند.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"encoding/xml"
"fmt"
"log"
)
type (
item struct {
XMLName xml.Name `xml:"item"`
Title string `xml:"title"`
Description string `xml:"description"`
}
channel struct {
XMLName xml.Name `xml:"channel"`
Items []item `xml:"item"`
}
document struct {
XMLName xml.Name `xml:"rss"`
Channel channel `xml:"channel"`
}
)
func main() {
docs := make([]string, 4000)
for i := range docs {
docs[i] = fmt.Sprintf("newsfeed-%.4d.xml", i)
}
topic := "president"
n := freq(topic, docs)
log.Printf("Searching %d files, found %s %d times.", len(docs), topic, n)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>کدی که تکه‌ای از اسناد 4k را می‌سازد، مجموعه‌ای از فایل‌های منحصربه‌فرد را براساس یک فایل واقعی که ما newfeed.xml نامیده‌ایم ایجاد می‌کند.&lt;/p>
&lt;pre>&lt;code class="language-xml">newsfeed.xml
&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;?xml-stylesheet title=&amp;quot;XSL_formatting&amp;quot; type=&amp;quot;text/xsl&amp;quot;?&amp;gt;
&amp;lt;rss&amp;gt;
&amp;lt;channel&amp;gt;
&amp;lt;title&amp;gt;&amp;lt;![CDATA[BBC News - US &amp;amp; Canada]]&amp;gt;&amp;lt;/title&amp;gt;
&amp;lt;description&amp;gt;&amp;lt;![CDATA[BBC News - US &amp;amp; Canada]]&amp;gt;&amp;lt;/description&amp;gt;
&amp;lt;item&amp;gt;
&amp;lt;title&amp;gt;&amp;lt;![CDATA[President China visit: US leader strik]]&amp;gt;&amp;lt;/title&amp;gt;
&amp;lt;description&amp;gt;&amp;lt;![CDATA[The US president praises]]&amp;gt;&amp;lt;/description&amp;gt;
&amp;lt;/item&amp;gt;
&amp;lt;/channel&amp;gt;
&amp;lt;/rss&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>این یک نمونه بسیار کوچک از فایل newsfeed.xml است. به جای اینکه فایل های واقعی 4k را نگه داریم، فقط یک فایل را نگه می داریم و تلاش می کنیم که 4k یکی از آنها را نشان دهد. الگوریتم freq کاراکترهای اضافی را از نام فایل، قبل از باز کردن فایل حذف می کند. خوب است که یک ایده اولیه از مدت زمان لازم برای پردازش این 4000 فایل با نسخه تک رشته ای Freq داشته باشید. پس می توانیم این کار را با استفاده از time command در ارتباط با اجرای برنامه انجام دهیم.&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go build
$ time ./trace
2021/05/12 09:30:52 Searching 4000 files, found president 28000 times.
./trace 2.63s user 0.18s system 101% cpu 2.763 total
&lt;/code>&lt;/pre>
&lt;p>می بینیم که زمان اجرای برنامه حدود 2.7 ثانیه طول کشید تا فایل های 4k را پردازش کند. اگر قرار بود فقط فایل‌های 4k یا شاید حتی چند هزار فایل دیگر را پردازش کنیم، این برنامه تکمیل شده و تمام بود. با این حال، در نظر داریم که توانایی پردازش یک میلیون فایل را داشته باشیم و تجزیه و تحلیل آن ساعت‌ها طول نکشد. پس باید راهی برای افزایش سرعت این برنامه پیدا کنیم. در واقع می‌توانیم از یک memory profile استفاده کنیم، هر چند که این برنامه از memory گذرا زیادی استفاده می‌کند و کار زیادی نمی‌توانیم در مورد آن انجام دهیم. پس می‌توانیم از یک cpu profile استفاده کنیم. این روش به در واقع بیان می‌کند که به لطف فراخوانی با os.OpenFile، بیشتر زمان را در فراخوانی و رخدادهای سیستمی مصرف می‌کنیم. مشکل استفاده از profiler در اینجا این است که یک profiler فقط می تواند بگوید که چه اتفاقی می افتد ولی باید بدانیم چه چیزی اتفاقی می افتد و چه چیزی اتفاق نمی افتد تا راهی برای سرعت بخشیدن به این برنامه پیدا کنیم. وقتی باید ببینیم چه اتفاقی نیافتاده، ابزار ردیابی گزینه خوبی است.&lt;/p>
&lt;h2 id="4242--generating-traces">
4.24.2 Generating Traces
&lt;a class="anchor" href="#4242--generating-traces">#&lt;/a>
&lt;/h2>
&lt;p>از آنجایی که این برنامه در عرض چند ثانیه شروع و متوقف می شود، می توانیم از کتابخانه استاندارد برای ایجاد ردی از این برنامه استفاده کنم. به طور کلی، ایجاد ردیابی برای بیش از چند ثانیه از زمان اجرا می‌تواند برای بررسی سخت باشد، زیرا یک ردیابی مقدار زیادی داده تولید می‌کند. ما می خواهیم بر روی ردپاهای کوچک و هدفمند تمرکز کنیم.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"fmt"
"log"
"os"
"runtime/trace" //&lt;-- ADDED
)
func main() {
trace.Start(os.Stdout) // &lt;-- ADDED
defer trace.Stop() // &lt;-- ADDED
docs := make([]string, 4000)
for i := range docs {
docs[i] = fmt.Sprintf("newsfeed-%.4d.xml", i)
}
topic := "president"
n := freq(topic, docs)
log.Printf("Search %d files, found %s %d times.", len(docs), topic, n)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>پس از افزودن بسته trace به importها، می توانیم از توابع trace.Start و Stop استفاده کنیم. نوشتن ردیابی در stdout گرفتن و تغییر مسیر داده های ردیابی به یک فایل را ساده می کند. حالا می توانم دوباره برنامه را اجرا کنیم.&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go build
$ time ./trace &amp;gt; t.out
2021/05/12 11:57:06 Search 4000 files, found president 28000 times.
./trace &amp;gt; t.out 2.71s user 0.19s system 102% cpu 2.827 total
$ time ./trace &amp;gt; t.out
2021/05/12 11:57:11 Search 4000 files, found president 28000 times.
./trace &amp;gt; t.out 2.73s user 0.18s system 108% cpu 2.683 total
$ ls -l
total 9136
-rw-r--r-- 1 bill staff 2108 Jan 4 08:16 README.md
-rw-r--r-- 1 bill staff 25544 Jan 4 08:16 newsfeed.xml
-rw-r--r-- 1 bill staff 1501618 May 12 11:57 t.out
-rwxr-xr-x 1 bill staff 2470208 May 12 11:57 trace
-rw-r--r-- 1 bill staff 8135 May 12 11:56 trace.go
&lt;/code>&lt;/pre>
&lt;p>ما همیشه برنامه را دو بار اجرا می کنیم تا مطمئن شوم دستگاه گرم شده است. اجرای دوم معمولا بهتر از اولین اجرا می شود و من می توانم 144 میلی ثانیه تفاوت بین این دو اجرا ببینم. همچنین می‌توانم ببینم که فایل t.out در فهرست، 1.5 مگ داده در طول 2.6 ثانیه زمان اجرا گرفته است.&lt;/p>
&lt;h2 id="4243--generating-traces">
4.24.3 Generating Traces
&lt;a class="anchor" href="#4243--generating-traces">#&lt;/a>
&lt;/h2>
&lt;p>برای بررسی ردیابی، باید از ابزار ردیابی استفاده کنم.&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go tool trace t.out
2021/05/12 12:00:19 Parsing trace...
2021/05/12 12:00:19 Splitting trace...
2021/05/12 12:00:19 Opening browser. Trace viewer is listening on
http://127.0.0.1:64321
&lt;/code>&lt;/pre>
&lt;p>پس از تجزیه و تقسیم فایل، یک برگه مرورگر با مجموعه ای از linkها باز می شود.&lt;/p>
&lt;p>&lt;img src="../../assets/img/content/chapter4/tracing/1.png" alt="array" />&lt;/p>
&lt;p>حالا می‌خواهیم اولین link را انتخاب کنیم که یک رابط کاربری مبتنی بر Chrome را باز می‌کند که می‌تواند داده‌های ردیابی را ارائه دهد. این ابزار فقط در کروم کار می کند.&lt;/p>
&lt;p>&lt;img src="../../assets/img/content/chapter4/tracing/2.png" alt="array" />&lt;/p>
&lt;p>تمام اطلاعاتی که ارائه می شود تا میکروثانیه زمان وقوع آن ثبت می شود. در سمت چپ، می توانیم دسته های مختلف اطلاعات نموداری را ببینم.&lt;/p>
&lt;p>در هر زمان معین در ردیابی موارد زیر را داریم:&lt;/p>
&lt;p>● Goroutines: The number of Goroutines.&lt;/p>
&lt;p>● Heap: The amount of memory in-use on the heap.&lt;/p>
&lt;p>● Threads: The number of operating system threads.&lt;/p>
&lt;p>● GC: The start/end of each GC with details.&lt;/p>
&lt;p>● Syscalls: The start/end of any system call with details.&lt;/p>
&lt;p>● Procs: The activity on each logical processor.&lt;/p>
&lt;p>اولین کاری که باید انجام دهیم اندازه گیری مدت زمان اجرای برنامه بر اساس داده های ردیابی است. می‌توانیم این کار را با ابزار زمان بندی، که آخرین ابزار در toolbar است، انجام دهیم.&lt;/p>
&lt;p>&lt;img src="../../assets/img/content/chapter4/tracing/3.png" alt="array" />&lt;/p>
&lt;p>اگرtimeline کل ردیابی را انتخاب کنیم، برابر 2.67 ثانیه خواهد بود که تقریباً به آنچه time command ارائه شده است نزدیک است. نکته بعدی که می‌خواهم بدانم این است که اندازه heap چقدر ثابت مانده است یا چقدر بزرگ‌تر شده است. برای این کار باید نمای نمودار را گسترش می دهیم و سپس از ابزار انتخاب (اولین ابزار در نوار ابزار) برای انتخاب قسمت بالای نمودار heap استفاده می کنبم.&lt;/p>
&lt;p>&lt;img src="../../assets/img/content/chapter4/tracing/3_1.png" alt="array" />&lt;/p>
&lt;p>دو رنگ (یا سایه) وجود دارد که در نمودار heap نشان داده شده است. نارنجی (سایه تیره تر) میزان حافظه در حال استفاده روی heap را در هر میکروثانیه نشان می دهد. سبز (سایه روشن‌تر) نشان‌دهنده زمانی است که GC بعدی بر اساس زمانی که آن مقدار حافظه دوباره در heap مورد استفاده قرار می‌گیرد، راه‌اندازی می‌شود.&lt;/p>
&lt;p>&lt;img src="../../assets/img/content/chapter4/tracing/4.png" alt="array" />&lt;/p>
&lt;p>به همین دلیل است که وقتی ناحیه نارنجی به بالای منطقه سبز می رسد، یک خط در قسمت GC وجود دارد. هر خط نشان دهنده یک GC است که اتفاق افتاده است.&lt;/p>
&lt;p>از آنجایی که ناحیه سبز در یک خط مستقیم ثابت برای کل اجرای برنامه است، می توانم هر نقطه نارنجی را برای دیدن حداکثر اندازه heap انتخاب کنیم. در این صورت اگر بخواهم در مورد این عدد وضوح بیشتری داشته باشم، می توانیم از GODEBUG استفاده کنیم و دوباره برنامه را اجرا کنیم.&lt;/p>
&lt;pre>&lt;code class="language-go">$ time GODEBUG=gctrace=1 ./trace &amp;gt; t.out
gc 1 @0.016s 0%: 0.020+0.29+0.024 ms clock, 0.32+0.18/0.12/0.12+0.39 ms cpu,
4-&amp;gt;4-&amp;gt;0 MB, 5 MB goal, 16 P
gc 2 @0.029s 0%: 0.030+0.23+0.002 ms clock, 0.49+0.15/0.17/0.001+0.037 ms
cpu, 4-&amp;gt;4-&amp;gt;0 MB, 5 MB goal, 16 P
gc 3 @0.040s 0%: 0.033+0.26+0.019 ms clock, 0.52+0.15/0.15/0.059+0.31 ms
cpu, 4-&amp;gt;4-&amp;gt;0 MB, 5 MB goal, 16 P
. . .
gc 273 @2.793s 0%: 0.043+0.46+0.040 ms clock, 0.70+0.24/0.18/0.25+0.65 ms
cpu, 4-&amp;gt;4-&amp;gt;0 MB, 5 MB goal, 16 P
gc 274 @2.804s 0%: 0.043+0.35+0.002 ms clock, 0.69+0.28/0.37/0.16+0.042 ms
cpu, 4-&amp;gt;4-&amp;gt;0 MB, 5 MB goal, 16 P
gc 275 @2.814s 0%: 0.032+0.28+0.017 ms clock, 0.52+0.20/0.26/0.026+0.28 ms
cpu, 4-&amp;gt;4-&amp;gt;0 MB, 5 MB goal, 16 P
2021/05/12 15:17:24 Searching 4000 files, found president 28000 times.
&lt;/code>&lt;/pre>
&lt;p>اینطور به نظر می‌رسد که ، heap در meg 4 نگهداری می شد و تمام memory گذرا بوده است زیرا هر GC منجر به صفر بودن تعداد مقادیر زنده می شد. دقیقاً همان چیزی است که در ردیابی می بینیم. چیزی که واقعاً به آن نیاز داریم اطلاعات بیشتری در مورد GC است. این در مورد 1 GC نیست، بلکه در مورد همه GCهایی است که باید انجام شوند. پس می توانیم این اطلاعات را با استفاده از ابزار انتخاب و دوبار کلیک کردن روی هر خط آبی GC بدست بیاورم.&lt;/p>
&lt;p>&lt;img src="../../assets/img/content/chapter4/tracing/5.png" alt="array" />&lt;/p>
&lt;p>این اعداد در تعیین میزان کار GC در اجرای برنامه مفید هستند. با این اعداد ما یک پایه برای عملکرد برنامه داریم.
&lt;img src="../../assets/img/content/chapter4/tracing/6.png" alt="array" />
با اعداد پایه، هنوز پاسخی در مورد اینکه چگونه می توانم برنامه را سرعت بخشم، نداریم. شاید نگاه کردن به بخش بزرگتری از نمودار کمک کند؟&lt;/p>
&lt;p>![[Pasted image 20230619032144.png]]&lt;/p>
&lt;p>&lt;img src="../../assets/img/content/chapter4/tracing/7.png" alt="array" />&lt;/p>
&lt;p>اگر به این بخش از ردیابی دقیق تر نگاه کنیم، می توانیم مشکل را ببینیم. این برنامه فقط از یک پردازنده منطقی در هر زمان معین برای اجرای کار برنامه استفاده می کند. با این حال GC بیشتر منابع استفاده می کند. اگر الگوریتم را به صورت همزمان و friendly برای استفاده از تمام هسته‌های موجود در دستگاه خود تغییر دهیم، شاید این باید به بهبود performance کمک کند.&lt;/p>
&lt;h2 id="4244-الگوی-fan-out">
4.24.4 الگوی Fan-Out
&lt;a class="anchor" href="#4244-%d8%a7%d9%84%da%af%d9%88%db%8c-fan-out">#&lt;/a>
&lt;/h2>
&lt;p>یکی از الگوهای concurrency که می‌توانم استفاده کنیم، الگوی fan-out است. این الگو به ما اجازه می دهد تا یک الگوریتم همزمان با کمترین مقدار تغییر کد داشته باشم. ایده این الگو این است که برای هر فایلی که نیاز به پردازش دارد، یک گوروتین ایجاد می‌کند و به scheduler اجازه می‌دهد تمام Goroutine را مدیریت کند و آنها را در تمام پردازنده‌های منطقی زمان‌بندی کند. ما می توانیم همه این گوروتین ها را fan-out کنیم زیرا ترتیب کار مهم نیست. مهم این است که همه چیز درست انجام شود.&lt;/p>
&lt;pre>&lt;code class="language-go">func freqConcurrent(topic string, docs []string) int {
var found int
g := len(docs) // &amp;lt;-- ADDED
var wg sync.WaitGroup // &amp;lt;-- ADDED
wg.Add(g) // &amp;lt;-- ADDED
for _, doc := range docs {
. . .
}
wg.Wait() //&amp;lt;-- ADDED
return int
}
&lt;/code>&lt;/pre>
&lt;p>برای شروع، باید کدی اضافه کنیم که مطمئن شویم تا زمانی که کار کامل نشده است، تابع freq برنگردد. این به بهترین وجه با استفاده از WaitGroup پیاده سازی می شود. ما با شناسایی تعداد گوروتین هایی که باید ایجاد شوند شروع می کنیم، که با طول docs collection نشان داده می شود. سپس آن عدد را به WaitGroup اضافه می کنم و در پایان تابع منتظر می مانم تا WaitGroup دوباره به صفر برسد.&lt;/p>
&lt;pre>&lt;code class="language-go">func freqConcurrent(topic string, docs []string) int {
var found int
g := len(docs)
var wg sync.WaitGroup
wg.Add(g)
for _, doc := range docs {
go func(doc string) { // &amp;lt;-- ADDED
defer wg.Done() // &amp;lt;-- ADDED
. . .
}(doc) // &amp;lt;-- ADDED
}
wg.Wait()
return int
}
&lt;/code>&lt;/pre>
&lt;p>برای شروع، باید کدی اضافه کنیم که مطمئن شود تا زمانی که کار کامل نشده است، تابع freq برنگردد. این به بهترین وجه با استفاده از WaitGroup پیاده سازی می شود. من با شناسایی تعداد گوروتین هایی که باید ایجاد شوند شروع می کنیم، که با طول مجموعه اسناد نشان داده می شود. سپس آن عدد را به WaitGroup اضافه می کنیم و در پایان تابع منتظر می مانم تا WaitGroup دوباره به صفر برسد.&lt;/p>
&lt;p>در مرحله بعد، کد موجود را در داخل حلقه for range حول یک Goroutine می پیچیم، جایی که هر document تکرار شده به Goroutine جدید منتقل می شود تا از هرگونه اشکال بسته شدن جلوگیری شود. با وجود Goroutine، می‌توانیم کد WaitGroup را با اطمینان از اینکه هر Goroutine ()wg.Done را قبل از پایان آن فراخوانی می‌کند، نهایی کنیم. آخرین کاری که باید انجام دهیم این است که هنگام پردازش یک فایل، مقدار بازگشتی 0 را از تمام شرایط خطای داخل حلقه حذف کنیم. ممکن است فکر کنیم این کد آماده است زیرا تمام هماهنگی ها با WaitGroup در جای خود است، اما اگر این کد را با race detector اجرا کنیم چه اتفاقی می افتد؟&lt;/p>
&lt;pre>&lt;code class="language-shell">
$ go build -race
$ ./trace &amp;gt; t.out
==================
WARNING: DATA RACE
Read at 0x00c000157548 by goroutine 21:
main.freq.func1()
/Users/bill/code/go/src/github.com/ardanlabs/gotraining/topics/go/
profiling/trace/trace.go:103 +0x644
Previous write at 0x00c000157548 by goroutine 66:
main.freq.func1()
/Users/bill/code/go/src/github.com/ardanlabs/gotraining/topics/go/
profiling/trace/trace.go:103 +0x65d
. . .
==================
&lt;/code>&lt;/pre>
&lt;p>دو خط اول در خروجی می گوید که یک خواندن و یک نوشتن قبلی در همان محل حافظه در همان خط کد در داخل تابع تحت اللفظی وجود دارد. با این وجود در خط 103 چه کدی وجود دارد؟&lt;/p>
&lt;pre>&lt;code class="language-go">96 for _, item := range d.Channel.Items {
97 if strings.Contains(item.Title, topic) {
98 found++
99 continue
100 }
101
102 if strings.Contains(item.Description, topic) {
103 found++
104 }
105 }
&lt;/code>&lt;/pre>
&lt;p>اگر شماره خطوط را به کد اضافه کنیم، می توانیم ببیینم که مورد مربوط به افزایش متغیر پیدا شده است. این کد در واقع دوباره در خط 98 استفاده می شود، بنابراین هر دو خط کد (98، 103) حاوی یک data race است. برای رفع این data race، باید افزایش متغیر پیدا شده را برای استفاده از یک atomic instruction. تغییر دهیم. برای این کار می توانم از atomic package استفاده کنم.&lt;/p>
&lt;pre>&lt;code class="language-go">96 for _, item := range d.Channel.Items {
97 if strings.Contains(item.Title, topic) {
98 atomic.AddInt32(&amp;amp;found, 1) // &amp;lt;-- CHANGED
99 continue
100 }
101
102 if strings.Contains(item.Description, topic) {
103 atomic.AddInt32(&amp;amp;found, 1) // &amp;lt;-- CHANGED
104 }
105 }
&lt;/code>&lt;/pre>
&lt;p>ما خطوط 98 و 103 را برای استفاده از تابع atomic.AddInt32 جایگزین کردم. مشکل این است که این تابع به int32 نیاز دارد نه int، بنابراین باید دو تغییر دیگر انجام دهم.&lt;/p>
&lt;pre>&lt;code class="language-go">func freq(topic string, docs []string) int {
var found int32 // &amp;lt;-- CHANGED
. . .
wg.Wait()
return int(found) // &amp;lt;-- CHANGED
}
&lt;/code>&lt;/pre>
&lt;p>این تغییرات برای استفاده از تابع atomic.AddInt32 و بازگرداندن یک عدد صحیح ضروری است. با این تغییرات، data race از بین خواهد رفت. با این حال، هنوز مشکل دیگری در مورد کد وجود دارد. اینکه آنقدرها هم که می‌توانست با حافظه پنهان سازگار نباشد.&lt;/p>
&lt;h2 id="4245-cache-friendly">
4.24.5 Cache Friendly
&lt;a class="anchor" href="#4245-cache-friendly">#&lt;/a>
&lt;/h2>
&lt;p>در حال تکمیل &amp;hellip;&lt;/p></description></item><item><author/><title>4.25 آموزش profiling</title><link>https://book.gofarsi.ir/chapter-4/profiling/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/profiling/</guid><description>&lt;p>پروفایلینگ یک تکنیک مفید برای شناسایی &lt;span class="tooltip" data-tooltip="bottlenecks" ontouchend="toggleTooltip(this)">گلوگاه‌های&lt;/span>
&lt;span class="tooltip" data-tooltip="performance" ontouchend="toggleTooltip(this)">عملکرد&lt;/span>
، بررسی مصرف حافظه و به دست آوردن بینش درباره سربار جمع‌آوری زباله (Garbage Collection) و موارد دیگر است. اکوسیستم Go ابزارهای فوق‌العاده‌ای برای این منظور ارائه می‌دهد. امکان فعال و غیرفعال کردن پروفایلینگ به ویژه هنگام رفع اشکال در یک برنامه CLI نوشته شده با Go بسیار مفید است.&lt;/p>
&lt;blockquote class="book-hint info">
&lt;p>&lt;strong>نقل و قول نویسنده:&lt;/strong>&lt;/p>
&lt;p>شاید profiling برای حال حاضر قابل اهمیت نباشد اما روزی خواهد رسید که در بخش هایی از پروژه دچار مصرف بیش از حد memory, CPU خواهید شد و اینجاس که profiling به شما کمک خواهد کرد سریز منابع را پیدا کنید.&lt;/p>
&lt;p>سعی کنید این مطلب را یاد بگیرید قطعا یک روزی با این موضوع مواجه خواهید شد.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>چه زمانی پروفایل کنیم؟&lt;/strong>&lt;/p>
&lt;p>موارد استفاده رایج پروفایلینگ عبارتند از:&lt;/p>
&lt;ul>
&lt;li>کشف &lt;span class="tooltip" data-tooltip="bottlenecks" ontouchend="toggleTooltip(this)">گلوگاه‌های&lt;/span>
عملکرد و رفع آن‌ها برای بهبود عملکرد کلی&lt;/li>
&lt;li>یافتن &lt;span class="tooltip" data-tooltip="allocations" ontouchend="toggleTooltip(this)">تخصیص‌های&lt;/span>
اضافی حافظه و کاهش آن‌ها به منظور کاهش تاثیر منفی Garbage Collection بر عملکرد.&lt;/li>
&lt;li>سرریز یا نشت حافظه یا CPU در بلند مدت (نشت منابع وقتی مشخص می شود که سرویس شما برای مدت طولانی چند روز در حال اجرا باشد.)&lt;/li>
&lt;/ul>
&lt;h2 id="4251-مدل-ذهنی-mental-برای-go">
4.25.1 مدل ذهنی (mental) برای Go
&lt;a class="anchor" href="#4251-%d9%85%d8%af%d9%84-%d8%b0%d9%87%d9%86%db%8c-mental-%d8%a8%d8%b1%d8%a7%db%8c-go">#&lt;/a>
&lt;/h2>
&lt;p>ممکن است بتوانید در نوشتن کد Go به مهارت بالایی برسید بدون اینکه درک دقیقی از نحوه عملکرد این زبان در پشت صحنه داشته باشید. اما وقتی به عملکرد و اشکال‌زدایی می‌رسیم، داشتن یک مدل ذهنی از جزئیات داخلی زبان به شدت به نفع شما خواهد بود. بنابراین، ابتدا یک مدل ابتدایی از Go را شرح می‌دهیم. این مدل به اندازه کافی خوب است که به شما کمک کند از اشتباهات رایج اجتناب کنید، اما تمامی مدل‌ها محدودیت دارند، بنابراین توصیه می‌شود که برای حل مشکلات پیچیده‌تر در آینده، به منابع تخصصی‌تر مراجعه کنید.&lt;/p>
&lt;p>وظیفه اصلی Go، مشابه یک سیستم‌عامل، این است که منابع سخت‌افزاری را چندوظیفه‌ای و انتزاعی کند. این کار عمدتاً با استفاده از دو انتزاع اصلی انجام می‌شود:&lt;/p>
&lt;ol>
&lt;li>&lt;span class="tooltip" data-tooltip="Scheduler" ontouchend="toggleTooltip(this)">زمان‌بند&lt;/span>
Goroutine: مدیریت نحوه اجرای کد شما بر روی پردازنده‌های سیستم.&lt;/li>
&lt;li>جمع‌آوری زباله (Garbage Collector): حافظه مجازی را فراهم می‌کند که به طور خودکار در صورت نیاز آزاد می‌شود.&lt;/li>
&lt;/ol>
&lt;h3 id="42511-زمانبند-scheduler-گوروتین">
4.25.1.1 زمان‌بند (scheduler) گوروتین
&lt;a class="anchor" href="#42511-%d8%b2%d9%85%d8%a7%d9%86%d8%a8%d9%86%d8%af-scheduler-%da%af%d9%88%d8%b1%d9%88%d8%aa%db%8c%d9%86">#&lt;/a>
&lt;/h3>
&lt;p>ابتدا با استفاده از مثال زیر در مورد زمان‌بند صحبت کنیم:&lt;/p>
&lt;pre>&lt;code class="language-go">func main() {
res, err := http.Get(&amp;quot;https://example.org/&amp;quot;)
if err != nil {
panic(err)
}
fmt.Printf(&amp;quot;%d\n&amp;quot;, res.StatusCode)
}
&lt;/code>&lt;/pre>
&lt;p>در اینجا یک goroutine واحد داریم که آن را G1 می‌نامیم و این goroutine تابع main را اجرا می‌کند. تصویر زیر یک خط زمانی ساده‌شده از نحوه اجرای این goroutine روی یک پردازنده را نشان می‌دهد. ابتدا G1 بر روی پردازنده اجرا می‌شود تا درخواست HTTP را آماده کند. سپس پردازنده بیکار می‌شود زیرا goroutine باید منتظر شبکه بماند. در نهایت، goroutine دوباره روی پردازنده زمان‌بندی می‌شود تا کد وضعیت را چاپ کند.&lt;/p>
&lt;center>&lt;a href="#">
&lt;img src="../../assets/img/content/chapter4/profiling/1.png" alt="go scheduler">
&lt;/a>&lt;/center>
&lt;p>از دیدگاه زمان‌بند، برنامه بالا به این صورت اجرا می‌شود. ابتدا G1 در حال اجرا روی پردازنده 1 است. سپس goroutine از پردازنده خارج می‌شود و در حال انتظار برای شبکه قرار می‌گیرد. زمانی که زمان‌بند متوجه می‌شود شبکه پاسخ داده است (با استفاده از ورودی/خروجی غیرمسدودکننده، مشابه Node.js) گوروتین را به عنوان &amp;quot; &lt;span class="tooltip" data-tooltip="Runnable" ontouchend="toggleTooltip(this)">آماده اجرا&lt;/span>
&amp;quot; علامت‌گذاری می‌کند. و به محض اینکه یک هسته پردازنده آزاد شود، goroutine دوباره شروع به اجرا می‌کند. در مثال ما تمام هسته‌ها در دسترس هستند، بنابراین G1 بلافاصله بدون صرف زمانی در حالت &amp;ldquo;آماده اجرا&amp;rdquo; می‌تواند به اجرای تابع &lt;code>fmt.Printf()&lt;/code> بر روی یکی از پردازنده‌ها برگردد.&lt;/p>
&lt;center>&lt;a href="#">
&lt;img src="../../assets/img/content/chapter4/profiling/2.gif" alt="scheduler">
&lt;/a>&lt;/center>
&lt;p>در اکثر مواقع، برنامه‌های Go چندین goroutine را به طور همزمان اجرا می‌کنند، بنابراین تعدادی از goroutineها در حال اجرای روی برخی از هسته‌های پردازنده هستند، تعداد زیادی از goroutineها به دلایل مختلف در حالت &amp;ldquo;انتظار&amp;rdquo; قرار دارند، و ایده‌آل این است که هیچ goroutineی در حالت &amp;ldquo;آماده اجرا&amp;rdquo; نباشد، مگر اینکه برنامه شما بار پردازشی بسیار بالایی بر روی پردازنده ایجاد کند. یک مثال از این حالت را می‌توان در زیر مشاهده کرد.&lt;/p>
&lt;center>&lt;a href="#">
&lt;img src="../../assets/img/content/chapter4/profiling/3.png" alt="scheduler complete">
&lt;/a>&lt;/center>
&lt;p>البته مدل بالا بسیاری از جزئیات را نادیده می‌گیرد. در واقعیت، زمان‌بند Go بر روی نخ‌هایی (threads) که توسط سیستم‌عامل مدیریت می‌شوند، کار می‌کند و حتی خود پردازنده‌ها نیز قادر به استفاده از هایپرتردینگ (hyper-threading) هستند که می‌توان آن را نوعی زمان‌بندی در نظر گرفت.&lt;/p>
&lt;p>با این حال، مدل فوق باید برای درک بخش‌های باقی‌مانده از این راهنما کافی باشد. به طور خاص، باید روشن شود که زمان اندازه‌گیری‌شده توسط پروفایلرهای مختلف Go در اصل زمانی است که goroutineهای شما در حالت &amp;ldquo;اجرا&amp;rdquo; (Executing) و &amp;ldquo;انتظار&amp;rdquo; (Waiting) صرف می‌کنند، همان‌طور که در نمودار زیر نشان داده شده است.&lt;/p>
&lt;center>&lt;a href="#">
&lt;img src="../../assets/img/content/chapter4/profiling/4.png" alt="profile venn">
&lt;/a>&lt;/center>
&lt;h3 id="42512-زباله-جمع-کن-garbage-collector">
4.25.1.2 زباله جمع کن (Garbage Collector)
&lt;a class="anchor" href="#42512-%d8%b2%d8%a8%d8%a7%d9%84%d9%87-%d8%ac%d9%85%d8%b9-%da%a9%d9%86-garbage-collector">#&lt;/a>
&lt;/h3>
&lt;p>دیگر انتزاع مهم در Go، جمع‌آوری زباله (Garbage Collector) است. در زبان‌هایی مانند C، برنامه‌نویس باید به صورت دستی تخصیص و آزادسازی حافظه را با استفاده از &lt;code>malloc()&lt;/code> و &lt;code>free()&lt;/code> مدیریت کند. این رویکرد کنترل خوبی ارائه می‌دهد، اما در عمل بسیار مستعد خطا است. یک جمع‌آوری‌کننده زباله (GC) می‌تواند این بار را کاهش دهد، اما مدیریت خودکار حافظه ممکن است به راحتی به یک گلوگاه عملکرد تبدیل شود. این بخش از راهنما یک مدل ساده برای GC در Go ارائه می‌دهد که برای شناسایی و بهینه‌سازی مشکلات مربوط به مدیریت حافظه مفید خواهد بود.&lt;/p>
&lt;p>برای یک راهنمای جامع‌تر درباره GC در Go، به &lt;a href="https://go.dev/doc/gc-guide">مستندات رسمی&lt;/a> مراجعه کنید.&lt;/p>
&lt;h4 id="425121-پشته-stack">
4.25.1.2.1 پشته (Stack)
&lt;a class="anchor" href="#425121-%d9%be%d8%b4%d8%aa%d9%87-stack">#&lt;/a>
&lt;/h4>
&lt;p>با اصول اولیه شروع کنیم. Go می‌تواند حافظه را در یکی از دو مکان تخصیص دهد: پشته یا هیپ. هر goroutine پشته خاص خود را دارد که یک ناحیه پیوسته از حافظه است. علاوه بر این، یک ناحیه بزرگ از حافظه وجود دارد که بین goroutineها به اشتراک گذاشته می‌شود و به آن &lt;span class="tooltip" data-tooltip="heap" ontouchend="toggleTooltip(this)">هیپ&lt;/span>
می‌گویند. این حالت را می‌توان در تصویر زیر مشاهده کرد.&lt;/p>
&lt;center>&lt;a href="#">
&lt;img src="../../assets/img/content/chapter4/profiling/5.png" alt="sample heap">
&lt;/a>&lt;/center>
&lt;p>وقتی یک تابع تابع دیگری را فراخوانی می‌کند، یک بخش مخصوص روی پشته به آن اختصاص داده می‌شود که به آن «فریم پشته» (stack frame) می‌گویند و می‌تواند برای قرار دادن متغیرهای محلی از آن استفاده کند. یک اشاره‌گر پشته (stack pointer) برای شناسایی محل آزاد بعدی در فریم استفاده می‌شود. زمانی که یک تابع به پایان می‌رسد، داده‌های فریم قبلی به سادگی با بازگرداندن اشاره‌گر پشته به انتهای فریم قبلی حذف می‌شوند. داده‌های فریم همچنان می‌توانند در پشته باقی بمانند و با فراخوانی بعدی تابع بازنویسی شوند. این فرآیند بسیار ساده و کارآمد است زیرا Go نیازی به پیگیری هر متغیر ندارد.&lt;/p>
&lt;pre>&lt;code class="language-go">func main() {
sum := 0
sum = add(23, 42)
fmt.Println(sum)
}
func add(a, b int) int {
return a + b
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>برای درک بهتر این موضوع، به مثال زیر توجه کنید:&lt;/strong>&lt;/p>
&lt;p>در اینجا یک تابع &lt;code>main()&lt;/code> داریم که با رزرو مقداری فضا روی پشته برای متغیر &lt;code>sum&lt;/code> شروع می‌شود. وقتی تابع &lt;code>add()&lt;/code> فراخوانی می‌شود، یک فریم مخصوص برای نگه داشتن پارامترهای محلی &lt;code>a&lt;/code> و &lt;code>b&lt;/code> به آن اختصاص داده می‌شود. پس از اتمام اجرای &lt;code>add()&lt;/code>، داده‌های آن با بازگرداندن اشاره‌گر پشته به انتهای فریم تابع &lt;code>main()&lt;/code> حذف می‌شوند و متغیر &lt;code>sum&lt;/code> با نتیجه به‌روز می‌شود. در همین حال، مقادیر قدیمی تابع &lt;code>add()&lt;/code> فراتر از اشاره‌گر پشته باقی می‌مانند تا با فراخوانی بعدی تابع بازنویسی شوند. در زیر یک تصویرسازی از این فرآیند آمده است:&lt;/p>
&lt;center>&lt;a href="#">
&lt;img src="../../assets/img/content/chapter4/profiling/6.gif" alt="stack">
&lt;/a>&lt;/center>
&lt;p>مثال بالا به شدت ساده شده است و بسیاری از جزئیات مانند مقادیر بازگشتی، اشاره‌گرهای فریم، آدرس‌های بازگشت و درون‌خطی‌سازی (inlining) توابع را حذف کرده است. در واقع، از نسخه Go 1.17 به بعد، ممکن است برنامه بالا نیازی به فضای پشته نداشته باشد، زیرا مقدار کم داده می‌تواند توسط کامپایلر با استفاده از ثبات‌های پردازنده (CPU registers) مدیریت شود. اما این مسئله مشکلی ایجاد نمی‌کند. این مدل همچنان به شما یک شهود معقول از نحوه تخصیص و حذف متغیرهای محلی در برنامه‌های پیچیده‌تر Go روی پشته می‌دهد.&lt;/p>
&lt;p>شاید در این مرحله این سوال برای شما پیش بیاید که چه اتفاقی می‌افتد اگر فضای پشته تمام شود. در زبان‌هایی مانند C، این موضوع باعث خطای سرریز پشته (stack overflow) می‌شود. اما در Go، این مشکل به صورت خودکار با ایجاد یک نسخه کپی از پشته که دو برابر بزرگتر است، مدیریت می‌شود. این قابلیت به goroutineها اجازه می‌دهد که با پشته‌های بسیار کوچک، معمولاً 2 کیلوبایت، شروع کنند و یکی از عوامل اصلی مقیاس‌پذیری بیشتر goroutineها نسبت به نخ‌های سیستم‌عامل همین موضوع است.&lt;/p>
&lt;h4 id="425122-هیپ-heap">
4.25.1.2.2 هیپ (Heap)
&lt;a class="anchor" href="#425122-%d9%87%db%8c%d9%be-heap">#&lt;/a>
&lt;/h4>
&lt;p>تخصیص‌های پشته عالی هستند، اما در بسیاری از موارد Go نمی‌تواند از آن‌ها استفاده کند. رایج‌ترین حالت زمانی است که باید اشاره‌گری به یک متغیر محلی از یک تابع بازگردانده شود. این موضوع را می‌توان در نسخه اصلاح‌شده مثال تابع &lt;code>add()&lt;/code> که در بالا آمد، مشاهده کرد:&lt;/p>
&lt;pre>&lt;code class="language-go">func main() {
fmt.Println(*add(23, 42))
}
func add(a, b int) *int {
sum := a + b
return &amp;amp;sum
}
&lt;/code>&lt;/pre>
&lt;p>در حالت عادی، Go می‌تواند متغیر &lt;code>sum&lt;/code> را داخل تابع &lt;code>add()&lt;/code> روی پشته تخصیص دهد. اما همانطور که یاد گرفتیم، این داده‌ها هنگام بازگشت تابع &lt;code>add()&lt;/code> از بین می‌روند. بنابراین، برای بازگرداندن ایمن یک اشاره‌گر به &lt;code>&amp;amp;sum&lt;/code>، Go باید حافظه را از خارج از پشته تخصیص دهد. اینجا است که هیپ وارد عمل می‌شود.&lt;/p>
&lt;p>&lt;strong>هیپ&lt;/strong> برای ذخیره‌سازی داده‌هایی استفاده می‌شود که ممکن است پس از پایان اجرای تابع سازنده، همچنان مورد نیاز باشند، همچنین برای هر داده‌ای که بین goroutineها با استفاده از اشاره‌گرها به اشتراک گذاشته می‌شود. اما این سوال پیش می‌آید که چگونه این حافظه آزاد می‌شود؟ چون برخلاف تخصیص‌های پشته، تخصیص‌های هیپ را نمی‌توان به محض اتمام تابعی که آن‌ها را ایجاد کرده، حذف کرد.&lt;/p>
&lt;p>Go این مشکل را با استفاده از جمع‌آوری زباله داخلی (GC) خود حل می‌کند. جزئیات پیاده‌سازی آن بسیار پیچیده است، اما از یک دید کلی، GC حافظه شما را به این شکل مدیریت می‌کند. در تصویر زیر می‌بینید که سه goroutine دارای اشاره‌گرهایی به تخصیص‌های سبز رنگ روی هیپ هستند. برخی از این تخصیص‌ها همچنین به تخصیص‌های سبز دیگری اشاره می‌کنند. علاوه بر این، تخصیص‌های خاکستری وجود دارند که ممکن است به تخصیص‌های سبز یا یکدیگر اشاره کنند، اما خودشان توسط تخصیص‌های سبز مرجع نشده‌اند. این تخصیص‌ها زمانی قابل دسترس بودند، اما اکنون به عنوان زباله در نظر گرفته می‌شوند. این اتفاق ممکن است زمانی رخ دهد که تابعی که اشاره‌گرهای آن‌ها را روی پشته ایجاد کرده بود بازگردد، یا مقدارشان بازنویسی شده باشد. وظیفه GC این است که به صورت خودکار این تخصیص‌ها را شناسایی و آزاد کند.&lt;/p>
&lt;center>&lt;a href="#">
&lt;img src="../../assets/img/content/chapter4/profiling/7.gif" alt="heap gc">
&lt;/a>&lt;/center>
&lt;p>اجرای جمع‌آوری زباله (GC) شامل پیمایش گراف‌های پرهزینه و تخلیه کش (cache thrashing) است. این فرایند حتی نیاز به فازهای متوقف‌کننده کل جهان (stop-the-world) دارد که اجرای کل برنامه شما را متوقف می‌کند. خوشبختانه نسخه‌های اخیر Go این زمان را به کسری از یک میلی‌ثانیه کاهش داده‌اند، اما بسیاری از هزینه‌های باقی‌مانده ذاتاً به هر GC مربوط می‌شود. در واقع، معمولاً ۲۰ تا ۳۰ درصد از اجرای یک برنامه Go صرف مدیریت حافظه می‌شود.&lt;/p>
&lt;p>به‌طور کلی، هزینه GC متناسب با مقدار تخصیص‌های هیپ (heap allocations) است که برنامه شما انجام می‌دهد. بنابراین وقتی صحبت از بهینه‌سازی هزینه‌های مرتبط با حافظه می‌شود، شعار این است:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>کاهش (Reduce)&lt;/strong>: سعی کنید تخصیص‌های هیپ را به تخصیص‌های پشته تبدیل کنید یا از آن‌ها به‌طور کلی اجتناب کنید. کاهش تعداد اشاره‌گرها در هیپ نیز کمک می‌کند.&lt;/li>
&lt;li>&lt;strong>بازاستفاده (Reuse)&lt;/strong>: تخصیص‌های هیپ را دوباره استفاده کنید به جای اینکه آن‌ها را با تخصیص‌های جدید جایگزین کنید.&lt;/li>
&lt;li>&lt;strong>بازیافت (Recycle)&lt;/strong>: برخی از تخصیص‌های هیپ غیرقابل اجتناب هستند. بگذارید GC آن‌ها را بازیافت کند و بر روی مسائل دیگر تمرکز کنید.&lt;/li>
&lt;/ul>
&lt;p>همانند مدل ذهنی قبلی در این راهنما، همه موارد بالا نمایی به شدت ساده شده از واقعیت است. اما امیدوارم که این مدل به اندازه کافی مفید باشد تا باقی‌مانده این راهنما را درک کنید و شما را به مطالعه مقالات بیشتری در این زمینه ترغیب کند.&lt;/p>
&lt;h2 id="4252-درک-عمیق-پروفایلرهای-profilers-گو">
4.25.2 درک عمیق پروفایلرهای (Profilers) گو
&lt;a class="anchor" href="#4252-%d8%af%d8%b1%da%a9-%d8%b9%d9%85%db%8c%d9%82-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1%d9%87%d8%a7%db%8c-profilers-%da%af%d9%88">#&lt;/a>
&lt;/h2>
&lt;p>در اینجا مروری بر &lt;span class="tooltip" data-tooltip="profilers" ontouchend="toggleTooltip(this)">پروفایلرهای&lt;/span>
ساخته‌شده در زمان اجرای Go (Go runtime) ارائه می‌شود. برای جزئیات بیشتر، به لینک‌ها مراجعه کنید.&lt;/p>
&lt;p>در زیر جدول مربوط به پروفایلرهای مختلف موجود در Go ارائه شده است:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>ویژگی&lt;/th>
&lt;th>&lt;a href="#42521-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-cpu">CPU&lt;/a>&lt;/th>
&lt;th>&lt;a href="#42522-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-%d8%ad%d8%a7%d9%81%d8%b8%d9%87-memory">Memory&lt;/a>&lt;/th>
&lt;th>&lt;a href="#42523-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-%d8%a8%d9%84%d8%a7%da%a9">Block&lt;/a>&lt;/th>
&lt;th>&lt;a href="#42524-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-mutex">Mutex&lt;/a>&lt;/th>
&lt;th>&lt;a href="#42525-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-goroutine">Goroutine&lt;/a>&lt;/th>
&lt;th>&lt;a href="#42526-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-threadcreate">ThreadCreate&lt;/a>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Production Safety&lt;/td>
&lt;td>✅&lt;/td>
&lt;td>✅&lt;/td>
&lt;td>⚠ (1.)&lt;/td>
&lt;td>✅&lt;/td>
&lt;td>⚠️ (2.)&lt;/td>
&lt;td>🐞 (3.)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;span class="tooltip" data-tooltip="Safe Rate" ontouchend="toggleTooltip(this)">نرخ ایمنی&lt;/span>
&lt;/td>
&lt;td>default&lt;/td>
&lt;td>default&lt;/td>
&lt;td>❌ (1.)&lt;/td>
&lt;td>&lt;code>100&lt;/code>&lt;/td>
&lt;td>&lt;code>1000&lt;/code> goroutines&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;span class="tooltip" data-tooltip="Accuracy" ontouchend="toggleTooltip(this)">دقت&lt;/span>
&lt;/td>
&lt;td>⭐️⭐️&lt;/td>
&lt;td>⭐⭐⭐&lt;/td>
&lt;td>⭐⭐⭐&lt;/td>
&lt;td>⭐⭐⭐&lt;/td>
&lt;td>⭐⭐⭐&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;span class="tooltip" data-tooltip="Max Stack Depth" ontouchend="toggleTooltip(this)">عمق حداکثر پشته&lt;/span>
&lt;/td>
&lt;td>&lt;code>64&lt;/code>&lt;/td>
&lt;td>&lt;code>32&lt;/code>&lt;/td>
&lt;td>&lt;code>32&lt;/code>&lt;/td>
&lt;td>&lt;code>32&lt;/code>&lt;/td>
&lt;td>&lt;code>32&lt;/code> - &lt;code>100&lt;/code> (4.)&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;span class="tooltip" data-tooltip="Profiler Labels" ontouchend="toggleTooltip(this)">برچسب‌های پروفایلر&lt;/span>
&lt;/td>
&lt;td>✅&lt;/td>
&lt;td>❌&lt;/td>
&lt;td>❌&lt;/td>
&lt;td>❌&lt;/td>
&lt;td>✅&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ol>
&lt;li>&lt;strong>پروفایلر بلوک&lt;/strong> (block profiler): اگر به درستی پیکربندی نشده باشد، پروفایلر بلوک می‌تواند منبع قابل توجهی از بار CPU باشد.&lt;/li>
&lt;li>&lt;strong>توقف‌های جهانی&lt;/strong> (stop-the-world): یک توقف جهانی&lt;code>O(N)&lt;/code> وجود دارد که N تعداد goroutineها است. انتظار می‌رود هر goroutine بین &lt;code>~1-10&lt;/code> میکروثانیه توقف داشته باشد.&lt;/li>
&lt;li>&lt;strong>پروفایلر ThreadCreate&lt;/strong>: این پروفایلر به طور کامل معیوب است و بهتر است از آن استفاده نکنید.&lt;/li>
&lt;li>&lt;strong>عمق حداکثر پشته&lt;/strong>: این مورد به API وابسته است.&lt;/li>
&lt;/ol>
&lt;h3 id="42521-پروفایلر-cpu">
4.25.2.1 پروفایلر CPU
&lt;a class="anchor" href="#42521-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-cpu">#&lt;/a>
&lt;/h3>
&lt;p>پروفایلر CPU در Go می‌تواند به شما کمک کند تا قسمت‌هایی از کد خود را که زمان CPU زیادی مصرف می‌کنند، شناسایی کنید.&lt;/p>
&lt;p>⚠️ توجه داشته باشید که زمان CPU معمولاً با زمان واقعی که کاربران شما تجربه می‌کنند (که به آن تاخیر می‌گویند) متفاوت است. به عنوان مثال، یک درخواست HTTP معمولاً ممکن است ۱۰۰ میلی‌ثانیه طول بکشد، اما تنها ۵ میلی‌ثانیه از زمان CPU را مصرف کند و ۹۵ میلی‌ثانیه را در انتظار پاسخ از پایگاه داده بگذراند. همچنین ممکن است یک درخواست ۱۰۰ میلی‌ثانیه طول بکشد، اما ۲۰۰ میلی‌ثانیه از زمان CPU را صرف کند اگر دو goroutine به طور همزمان کارهای پردازشی سنگین انجام دهند. اگر این موضوع برای شما گیج‌کننده است.&lt;/p>
&lt;p>شما می‌توانید پروفایلر CPU را از طریق APIهای مختلف کنترل کنید:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>go test -cpuprofile cpu.pprof&lt;/code>: این دستور تست‌های شما را اجرا کرده و پروفایل CPU را در فایلی به نام &lt;strong>cpu.pprof&lt;/strong> می‌نویسد.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>pprof.StartCPUProfile(w)&lt;/code>: این دستور پروفایل CPU را به &lt;strong>w&lt;/strong> ضبط می‌کند و زمان را تا زمانی که &lt;code>pprof.StopCPUProfile()&lt;/code> فراخوانی شود، پوشش می‌دهد.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>import _ &amp;quot;net/http/pprof&amp;quot;&lt;/code>: این کد به شما اجازه می‌دهد با درخواست GET به آدرس &lt;code>/debug/pprof/profile?seconds=30&lt;/code> از سرور HTTP پیش‌فرض که می‌توانید با استفاده از &lt;code>http.ListenAndServe(&amp;quot;localhost:6060&amp;quot;, nil)&lt;/code> راه‌اندازی کنید، یک پروفایل CPU به مدت ۳۰ ثانیه درخواست کنید.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>runtime.SetCPUProfileRate()&lt;/code>: این تابع به شما اجازه می‌دهد نرخ نمونه‌گیری پروفایلر CPU را کنترل کنید. برای محدودیت‌های فعلی به &lt;strong>محدودیت‌های پروفایلر CPU&lt;/strong> مراجعه کنید.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>runtime.SetCgoTraceback()&lt;/code>: این تابع می‌تواند برای دریافت ردیابی‌های پشته به کد cgo استفاده شود. &lt;code>benesch/cgosymbolizer&lt;/code> یک پیاده‌سازی برای Linux و macOS دارد.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>اگر به یک قطعه کد سریع نیاز دارید که بتوانید در تابع &lt;strong>main()&lt;/strong> خود قرار دهید، می‌توانید از کد زیر استفاده کنید:&lt;/p>
&lt;pre>&lt;code class="language-go">file, _ := os.Create(&amp;quot;./cpu.pprof&amp;quot;)
pprof.StartCPUProfile(file)
defer pprof.StopCPUProfile()
&lt;/code>&lt;/pre>
&lt;p>صرف نظر از اینکه چگونه پروفایلر CPU را فعال می‌کنید، پروفایل به‌دست‌آمده در اصل یک جدول از ردیابی‌های پشته است که به فرمت باینری &lt;strong>pprof&lt;/strong> قالب‌بندی شده است. در زیر نسخه‌ای ساده‌شده از چنین جدولی نشان داده شده است:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>stack trace&lt;/th>
&lt;th>samples/count&lt;/th>
&lt;th>cpu/nanoseconds&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>main;foo&lt;/td>
&lt;td>5&lt;/td>
&lt;td>50000000&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>main;foo;bar&lt;/td>
&lt;td>3&lt;/td>
&lt;td>30000000&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>main;foobar&lt;/td>
&lt;td>4&lt;/td>
&lt;td>40000000&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>پروفایلر CPU این داده‌ها را با درخواست از سیستم‌عامل برای نظارت بر استفاده از CPU برنامه جمع‌آوری می‌کند و هر ۱۰ میلی‌ثانیه که CPU زمانی را مصرف می‌کند، سیگنال &lt;strong>SIGPROF&lt;/strong> را به آن ارسال می‌کند. همچنین سیستم‌عامل زمان صرف‌شده توسط کرنل به نمایندگی از برنامه را در این نظارت شامل می‌کند. از آنجا که نرخ تحویل سیگنال به مصرف CPU وابسته است، این نرخ دینامیک بوده و می‌تواند به حداکثر &lt;strong>N * 100Hz&lt;/strong> برسد که در آن &lt;strong>N&lt;/strong> تعداد هسته‌های منطقی CPU در سیستم است.&lt;/p>
&lt;p>هنگامی که سیگنال &lt;strong>SIGPROF&lt;/strong> دریافت می‌شود، هندلر سیگنال Go یک ردیابی پشته از goroutine فعالی که در حال حاضر در حال اجرا است، جمع‌آوری می‌کند و مقادیر مربوطه در پروفایل را افزایش می‌دهد. مقدار &lt;strong>cpu/nanoseconds&lt;/strong> در حال حاضر مستقیماً از تعداد نمونه‌ها مشتق می‌شود، بنابراین این مقدار تکراری است، اما راحت است.&lt;/p>
&lt;h4 id="425211-برچسبهای-پروفایلر-profiler-labels-cpu">
4.25.2.1.1 برچسب‌های پروفایلر (Profiler Labels) CPU
&lt;a class="anchor" href="#425211-%d8%a8%d8%b1%da%86%d8%b3%d8%a8%d9%87%d8%a7%db%8c-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-profiler-labels-cpu">#&lt;/a>
&lt;/h4>
&lt;p>یکی از ویژگی‌های جالب پروفایلر CPU در Go این است که می‌توانید جفت‌های کلید و مقدار دلخواهی را به یک goroutine متصل کنید. این برچسب‌ها توسط هر goroutine‌ای که از آن goroutine متولد می‌شود، به ارث برده می‌شوند و در پروفایل نهایی نمایش داده می‌شوند.&lt;/p>
&lt;p>بیایید مثالی را در نظر بگیریم که برخی از کارهای CPU را به نمایندگی از یک کاربر انجام می‌دهد. با استفاده از API های &lt;code>pprof.Labels()&lt;/code> و &lt;code>pprof.Do()&lt;/code>، می‌توانیم کاربر را با goroutine که در حال اجرای تابع &lt;code>work()&lt;/code> است، مرتبط کنیم. علاوه بر این، برچسب‌ها به‌طور خودکار توسط هر goroutine‌ای که در همان بلوک کد متولد می‌شود، به ارث برده می‌شوند، برای مثال &lt;code>goroutine backgroundWork()&lt;/code>.&lt;/p>
&lt;pre>&lt;code class="language-go">func work(ctx context.Context, user string) {
labels := pprof.Labels(&amp;quot;user&amp;quot;, user)
pprof.Do(ctx, labels, func(_ context.Context) {
go backgroundWork()
directWork()
})
}
&lt;/code>&lt;/pre>
&lt;p>پروفایل نهایی شامل یک ستون برچسب جدید خواهد بود و ممکن است به شکل زیر باشد:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>stack trace&lt;/th>
&lt;th>label&lt;/th>
&lt;th>samples/count&lt;/th>
&lt;th>cpu/nanoseconds&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>main.backgroundWork&lt;/td>
&lt;td>user:bob&lt;/td>
&lt;td>5&lt;/td>
&lt;td>50000000&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>main.backgroundWork&lt;/td>
&lt;td>user:alice&lt;/td>
&lt;td>2&lt;/td>
&lt;td>20000000&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>main.work;main.directWork&lt;/td>
&lt;td>user:bob&lt;/td>
&lt;td>4&lt;/td>
&lt;td>40000000&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>main.work;main.directWork&lt;/td>
&lt;td>user:alice&lt;/td>
&lt;td>3&lt;/td>
&lt;td>30000000&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>مشاهده همان پروفایل با نمای گراف pprof نیز شامل برچسب‌ها خواهد بود:&lt;/p>
&lt;center>&lt;a href="#">
&lt;img src="../../assets/img/content/chapter4/profiling/8.png" alt="cpu profiler labels">
&lt;/a>&lt;/center>
&lt;p>چگونگی استفاده از این برچسب‌ها به شما بستگی دارد. می‌توانید مواردی مانند شناسه‌های کاربری، شناسه‌های درخواست، نقاط پایانی HTTP، برنامه‌های اشتراک یا داده‌های دیگر را شامل کنید که به شما کمک می‌کند درک بهتری از اینکه کدام نوع درخواست‌ها باعث مصرف بالای CPU می‌شوند، حتی زمانی که توسط همان مسیرهای کد پردازش می‌شوند، به دست آورید. با این حال، استفاده از برچسب‌ها اندازه فایل‌های pprof شما را افزایش می‌دهد. بنابراین بهتر است با برچسب‌های با کاردینالیته پایین مانند نقاط پایانی شروع کنید و سپس به برچسب‌های با کاردینالیته بالا بروید، زمانی که احساس می‌کنید بر عملکرد برنامه شما تأثیر نمی‌گذارد.&lt;/p>
&lt;p>⚠️ نسخه‌های Go 1.17 و پایین‌تر حاوی چندین اشکال بودند که می‌توانستند منجر به عدم وجود برخی برچسب‌های پروفایلر در پروفایل‌های CPU شوند، برای اطلاعات بیشتر به محدودیت‌های پروفایلر CPU مراجعه کنید.&lt;/p>
&lt;h4 id="425212-مصرف-cpu">
4.25.2.1.2 مصرف CPU
&lt;a class="anchor" href="#425212-%d9%85%d8%b5%d8%b1%d9%81-cpu">#&lt;/a>
&lt;/h4>
&lt;p>از آنجایی که نرخ نمونه‌گیری پروفایلر CPU با توجه به مقدار CPU که برنامه شما مصرف می‌کند، تنظیم می‌شود، می‌توانید مصرف CPU را از پروفایل‌های CPU استخراج کنید. در واقع، pprof این کار را به طور خودکار برای شما انجام می‌دهد. به عنوان مثال، پروفایل زیر از برنامه‌ای استخراج شده است که دارای میانگین مصرف CPU برابر با 147.77% بود:&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go tool pprof guide/cpu-utilization.pprof
Type: cpu
Time: Sep 9, 2021 at 11:34pm (CEST)
Duration: 1.12s, Total samples = 1.65s (147.77%)
Entering interactive mode (type &amp;quot;help&amp;quot; for commands, &amp;quot;o&amp;quot; for options)
(pprof)
&lt;/code>&lt;/pre>
&lt;p>روش دیگری که برای بیان مصرف CPU محبوب است، استفاده از هسته‌های CPU است. در مثال بالا، برنامه به‌طور میانگین از 1.47 هسته CPU در طول دوره پروفایل‌سازی استفاده می‌کرد.&lt;/p>
&lt;p>⚠️ در نسخه‌های Go 1.17 و پایین‌تر، نباید به این عدد به خصوص اگر نزدیک یا بیشتر از 250% باشد، اعتماد زیادی داشته باشید. با این حال، اگر عدد بسیار پایینی مانند 10% مشاهده کردید، معمولاً نشان‌دهنده این است که مصرف CPU برای برنامه شما مشکلی نیست. یک اشتباه رایج این است که به این عدد توجه نکرده و نگران یک تابع خاص باشید که زمان زیادی نسبت به بقیه پروفایل صرف می‌کند. این معمولاً وقت تلف کردن است، زمانی که مصرف کلی CPU پایین است، زیرا از بهینه‌سازی این تابع چندان سودی نخواهید برد.&lt;/p>
&lt;h4 id="425213-فراخوانیهای-سیستم-در-پروفایلهای-cpu">
4.25.2.1.3 فراخوانی‌های سیستم در پروفایل‌های CPU
&lt;a class="anchor" href="#425213-%d9%81%d8%b1%d8%a7%d8%ae%d9%88%d8%a7%d9%86%db%8c%d9%87%d8%a7%db%8c-%d8%b3%db%8c%d8%b3%d8%aa%d9%85-%d8%af%d8%b1-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d9%87%d8%a7%db%8c-cpu">#&lt;/a>
&lt;/h4>
&lt;p>اگر در پروفایل‌های CPU خود فراخوانی‌های سیستمی مانند &lt;code>syscall.Read()&lt;/code> یا &lt;code>syscall.Write()&lt;/code> را مشاهده کردید که زمان زیادی را صرف می‌کنند، لطفاً توجه داشته باشید که این فقط زمان CPU صرف شده در داخل این توابع در هسته است. زمان I/O خود به‌طور جداگانه پیگیری نمی‌شود. صرف زمان زیادی در فراخوانی‌های سیستمی معمولاً نشانه‌ای از انجام بیش از حد آن‌ها است، بنابراین شاید افزایش اندازه بافرها بتواند کمک کند. برای موقعیت‌های پیچیده‌تر مانند این، باید استفاده از Linux perf را در نظر بگیرید، زیرا می‌تواند stack trace های هسته را نیز به شما نشان دهد که ممکن است سرنخ‌های اضافی برای شما فراهم کند.&lt;/p>
&lt;h4 id="425214-محدودیتهای-پروفایلر-cpu">
4.25.2.1.4 محدودیت‌های پروفایلر CPU
&lt;a class="anchor" href="#425214-%d9%85%d8%ad%d8%af%d9%88%d8%af%db%8c%d8%aa%d9%87%d8%a7%db%8c-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-cpu">#&lt;/a>
&lt;/h4>
&lt;p>چندین مشکل و محدودیت شناخته‌شده برای پروفایلر CPU وجود دارد که ممکن است بخواهید از آن‌ها آگاه باشید:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>🐞 &lt;a href="https://github.com/golang/go/issues/35057">&lt;strong>GH #35057&lt;/strong>&lt;/a>: پروفایل‌های CPU که با نسخه‌های Go &amp;lt;= 1.17 گرفته شده‌اند، به‌طور نسبی برای برنامه‌هایی که از بیش از 2.5 هسته CPU استفاده می‌کنند، دقت کمتری دارند. به‌طور کلی، استفاده کلی از CPU به‌طور نادرست گزارش می‌شود و پیک‌های بارکاری ممکن است به‌درستی در پروفایل حاصل نمایان نشوند. این مشکل در Go 1.18 برطرف شده است. در عین حال، می‌توانید از Linux perf به‌عنوان یک راه‌حل موقت استفاده کنید.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>🐞 &lt;strong>برچسب‌های پروفایلر در Go &amp;lt;= 1.17&lt;/strong> از چندین باگ رنج می‌بردند.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/golang/go/issues/48577">&lt;strong>GH #48577&lt;/strong>&lt;/a> و &lt;a href="https://go-review.googlesource.com/c/go/&amp;#43;/367200/">&lt;strong>CL 367200&lt;/strong>&lt;/a>: برچسب‌ها برای goroutineهایی که بر روی استک سیستم، کد C را اجرا می‌کنند یا فراخوانی‌های سیستمی را انجام می‌دهند، گم شده بودند.&lt;/li>
&lt;li>&lt;a href="https://go-review.googlesource.com/c/go/&amp;#43;/369741">&lt;strong>CL 369741&lt;/strong>&lt;/a>: اولین دسته از نمونه‌ها در یک پروفایل CPU دارای خطای off-by-one بودند که باعث نسبت‌گذاری نادرست برچسب‌ها می‌شد.&lt;/li>
&lt;li>&lt;a href="https://go-review.googlesource.com/c/go/&amp;#43;/369983">&lt;strong>CL 369983&lt;/strong>&lt;/a>: سیستم goroutineهایی که به نمایندگی از goroutineهای کاربر ایجاد شده‌اند (مثلاً برای جمع‌آوری زباله) به‌طور نادرست برچسب‌های والدین خود را به ارث بردند.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>⚠️️ می‌توانید از &lt;a href="https://pkg.go.dev/runtime#SetCPUProfileRate">&lt;code>runtime.SetCPUProfileRate()&lt;/code>&lt;/a> برای تنظیم نرخ پروفایلر CPU قبل از فراخوانی &lt;code>runtime.StartCPUProfile()&lt;/code> استفاده کنید. این عمل یک هشدار را چاپ می‌کند که می‌گوید &lt;code>runtime: cannot set cpu profile rate until previous profile has finished&lt;/code>. با این حال، این عمل هنوز در چارچوب محدودیت‌های باگ ذکر شده عمل می‌کند. این مسئله ابتدا در &lt;a href="https://github.com/golang/go/issues/40094">اینجا&lt;/a> مطرح شد و یک &lt;a href="https://github.com/golang/go/issues/42502">پیشنهاد&lt;/a> پذیرفته شده برای بهبود API وجود دارد.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>⚠️ حداکثر تعداد فراخوانی‌های تو در توی تابعی که می‌تواند در stack trace ها توسط پروفایلر CPU ضبط شود، در حال حاضر &lt;a href="https://sourcegraph.com/search?q=context:global&amp;#43;repo:github.com/golang/go&amp;#43;file:src/*&amp;#43;maxCPUProfStack&amp;#43;%3D&amp;amp;patternType=literal">64&lt;/a> است. اگر برنامه شما از الگوهایی مانند بازگشت عمیق یا دیگر الگوهایی استفاده کند که به عمق استک بالایی منجر می‌شود، پروفایل CPU شما شامل stack trace هایی خواهد بود که برش داده شده‌اند. این به این معناست که شما بخشی از زنجیرهٔ فراخوانی که به تابعی که در زمان نمونه‌برداری فعال بود، منجر شده، را از دست خواهید داد.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="42522-پروفایلر-حافظه-memory">
4.25.2.2 پروفایلر حافظه (Memory)
&lt;a class="anchor" href="#42522-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-%d8%ad%d8%a7%d9%81%d8%b8%d9%87-memory">#&lt;/a>
&lt;/h3>
&lt;p>پروفایلر حافظه در Go می‌تواند به شما کمک کند تا شناسایی کنید کدام بخش‌های کد شما دارای تعداد زیادی تخصیصات حافظه در هیپ (heap) هستند و همچنین چند تا از این تخصیصات در آخرین جمع‌آوری زباله (garbage collection) هنوز در دسترس بودند. به همین دلیل، پروفایل تولید شده توسط پروفایلر حافظه معمولاً به‌عنوان پروفایل هیپ نیز شناخته می‌شود.&lt;/p>
&lt;p>مدیریت حافظه هیپ معمولاً مسئول حدود 20-30% از زمان CPU مصرفی توسط فرآیندهای Go است. علاوه بر این، حذف تخصیصات هیپ می‌تواند تأثیرات ثانویه‌ای داشته باشد که بخش‌های دیگر کد شما را به‌دلیل کاهش مقدار هدر رفت کش (cache thrashing) که در هنگام اسکن هیپ توسط جمع‌آورنده زباله (garbage collector) رخ می‌دهد، سریع‌تر می‌کند. به این معنی که بهینه‌سازی تخصیص‌های حافظه می‌تواند معمولاً بازگشت بهتری نسبت به بهینه‌سازی مسیرهای کد وابسته به CPU در برنامه شما داشته باشد.&lt;/p>
&lt;p>⚠️ پروفایلر حافظه تخصیصات استک را نشان نمی‌دهد زیرا این‌ها به‌طور کلی بسیار ارزان‌تر از تخصیصات هیپ هستند. برای اطلاعات بیشتر به بخش جمع‌آورنده زباله مراجعه کنید.&lt;/p>
&lt;p>شما می‌توانید پروفایلر حافظه را از طریق API های مختلف کنترل کنید:&lt;/p>
&lt;ul>
&lt;li>&lt;code>go test -memprofile mem.pprof&lt;/code> تست‌های شما را اجرا می‌کند و پروفایل حافظه را در فایلی به نام &lt;code>mem.pprof&lt;/code> می‌نویسد.&lt;/li>
&lt;li>&lt;code>pprof.Lookup(&amp;quot;allocs&amp;quot;).WriteTo(w, 0)&lt;/code> پروفایل حافظه‌ای که شامل رویدادهای تخصیص از زمان شروع فرآیند است را به &lt;code>w&lt;/code> می‌نویسد.&lt;/li>
&lt;li>&lt;code>import _ &amp;quot;net/http/pprof&amp;quot;&lt;/code> به شما امکان می‌دهد که یک پروفایل حافظه 30 ثانیه‌ای با فراخوانی &lt;code>GET /debug/pprof/allocs?seconds=30&lt;/code> از سرور HTTP پیش‌فرض که می‌توانید با &lt;code>http.ListenAndServe(&amp;quot;localhost:6060&amp;quot;, nil)&lt;/code> راه‌اندازی کنید، درخواست کنید. این پروفایل به‌طور داخلی به عنوان پروفایل دلتا (delta profile) شناخته می‌شود.&lt;/li>
&lt;li>&lt;code>runtime.MemProfileRate&lt;/code> به شما اجازه می‌دهد تا نرخ نمونه‌برداری پروفایلر حافظه را کنترل کنید. برای محدودیت‌های کنونی به &lt;strong>محدودیت‌های پروفایلر حافظه&lt;/strong> مراجعه کنید.&lt;/li>
&lt;/ul>
&lt;p>اگر به یک قطعه کد سریع نیاز دارید که بتوانید آن را به تابع &lt;code>main()&lt;/code> خود اضافه کنید، می‌توانید از کد زیر استفاده کنید:&lt;/p>
&lt;pre>&lt;code class="language-go">file, _ := os.Create(&amp;quot;./mem.pprof&amp;quot;)
defer pprof.Lookup(&amp;quot;allocs&amp;quot;).WriteTo(file, 0)
defer runtime.GC()
&lt;/code>&lt;/pre>
&lt;p>صرف نظر از اینکه چگونه پروفایلر حافظه را فعال کنید، پروفایل حاصل اساساً یک جدول از ردیابی‌های پشته است که به فرمت باینری pprof فرمت‌بندی شده است. نسخه‌ای ساده‌شده از چنین جدولی در زیر نشان داده شده است:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>stack trace&lt;/th>
&lt;th>alloc_objects/count&lt;/th>
&lt;th>alloc_space/bytes&lt;/th>
&lt;th>inuse_objects/count&lt;/th>
&lt;th>inuse_space/bytes&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>main;foo&lt;/td>
&lt;td>5&lt;/td>
&lt;td>120&lt;/td>
&lt;td>2&lt;/td>
&lt;td>48&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>main;foo;bar&lt;/td>
&lt;td>3&lt;/td>
&lt;td>768&lt;/td>
&lt;td>0&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>main;foobar&lt;/td>
&lt;td>4&lt;/td>
&lt;td>512&lt;/td>
&lt;td>1&lt;/td>
&lt;td>128&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>یک پروفایل حافظه شامل دو بخش اصلی اطلاعات است:&lt;/p>
&lt;ul>
&lt;li>&lt;code>alloc_*&lt;/code>: مقدار تخصیص‌هایی که برنامه شما از زمان شروع فرایند (یا دوره پروفایل‌گیری برای پروفایل‌های دلتا) انجام داده است.&lt;/li>
&lt;li>&lt;code>inuse_*&lt;/code>: مقدار تخصیص‌هایی که برنامه شما انجام داده و در آخرین جمع‌آوری زباله (GC) همچنان قابل دسترسی بودند.&lt;/li>
&lt;/ul>
&lt;p>شما می‌توانید از این اطلاعات برای مقاصد مختلف استفاده کنید. به عنوان مثال، می‌توانید از داده‌های &lt;code>alloc_*&lt;/code> برای تعیین اینکه کدام مسیرهای کد ممکن است زباله زیادی تولید کنند که GC باید با آن برخورد کند، استفاده کنید. همچنین بررسی داده‌های &lt;code>inuse_*&lt;/code> در طول زمان می‌تواند به شما در بررسی نشت حافظه یا استفاده بالای حافظه توسط برنامه‌تان کمک کند.&lt;/p>
&lt;h4 id="425221-تفاوت-پروفایلهای-allocations-و-heap">
4.25.2.2.1 تفاوت پروفایل‌های Allocations و Heap
&lt;a class="anchor" href="#425221-%d8%aa%d9%81%d8%a7%d9%88%d8%aa-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d9%87%d8%a7%db%8c-allocations-%d9%88-heap">#&lt;/a>
&lt;/h4>
&lt;p>تابع &lt;code>pprof.Lookup()&lt;/code> و همچنین بسته &lt;code>[net/http/pprof](https://pkg.go.dev/net/http/pprof)&lt;/code> پروفایل حافظه را تحت دو نام مختلف عرضه می‌کنند: &lt;code>allocs&lt;/code> و &lt;code>heap&lt;/code>. هر دو پروفایل شامل داده‌های یکسانی هستند، تنها تفاوت این است که پروفایل &lt;code>allocs&lt;/code> به عنوان نوع نمونه پیش‌فرض &lt;code>alloc_space/bytes&lt;/code> را دارد، در حالی که پروفایل &lt;code>heap&lt;/code> به طور پیش‌فرض &lt;code>inuse_space/bytes&lt;/code> را انتخاب می‌کند. این موضوع توسط ابزار &lt;code>pprof&lt;/code> برای تصمیم‌گیری درباره نوع نمونه‌ای که باید به طور پیش‌فرض نشان داده شود، استفاده می‌شود.&lt;/p>
&lt;h4 id="425222-نمونهبرداری-sampling-پروفایل-حافظه">
4.25.2.2.2 نمونه‌برداری (Sampling) پروفایل حافظه
&lt;a class="anchor" href="#425222-%d9%86%d9%85%d9%88%d9%86%d9%87%d8%a8%d8%b1%d8%af%d8%a7%d8%b1%db%8c-sampling-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84-%d8%ad%d8%a7%d9%81%d8%b8%d9%87">#&lt;/a>
&lt;/h4>
&lt;p>برای حفظ بار کم، پروفایل حافظه از نمونه‌برداری پواسون استفاده می‌کند تا به طور متوسط فقط یک تخصیص از هر 512KiB باعث شود که یک ردیابی پشته گرفته شده و به پروفایل اضافه شود. با این حال، قبل از اینکه پروفایل به فایل نهایی &lt;code>pprof&lt;/code> نوشته شود، زمان‌اجرا مقادیر نمونه جمع‌آوری شده را با تقسیم بر احتمال نمونه‌برداری مقیاس می‌دهد. این بدان معناست که مقدار تخصیص‌های گزارش شده باید تخمینی خوب از مقدار واقعی تخصیص‌ها باشد، صرف‌نظر از نرخ &lt;code>runtime.MemProfileRate&lt;/code> که استفاده می‌کنید.&lt;/p>
&lt;p>برای پروفایل‌گیری در محیط تولید، معمولاً نیازی به تغییر نرخ نمونه‌برداری نیست. تنها دلیلی که برای این کار وجود دارد، نگرانی درباره این است که در شرایطی که تخصیص‌های بسیار کمی انجام می‌شود، ممکن است تعداد کافی نمونه‌ها جمع‌آوری نشود.&lt;/p>
&lt;h4 id="425223-memory-inuse-در-مقابل-rss">
4.25.2.2.3 Memory Inuse در مقابل RSS
&lt;a class="anchor" href="#425223-memory-inuse-%d8%af%d8%b1-%d9%85%d9%82%d8%a7%d8%a8%d9%84-rss">#&lt;/a>
&lt;/h4>
&lt;p>یک اشتباه رایج این است که مقدار کل حافظه گزارش‌شده توسط نوع نمونه &lt;code>inuse_space/bytes&lt;/code> را با مقدار استفاده از حافظه &lt;a href="https://en.wikipedia.org/wiki/Resident_set_size">RSS&lt;/a> که توسط سیستم‌عامل گزارش می‌شود مقایسه کنید و متوجه شوید که این دو با هم مطابقت ندارند. دلایل مختلفی برای این عدم تطابق وجود دارد:&lt;/p>
&lt;ul>
&lt;li>به‌طور تعریف شده، RSS شامل مواردی بیشتر از فقط استفاده از حافظه پشته Go است، مانند حافظه استفاده شده توسط پشته‌های گوروتین‌ها، فایل اجرایی برنامه، کتابخانه‌های مشترک و همچنین حافظه تخصیص یافته توسط توابع C.&lt;/li>
&lt;li>GC (جمع‌کننده زباله) ممکن است تصمیم بگیرد که حافظه آزاد را فوراً به سیستم‌عامل بازنگرداند، اما بعد از تغییرات زمان‌اجرا در &lt;a href="https://golang.org/doc/go1.16#runtime">Go 1.16&lt;/a> این موضوع کمتر مشکل‌ساز شده است.&lt;/li>
&lt;li>Go از GC غیرمتحرک استفاده می‌کند، بنابراین در برخی موارد، حافظه آزاد پشته ممکن است به گونه‌ای تکه‌تکه شود که مانع از بازگشت آن به سیستم‌عامل شود.&lt;/li>
&lt;/ul>
&lt;h4 id="425224-پیادهسازی-پروفایلر-حافظه">
4.25.2.2.4 پیاده‌سازی پروفایلر حافظه
&lt;a class="anchor" href="#425224-%d9%be%db%8c%d8%a7%d8%af%d9%87%d8%b3%d8%a7%d8%b2%db%8c-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-%d8%ad%d8%a7%d9%81%d8%b8%d9%87">#&lt;/a>
&lt;/h4>
&lt;p>کد زیر باید جنبه‌های اساسی پیاده‌سازی پروفایلر حافظه را پوشش دهد تا شما درک بهتری از آن داشته باشید. همانطور که مشاهده می‌کنید، تابع &lt;code>malloc()&lt;/code> در داخل زمان‌اجرای Go از تابع &lt;code>poisson_sample(size)&lt;/code> برای تعیین این که آیا باید یک تخصیص نمونه‌گیری شود یا خیر استفاده می‌کند. اگر جواب مثبت باشد، یک دنباله پشته (stack trace) به نام &lt;code>s&lt;/code> گرفته می‌شود و به عنوان کلید در &lt;code>mem_profile&lt;/code> (یک نقشه هش) استفاده می‌شود تا شمارنده‌های &lt;code>allocs&lt;/code> و &lt;code>alloc_bytes&lt;/code> افزایش یابند. علاوه بر این، فراخوانی &lt;code>track_profiled(object, s)&lt;/code>، شیء تخصیص یافته را به عنوان یک تخصیص نمونه‌گیری شده در پشته علامت‌گذاری می‌کند و دنباله پشته &lt;code>s&lt;/code> را با آن مرتبط می‌سازد.&lt;/p>
&lt;pre>&lt;code class="language-go">func malloc(size):
object = ... // allocation magic
if poisson_sample(size):
s = stacktrace()
mem_profile[s].allocs++
mem_profile[s].alloc_bytes += size
track_profiled(object, s)
return object
&lt;/code>&lt;/pre>
&lt;p>هنگامی که GC (جمع‌آوری زباله‌ها) تعیین می‌کند که زمان آزادسازی یک شیء تخصیص یافته فرا رسیده است، تابع &lt;code>sweep()&lt;/code> را فراخوانی می‌کند که از &lt;code>is_profiled(object)&lt;/code> استفاده می‌کند تا بررسی کند آیا شیء به عنوان یک شیء نمونه‌گیری شده علامت‌گذاری شده است یا خیر. اگر جواب مثبت باشد، دنباله پشته &lt;code>s&lt;/code> که منجر به تخصیص شده بود بازیابی می‌شود و شمارنده‌های &lt;code>frees&lt;/code> و &lt;code>free_bytes&lt;/code> برای آن داخل &lt;code>mem_profile&lt;/code> افزایش می‌یابد.&lt;/p>
&lt;pre>&lt;code class="language-go">func sweep(object):
if is_profiled(object)
s = alloc_stacktrace(object)
mem_profile[s].frees++
mem_profile[s].free_bytes += sizeof(object)
// deallocation magic
&lt;/code>&lt;/pre>
&lt;p>شمارنده‌های &lt;code>free_*&lt;/code> به‌طور مستقیم در پروفایل نهایی حافظه گنجانده نمی‌شوند. در عوض، از آن‌ها برای محاسبه شمارنده‌های &lt;code>inuse_*&lt;/code> در پروفایل از طریق کم کردن ساده‌ی &lt;code>frees&lt;/code> از &lt;code>allocs&lt;/code> استفاده می‌شود. همچنین، مقادیر خروجی نهایی با تقسیم آن‌ها بر احتمال نمونه‌گیری مقیاس‌بندی می‌شوند.&lt;/p>
&lt;h4 id="425225-محدودیتهای-پروفایلر-حافظه">
4.25.2.2.5 محدودیت‌های پروفایلر حافظه
&lt;a class="anchor" href="#425225-%d9%85%d8%ad%d8%af%d9%88%d8%af%db%8c%d8%aa%d9%87%d8%a7%db%8c-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-%d8%ad%d8%a7%d9%81%d8%b8%d9%87">#&lt;/a>
&lt;/h4>
&lt;p>چندین مشکل و محدودیت شناخته‌شده برای پروفایلر حافظه وجود دارد که باید از آن‌ها آگاه باشید:&lt;/p>
&lt;ul>
&lt;li>🐞 &lt;a href="https://github.com/golang/go/issues/49171">GH #49171&lt;/a>: پروفایل‌های دلتا (که با مثلاً &lt;code>GET /debug/pprof/allocs?seconds=60&lt;/code> گرفته می‌شوند) ممکن است به دلیل یک باگ در هم‌نمادسازی مرتبط با closures داخلی در Go 1.17 شمارش تخصیص منفی را گزارش کنند. این مشکل در Go 1.18 رفع شده است.&lt;/li>
&lt;li>⚠️ &lt;a href="https://pkg.go.dev/runtime#MemProfileRate">&lt;code>runtime.MemProfileRate&lt;/code>&lt;/a> باید فقط یک بار و در اسرع وقت در ابتدای اجرای برنامه تغییر داده شود؛ برای مثال در ابتدای تابع &lt;code>main()&lt;/code>. تغییر این مقدار به‌صورت چندباره در طول اجرای برنامه باعث تولید پروفایل‌های نادرست خواهد شد.&lt;/li>
&lt;li>⚠ هنگام عیب‌یابی نشتی‌های حافظه احتمالی، پروفایلر حافظه می‌تواند نشان دهد که این تخصیص‌ها کجا ایجاد شده‌اند، اما نمی‌تواند نشان دهد که کدام مراجع باعث زنده نگه‌داشتن آن‌ها هستند. چندین تلاش برای حل این مشکل انجام شده است، اما هیچ‌کدام با نسخه‌های اخیر Go کار نمی‌کنند.&lt;/li>
&lt;li>⚠ &lt;a href="#425211-%d8%a8%d8%b1%da%86%d8%b3%d8%a8%d9%87%d8%a7%db%8c-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-profiler-labels-cpu">برچسب‌های پروفایلر CPU&lt;/a> یا مشابه آن توسط پروفایلر حافظه پشتیبانی نمی‌شوند. اضافه کردن این ویژگی به پیاده‌سازی فعلی سخت است زیرا می‌تواند منجر به نشتی حافظه در جدول هش داخلی داده‌های پروفایل حافظه شود.&lt;/li>
&lt;li>⚠ تخصیص‌های انجام شده توسط کد C (cgo) در پروفایل حافظه نمایش داده نمی‌شوند.&lt;/li>
&lt;li>⚠ داده‌های پروفایل حافظه ممکن است تا دو چرخه‌ی جمع‌آوری زباله قدیمی باشند. اگر نیاز به یک عکس فوری مداوم دارید، می‌توانید قبل از درخواست پروفایل حافظه، &lt;code>runtime.GC()&lt;/code> را فراخوانی کنید. &lt;a href="https://pkg.go.dev/net/http/pprof">net/http/pprof&lt;/a> از آرگومان &lt;code>?gc=1&lt;/code> برای این منظور پشتیبانی می‌کند.&lt;/li>
&lt;li>⚠ حداکثر تعداد توابع تو در تو که توسط پروفایلر حافظه در اثر فراخوانی ثبت می‌شوند، در حال حاضر &lt;a href="https://sourcegraph.com/search?q=context:global&amp;#43;repo:github.com/golang/go&amp;#43;file:src/*&amp;#43;maxStack&amp;#43;%3D&amp;amp;patternType=literal">&lt;code>32&lt;/code>&lt;/a> است. برای اطلاعات بیشتر در مورد این محدودیت، به &lt;a href="#425214-%d9%85%d8%ad%d8%af%d9%88%d8%af%db%8c%d8%aa%d9%87%d8%a7%db%8c-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-cpu">محدودیت‌های پروفایلر CPU&lt;/a> مراجعه کنید.&lt;/li>
&lt;li>⚠ هیچ محدودیتی برای اندازه‌ی جدول هش داخلی که پروفایل حافظه را نگه‌ می‌دارد وجود ندارد. این جدول تا زمانی که تمام مسیرهای تخصیص کد شما را پوشش دهد، بزرگ می‌شود. این مسئله در عمل مشکل‌ساز نیست اما ممکن است به‌نظر برسد که مانند یک نشتی حافظه کوچک است اگر از میزان استفاده حافظه فرآیند خود نظارت کنید.&lt;/li>
&lt;/ul>
&lt;h3 id="42523-پروفایلر-بلاک">
4.25.2.3 پروفایلر بلاک
&lt;a class="anchor" href="#42523-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-%d8%a8%d9%84%d8%a7%da%a9">#&lt;/a>
&lt;/h3>
&lt;p>پروفایلر بلاک در Go اندازه‌گیری می‌کند که چقدر زمان گوروتین‌های شما در حالت Off-CPU صرف می‌شود، در حالی که منتظر عملیات کانال و mutexهای ارائه‌شده توسط پکیج &lt;a href="https://pkg.go.dev/sync">sync&lt;/a> هستند. عملیات‌های Go زیر توسط پروفایلر بلاک کنترل می‌شوند:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/golang/go/blob/go1.15.7/src/runtime/select.go#L511">select&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/golang/go/blob/go1.15.7/src/runtime/chan.go#L279">chan send&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/golang/go/blob/go1.15.7/src/runtime/chan.go#L586">chan receive&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/golang/go/blob/go1.15.7/src/runtime/sema.go#L150">semacquire&lt;/a> (مثل &lt;a href="https://golang.org/pkg/sync/#Mutex.Lock">&lt;code>Mutex.Lock&lt;/code>&lt;/a>، &lt;a href="https://golang.org/pkg/sync/#RWMutex.RLock">&lt;code>RWMutex.RLock&lt;/code>&lt;/a>، &lt;a href="https://golang.org/pkg/sync/#RWMutex.Lock">&lt;code>RWMutex.Lock&lt;/code>&lt;/a>، &lt;a href="https://golang.org/pkg/sync/#WaitGroup.Wait">&lt;code>WaitGroup.Wait&lt;/code>&lt;/a>)&lt;/li>
&lt;li>&lt;a href="https://github.com/golang/go/blob/go1.15.7/src/runtime/sema.go#L515">notifyListWait&lt;/a> (مثل &lt;a href="https://golang.org/pkg/sync/#Cond.Wait">&lt;code>Cond.Wait&lt;/code>&lt;/a>)&lt;/li>
&lt;/ul>
&lt;p>⚠️ پروفایل‌های بلاک شامل زمان انتظار روی I/O، خواب (Sleep)، GC و سایر حالات انتظار نیستند. همچنین رویدادهای مسدود کننده تا زمانی که کامل نشوند ثبت نمی‌شوند، بنابراین پروفایل بلاک نمی‌تواند برای اشکال‌زدایی از اینکه چرا یک برنامه Go در حال حاضر قفل کرده استفاده شود. برای این منظور، از پروفایلر گوروتین می‌توان استفاده کرد.&lt;/p>
&lt;h4 id="425231-کنترل-پروفایلر-بلاک-با-apiهای-مختلف">
4.25.2.3.1 کنترل پروفایلر بلاک با API‌های مختلف:
&lt;a class="anchor" href="#425231-%da%a9%d9%86%d8%aa%d8%b1%d9%84-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-%d8%a8%d9%84%d8%a7%da%a9-%d8%a8%d8%a7-api%d9%87%d8%a7%db%8c-%d9%85%d8%ae%d8%aa%d9%84%d9%81">#&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>دستور &lt;code>go test -blockprofile block.pprof&lt;/code> تست‌ها را اجرا کرده و پروفایلی از هر رویداد مسدودکننده در فایلی به نام &lt;code>block.pprof&lt;/code> ذخیره می‌کند.&lt;/li>
&lt;li>تابع &lt;a href="https://pkg.go.dev/runtime#SetBlockProfileRate">&lt;code>runtime.SetBlockProfileRate(rate)&lt;/code>&lt;/a> به شما اجازه می‌دهد نرخ نمونه‌گیری پروفایلر بلاک را کنترل کنید.&lt;/li>
&lt;li>دستور &lt;a href="https://pkg.go.dev/runtime/pprof#Lookup">&lt;code>pprof.Lookup(&amp;quot;block&amp;quot;).WriteTo(w, 0)&lt;/code>&lt;/a> پروفایلی از رویدادهای مسدودکننده از ابتدای فرآیند تا کنون ایجاد می‌کند و در خروجی &lt;code>w&lt;/code> می‌نویسد.&lt;/li>
&lt;li>دستور &lt;a href="https://pkg.go.dev/net/http/pprof">&lt;code>import _ &amp;quot;net/http/pprof&amp;quot;&lt;/code>&lt;/a> اجازه می‌دهد تا با استفاده از درخواست &lt;code>GET /debug/pprof/block?seconds=30&lt;/code> یک پروفایل بلاک 30 ثانیه‌ای درخواست کنید.&lt;/li>
&lt;/ul>
&lt;h4 id="425232-کد-نمونه-برای-استفاده-از-پروفایلر-بلاک-در-برنامه">
4.25.2.3.2 کد نمونه برای استفاده از پروفایلر بلاک در برنامه:
&lt;a class="anchor" href="#425232-%da%a9%d8%af-%d9%86%d9%85%d9%88%d9%86%d9%87-%d8%a8%d8%b1%d8%a7%db%8c-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-%d8%a8%d9%84%d8%a7%da%a9-%d8%af%d8%b1-%d8%a8%d8%b1%d9%86%d8%a7%d9%85%d9%87">#&lt;/a>
&lt;/h4>
&lt;pre>&lt;code class="language-go">runtime.SetBlockProfileRate(100_000_000) // هشدار: می‌تواند باعث افزایش استفاده از CPU شود
file, _ := os.Create(&amp;quot;./block.pprof&amp;quot;)
defer pprof.Lookup(&amp;quot;block&amp;quot;).WriteTo(file, 0)
&lt;/code>&lt;/pre>
&lt;p>صرف‌نظر از نحوه فعال کردن پروفایلر بلاک، پروفایل نهایی یک جدول از ردپاهای پشته خواهد بود که در فرمت باینری &lt;strong>pprof&lt;/strong> فرمت شده است.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>stack trace&lt;/th>
&lt;th>contentions/count&lt;/th>
&lt;th>delay/nanoseconds&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>main;foo;runtime.selectgo&lt;/td>
&lt;td>5&lt;/td>
&lt;td>867549417&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>main;foo;bar;sync.(*Mutex).Lock&lt;/td>
&lt;td>3&lt;/td>
&lt;td>453510869&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>main;foobar;runtime.chanrecv1&lt;/td>
&lt;td>4&lt;/td>
&lt;td>5351086&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="425233-پیادهسازی-پروفایلر-بلاک">
4.25.2.3.3 پیاده‌سازی پروفایلر بلاک
&lt;a class="anchor" href="#425233-%d9%be%db%8c%d8%a7%d8%af%d9%87%d8%b3%d8%a7%d8%b2%db%8c-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-%d8%a8%d9%84%d8%a7%da%a9">#&lt;/a>
&lt;/h4>
&lt;p>کد شبه زیر جنبه‌های اساسی از پیاده‌سازی پروفایلر بلاک را نشان می‌دهد تا درک بهتری از آن به شما بدهد. هنگام ارسال پیام به یک کانال، یعنی &lt;code>ch &amp;lt;- msg&lt;/code>، Go تابع &lt;code>chansend()&lt;/code> را در runtime فراخوانی می‌کند. اگر کانال برای دریافت پیام آماده باشد (&lt;code>ready()&lt;/code>)، عملیات &lt;code>send()&lt;/code> بلافاصله انجام می‌شود. در غیر این صورت، پروفایلر بلاک زمان شروع رویداد مسدودکننده را ثبت می‌کند و از تابع &lt;code>wait_until_ready()&lt;/code> استفاده می‌کند تا گوروتین از CPU خارج شود تا زمانی که کانال آماده شود. هنگامی که کانال آماده شد، مدت زمان مسدود شدن تعیین می‌شود و با استفاده از تابع &lt;code>random_sample()&lt;/code> و نرخ نمونه‌گیری، بررسی می‌شود که آیا باید این رویداد مسدودکننده ثبت شود یا خیر. در صورت مثبت بودن پاسخ، ردپای پشته فعلی (&lt;code>stack trace&lt;/code>) گرفته شده و به عنوان کلید درون نقشه هش &lt;code>block_profile&lt;/code> استفاده می‌شود تا شمارنده‌های &lt;code>count&lt;/code> و &lt;code>delay&lt;/code> افزایش یابند. پس از آن، عملیات &lt;code>send()&lt;/code> ادامه می‌یابد.&lt;/p>
&lt;pre>&lt;code class="language-go">func chansend(channel, msg):
if ready(channel):
send(channel, msg)
return
start = now()
wait_until_ready(channel) // Off-CPU Wait
duration = now() - start
if random_sample(duration, rate):
s = stacktrace()
// note: actual implementation is a bit trickier to correct for bias
block_profile[s].contentions += 1
block_profile[s].delay += duration
send(channel, msg)
&lt;/code>&lt;/pre>
&lt;p>تابع &lt;code>random_sample&lt;/code> به این صورت عمل می‌کند. اگر پروفایلر بلاک فعال باشد، همه رویدادهایی که &lt;code>duration &amp;gt;= rate&lt;/code> باشند ثبت می‌شوند و رویدادهای کوتاه‌تر با احتمال &lt;code>duration/rate&lt;/code> ثبت می‌شوند.&lt;/p>
&lt;pre>&lt;code class="language-go">func random_sample(duration, rate):
if rate &amp;lt;= 0 || (duration &amp;lt; rate &amp;amp;&amp;amp; duration/rate &amp;gt; rand(0, 1)):
return false
return true
&lt;/code>&lt;/pre>
&lt;p>به عبارت دیگر، اگر نرخ (&lt;code>rate&lt;/code>) را برابر &lt;code>10,000&lt;/code> تنظیم کنید (واحد در اینجا نانوثانیه است)، همه رویدادهای مسدودکننده‌ای که &lt;code>10 µsec&lt;/code> یا بیشتر طول می‌کشند ثبت می‌شوند. علاوه بر این، &lt;code>10%&lt;/code> از رویدادهای با طول &lt;code>1 µsec&lt;/code> و &lt;code>1%&lt;/code> از رویدادهای با طول &lt;code>100 نانوثانیه&lt;/code> و&amp;hellip; نیز ثبت می‌شوند.&lt;/p>
&lt;h4 id="425234-تفاوت-پروفایلر-بلاک-و-پروفایلر-mutex">
4.25.2.3.4 تفاوت پروفایلر بلاک و پروفایلر Mutex
&lt;a class="anchor" href="#425234-%d8%aa%d9%81%d8%a7%d9%88%d8%aa-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-%d8%a8%d9%84%d8%a7%da%a9-%d9%88-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-mutex">#&lt;/a>
&lt;/h4>
&lt;p>هر دو پروفایلر بلاک و mutex زمان انتظار روی mutexها را گزارش می‌دهند. تفاوت این است که پروفایلر بلاک زمان انتظار برای به دست آوردن &lt;code>Lock()&lt;/code> را ثبت می‌کند، در حالی که پروفایلر mutex زمانی که گوروتین دیگری منتظر &lt;code>Unlock()&lt;/code> است تا اجرا شود را ثبت می‌کند.&lt;/p>
&lt;h4 id="425235-محدودیتهای-پروفایلر-بلاک">
4.25.2.3.5 محدودیت‌های پروفایلر بلاک
&lt;a class="anchor" href="#425235-%d9%85%d8%ad%d8%af%d9%88%d8%af%db%8c%d8%aa%d9%87%d8%a7%db%8c-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-%d8%a8%d9%84%d8%a7%da%a9">#&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>🚨 پروفایلر بلاک می‌تواند باعث افزایش قابل توجه مصرف CPU در محیط تولید شود. توصیه می‌شود که تنها برای توسعه و تست استفاده شود. اگر نیاز به استفاده از آن در محیط تولید دارید، با نرخ بسیار بالا شروع کنید، مثلاً 100 میلیون، و تنها در صورت نیاز آن را کاهش دهید.&lt;/li>
&lt;li>⚠ پروفایل‌های بلاک تنها شامل زیر مجموعه کوچکی از حالات انتظار Off-CPU هستند که یک گوروتین می‌تواند وارد آن‌ها شود.&lt;/li>
&lt;li>⚠ حداکثر تعداد توابع تو در تو که می‌توانند در ردپاهای پشته توسط پروفایلر بلاک ثبت شوند، فعلاً برابر &lt;a href="https://sourcegraph.com/search?q=context:global&amp;#43;repo:github.com/golang/go&amp;#43;file:src/*&amp;#43;maxStack&amp;#43;%3D&amp;amp;patternType=literal">&lt;code>32&lt;/code>&lt;/a> است.&lt;/li>
&lt;li>⚠ نقشه هش داخلی که پروفایل بلاک را نگه می‌دارد هیچ محدودیتی در اندازه ندارد.&lt;/li>
&lt;/ul>
&lt;h3 id="42524-پروفایلر-mutex">
4.25.2.4 پروفایلر Mutex
&lt;a class="anchor" href="#42524-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-mutex">#&lt;/a>
&lt;/h3>
&lt;p>پروفایلر mutex زمانی را اندازه‌گیری می‌کند که گوروتین‌ها صرف مسدود کردن سایر گوروتین‌ها می‌کنند. به عبارتی، این پروفایلر منابع رقابت برای قفل‌ها را ثبت می‌کند. پروفایلر mutex می‌تواند رقابت ناشی از &lt;code>sync.Mutex&lt;/code> و &lt;code>sync.RWMutex&lt;/code> را ثبت کند.&lt;/p>
&lt;p>⚠️ پروفایل‌های mutex شامل سایر منابع رقابت مثل &lt;code>sync.WaitGroup&lt;/code>، &lt;code>sync.Cond&lt;/code> یا دسترسی به توصیف‌کننده‌های فایل نمی‌شوند. همچنین، رقابت mutex تا زمانی که mutex آزاد نشود، ثبت نمی‌شود. بنابراین، پروفایل mutex برای اشکال‌زدایی از دلیل معلق بودن برنامه Go قابل استفاده نیست؛ برای این کار می‌توانید از پروفایلر گوروتین استفاده کنید.&lt;/p>
&lt;h4 id="425241-کنترل-پروفایلر-mutex">
4.25.2.4.1 کنترل پروفایلر Mutex
&lt;a class="anchor" href="#425241-%da%a9%d9%86%d8%aa%d8%b1%d9%84-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-mutex">#&lt;/a>
&lt;/h4>
&lt;p>چندین API برای کنترل پروفایلر mutex در دسترس است:&lt;/p>
&lt;ul>
&lt;li>&lt;code>go test -mutexprofile mutex.pprof&lt;/code> تست‌ها را اجرا می‌کند و پروفایل mutex را در یک فایل با نام &lt;code>mutex.pprof&lt;/code> می‌نویسد.&lt;/li>
&lt;li>&lt;a href="https://pkg.go.dev/runtime#SetMutexProfileRate">&lt;code>runtime.SetMutexProfileRate(rate)&lt;/code>&lt;/a> به شما امکان می‌دهد نرخ نمونه‌گیری پروفایلر mutex را فعال و کنترل کنید. اگر نرخ نمونه‌گیری برابر با &lt;code>R&lt;/code> تنظیم شود، به طور متوسط &lt;code>1/R&lt;/code> از رویدادهای رقابت mutex ثبت می‌شوند. اگر نرخ برابر 0 یا کمتر باشد، هیچ رویدادی ثبت نمی‌شود.&lt;/li>
&lt;li>&lt;a href="https://pkg.go.dev/runtime/pprof#Lookup">&lt;code>pprof.Lookup(&amp;quot;mutex&amp;quot;).WriteTo(w, 0)&lt;/code>&lt;/a> پروفایل mutex را از شروع پردازش تا زمان نوشتن به &lt;code>w&lt;/code> ثبت می‌کند.&lt;/li>
&lt;li>&lt;a href="https://pkg.go.dev/net/http/pprof">&lt;code>import _ &amp;quot;net/http/pprof&amp;quot;&lt;/code>&lt;/a> به شما امکان می‌دهد با ارسال درخواست به مسیر &lt;code>GET /debug/pprof/mutex?seconds=30&lt;/code> یک پروفایل 30 ثانیه‌ای از mutex‌ها دریافت کنید.&lt;/li>
&lt;/ul>
&lt;h4 id="425242-نمونه-سریع-استفاده-از-پروفایلر-mutex">
4.25.2.4.2 نمونه سریع استفاده از پروفایلر Mutex
&lt;a class="anchor" href="#425242-%d9%86%d9%85%d9%88%d9%86%d9%87-%d8%b3%d8%b1%db%8c%d8%b9-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-mutex">#&lt;/a>
&lt;/h4>
&lt;p>اگر نیاز به کد سریع برای قرار دادن در تابع &lt;code>main()&lt;/code> دارید، می‌توانید از کد زیر استفاده کنید:&lt;/p>
&lt;pre>&lt;code class="language-go">runtime.SetMutexProfileFraction(100)
file, _ := os.Create(&amp;quot;./mutex.pprof&amp;quot;)
defer pprof.Lookup(&amp;quot;mutex&amp;quot;).WriteTo(file, 0)
&lt;/code>&lt;/pre>
&lt;p>پروفایل mutex به دست آمده در اصل جدولی از ردپای پشته‌ها (&lt;code>stack traces&lt;/code>) خواهد بود که به صورت فرمت دودویی pprof ذخیره می‌شود.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>stack trace&lt;/th>
&lt;th>contentions/count&lt;/th>
&lt;th>delay/nanoseconds&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>main;foo;sync.(*Mutex).Unlock&lt;/td>
&lt;td>5&lt;/td>
&lt;td>867549417&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>main;bar;baz;sync.(*Mutex).Unlock&lt;/td>
&lt;td>3&lt;/td>
&lt;td>453510869&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>main;foobar;sync.(*RWMutex).RUnlock&lt;/td>
&lt;td>4&lt;/td>
&lt;td>5351086&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="425243-تفاوت-پروفایلهای-block-و-mutex">
4.25.2.4.3 تفاوت پروفایل‌های Block و Mutex
&lt;a class="anchor" href="#425243-%d8%aa%d9%81%d8%a7%d9%88%d8%aa-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d9%87%d8%a7%db%8c-block-%d9%88-mutex">#&lt;/a>
&lt;/h4>
&lt;p>پروفایل‌های block و mutex هر دو زمان انتظار روی mutex‌ها را ثبت می‌کنند، اما تفاوت در این است که پروفایل block زمانی که گوروتین در حال انتظار برای قفل شدن است را ثبت می‌کند، در حالی که پروفایل mutex زمانی که یک گوروتین قفل را در اختیار دارد و باعث جلوگیری از ادامه کار سایر گوروتین‌ها می‌شود، را ثبت می‌کند.&lt;/p>
&lt;h4 id="425244-پیادهسازی-پروفایلر-mutex">
4.25.2.4.4 پیاده‌سازی پروفایلر Mutex
&lt;a class="anchor" href="#425244-%d9%be%db%8c%d8%a7%d8%af%d9%87%d8%b3%d8%a7%d8%b2%db%8c-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-mutex">#&lt;/a>
&lt;/h4>
&lt;p>پروفایلر mutex با ثبت زمانی که یک گوروتین تلاش می‌کند قفلی را بگیرد (مثلاً &lt;code>mu.Lock()&lt;/code>)، تا زمانی که گوروتین صاحب قفل آن را آزاد کند (مثلاً &lt;code>mu.Unlock()&lt;/code>)، کار می‌کند. ابتدا یک گوروتین &lt;code>semacquire()&lt;/code> را برای گرفتن قفل فراخوانی می‌کند و اگر قفل در حال حاضر توسط گوروتین دیگری گرفته شده باشد، زمان شروع انتظار ثبت می‌شود. وقتی گوروتین صاحب قفل آن را با فراخوانی &lt;code>semrelease()&lt;/code> آزاد می‌کند، گوروتین منتظر بررسی می‌شود و زمان انتظار آن محاسبه می‌گردد. در نهایت، اگر رویداد به صورت تصادفی برای ثبت انتخاب شود، زمان مسدودی به یک نقشه هش (&lt;code>hash map&lt;/code>) اضافه می‌شود که کلید آن پشته فراخوانی گوروتین آزادکننده قفل است.&lt;/p>
&lt;h4 id="425245-محدودیتهای-پروفایلر-mutex">
4.25.2.4.5 محدودیت‌های پروفایلر Mutex
&lt;a class="anchor" href="#425245-%d9%85%d8%ad%d8%af%d9%88%d8%af%db%8c%d8%aa%d9%87%d8%a7%db%8c-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-mutex">#&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>⚠️ حداکثر تعداد فراخوانی‌های تو در تو که می‌توان در پشته فراخوانی‌های پروفایل mutex ثبت کرد، در حال حاضر &lt;a href="https://sourcegraph.com/search?q=context:global&amp;#43;repo:github.com/golang/go&amp;#43;file:src/*&amp;#43;maxStack&amp;#43;%3D&amp;amp;patternType=literal">&lt;code>32&lt;/code>&lt;/a> است. برای اطلاعات بیشتر درباره محدودیت‌های پروفایلر CPU، به مستندات مرتبط مراجعه کنید.&lt;/li>
&lt;li>⚠️ هیچ محدودیتی برای اندازه نقشه هش داخلی که داده‌های پروفایل mutex را نگه می‌دارد وجود ندارد. این بدان معناست که اندازه آن تا زمانی که تمام مسیرهای مسدودکننده در کد شما پوشش داده شوند، رشد خواهد کرد. در عمل، این مشکل چندانی ایجاد نمی‌کند، اما ممکن است به عنوان یک نشت حافظه کوچک به نظر برسد.&lt;/li>
&lt;li>⚠️ برچسب‌های پروفایلر CPU در پروفایل mutex پشتیبانی نمی‌شوند. اضافه کردن این ویژگی به پیاده‌سازی فعلی ممکن است باعث ایجاد نشت حافظه در نقشه هش داخلی که داده‌های پروفایل حافظه را نگه می‌دارد، شود.&lt;/li>
&lt;li>⚠️ تعداد رقابت‌ها و زمان‌های تأخیر در یک پروفایل mutex بر اساس &lt;strong>آخرین&lt;/strong> نرخ نمونه‌برداری تنظیم شده، تنظیم می‌شوند، نه در زمان نمونه‌برداری. در نتیجه، برنامه‌هایی که نرخ نمونه‌برداری پروفایل mutex را در میانه اجرای خود تغییر می‌دهند، ممکن است نتایج نادقیقی را مشاهده کنند.&lt;/li>
&lt;/ul>
&lt;h3 id="42525-پروفایلر-goroutine">
4.25.2.5 پروفایلر Goroutine
&lt;a class="anchor" href="#42525-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-goroutine">#&lt;/a>
&lt;/h3>
&lt;p>در زمان اجرای Go، تمام گوروتین‌ها در یک آرایه ساده به نام &lt;a href="https://github.com/golang/go/blob/3a778ff50f7091b8a64875c8ed95bfaacf3d334c/src/runtime/proc.go#L500">allgs&lt;/a> نگهداری می‌شوند. این آرایه شامل گوروتین‌های فعال و غیرفعال (مرده) است. گوروتین‌های مرده برای استفاده مجدد زمانی که گوروتین‌های جدید ایجاد می‌شوند، نگه داشته می‌شوند.&lt;/p>
&lt;p>Go دارای API‌های مختلفی برای بررسی گوروتین‌های فعال در &lt;code>allgs&lt;/code> است که به همراه استک ترِیس و برخی دیگر از ویژگی‌های آنها اطلاعاتی ارائه می‌دهند. برخی از این API‌ها اطلاعات آماری ارائه می‌دهند، در حالی که برخی دیگر اطلاعات مربوط به هر گوروتین را به صورت جداگانه فراهم می‌کنند.&lt;/p>
&lt;p>علیرغم تفاوت‌های بین این API‌ها، تعریف &lt;a href="https://github.com/golang/go/blob/9b955d2d3fcff6a5bc8bce7bafdc4c634a28e95b/src/runtime/mprof.go#L729">مشترک&lt;/a> از گوروتین &amp;ldquo;فعال&amp;rdquo; به نظر می‌رسد که شامل موارد زیر باشد:&lt;/p>
&lt;ul>
&lt;li>گوروتین &lt;a href="https://github.com/golang/go/blob/go1.15.6/src/runtime/runtime2.go#L65-L71">از بین رفته&lt;/a> نباشد.&lt;/li>
&lt;li>گوروتین &lt;a href="https://github.com/golang/go/blob/9b955d2d3fcff6a5bc8bce7bafdc4c634a28e95b/src/runtime/traceback.go#L1013-L1021">سیستمی&lt;/a> یا گوروتین نهایی‌کننده نباشد.&lt;/li>
&lt;/ul>
&lt;p>به عبارت دیگر، گوروتین‌هایی که در حال اجرا هستند و همچنین آنهایی که منتظر ورودی/خروجی (I/O)، قفل‌ها، کانال‌ها، برنامه‌ریزی و غیره هستند، همه به عنوان &amp;ldquo;فعال&amp;rdquo; در نظر گرفته می‌شوند، حتی اگر به نظر برسد که برخی از این حالت‌ها غیرفعال هستند.&lt;/p>
&lt;h4 id="425251-سربار-overhead">
4.25.2.5.1 سربار (Overhead)
&lt;a class="anchor" href="#425251-%d8%b3%d8%b1%d8%a8%d8%a7%d8%b1-overhead">#&lt;/a>
&lt;/h4>
&lt;p>همه پروفایل‌گیری‌های گوروتین در Go نیاز به یک فاز &lt;strong>متوقف‌سازی جهان (stop-the-world)&lt;/strong> به اندازه &lt;code>O(N)&lt;/code> دارند، که در آن &lt;code>N&lt;/code> تعداد گوروتین‌های تخصیص داده شده است. یک &lt;a href="https://github.com/felixge/fgprof/blob/fe01e87ceec08ea5024e8168f88468af8f818b62/fgprof_test.go#L35-L78">بنچمارک ساده&lt;/a> &lt;a href="https://github.com/felixge/fgprof/blob/master/BenchmarkProfilerGoroutines.txt">نشان می‌دهد&lt;/a> که جهان به طور تقریبی به ازای هر گوروتین حدود ~1µs متوقف می‌شود، وقتی از API &lt;a href="https://golang.org/pkg/runtime/#GoroutineProfile">&lt;code>runtime.GoroutineProfile()&lt;/code>&lt;/a> استفاده می‌شود. اما این مقدار ممکن است بسته به عواملی مانند عمق استک برنامه، تعداد گوروتین‌های مرده و غیره تغییر کند.&lt;/p>
&lt;p>به طور کلی، برنامه‌هایی که بسیار حساس به تأخیر هستند و از هزاران گوروتین فعال استفاده می‌کنند، ممکن است بخواهند در پروفایل‌گیری گوروتین در محیط تولید با دقت بیشتری عمل کنند. با این حال، تعداد زیاد گوروتین‌ها و حتی شاید خود زبان Go ممکن است برای چنین برنامه‌هایی ایده‌ی مناسبی نباشد.&lt;/p>
&lt;p>بیشتر برنامه‌هایی که تعداد زیادی گوروتین ایجاد نمی‌کنند و می‌توانند چند میلی‌ثانیه تأخیر اضافی را تحمل کنند، نباید مشکلی با پروفایل‌گیری مستمر گوروتین در محیط تولید داشته باشند.&lt;/p>
&lt;h4 id="425252-ویژگیهای-گوروتین">
4.25.2.5.2 ویژگی‌های گوروتین
&lt;a class="anchor" href="#425252-%d9%88%db%8c%da%98%da%af%db%8c%d9%87%d8%a7%db%8c-%da%af%d9%88%d8%b1%d9%88%d8%aa%db%8c%d9%86">#&lt;/a>
&lt;/h4>
&lt;p>گوروتین‌ها دارای بسیاری از &lt;a href="https://github.com/golang/go/blob/go1.15.6/src/runtime/runtime2.go#L406-L486">ویژگی‌ها&lt;/a> هستند که می‌توانند به اشکال‌زدایی برنامه‌های Go کمک کنند. موارد زیر جالب توجه هستند و به طرق مختلف از طریق API‌هایی که در ادامه این سند توضیح داده شده‌اند، در دسترس قرار دارند:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/golang/go/blob/go1.15.6/src/runtime/runtime2.go#L428">&lt;code>goid&lt;/code>&lt;/a>: شناسه‌ی یکتای گوروتین؛ گوروتین اصلی دارای شناسه &lt;code>1&lt;/code> است.&lt;/li>
&lt;li>&lt;a href="https://github.com/golang/go/blob/go1.15.6/src/runtime/runtime2.go#L14-L105">&lt;code>atomicstatus&lt;/code>&lt;/a>: وضعیت گوروتین، یکی از موارد زیر:
&lt;ul>
&lt;li>&lt;code>idle&lt;/code>: تازه تخصیص داده شده است.&lt;/li>
&lt;li>&lt;code>runnable&lt;/code>: در صف اجرا، منتظر زمان‌بندی.&lt;/li>
&lt;li>&lt;code>running&lt;/code>: در حال اجرا روی یک نخ (thread) سیستم‌عامل.&lt;/li>
&lt;li>&lt;code>syscall&lt;/code>: مسدود شده در یک فراخوان سیستمی.&lt;/li>
&lt;li>&lt;code>waiting&lt;/code>: توسط زمان‌بندی‌کننده متوقف شده، نگاه کنید به &lt;code>g.waitreason&lt;/code>.&lt;/li>
&lt;li>&lt;code>dead&lt;/code>: تازه خارج شده یا در حال دوباره‌سازی.&lt;/li>
&lt;li>&lt;code>copystack&lt;/code>: استک در حال انتقال است.&lt;/li>
&lt;li>&lt;code>preempted&lt;/code>: تازه از اجرا خودداری کرده است.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://github.com/golang/go/blob/go1.15.6/src/runtime/runtime2.go#L996-L1024">&lt;code>waitreason&lt;/code>&lt;/a>: دلیلی که گوروتین در وضعیت &lt;code>waiting&lt;/code> قرار دارد، مانند خواب، عملیات کانال، I/O، جمع‌آوری زباله (GC) و غیره.&lt;/li>
&lt;li>&lt;a href="https://github.com/golang/go/blob/go1.15.6/src/runtime/runtime2.go#L430">&lt;code>waitsince&lt;/code>&lt;/a>: زمان تقریبی که گوروتین وارد وضعیت &lt;code>waiting&lt;/code> یا &lt;code>syscall&lt;/code> شده است که توسط اولین GC بعد از شروع انتظار تعیین می‌شود.&lt;/li>
&lt;li>&lt;a href="https://github.com/golang/go/blob/go1.15.6/src/runtime/runtime2.go#L472">&lt;code>labels&lt;/code>&lt;/a>: مجموعه‌ای از کلید/مقدار &lt;a href="https://rakyll.org/profiler-labels/">برچسب‌های پروفایل‌گیر&lt;/a> که می‌توانند به گوروتین‌ها متصل شوند.&lt;/li>
&lt;li>&lt;code>stack trace&lt;/code>: تابعی که در حال اجراست و همچنین توابع فراخواننده آن. این به صورت خروجی متنی شامل نام فایل‌ها، نام توابع و شماره خطوط یا به صورت یک آرایه از آدرس‌های شمارنده برنامه (PCs) نمایش داده می‌شود. 🚧تحقیق بیشتر درباره این موضوع: آیا می‌توان متن تابع/فایل/خط را به PCs تبدیل کرد؟&lt;/li>
&lt;li>&lt;a href="https://github.com/golang/go/blob/go1.15.6/src/runtime/runtime2.go#L466">&lt;code>gopc&lt;/code>&lt;/a>: آدرس شمارنده برنامه (PC) مربوط به فراخوانی &lt;code>go ...&lt;/code> که باعث ایجاد این گوروتین شده است. این می‌تواند به فایل، نام تابع و شماره خط تبدیل شود.&lt;/li>
&lt;li>&lt;a href="https://github.com/golang/go/blob/go1.15.6/src/runtime/runtime2.go#L460">&lt;code>lockedm&lt;/code>&lt;/a>: نخی که این گوروتین به آن قفل شده است، در صورتی که وجود داشته باشد.&lt;/li>
&lt;/ul>
&lt;h4 id="425253-ماتریس-ویژگیها-feature-matrix">
4.25.2.5.3 ماتریس ویژگی‌ها (Feature Matrix)
&lt;a class="anchor" href="#425253-%d9%85%d8%a7%d8%aa%d8%b1%db%8c%d8%b3-%d9%88%db%8c%da%98%da%af%db%8c%d9%87%d8%a7-feature-matrix">#&lt;/a>
&lt;/h4>
&lt;p>جدول ماتریس ویژگی‌های زیر به شما یک ایده کلی از دسترسی کنونی این ویژگی‌ها از طریق APIهای مختلف ارائه می‌دهد.&lt;/p>
&lt;center>&lt;a href="#">
&lt;img src="../../assets/img/content/chapter4/profiling/9.png" alt="goroutine matrix">
&lt;/a>&lt;/center>
&lt;h4 id="425254-apiها">
4.25.2.5.4 APIها
&lt;a class="anchor" href="#425254-api%d9%87%d8%a7">#&lt;/a>
&lt;/h4>
&lt;p>&lt;a href="https://golang.org/pkg/runtime/#Stack">&lt;code>runtime.Stack()&lt;/code>&lt;/a> / &lt;a href="https://golang.org/pkg/runtime/pprof/#Lookup">&lt;code>pprof.Lookup(debug=2)&lt;/code>&lt;/a>&lt;/p>
&lt;p>این تابع خروجی متنی بدون ساختار بازمی‌گرداند که شامل استک (Stack) تمام گوروتین‌های فعال و ویژگی‌هایی که در ماتریس ویژگی‌ها ذکر شده است، می‌باشد.&lt;/p>
&lt;p>ویژگی &lt;code>waitsince&lt;/code> به عنوان &lt;code>nanotime() - gp.waitsince()&lt;/code> بر حسب دقیقه نمایش داده می‌شود، اما تنها زمانی که مدت زمان بیش از 1 دقیقه باشد.&lt;/p>
&lt;p>&lt;code>pprof.Lookup(debug=2)&lt;/code> یک نام مستعار ساده‌شده برای استفاده از این پروفایل است. فراخوانی واقعی به این شکل است:&lt;/p>
&lt;pre>&lt;code class="language-go">profile := pprof.Lookup(&amp;quot;goroutine&amp;quot;)
profile.WriteTo(os.Stdout, 2)
&lt;/code>&lt;/pre>
&lt;p>پیاده‌سازی پروفایل به سادگی &lt;code>runtime.Stack()&lt;/code> را فراخوانی می‌کند.&lt;/p>
&lt;p>در زیر مثالی کوتاه از خروجی بازگردانده شده آمده است.&lt;/p>
&lt;pre>&lt;code class="language-shell">goroutine 1 [running]:
main.glob..func1(0x14e5940, 0xc0000aa7b0, 0xc000064eb0, 0x2)
/Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:29 +0x6f
main.writeProfiles(0x2, 0xc0000c4008, 0x1466424)
/Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:106 +0x187
main.main()
/Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:152 +0x3d2
goroutine 22 [sleep, 1 minutes]:
time.Sleep(0x3b9aca00)
/usr/local/Cellar/go/1.15.6/libexec/src/runtime/time.go:188 +0xbf
main.shortSleepLoop()
/Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:165 +0x2a
created by main.indirectShortSleepLoop2
/Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:185 +0x35
goroutine 3 [IO wait, 1 minutes]:
internal/poll.runtime_pollWait(0x1e91e88, 0x72, 0x0)
/usr/local/Cellar/go/1.15.6/libexec/src/runtime/netpoll.go:222 +0x55
internal/poll.(*pollDesc).wait(0xc00019e018, 0x72, 0x0, 0x0, 0x1465786)
/usr/local/Cellar/go/1.15.6/libexec/src/internal/poll/fd_poll_runtime.go:87 +0x45
internal/poll.(*pollDesc).waitRead(...)
/usr/local/Cellar/go/1.15.6/libexec/src/internal/poll/fd_poll_runtime.go:92
internal/poll.(*FD).Accept(0xc00019e000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0)
/usr/local/Cellar/go/1.15.6/libexec/src/internal/poll/fd_unix.go:394 +0x1fc
net.(*netFD).accept(0xc00019e000, 0x7d667d63cbbded3e, 0x1789ccbbded3e, 0x100000001)
/usr/local/Cellar/go/1.15.6/libexec/src/net/fd_unix.go:172 +0x45
net.(*TCPListener).accept(0xc000188060, 0x60006709, 0xc000196da8, 0x109abe6)
/usr/local/Cellar/go/1.15.6/libexec/src/net/tcpsock_posix.go:139 +0x32
net.(*TCPListener).Accept(0xc000188060, 0xc000196df8, 0x18, 0xc000001200, 0x12e9eec)
/usr/local/Cellar/go/1.15.6/libexec/src/net/tcpsock.go:261 +0x65
net/http.(*Server).Serve(0xc00019c000, 0x14ec6e0, 0xc000188060, 0x0, 0x0)
/usr/local/Cellar/go/1.15.6/libexec/src/net/http/server.go:2937 +0x266
net/http.(*Server).ListenAndServe(0xc00019c000, 0xc00019c000, 0x1475536)
/usr/local/Cellar/go/1.15.6/libexec/src/net/http/server.go:2866 +0xb7
net/http.ListenAndServe(...)
/usr/local/Cellar/go/1.15.6/libexec/src/net/http/server.go:3120
main.main.func1(0xc000032120)
/Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:123 +0x126
created by main.main
/Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:121 +0xc5
goroutine 4 [sleep, 1 minutes]:
time.Sleep(0x3b9aca00)
/usr/local/Cellar/go/1.15.6/libexec/src/runtime/time.go:188 +0xbf
main.shortSleepLoop()
/Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:165 +0x2a
created by main.main
/Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:130 +0x195
goroutine 5 [sleep, 1 minutes]:
time.Sleep(0x34630b8a000)
/usr/local/Cellar/go/1.15.6/libexec/src/runtime/time.go:188 +0xbf
main.sleepLoop(0x34630b8a000)
/Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:171 +0x2b
created by main.main
/Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:131 +0x1bc
goroutine 6 [chan receive, 1 minutes]:
main.chanReceiveForever()
/Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:177 +0x4d
created by main.main
/Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:132 +0x1d4
goroutine 24 [select, 1 minutes]:
net/http.(*persistConn).writeLoop(0xc0000cea20)
/usr/local/Cellar/go/1.15.6/libexec/src/net/http/transport.go:2340 +0x11c
created by net/http.(*Transport).dialConn
/usr/local/Cellar/go/1.15.6/libexec/src/net/http/transport.go:1709 +0xcdc
goroutine 23 [IO wait, 1 minutes]:
internal/poll.runtime_pollWait(0x1e91da0, 0x72, 0x14e6ca0)
/usr/local/Cellar/go/1.15.6/libexec/src/runtime/netpoll.go:222 +0x55
internal/poll.(*pollDesc).wait(0xc00010e198, 0x72, 0x14e6c00, 0x16db878, 0x0)
/usr/local/Cellar/go/1.15.6/libexec/src/internal/poll/fd_poll_runtime.go:87 +0x45
internal/poll.(*pollDesc).waitRead(...)
/usr/local/Cellar/go/1.15.6/libexec/src/internal/poll/fd_poll_runtime.go:92
internal/poll.(*FD).Read(0xc00010e180, 0xc000256000, 0x1000, 0x1000, 0x0, 0x0, 0x0)
/usr/local/Cellar/go/1.15.6/libexec/src/internal/poll/fd_unix.go:159 +0x1a5
net.(*netFD).Read(0xc00010e180, 0xc000256000, 0x1000, 0x1000, 0x103b1dc, 0xc000199b58, 0x10680e0)
/usr/local/Cellar/go/1.15.6/libexec/src/net/fd_posix.go:55 +0x4f
net.(*conn).Read(0xc000010008, 0xc000256000, 0x1000, 0x1000, 0x0, 0x0, 0x0)
/usr/local/Cellar/go/1.15.6/libexec/src/net/net.go:182 +0x8e
net/http.(*persistConn).Read(0xc0000cea20, 0xc000256000, 0x1000, 0x1000, 0xc00009e300, 0xc000199c58, 0x10074b5)
/usr/local/Cellar/go/1.15.6/libexec/src/net/http/transport.go:1887 +0x77
bufio.(*Reader).fill(0xc0001801e0)
/usr/local/Cellar/go/1.15.6/libexec/src/bufio/bufio.go:101 +0x105
bufio.(*Reader).Peek(0xc0001801e0, 0x1, 0x0, 0x0, 0x1, 0x0, 0xc0001d0060)
/usr/local/Cellar/go/1.15.6/libexec/src/bufio/bufio.go:139 +0x4f
net/http.(*persistConn).readLoop(0xc0000cea20)
/usr/local/Cellar/go/1.15.6/libexec/src/net/http/transport.go:2040 +0x1a8
created by net/http.(*Transport).dialConn
/usr/local/Cellar/go/1.15.6/libexec/src/net/http/transport.go:1708 +0xcb7
goroutine 41 [IO wait, 1 minutes]:
internal/poll.runtime_pollWait(0x1e91cb8, 0x72, 0x14e6ca0)
/usr/local/Cellar/go/1.15.6/libexec/src/runtime/netpoll.go:222 +0x55
internal/poll.(*pollDesc).wait(0xc00019e098, 0x72, 0x14e6c00, 0x16db878, 0x0)
/usr/local/Cellar/go/1.15.6/libexec/src/internal/poll/fd_poll_runtime.go:87 +0x45
internal/poll.(*pollDesc).waitRead(...)
/usr/local/Cellar/go/1.15.6/libexec/src/internal/poll/fd_poll_runtime.go:92
internal/poll.(*FD).Read(0xc00019e080, 0xc000326000, 0x1000, 0x1000, 0x0, 0x0, 0x0)
/usr/local/Cellar/go/1.15.6/libexec/src/internal/poll/fd_unix.go:159 +0x1a5
net.(*netFD).Read(0xc00019e080, 0xc000326000, 0x1000, 0x1000, 0x203000, 0x203000, 0x203000)
/usr/local/Cellar/go/1.15.6/libexec/src/net/fd_posix.go:55 +0x4f
net.(*conn).Read(0xc000186028, 0xc000326000, 0x1000, 0x1000, 0x0, 0x0, 0x0)
/usr/local/Cellar/go/1.15.6/libexec/src/net/net.go:182 +0x8e
net/http.(*connReader).Read(0xc00007c300, 0xc000326000, 0x1000, 0x1000, 0x100000006, 0x10, 0x1819408)
/usr/local/Cellar/go/1.15.6/libexec/src/net/http/server.go:798 +0x1ad
bufio.(*Reader).fill(0xc000290060)
/usr/local/Cellar/go/1.15.6/libexec/src/bufio/bufio.go:101 +0x105
bufio.(*Reader).ReadSlice(0xc000290060, 0xa, 0x1819408, 0xc000337988, 0x100f6d0, 0xc000110000, 0x100)
/usr/local/Cellar/go/1.15.6/libexec/src/bufio/bufio.go:360 +0x3d
bufio.(*Reader).ReadLine(0xc000290060, 0xc000110000, 0x1079694, 0xc0001a4000, 0x0, 0x1010038, 0x30)
/usr/local/Cellar/go/1.15.6/libexec/src/bufio/bufio.go:389 +0x34
net/textproto.(*Reader).readLineSlice(0xc000182300, 0xc000110000, 0x10d7c4d, 0xc00019e080, 0x1068000, 0xc000282900)
/usr/local/Cellar/go/1.15.6/libexec/src/net/textproto/reader.go:58 +0x6c
net/textproto.(*Reader).ReadLine(...)
/usr/local/Cellar/go/1.15.6/libexec/src/net/textproto/reader.go:39
net/http.readRequest(0xc000290060, 0x0, 0xc000110000, 0x0, 0x0)
/usr/local/Cellar/go/1.15.6/libexec/src/net/http/request.go:1012 +0xaa
net/http.(*conn).readRequest(0xc0000c6320, 0x14ed4a0, 0xc000322000, 0x0, 0x0, 0x0)
/usr/local/Cellar/go/1.15.6/libexec/src/net/http/server.go:984 +0x19a
net/http.(*conn).serve(0xc0000c6320, 0x14ed4a0, 0xc000322000)
/usr/local/Cellar/go/1.15.6/libexec/src/net/http/server.go:1851 +0x705
created by net/http.(*Server).Serve
/usr/local/Cellar/go/1.15.6/libexec/src/net/http/server.go:2969 +0x36c
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>&lt;a href="https://golang.org/pkg/runtime/pprof/#Lookup">&lt;code>pprof.Lookup(debug=1)&lt;/code>&lt;/a>&lt;/strong>&lt;/p>
&lt;p>این روش پروفایل‌گیری مشابه &lt;code>pprof.Lookup(debug=2)&lt;/code> فراخوانی می‌شود، اما داده‌های کاملاً متفاوتی تولید می‌کند:&lt;/p>
&lt;ul>
&lt;li>به جای لیست کردن هر گوروتین به صورت جداگانه، گوروتین‌هایی با استک و برچسب‌های یکسان فقط یک بار همراه با تعداد آنها لیست می‌شوند.&lt;/li>
&lt;li>برچسب‌های pprof در این حالت گنجانده می‌شوند، در حالی که &lt;code>debug=2&lt;/code> آنها را شامل نمی‌شود.&lt;/li>
&lt;li>بیشتر ویژگی‌های دیگر گوروتین که در &lt;code>debug=2&lt;/code> وجود دارند، در اینجا وجود ندارند.&lt;/li>
&lt;li>فرمت خروجی همچنان به صورت متنی است، اما ظاهری بسیار متفاوت نسبت به &lt;code>debug=2&lt;/code> دارد.&lt;/li>
&lt;/ul>
&lt;p>در زیر یک نمونه کوتاه از خروجی برگردانده شده آورده شده است.&lt;/p>
&lt;pre>&lt;code class="language-shell">goroutine profile: total 9
2 @ 0x103b125 0x106cd1f 0x13ac44a 0x106fd81
# labels: {&amp;quot;test_label&amp;quot;:&amp;quot;test_value&amp;quot;}
# 0x106cd1e time.Sleep+0xbe /usr/local/Cellar/go/1.15.6/libexec/src/runtime/time.go:188
# 0x13ac449 main.shortSleepLoop+0x29 /Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:165
1 @ 0x103b125 0x10083ef 0x100802b 0x13ac4ed 0x106fd81
# labels: {&amp;quot;test_label&amp;quot;:&amp;quot;test_value&amp;quot;}
# 0x13ac4ec main.chanReceiveForever+0x4c /Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:177
1 @ 0x103b125 0x103425b 0x106a1d5 0x10d8185 0x10d91c5 0x10d91a3 0x11b8a8f 0x11cb72e 0x12df52d 0x11707c5 0x117151d 0x1171754 0x1263c2c 0x12d96ca 0x12d96f9 0x12e09ba 0x12e5085 0x106fd81
# 0x106a1d4 internal/poll.runtime_pollWait+0x54 /usr/local/Cellar/go/1.15.6/libexec/src/runtime/netpoll.go:222
# 0x10d8184 internal/poll.(*pollDesc).wait+0x44 /usr/local/Cellar/go/1.15.6/libexec/src/internal/poll/fd_poll_runtime.go:87
# 0x10d91c4 internal/poll.(*pollDesc).waitRead+0x1a4 /usr/local/Cellar/go/1.15.6/libexec/src/internal/poll/fd_poll_runtime.go:92
# 0x10d91a2 internal/poll.(*FD).Read+0x182 /usr/local/Cellar/go/1.15.6/libexec/src/internal/poll/fd_unix.go:159
# 0x11b8a8e net.(*netFD).Read+0x4e /usr/local/Cellar/go/1.15.6/libexec/src/net/fd_posix.go:55
# 0x11cb72d net.(*conn).Read+0x8d /usr/local/Cellar/go/1.15.6/libexec/src/net/net.go:182
# 0x12df52c net/http.(*connReader).Read+0x1ac /usr/local/Cellar/go/1.15.6/libexec/src/net/http/server.go:798
# 0x11707c4 bufio.(*Reader).fill+0x104 /usr/local/Cellar/go/1.15.6/libexec/src/bufio/bufio.go:101
# 0x117151c bufio.(*Reader).ReadSlice+0x3c /usr/local/Cellar/go/1.15.6/libexec/src/bufio/bufio.go:360
# 0x1171753 bufio.(*Reader).ReadLine+0x33 /usr/local/Cellar/go/1.15.6/libexec/src/bufio/bufio.go:389
# 0x1263c2b net/textproto.(*Reader).readLineSlice+0x6b /usr/local/Cellar/go/1.15.6/libexec/src/net/textproto/reader.go:58
# 0x12d96c9 net/textproto.(*Reader).ReadLine+0xa9 /usr/local/Cellar/go/1.15.6/libexec/src/net/textproto/reader.go:39
# 0x12d96f8 net/http.readRequest+0xd8 /usr/local/Cellar/go/1.15.6/libexec/src/net/http/request.go:1012
# 0x12e09b9 net/http.(*conn).readRequest+0x199 /usr/local/Cellar/go/1.15.6/libexec/src/net/http/server.go:984
# 0x12e5084 net/http.(*conn).serve+0x704 /usr/local/Cellar/go/1.15.6/libexec/src/net/http/server.go:1851
...
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>&lt;a href="https://golang.org/pkg/runtime/pprof/#Lookup">&lt;code>pprof.Lookup(debug=0)&lt;/code>&lt;/a>&lt;/strong>&lt;/p>
&lt;p>این روش پروفایل‌گیری دقیقاً مانند &lt;code>pprof.Lookup(debug=1)&lt;/code> فراخوانی می‌شود و همان داده‌ها را تولید می‌کند. تنها تفاوت این است که فرمت داده‌ها به صورت پروتکل بافر pprof است.&lt;/p>
&lt;p>در زیر یک نمونه کوتاه از خروجی برگشتی که توسط &lt;code>go tool pprof -raw&lt;/code> گزارش شده است آورده شده است.&lt;/p>
&lt;pre>&lt;code class="language-shell">PeriodType: goroutine count
Period: 1
Time: 2021-01-14 16:46:23.697667 +0100 CET
Samples:
goroutine/count
2: 1 2 3
test_label:[test_value]
1: 1 4 5 6
test_label:[test_value]
1: 1 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1: 1 7 8 9 10 11 12 21 14 22 23
test_label:[test_value]
1: 1 7 8 9 24 25 26 27 28 29 30
1: 1 31 32
test_label:[test_value]
1: 1 2 33
test_label:[test_value]
1: 34 35 36 37 38 39 40 41
test_label:[test_value]
Locations
1: 0x103b124 M=1 runtime.gopark /usr/local/Cellar/go/1.15.6/libexec/src/runtime/proc.go:306 s=0
2: 0x106cd1e M=1 time.Sleep /usr/local/Cellar/go/1.15.6/libexec/src/runtime/time.go:188 s=0
3: 0x13ac449 M=1 main.shortSleepLoop /Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:165 s=0
4: 0x10083ee M=1 runtime.chanrecv /usr/local/Cellar/go/1.15.6/libexec/src/runtime/chan.go:577 s=0
5: 0x100802a M=1 runtime.chanrecv1 /usr/local/Cellar/go/1.15.6/libexec/src/runtime/chan.go:439 s=0
6: 0x13ac4ec M=1 main.chanReceiveForever /Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:177 s=0
...
Mappings
1: 0x0/0x0/0x0 [FN]
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>&lt;a href="https://golang.org/pkg/runtime/#GoroutineProfile">&lt;code>runtime.GoroutineProfile()&lt;/code>&lt;/a>&lt;/strong>&lt;/p>
&lt;p>این تابع در واقع یک slice از تمام گوروتین‌های فعال و trace استک فعلی آنها را برمی‌گرداند. استک ترِیس‌ها به صورت آدرس‌های برنامه ارائه می‌شوند که می‌توان آنها را با استفاده از تابع &lt;a href="https://golang.org/pkg/runtime/#CallersFrames">&lt;code>runtime.CallersFrames()&lt;/code>&lt;/a> به نام‌های توابع ترجمه کرد.&lt;/p>
&lt;p>این روش توسط &lt;a href="https://github.com/felixge/fgprof">fgprof&lt;/a> برای پیاده‌سازی پروفایل‌گیری دیوار ساعت استفاده می‌شود.&lt;/p>
&lt;p>ویژگی‌های زیر در حال حاضر در دسترس نیستند، اما ممکن است برای پیشنهاد به پروژه Go در آینده جالب باشند:&lt;/p>
&lt;ul>
&lt;li>شامل کردن ویژگی‌های گوروتین‌هایی که هنوز در دسترس نیستند، به خصوص برچسب‌ها.&lt;/li>
&lt;li>فیلتر کردن بر اساس برچسب‌های pprof، این کار می‌تواند &lt;strong>stop-the-world&lt;/strong> را کاهش دهد، اما نیاز به نگهداری اضافی توسط runtime خواهد داشت.&lt;/li>
&lt;li>محدود کردن تعداد گوروتین‌های بازگشتی به یک زیرمجموعه تصادفی، که می‌تواند &lt;strong>stop-the-world&lt;/strong> را کاهش دهد و ممکن است پیاده‌سازی آن نسبت به فیلتر بر اساس برچسب آسان‌تر باشد.&lt;/li>
&lt;/ul>
&lt;p>در زیر یک مثال کوتاه از خروجی بازگشتی آورده شده است.&lt;/p>
&lt;pre>&lt;code class="language-json">[
{
&amp;quot;Stack0&amp;quot;: [
20629256,
20629212,
20627047,
20628306,
17018153,
17235329,
...
]
},
{
&amp;quot;Stack0&amp;quot;: [
17019173,
17222943,
20628554,
17235329,
...
]
},
...
]
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>&lt;a href="https://golang.org/pkg/net/http/pprof/">&lt;code>net/http/pprof&lt;/code>&lt;/a>&lt;/strong>&lt;/p>
&lt;p>این پکیج پروفایل‌های توصیف‌شده در بخش &lt;a href="https://golang.org/pkg/runtime/pprof/#Lookup">&lt;code>pprof.Lookup(&amp;quot;goroutine&amp;quot;)&lt;/code>&lt;/a> را از طریق endpointهای HTTP فراهم می‌کند. خروجی دقیقاً همان چیزی است که در روش‌های دیگر دیده می‌شود.&lt;/p>
&lt;h4 id="425255-تاریخچه">
4.25.2.5.5 تاریخچه
&lt;a class="anchor" href="#425255-%d8%aa%d8%a7%d8%b1%db%8c%d8%ae%da%86%d9%87">#&lt;/a>
&lt;/h4>
&lt;p>پروفایل‌گیری گوروتین توسط &lt;a href="https://github.com/rsc">Russ Cox&lt;/a> &lt;a href="https://codereview.appspot.com/5687076/">پیاده‌سازی شد&lt;/a> و برای اولین بار در نسخه &lt;a href="https://golang.org/doc/devel/weekly.html#2012-02-22">weekly.2012-02-22&lt;/a> پیش از انتشار go1 ظاهر شد.&lt;/p>
&lt;h3 id="42526-پروفایلر-threadcreate">
4.25.2.6 پروفایلر ThreadCreate
&lt;a class="anchor" href="#42526-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-threadcreate">#&lt;/a>
&lt;/h3>
&lt;p>🐞 پروفایل threadcreate برای نمایش استک ترِیس‌هایی طراحی شده که منجر به ایجاد نخ‌های (threads) جدید سیستم‌عامل شده‌اند. با این حال، از سال ۲۰۱۳ &lt;a href="https://github.com/golang/go/issues/6104">خراب شده است&lt;/a>، بنابراین بهتر است از آن دوری کنید.&lt;/p>
&lt;h2 id="4253-آموزش-کار-با-ابزار-go-pprof">
4.25.3 آموزش کار با ابزار go pprof
&lt;a class="anchor" href="#4253-%d8%a2%d9%85%d9%88%d8%b2%d8%b4-%da%a9%d8%a7%d8%b1-%d8%a8%d8%a7-%d8%a7%d8%a8%d8%b2%d8%a7%d8%b1-go-pprof">#&lt;/a>
&lt;/h2>
&lt;p>پروفایلرهای مختلف داخلی در Go برای کار با ابزار بصری‌سازی &lt;a href="https://github.com/google/pprof">pprof&lt;/a> طراحی شده‌اند. pprof خود یک پروژه غیررسمی از گوگل است که برای تحلیل داده‌های پروفایل‌گیری از برنامه‌های C++، Java و Go طراحی شده است. این پروژه یک فرمت پروتکل بافر را تعریف می‌کند که توسط تمام پروفایلرهای Go استفاده می‌شود و در این سند توضیح داده شده است.&lt;/p>
&lt;p>پروژه Go خود یک نسخه از pprof را &lt;a href="https://github.com/golang/go/tree/master/src/cmd/pprof">به‌همراه&lt;/a> دارد که می‌توان آن را از طریق دستور &lt;code>go tool pprof&lt;/code> فراخوانی کرد. این ابزار تا حد زیادی با ابزار اصلی مشابه است، به‌جز چند تغییر جزئی. Go توصیه می‌کند که برای کار با پروفایل‌های Go همیشه از &lt;code>go tool pprof&lt;/code> به‌جای ابزار اصلی استفاده شود.&lt;/p>
&lt;h3 id="42531-ویژگیها">
4.25.3.1 ویژگی‌ها
&lt;a class="anchor" href="#42531-%d9%88%db%8c%da%98%da%af%db%8c%d9%87%d8%a7">#&lt;/a>
&lt;/h3>
&lt;p>ابزار pprof دارای یک رابط خط فرمان تعاملی است، اما همچنین یک رابط کاربری وب و گزینه‌های مختلف فرمت خروجی دیگر نیز دارد.&lt;/p>
&lt;h3 id="42532-فرمت-فایل">
4.25.3.2 فرمت فایل
&lt;a class="anchor" href="#42532-%d9%81%d8%b1%d9%85%d8%aa-%d9%81%d8%a7%db%8c%d9%84">#&lt;/a>
&lt;/h3>
&lt;p>فرمت pprof در تعریف پروتکل بافر &lt;a href="https://github.com/google/pprof/blob/master/proto/profile.proto">profile.proto&lt;/a> تعریف شده است که شامل نظرات مفیدی است. علاوه بر این، یک &lt;a href="https://github.com/google/pprof/blob/master/proto/README.md">README&lt;/a> رسمی برای آن وجود دارد. فایل‌های pprof همیشه با فشرده‌سازی gzip در دیسک ذخیره می‌شوند.&lt;/p>
&lt;p>یک تصویر به اندازه هزار کلمه می‌ارزد، بنابراین در زیر یک تجسم خودکار &lt;a href="https://github.com/seamia/protodot">تولید شده&lt;/a> از این فرمت قرار داده شده است. لطفاً توجه داشته باشید که فیلدهایی مانند &lt;code>filename&lt;/code> اشاره‌گرهایی به &lt;code>string_table&lt;/code> هستند که در تجسم نشان داده نمی‌شوند و بهبودهای این حوزه خوش‌آمد است!&lt;/p>
&lt;center>&lt;a href="#">
&lt;img src="../../assets/img/content/chapter4/profiling/10.png" alt="profile">
&lt;/a>&lt;/center>
&lt;h3 id="42533-فرمت-دادههای-pprof">
4.25.3.3 فرمت داده‌های pprof
&lt;a class="anchor" href="#42533-%d9%81%d8%b1%d9%85%d8%aa-%d8%af%d8%a7%d8%af%d9%87%d9%87%d8%a7%db%8c-pprof">#&lt;/a>
&lt;/h3>
&lt;p>فرمت داده‌های pprof به نظر می‌رسد که برای کارایی، زبان‌های مختلف و انواع پروفایل‌های مختلف (CPU، Heap و غیره) طراحی شده است، اما به دلیل این موضوع، بسیار انتزاعی و پر از اشاره‌گری است. اگر می‌خواهید جزئیات کامل را مشاهده کنید، به لینک‌های بالا مراجعه کنید. اگر به دنبال &lt;strong>خلاصه‌ای مختصر&lt;/strong> هستید، ادامه دهید:&lt;/p>
&lt;p>یک فایل pprof شامل فهرستی از &lt;strong>پشته‌های تراشه&lt;/strong> است که به آن‌ها نمونه‌ها گفته می‌شود و یک یا چند &lt;strong>مقدار&lt;/strong> عددی با آن‌ها مرتبط است. برای یک پروفایل CPU، مقدار ممکن است مدت زمان CPU در نانوثانیه باشد که پشته تراشه در طول پروفایل‌سازی مشاهده شده است. برای یک پروفایل Heap، ممکن است تعداد بایت‌های تخصیص‌یافته باشد. &lt;strong>نوع‌های مقداری&lt;/strong> خود در ابتدای فایل توصیف شده و برای پر کردن فهرست &amp;ldquo;نمونه&amp;rdquo; در رابط کاربری pprof استفاده می‌شوند. علاوه بر مقادیر، هر پشته تراشه می‌تواند شامل مجموعه‌ای از &lt;strong>برچسب‌ها&lt;/strong> نیز باشد. برچسب‌ها زوج‌های کلید-مقدار هستند و حتی می‌توانند شامل واحد نیز باشند. در Go، این برچسب‌ها برای &lt;a href="https://rakyll.org/profiler-labels/">برچسب‌های پروفایلر&lt;/a> استفاده می‌شوند.&lt;/p>
&lt;p>این پروفایل همچنین شامل &lt;strong>زمان&lt;/strong> (در UTC) است که پروفایل ثبت شده و &lt;strong>مدت زمان&lt;/strong> ضبط را نشان می‌دهد.&lt;/p>
&lt;p>علاوه بر این، فرمت امکان استفاده از &lt;strong>عبارات منظم drop/keep&lt;/strong> برای حذف یا شامل کردن برخی از پشته‌های تراشه را فراهم می‌کند، اما آن‌ها &lt;a href="https://github.com/golang/go/blob/go1.15.6/src/runtime/pprof/proto.go#L375-L376">توسط Go استفاده نمی‌شوند&lt;/a>. همچنین فضایی برای فهرستی از &lt;strong>نظرات&lt;/strong> (&lt;a href="https://github.com/golang/go/search?q=tagProfile_Comment">توسط Go نیز استفاده نمی‌شود&lt;/a>) و توصیف &lt;strong>فاصله&lt;/strong> دوره‌ای که در آن نمونه‌ها گرفته شده‌اند وجود دارد.&lt;/p>
&lt;p>کد تولید خروجی pprof در Go در &lt;a href="https://github.com/golang/go/blob/go1.15.6/src/runtime/pprof/proto.go">runtime/pprof/proto.go&lt;/a> موجود است.&lt;/p>
&lt;h3 id="42534-رمزگشایی-decoding">
4.25.3.4 رمزگشایی (Decoding)
&lt;a class="anchor" href="#42534-%d8%b1%d9%85%d8%b2%da%af%d8%b4%d8%a7%db%8c%db%8c-decoding">#&lt;/a>
&lt;/h3>
&lt;p>در زیر تعدادی ابزار برای رمزگشایی فایل‌های pprof به خروجی متنی قابل خواندن انسان آورده شده است. آن‌ها بر اساس پیچیدگی فرمت خروجی خود مرتب شده‌اند، به طوری که ابزارهایی که خروجی ساده‌تری ارائه می‌دهند ابتدا فهرست شده‌اند:&lt;/p>
&lt;h3 id="42535-استفاده-از-pprofutils">
4.25.3.5 استفاده از &lt;code>pprofutils&lt;/code>
&lt;a class="anchor" href="#42535-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-pprofutils">#&lt;/a>
&lt;/h3>
&lt;p>&lt;a href="https://github.com/felixge/pprofutils">pprofutils&lt;/a> ابزاری کوچک برای تبدیل بین فایل‌های pprof و فرمت متنی جمع شده Brendan Gregg است (&lt;a href="https://github.com/brendangregg/FlameGraph#2-fold-stacks">folded text&lt;/a>). می‌توانید از آن به صورت زیر استفاده کنید:&lt;/p>
&lt;pre>&lt;code class="language-bash">$ pprof2text &amp;lt; examples/cpu/pprof.samples.cpu.001.pb.gz
golang.org/x/sync/errgroup.(*Group).Go.func1;main.run.func2;main.computeSum 19
golang.org/x/sync/errgroup.(*Group).Go.func1;main.run.func2;main.computeSum;runtime.asyncPreempt 5
runtime.mcall;runtime.gopreempt_m;runtime.goschedImpl;runtime.schedule;runtime.findrunnable;runtime.stopm;runtime.notesleep;runtime.semasleep;runtime.pthread_cond_wait 1
runtime.mcall;runtime.park_m;runtime.schedule;runtime.findrunnable;runtime.checkTimers;runtime.nanotime;runtime.nanotime1 1
runtime.mcall;runtime.park_m;runtime.schedule;runtime.findrunnable;runtime.stopm;runtime.notesleep;runtime.semasleep;runtime.pthread_cond_wait 2
runtime.mcall;runtime.park_m;runtime.resetForSleep;runtime.resettimer;runtime.modtimer;runtime.wakeNetPoller;runtime.netpollBreak;runtime.write;runtime.write1 7
runtime.mstart;runtime.mstart1;runtime.sysmon;runtime.usleep 3
&lt;/code>&lt;/pre>
&lt;h3 id="42536-استفاده-از-go-tool-pprof">
4.25.3.6 استفاده از &lt;code>go tool pprof&lt;/code>
&lt;a class="anchor" href="#42536-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-go-tool-pprof">#&lt;/a>
&lt;/h3>
&lt;p>خود &lt;code>pprof&lt;/code> دارای یک حالت خروجی به نام &lt;code>-raw&lt;/code> است که محتوای یک فایل pprof را نمایش می‌دهد. با این حال، باید توجه داشت که این حالت آنچنان &lt;code>-raw&lt;/code> نیست که می‌توان به آن رسید، به &lt;code>protoc&lt;/code> زیر نگاه کنید:&lt;/p>
&lt;pre>&lt;code class="language-bash">$ go tool pprof -raw examples/cpu/pprof.samples.cpu.001.pb.gz
PeriodType: cpu nanoseconds
Period: 10000000
Time: 2021-01-08 17:10:32.116825 +0100 CET
Duration: 3.13
Samples:
samples/count cpu/nanoseconds
19 190000000: 1 2 3
5 50000000: 4 5 2 3
1 10000000: 6 7 8 9 10 11 12 13 14
1 10000000: 15 16 17 11 18 14
2 20000000: 6 7 8 9 10 11 18 14
7 70000000: 19 20 21 22 23 24 14
3 30000000: 25 26 27 28
Locations
1: 0x1372f7f M=1 main.computeSum /Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/cpu/main.go:39 s=0
2: 0x13730f2 M=1 main.run.func2 /Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/cpu/main.go:31 s=0
3: 0x1372cf8 M=1 golang.org/x/sync/errgroup.(*Group).Go.func1 /Users/felix.geisendoerfer/go/pkg/mod/golang.org/x/sync@v0.0.0-20201207232520-09787c993a3a/errgroup/errgroup.go:57 s=0
...
Mappings
1: 0x0/0x0/0x0 [FN]
&lt;/code>&lt;/pre>
&lt;h3 id="42537-استفاده-از-protoc">
4.25.3.7 استفاده از &lt;code>protoc&lt;/code>
&lt;a class="anchor" href="#42537-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-protoc">#&lt;/a>
&lt;/h3>
&lt;p>برای کسانی که به دنبال دیدن داده‌ها نزدیک به ذخیره‌سازی باینری خام هستند، ما به کامپایلر پروتکل بافر &lt;code>protoc&lt;/code> نیاز داریم. در macOS می‌توانید از &lt;code>brew install protobuf&lt;/code> برای نصب آن استفاده کنید، برای سایر پلتفرم‌ها به بخش نصب &lt;a href="https://github.com/protocolbuffers/protobuf#protocol-compiler-installation">README&lt;/a> مراجعه کنید.&lt;/p>
&lt;p>حالا بیایید به همان پروفایل CPU از بالا نگاهی بیندازیم:&lt;/p>
&lt;pre>&lt;code class="language-bash">$ gzcat examples/cpu/pprof.samples.cpu.001.pb.gz | protoc --decode perftools.profiles.Profile ./profile.proto
sample_type {
type: 1
unit: 2
}
sample_type {
type: 3
unit: 4
}
sample {
location_id: 1
location_id: 2
location_id: 3
value: 19
value: 190000000
}
sample {
location_id: 4
location_id: 5
location_id: 2
location_id: 3
value: 5
value: 50000000
}
...
mapping {
id: 1
has_functions: true
}
location {
id: 1
mapping_id: 1
address: 20393855
line {
function_id: 1
line: 39
}
}
location {
id: 2
mapping_id: 1
address: 20394226
line {
function_id: 2
line: 31
}
}
...
function {
id: 1
name: 5
system_name: 5
filename: 6
}
function {
id: 2
name: 7
system_name: 7
filename: 6
}
...
string_table: &amp;quot;&amp;quot;
string_table: &amp;quot;samples&amp;quot;
string_table: &amp;quot;count&amp;quot;
string_table: &amp;quot;cpu&amp;quot;
string_table: &amp;quot;nanoseconds&amp;quot;
string_table: &amp;quot;main.computeSum&amp;quot;
string_table: &amp;quot;/Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/cpu/main.go&amp;quot;
...
time_nanos: 1610122232116825000
duration_nanos: 3135113726
period_type {
type: 3
unit: 4
}
period:
10000000
&lt;/code>&lt;/pre>
&lt;p>این دستورات به ما این امکان را می‌دهند که ساختارهای ورودی و مقادیر خود را مشاهده کنیم، به ما کمک می‌کنند تا در نهایت فرمت را بهتر درک کنیم.&lt;/p>
&lt;h3 id="42538-استفاده-از-nethttppprof-پروفایلینگ-ریموت">
4.25.3.8 استفاده از net/http/pprof پروفایلینگ ریموت
&lt;a class="anchor" href="#42538-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-nethttppprof-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%db%8c%d9%86%da%af-%d8%b1%db%8c%d9%85%d9%88%d8%aa">#&lt;/a>
&lt;/h3>
&lt;p>امکان دیباگ سرویس با استفاده از pprof برروی &lt;code>http.Server&lt;/code> یا سایر وب سرورها. شما می توانید از پکیج &lt;a href="https://pkg.go.dev/net/http/pprof@go1.23.2">&lt;code>net/http/pprof&lt;/code>&lt;/a> استفاده کنید اما دقت کنید ۲ مسئله وجود دارد باید در نظر بگیرید هنگام استفاده:&lt;/p>
&lt;ol>
&lt;li>زمانیکه این پکیج را در هر جایی از پروژه خود فراخوانی کنید تابع &lt;code>init()&lt;/code> داخل پکیج اجرا می شود و خودکار به &lt;code>http.Handler&lt;/code> سرور mux اضافه می شود و نیازی به ریجستر کردن handler نیست اما اگر web framework های دیگر را استفاده میکنید باید بصورت دستی استفاده کنید.&lt;/li>
&lt;li>امکان اینکه پکیج pprof قابلیت configuration شدن را داشته باشد ندارد و اطلاعات دیباگ خیلی حساس هستند اگر سرویس شما روی پروداکشن هست ممکن است اطلاعات حساسی بیرون درز دهد, به عنوان مثال &lt;code>debug/pprof/cmdline&lt;/code> اطلاعات flag, switch هایی که سرویس شما اجرا شده است را نمایش می دهد و در صورتیکه فلگی داشته باشید شامل اطلاعات حساسی نظیر secret key, password و&amp;hellip; باشد دیده می شود.&lt;/li>
&lt;/ol>
&lt;p>برای مورد دوم راه حلی داریم که می توانید جلو خودکار ریجستر شدن handler های pprof را بگیرید و موارد مورد نیاز را ریجستر کنید.&lt;/p>
&lt;blockquote class="book-hint info">
&lt;p>برای مورد دوم راه حلی داریم که می توانید جلو خودکار ریجستر شدن handler های pprof را بگیرید و موارد مورد نیاز را ریجستر کنید.&lt;/p>
&lt;p>به نمونه کد زیر توجه کنید:&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;flag&amp;quot;
&amp;quot;fmt&amp;quot; &amp;quot;github.com/PacViewer/synker/internal/logger&amp;quot; _ &amp;quot;go.uber.org/automaxprocs&amp;quot;
&amp;quot;net/http&amp;quot; &amp;quot;net/http/pprof&amp;quot;)
var (
pprofAddr *string
)
func init() {
pprofAddr = flag.String(&amp;quot;pprof-addr&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;start pprof on server&amp;quot;)
flag.Parse()
// init disables default pprof handlers registered by importing net/http/pprof.
// Your pprof is showing (https://mmcloughlin.com/posts/your-pprof-is-showing)
http.DefaultServeMux = http.NewServeMux()
}
func main() {
log := logger.DefaultLogger
if *pprofAddr != &amp;quot;&amp;quot; {
mux := http.NewServeMux()
mux.HandleFunc(&amp;quot;/debug/pprof/&amp;quot;, pprof.Index)
mux.HandleFunc(&amp;quot;/debug/pprof/profile&amp;quot;, pprof.Profile)
mux.HandleFunc(&amp;quot;/debug/pprof/symbol&amp;quot;, pprof.Symbol)
mux.HandleFunc(&amp;quot;/debug/pprof/trace&amp;quot;, pprof.Trace)
sv := &amp;amp;http.Server{
Addr: *pprofAddr,
Handler: mux,
}
log.Info(&amp;quot;pprof listened&amp;quot;, &amp;quot;addr&amp;quot;, fmt.Sprintf(&amp;quot;http://%s/debug/pprof&amp;quot;, *pprofAddr))
go func() {
if err := sv.ListenAndServe(); err != nil {
log.Fatal(&amp;quot;failed to listen pprof server&amp;quot;, &amp;quot;err&amp;quot;, err)
}
}()
}
}
&lt;/code>&lt;/pre>
&lt;/blockquote>
&lt;p>پس از اینکه &lt;code>net/http/pprof&lt;/code> را ریجستر کردید برروی سرور روی روت &lt;code>/debug/pprof&lt;/code> در دسترس است.&lt;/p>
&lt;center>&lt;a href="#">
&lt;img src="../../assets/img/content/chapter4/profiling/11.png" alt="pprof">
&lt;/a>&lt;/center>
&lt;h3 id="42539-دستورات-pprof">
4.25.3.9 دستورات pprof
&lt;a class="anchor" href="#42539-%d8%af%d8%b3%d8%aa%d9%88%d8%b1%d8%a7%d8%aa-pprof">#&lt;/a>
&lt;/h3>
&lt;p>در زیر ما یکسری دستوارت کاربردی pprof را معرفی میکنیم که میتوانید بصورت visualization اطلاعات پروفایل را در لوکال یا ریموت ببینید.&lt;/p>
&lt;h4 id="425391-دیدن-cpu-profile-آنلاین-روی-لوکال">
4.25.3.9.1 دیدن CPU Profile آنلاین روی لوکال
&lt;a class="anchor" href="#425391-%d8%af%db%8c%d8%af%d9%86-cpu-profile-%d8%a2%d9%86%d9%84%d8%a7%db%8c%d9%86-%d8%b1%d9%88%db%8c-%d9%84%d9%88%da%a9%d8%a7%d9%84">#&lt;/a>
&lt;/h4>
&lt;p>برای دیدن اطلاعات CPU Profile بصورت آنلاین روی لوکال دستور زیر را بزنید:&lt;/p>
&lt;pre>&lt;code class="language-shell">go tool pprof -http=:8081 http://localhost:8080/debug/pprof/profile
&lt;/code>&lt;/pre>
&lt;center>&lt;a href="#">
&lt;img src="../../assets/img/content/chapter4/profiling/12.png" alt="cpu profile">
&lt;/a>&lt;/center>
&lt;h4 id="425392-دیدن-memory-profile-آنلاین-روی-لوکال">
4.25.3.9.2 دیدن Memory Profile آنلاین روی لوکال
&lt;a class="anchor" href="#425392-%d8%af%db%8c%d8%af%d9%86-memory-profile-%d8%a2%d9%86%d9%84%d8%a7%db%8c%d9%86-%d8%b1%d9%88%db%8c-%d9%84%d9%88%da%a9%d8%a7%d9%84">#&lt;/a>
&lt;/h4>
&lt;p>برای دیدن اطلاعات Memory Profile بصورت آنلاین روی لوکال دستور زیر را بزنید:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>دیدن allocation ها&lt;/strong>&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">go tool pprof -http=:8081 http://localhost:8080/debug/pprof/allocs
&lt;/code>&lt;/pre>
&lt;center>&lt;a href="#">
&lt;img src="../../assets/img/content/chapter4/profiling/13.png" alt="memory allocs profile">
&lt;/a>&lt;/center>
&lt;ul>
&lt;li>&lt;strong>دیدن heap ها&lt;/strong>&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">go tool pprof -http=:8081 http://localhost:8080/debug/pprof/heap
&lt;/code>&lt;/pre>
&lt;center>&lt;a href="#">
&lt;img src="../../assets/img/content/chapter4/profiling/13.png" alt="heap profile">
&lt;/a>&lt;/center>
&lt;p>برای دیدن در قالب flame graph می توانید به آدرس زیر برروید:&lt;/p>
&lt;pre>&lt;code class="language-shell">http://localhost:8082/ui/flamegraph
&lt;/code>&lt;/pre>
&lt;center>&lt;a href="#">
&lt;img src="../../assets/img/content/chapter4/profiling/15.png" alt="flame graph">
&lt;/a>&lt;/center>
&lt;h4 id="425393-گرفتن-خروجی-pdf-png-svg">
4.25.3.9.3 گرفتن خروجی pdf, png, svg
&lt;a class="anchor" href="#425393-%da%af%d8%b1%d9%81%d8%aa%d9%86-%d8%ae%d8%b1%d9%88%d8%ac%db%8c-pdf-png-svg">#&lt;/a>
&lt;/h4>
&lt;p>برای اینکه بتوانید از اطلاعات profiling خروجی فایل بگیرید دستور زیر را بزنید.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>PDF&lt;/strong>&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">go tool pprof -pdf heap_profile.pprof
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>&lt;strong>SVG&lt;/strong>&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">go tool pprof -svg heap_profile.pprof
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>&lt;strong>PNG&lt;/strong>&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-shell">go tool pprof -png heap_profile.pprof
&lt;/code>&lt;/pre>
&lt;h3 id="42539-نتیجهگیری">
4.25.3.9 نتیجه‌گیری
&lt;a class="anchor" href="#42539-%d9%86%d8%aa%db%8c%d8%ac%d9%87%da%af%db%8c%d8%b1%db%8c">#&lt;/a>
&lt;/h3>
&lt;p>مدیریت کارآمد حافظه در Go، به همراه ابزارهای پروفایل‌سازی‌اش، به توسعه‌دهندگان پلتفرمی قوی برای ساخت برنامه‌های کارآمد ارائه می‌دهد. با درک رفتار حافظه در Go و پروفایل‌سازی منظم برنامه خود، می‌توانید اطمینان حاصل کنید که این برنامه حتی در بارهای سنگین نیز کارآمد و پاسخگو باقی می‌ماند.&lt;/p></description></item><item><author/><title>4.26 ساختار پروژه</title><link>https://book.gofarsi.ir/chapter-4/go-project-layout/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/go-project-layout/</guid><description>&lt;h2 id="4261-نمای-کلی-project-layout">
4.26.1 نمای کلی project-layout
&lt;a class="anchor" href="#4261-%d9%86%d9%85%d8%a7%db%8c-%da%a9%d9%84%db%8c-project-layout">#&lt;/a>
&lt;/h2>
&lt;p>این متن یک طرح اساسی برای پروژه‌های برنامه‌نویسی به زبان Go است. توجه داشته باشید که این طرح از نظر محتوا ساده است، زیرا فقط روی layout کلی تمرکز دارد و نه آنچه در داخل آن قرار دارد. همچنین ساده است هر چند که از نظر محتوی پیشرفته است ولی به جزئیات زیادی در مورد نحوه ساختاردهی بیشتر پروژه شما نمی‌پردازد. برای مثال، سعی نمی‌کند ساختار پروژه‌ای را با چیزی مانند Clean Architecture پوشش دهد.
برای بررسی نمونه کدهای مشابه و مرجع این متن به این &lt;a href="https://github.com/golang-standards/project-layout/tree/master">لینک&lt;/a> مراجعه کنید.
این یک &lt;code>استاندارد رسمی تعریف شده توسط تیم توسعه اصلی Go نیست&lt;/code>. این مجموعه‌ای از الگوهای layout پروژه‌های رایج با سابقه و نوظهور در اکوسیستم Go است. برخی از این الگوها از بقیه محبوب‌تر هستند. همچنین دارای تعدادی بهبود کوچک همراه با چندین دایرکتوری پشتیبانی مشترک در هر برنامه واقعی به اندازه کافی بزرگ است. توجه داشته باشید که تیم اصلی Go مجموعه خوبی از دستورالعمل‌های عمومی در مورد ساختاردهی پروژه‌های Go و معنای آن برای پروژه شما هنگام وارد شدن و نصب آن ارائه می‌دهد. برای اطلاعات بیشتر، به صفحه &lt;a href="https://go.dev/doc/modules/layout">&lt;code>Organizing a Go module&lt;/code>&lt;/a> در اسناد رسمی Go مراجعه کنید. این صفحه شامل الگوهای دایرکتوری داخلی و cmd (که در زیر توضیح داده شده است) و سایر اطلاعات مفید است.
اگر در حال یادگیری Go هستید یا یک PoC یا یک پروژه ساده برای خودتان می‌سازید، این طرح پروژه بیش از حد پیچیده است. در عوض، با چیزی بسیار ساده شروع کنید (یک فایل main.go و go.mod بیش از اندازه کافی است). با پیشرفت پروژه، به خاطر داشته باشید که ساختاردهی مناسب کد شما بسیار مهم خواهد بود، در غیر این صورت در نهایت با یک کد نامرتب با وابستگی‌های پنهان (hidden dependencies) و global state زیادی مواجه خواهید شد. وقتی افراد بیشتری روی پروژه کار می‌کنند، به ساختار بیشتری نیاز خواهید داشت. در این زمان است که معرفی یک روش مشترک برای مدیریت بسته‌ها/کتابخانه‌ها اهمیت دارد. وقتی یک پروژه متن‌باز دارید یا می‌دانید که پروژه‌های دیگر کد را از مخزن پروژه شما وارد می‌کنند، آن زمان است که داشتن بسته‌ها و کدهای خصوصی (معادل internal) اهمیت دارد. repository را کپی کنید، آنچه را که نیاز دارید نگه دارید و بقیه را حذف کنید! فقط به این دلیل که وجود دارد، به این معنی نیست که باید از همه آن استفاده کنید. هیچ یک از این الگوها در هر پروژه‌ای استفاده نمی‌شوند. حتی الگوی &lt;code>vendor&lt;/code> نیز universal نیست.
با آمدن Go 1.14 در نهایت &lt;a href="https://go.dev/wiki/Modules">&lt;code>Go Modules&lt;/code>&lt;/a> برای production آماده شدند. از &lt;a href="https://blog.golang.org/using-go-modules">&lt;code>Go Modules&lt;/code>&lt;/a> استفاده کنید، مگر اینکه دلیل خاصی برای استفاده نکردن از آن‌ها داشته باشید و اگر اینطور است، نیازی به نگرانی در مورد $GOPATH و جایی که پروژه خود را قرار می‌دهید ندارید. فایل &lt;code>go.mod&lt;/code> پایه در مخزن فرض می‌کند که پروژه شما در GitHub میزبانی می‌شود، اما این یک الزام نیست. module path می‌تواند هر چیزی باشد، اگرچه اولین جزء module path باید یک نقطه در نام خود داشته باشد (نسخه فعلی Go دیگر آن را اجباری نمی‌کند، اما اگر از نسخه‌های کمی قدیمی‌تر استفاده می‌کنید، تعجب نکنید اگر ساخت‌های شما بدون آن شکست بخورد). اگر می‌خواهید درباره آن بیشتر بدانید، به Issues &lt;a href="https://github.com/golang/go/issues/37554">&lt;code>37554&lt;/code>&lt;/a> و &lt;a href="https://github.com/golang/go/issues/32819">&lt;code>32819&lt;/code>&lt;/a>مراجعه کنید.
این طرح پروژه عمداً عمومی است و سعی نمی‌کند یک ساختار پکیج Go خاص را تحمیل کند.
این یک تلاش مشترک است. اگر الگوی جدیدی مشاهده کردید یا فکر می‌کنید یکی از الگوهای موجود نیاز به به‌روزرسانی دارد، یک issue را باز کنید.
اگر به کمک در مورد نام‌گذاری، قالب‌بندی و style نیاز دارید، ابتدا &lt;a href="https://golang.org/cmd/gofmt/">&lt;code>gofmt&lt;/code>&lt;/a> و &lt;a href="https://github.com/dominikh/go-tools/tree/master/cmd/staticcheck">&lt;code>staticcheck&lt;/code>&lt;/a> را اجرا کنید. linter استاندارد قبلی، golint، اکنون منسوخ شده است و نگهداری نمی‌شود؛ استفاده از یک linter در حال توسعه و نگهداری شده مانند staticcheck توصیه می‌شود. همچنین مطمئن شوید که این دستورالعمل‌ها و توصیه‌های Go code style را بخوانید:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://talks.golang.org/2014/names.slide">https://talks.golang.org/2014/names.slide&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://golang.org/doc/effective_go.html#names">https://golang.org/doc/effective_go.html#names&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.golang.org/package-names">https://blog.golang.org/package-names&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://go.dev/wiki/CodeReviewComments">https://go.dev/wiki/CodeReviewComments&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://rakyll.org/style-packages">Style guideline for Go packages&lt;/a> (rakyll/JBD)
برای اطلاعات بیشتر ، &lt;a href="https://medium.com/golang-learn/go-project-layout-e5213cdcfaa2">&lt;code>Go Project Layout&lt;/code>&lt;/a> را ببینید.
اطلاعات بیشتر در مورد نامگذاری و سازماندهی بسته‌ها و همچنین سایر توصیه‌های ساختار کد:&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=PTE4VJIdHPg">GopherCon EU 2018: Peter Bourgon-Best Practices for Industrial Programming&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=MzTcsI6tn-0">GopherCon Russia 2018: Ashley McNamara + Brian Ketelsen - Go best practices.&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=ltqV6pDKZD8">GopherCon 2017: Edward Muller-Go Anti-Patterns&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=oL6JBUk6tj0">GopherCon 2018: Kat Zien - How Do You Structure Your Go Apps&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="4252-دایرکتوریها-در-go">
4.25.2 دایرکتوری‌ها در Go
&lt;a class="anchor" href="#4252-%d8%af%d8%a7%db%8c%d8%b1%da%a9%d8%aa%d9%88%d8%b1%db%8c%d9%87%d8%a7-%d8%af%d8%b1-go">#&lt;/a>
&lt;/h2>
&lt;h4 id="cmd">
/cmd
&lt;a class="anchor" href="#cmd">#&lt;/a>
&lt;/h4>
&lt;p>این دایرکتوری شامل برنامه‌های اصلی پروژه شما است. نام هر دایرکتوری فرعی باید با نام برنامه اجرایی مطابقت داشته باشد (برای مثال، &lt;code>/cmd/myapp&lt;/code>).
از قرار دادن حجم کد زیاد در دایرکتوری برنامه خودداری کنید. اگر فکر می‌کنید این کد‌ها قابلیت وارد شدن و استفاده در پروژه‌های دیگر را دارد، باید در دایرکتوری &lt;code>/pkg&lt;/code> قرار گیرد. اگر کد قابل استفاده مجدد نیست یا نمی‌خواهید دیگران از آن استفاده مجدد کنند، آن کد را در دایرکتوری &lt;code>/internal&lt;/code> قرار دهید. تعجب خواهید کرد که دیگران چه کارهایی انجام می‌دهند، بنابراین در مورد اهداف خود صریح باشید!
معمولاً یک تابع اصلی کوچک وجود دارد که کد را از دایرکتوری‌های &lt;code>/internal &lt;/code>و &lt;code>/pkg &lt;/code>وارد کرده و فراخوانی می‌کند و کار دیگری انجام نمی‌دهد.
به‌عنوان‌مثال به دایرکتوری &lt;a href="https://github.com/golang-standards/project-layout/blob/master/cmd/README.md">&lt;code>/cmd&lt;/code>&lt;/a> مراجعه کنید.&lt;/p>
&lt;h4 id="internal">
/internal
&lt;a class="anchor" href="#internal">#&lt;/a>
&lt;/h4>
&lt;p>شامل کد Private application و library code است. این کدی است که نمی‌خواهید دیگران آن را در برنامه‌ها یا کتابخانه‌های خود وارد کنند. توجه داشته باشید که این الگوی چیدمان توسط خود کامپایلر Go اعمال می‌شود. برای جزئیات بیشتر، Go 1.4 &lt;a href="https://golang.org/doc/go1.4#internalpackages">&lt;code>release notes&lt;/code>&lt;/a>را ببینید. توجه داشته باشید که شما به دایرکتوری &lt;code>internal&lt;/code> سطح بالا محدود نیستید. شما می‌توانید در هر سطحی از درخت پروژه خود بیش از یک دایرکتوری &lt;code>internal&lt;/code> داشته باشید.
به‌صورت اختیاری می‌توانید برای جدا کردن کد داخلی مشترک و غیرمشترک خود، کمی ساختار اضافی به بسته‌های داخلی (internal packages) خود اضافه کنید. این کار الزامی نیست (به ویژه برای پروژه‌های کوچک‌تر)، اما داشتن نشانه‌های بصری برای نشان دادن نحوه استفاده موردنظر package بسیار مناسب است. کد application واقعی شما می‌تواند در دایرکتوری &lt;code>/internal/app&lt;/code> (مثلاً &lt;code>/internal/app/myapp&lt;/code>) و کد مشترک بین آن برنامه‌ها در دایرکتوری &lt;code>/internal/pkg/&lt;/code> (مثلاً , &lt;code>/internal/pkg/myprivlib&lt;/code>) قرار گیرد.
شما از دایرکتوری‌های internal برای private کردن package‌ها استفاده می‌کنید. اگر یک package را داخل یک internal directory قرار دهید، بسته‌های دیگر نمی‌توانند آن را وارد کنند مگر اینکه یک جد مشترک (common ancestor) داشته باشند. این تنها دایرکتوری‌ای است که در مستندات Go نام برده شده و نحوه برخورد با آن توسط کامپایلر Go خاص و متفاوت است.&lt;/p>
&lt;h4 id="pkg">
/pkg
&lt;a class="anchor" href="#pkg">#&lt;/a>
&lt;/h4>
&lt;p>کد کتابخانه که امکان استفاده توسط برنامه‌های خارجی را دارد (به‌عنوان مثال، &lt;code>/pkg/mypubliclib&lt;/code>). سایر پروژه‌ها این کتابخانه‌ها را import می‌کنند و انتظار کارکرد درست آنها را دارند، بنابراین قبل از قرار دادن چیزی در اینجا خوب فکر کنید :-) و توجه داشته باشید که &lt;code>internal&lt;/code> directory، راه بهتری برای اطمینان از وارد نشدن private packages شماست، زیرا توسط Go اجرا می‌شود. دایرکتوری &lt;code>/pkg&lt;/code>همچنان راه خوبی برای بیان صریح این است که کد موجود در آن دایرکتوری برای استفاده توسط دیگران ایمن است.
مقاله وبلاگ « &lt;a href="https://travisjeffery.com/b/2019/11/i-ll-take-pkg-over-internal/">&lt;code>I'll take pkg over internal&lt;/code>&lt;/a>» توسط Travis Jeffery، نمای کلی خوبی از دایرکتوری‌های pkg و internal و زمان‌هایی که استفاده از آنها منطقی است ارائه می‌دهد.
همچنین این راهی برای گروه‌بندی کد Go در یک مکان است، زمانی که دایرکتوری اصلی شما حاوی بسیاری از اجزا و دایرکتوری‌های غیر Go باشد، این کار اجرای ابزارهای مختلف Go را آسان‌تر می‌کند (همانطور که در این سخنرانی‌ها ذکر شده است: &lt;a href="https://www.youtube.com/watch?v=PTE4VJIdHPg">&lt;code>Best Practices for Industrial Programming&lt;/code>&lt;/a> از GopherCon EU و &lt;a href="https://www.youtube.com/watch?v=oL6JBUk6tj0">GopherCon 2018: Kat Zien - How Do You Structure Your Go Apps&lt;/a> و &lt;a href="https://www.youtube.com/watch?v=3gQa1LWwuzk">GoLab 2018 - Massimiliano Pippi - Project layout patterns in Go&lt;/a>).
اگر می‌خواهید ببینید کدام مخازن محبوب Go از این layout pattern پروژه استفاده می‌کنند، به دایرکتوری &lt;a href="https://github.com/golang-standards/project-layout/blob/master/pkg/README.md">&lt;code>/pkg&lt;/code>&lt;/a> مراجعه کنید. این یک الگوی layout رایج است، اما به‌طور جهانی پذیرفته نشده است و برخی از اعضای جامعه Go آن را توصیه نمی‌کنند.
اگر پروژه برنامه‌ی شما واقعاً کوچک است و جایی که لایه‌ی اضافی تودرتو بودن ارزش زیادی اضافه نمی‌کند، استفاده نکردن از آن اشکالی ندارد (مگر اینکه واقعاً بخواهید :-)). در مورد آن فکر کنید زمانی که پروژه به اندازه کافی بزرگ می شود و دایرکتوری اصلی شما شلوغ می شود (به خصوص اگر اجزای برنامه غیر Go زیادی دارید).
&lt;strong>ریشه‌های دایرکتوری pkg:&lt;/strong> کد منبع قدیمی Go برای بسته‌های خود از pkg استفاده می‌کرد و سپس پروژه‌های مختلف Go در جامعه شروع به کپی کردن این الگو کردند (برای درک بهتر به &lt;a href="https://twitter.com/bradfitz/status/1039512487538970624">این&lt;/a> توییت Brad Fitzpatrick مراجعه کنید).&lt;/p>
&lt;h3 id="vendor">
/vendor
&lt;a class="anchor" href="#vendor">#&lt;/a>
&lt;/h3>
&lt;p>وابستگی‌های برنامه (به‌صورت دستی یا توسط ابزار مدیریت وابستگی مورد علاقه شما مانند ویژگی جدید &lt;a href="https://go.dev/wiki/Modules">&lt;code>Go Modules&lt;/code>&lt;/a>داخلی مدیریت می‌شود). دستور &lt;code>go mod vendor&lt;/code> دایرکتوری &lt;code>vendor/&lt;/code> را برای شما ایجاد می‌کند. توجه داشته باشید که اگر از Go 1.14 استفاده نمی‌کنید که به صورت پیش‌فرض فعال است، ممکن است نیاز به اضافه کردن پرچم &lt;code>-mod=vendor&lt;/code> به دستور go build خود داشته باشید.
اگر در حال ساخت کتابخانه هستید، وابستگی‌های برنامه خود را commit نکنید.
توجه داشته باشید که از Go &lt;a href="https://golang.org/doc/go1.13#modules">&lt;code>1.13&lt;/code>&lt;/a> ، قابلیت module proxy نیز در Go فعال شد (که به طور پیش‌فرض از &lt;a href="https://proxy.golang.org/">https://proxy.golang.org&lt;/a> به عنوان سرور پراکسی ماژول خود استفاده می‌کند). برای اینکه ببینید آیا این قابلیت با تمام الزامات و محدودیت‌های شما مطابقت دارد، در &lt;a href="https://blog.golang.org/module-mirror-launch">اینجا&lt;/a> بیشتر در مورد آن بخوانید. اگر اینطور باشد، اصلاً به دایرکتوری &lt;code>vendor&lt;/code> نیاز نخواهید داشت.&lt;/p>
&lt;h3 id="4263-دایرکتوریهای-سرویس-application">
4.26.3 دایرکتوری‌های سرویس application
&lt;a class="anchor" href="#4263-%d8%af%d8%a7%db%8c%d8%b1%da%a9%d8%aa%d9%88%d8%b1%db%8c%d9%87%d8%a7%db%8c-%d8%b3%d8%b1%d9%88%db%8c%d8%b3-application">#&lt;/a>
&lt;/h3>
&lt;h3 id="api">
&lt;code>/api&lt;/code>
&lt;a class="anchor" href="#api">#&lt;/a>
&lt;/h3>
&lt;p>مشخصات OpenAPI/Swagger، فایل‌های JSON schema، فایل‌های تعریف پروتکل.
برای مثال به دایرکتوری &lt;a href="https://github.com/golang-standards/project-layout/blob/master/api/README.md">&lt;code>/api/&lt;/code>&lt;/a> مراجعه کنید.&lt;/p>
&lt;h3 id="4264-دایرکتوریهای-سرویس-وب">
4.26.4 دایرکتوری‌های سرویس وب
&lt;a class="anchor" href="#4264-%d8%af%d8%a7%db%8c%d8%b1%da%a9%d8%aa%d9%88%d8%b1%db%8c%d9%87%d8%a7%db%8c-%d8%b3%d8%b1%d9%88%db%8c%d8%b3-%d9%88%d8%a8">#&lt;/a>
&lt;/h3>
&lt;p>اجزای خاص برنامه وب: static web assets و templateهای سمت سرور و SPAها.&lt;/p>
&lt;h3 id="4265-دایرکتوریهای-مشترک-در-application">
4.26.5 دایرکتوری‌های مشترک در application
&lt;a class="anchor" href="#4265-%d8%af%d8%a7%db%8c%d8%b1%da%a9%d8%aa%d9%88%d8%b1%db%8c%d9%87%d8%a7%db%8c-%d9%85%d8%b4%d8%aa%d8%b1%da%a9-%d8%af%d8%b1-application">#&lt;/a>
&lt;/h3>
&lt;h3 id="configs">
&lt;code>/configs&lt;/code>
&lt;a class="anchor" href="#configs">#&lt;/a>
&lt;/h3>
&lt;p>قالب‌های فایل پیکربندی یا تنظیمات پیش‌فرض.
فایل‌های قالب &lt;code>confd&lt;/code> یا &lt;code>consul-template&lt;/code> خود را اینجا قرار دهید.&lt;/p>
&lt;h3 id="init">
&lt;code>/init&lt;/code>
&lt;a class="anchor" href="#init">#&lt;/a>
&lt;/h3>
&lt;p>پیکربندی‌های init سیستم (systemd، upstart، sysv) و process manager/supervisor (runit, supervisord).&lt;/p>
&lt;h3 id="scripts">
&lt;code>/scripts&lt;/code>
&lt;a class="anchor" href="#scripts">#&lt;/a>
&lt;/h3>
&lt;p>اسکریپت‌هایی برای انجام عملیات‌های مختلف build, install, analysis و غیره.
این اسکریپت‌ها Makefile سطح ریشه را کوچک و ساده نگه می‌دارند (به عنوان مثال،&lt;a href="https://github.com/hashicorp/terraform/blob/main/Makefile">&lt;code>https://github.com/hashicorp/terraform/blob/main/Makefile&lt;/code>&lt;/a>).
برای مثال به دایرکتوری &lt;a href="https://github.com/golang-standards/project-layout/blob/master/scripts/README.md">&lt;code>scripts/&lt;/code>&lt;/a> مراجعه کنید.&lt;/p>
&lt;h3 id="build">
&lt;code>/build&lt;/code>
&lt;a class="anchor" href="#build">#&lt;/a>
&lt;/h3>
&lt;p>‏برای Packaging و Continuous Integration&lt;/p>
&lt;ul>
&lt;li>پیکربندی‌ها و اسکریپت‌های package‌های ابری (AMI)، کانتینری (Docker)، سیستم‌عامل (deb، rpm، pkg) را در این دایرکتوری قرار دهید.&lt;/li>
&lt;/ul>
&lt;h3 id="build-1">
&lt;code>/build&lt;/code>
&lt;a class="anchor" href="#build-1">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>پیکربندی‌ها و اسکریپت‌های CI (travis، circle، drone) را در این دایرکتوری قرار دهید. توجه داشته باشید که برخی از ابزارهای CI (مانند Travis CI) در مورد مکان فایل‌های پیکربندی خود بسیار حساس هستند. سعی کنید فایل‌های پیکربندی را در دایرکتوری &lt;code>/build/ci&lt;/code> قرار داده و آن‌ها را به مکانی که ابزارهای CI انتظار دارند (در صورت امکان) لینک کنید.&lt;/li>
&lt;/ul>
&lt;h3 id="deployments">
&lt;code>/deployments&lt;/code>
&lt;a class="anchor" href="#deployments">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>پیکربندی‌ها و قالب‌های deployment یا استقرار IaaS، PaaS، سیستم و orchestration کانتینر (dockerCompose, kubernetes/helm, terraform). توجه داشته باشید که در برخی از repoها (به ویژه برنامه‌هایی که با kubernetes استقرار می‌یابند) این دایرکتوری &lt;code>deploy/&lt;/code> نامیده می‌شود.&lt;/li>
&lt;/ul>
&lt;h3 id="test">
&lt;code>/test&lt;/code>
&lt;a class="anchor" href="#test">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>برنامه‌های تست خارجی اضافی و داده‌های تست&lt;/strong>. می‌توانید دایرکتوری &lt;code>test/&lt;/code> را به هر شکلی که می‌خواهید ساختار دهید. برای پروژه‌های بزرگ‌تر، داشتن یک زیردایرکتوری data منطقی است. برای مثال، می‌توانید &lt;code>test/testdata/&lt;/code> یا &lt;code>test/data/&lt;/code> را داشته باشید اگر نیاز دارید که Go آنچه در آن دایرکتوری است را نادیده بگیرد. توجه داشته باشید که Go همچنین دایرکتوری‌ها یا فایل‌هایی که با &amp;ldquo;.&amp;rdquo; یا &amp;quot;&amp;quot; شروع می‌شوند را نادیده می‌گیرد، بنابراین در نحوه نام‌گذاری دایرکتوری داده‌های تست خود انعطاف بیشتری دارید.
برای نمونه‌ها به دایرکتوری &lt;a href="https://github.com/golang-standards/project-layout/blob/master/test/README.md">&lt;code>test/&lt;/code>&lt;/a>مراجعه کنید.&lt;/li>
&lt;/ul>
&lt;h2 id="دایرکتوریهای-دیگر">
دایرکتوری‌های دیگر
&lt;a class="anchor" href="#%d8%af%d8%a7%db%8c%d8%b1%da%a9%d8%aa%d9%88%d8%b1%db%8c%d9%87%d8%a7%db%8c-%d8%af%db%8c%da%af%d8%b1">#&lt;/a>
&lt;/h2>
&lt;p>اسناد طراحی و کاربر (علاوه بر مستندات ایجاد شده توسط godoc شما).
برای مثال به دایرکتوری &lt;a href="https://github.com/golang-standards/project-layout/blob/master/docs/README.md">&lt;code>docs/&lt;/code>&lt;/a> مراجعه کنید.&lt;/p>
&lt;h3 id="tools">
&lt;code>/tools&lt;/code>
&lt;a class="anchor" href="#tools">#&lt;/a>
&lt;/h3>
&lt;p>ابزارهای پشتیبانی این پروژه توجه داشته باشید که این ابزارها می توانند کد را از دایرکتوری های pkg/ و internal/ وارد کنند.
برای مثال به دایرکتوری tools/ مراجعه کنید.&lt;/p>
&lt;h3 id="examples">
&lt;code>/examples&lt;/code>
&lt;a class="anchor" href="#examples">#&lt;/a>
&lt;/h3>
&lt;p>نمونه‌هایی برای application و یا کتابخانه‌های public شما.
برای مثال به دایرکتوری &lt;a href="https://github.com/golang-standards/project-layout/blob/master/examples/README.md">&lt;code>examples/&lt;/code>&lt;/a> مراجعه کنید.&lt;/p>
&lt;h3 id="third_party">
&lt;code>/third_party&lt;/code>
&lt;a class="anchor" href="#third_party">#&lt;/a>
&lt;/h3>
&lt;p>ابزارهای کمکی خارجی، کد fork شده و سایر ابزارهای شخص ثالث (مانند Swagger UI).&lt;/p>
&lt;h3 id="githooks">
&lt;code>/githooks&lt;/code>
&lt;a class="anchor" href="#githooks">#&lt;/a>
&lt;/h3>
&lt;p>برای Git hooks.&lt;/p>
&lt;h3 id="assets">
&lt;code>/assets&lt;/code>
&lt;a class="anchor" href="#assets">#&lt;/a>
&lt;/h3>
&lt;p>سایر assetها برای همراهی با repository شما (image, logoها و غیره).&lt;/p>
&lt;h3 id="website">
&lt;code>/website&lt;/code>
&lt;a class="anchor" href="#website">#&lt;/a>
&lt;/h3>
&lt;p>اگر از GitHub pages استفاده نمی‌کنید، اینجا مکانی است که می توانید داده‌های وب‌سایت پروژه خود را قرار دهید.
برای مثال به دایرکتوری &lt;a href="https://github.com/golang-standards/project-layout/blob/master/website/README.md">&lt;code>website/&lt;/code>&lt;/a>مراجعه کنید.&lt;/p>
&lt;h2 id="دایرکتوریهایی-که-نباید-داشته-باشید">
دایرکتوری‌هایی که نباید داشته باشید
&lt;a class="anchor" href="#%d8%af%d8%a7%db%8c%d8%b1%da%a9%d8%aa%d9%88%d8%b1%db%8c%d9%87%d8%a7%db%8c%db%8c-%da%a9%d9%87-%d9%86%d8%a8%d8%a7%db%8c%d8%af-%d8%af%d8%a7%d8%b4%d8%aa%d9%87-%d8%a8%d8%a7%d8%b4%db%8c%d8%af">#&lt;/a>
&lt;/h2>
&lt;h3 id="src">
/src
&lt;a class="anchor" href="#src">#&lt;/a>
&lt;/h3>
&lt;p>برخی از پروژه‌های Go دارای یک پوشه &lt;code>src&lt;/code> هستند، اما این معمولاً زمانی اتفاق می‌افتد که توسعه‌دهندگان از دنیای جاوا آمده‌اند که در آنجا یک الگوی رایج است. اگر می‌توانید، سعی کنید این الگوی جاوا را نپذیرید. شما واقعاً نمی‌خواهید که کد Go یا پروژه‌های Go شما شبیه جاوا به نظر برسند :-)
دایرکتوری &lt;code>/src&lt;/code> در سطح پروژه را با دایرکتوری &lt;code>/src&lt;/code> که Go برای کارگاه‌های خود استفاده می‌کند، اشتباه نگیرید که در &lt;a href="https://golang.org/doc/code.html">&lt;code>How to Write Go Code&lt;/code>&lt;/a> توضیح داده شده است. &lt;code>$GOPATH&lt;/code> environment variable به (current) workspace فعلی شما اشاره می‌کند (به طور پیش‌فرض به &lt;code>$HOME/go&lt;/code> در سیستم‌های غیر ویندوزی اشاره می‌کند). این workspace شامل دایرکتوری‌های سطح بالا &lt;code>/pkg&lt;/code>, &lt;code>/bin&lt;/code> و &lt;code>/src&lt;/code> است. پروژه واقعی شما در نهایت یک زیردایرکتوری زیر &lt;code>/src&lt;/code> می‌شود، بنابراین اگر دایرکتوری &lt;code>/src&lt;/code> را در پروژه خود دارید، مسیر پروژه به این شکل خواهد بود: &lt;code>/some/path/to/workspace/src/your_project/src/your_code.go&lt;/code>. توجه داشته باشید که با Go 1.11 امکان دارد پروژه خود را خارج از &lt;code>GOPATH&lt;/code> خود داشته باشید، اما این هنوز به معنای این نیست که استفاده از این الگوی layout pattern ایده خوبی است.&lt;/p>
&lt;h3 id="4266--بررسی-badgeها">
4.26.6 بررسی Badgeها
&lt;a class="anchor" href="#4266--%d8%a8%d8%b1%d8%b1%d8%b3%db%8c-badge%d9%87%d8%a7">#&lt;/a>
&lt;/h3>
&lt;p>‏ &lt;a href="https://goreportcard.com/">Go Report Card&lt;/a>
کد شما را با gofmt، go vet، gocyclo، golint، ineffassign، مجوز و غلط املایی اسکن می کند. مرجع پروژه خود را جایگزین github.com/golang-standards/project-layout کنید.
&lt;a href="https://goreportcard.com/report/github.com/golang-standards/project-layout">&lt;img src="https://camo.githubusercontent.com/c1e1c210dea2e0410ecbb861999b969841a526d424818d7f9b816bd9f1364d55/68747470733a2f2f676f7265706f7274636172642e636f6d2f62616467652f6769746875622e636f6d2f676f6c616e672d7374616e64617264732f70726f6a6563742d6c61796f75743f7374796c653d666c61742d737175617265" alt="Go Report Card" />&lt;/a>
‏ &lt;del>&lt;a href="http://godoc.org/">GoDoc&lt;/a>&lt;/del>
&lt;del>این نسخه آنلاین اسناد تولید شده GoDoc شما را ارائه می‌دهد. link را تغییر دهید تا به پروژه شما اشاره کند.&lt;/del>
&lt;a href="http://godoc.org/github.com/golang-standards/project-layout">&lt;img src="https://camo.githubusercontent.com/fe1188b9f0668a1e0a543e1cbcc6fb28d50a52f74d04e99407f8e6405a7132cd/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f676f646f632d7265666572656e63652d626c75652e7376673f7374796c653d666c61742d737175617265" alt="Go Doc" />&lt;/a>
‏ &lt;a href="https://pkg.go.dev/">Pkg.go.dev&lt;/a>
‏ Pkg.go.dev مقصد جدیدی برای شناسایی و مستندات Go است. می‌توانید با استفاده از &lt;a href="https://pkg.go.dev/badge">badge generation tool&lt;/a>آن را ایجاد کنید.
&lt;a href="https://pkg.go.dev/github.com/golang-standards/project-layout">&lt;img src="https://camo.githubusercontent.com/2f374e52d47edc4ea0e93661bc0eb204743e26718e423a31ae87bac272385081/68747470733a2f2f706b672e676f2e6465762f62616467652f6769746875622e636f6d2f676f6c616e672d7374616e64617264732f70726f6a6563742d6c61796f7574" alt="PkgGoDev" />&lt;/a>
در مورد Release - آخرین شماره انتشار پروژه شما را نشان می دهد. لینک github را تغییر دهید تا به پروژه شما اشاره کند.&lt;/p>
&lt;h3 id="4268-نکتهها">
4.26.8 نکته‌ها
&lt;a class="anchor" href="#4268-%d9%86%da%a9%d8%aa%d9%87%d9%87%d8%a7">#&lt;/a>
&lt;/h3>
&lt;p>یک الگوی پروژه با نظر بیشتر با تنظیمات sample/reusable استفاده مجدد، اسکریپت‌ها و کد یک WIP است.&lt;/p></description></item><item><author/><title>4.27 آموزش کار با پکیج io</title><link>https://book.gofarsi.ir/chapter-4/go-io-package/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/go-io-package/</guid><description>&lt;p align="center">
&lt;img src="../../assets/img/content/chapter4/io/go-io.png" alt="io">
&lt;/p>
&lt;p>پکیج &lt;code>io&lt;/code> در زبان Go یکی از ابزارهای پایه و همه‌فن‌حریف برای کار با عملیات &lt;span class="tooltip" data-tooltip="ورودی/خروجی" ontouchend="toggleTooltip(this)">Input/Output&lt;/span>
است. فلسفه‌اش اینه که ما بدون وابستگی به نوع خاص داده (مثل فایل، شبکه یا حافظه) بتونیم از یک &lt;span class="tooltip" data-tooltip="رابط" ontouchend="toggleTooltip(this)">Interface&lt;/span>
ساده استفاده کنیم. این یعنی اگر یک شیء فقط متد مورد نیاز رو پیاده‌سازی کنه، می‌تونه در تمام جاهایی که اون رابط انتظار میره استفاده بشه. مثلا &lt;code>io.Reader&lt;/code> فقط یک متد &lt;code>Read&lt;/code> داره و &lt;code>io.Writer&lt;/code> یک متد &lt;code>Write&lt;/code>، ولی همین دو قرارداد ساده پایه تمام سیستم &lt;span class="tooltip" data-tooltip="انتزاع ورودی/خروجی" ontouchend="toggleTooltip(this)">I/O Abstraction&lt;/span>
در Go رو تشکیل میدن.&lt;/p>
&lt;p>اینترفیس‌های اصلی این پکیج مثل &lt;code>io.Reader&lt;/code> و &lt;code>io.Writer&lt;/code> رو میشه ترکیب کرد و ساختارهای جدیدی ساخت، مثل &lt;code>io.ReadWriter&lt;/code> که هم قابلیت خواندن داره و هم نوشتن، یا &lt;code>io.ReadCloser&lt;/code> که علاوه بر خواندن، قابلیت بستن منبع داده رو هم فراهم می‌کنه. این ترکیب‌ها به ما امکان میدن با منابع داده‌ای مختلف، از فایل گرفته تا اتصال شبکه، به شکلی یکپارچه کار کنیم. وقتی کد رو بر اساس اینترفیس‌ها بنویسیم، نه‌تنها تست‌پذیرتر و قابل توسعه‌تر میشه، بلکه وابستگی به پیاده‌سازی‌های خاص هم از بین میره.&lt;/p>
&lt;p>پکیج &lt;code>io&lt;/code> فقط به رابط‌ها محدود نیست و مجموعه‌ای از &lt;span class="tooltip" data-tooltip="توابع کمکی" ontouchend="toggleTooltip(this)">Helper Functions&lt;/span>
رو هم ارائه میده که کار رو به شدت ساده‌تر و بهینه‌تر می‌کنن. مثلا &lt;code>io.Copy&lt;/code> داده رو مستقیم از یک &lt;code>Reader&lt;/code> به یک &lt;code>Writer&lt;/code> منتقل می‌کنه بدون اینکه ما نیاز به نوشتن حلقه خواندن و نوشتن داشته باشیم. &lt;code>io.MultiWriter&lt;/code> خروجی رو به چند مقصد به طور همزمان ارسال می‌کنه، و &lt;code>io.TeeReader&lt;/code> برای زمانی که می‌خوای داده رو بخونی و همزمان یک نسخه ازش رو برای &lt;span class="tooltip" data-tooltip="ثبت رویداد" ontouchend="toggleTooltip(this)">Logging&lt;/span>
یا &lt;span class="tooltip" data-tooltip="اشکال‌زدایی" ontouchend="toggleTooltip(this)">Debugging&lt;/span>
ذخیره کنی عالیه. همچنین ابزارهایی مثل &lt;code>io.LimitReader&lt;/code> یا &lt;code>io.SectionReader&lt;/code> وجود دارن که اجازه میدن فقط بخش خاصی از داده رو پردازش کنیم.&lt;/p>
&lt;p>در بخش پیشرفته‌تر، این پکیج امکاناتی مثل &lt;code>io.Pipe&lt;/code> رو هم ارائه میده که دو سر ورودی و خروجی رو به هم وصل می‌کنه و به‌ویژه برای &lt;span class="tooltip" data-tooltip="جریان داده" ontouchend="toggleTooltip(this)">Streaming&lt;/span>
و ارتباط بین &lt;span class="tooltip" data-tooltip="گوروتین‌ها" ontouchend="toggleTooltip(this)">Goroutines&lt;/span>
بسیار کاربردیه. نکته مهم توی استفاده از این پکیج مدیریت درست خطاست؛ مثلا تفاوت &lt;code>io.EOF&lt;/code> که فقط نشون‌دهنده پایان داده‌ست با یک خطای واقعی رو باید بدونیم. همچنین استفاده از بافرها (&lt;code>bufio&lt;/code>) برای بهبود کارایی و کاهش هزینه I/O در پروژه‌های &lt;span class="tooltip" data-tooltip="محیط عملیاتی" ontouchend="toggleTooltip(this)">Production&lt;/span>
توصیه میشه.&lt;/p>
&lt;h2 id="4271-معرفی-پکیج-io-و-فلسفه-طراحی">
4.27.1 معرفی پکیج io و فلسفه طراحی
&lt;a class="anchor" href="#4271-%d9%85%d8%b9%d8%b1%d9%81%db%8c-%d9%be%da%a9%db%8c%d8%ac-io-%d9%88-%d9%81%d9%84%d8%b3%d9%81%d9%87-%d8%b7%d8%b1%d8%a7%d8%ad%db%8c">#&lt;/a>
&lt;/h2>
&lt;p>پکیج &lt;code>io&lt;/code> در زبان Go یک بخش کلیدی از کتابخانه استاندارد است که پایه و اساس تمام عملیات &lt;span class="tooltip" data-tooltip="ورودی/خروجی" ontouchend="toggleTooltip(this)">Input/Output&lt;/span>
را فراهم می‌کند. هدف اصلی این پکیج، ایجاد یک &lt;span class="tooltip" data-tooltip="انتزاع" ontouchend="toggleTooltip(this)">Abstraction&lt;/span>
ساده اما قدرتمند برای خواندن و نوشتن داده است، بدون این‌که برنامه‌نویس به منبع یا مقصد خاصی وابسته باشد. این یعنی چه داده از یک فایل بیاید، چه از یک اتصال شبکه یا حتی از حافظه، کدی که آن را پردازش می‌کند یکسان خواهد بود.&lt;/p>
&lt;p>در قلب این پکیج دو &lt;span class="tooltip" data-tooltip="رابط" ontouchend="toggleTooltip(this)">Interface&lt;/span>
بسیار ساده قرار دارند: &lt;code>io.Reader&lt;/code> و &lt;code>io.Writer&lt;/code>.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;code>io.Reader&lt;/code>&lt;/strong>: فقط یک متد &lt;code>Read&lt;/code> دارد که داده را به صورت بایت‌اسلایس می‌خواند.&lt;/li>
&lt;li>&lt;strong>&lt;code>io.Writer&lt;/code>&lt;/strong>: فقط یک متد &lt;code>Write&lt;/code> دارد که داده را به یک مقصد ارسال می‌کند.&lt;/li>
&lt;/ul>
&lt;p>هر نوعی (type) که این متدها را پیاده‌سازی کند، به طور خودکار به یک منبع یا مقصد داده قابل استفاده در اکوسیستم &lt;code>io&lt;/code> تبدیل می‌شود. همین سادگی باعث شده که اجزای مختلف سیستم، از جمله پکیج‌هایی مثل &lt;code>os&lt;/code>، &lt;code>net&lt;/code>، &lt;code>bufio&lt;/code> و &lt;code>compress&lt;/code>، بتوانند به راحتی با هم ترکیب شوند.&lt;/p>
&lt;p>یکی از مزیت‌های بزرگ این طراحی این است که به‌جای وابستگی به نوع خاص، وابستگی به رفتار داریم. مثلا تابعی که یک &lt;code>io.Reader&lt;/code> را می‌گیرد، می‌تواند بدون تغییر، هم از یک فایل روی دیسک بخواند و هم از یک جریان داده آنلاین یا حتی داده تولیدشده در حافظه. این قابلیت انعطاف‌پذیری بالا را ممکن می‌سازد و کد را برای تست و توسعه آسان‌تر می‌کند.&lt;/p>
&lt;p>در نتیجه، پکیج &lt;code>io&lt;/code> نه فقط یک ابزار برای کار با داده، بلکه یک لایه انتزاعی است که ساختار و معماری برنامه را ساده، منسجم و مقیاس‌پذیر نگه می‌دارد. این فلسفه مینیمالیستی و ماژولار، از دلایلی است که Go را برای پروژه‌های بزرگ و طولانی‌مدت به انتخابی محبوب تبدیل کرده است.&lt;/p>
&lt;h3 id="42711-اهمیت-abstraction-در-io">
4.27.1.1 اهمیت abstraction در I/O
&lt;a class="anchor" href="#42711-%d8%a7%d9%87%d9%85%db%8c%d8%aa-abstraction-%d8%af%d8%b1-io">#&lt;/a>
&lt;/h3>
&lt;p>وقتی صحبت از &lt;span class="tooltip" data-tooltip="ورودی/خروجی" ontouchend="toggleTooltip(this)">Input/Output&lt;/span>
می‌شود، خیلی‌ها اولین چیزی که به ذهنشان می‌رسد یک فایل روی دیسک یا یک اتصال شبکه است. اما در عمل، منابع داده می‌توانند بسیار متنوع باشند: یک فایل محلی، یک API، یک بافر حافظه، یا حتی داده تولیدشده لحظه‌ای توسط یک الگوریتم. اگر برای هر کدام بخواهیم کد جداگانه بنویسیم، خیلی زود با یک مجموعه توابع و کلاس‌های تکراری و پیچیده روبه‌رو می‌شویم که نگهداری آن‌ها کابوس خواهد بود.&lt;/p>
&lt;p>اینجاست که &lt;span class="tooltip" data-tooltip="انتزاع" ontouchend="toggleTooltip(this)">Abstraction&lt;/span>
وارد میدان می‌شود. با تعریف یک &lt;span class="tooltip" data-tooltip="رابط" ontouchend="toggleTooltip(this)">Interface&lt;/span>
مشترک مثل &lt;code>io.Reader&lt;/code> یا &lt;code>io.Writer&lt;/code>، می‌توانیم منطق اصلی کد را مستقل از منبع یا مقصد داده بنویسیم. این یعنی یک تابعی که داده را از ورودی می‌خواند و روی خروجی می‌نویسد، می‌تواند بدون تغییر هم روی فایل کار کند، هم روی شبکه، و هم روی داده‌های در حافظه.&lt;/p>
&lt;p>مثلا تصور کنید می‌خواهیم یک تابع بنویسیم که محتوا را از یک &lt;span class="tooltip" data-tooltip="خواننده" ontouchend="toggleTooltip(this)">Reader&lt;/span>
به یک &lt;span class="tooltip" data-tooltip="نویسنده" ontouchend="toggleTooltip(this)">Writer&lt;/span>
منتقل کند:&lt;/p>
&lt;pre>&lt;code class="language-go">func TransferData(src io.Reader, dst io.Writer) error {
_, err := io.Copy(dst, src)
return err
}
&lt;/code>&lt;/pre>
&lt;p>این تابع اصلاً اهمیتی نمی‌دهد که &lt;code>src&lt;/code> یک فایل است (&lt;code>*os.File&lt;/code>)، یک اتصال TCP (&lt;code>net.Conn&lt;/code>) یا حتی یک رشته متنی در حافظه (&lt;code>strings.Reader&lt;/code>). کافی است آن منبع متد &lt;code>Read&lt;/code> را داشته باشد. همین موضوع باعث می‌شود کد قابل استفاده مجدد، ساده و به راحتی تست‌پذیر شود.&lt;/p>
&lt;p>به این شکل، abstraction در I/O مثل یک پل عمل می‌کند که لایه منطق برنامه را از جزئیات فنی منابع داده جدا می‌کند. این کار نه تنها خوانایی و نگهداری کد را بهتر می‌کند، بلکه توسعه ویژگی‌های جدید را هم سریع‌تر و بی‌خطرتر می‌سازد.&lt;/p>
&lt;h3 id="42712-نقش-io-در-کتابخانه-استاندارد-go">
4.27.1.2 نقش io در کتابخانه استاندارد Go
&lt;a class="anchor" href="#42712-%d9%86%d9%82%d8%b4-io-%d8%af%d8%b1-%da%a9%d8%aa%d8%a7%d8%a8%d8%ae%d8%a7%d9%86%d9%87-%d8%a7%d8%b3%d8%aa%d8%a7%d9%86%d8%af%d8%a7%d8%b1%d8%af-go">#&lt;/a>
&lt;/h3>
&lt;p>پکیج &lt;code>io&lt;/code> رو میشه به‌نوعی ستون فقرات عملیات &lt;span class="tooltip" data-tooltip="ورودی/خروجی" ontouchend="toggleTooltip(this)">Input/Output&lt;/span>
در کل اکوسیستم Go دونست. خیلی از پکیج‌های کتابخانه استاندارد روی همین رابط‌های ساده &lt;code>io.Reader&lt;/code> و &lt;code>io.Writer&lt;/code> ساخته شدن. این یعنی وقتی با اینترفیس‌های &lt;code>io&lt;/code> کار می‌کنید، عملاً دارید با یک استاندارد مشترک صحبت می‌کنید که بقیه پکیج‌ها هم اون رو می‌فهمن.&lt;/p>
&lt;p>برای مثال:&lt;/p>
&lt;ul>
&lt;li>پکیج &lt;code>os&lt;/code> که برای کار با فایل‌ها استفاده میشه، وقتی فایل رو با &lt;code>os.Open&lt;/code> باز می‌کنید، یک شیء برمی‌گردونه که هم &lt;code>io.Reader&lt;/code> هست، هم &lt;code>io.Writer&lt;/code>، هم &lt;code>io.Seeker&lt;/code> و هم &lt;code>io.Closer&lt;/code>.&lt;/li>
&lt;li>پکیج &lt;code>net&lt;/code> برای کار با شبکه، اتصالات TCP و HTTP رو به شکلی پیاده‌سازی کرده که اون‌ها هم این اینترفیس‌ها رو داشته باشن.&lt;/li>
&lt;li>پکیج &lt;code>bufio&lt;/code> که برای افزایش کارایی از بافر استفاده می‌کنه، عملاً روی همین رابط‌ها سوار شده و می‌تونه هر چیزی که &lt;code>io.Reader&lt;/code> یا &lt;code>io.Writer&lt;/code> باشه رو بپذیره.&lt;/li>
&lt;li>پکیج‌های فشرده‌سازی مثل &lt;code>compress/gzip&lt;/code> و &lt;code>compress/zlib&lt;/code> هم با همین استاندارد کار می‌کنن، بنابراین می‌تونید یک فایل gzip رو بخونید و بدون تغییر خاصی روی خروجی HTTP بفرستید.&lt;/li>
&lt;/ul>
&lt;p>این یکپارچگی باعث میشه بتونید اجزای مختلف رو خیلی راحت به هم وصل کنید. مثلا می‌تونید یک فایل فشرده رو باز کنید، خروجیش رو مستقیم از طریق شبکه بفرستید، یا برعکس داده‌های دریافتی رو مستقیماً داخل یک فایل ذخیره کنید، همه این‌ها فقط با چند خط کد.&lt;/p>
&lt;p>در واقع پکیج &lt;code>io&lt;/code> نقش یک زبان مشترک رو بین اجزای مختلف Go بازی می‌کنه. وقتی هر منبع یا مقصد داده این رابط‌ها رو پیاده‌سازی می‌کنه، شما می‌تونید اون‌ها رو به صورت ماژولار ترکیب کنید و بدون دغدغه از تفاوت‌های داخلی هر منبع، به یک جریان داده واحد برسید. این دقیقاً همون چیزی هست که Go رو در پروژه‌های بزرگ و چندبخشی، ساده و قابل اعتماد نگه می‌داره.&lt;/p>
&lt;h2 id="4272-اینترفیسهای-اصلی-پکیج-io">
4.27.2 اینترفیس‌های اصلی پکیج io
&lt;a class="anchor" href="#4272-%d8%a7%db%8c%d9%86%d8%aa%d8%b1%d9%81%db%8c%d8%b3%d9%87%d8%a7%db%8c-%d8%a7%d8%b5%d9%84%db%8c-%d9%be%da%a9%db%8c%d8%ac-io">#&lt;/a>
&lt;/h2>
&lt;p>پکیج &lt;code>io&lt;/code> بر پایه چند &lt;span class="tooltip" data-tooltip="رابط" ontouchend="toggleTooltip(this)">Interface&lt;/span>
کلیدی ساخته شده که هر کدوم رفتار مشخصی رو تعریف می‌کنن. این اینترفیس‌ها شبیه یک قرارداد عمل می‌کنن؛ هر نوعی که این قرارداد رو پیاده‌سازی کنه، می‌تونه به عنوان ورودی یا خروجی در هر کدی که با اون اینترفیس کار می‌کنه استفاده بشه. این رویکرد باعث میشه کدها انعطاف‌پذیر، قابل توسعه و ماژولار باقی بمونن.&lt;/p>
&lt;h3 id="42721-ioreader-و-متد-read">
4.27.2.1 io.Reader و متد Read
&lt;a class="anchor" href="#42721-ioreader-%d9%88-%d9%85%d8%aa%d8%af-read">#&lt;/a>
&lt;/h3>
&lt;p>&lt;code>io.Reader&lt;/code> مهم‌ترین و پرکاربردترین اینترفیس پکیج &lt;code>io&lt;/code> است:&lt;/p>
&lt;pre>&lt;code class="language-go">type Reader interface {
Read(p []byte) (n int, err error)
}
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>پارامتر &lt;code>p&lt;/code>&lt;/strong>: یک &lt;span class="tooltip" data-tooltip="برش بایت" ontouchend="toggleTooltip(this)">Byte Slice&lt;/span>
است که داده‌ها در آن قرار می‌گیرند.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>برگشتی &lt;code>n&lt;/code>&lt;/strong>: تعداد بایت‌هایی که خوانده شده.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>برگشتی &lt;code>err&lt;/code>&lt;/strong>: اگر خطایی رخ دهد برگردانده می‌شود، که ممکن است &lt;code>io.EOF&lt;/code> باشد تا پایان داده را نشان دهد.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>هر نوعی که این متد را پیاده‌سازی کند، می‌تواند به عنوان یک Reader استفاده شود. این منبع داده می‌تواند یک فایل، شبکه، حافظه یا هر چیز دیگری باشد.&lt;/p>
&lt;p>مثال ساده خواندن از یک رشته:&lt;/p>
&lt;pre>&lt;code class="language-go">r := strings.NewReader(&amp;quot;Hello IO&amp;quot;)
buf := make([]byte, 4)
for {
n, err := r.Read(buf)
fmt.Printf(&amp;quot;Read: %s\n&amp;quot;, buf[:n])
if err == io.EOF {
break
}
}
&lt;/code>&lt;/pre>
&lt;p>یک مثال کامل:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"fmt"
"io"
"strings"
)
func main() {
r := strings.NewReader("Hello IO")
buf := make([]byte, 4)
for {
n, err := r.Read(buf)
if n > 0 {
fmt.Printf("Read: %s\n", buf[:n])
}
if err == io.EOF {
break
}
if err != nil {
fmt.Println("Error:", err)
break
}
}
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;h3 id="42722-iowriter-و-متد-write">
4.27.2.2 io.Writer و متد Write
&lt;a class="anchor" href="#42722-iowriter-%d9%88-%d9%85%d8%aa%d8%af-write">#&lt;/a>
&lt;/h3>
&lt;p>&lt;code>io.Writer&lt;/code> مکمل &lt;code>io.Reader&lt;/code> است:&lt;/p>
&lt;pre>&lt;code class="language-go">type Writer interface {
Write(p []byte) (n int, err error)
}
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>&lt;strong>پارامتر &lt;code>p&lt;/code>&lt;/strong>: داده‌هایی که باید نوشته شوند.&lt;/li>
&lt;li>&lt;strong>برگشتی &lt;code>n&lt;/code>&lt;/strong>: تعداد بایت‌هایی که نوشته شده‌اند.&lt;/li>
&lt;li>&lt;strong>برگشتی &lt;code>err&lt;/code>&lt;/strong>: خطا هنگام نوشتن (مثلاً فضای ناکافی یا قطع ارتباط).&lt;/li>
&lt;/ul>
&lt;p>هر چیزی که متد &lt;code>Write&lt;/code> را داشته باشد، می‌تواند مقصد داده باشد، چه این مقصد یک فایل باشد، چه یک اتصال شبکه یا حتی یک بافر حافظه.&lt;/p>
&lt;p>مثال ساده نوشتن روی خروجی استاندارد:&lt;/p>
&lt;pre>&lt;code class="language-go">msg := []byte(&amp;quot;Hello Writer\n&amp;quot;)
os.Stdout.Write(msg)
&lt;/code>&lt;/pre>
&lt;p>مثال کامل:
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"os"
)
func main() {
msg := []byte("Hello Writer\n")
_, err := os.Stdout.Write(msg)
if err != nil {
panic(err)
}
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;/p>
&lt;h3 id="42723-ترکیب-اینترفیسها">
4.27.2.3 ترکیب اینترفیس‌ها
&lt;a class="anchor" href="#42723-%d8%aa%d8%b1%da%a9%db%8c%d8%a8-%d8%a7%db%8c%d9%86%d8%aa%d8%b1%d9%81%db%8c%d8%b3%d9%87%d8%a7">#&lt;/a>
&lt;/h3>
&lt;p>در پکیج &lt;code>io&lt;/code>، اینترفیس‌ها می‌توانند با هم ترکیب شوند تا قابلیت‌های بیشتری ارائه دهند:&lt;/p>
&lt;ul>
&lt;li>&lt;code>io.ReadWriter&lt;/code>: ترکیب Reader و Writer.&lt;/li>
&lt;li>&lt;code>io.ReadCloser&lt;/code>: ترکیب Reader و &lt;span class="tooltip" data-tooltip="بستن منبع داده" ontouchend="toggleTooltip(this)">Closer&lt;/span>
.&lt;/li>
&lt;li>&lt;code>io.WriteCloser&lt;/code>: ترکیب Writer و Closer.&lt;/li>
&lt;li>&lt;code>io.ReadWriteCloser&lt;/code>: ترکیب Reader، Writer و Closer.&lt;/li>
&lt;/ul>
&lt;p>این ترکیب‌ها باعث می‌شوند بتوانید منابع داده‌ای داشته باشید که چندین قابلیت را همزمان ارائه می‌دهند، مثل یک فایل که هم قابل خواندن است، هم نوشتن و هم بستن.&lt;/p>
&lt;p>به عنوان مثال:
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"fmt"
"os"
)
func main() {
// os.File هم Reader است، هم Writer، هم Closer
file, err := os.Create("example.txt")
if err != nil {
panic(err)
}
defer file.Close()
_, err = file.Write([]byte("Hello File\n"))
if err != nil {
panic(err)
}
fmt.Println("Data written to example.txt successfully")
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;/p>
&lt;h3 id="42724-ioseeker-و-جابهجایی-در-دادهها">
4.27.2.4 io.Seeker و جابه‌جایی در داده‌ها
&lt;a class="anchor" href="#42724-ioseeker-%d9%88-%d8%ac%d8%a7%d8%a8%d9%87%d8%ac%d8%a7%db%8c%db%8c-%d8%af%d8%b1-%d8%af%d8%a7%d8%af%d9%87%d9%87%d8%a7">#&lt;/a>
&lt;/h3>
&lt;p>&lt;code>io.Seeker&lt;/code> امکان حرکت در یک منبع داده را فراهم می‌کند:&lt;/p>
&lt;pre>&lt;code class="language-go">type Seeker interface {
Seek(offset int64, whence int) (int64, error)
}
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>&lt;strong>offset&lt;/strong>: تعداد بایت‌هایی که باید جابه‌جا شود.&lt;/li>
&lt;li>&lt;strong>whence&lt;/strong>: نقطه مرجع برای جابه‌جایی (&lt;code>io.SeekStart&lt;/code>, &lt;code>io.SeekCurrent&lt;/code>, &lt;code>io.SeekEnd&lt;/code>).&lt;/li>
&lt;/ul>
&lt;p>مثال تغییر مکان در یک فایل:&lt;/p>
&lt;pre>&lt;code class="language-go">file, _ := os.Open(&amp;quot;data.txt&amp;quot;)
file.Seek(10, io.SeekStart) // حرکت به بایت دهم از ابتدای فایل
&lt;/code>&lt;/pre>
&lt;p>&lt;code>io.Seeker&lt;/code> معمولاً همراه Reader یا Writer استفاده می‌شود و برای کار با داده‌هایی که نیاز به دسترسی تصادفی دارند (مثل پایگاه داده یا فرمت‌های باینری خاص) ضروری است.&lt;/p>
&lt;p>به عنوان مثال:
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"fmt"
"io"
"os"
)
func main() {
file, err := os.Create("seek.txt")
if err != nil {
panic(err)
}
defer file.Close()
// نوشتن داده اولیه
file.Write([]byte("0123456789"))
// رفتن به بایت پنجم
_, err = file.Seek(5, io.SeekStart)
if err != nil {
panic(err)
}
// بازنویسی از بایت پنجم به بعد
file.Write([]byte("XYZ"))
fmt.Println("File updated successfully")
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;/p>
&lt;h2 id="4273-توابع-کمکی-کاربردی">
4.27.3 توابع کمکی کاربردی
&lt;a class="anchor" href="#4273-%d8%aa%d9%88%d8%a7%d8%a8%d8%b9-%da%a9%d9%85%da%a9%db%8c-%da%a9%d8%a7%d8%b1%d8%a8%d8%b1%d8%af%db%8c">#&lt;/a>
&lt;/h2>
&lt;p>پکیج &lt;code>io&lt;/code> علاوه بر &lt;span class="tooltip" data-tooltip="رابط" ontouchend="toggleTooltip(this)">Interface&lt;/span>
‌های پایه، یک سری &lt;span class="tooltip" data-tooltip="توابع کمکی" ontouchend="toggleTooltip(this)">Helper Functions&lt;/span>
هم دارد که خیلی از عملیات رایج I/O را ساده‌تر و بهینه‌تر انجام می‌دهند. این توابع باعث می‌شوند دیگر لازم نباشد حلقه‌های دستی برای خواندن و نوشتن بنویسیم و در عین حال از پیاده‌سازی‌های بهینه Go هم استفاده کنیم.&lt;/p>
&lt;h3 id="42731-iocopy-و-iocopyn">
4.27.3.1 io.Copy و io.CopyN
&lt;a class="anchor" href="#42731-iocopy-%d9%88-iocopyn">#&lt;/a>
&lt;/h3>
&lt;p>تابع &lt;code>io.Copy&lt;/code> داده را از یک &lt;code>io.Reader&lt;/code> به یک &lt;code>io.Writer&lt;/code> منتقل می‌کند تا زمانی که منبع به انتها برسد یا خطایی رخ دهد.&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;fmt&amp;quot;
&amp;quot;io&amp;quot;
&amp;quot;os&amp;quot;
&amp;quot;strings&amp;quot;
)
func main() {
src := strings.NewReader(&amp;quot;Hello io.Copy\n&amp;quot;)
_, err := io.Copy(os.Stdout, src)
if err != nil {
panic(err)
}
fmt.Println(&amp;quot;Copy completed successfully&amp;quot;)
}
&lt;/code>&lt;/pre>
&lt;p>اگر بخواهیم فقط تعداد مشخصی بایت منتقل کنیم، می‌توانیم از &lt;code>io.CopyN&lt;/code> استفاده کنیم:&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;fmt&amp;quot;
&amp;quot;io&amp;quot;
&amp;quot;os&amp;quot;
&amp;quot;strings&amp;quot;
)
func main() {
src := strings.NewReader(&amp;quot;ABCDEFGH&amp;quot;)
_, err := io.CopyN(os.Stdout, src, 4)
if err != nil {
panic(err)
}
fmt.Println(&amp;quot;\nCopyN completed successfully&amp;quot;)
}
&lt;/code>&lt;/pre>
&lt;h3 id="42732-iomultireader-و-iomultiwriter">
4.27.3.2 io.MultiReader و io.MultiWriter
&lt;a class="anchor" href="#42732-iomultireader-%d9%88-iomultiwriter">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>&lt;code>io.MultiReader&lt;/code>&lt;/strong> چند Reader را به هم وصل می‌کند تا خروجی‌شان پشت سر هم خوانده شود.&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;io&amp;quot;
&amp;quot;os&amp;quot;
&amp;quot;strings&amp;quot;
)
func main() {
r1 := strings.NewReader(&amp;quot;Hello &amp;quot;)
r2 := strings.NewReader(&amp;quot;World\n&amp;quot;)
mr := io.MultiReader(r1, r2)
io.Copy(os.Stdout, mr)
}
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>&lt;strong>&lt;code>io.MultiWriter&lt;/code>&lt;/strong> داده را همزمان به چند Writer ارسال می‌کند.&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;io&amp;quot;
&amp;quot;os&amp;quot;
&amp;quot;strings&amp;quot;
)
func main() {
file, _ := os.Create(&amp;quot;multi.txt&amp;quot;)
defer file.Close()
mw := io.MultiWriter(os.Stdout, file)
io.Copy(mw, strings.NewReader(&amp;quot;Hello MultiWriter\n&amp;quot;))
}
&lt;/code>&lt;/pre>
&lt;h3 id="42733-ioteereader">
4.27.3.3 io.TeeReader
&lt;a class="anchor" href="#42733-ioteereader">#&lt;/a>
&lt;/h3>
&lt;p>&lt;code>io.TeeReader&lt;/code> داده را از یک Reader می‌خواند و در حین خواندن، همان داده را در یک Writer هم می‌نویسد.&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;io&amp;quot;
&amp;quot;os&amp;quot;
&amp;quot;strings&amp;quot;
)
func main() {
src := strings.NewReader(&amp;quot;Hello TeeReader\n&amp;quot;)
tr := io.TeeReader(src, os.Stdout)
// خواندن کامل باعث می‌شود داده هم روی stdout نوشته شود
io.ReadAll(tr)
}
&lt;/code>&lt;/pre>
&lt;h3 id="42734-iolimitreader-و-iolimitwriter">
4.27.3.4 io.LimitReader و io.LimitWriter
&lt;a class="anchor" href="#42734-iolimitreader-%d9%88-iolimitwriter">#&lt;/a>
&lt;/h3>
&lt;p>این توابع حجم داده را محدود می‌کنند.&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;io&amp;quot;
&amp;quot;os&amp;quot;
&amp;quot;strings&amp;quot;
)
func main() {
src := strings.NewReader(&amp;quot;This is a long text&amp;quot;)
limited := io.LimitReader(src, 7)
io.Copy(os.Stdout, limited) // فقط ۷ بایت اول چاپ می‌شود
}
&lt;/code>&lt;/pre>
&lt;h3 id="42735-ioreadall">
4.27.3.5 io.ReadAll
&lt;a class="anchor" href="#42735-ioreadall">#&lt;/a>
&lt;/h3>
&lt;p>&lt;code>io.ReadAll&lt;/code> تمام داده را تا پایان منبع (&lt;code>io.EOF&lt;/code>) می‌خواند و در حافظه نگه می‌دارد (برای داده‌های بزرگ باید با احتیاط استفاده شود).&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;fmt&amp;quot;
&amp;quot;io&amp;quot;
&amp;quot;strings&amp;quot;
)
func main() {
data := strings.NewReader(&amp;quot;ReadAll example&amp;quot;)
all, err := io.ReadAll(data)
if err != nil {
panic(err)
}
fmt.Println(string(all))
}
&lt;/code>&lt;/pre>
&lt;h3 id="42736-iosectionreader">
4.27.3.6 io.SectionReader
&lt;a class="anchor" href="#42736-iosectionreader">#&lt;/a>
&lt;/h3>
&lt;p>&lt;code>io.SectionReader&lt;/code> اجازه می‌دهد فقط بخشی از یک منبع داده را بخوانیم.&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;fmt&amp;quot;
&amp;quot;io&amp;quot;
&amp;quot;os&amp;quot;
)
func main() {
file, _ := os.Open(&amp;quot;section.txt&amp;quot;)
defer file.Close()
// فرض می‌کنیم فایل حداقل ۱۰ بایت دارد
section := io.NewSectionReader(file, 3, 5) // از بایت سوم، ۵ بایت بخوان
buf := make([]byte, 5)
_, err := section.Read(buf)
if err != nil &amp;amp;&amp;amp; err != io.EOF {
panic(err)
}
fmt.Printf(&amp;quot;Section data: %s\n&amp;quot;, buf)
}
&lt;/code>&lt;/pre>
&lt;h2 id="4274-کار-با-iopipe-و-ارتباط-بین-goroutines">
4.27.4 کار با io.Pipe و ارتباط بین Goroutines
&lt;a class="anchor" href="#4274-%da%a9%d8%a7%d8%b1-%d8%a8%d8%a7-iopipe-%d9%88-%d8%a7%d8%b1%d8%aa%d8%a8%d8%a7%d8%b7-%d8%a8%db%8c%d9%86-goroutines">#&lt;/a>
&lt;/h2>
&lt;p>پکیج &lt;code>io&lt;/code> یک ابزار جالب و قدرتمند به اسم &lt;code>io.Pipe&lt;/code> داره که برای اتصال مستقیم دو &lt;strong>goroutine&lt;/strong> به هم استفاده میشه. ایده اینه که یک goroutine داده‌ها رو به &lt;code>PipeWriter&lt;/code> می‌نویسه و یک goroutine دیگه همون لحظه اون داده‌ها رو از &lt;code>PipeReader&lt;/code> می‌خونه؛ یعنی بینشون یک کانال داده با API شبیه &lt;code>io.Reader&lt;/code>/&lt;code>io.Writer&lt;/code> ایجاد میشه.&lt;/p>
&lt;p>برخلاف فایل یا بافر، &lt;code>io.Pipe&lt;/code> داده رو جایی ذخیره نمی‌کنه؛ بلکه هر چیزی که نوشته میشه، باید همون لحظه توسط Reader خونده بشه. اگه Reader آماده نباشه، Writer بلاک میشه، و برعکس. این باعث میشه برای &lt;strong>streaming real-time&lt;/strong> یا پردازش خط‌به‌خط داده عالی باشه، بدون اینکه کل داده تو حافظه بارگذاری بشه.&lt;/p>
&lt;p>یک کاربرد مهمش وقتی هست که بخوای داده رو از یک منبع بخونی، قبل از ذخیره یا ارسال، پردازش کنی، و نتیجه رو به مقصد برسونی — و این کار رو با چند goroutine موازی انجام بدی. برای مثال، در کتاب‌های مرجع هم توضیح داده شده که &lt;code>io.Pipe&lt;/code> برای اتصال encoder/decoder به ورودی یا خروجی در لحظه عالیه، مثل گرفتن خروجی یک پردازش و ارسال مستقیمش به gzip بدون ذخیره‌ی موقت.&lt;/p>
&lt;h2 id="42741-مفاهیم-pipereader-و-pipewriter">
4.27.4.1 مفاهیم PipeReader و PipeWriter
&lt;a class="anchor" href="#42741-%d9%85%d9%81%d8%a7%d9%87%db%8c%d9%85-pipereader-%d9%88-pipewriter">#&lt;/a>
&lt;/h2>
&lt;p>&lt;code>&lt;span class="tooltip" data-tooltip="PipeReader / PipeWriter" ontouchend="toggleTooltip(this)">io.Pipe&lt;/span>
&lt;/code> یه &lt;strong>لولهٔ درون‌حافظه‌ای&lt;/strong> می‌سازه: یه سرش &lt;code>&lt;span class="tooltip" data-tooltip="انتهای خواندن pipe" ontouchend="toggleTooltip(this)">*io.PipeReader&lt;/span>
&lt;/code> و سر دیگه‌ش &lt;code>&lt;span class="tooltip" data-tooltip="انتهای نوشتن pipe" ontouchend="toggleTooltip(this)">*io.PipeWriter&lt;/span>
&lt;/code>. هر بایتی که در &lt;code>PipeWriter&lt;/code> می‌نویسی، از &lt;code>PipeReader&lt;/code> خونده می‌شه—معمولاً توی دو تا goroutine جدا. این برای زمانی عالیه که &lt;strong>تولید داده (producer)&lt;/strong> و &lt;strong>مصرف اون (consumer)&lt;/strong> هم‌زمان و بدون بافر بزرگ کار کنن. &lt;strong>Backpressure&lt;/strong> طبیعی هم داریم: اگه خواننده کند باشه، نویسنده بلاک می‌شه (و برعکس)، پس هر دو سمت باید «زنده» باشن. ایدهٔ پایه و مثال سادهٔ همین الگو توی منابع پیوست هم اومده.&lt;/p>
&lt;p>دو نکتهٔ حیاتی:&lt;/p>
&lt;ul>
&lt;li>همیشه انتهای &lt;strong>Writer&lt;/strong> رو وقتی کارت تموم شد &lt;code>&lt;span class="tooltip" data-tooltip="بستن Writer" ontouchend="toggleTooltip(this)">Close&lt;/span>
&lt;/code> یا بهتر از اون &lt;code>&lt;span class="tooltip" data-tooltip="بستن با خطا برای propagate" ontouchend="toggleTooltip(this)">CloseWithError&lt;/span>
&lt;/code> کن؛ وگرنه خواننده تا ابد منتظر می‌مونه → deadlock.&lt;/li>
&lt;li>مصرف‌کننده تا &lt;strong>EOF&lt;/strong> بخونه (یا Copy کنه). قواعد خواندن/EOF رو جدی بگیر—خیلی از باگ‌های استریم همین‌جان.&lt;/li>
&lt;/ul>
&lt;h3 id="مثال-۱-ابتداییترین-اتصال-producerconsumer-با-iocopy">
مثال ۱: ابتدایی‌ترین اتصال Producer/Consumer با &lt;code>io.Copy&lt;/code>
&lt;a class="anchor" href="#%d9%85%d8%ab%d8%a7%d9%84-%db%b1-%d8%a7%d8%a8%d8%aa%d8%af%d8%a7%db%8c%db%8c%d8%aa%d8%b1%db%8c%d9%86-%d8%a7%d8%aa%d8%b5%d8%a7%d9%84-producerconsumer-%d8%a8%d8%a7-iocopy">#&lt;/a>
&lt;/h3>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"bytes"
"fmt"
"io"
"os"
)
func main() {
// منبع دادهٔ ما: یک بافر درون‌حافظه‌ای
src := new(bytes.Buffer)
src.WriteString("hello pipe\n")
src.WriteString("line 2\n")
pr, pw := io.Pipe()
// Producer: می‌نویسه داخل pw
go func() {
defer func() {
_ = pw.Close() // پایان جریان؛ مهم برای جلوگیری از بن‌بست
}()
if _, err := io.Copy(pw, src); err != nil {
// در صورت خطا بهتره CloseWithError بدیم:
// _ = pw.CloseWithError(err)
fmt.Println("producer copy error:", err)
}
}()
// Consumer: از pr می‌خونه و می‌ریزه روی Stdout
if _, err := io.Copy(os.Stdout, pr); err != nil {
fmt.Println("consumer copy error:", err)
}
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>این الگو تقریباً همون چیزیه که در نمونه‌های پیوست هم می‌بینی: &lt;code>Pipe()&lt;/code>، یک goroutine برای نوشتن، و &lt;code>io.Copy&lt;/code> برای خواندن تا EOF.&lt;/p>
&lt;h2 id="42742-استفاده-در-جریان-داده-streaming">
4.27.4.2 استفاده در جریان داده (Streaming)
&lt;a class="anchor" href="#42742-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%af%d8%b1-%d8%ac%d8%b1%db%8c%d8%a7%d9%86-%d8%af%d8%a7%d8%af%d9%87-streaming">#&lt;/a>
&lt;/h2>
&lt;p>جذابیت اصلی &lt;code>io.Pipe&lt;/code> اینه که می‌تونی &lt;strong>پایپ‌لاین‌های استریم&lt;/strong> بسازی: ورودی از یه جا میاد، وسط راه encode/zip/hash می‌شه، و خروجی همزمان جای دیگه می‌ره—همه بدون اینکه کل داده رو تو حافظه نگه داری. نمونه‌ها و توصیه‌های استریمی در مقالات پیوست زیاد تأکید می‌کنن که به جای &lt;code>ReadAll&lt;/code>، &lt;strong>جریان بده&lt;/strong> و تو مسیر پردازش کن.&lt;/p>
&lt;h3 id="مثال-۲-فشردهسازی-on-the-fly-با-compressgzip-روی-pipe">
مثال ۲: فشرده‌سازی on-the-fly با &lt;code>compress/gzip&lt;/code> روی pipe
&lt;a class="anchor" href="#%d9%85%d8%ab%d8%a7%d9%84-%db%b2-%d9%81%d8%b4%d8%b1%d8%af%d9%87%d8%b3%d8%a7%d8%b2%db%8c-on-the-fly-%d8%a8%d8%a7-compressgzip-%d8%b1%d9%88%db%8c-pipe">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>Producer دادهٔ خام رو می‌خونه و داخل &lt;code>gzip.Writer&lt;/code> می‌نویسه که خروجی‌ش &lt;code>PipeWriter&lt;/code> ماست.&lt;/li>
&lt;li>Consumer از &lt;code>PipeReader&lt;/code> می‌خونه و مستقیم به فایل می‌نویسه.&lt;/li>
&lt;/ul>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"compress/gzip"
"fmt"
"io"
"os"
"strings"
)
func main() {
input := strings.NewReader(strings.Repeat("Go IO Pipe\n", 5))
pr, pw := io.Pipe()
// Producer: gzip روی pw
go func() {
defer func() {
_ = pw.Close() // اول gzip.Close، بعد pw.Close
}()
gzw := gzip.NewWriter(pw)
if _, err := io.Copy(gzw, input); err != nil {
_ = gzw.Close()
_ = pw.CloseWithError(err)
return
}
_ = gzw.Close()
}()
// Consumer: خروجی gzip شده می‌ره توی فایل
out, err := os.Create("out.gz")
if err != nil {
panic(err)
}
defer out.Close()
if _, err := io.Copy(out, pr); err != nil {
fmt.Println("copy error:", err)
}
fmt.Println("done -> out.gz")
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>&lt;strong>نکتهٔ مهم:&lt;/strong> ترتیب بستن‌ها: اول &lt;code>gzw.Close()&lt;/code> تا footer نوشته بشه، بعد &lt;code>pw.Close()&lt;/code> تا EOF به مصرف‌کننده برسد. این دقیقا همان الگوی «اتصال goroutine‌ها با Pipe و Copy»‌ است.&lt;/p>
&lt;h3 id="مثال-۳-محاسبه-checksum-همزمان-با-عبور-داده-pipe--teereader">
مثال ۳: محاسبهٔ checksum همزمان با عبور داده (Pipe + TeeReader)
&lt;a class="anchor" href="#%d9%85%d8%ab%d8%a7%d9%84-%db%b3-%d9%85%d8%ad%d8%a7%d8%b3%d8%a8%d9%87-checksum-%d9%87%d9%85%d8%b2%d9%85%d8%a7%d9%86-%d8%a8%d8%a7-%d8%b9%d8%a8%d9%88%d8%b1-%d8%af%d8%a7%d8%af%d9%87-pipe--teereader">#&lt;/a>
&lt;/h3>
&lt;p>گاهی می‌خوای همزمان که داده رو می‌فرستی، &lt;strong>هش/چک‌سام&lt;/strong> هم بگیری. &lt;code>&lt;span class="tooltip" data-tooltip="کپی موازی داده به یک Writer" ontouchend="toggleTooltip(this)">io.TeeReader&lt;/span>
&lt;/code> همین کارو می‌کنه.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"crypto/sha256"
"fmt"
"io"
"os"
"strings"
)
func main() {
src := strings.NewReader(strings.Repeat("data...", 100))
pr, pw := io.Pipe()
// Producer: src -> TeeReader(hasher) -> pw
go func() {
defer pw.Close()
hasher := sha256.New()
tr := io.TeeReader(src, hasher)
if _, err := io.Copy(pw, tr); err != nil {
_ = pw.CloseWithError(err)
return
}
sum := hasher.Sum(nil)
fmt.Fprintf(os.Stderr, "sha256: %x\n", sum)
}()
// Consumer: pr -> stdout (یا هر مقصد دیگری)
if _, err := io.Copy(os.Stdout, pr); err != nil {
fmt.Println("copy error:", err)
}
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>این الگوی «داده رد می‌شه، همزمان پردازش جانبی انجام می‌دیم».&lt;/p>
&lt;h2 id="42743-الگوهای-همزمانی-با-iopipe">
4.27.4.3 الگوهای همزمانی با io.Pipe
&lt;a class="anchor" href="#42743-%d8%a7%d9%84%da%af%d9%88%d9%87%d8%a7%db%8c-%d9%87%d9%85%d8%b2%d9%85%d8%a7%d9%86%db%8c-%d8%a8%d8%a7-iopipe">#&lt;/a>
&lt;/h2>
&lt;p>چند الگوی پرکاربرد و Best Practiceها:&lt;/p>
&lt;ol>
&lt;li>&lt;strong>Producer/Consumer با پایان مشخص&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>Writer را حتماً Close/CloseWithError کنید&lt;/strong>؛ در غیر این صورت خواننده هرگز EOF نمی‌گیره و گیر می‌کنه. نمونهٔ درست توی مثال‌ها و منبع پیوست هست.&lt;/li>
&lt;li>سمت مصرف‌کننده از &lt;code>io.Copy&lt;/code> استفاده کن تا قواعد &lt;code>EOF&lt;/code> و شمارش بایت‌ها خودکار رعایت بشه.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>خطا را propagate کن&lt;/strong>
&lt;ul>
&lt;li>اگر وسط کار producer خطا خورد، &lt;code>CloseWithError&lt;/code> بده تا consumer مطلع شه و سریع‌تر fail کنه. این باور غلط که «همیشه Close ساده کافیه» در استریم‌های طولانی دردسرسازه. (قواعد خطا/EOF در منابع پیوست مرور شده.)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>بافر جایی دیگه، Pipe اینجا&lt;/strong>
&lt;ul>
&lt;li>&lt;code>io.Pipe&lt;/code> خودش بافر قابل‌توجهی نداره؛ برای throughput بهتر از &lt;code>&lt;span class="tooltip" data-tooltip="بافرخوانی/نوشتن" ontouchend="toggleTooltip(this)">bufio&lt;/span>
&lt;/code> یا &lt;code>&lt;span class="tooltip" data-tooltip="کپی با بافر سفارشی" ontouchend="toggleTooltip(this)">io.CopyBuffer&lt;/span>
&lt;/code> روی مقصد/مبدأ استفاده کن؛&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Fan-in/Fan-out با Pipeهای زنجیره‌ای&lt;/strong>
&lt;ul>
&lt;li>می‌تونی چند مرحلهٔ پردازش (encode → compress → encrypt) رو با چند goroutine و چند Pipe زنجیره کنی. دقت کن هر مرحله خروجی رو &lt;strong>تا آخر&lt;/strong> drain کنه و به‌موقع ببنده، وگرنه مرحلهٔ قبل block می‌شه.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>از ReadAll پرهیز کن&lt;/strong>
&lt;ul>
&lt;li>برای دادهٔ بزرگ، به‌جای &lt;code>&lt;span class="tooltip" data-tooltip="خواندن کامل در حافظه" ontouchend="toggleTooltip(this)">io.ReadAll&lt;/span>
&lt;/code> استریم کن.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="نکات-production-ready-خلاصه">
نکات Production-Ready خلاصه
&lt;a class="anchor" href="#%d9%86%da%a9%d8%a7%d8%aa-production-ready-%d8%ae%d9%84%d8%a7%d8%b5%d9%87">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>همیشه&lt;/strong> پایان جریان را سیگنال بده: &lt;code>Close()&lt;/code> یا &lt;code>CloseWithError(err)&lt;/code>.&lt;/li>
&lt;li>سمت مصرف‌کننده &lt;strong>تا EOF بخونه&lt;/strong>؛ ساده‌ترین: &lt;code>io.Copy(dst, pr)&lt;/code>. قواعد EOF/Read را رعایت کن.&lt;/li>
&lt;li>در pipelineها ترتیب &lt;strong>بستن wrapperها&lt;/strong> مهمه (مثلاً اول &lt;code>gzip.Close&lt;/code> بعد &lt;code>PipeWriter.Close&lt;/code>).&lt;/li>
&lt;li>عملکرد: برای انتقال‌های بزرگ، از &lt;code>io.CopyBuffer&lt;/code> یا &lt;code>bufio.Writer/Reader&lt;/code> کمک بگیر و سایز بافر رو بسته به سناریو تنظیم کن.&lt;/li>
&lt;li>اگر مرحله‌ای error داد، سریعاً &lt;strong>propagate&lt;/strong> کن تا همهٔ goroutineها بدونن باید جمع کنن؛ لوپ‌های بی‌پایان مصرف CPU می‌شن.&lt;/li>
&lt;/ul>
&lt;h2 id="4275-پیادهسازی-reader-و-writer-سفارشی">
4.27.5 پیاده‌سازی Reader و Writer سفارشی
&lt;a class="anchor" href="#4275-%d9%be%db%8c%d8%a7%d8%af%d9%87%d8%b3%d8%a7%d8%b2%db%8c-reader-%d9%88-writer-%d8%b3%d9%81%d8%a7%d8%b1%d8%b4%db%8c">#&lt;/a>
&lt;/h2>
&lt;p>ایده‌ی اصلی اینجاست: هر چیزی که متد &lt;code>Read([]byte) (int, error)&lt;/code> داشته باشه یک &lt;span class="tooltip" data-tooltip="رابط خواندن داده در کتابخانه استاندارد Go" ontouchend="toggleTooltip(this)">io.Reader&lt;/span>
و هر چیزی که متد &lt;code>Write([]byte) (int, error)&lt;/code> داشته باشه یک &lt;span class="tooltip" data-tooltip="رابط نوشتن داده در کتابخانه استاندارد Go" ontouchend="toggleTooltip(this)">io.Writer&lt;/span>
محسوب می‌شه. این دو رابط پایهٔ تمام ورودی/خروجیِ «جریان‌محور» هستن و باهاشون می‌تونیم اجزای قابل‌اتصال بسازیم.&lt;/p>
&lt;h3 id="42751-ساخت-یک-custom-reader">
4.27.5.1 ساخت یک Custom Reader
&lt;a class="anchor" href="#42751-%d8%b3%d8%a7%d8%ae%d8%aa-%db%8c%da%a9-custom-reader">#&lt;/a>
&lt;/h3>
&lt;p>بیایید یک Reader بسازیم که حروف را به &lt;strong>UpperCase&lt;/strong> تبدیل می‌کند. این Reader خودش دادهٔ خام را از یک Readerِ زیری می‌خواند و هنگام بازگشت، تبدیل را اعمال می‌کند.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"bytes"
"fmt"
"io"
"os"
"strings"
)
type UpperReader struct {
r io.Reader // زیرساخت خواندن
}
// Read باید تا حد امکان بافر p را پر کند، تعداد بایت‌های نوشته‌شده و خطا را برگرداند.
func (u *UpperReader) Read(p []byte) (int, error) {
n, err := u.r.Read(p)
if n > 0 {
// فقط همان تکه‌ای را که پر شده upper کنیم
// (تبدیل درجا روی p[:n])
copy(p[:n], bytes.ToUpper(p[:n]))
}
return n, err
}
func main() {
src := strings.NewReader("go io is composable!\n")
ur := &amp;UpperReader{r: src}
if _, err := io.Copy(os.Stdout, ur); err != nil {
fmt.Fprintln(os.Stderr, "copy error:", err)
}
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>نکات مهم طراحی (طبق توصیه‌های فصل I/O):&lt;/p>
&lt;ul>
&lt;li>سعی کنید روی &lt;code>p[:n]&lt;/code> کار کنید و از ایجاد &lt;span class="tooltip" data-tooltip="تخصیص حافظه" ontouchend="toggleTooltip(this)">allocation&lt;/span>
‌های اضافی پرهیز کنید.&lt;/li>
&lt;li>اجازه بدید خطاهای زیری (مثل &lt;code>io.EOF&lt;/code>) همون‌طور عبور کنن تا &lt;span class="tooltip" data-tooltip="تابع کپی داده" ontouchend="toggleTooltip(this)">io.Copy&lt;/span>
رفتار درست داشته باشه.&lt;/li>
&lt;/ul>
&lt;h3 id="42752-ساخت-یک-custom-writer">
4.27.5.2 ساخت یک Custom Writer
&lt;a class="anchor" href="#42752-%d8%b3%d8%a7%d8%ae%d8%aa-%db%8c%da%a9-custom-writer">#&lt;/a>
&lt;/h3>
&lt;p>حالا یک Writer می‌سازیم که به ابتدای هر &lt;strong>خط&lt;/strong> یک پیشوند اضافه کند؛ این یعنی باید مرز خطوط را مدیریت کنیم و ممکن است تکه‌خطوط بین فراخوانی‌های &lt;code>Write&lt;/code> بمانند.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"bufio"
"bytes"
"fmt"
"io"
"os"
)
type LinePrefixWriter struct {
w io.Writer
prefix []byte
pending bool // آیا در ابتدای خط جدید هستیم؟
buf []byte // بافر carry برای تکه‌خط‌های بدون \n
}
func NewLinePrefixWriter(w io.Writer, prefix string) *LinePrefixWriter {
return &amp;LinePrefixWriter{w: w, prefix: []byte(prefix), pending: true}
}
func (lp *LinePrefixWriter) Write(p []byte) (int, error) {
total := 0
// دادهٔ جدید را به بافر داخلی اضافه می‌کنیم
lp.buf = append(lp.buf, p...)
sc := bufio.NewScanner(bytes.NewReader(lp.buf))
sc.Split(bufio.ScanLines)
var out bytes.Buffer
for sc.Scan() {
line := sc.Bytes()
// ScanLines انتهای \n را حذف می‌کند؛ باید خودمان اضافه کنیم
if lp.pending {
out.Write(lp.prefix)
}
out.Write(line)
out.WriteByte('\n')
lp.pending = true // بعد از نوشتن \n ابتدای خط بعدی هستیم
total += len(line) + 1
}
if err := sc.Err(); err != nil {
return 0, err
}
// تشخیص اینکه آیا ورودی با \n تمام شده یا تکه‌خط نیمه‌کاره داریم
if len(lp.buf) > 0 &amp;&amp; lp.buf[len(lp.buf)-1] != '\n' {
// آخرین توکن توسط Scanner برگردانده نمی‌شود؛ نگهش می‌داریم
// و pending را false می‌کنیم چون وسط خط هستیم.
lastNL := bytes.LastIndexByte(lp.buf, '\n')
if lastNL >= 0 {
lp.buf = append([]byte{}, lp.buf[lastNL+1:]...) // نگه داشتن دمِ خط
}
lp.pending = false
} else {
lp.buf = lp.buf[:0] // همه مصرف شده
lp.pending = true
}
// خروجی بافر را یکجا بنویسیم
nw, err := lp.w.Write(out.Bytes())
if err != nil {
return nw, err
}
return len(p), nil // قرارداد Writer: تعداد بایت‌های از ورودیِ p پذیرفته‌شده
}
func main() {
lw := NewLinePrefixWriter(os.Stdout, "[LOG] ")
_, _ = lw.Write([]byte("hello"))
_, _ = lw.Write([]byte(" world\nnext line\npartial"))
_, _ = lw.Write([]byte(" tail\n"))
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>نکات:&lt;/p>
&lt;ul>
&lt;li>Writer باید تا حد امکان «همهٔ p» را بپذیرد و اگر کمتر نوشت، مقدار برگشتی را دقیق بده (قابل‌استناد برای &lt;span class="tooltip" data-tooltip="فشار معکوس؛ کند کردن تولیدکننده هنگام کند بودن مصرف‌کننده" ontouchend="toggleTooltip(this)">backpressure&lt;/span>
).&lt;/li>
&lt;li>استفاده از بافر داخلی برای تکه‌خط‌ها یک الگوی رایج است. مراقب رشد بافر باشید.&lt;/li>
&lt;/ul>
&lt;h3 id="42753-پیادهسازی-ioreaderfrom-و-iowriterto-برای-بهینهسازی">
4.27.5.3 پیاده‌سازی io.ReaderFrom و io.WriterTo برای بهینه‌سازی
&lt;a class="anchor" href="#42753-%d9%be%db%8c%d8%a7%d8%af%d9%87%d8%b3%d8%a7%d8%b2%db%8c-ioreaderfrom-%d9%88-iowriterto-%d8%a8%d8%b1%d8%a7%db%8c-%d8%a8%d9%87%db%8c%d9%86%d9%87%d8%b3%d8%a7%d8%b2%db%8c">#&lt;/a>
&lt;/h3>
&lt;p>تابع &lt;span class="tooltip" data-tooltip="کپی بین Reader و Writer" ontouchend="toggleTooltip(this)">io.Copy&lt;/span>
یک میان‌بُر مهم دارد:&lt;/p>
&lt;ul>
&lt;li>اگر &lt;strong>Reader&lt;/strong> متد &lt;span class="tooltip" data-tooltip="WriteTo(w) (int64, error)" ontouchend="toggleTooltip(this)">io.WriterTo&lt;/span>
را پیاده‌سازی کند، &lt;code>io.Copy&lt;/code> به‌جای حلقهٔ پیش‌فرض، &lt;code>r.WriteTo(dst)&lt;/code> را صدا می‌زند.&lt;/li>
&lt;li>اگر &lt;strong>Writer&lt;/strong> متد &lt;span class="tooltip" data-tooltip="ReadFrom(r) (int64, error)" ontouchend="toggleTooltip(this)">io.ReaderFrom&lt;/span>
را پیاده‌سازی کند، &lt;code>io.Copy&lt;/code> از &lt;code>w.ReadFrom(src)&lt;/code> استفاده می‌کند.&lt;/li>
&lt;/ul>
&lt;p>این مسیرها اجازه می‌دهند پیاده‌سازیِ شما مسیر داده را بهینه کند (مثلاً استفاده از بافرهای بزرگ‌تر، جلوگیری از کپی‌های اضافه، یا بهره‌بردن از توابع سیستم‌عاملی). به الگوهای استاندارد I/O و توضیحات دربارهٔ &lt;code>io.Copy&lt;/code> در منابع اشاره‌شده رجوع کنید.&lt;/p>
&lt;p>در کُد زیر، برای &lt;code>UpperReader&lt;/code>، متد &lt;code>WriteTo&lt;/code> را اضافه می‌کنیم تا مسیر «Reader → Writer» مستقیم‌تر شود. و برای &lt;code>LinePrefixWriter&lt;/code>، متد &lt;code>ReadFrom&lt;/code> را می‌گذاریم تا داده را &lt;strong>بکشد&lt;/strong>.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"bytes"
"fmt"
"io"
"os"
"strings"
)
type UpperReader struct{ r io.Reader }
func (u *UpperReader) Read(p []byte) (int, error) {
n, err := u.r.Read(p)
if n > 0 {
copy(p[:n], bytes.ToUpper(p[:n]))
}
return n, err
}
// WriterTo: به io.Copy اجازه می‌دهد مستقیماً از WriteTo استفاده کند.
func (u *UpperReader) WriteTo(w io.Writer) (int64, error) {
var total int64
buf := make([]byte, 32*1024) // بافر بزرگ‌تر برای throughput بهتر
for {
n, err := u.r.Read(buf)
if n > 0 {
blk := bytes.ToUpper(buf[:n])
m, werr := w.Write(blk)
total += int64(m)
if werr != nil {
return total, werr
}
if m &lt; n {
return total, io.ErrShortWrite
}
}
if err != nil {
if err == io.EOF {
return total, nil
}
return total, err
}
}
}
type LinePrefixWriter struct {
w io.Writer
prefix []byte
pending bool
}
// ReaderFrom: به io.Copy اجازه می‌دهد Writer خودش از منبع بخواند.
func (lp *LinePrefixWriter) ReadFrom(r io.Reader) (int64, error) {
var total int64
buf := make([]byte, 32*1024)
var carry []byte
writeLine := func(line []byte) error {
if lp.pending {
if _, err := lp.w.Write(lp.prefix); err != nil {
return err
}
}
if _, err := lp.w.Write(line); err != nil {
return err
}
if _, err := lp.w.Write([]byte{'\n'}); err != nil {
return err
}
lp.pending = true
return nil
}
for {
n, err := r.Read(buf)
if n > 0 {
total += int64(n)
chunk := append(carry, buf[:n]...)
start := 0
for {
i := bytes.IndexByte(chunk[start:], '\n')
if i &lt; 0 {
// تکه‌خط ناقص
carry = append([]byte{}, chunk[start:]...)
lp.pending = false
break
}
end := start + i
if err2 := writeLine(chunk[start:end]); err2 != nil {
return total, err2
}
start = end + 1
}
}
if err != nil {
if err == io.EOF {
// هرچه مانده را بدون \n نهایی، با پیشوند بنویسیم
if len(carry) > 0 {
if lp.pending {
if _, werr := lp.w.Write(lp.prefix); werr != nil {
return total, werr
}
}
if _, werr := lp.w.Write(carry); werr != nil {
return total, werr
}
lp.pending = false
}
return total, nil
}
return total, err
}
}
}
func NewLinePrefixWriter(w io.Writer, prefix string) *LinePrefixWriter {
return &amp;LinePrefixWriter{w: w, prefix: []byte(prefix), pending: true}
}
func main() {
// مسیر بهینه‌شده: io.Copy ابتدا WriterTo روی Reader را امتحان می‌کند
r := &amp;UpperReader{r: strings.NewReader("hello\nGo io\n")}
w := NewLinePrefixWriter(os.Stdout, "[UP] ")
if _, err := io.Copy(w, r); err != nil {
fmt.Fprintln(os.Stderr, "copy error:", err)
}
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>چرا این کار سریع‌تر می‌شود؟&lt;/p>
&lt;ul>
&lt;li>&lt;code>WriteTo&lt;/code> و &lt;code>ReadFrom&lt;/code> به شما کنترل بافر و مسیر داده را می‌دهند، پس &lt;strong>کپی‌های کمتر&lt;/strong> و &lt;strong>تخصیص‌های کمتر&lt;/strong> خواهید داشت؛&lt;/li>
&lt;li>مطابق توضیحات منابع I/O، &lt;code>io.Copy&lt;/code> طبق قرارداد ابتدا &lt;code>WriterTo&lt;/code> را روی Reader و بعد &lt;code>ReaderFrom&lt;/code> را روی Writer چک می‌کند؛ داشتن یکی از این‌ها کافی‌ست تا حلقهٔ پیش‌فرضِ کپی کنار گذاشته شود.&lt;/li>
&lt;/ul>
&lt;h2 id="4276-مدیریت-خطا-در-io">
4.27.6 مدیریت خطا در io
&lt;a class="anchor" href="#4276-%d9%85%d8%af%db%8c%d8%b1%db%8c%d8%aa-%d8%ae%d8%b7%d8%a7-%d8%af%d8%b1-io">#&lt;/a>
&lt;/h2>
&lt;p>کار با I/O توی Go قشنگه چون همه‌چیز «جریان بایت»‌ه؛ اما همین‌جا اکثر خطاهای ریزه‌میزه هم رخ می‌دن: از برگشتن &lt;code>n&amp;gt;0&lt;/code> همراه با یک &lt;code>err&lt;/code> گرفته تا تشخیص پایان داده با &lt;code>io.EOF&lt;/code> و هندل کردن عملیات طولانی که باید قابل لغو باشن. این بخش خیلی جمع‌وجور ولی کاربردی می‌گه «چه خطایی عادیه، چی بحرانیه و چطور تولیدی (Production-Ready) هندلش کنیم». بر اساس مقاله‌های پیوست‌شده درباره‌ی I/O استریمی و الگوهای خطا (و چند نکته از اسناد استاندارد)، قواعد مهم &lt;code>Read/Write&lt;/code>، تمایز &lt;code>io.EOF&lt;/code>، و مدیریت عملیات طولانی با &lt;span class="tooltip" data-tooltip="انقضای زمان" ontouchend="toggleTooltip(this)">Timeout&lt;/span>
و &lt;span class="tooltip" data-tooltip="لغو" ontouchend="toggleTooltip(this)">Cancellation&lt;/span>
رو مرور می‌کنیم.&lt;/p>
&lt;h3 id="42761-تفاوت-ioeof-با-خطاهای-دیگر">
4.27.6.1 تفاوت &lt;code>io.EOF&lt;/code> با خطاهای دیگر
&lt;a class="anchor" href="#42761-%d8%aa%d9%81%d8%a7%d9%88%d8%aa-ioeof-%d8%a8%d8%a7-%d8%ae%d8%b7%d8%a7%d9%87%d8%a7%db%8c-%d8%af%db%8c%da%af%d8%b1">#&lt;/a>
&lt;/h3>
&lt;ol>
&lt;li>&lt;strong>&lt;code>io.EOF&lt;/code> خطا نیست؛ علامت پایان جریانه.&lt;/strong> وقتی منبع داده تموم می‌شه، بعضی Readerها &lt;code>n&amp;gt;0&lt;/code> و &lt;code>err==io.EOF&lt;/code> برمی‌گردونن (یعنی «این آخریشه!»). بعضی‌های دیگه ممکنه همون لحظه &lt;code>err==nil&lt;/code> بدن و خواندن بعدی &lt;code>io.EOF&lt;/code> بده. پس «پایان» همیشه در فراخوانی بعدی قطعی می‌شه. نتیجه؟ حلقه‌ی خواندن باید روی &lt;code>io.EOF&lt;/code> از حلقه خارج بشه؛ ولی قبلش هر بایتی که با &lt;code>n&amp;gt;0&lt;/code> اومده رو پردازش کن. این دقیقاً همون «قوانین خواندن»یه که روی Readerها تأکید شده.&lt;/li>
&lt;li>&lt;strong>&lt;code>n&amp;gt;0&lt;/code> همراه با &lt;code>err!=nil&lt;/code>&lt;/strong>: طبق قواعد Reader، ممکنه قبل از وقوع خطا هنوز چند بایت معتبر توی &lt;code>p[:n]&lt;/code> داشته باشید (مثلاً سوکت ناگهانی بسته شده). حواستون باشه اون بایت‌ها از دست نرن؛ اول مصرفشون کنید، بعد تصمیم بگیرید ریترای کنید یا قطع.&lt;/li>
&lt;li>&lt;strong>&lt;code>io.ErrUnexpectedEOF&lt;/code> با &lt;code>io.EOF&lt;/code> فرق داره.&lt;/strong> &lt;code>io.ErrUnexpectedEOF&lt;/code> یعنی «داده زودتر از حد انتظار تموم شد» (مثلاً وسط یک بلاک ساختاریافته). این یکی خطای واقعی است و معمولاً باید به کاربر گزارش بشه یا عملیات رو ریترای/رول‌بک کنید. (نمونه‌های مرسوم هنگام &lt;code>io.CopyN&lt;/code> یا &lt;code>io.ReadFull&lt;/code> اتفاق می‌افته.)&lt;/li>
&lt;li>&lt;strong>الگوی صحیح حلقه‌ی خواندن&lt;/strong>: تا وقتی &lt;code>err==nil&lt;/code> ادامه بده؛ اگر &lt;code>err==io.EOF&lt;/code> بود از حلقه خارج شو؛ اگر &lt;code>err!=nil&lt;/code> بود، بسته به سناریو لاگ/بازگشت خطا. (و یادت باشه قبل از خروج هر چیزی در &lt;code>p[:n]&lt;/code> رو مصرف کنی.&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>مثال (الگوی درستِ برخورد با EOF و خطاهای جزئی):&lt;/strong>&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"fmt"
"io"
"os"
"strings"
)
func main() {
// می‌تونی این رو با فایل هم تست کنی: f, _ := os.Open("file.txt"); defer f.Close(); r := f
r := strings.NewReader("Clear is better than clever")
buf := make([]byte, 4)
for {
n, err := r.Read(buf)
if n > 0 {
fmt.Print(string(buf[:n])) // قبل از بررسی خطا، داده‌های دریافت‌شده رو مصرف کن
}
if err != nil {
if err == io.EOF {
break // پایان طبیعی جریان
}
// خطای واقعی (شبکه، دیسک، مجوز و...)
fmt.Fprintln(os.Stderr, "read error:", err)
return
}
}
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>این الگو دقیقاً همون چیزیه که در منابع رویش تأکید شده: ممکنه &lt;code>n&lt;/code> کمتر از &lt;code>len(p)&lt;/code> باشه، ممکنه &lt;code>n&amp;gt;0&lt;/code> همراه با خطا بیاد، و &lt;code>n=0, err=nil&lt;/code> به معنی EOF نیست.&lt;/p>
&lt;p>&lt;strong>نکات پروداکشنی:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>از &lt;code>io.Copy&lt;/code> برای ساده‌سازی حلقه‌ها استفاده کن؛ خودش شمارش بایت و EOF رو درست مدیریت می‌کنه.&lt;/li>
&lt;li>موقع &lt;code>Write&lt;/code>، &lt;code>n!=len(p)&lt;/code> و &lt;code>io.ErrShortWrite&lt;/code> رو جدی بگیر.&lt;/li>
&lt;li>خطاهای &lt;code>Close()&lt;/code> رو چک کن؛ مخصوصاً روی فایل/شبکه. (اگرچه مثال‌های این بخش روی Reader تمرکز دارن، اما چک کردن Close توی خروجی هم مهمه.)&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;h3 id="42762-مدیریت-خطا-در-عملیات-طولانی">
4.27.6.2 مدیریت خطا در عملیات طولانی
&lt;a class="anchor" href="#42762-%d9%85%d8%af%db%8c%d8%b1%db%8c%d8%aa-%d8%ae%d8%b7%d8%a7-%d8%af%d8%b1-%d8%b9%d9%85%d9%84%db%8c%d8%a7%d8%aa-%d8%b7%d9%88%d9%84%d8%a7%d9%86%db%8c">#&lt;/a>
&lt;/h3>
&lt;p>هدف اینجاست: کد I/O طولانی شما باید &lt;strong>قابل لغو&lt;/strong> باشه، &lt;strong>زمان‌بندی&lt;/strong> داشته باشه، و &lt;strong>به‌صورت پیوسته خطا/پیشرفت&lt;/strong> رو مدیریت کنه—بدون اینکه رم رو بترکونه یا فایل لاک بمونه.&lt;/p>
&lt;p>&lt;strong>1) لغو با &lt;code>context.Context&lt;/code> (سراسری و ساده):&lt;/strong>&lt;br>
خیلی از APIهای خالص &lt;code>io&lt;/code> کانتکست نمی‌گیرن، ولی می‌تونیم یک Reader «کانتکست-اگاه» بسازیم که اگر &lt;code>ctx.Done()&lt;/code> شد، دیگه نخونه و &lt;code>ctx.Err()&lt;/code> برگردونه. این روش برای هر منبعی جواب می‌ده (فایل، حافظه، Pipe، HTTP body و&amp;hellip;).&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"context"
"fmt"
"io"
"os"
"strings"
"time"
)
type ctxReader struct {
ctx context.Context
r io.Reader
}
func (c *ctxReader) Read(p []byte) (int, error) {
select {
case &lt;-c.ctx.Done():
return 0, c.ctx.Err()
default:
return c.r.Read(p)
}
}
func main() {
ctx, cancel := context.WithTimeout(context.Background(), 500*time.Millisecond)
defer cancel()
// منبع کند (شبیه‌سازی): هر 200ms چند بایت می‌ده
src := io.Reader(strings.NewReader(strings.Repeat("DATA-", 1&lt;&lt;14)))
r := &amp;ctxReader{ctx: ctx, r: src}
// خروجی: استاندارد (می‌تونی فایل هم بذاری)
if _, err := io.Copy(os.Stdout, r); err != nil {
fmt.Fprintln(os.Stderr, "copy stopped:", err) // deadline exceeded یا canceled
}
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>نکته: برای شبکه‌ها (&lt;code>net.Conn&lt;/code>) اصلاً لازم نیست دور Reader کُوری بپیچید؛ مستقیماً از &lt;code>SetDeadline/SetReadDeadline&lt;/code> استفاده کنید تا Read/Write با &lt;span class="tooltip" data-tooltip="انقضای زمان" ontouchend="toggleTooltip(this)">Timeout&lt;/span>
قطع بشه. برای HTTP از &lt;code>http.Client&lt;/code> با &lt;code>Timeout&lt;/code> یا &lt;code>Context&lt;/code> روی &lt;code>Request&lt;/code> استفاده کنید. (الگوی خطا همان است: اگر &lt;code>n&amp;gt;0&lt;/code> برگشته، مصرف کن و بعد خطا را مدیریت کن.)&lt;/p>
&lt;p>&lt;strong>2) کنترل حافظه و اندازه‌ی داده:&lt;/strong>&lt;br>
در عملیات طولانی، وسوسه نشید &lt;code>io.ReadAll&lt;/code> بزنید؛ برای داده‌های بزرگ باعث مصرف رم می‌شه. به‌جایش جریان‌محور (&lt;code>io.Copy&lt;/code>، &lt;code>io.CopyBuffer&lt;/code> با بافر قابل‌استفاده‌مجدد) کار کنید. اگر باید سقف اندازه را enforce کنید، &lt;code>io.LimitReader&lt;/code> یا &lt;code>io.CopyN&lt;/code> بگذارید و به &lt;code>io.ErrUnexpectedEOF&lt;/code> حساس باشید.&lt;/p>
&lt;p>&lt;strong>3) پایش و لاگ خطای مرحله‌ای (Stream-aware):&lt;/strong>&lt;br>
اگر هم‌زمان می‌خواید پیشرفت یا checksum بگیرید، از &lt;code>io.TeeReader&lt;/code> استفاده کنید تا جریان یکجا هم مصرف شود هم ثبت/هش شود—و هر خطا همان‌جا متوقف کند.&lt;/p>
&lt;p>&lt;strong>4) بستن منابع به‌موقع:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>روی هر مسیر خروج (موفق/ناموفق) &lt;code>Close()&lt;/code> را چک کنید و در حلقه‌ها &lt;code>defer Close()&lt;/code> نگذارید (نشت دسته‌جمعی می‌ده). برای تعداد زیاد فایل‌ها، «باز کن—کار کن—ببند» را سریع انجام بده.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>مثال (کپیِ قابل-لغو + محدودیت حجم + شمارنده‌ی پیشرفت):&lt;/strong>&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"context"
"crypto/sha256"
"fmt"
"io"
"os"
"strings"
"time"
)
type ctxReader struct {
ctx context.Context
r io.Reader
}
func (c *ctxReader) Read(p []byte) (int, error) {
select {
case &lt;-c.ctx.Done():
return 0, c.ctx.Err()
default:
return c.r.Read(p)
}
}
func main() {
// منبع شبیه‌سازی‌شدهٔ بزرگ
src := strings.NewReader(strings.Repeat("X", 10&lt;&lt;20)) // 10MB
// 1) محدودیت 1MB
limited := io.LimitReader(src, 1&lt;&lt;20) // 1 MiB
// 2) پیشرفت/هش موازی با TeeReader
hasher := sha256.New()
tr := io.TeeReader(limited, hasher)
// 3) لغو با Timeout
ctx, cancel := context.WithTimeout(context.Background(), 300*time.Millisecond)
defer cancel()
cr := &amp;ctxReader{ctx: ctx, r: tr}
dst, err := os.Create("out.bin")
if err != nil {
fmt.Println("create:", err)
return
}
defer func() {
if err := dst.Close(); err != nil {
fmt.Println("close:", err)
}
}()
// کپی جریان‌محور
written, err := io.Copy(dst, cr)
if err != nil {
fmt.Println("copy error:", err) // ممکنه context deadline exceeded باشه
} else {
fmt.Println("written bytes:", written)
}
fmt.Printf("sha256 (partial/complete): %x\n", hasher.Sum(nil))
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>&lt;strong>چند Best Practice کوتاه برای عملیات طولانی:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>«سقف ورودی» بگذار: &lt;code>io.LimitReader&lt;/code> روی بدنه‌ی درخواست‌ها (مثلاً آپلود) تا از سوءاستفاده و OOM جلوگیری کنی.&lt;/li>
&lt;li>«بافر درست» انتخاب کن و اگر حلقه‌ی طولانیه از &lt;code>io.CopyBuffer&lt;/code> با یک بافر reuse‌شونده استفاده کن. (افزایش کارایی روی فایل/شبکه)&lt;/li>
&lt;li>&lt;code>io.Copy&lt;/code> خطاها و EOF رو درست مدیریت می‌کنه؛ وقتی خاص‌نویسی لازم نیست، از همون استفاده کن.&lt;/li>
&lt;/ul>
&lt;h2 id="4277-best-practices-در-استفاده-از-io">
4.27.7 Best Practices در استفاده از io
&lt;a class="anchor" href="#4277-best-practices-%d8%af%d8%b1-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-io">#&lt;/a>
&lt;/h2>
&lt;p>پکیج &lt;code>io&lt;/code> قلب عملیات ورودی/خروجی (I/O) در Go است و تقریبا همه کتابخانه‌های استاندارد مربوط به فایل، شبکه، و پردازش داده بر پایه همین abstractionها ساخته شده‌اند. اما استفاده درست از آن می‌تواند تفاوت زیادی در کارایی، مصرف حافظه، و پایداری کد شما ایجاد کند. در ادامه چند &lt;strong>بهترین شیوه&lt;/strong>‌ی مهم برای استفاده از این پکیج را بررسی می‌کنیم.&lt;/p>
&lt;h3 id="42771-استفاده-از-interface-به-جای-نوع-خاص">
4.27.7.1 استفاده از Interface به جای نوع خاص
&lt;a class="anchor" href="#42771-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-interface-%d8%a8%d9%87-%d8%ac%d8%a7%db%8c-%d9%86%d9%88%d8%b9-%d8%ae%d8%a7%d8%b5">#&lt;/a>
&lt;/h3>
&lt;p>یکی از فلسفه‌های کلیدی Go این است که به جای تکیه بر نوع خاص (مثل &lt;code>*os.File&lt;/code>) از اینترفیس‌های عمومی مثل &lt;code>io.Reader&lt;/code> و &lt;code>io.Writer&lt;/code> استفاده کنیم.&lt;br>
این کار باعث می‌شود که کد ما انعطاف‌پذیر باشد و بتواند با هر منبع یا مقصد داده‌ای کار کند — چه فایل باشد، چه شبکه، چه حافظه.&lt;/p>
&lt;p>&lt;strong>مثال:&lt;/strong>&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"fmt"
"io"
"os"
"strings"
)
func printData(r io.Reader) {
buf := make([]byte, 16)
for {
n, err := r.Read(buf)
if n > 0 {
fmt.Print(string(buf[:n]))
}
if err == io.EOF {
break
}
if err != nil {
fmt.Println("Error:", err)
break
}
}
}
func main() {
// خواندن از یک رشته
printData(strings.NewReader("Hello Go\n"))
// خواندن از یک فایل
file, _ := os.Open("test.txt")
defer file.Close()
printData(file)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در این مثال، تابع &lt;code>printData&lt;/code> با هر چیزی که &lt;code>io.Reader&lt;/code> را پیاده‌سازی کند کار می‌کند، بدون وابستگی به نوع خاص.&lt;/p>
&lt;h3 id="42772-بهینهسازی-با-bufio">
4.27.7.2 بهینه‌سازی با bufio
&lt;a class="anchor" href="#42772-%d8%a8%d9%87%db%8c%d9%86%d9%87%d8%b3%d8%a7%d8%b2%db%8c-%d8%a8%d8%a7-bufio">#&lt;/a>
&lt;/h3>
&lt;p>خواندن و نوشتن مستقیم روی منابع I/O می‌تواند منجر به تعداد زیادی فراخوانی سیستم (syscall) و کاهش کارایی شود. برای همین &lt;code>bufio&lt;/code> بافرهایی ارائه می‌دهد که باعث کاهش فراخوانی‌های I/O و افزایش سرعت می‌شوند.&lt;/p>
&lt;p>&lt;strong>نکته:&lt;/strong> همیشه وقتی با داده‌های زیاد یا عملیات کوچک و پرتکرار کار می‌کنید، از &lt;code>bufio.Reader&lt;/code> یا &lt;code>bufio.Writer&lt;/code> استفاده کنید.&lt;/p>
&lt;p>&lt;strong>مثال:&lt;/strong>&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"bufio"
"fmt"
"os"
)
func main() {
file, err := os.Open("bigfile.txt")
if err != nil {
panic(err)
}
defer file.Close()
reader := bufio.NewReader(file)
for {
line, err := reader.ReadString('\n')
fmt.Print(line)
if err != nil {
break
}
}
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;h3 id="42773-مدیریت-منابع-با-iocloser-و-defer">
4.27.7.3 مدیریت منابع با io.Closer و defer
&lt;a class="anchor" href="#42773-%d9%85%d8%af%db%8c%d8%b1%db%8c%d8%aa-%d9%85%d9%86%d8%a7%d8%a8%d8%b9-%d8%a8%d8%a7-iocloser-%d9%88-defer">#&lt;/a>
&lt;/h3>
&lt;p>بسیاری از منابع I/O مثل فایل‌ها و کانکشن‌های شبکه نیاز به بستن (Close) دارند. پیاده‌سازی &lt;code>io.Closer&lt;/code> و استفاده از &lt;code>defer&lt;/code> تضمین می‌کند که حتی در صورت بروز خطا، منابع آزاد می‌شوند.&lt;/p>
&lt;p>&lt;strong>مثال:&lt;/strong>&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"fmt"
"os"
)
func main() {
file, err := os.Open("data.txt")
if err != nil {
panic(err)
}
defer file.Close() // تضمین آزاد شدن منبع
buf := make([]byte, 32)
n, _ := file.Read(buf)
fmt.Println(string(buf[:n]))
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;h3 id="42774-انتخاب-اندازه-buffer-مناسب">
4.27.7.4 انتخاب اندازه buffer مناسب
&lt;a class="anchor" href="#42774-%d8%a7%d9%86%d8%aa%d8%ae%d8%a7%d8%a8-%d8%a7%d9%86%d8%af%d8%a7%d8%b2%d9%87-buffer-%d9%85%d9%86%d8%a7%d8%b3%d8%a8">#&lt;/a>
&lt;/h3>
&lt;p>اندازه بافر تأثیر مستقیم روی کارایی دارد. بافر کوچک ممکن است باعث افزایش تعداد فراخوانی‌ها و کندی برنامه شود؛ بافر بزرگ هم می‌تواند حافظه را هدر دهد.&lt;br>
به‌طور معمول، برای بیشتر کاربردها بافر 4KB تا 32KB مناسب است (همانند اندازه پیش‌فرض در &lt;code>bufio&lt;/code>)، اما در عملیات شبکه‌ای یا پردازش فایل‌های بزرگ می‌توانید آزمایش و بهینه‌سازی کنید.&lt;/p>
&lt;p>&lt;strong>مثال:&lt;/strong>&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"io"
"os"
)
func main() {
src, _ := os.Open("large.bin")
defer src.Close()
dst, _ := os.Create("copy.bin")
defer dst.Close()
buf := make([]byte, 64*1024) // 64KB buffer
io.CopyBuffer(dst, src, buf)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;h3 id="42775-آپلود-استریمی-فایل-بزرگ-با-ذخیرهسازی-امن-atomic-روی-دیسک">
4.27.7.5 آپلود استریمیِ فایل بزرگ با ذخیره‌سازی امن (atomic) روی دیسک
&lt;a class="anchor" href="#42775-%d8%a2%d9%be%d9%84%d9%88%d8%af-%d8%a7%d8%b3%d8%aa%d8%b1%db%8c%d9%85%db%8c-%d9%81%d8%a7%db%8c%d9%84-%d8%a8%d8%b2%d8%b1%da%af-%d8%a8%d8%a7-%d8%b0%d8%ae%db%8c%d8%b1%d9%87%d8%b3%d8%a7%d8%b2%db%8c-%d8%a7%d9%85%d9%86-atomic-%d8%b1%d9%88%db%8c-%d8%af%db%8c%d8%b3%da%a9">#&lt;/a>
&lt;/h3>
&lt;h3 id="اصول">
اصول
&lt;a class="anchor" href="#%d8%a7%d8%b5%d9%88%d9%84">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>استریم‌کردن&lt;/strong>: به‌جای نگه‌داشتن کل فایل در حافظه، ورودی را مستقیم به دیسک کپی کنید.&lt;/li>
&lt;li>&lt;strong>حداکثر اندازه&lt;/strong>: حتماً روی بدنه‌ی درخواست limit بگذارید.&lt;/li>
&lt;li>&lt;strong>فایل موقت + rename اتمی&lt;/strong>: اول در مسیر مقصد یک فایل موقت (&lt;code>*.part&lt;/code>) بسازید، آخر کار که موفق بود، با &lt;code>os.Rename&lt;/code> به نام نهایی منتقلش کنید. روی یک فایل‌سیستم، rename اتمی است.&lt;/li>
&lt;li>&lt;strong>پاکسازی مطمئن&lt;/strong>: هر خطا/لغو باعث حذف فایل موقت شود.&lt;/li>
&lt;li>&lt;strong>Context‑aware&lt;/strong>: اگر کلاینت آپلود را کنسل کرد، کپی متوقف شود (Go خودش روی &lt;code>r.Context()&lt;/code> این را propagate می‌کند).&lt;/li>
&lt;/ul>
&lt;h3 id="هندلر-نمونه-http-multipartform-data">
هندلر نمونه (HTTP، &lt;code>multipart/form-data&lt;/code>)
&lt;a class="anchor" href="#%d9%87%d9%86%d8%af%d9%84%d8%b1-%d9%86%d9%85%d9%88%d9%86%d9%87-http-multipartform-data">#&lt;/a>
&lt;/h3>
&lt;p>این نمونه آپلود &lt;strong>تک‌فایله&lt;/strong> را نشان می‌دهد. برای چند فایل، حلقه روی پارت‌ها بزنید.&lt;/p>
&lt;pre>&lt;code class="language-go">package upload
import (
&amp;quot;bufio&amp;quot;
&amp;quot;errors&amp;quot;
&amp;quot;fmt&amp;quot;
&amp;quot;io&amp;quot;
&amp;quot;mime/multipart&amp;quot;
&amp;quot;net/http&amp;quot;
&amp;quot;os&amp;quot;
&amp;quot;path/filepath&amp;quot;
&amp;quot;strconv&amp;quot;
&amp;quot;strings&amp;quot;
)
const (
maxUploadSize = 1 &amp;lt;&amp;lt; 30 // 1GiB نمونه؛ بسته به نیاز تغییر دهید
uploadDir = &amp;quot;./uploads&amp;quot;
)
func UploadHandler(w http.ResponseWriter, r *http.Request) {
// 1) محدود کردن اندازه بدنۀ درخواست (حفاظت از حافظه و DoS)
r.Body = http.MaxBytesReader(w, r.Body, maxUploadSize)
// 2) استریم‌کردن multipart بدون بافرکردن کل فرم
mr, err := r.MultipartReader()
if err != nil {
http.Error(w, &amp;quot;invalid multipart request&amp;quot;, http.StatusBadRequest)
return
}
// 3) اطمینان از وجود مسیر ذخیره
if err := os.MkdirAll(uploadDir, 0o755); err != nil {
http.Error(w, &amp;quot;cannot create upload dir&amp;quot;, http.StatusInternalServerError)
return
}
// انتظار داریم یک part فایل به نام &amp;quot;file&amp;quot;
var savedName string
for {
part, err := mr.NextPart()
if errors.Is(err, io.EOF) {
break
}
if err != nil {
http.Error(w, &amp;quot;read part failed&amp;quot;, http.StatusBadRequest)
return
}
if part.FormName() != &amp;quot;file&amp;quot; || part.FileName() == &amp;quot;&amp;quot; {
// سایر فیلدهای فرم را رد کنید (مثلاً متن و …)
continue
}
// 4) ساخت فایل موقت در همان دایرکتوری مقصد (برای rename اتمی روی همان FS)
tmp, err := os.CreateTemp(uploadDir, &amp;quot;*.part&amp;quot;)
if err != nil {
http.Error(w, &amp;quot;cannot create temp file&amp;quot;, http.StatusInternalServerError)
return
}
tmpPath := tmp.Name()
defer func() {
// اگر تا آخر کار rename موفق نشود، فایل موقت پاک می‌شود
tmp.Close() // امن است حتی اگر قبلاً بسته شده باشد
_ = os.Remove(tmpPath)
}()
// 5) استریم کپی با بافر معقول (کاهش syscall ها)
bufw := bufio.NewWriterSize(tmp, 64*1024) // 64KiB؛ با بنچمارک تنظیم کنید
// اگر بخواهید همزمان hash بگیرید:
// h := sha256.New()
// src := io.TeeReader(part, h)
// _, err = io.CopyBuffer(bufw, src, make([]byte, 64*1024))
_, err = io.CopyBuffer(bufw, part, make([]byte, 64*1024))
closeErr := bufw.Flush()
if err == nil {
err = closeErr
}
// توجه: اگر کلاینت وسط کار قطع شود، copy با خطا برمی‌گردد.
if err != nil {
http.Error(w, &amp;quot;upload interrupted/failed&amp;quot;, http.StatusBadRequest)
return
}
// 6) اطمینان از پایداری روی دیسک (اختیاری، برای حساسیت بالا)
if err := tmp.Sync(); err != nil {
http.Error(w, &amp;quot;fsync failed&amp;quot;, http.StatusInternalServerError)
return
}
if err := tmp.Close(); err != nil {
http.Error(w, &amp;quot;close failed&amp;quot;, http.StatusInternalServerError)
return
}
// 7) تولید نام نهایی امن
finalName := sanitizeFilename(part.FileName())
finalPath := filepath.Join(uploadDir, finalName)
// در صورت وجود فایل همنام، یک suffix یکتا اضافه کنید
finalPath = uniquifyPath(finalPath)
// 8) جابجایی اتمی
if err := os.Rename(tmpPath, finalPath); err != nil {
http.Error(w, &amp;quot;atomic move failed&amp;quot;, http.StatusInternalServerError)
return
}
// از اینجا به بعد، فایل موقت را دیگر پاک نکنید
savedName = filepath.Base(finalPath)
// یک فایل را ذخیره کردیم؛ اگر فقط یک فایل می‌پذیرید، می‌توانید break کنید.
break
}
if savedName == &amp;quot;&amp;quot; {
http.Error(w, &amp;quot;no file part found&amp;quot;, http.StatusBadRequest)
return
}
w.WriteHeader(http.StatusCreated)
_, _ = fmt.Fprintf(w, &amp;quot;uploaded: %s\n&amp;quot;, savedName)
}
func sanitizeFilename(name string) string {
// خیلی ساده: مسیرها را حذف و فضای خالی را _ کنیم؛ در عمل سخت‌گیرتر باشید.
name = filepath.Base(name)
name = strings.ReplaceAll(name, &amp;quot; &amp;quot;, &amp;quot;_&amp;quot;)
return name
}
func uniquifyPath(path string) string {
dir := filepath.Dir(path)
base := filepath.Base(path)
ext := filepath.Ext(base)
name := strings.TrimSuffix(base, ext)
p := path
i := 1
for {
if _, err := os.Stat(p); errors.Is(err, os.ErrNotExist) {
return p
}
p = filepath.Join(dir, name+&amp;quot;(&amp;quot;+strconv.Itoa(i)+&amp;quot;)&amp;quot;+ext)
i++
}
}
&lt;/code>&lt;/pre>
&lt;h3 id="نکات-کلیدی">
نکات کلیدی
&lt;a class="anchor" href="#%d9%86%da%a9%d8%a7%d8%aa-%da%a9%d9%84%db%8c%d8%af%db%8c">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>&lt;code>http.MaxBytesReader&lt;/code> جلوی خواندن بیش از حد را می‌گیرد؛ اگر بزرگ‌تر باشد با خطای 4xx برمی‌گردید.&lt;/li>
&lt;li>به‌جای &lt;code>r.ParseMultipartForm&lt;/code> از &lt;code>r.MultipartReader()&lt;/code> استفاده کردیم تا &lt;strong>کاملاً استریمی&lt;/strong> باشد.&lt;/li>
&lt;li>اول روی فایل موقت می‌نویسیم، بعد &lt;code>Sync&lt;/code> و &lt;code>Close&lt;/code> و در پایان &lt;code>Rename&lt;/code> اتمی. اگر هر جا خطا بخورد، &lt;code>defer&lt;/code> فایل موقت را پاک می‌کند.&lt;/li>
&lt;li>اگر حجم‌ها واقعاً بزرگند، بهتر است &lt;strong>اندازه بافر&lt;/strong> را با بنچمارک روی محیط واقعی تنظیم کنید.&lt;/li>
&lt;li>اگر نیاز دارید &lt;strong>checksum/virus‑scan/thumbnail&lt;/strong> بسازید، از &lt;code>io.TeeReader&lt;/code> (یا کانال‌های موازی با &lt;code>errgroup&lt;/code>) استفاده کنید تا هنگام نوشتن، داده را همزمان به پردازش ثانویه بدهید.&lt;/li>
&lt;/ul>
&lt;h3 id="آیا-اینجا-از-iopipe-استفاده-کنیم">
آیا اینجا از &lt;code>io.Pipe&lt;/code> استفاده کنیم؟
&lt;a class="anchor" href="#%d8%a2%db%8c%d8%a7-%d8%a7%db%8c%d9%86%d8%ac%d8%a7-%d8%a7%d8%b2-iopipe-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%da%a9%d9%86%db%8c%d9%85">#&lt;/a>
&lt;/h3>
&lt;p>برای «کپی ساده‌ی ورودی به دیسک» معمولاً &lt;strong>لازم نیست&lt;/strong>. &lt;code>io.Copy&lt;/code>/&lt;code>io.TeeReader&lt;/code> ساده‌تر و کم‌ریسک‌ترند.&lt;/p>
&lt;p>&lt;code>io.Pipe&lt;/code> وقتی می‌درخشد که:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>تولیدکننده و مصرف‌کننده همزمان&lt;/strong> دارید و می‌خواهید backpressure طبیعی رخ دهد (تا وقتی مصرف‌کننده نخوانَد، تولیدکننده پیش نرود).&lt;/li>
&lt;li>نیاز به &lt;strong>تبدیل/فشرده‌سازی/اسکن&lt;/strong> در goroutine جدا دارید که داده را از همون استریم بگیرد.&lt;/li>
&lt;/ul>
&lt;p>نمونه‌ی کوتاه با &lt;code>io.Pipe&lt;/code> همزمان:&lt;/p>
&lt;pre>&lt;code class="language-go">pr, pw := io.Pipe()
// تولیدکننده: داده‌ی آپلود را در Pipe می‌نویسد
go func() {
defer pw.Close()
_, err := io.Copy(pw, part) // part همان multipart.Part
if err != nil {
// اگر خراب شد، Pipe را با خطا می‌بندیم تا مصرف‌کننده مطلع شود
_ = pw.CloseWithError(err)
}
}()
// مصرف‌کننده: همزمان روی دیسک می‌نویسد و پردازش می‌کند
go func() {
defer pr.Close()
dst, _ := os.CreateTemp(uploadDir, &amp;quot;*.part&amp;quot;)
defer dst.Close()
// همزمان hash یا AV:
// h := sha256.New()
// multi := io.TeeReader(pr, h)
_, err := io.Copy(dst, pr) // یا multi
if err != nil {
// خطا را log/propagate کنید و فایل موقت را حذف کنید
}
// ... Sync/Close/Rename مثل قبل
}()
&lt;/code>&lt;/pre>
&lt;p>احتیاط: با &lt;code>io.Pipe&lt;/code> اگر یکی از طرفین خواندن/نوشتن را متوقف کند و دیگری چشم‌انتظار بماند، &lt;strong>بن‌بست&lt;/strong> می‌گیرید. حتماً با مدیریت خطا/بستن و &lt;code>errgroup&lt;/code> کنترل کامل جریان را داشته باشید.&lt;/p></description></item></channel></rss>