<!doctype html><html lang=fa dir=rtl><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  

پکیج io در زبان Go یکی از ابزارهای پایه و همه‌فن‌حریف برای کار با عملیات Input/Output
 است. فلسفه‌اش اینه که ما بدون وابستگی به نوع خاص داده (مثل فایل، شبکه یا حافظه) بتونیم از یک Interface
 ساده استفاده کنیم. این یعنی اگر یک شیء فقط متد مورد نیاز رو پیاده‌سازی کنه، می‌تونه در تمام جاهایی که اون رابط انتظار میره استفاده بشه. مثلا io.Reader فقط یک متد Read داره و io.Writer یک متد Write، ولی همین دو قرارداد ساده پایه تمام سیستم I/O Abstraction
 در Go رو تشکیل میدن."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://book.gofarsi.ir/chapter-4/go-io-package/"><meta property="og:site_name" content="زبان گو فارسی"><meta property="og:title" content="4.27 آموزش کار با پکیج io"><meta property="og:description" content="پکیج io در زبان Go یکی از ابزارهای پایه و همه‌فن‌حریف برای کار با عملیات Input/Output است. فلسفه‌اش اینه که ما بدون وابستگی به نوع خاص داده (مثل فایل، شبکه یا حافظه) بتونیم از یک Interface ساده استفاده کنیم. این یعنی اگر یک شیء فقط متد مورد نیاز رو پیاده‌سازی کنه، می‌تونه در تمام جاهایی که اون رابط انتظار میره استفاده بشه. مثلا io.Reader فقط یک متد Read داره و io.Writer یک متد Write، ولی همین دو قرارداد ساده پایه تمام سیستم I/O Abstraction در Go رو تشکیل میدن."><meta property="og:locale" content="fa"><meta property="og:type" content="article"><meta property="article:section" content="chapter-4"><title>4.27 آموزش کار با پکیج io | زبان گو فارسی</title><link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://book.gofarsi.ir/chapter-4/go-io-package/><link rel=stylesheet href=/book.min.c2f5390a8db8d6e8a1f34ca78b37beea11b3040c8e6f418e46422051f3aa7136.css integrity="sha256-wvU5Co241uih80ynize+6hGzBAyOb0GORkIgUfOqcTY=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/fa.search.min.068daa01b501b56037e7271c5fb4de8760300850b1ce99341e9cad1fe913b814.js integrity="sha256-Bo2qAbUBtWA35yccX7Teh2AwCFCxzpk0HpytH+kTuBQ=" crossorigin=anonymous></script><link rel=stylesheet href=prism.css><meta name=keywords content><link href=https://cdn.jsdelivr.net/gh/rastikerdar/vazir-font@v30.1.0/dist/font-face.css rel=stylesheet type=text/css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.0/css/all.min.css crossorigin=anonymous><link rel=alternate type=application/rss+xml href=https://book.gofarsi.ir//feed.xml title="زبان گو فارسی"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/prism-themes@1.9.0/themes/prism-one-dark.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/line-numbers/prism-line-numbers.min.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZE44Q8PZDW"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZE44Q8PZDW")</script><script>var html=document.documentElement;localStorage.getItem("themeMode")=="dark"&&html.setAttribute("data-theme","dark"),localStorage.getItem("themeMode")=="light"&&html.setAttribute("data-theme","light")</script></head><body dir=rtl><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><img src=/favicon.png alt=Logo class=book-icon><span>زبان گو فارسی</span></a></h2><div class=magic><div class=book-search><input type=text id=book-search-input placeholder=جستجو aria-label=جستجو maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><div class=js-toggle-wrapper><div class=js-toggle><div class=js-toggle-track><div class=js-toggle-track-check><img src="data:image/png;base64,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" role=presentation style=pointer-events:none width=23 height=23></div><div class=js-toggle-track-x><img src=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAMAAABrrFhUAAAAsVBMVEUAAADxxA/xxA7xxA/xxA/yxA7xxA/wxBDtvQnyxQ/xxQ7zww7xxA/yxA/xxA7wxA/vwwzwxw/xxA/xxQ/2wxDwwQ7xxA/xxA/xxA7xxA/yxA/xxA/www/zxA/xxA7zyAzxxA/xxQ/zxA/yxQ3yxQ/yxA7yxA/yxA/xxQ/xxA/wxA7xxA/znBLxxA/zpxHywQ/yuw/znxHythDyrxDzohHxvg/yrBHyqhHzpBHytxDyshBq1XLAAAAALHRSTlMAMsTxt6+JQAiabTae0Y9XKRBvUh4ZppdJ3r16VUJaE+KBZSWqofz3yHhN21vQ0loAAAinSURBVHja5NuJWtpAEAfwSUJCuAQERQS8tdpv/zm4PN7/wWqRtmqTsDkmWdjfG2S+mWFndqGKtVqkN8chvY3HpLWfwE/S2T1wTxo7+QH8OCF93eDdDemrhnc10paBDYN0dY2Na9JVBxsd0tQZts5IT21stUlLJxa2LD2PAsf465h0ZOIvkzRUxyd10k8DnzRIO3VA7xSw8YVNmpnimynpxcSGtj8Ex9jS9CzQsvAfS6cFeQ3faLYYmSDShDRRf0CkB00OAycdxOjoMRXWsKFtGzhFglM6eE9I9EQHboYdZnTQBthpQAesCQlNOlhHkHJEh6lnQ5LdowN0cQVpVxeklus+5eQeIZUjl3LqX1Nx+nCGlMfMRErmjPIYOuhTgRxgZGSPn4MMnOxfYIwAh4o0xLvTGWXS7SCTTjdjup3i3ZAKNcJv9oBSM9rIrG1QagMbv42oWAY+mDcupWE0kEsjXQjcGxNMz05OsTV2jGyfzx8CwxnzjZUz/GNLFedts4ZC1Jq3JKFr885UNj4ZN6aUqCf39fIx6FGiaWPMfdE0wFfW3XQYU4iDUQeF64wGLkUaTu+sMkZKE/+xzFGz3uoNL13a6BvdSfscbM7bk67R34b5cthr1Zsj0wLKuWa6wd64IQ7uGHti7BILB3vCIR4G9oRBTGzsBZu4dLEXusRmL9rgmPg0sAcaxGeKQvjBfPHsvSxDsREuX7znxTzwUYgpMbKQkz9feKGIEXqLuY+cLOJ0hxz81/VS7LRcv/rI4Y6+UqUG/DdPSPPefGQ1JU5DZDP3REreHNkM6bvKm8BqEYoMwsUK6VnEy0RawbPI7DlAWibxGiGdwBO5eAHSGRGvJrayfT5/CJrEqw55/loUYu1DXp14tSDtLRQFCd8grUW8epAUvIgCvQSQ1CNeQ8hZiIItIGdIvC4hY+WJwnkryLgkXi4kzAWLOSS4xCxf+vOXAXHDLr4n2Hi++gFYLQWj5Ur1AAShYBUGagfgVbB7VTkAc1GCeaUB6Ff+/Tsi0CdeRr78568Cg3h1ESsQpQkQq0u8JoizCkVpwhXiTIhXGzH8pSjR0keMNvE6RwxPlMpDjHNi5Uqe//ktqpmGzvL+APL/GJ4RJweRVqICK0RyiNOjEg0gsQ08EqOeIg3gw6L8rWAzzQmIX1D6zUANUV5ERV4QpUZsbhHlTVTmDVFuiUsTEfxQVCb0JWqAuwLWokLrUmvAUKoDfgjKHIkbyhwBdhwGGvRBgwRITAEdEiAxBbRIgBJToI0Iz6JyzyWtRbrKTIHfrUpZDfY7Ck1BEjNRp0/FchAlFAoIy1gLzFTZA8nvhmZUINdUZw8iuxkxXSrOEaL4QhE+ohxRYS6g2hwsMxXjggrSu1JoEyhfA7jqUTFsqF0BcTUAmwpxH3sZrIxXRLsv7H24cpuQr9aMb8efEGcplLFEnKci7sKUbwGbJsBzU3ZR+XuY3K9mLvLmvzL3wUkWAEMV9Nt4p8iDgGQeErT7lEn9EVvqToJ/hEjyWKcMJg94tx89UAgfSR4mlFarht+UeBMmI0CyWotSObYAVP8otMD/Eli/2LsTpcSBIAzAnRsIBCQQDg+UlV0X/RMuRX3/B1stLQ8gmEwytQzT3wtQMzXMlenuNmV3ZuKNKotAplAC84yy8RxsOND74K/WyMDxsjS/ig/KrIIb62C6qkd7ddsmth3Wq4jdHpGR2e5Smn7dwiYVjkKvVsjMqvdpB+OqgQ3q7INSdkKpGlfG5tAfIqe7A4Ochl/+CmH0B9CtA4A/UUgv/OASgI4d8OIy8Ml3B/p2wMD16cV0oudfYDL9nATHtuIdMEdO9rjLyyBvhHgrzIchPg7zhQhfifGlKF+Lp/Aa6uyE5tin4ZGQrq3MOhhjD7tLoiJVloEl0kVUwF9FloEFZD2ROFdjFkyQ5pwKClU4Dq2QJqTCaio/kqpRCQJ1n8kF/FCSn8ryY2l+Ls8BExwyw0FTHDbHgZMcOsvB0xw+f6RDYN8A0GEI7B8AGgyBDAOA0+hwIiVOpcXJ1DidHidULEnjgG4HY+zUIJl6h59UtUcyhYfzoXCR71sQJ1bm1NqcXJ3T63OBBS6xwUVWuMwOF1riUltcbI3L7XHBRS65yUVXuewuF17m0ttcfJ3L74voIZ9ZLKX56Xokl4m8Zus7YesZ8jJJLgv53S/nQlPf8h75WSRVB2IWce6xv4CYDskUQlTyHOdo/XMCUSHJNEEBydPDKsOJ9+EpQQET+u7/TwHfJItlPE/918fLRYKCLJKoj1Iks8VyHT+u5u/tXj3G6+VilqAUfZIngAICkucWCrglaZpQQpNkcaAEhyQxoAiD5HChCJekqAygiEGFZBhDGWOSwcQWy+zVPL/VGb13+YnRPK0PIc2wfto0Tt4H5KjT8r1az7SwxSQJLjYbPwk7tFOl796gdDduP2Vkd8KJBYhEzYo/j7oN+rRXq2ajRHatRXv1g1vJT6Wm+OQ0KYNfNbus1v+iDJoOPk2pbM5nHk6DsjKqKKya4+fcgbTNkI835rhCeRhVCc1PVxmbkr4PRHg1FJhcjDqE1Q2ByXqYkj2oeKyIMyUhzQaENJokZOqUHzcSAJFPok5cCHBPSJQflXwtMEJQrEPPTeRknhcbsgFGVJ6rERVUCZBLUKGCRld0WC4ukdnlBR2hloOMnBYdp2tkck1H61rz9hNF+FFER83FD1w6cq7m7SeqYo8qaeBa0/nvw+gGKW5GpAXvN3b67ZEmTrHTKWnDxg426cO3sMXySSNtbGmTVkxsMEkvZ9hwRppx8I1DuvlXnr2jAAgDQRgetRDxURgiIVWsUs39r6ckAdHGTsX5zrCw/7ItT2QS4NDJ3QAXrfgAALXuCshm2QYobMOisZA0sBigybFwEDUyGaFqZfK1J95zKiYVZHnuPHTNuhGQ2UhG0QjIlt//Am8Y0kBaCNA2TdDW93jXBty7dRd1GL72AAAAAElFTkSuQmCC role=presentation style=pointer-events:none width=23 height=23></div></div><div class=js-toggle-thumb><img src=data:image/png;base64,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 role=presentation style=pointer-events:none width=46 height=46></div><input class=js-toggle-screenreader-only type=checkbox aria-label="تغییر تم بین روشن و تاریک"></div></div></div><ul><li><a href=/preface/>پیشگفتار</a></li><li><a href=/history/>تاریخچه</a></li><li><a href=/why-go/>چرا زبان Go؟</a></li><li><a href=/installation/>آموزش نصب</a></li><li><a href=/toolchain/>ابزارها, دستورات گو و معرفی IDE</a></li><li><a href=/roadmap/>نقشه یادگیری زبان گو</a></li><li><a href=/interview/>نمونه سوالات مصاحبه</a></li><li><input type=checkbox id=section-c0c35ea61c635f6152f0c00d6a15569e class=toggle>
<label for=section-c0c35ea61c635f6152f0c00d6a15569e class=flex><a href=/chapter-1/ class=flex-auto>فصل اول: آشنایی با مفاهیم گو</a></label><ul><li><a href=/chapter-1/structure-of-go-code/>1.1 ساختار کد گو</a></li><li><a href=/chapter-1/go-built-in-keywords-identifiers/>1.2 کلید واژه و شناسه‌ها</a></li><li><a href=/chapter-1/go-basic-types/>1.3 تایپ‌های پایه</a></li><li><a href=/chapter-1/go-operators/>1.4 عملگرها</a></li><li><a href=/chapter-1/go-variables-and-consts/>1.5 متغیرها و constant</a></li><li><a href=/chapter-1/go-zero-values/>1.6 مقادیر صفر تایپ‌ها (zero values)</a></li><li><a href=/chapter-1/go-function/>1.7 تابع (function)</a></li><li><a href=/chapter-1/go-array/>1.8 آرایه و slice</a></li><li><a href=/chapter-1/go-for/>1.9 حلقه‌ها (for)</a></li><li><a href=/chapter-1/go-map/>1.10 نقشه map</a></li><li><a href=/chapter-1/go-if-switch/>1.11 شرط (if, switch)</a></li><li><a href=/chapter-1/go-package/>1.12 اضافه کردن پکیج در کد (package)</a></li><li><a href=/chapter-1/go-defer-panic-recovery/>1.13 defer, panic, recovery</a></li><li><a href=/chapter-1/go-builtins/>1.14 لیست تایپ‌ها و توابع Builtin</a></li><li><a href=/chapter-1/go-string-formatting/>1.15 قالب بندی رشته‌ها</a></li></ul></li><li><input type=checkbox id=section-ce9b5b1ec927bacdb2712b9c215a3ca1 class=toggle>
<label for=section-ce9b5b1ec927bacdb2712b9c215a3ca1 class=flex><a href=/chapter-2/ class=flex-auto>فصل دوم: مکانیزم‌های زبان</a></label><ul><li><a href=/chapter-2/pointer/>2.1 اشاره‌گر (Pointer)</a></li><li><a href=/chapter-2/struct/>2.2 ساختار (struct)</a></li><li><a href=/chapter-2/method/>2.3 متد (Method)</a></li><li><a href=/chapter-2/interface/>2.4 اینترفیس (Interface)</a></li><li><a href=/chapter-2/type-embedding/>2.5 جاسازی تایپ (type embedding)</a></li><li><a href=/chapter-2/error-handling/>2.6 مدیریت خطاها</a></li><li><a href=/chapter-2/casting-vs-conversion/>2.7 فرق casting با conversion</a></li></ul></li><li><input type=checkbox id=section-0691270142e95f82c4d2eb637f234afd class=toggle>
<label for=section-0691270142e95f82c4d2eb637f234afd class=flex><a href=/chapter-3/ class=flex-auto>فصل سوم: همزمانی (concurrency)</a></label><ul><li><a href=/chapter-3/go-concurrency/>3.1 آشنایی با همزمانی</a></li><li><a href=/chapter-3/goroutine/>3.2 گوروتین (goroutine)</a></li><li><a href=/chapter-3/go-sync-package/>3.3 پکیج sync</a></li><li><a href=/chapter-3/go-atomic/>3.4 پکیج atomic</a></li><li><a href=/chapter-3/goroutine-data-race/>3.5 آموزش مقابله با data race</a></li><li><a href=/chapter-3/go-channel/>3.6 کانال (channel)</a></li><li><a href=/chapter-3/go-select/>3.7 آموزش استفاده از select</a></li><li><a href=/chapter-3/go-context/>3.8 پکیج context</a></li><li><a href=/chapter-3/go-concurrency-teqniques/>3.9 تکنیک های همزمانی</a></li><li><a href=/chapter-3/go-concurrency-patterns/>3.10 الگو های همزمانی</a></li></ul></li><li><input type=checkbox id=section-59efe912b32b5b1290d5ec2dac84f441 class=toggle checked>
<label for=section-59efe912b32b5b1290d5ec2dac84f441 class=flex><a href=/chapter-4/ class=flex-auto>فصل چهارم: مباحث پیشرفته</a></label><ul><li><a href=/chapter-4/build-go-file/>4.1 آموزش Build پروژه</a></li><li><a href=/chapter-4/debugging-go-code/>4.2 آموزش کار با Debugging</a></li><li><a href=/chapter-4/go-mod/>4.3 آموزش کار با go mod</a></li><li><a href=/chapter-4/workspace/>4.4 آموزش کار با workspace</a></li><li><a href=/chapter-4/vendor/>4.5 آموزش کار با Vendor</a></li><li><a href=/chapter-4/command-line-go/>4.6 آموزش نوشتن برنامه command line</a></li><li><a href=/chapter-4/work-with-file-in-go/>4.7 آموزش کار با فایل</a></li><li><a href=/chapter-4/work-with-json-file-in-go/>4.8 آموزش کار با json</a></li><li><a href=/chapter-4/work-with-toml-file-in-go/>4.9 آموزش کار با toml</a></li><li><a href=/chapter-4/work-with-yaml-file-in-go/>4.10 آموزش کار با yaml</a></li><li><a href=/chapter-4/work-with-csv-file-in-go/>4.11 آموزش کار با csv</a></li><li><a href=/chapter-4/work-with-ini-file-in-go/>4.12 آموزش کار با ini</a></li><li><a href=/chapter-4/work-with-environment-variable/>4.13 آموزش کار با environment variable</a></li><li><a href=/chapter-4/go-regular-expressions/>4.14 آموزش کار با regexp</a></li><li><a href=/chapter-4/go-reflection/>4.15 آموزش reflection</a></li><li><a href=/chapter-4/go-generator/>4.16 آموزش generator</a></li><li><a href=/chapter-4/go-stringer/>4.17 آموزش stringer</a></li><li><a href=/chapter-4/effective-go/>4.18 تکنیک های کدنویسی زبان گو</a></li><li><a href=/chapter-4/go-commentry/>4.19 اصول کامنت نویسی</a></li><li><a href=/chapter-4/go-code-rules/>4.20 قوانین کدنویسی در گو</a></li><li><a href=/chapter-4/go-garbage-collector/>4.21 زباله جمع کن (garbage collector)</a></li><li><a href=/chapter-4/go-plugin/>4.22 کتابخانه Plugin</a></li><li><input type=checkbox id=section-687c92e06ed3c05242e60a3a1a266aa4 class=toggle>
<label for=section-687c92e06ed3c05242e60a3a1a266aa4 class=flex><a href=/chapter-4/oop/ class=flex-auto>4.23 شی گرایی در زبان گو</a></label><ul><li><a href=/chapter-4/oop/go-encapsulation/>4.23.1 کپسوله سازی (Encapsulation)</a></li><li><a href=/chapter-4/oop/go-inheritance/>4.22.2 ارث بری</a></li><li><a href=/chapter-4/oop/go-polymorphism/>4.23.3 پلی مورفیسم (Polymorphism)</a></li><li><a href=/chapter-4/oop/go-overriding/>4.23.4 overriding</a></li><li><a href=/chapter-4/oop/go-abstraction/>4.23.5 abstraction</a></li></ul></li><li><a href=/chapter-4/tracing/>4.24 آموزش tracing</a></li><li><a href=/chapter-4/profiling/>4.25 آموزش profiling</a></li><li><a href=/chapter-4/go-project-layout/>4.26 ساختار پروژه</a></li><li><a href=/chapter-4/go-io-package/ class=active>4.27 آموزش کار با پکیج io</a></li></ul></li><li><input type=checkbox id=section-134502b5358f6cf5c83ad497f832087a class=toggle>
<label for=section-134502b5358f6cf5c83ad497f832087a class=flex><a href=/chapter-5/ class=flex-auto>فصل پنجم: برنامه نویسی شبکه با گو</a></label><ul><li><a href=/chapter-5/network-basic/>5.1 شبکه چیست</a></li><li><a href=/chapter-5/go-tcp-server-begginer/>5.2 سرور tcp مقدماتی</a></li><li><a href=/chapter-5/go-tcp-server-advanced/>5.3 سرور tcp پیشرفته</a></li><li><a href=/chapter-5/go-udp-server-begginer/>5.4 سرور udp مقدماتی</a></li><li><a href=/chapter-5/go-udp-server-advanced/>5.5 سرور udp پیشرفته</a></li><li><a href=/chapter-5/go-http-server-begginer/>5.6 کتابخانه http سمت سرور مقدماتی</a></li><li><a href=/chapter-5/go-http-server-advanced/>5.7 کتابخانه http سمت سرور پیشرفته</a></li><li><a href=/chapter-5/go-http-client-begginer/>5.8 کتابخانه http سمت کلاینت مقدماتی</a></li><li><a href=/chapter-5/go-http-client-advanced/>5.9 کتابخانه http سمت کلاینت پیشرفته</a></li><li><a href=/chapter-5/go-quic-prtoocol/>5.10 پروتکل quic</a></li></ul></li><li><input type=checkbox id=section-6f78676abc6f42fefd423ea7de4e1c4d class=toggle>
<label for=section-6f78676abc6f42fefd423ea7de4e1c4d class=flex><a href=/chapter-6/ class=flex-auto>فصل ششم: ژنریک ها (Generics)</a></label><ul><li><a href=/chapter-6/go-generics-basic/>6.1 مقدمه و اهمیت ژنریک‌ها</a></li><li><a href=/chapter-6/go-generics-fundamentals/>6.2 مبانی ژنریک‌ها در Go</a></li><li><a href=/chapter-6/go-generics-syntax-and-structure/>6.3 سینتکس و ساختار ژنریک‌ها در Go</a></li><li><a href=/chapter-6/go-generics-type-sets-and-constraints/>6.4 Constraints و Type Sets</a></li><li><a href=/chapter-6/go-generics-examples-and-practical/>6.5 مثال‌ها و کاربردهای عملی ژنریک‌ها</a></li><li><a href=/chapter-6/comparing-generics/>6.6 مقایسه ژنریک‌ها با راهکارهای قبل از Go 1.18</a></li><li><a href=/chapter-6/limitations-errors-and-anti-patterns-in-generics/>6.7 محدودیت‌ها، خطاها و ضدالگوها در ژنریک‌ها</a></li><li><a href=/chapter-6/generics-best-practice/>6.8 بهترین شیوه‌های استفاده از ژنریک‌ها (Best Practices)</a></li><li><a href=/chapter-6/generics-advanced-examples-and-tips/>6.9 مثال‌های پیشرفته و نکات ویژه</a></li></ul></li><li><input type=checkbox id=section-8f5df719cb6867058bc4273b800e1879 class=toggle>
<label for=section-8f5df719cb6867058bc4273b800e1879 class=flex><a href=/chapter-7/ class=flex-auto>فصل هفتم: تست نویسی</a></label><ul><li><a href=/chapter-7/go-introduction-testing/>7.1 مقدمه‌ای بر تست در Go</a></li><li><a href=/chapter-7/go-unit-testing/>7.2 تست واحد (Unit Test)</a></li><li><a href=/chapter-7/go-table-driven-tests/>7.3 تست جدول‌محور (Table-Driven Test)</a></li></ul></li><li><input type=checkbox id=section-46582e13a18a41adc7936c360b185ec8 class=toggle>
<label for=section-46582e13a18a41adc7936c360b185ec8 class=flex><a href=/chapter-8/ class=flex-auto>فصل هشتم: پکیج های استاندارد</a></label><ul></ul></li><li><input type=checkbox id=section-7b4fd75e0c8dddcfaf05d2809955458b class=toggle>
<label for=section-7b4fd75e0c8dddcfaf05d2809955458b class=flex><a href=/chapter-9/ class=flex-auto>فصل نهم: الگوهای طراحی</a></label><ul><li><input type=checkbox id=section-91fecfeb90059a6577f742161c3cc416 class=toggle>
<label for=section-91fecfeb90059a6577f742161c3cc416 class=flex><a href=/chapter-9/creational-patterns/ class=flex-auto>9.1 الگوهای طراحی سازنده</a></label><ul><li><a href=/chapter-9/creational-patterns/go-singleton-pattern/>9.1.1 الگو Singleton</a></li><li><a href=/chapter-9/creational-patterns/go-factory-method-pattern/>9.1.2 الگو Factory Method</a></li><li><a href=/chapter-9/creational-patterns/go-prototype-pattern/>9.1.3 الگو Prototype</a></li><li><a href=/chapter-9/creational-patterns/go-abstract-factory-pattern/>9.1.4 الگو Abstract Factory</a></li><li><a href=/chapter-9/creational-patterns/go-builder-pattern/>9.1.6 الگو Builder</a></li><li><a href=/chapter-9/creational-patterns/go-object-pool-pattern/>9.1.7 الگو Object Pool</a></li></ul></li><li><input type=checkbox id=section-0bf1b67244bd7a1b2067d73a9ac05c84 class=toggle>
<label for=section-0bf1b67244bd7a1b2067d73a9ac05c84 class=flex><a href=/chapter-9/structural-patterns/ class=flex-auto>9.2 الگوهای طراحی ساختاری</a></label><ul><li><a href=/chapter-9/structural-patterns/go-adaptor-pattern/>9.2.1 الگو Adaptor</a></li><li><a href=/chapter-9/structural-patterns/go-bridge-pattern/>9.2.2 الگو Bridge</a></li><li><a href=/chapter-9/structural-patterns/go-composite-pattern/>9.2.3 الگو Composite</a></li><li><a href=/chapter-9/structural-patterns/go-decorator-pattern/>9.2.1 الگو Decorator</a></li><li><a href=/chapter-9/structural-patterns/go-facade-pattern/>9.2.5 الگو Facade</a></li><li><a href=/chapter-9/structural-patterns/go-flyweight-pattern/>9.2.6 الگو Flyweight</a></li><li><a href=/chapter-9/structural-patterns/go-proxy-pattern/>9.2.7 الگو Proxy</a></li></ul></li><li><input type=checkbox id=section-67e202f99a50c1e49347339369c874b1 class=toggle>
<label for=section-67e202f99a50c1e49347339369c874b1 class=flex><a href=/chapter-9/behavioral-patterns/ class=flex-auto>9.3 الگوهای طراحی رفتاری</a></label><ul><li><a href=/chapter-9/behavioral-patterns/go-chain-of-responsibility-pattern/>9.3.1 الگو Chain Of Responsibility</a></li><li><a href=/chapter-9/behavioral-patterns/go-command-pattern/>9.3.2 الگو Command</a></li><li><a href=/chapter-9/behavioral-patterns/go-iterator-pattern/>9.3.3 الگو Iterator</a></li><li><a href=/chapter-9/behavioral-patterns/go-mediator-pattern/>9.3.4 الگو Mediator</a></li><li><a href=/chapter-9/behavioral-patterns/go-memento-pattern/>9.3.5 الگو Memento</a></li><li><a href=/chapter-9/behavioral-patterns/go-observer-pattern/>9.3.6 الگو Observer</a></li><li><a href=/chapter-9/behavioral-patterns/go-state-pattern/>9.3.7 الگو State</a></li><li><a href=/chapter-9/behavioral-patterns/go-strategy-pattern/>9.3.8 الگو Strategy</a></li><li><a href=/chapter-9/behavioral-patterns/go-template-method-pattern/>9.3.9 الگو Template Method</a></li><li><a href=/chapter-9/behavioral-patterns/go-visitor-pattern/>9.3.10 الگو Visitor</a></li></ul></li><li><input type=checkbox id=section-a8aa81f62696e9f9c69a81a3318a50eb class=toggle>
<label for=section-a8aa81f62696e9f9c69a81a3318a50eb class=flex><a href=/chapter-9/concurrency-patterns/ class=flex-auto>9.4 الگوهای همزمانی</a></label><ul><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-wait-for-result/>9.4.1 الگو Wait For Result</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-fan-out-in/>9.4.2 الگو Fan Out/In</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-wait-for-task/>9.4.3 الگو Wait For Task</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-worker-pool/>9.4.4 الگوی Worker Pool</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-drop/>9.4.5 الگو Drop</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-cancellation/>9.4.6 الگو Context Cancellation Pattern</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-semaphore/>9.4.7 الگو Semaphore</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-retry-timeout/>9.4.8 الگو Retry Timeout</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-producer-consumer/>9.4.9 الگو Producer-Consumer</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-monitor/>9.4.10 الگو Monitor</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-future/>9.4.11 الگو Future</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-pipeline/>9.4.12 الگو Pipeline</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-subscription/>9.4.13 الگو Subscription</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-brdige-channel/>9.4.14 الگو Bridge Channel</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-queuing/>9.4.15 الگو Queuing</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-ratelimit/>9.4.16 الگو Rate limit</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-deadlock-recovery/>9.4.17 الگو Deadlock Recovery</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-channel-cancellation/>9.4.18 الگو Channel Cancellation</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-lock-free-synchronization/>9.4.19 الگو Lock-free synchronization</a></li></ul></li><li><input type=checkbox id=section-d4428d0313ccb2e3380b00740324e064 class=toggle>
<label for=section-d4428d0313ccb2e3380b00740324e064 class=flex><a href=/chapter-9/cloud-native-patterns/ class=flex-auto>9.5 الگوهای Cloud Native</a></label><ul><li><a href=/chapter-9/cloud-native-patterns/go-cloud-native-circuit-breaker-pattern/>9.5.1 الگو Circuit Breaker</a></li><li><a href=/chapter-9/cloud-native-patterns/go-cloud-native-debounce-pattern/>9.5.2 الگو Debounce</a></li><li><a href=/chapter-9/cloud-native-patterns/go-cloud-native-retry-pattern/>9.5.3 الگو Retry</a></li><li><a href=/chapter-9/cloud-native-patterns/go-cloud-native-throttle-pattern/>9.5.4 الگو Throttle</a></li><li><a href=/chapter-9/cloud-native-patterns/go-cloud-native-timeout-pattern/>9.5.5 الگو Timeout</a></li></ul></li><li><input type=checkbox id=section-d2db70ad636838c12fc76435099656ac class=toggle>
<label for=section-d2db70ad636838c12fc76435099656ac class=flex><a href=/chapter-9/anti-pattern/ class=flex-auto>9.6 ضد الگوها (Anti-Patterns)</a></label><ul><li><a href=/chapter-9/anti-pattern/go-anti-patterns-in-syntax/>9.6.1 ضد الگو سینتکسی</a></li></ul></li><li><a href=/chapter-9/solid-principle-in-golang/>9.7 اصول SOLID</a></li></ul></li><li><input type=checkbox id=section-109a423730eebb4b9e804ab6e8dc6af0 class=toggle>
<label for=section-109a423730eebb4b9e804ab6e8dc6af0 class=flex><a href=/chapter-10/ class=flex-auto>فصل دهم: الگوریتم و ساختار داده</a></label><ul><li><a href=/chapter-10/10.1--data-structures-queue-stack-lists/>10.1 Data Structures (Queue Stack Lists)</a></li></ul></li><li><input type=checkbox id=section-0736842d303fef477d0a09e8de4a0d85 class=toggle>
<label for=section-0736842d303fef477d0a09e8de4a0d85 class=flex><a href=/chapter-11/ class=flex-auto>فصل یازدهم: معماری های نرم افزار</a></label><ul></ul></li><li><input type=checkbox id=section-efb5b19050ead65a76618516db266d2d class=toggle>
<label for=section-efb5b19050ead65a76618516db266d2d class=flex><a href=/chapter-12/ class=flex-auto>فصل دوازدهم: شبکه بلاکچین</a></label><ul><li><input type=checkbox id=section-ee81a41ef810f317eba2e67d447c0ec4 class=toggle>
<label for=section-ee81a41ef810f317eba2e67d447c0ec4 class=flex><a href=/chapter-12/blockchain/ class=flex-auto>12.1 بلاکچین</a></label><ul><li><a href=/chapter-12/blockchain/blockchain/>12.1.1 بلاکچین چیست</a></li><li><a href=/chapter-12/blockchain/blockchain-history/>12.1.2 تاریخچه بلاکچین</a></li><li><a href=/chapter-12/blockchain/blockchain-architecture/>12.1.3 معماری بلاکچین</a></li><li><a href=/chapter-12/blockchain/blockchain-type/>12.1.4 انواع بلاکچین</a></li><li><a href=/chapter-12/blockchain/blockchain-different-with-centerlized/>12.1.5 تفاوت سیستم متمرکز با غیرمتمرکز</a></li><li><a href=/chapter-12/blockchain/blockchain-scale/>12.1.6 مقیاس پذیری در بلاکچین</a></li><li><a href=/chapter-12/blockchain/blockchain-security/>12.1.7 امنیت در بلاکچین</a></li><li><a href=/chapter-12/blockchain/blockchain-cryptography/>12.1.8 مفاهیم رمزنگاری</a></li><li><a href=/chapter-12/blockchain/blockchain-consensus-algorithm/>12.1.10 الگوریتم اجماع (Consensus)</a></li><li><a href=/chapter-12/blockchain/blockchain-p2p-network/>12.1.11 ساختار و کاربرد شبکه P2P</a></li><li><a href=/chapter-12/blockchain/blockchain-data-management/>12.1.12 مدیریت داده در بلاکچین</a></li><li><a href=/chapter-12/blockchain/blockchain-network-testing/>12.1.13 تست پذیری شبکه</a></li><li><a href=/chapter-12/blockchain/blockchain-analyze-and-optimization/>12.1.14 ارزیابی و بهینه سازی شبکه</a></li><li><a href=/chapter-12/blockchain/blockchain-monitoring/>12.1.15 مانیتورینگ شبکه</a></li><li><a href=/chapter-12/blockchain/blockchain-forking/>12.1.16 استراتژی فورک ها</a></li><li><a href=/chapter-12/blockchain/blockchain-api-and-sdk/>12.1.17 پیاده سازی انواع API ها و SDK ها</a></li><li><a href=/chapter-12/blockchain/blockchain-keys-and-addresses/>12.1.18 کلیدها و آدرس ها</a></li><li><a href=/chapter-12/blockchain/blockchain-accounts/>12.1.19 اکانت ها</a></li><li><a href=/chapter-12/blockchain/blockchain-transactions-and-messages/>12.1.20 تراکنش ها و پیام ها</a></li><li><a href=/chapter-12/blockchain/blockchain-blocks/>12.1.21 بلوک ها (Blocks)</a></li><li><a href=/chapter-12/blockchain/blockchain-genesis/>12.1.22 جنسیس (Genesis)</a></li><li><a href=/chapter-12/blockchain/blockchain-smart-contracts/>12.1.23 قراردادهای هوشمند</a></li><li><a href=/chapter-12/blockchain/blockchain-privacy/>12.1.24 حریم خصوصی شبکه</a></li></ul></li><li><input type=checkbox id=section-3a22b13c7bb1ba964a59c01435868bd6 class=toggle>
<label for=section-3a22b13c7bb1ba964a59c01435868bd6 class=flex><a href=/chapter-12/bitcoin/ class=flex-auto>12.2 شبکه بیت کوین</a></label><ul><li><a href=/chapter-12/bitcoin/bitcoin/>12.2.1 معرفی بیت کوین</a></li><li><a href=/chapter-12/bitcoin/bitcoin-cryptography/>12.2.2 رمزنگاری در بیت کوین</a></li><li><a href=/chapter-12/bitcoin/bitcoin-addresses/>12.2.3 آدرس ها</a></li><li><a href=/chapter-12/bitcoin/bitcoin-transactions/>12.2.4 تراکنش ها</a></li><li><a href=/chapter-12/bitcoin/bitcoin-structure/>12.2.5 ساختار بلاکچین بیت کوین</a></li><li><a href=/chapter-12/bitcoin/bitcoin-consensus/>12.2.6 الگوریتم اجماع</a></li><li><a href=/chapter-12/bitcoin/bitcoin-miners/>12.2.7 ماینرها</a></li><li><a href=/chapter-12/bitcoin/bitcoin-network/>12.2.8 شبکه</a></li><li><a href=/chapter-12/bitcoin/bitcoin-wallets/>12.2.9 والت ها</a></li><li><a href=/chapter-12/bitcoin/bitcoin-in-real-world/>12.2.10 بیت کوین در دنیای واقعی</a></li><li><a href=/chapter-12/bitcoin/bitcoin-innovation/>12.2.11 نوآوری</a></li><li><a href=/chapter-12/bitcoin/bitcoin-clients/>12.2.12 کلاینت ها</a></li><li><a href=/chapter-12/bitcoin/bitcoin-programming/>12.2.13 برنامه نویسی در بیت کوین</a></li></ul></li><li><input type=checkbox id=section-b9f4acac44a727569ffab43028a36441 class=toggle>
<label for=section-b9f4acac44a727569ffab43028a36441 class=flex><a href=/chapter-12/ethereum/ class=flex-auto>12.3 شبکه اتریوم</a></label><ul><li><a href=/chapter-12/ethereum/ethereum/>12.3.1 معرفی اتریوم</a></li><li><a href=/chapter-12/ethereum/ethereum-cryptography/>12.3.2 رمزنگاری</a></li><li><a href=/chapter-12/ethereum/ethereum-keys-and-addresses/>12.3.3 آدرس ها و کلیدها</a></li><li><a href=/chapter-12/ethereum/ethereum-accounts/>12.3.4 اکانت ها</a></li><li><a href=/chapter-12/ethereum/ethereum-transactions-and-messages/>12.3.5 تراکنش ها و پیام ها</a></li><li><a href=/chapter-12/ethereum/ethereum-virtual-machine/>12.3.6 ماشین مجازی اتریوم</a></li><li><a href=/chapter-12/ethereum/ethereum-blocks/>12.3.7 بلاک ها</a></li><li><a href=/chapter-12/ethereum/ethereum-consensus/>12.3.8 الگوریتم اجماع</a></li><li><a href=/chapter-12/ethereum/ethereum-nodes-and-miners/>12.3.9 نودها و ماینرها</a></li><li><a href=/chapter-12/ethereum/ethereum-network/>12.3.10 شبکه</a></li><li><a href=/chapter-12/ethereum/ethereum-smart-contracts/>12.3.11 قراردادهای هوشمند</a></li><li><a href=/chapter-12/ethereum/ethereum-wallets-and-clients/>12.3.12 والت ها و کلاینت ها</a></li><li><a href=/chapter-12/ethereum/go-ethereum/>12.3.13 معرفی go-ethereum</a></li><li><a href=/chapter-12/ethereum/work-with-accounts/>12.3.14 کار با اکانت ها</a></li><li><a href=/chapter-12/ethereum/transactions-on-ethereum/>12.3.15 تراکنش برروی اتریوم</a></li><li><a href=/chapter-12/ethereum/read-write-in-smart-contracts/>12.3.16 نوشتن و ارتباط با قراردادهای هوشمند</a></li><li><a href=/chapter-12/ethereum/abi-and-bin-file/>12.3.17 آشنایی با فایل ABI و bytecode</a></li><li><a href=/chapter-12/ethereum/event-logs/>12.3.18 خواندن و دریافت لحظه ای لاگ های کانترکت ها</a></li><li><a href=/chapter-12/ethereum/signature/>12.3.19 ایجاد و تایید امضا</a></li><li><a href=/chapter-12/ethereum/geth/>12.3.20 کار با geth</a></li><li><a href=/chapter-12/ethereum/protocol-swarm-and-whisper/>12.3.21 کار با پروتکل whisper و swarm</a></li></ul></li><li><input type=checkbox id=section-71c1e946dcbe629ce566392c9ba8a5bd class=toggle>
<label for=section-71c1e946dcbe629ce566392c9ba8a5bd class=flex><a href=/chapter-12/pactus/ class=flex-auto>12.4 شبکه پکتوس</a></label><ul><li><a href=/chapter-12/pactus/pactus/>12.4.1 معرفی پکتوس</a></li><li><a href=/chapter-12/pactus/pactus-roadmap/>12.4.2 نقشه راه و اهداف</a></li><li><a href=/chapter-12/pactus/pactus-cryptography/>12.4.3 رمزنگاری</a></li><li><a href=/chapter-12/pactus/pactus-addresses-and-keys/>12.4.4 آدرس ها و کلیدها</a></li><li><a href=/chapter-12/pactus/pactus-accounts/>12.4.5 اکانت ها</a></li><li><a href=/chapter-12/pactus/pactus-transactions-and-messages/>12.4.6 تراکنش ها و پیغام ها</a></li><li><a href=/chapter-12/pactus/pactus-consensus/>12.4.7 الگوریتم اجماع</a></li><li><a href=/chapter-12/pactus/pactus-client/>12.4.8 کار با کلاینت</a></li><li><a href=/chapter-12/pactus/pactus-smart-contracts/>12.4.9 قراردادهای هوشمند (بزودی)</a></li></ul></li></ul></li></ul><a class="book-btn gray" href=https://github.com/GoFarsi/book>مخزن کتاب</a>
<a class=book-btn href=https://github.com/GoFarsi/book/blob/main/COUNTRIBUTING.md>مشارکت در کتاب زبان گو</a><center><p><img alt="GitHub Repo stars" src=https://img.shields.io/github/stars/GoFarsi/book> <img alt=GitHub src=https://img.shields.io/github/license/gofarsi/book> <img alt="GitHub contributors" src=https://img.shields.io/github/contributors/gofarsi/book></p></center></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>4.27 آموزش کار با پکیج io</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"></br><main><div class=wrapper><a href=https://t.me/GolangEngineers class="icon telegram" target=_blank><div class=tooltip>گروه تلگرامی مهندسین گولنگ</div><span><i class="fab fa-telegram"></i></span>
</a><a href=https://linkedin.com/in/Ja7ad class="icon linkedin" target=_blank><div class=tooltip>لینکدین نویسنده</div><span><i class="fab fa-linkedin"></i></span>
</a><a href=https://twitter.com/Ja7adR class="icon twitter" target=_blank><div class=tooltip>توییتر نویسنده</div><span><i class="fab fa-twitter"></i></span></a></div></main></br></br><nav id=TableOfContents><ul><li><ul><li><a href=#4271-معرفی-پکیج-io-و-فلسفه-طراحی>4.27.1 معرفی پکیج io و فلسفه طراحی</a><ul><li><a href=#42711-اهمیت-abstraction-در-io>4.27.1.1 اهمیت abstraction در I/O</a></li><li><a href=#42712-نقش-io-در-کتابخانه-استاندارد-go>4.27.1.2 نقش io در کتابخانه استاندارد Go</a></li></ul></li><li><a href=#4272-اینترفیسهای-اصلی-پکیج-io>4.27.2 اینترفیس‌های اصلی پکیج io</a><ul><li><a href=#42721-ioreader-و-متد-read>4.27.2.1 io.Reader و متد Read</a></li><li><a href=#42722-iowriter-و-متد-write>4.27.2.2 io.Writer و متد Write</a></li><li><a href=#42723-ترکیب-اینترفیسها>4.27.2.3 ترکیب اینترفیس‌ها</a></li><li><a href=#42724-ioseeker-و-جابهجایی-در-دادهها>4.27.2.4 io.Seeker و جابه‌جایی در داده‌ها</a></li></ul></li><li><a href=#4273-توابع-کمکی-کاربردی>4.27.3 توابع کمکی کاربردی</a><ul><li><a href=#42731-iocopy-و-iocopyn>4.27.3.1 io.Copy و io.CopyN</a></li><li><a href=#42732-iomultireader-و-iomultiwriter>4.27.3.2 io.MultiReader و io.MultiWriter</a></li><li><a href=#42733-ioteereader>4.27.3.3 io.TeeReader</a></li><li><a href=#42734-iolimitreader-و-iolimitwriter>4.27.3.4 io.LimitReader و io.LimitWriter</a></li><li><a href=#42735-ioreadall>4.27.3.5 io.ReadAll</a></li><li><a href=#42736-iosectionreader>4.27.3.6 io.SectionReader</a></li></ul></li><li><a href=#4274-کار-با-iopipe-و-ارتباط-بین-goroutines>4.27.4 کار با io.Pipe و ارتباط بین Goroutines</a></li><li><a href=#42741-مفاهیم-pipereader-و-pipewriter>4.27.4.1 مفاهیم PipeReader و PipeWriter</a><ul><li><a href=#مثال-۱-ابتداییترین-اتصال-producerconsumer-با-iocopy>مثال ۱: ابتدایی‌ترین اتصال Producer/Consumer با <code>io.Copy</code></a></li></ul></li><li><a href=#42742-استفاده-در-جریان-داده-streaming>4.27.4.2 استفاده در جریان داده (Streaming)</a><ul><li><a href=#مثال-۲-فشردهسازی-on-the-fly-با-compressgzip-روی-pipe>مثال ۲: فشرده‌سازی on-the-fly با <code>compress/gzip</code> روی pipe</a></li><li><a href=#مثال-۳-محاسبه-checksum-همزمان-با-عبور-داده-pipe--teereader>مثال ۳: محاسبهٔ checksum همزمان با عبور داده (Pipe + TeeReader)</a></li></ul></li><li><a href=#42743-الگوهای-همزمانی-با-iopipe>4.27.4.3 الگوهای همزمانی با io.Pipe</a><ul><li><a href=#نکات-production-ready-خلاصه>نکات Production-Ready خلاصه</a></li></ul></li><li><a href=#4275-پیادهسازی-reader-و-writer-سفارشی>4.27.5 پیاده‌سازی Reader و Writer سفارشی</a><ul><li><a href=#42751-ساخت-یک-custom-reader>4.27.5.1 ساخت یک Custom Reader</a></li><li><a href=#42752-ساخت-یک-custom-writer>4.27.5.2 ساخت یک Custom Writer</a></li><li><a href=#42753-پیادهسازی-ioreaderfrom-و-iowriterto-برای-بهینهسازی>4.27.5.3 پیاده‌سازی io.ReaderFrom و io.WriterTo برای بهینه‌سازی</a></li></ul></li><li><a href=#4276-مدیریت-خطا-در-io>4.27.6 مدیریت خطا در io</a><ul><li><a href=#42761-تفاوت-ioeof-با-خطاهای-دیگر>4.27.6.1 تفاوت <code>io.EOF</code> با خطاهای دیگر</a></li><li><a href=#42762-مدیریت-خطا-در-عملیات-طولانی>4.27.6.2 مدیریت خطا در عملیات طولانی</a></li></ul></li><li><a href=#4277-best-practices-در-استفاده-از-io>4.27.7 Best Practices در استفاده از io</a><ul><li><a href=#42771-استفاده-از-interface-به-جای-نوع-خاص>4.27.7.1 استفاده از Interface به جای نوع خاص</a></li><li><a href=#42772-بهینهسازی-با-bufio>4.27.7.2 بهینه‌سازی با bufio</a></li><li><a href=#42773-مدیریت-منابع-با-iocloser-و-defer>4.27.7.3 مدیریت منابع با io.Closer و defer</a></li><li><a href=#42774-انتخاب-اندازه-buffer-مناسب>4.27.7.4 انتخاب اندازه buffer مناسب</a></li><li><a href=#42775-آپلود-استریمی-فایل-بزرگ-با-ذخیرهسازی-امن-atomic-روی-دیسک>4.27.7.5 آپلود استریمیِ فایل بزرگ با ذخیره‌سازی امن (atomic) روی دیسک</a></li><li><a href=#اصول>اصول</a></li><li><a href=#هندلر-نمونه-http-multipartform-data>هندلر نمونه (HTTP، <code>multipart/form-data</code>)</a></li><li><a href=#نکات-کلیدی>نکات کلیدی</a></li><li><a href=#آیا-اینجا-از-iopipe-استفاده-کنیم>آیا اینجا از <code>io.Pipe</code> استفاده کنیم؟</a></li></ul></li></ul></li></ul></nav></aside></header><h1>4.27 آموزش کار با پکیج io</h1><article class="markdown book-article"><p align=center><img src=../../assets/img/content/chapter4/io/go-io.png alt=io></p><p>پکیج <code>io</code> در زبان Go یکی از ابزارهای پایه و همه‌فن‌حریف برای کار با عملیات <span class=tooltip data-tooltip=ورودی/خروجی ontouchend=toggleTooltip(this)>Input/Output</span>
است. فلسفه‌اش اینه که ما بدون وابستگی به نوع خاص داده (مثل فایل، شبکه یا حافظه) بتونیم از یک <span class=tooltip data-tooltip=رابط ontouchend=toggleTooltip(this)>Interface</span>
ساده استفاده کنیم. این یعنی اگر یک شیء فقط متد مورد نیاز رو پیاده‌سازی کنه، می‌تونه در تمام جاهایی که اون رابط انتظار میره استفاده بشه. مثلا <code>io.Reader</code> فقط یک متد <code>Read</code> داره و <code>io.Writer</code> یک متد <code>Write</code>، ولی همین دو قرارداد ساده پایه تمام سیستم <span class=tooltip data-tooltip="انتزاع ورودی/خروجی" ontouchend=toggleTooltip(this)>I/O Abstraction</span>
در Go رو تشکیل میدن.</p><p>اینترفیس‌های اصلی این پکیج مثل <code>io.Reader</code> و <code>io.Writer</code> رو میشه ترکیب کرد و ساختارهای جدیدی ساخت، مثل <code>io.ReadWriter</code> که هم قابلیت خواندن داره و هم نوشتن، یا <code>io.ReadCloser</code> که علاوه بر خواندن، قابلیت بستن منبع داده رو هم فراهم می‌کنه. این ترکیب‌ها به ما امکان میدن با منابع داده‌ای مختلف، از فایل گرفته تا اتصال شبکه، به شکلی یکپارچه کار کنیم. وقتی کد رو بر اساس اینترفیس‌ها بنویسیم، نه‌تنها تست‌پذیرتر و قابل توسعه‌تر میشه، بلکه وابستگی به پیاده‌سازی‌های خاص هم از بین میره.</p><p>پکیج <code>io</code> فقط به رابط‌ها محدود نیست و مجموعه‌ای از <span class=tooltip data-tooltip="توابع کمکی" ontouchend=toggleTooltip(this)>Helper Functions</span>
رو هم ارائه میده که کار رو به شدت ساده‌تر و بهینه‌تر می‌کنن. مثلا <code>io.Copy</code> داده رو مستقیم از یک <code>Reader</code> به یک <code>Writer</code> منتقل می‌کنه بدون اینکه ما نیاز به نوشتن حلقه خواندن و نوشتن داشته باشیم. <code>io.MultiWriter</code> خروجی رو به چند مقصد به طور همزمان ارسال می‌کنه، و <code>io.TeeReader</code> برای زمانی که می‌خوای داده رو بخونی و همزمان یک نسخه ازش رو برای <span class=tooltip data-tooltip="ثبت رویداد" ontouchend=toggleTooltip(this)>Logging</span>
یا <span class=tooltip data-tooltip=اشکال‌زدایی ontouchend=toggleTooltip(this)>Debugging</span>
ذخیره کنی عالیه. همچنین ابزارهایی مثل <code>io.LimitReader</code> یا <code>io.SectionReader</code> وجود دارن که اجازه میدن فقط بخش خاصی از داده رو پردازش کنیم.</p><p>در بخش پیشرفته‌تر، این پکیج امکاناتی مثل <code>io.Pipe</code> رو هم ارائه میده که دو سر ورودی و خروجی رو به هم وصل می‌کنه و به‌ویژه برای <span class=tooltip data-tooltip="جریان داده" ontouchend=toggleTooltip(this)>Streaming</span>
و ارتباط بین <span class=tooltip data-tooltip=گوروتین‌ها ontouchend=toggleTooltip(this)>Goroutines</span>
بسیار کاربردیه. نکته مهم توی استفاده از این پکیج مدیریت درست خطاست؛ مثلا تفاوت <code>io.EOF</code> که فقط نشون‌دهنده پایان داده‌ست با یک خطای واقعی رو باید بدونیم. همچنین استفاده از بافرها (<code>bufio</code>) برای بهبود کارایی و کاهش هزینه I/O در پروژه‌های <span class=tooltip data-tooltip="محیط عملیاتی" ontouchend=toggleTooltip(this)>Production</span>
توصیه میشه.</p><h2 id=4271-معرفی-پکیج-io-و-فلسفه-طراحی>4.27.1 معرفی پکیج io و فلسفه طراحی
<a class=anchor href=#4271-%d9%85%d8%b9%d8%b1%d9%81%db%8c-%d9%be%da%a9%db%8c%d8%ac-io-%d9%88-%d9%81%d9%84%d8%b3%d9%81%d9%87-%d8%b7%d8%b1%d8%a7%d8%ad%db%8c>#</a></h2><p>پکیج <code>io</code> در زبان Go یک بخش کلیدی از کتابخانه استاندارد است که پایه و اساس تمام عملیات <span class=tooltip data-tooltip=ورودی/خروجی ontouchend=toggleTooltip(this)>Input/Output</span>
را فراهم می‌کند. هدف اصلی این پکیج، ایجاد یک <span class=tooltip data-tooltip=انتزاع ontouchend=toggleTooltip(this)>Abstraction</span>
ساده اما قدرتمند برای خواندن و نوشتن داده است، بدون این‌که برنامه‌نویس به منبع یا مقصد خاصی وابسته باشد. این یعنی چه داده از یک فایل بیاید، چه از یک اتصال شبکه یا حتی از حافظه، کدی که آن را پردازش می‌کند یکسان خواهد بود.</p><p>در قلب این پکیج دو <span class=tooltip data-tooltip=رابط ontouchend=toggleTooltip(this)>Interface</span>
بسیار ساده قرار دارند: <code>io.Reader</code> و <code>io.Writer</code>.</p><ul><li><strong><code>io.Reader</code></strong>: فقط یک متد <code>Read</code> دارد که داده را به صورت بایت‌اسلایس می‌خواند.</li><li><strong><code>io.Writer</code></strong>: فقط یک متد <code>Write</code> دارد که داده را به یک مقصد ارسال می‌کند.</li></ul><p>هر نوعی (type) که این متدها را پیاده‌سازی کند، به طور خودکار به یک منبع یا مقصد داده قابل استفاده در اکوسیستم <code>io</code> تبدیل می‌شود. همین سادگی باعث شده که اجزای مختلف سیستم، از جمله پکیج‌هایی مثل <code>os</code>، <code>net</code>، <code>bufio</code> و <code>compress</code>، بتوانند به راحتی با هم ترکیب شوند.</p><p>یکی از مزیت‌های بزرگ این طراحی این است که به‌جای وابستگی به نوع خاص، وابستگی به رفتار داریم. مثلا تابعی که یک <code>io.Reader</code> را می‌گیرد، می‌تواند بدون تغییر، هم از یک فایل روی دیسک بخواند و هم از یک جریان داده آنلاین یا حتی داده تولیدشده در حافظه. این قابلیت انعطاف‌پذیری بالا را ممکن می‌سازد و کد را برای تست و توسعه آسان‌تر می‌کند.</p><p>در نتیجه، پکیج <code>io</code> نه فقط یک ابزار برای کار با داده، بلکه یک لایه انتزاعی است که ساختار و معماری برنامه را ساده، منسجم و مقیاس‌پذیر نگه می‌دارد. این فلسفه مینیمالیستی و ماژولار، از دلایلی است که Go را برای پروژه‌های بزرگ و طولانی‌مدت به انتخابی محبوب تبدیل کرده است.</p><h3 id=42711-اهمیت-abstraction-در-io>4.27.1.1 اهمیت abstraction در I/O
<a class=anchor href=#42711-%d8%a7%d9%87%d9%85%db%8c%d8%aa-abstraction-%d8%af%d8%b1-io>#</a></h3><p>وقتی صحبت از <span class=tooltip data-tooltip=ورودی/خروجی ontouchend=toggleTooltip(this)>Input/Output</span>
می‌شود، خیلی‌ها اولین چیزی که به ذهنشان می‌رسد یک فایل روی دیسک یا یک اتصال شبکه است. اما در عمل، منابع داده می‌توانند بسیار متنوع باشند: یک فایل محلی، یک API، یک بافر حافظه، یا حتی داده تولیدشده لحظه‌ای توسط یک الگوریتم. اگر برای هر کدام بخواهیم کد جداگانه بنویسیم، خیلی زود با یک مجموعه توابع و کلاس‌های تکراری و پیچیده روبه‌رو می‌شویم که نگهداری آن‌ها کابوس خواهد بود.</p><p>اینجاست که <span class=tooltip data-tooltip=انتزاع ontouchend=toggleTooltip(this)>Abstraction</span>
وارد میدان می‌شود. با تعریف یک <span class=tooltip data-tooltip=رابط ontouchend=toggleTooltip(this)>Interface</span>
مشترک مثل <code>io.Reader</code> یا <code>io.Writer</code>، می‌توانیم منطق اصلی کد را مستقل از منبع یا مقصد داده بنویسیم. این یعنی یک تابعی که داده را از ورودی می‌خواند و روی خروجی می‌نویسد، می‌تواند بدون تغییر هم روی فایل کار کند، هم روی شبکه، و هم روی داده‌های در حافظه.</p><p>مثلا تصور کنید می‌خواهیم یک تابع بنویسیم که محتوا را از یک <span class=tooltip data-tooltip=خواننده ontouchend=toggleTooltip(this)>Reader</span>
به یک <span class=tooltip data-tooltip=نویسنده ontouchend=toggleTooltip(this)>Writer</span>
منتقل کند:</p><pre><code class=language-go>func TransferData(src io.Reader, dst io.Writer) error {
    _, err := io.Copy(dst, src)
    return err
}
</code></pre><p>این تابع اصلاً اهمیتی نمی‌دهد که <code>src</code> یک فایل است (<code>*os.File</code>)، یک اتصال TCP (<code>net.Conn</code>) یا حتی یک رشته متنی در حافظه (<code>strings.Reader</code>). کافی است آن منبع متد <code>Read</code> را داشته باشد. همین موضوع باعث می‌شود کد قابل استفاده مجدد، ساده و به راحتی تست‌پذیر شود.</p><p>به این شکل، abstraction در I/O مثل یک پل عمل می‌کند که لایه منطق برنامه را از جزئیات فنی منابع داده جدا می‌کند. این کار نه تنها خوانایی و نگهداری کد را بهتر می‌کند، بلکه توسعه ویژگی‌های جدید را هم سریع‌تر و بی‌خطرتر می‌سازد.</p><h3 id=42712-نقش-io-در-کتابخانه-استاندارد-go>4.27.1.2 نقش io در کتابخانه استاندارد Go
<a class=anchor href=#42712-%d9%86%d9%82%d8%b4-io-%d8%af%d8%b1-%da%a9%d8%aa%d8%a7%d8%a8%d8%ae%d8%a7%d9%86%d9%87-%d8%a7%d8%b3%d8%aa%d8%a7%d9%86%d8%af%d8%a7%d8%b1%d8%af-go>#</a></h3><p>پکیج <code>io</code> رو میشه به‌نوعی ستون فقرات عملیات <span class=tooltip data-tooltip=ورودی/خروجی ontouchend=toggleTooltip(this)>Input/Output</span>
در کل اکوسیستم Go دونست. خیلی از پکیج‌های کتابخانه استاندارد روی همین رابط‌های ساده <code>io.Reader</code> و <code>io.Writer</code> ساخته شدن. این یعنی وقتی با اینترفیس‌های <code>io</code> کار می‌کنید، عملاً دارید با یک استاندارد مشترک صحبت می‌کنید که بقیه پکیج‌ها هم اون رو می‌فهمن.</p><p>برای مثال:</p><ul><li>پکیج <code>os</code> که برای کار با فایل‌ها استفاده میشه، وقتی فایل رو با <code>os.Open</code> باز می‌کنید، یک شیء برمی‌گردونه که هم <code>io.Reader</code> هست، هم <code>io.Writer</code>، هم <code>io.Seeker</code> و هم <code>io.Closer</code>.</li><li>پکیج <code>net</code> برای کار با شبکه، اتصالات TCP و HTTP رو به شکلی پیاده‌سازی کرده که اون‌ها هم این اینترفیس‌ها رو داشته باشن.</li><li>پکیج <code>bufio</code> که برای افزایش کارایی از بافر استفاده می‌کنه، عملاً روی همین رابط‌ها سوار شده و می‌تونه هر چیزی که <code>io.Reader</code> یا <code>io.Writer</code> باشه رو بپذیره.</li><li>پکیج‌های فشرده‌سازی مثل <code>compress/gzip</code> و <code>compress/zlib</code> هم با همین استاندارد کار می‌کنن، بنابراین می‌تونید یک فایل gzip رو بخونید و بدون تغییر خاصی روی خروجی HTTP بفرستید.</li></ul><p>این یکپارچگی باعث میشه بتونید اجزای مختلف رو خیلی راحت به هم وصل کنید. مثلا می‌تونید یک فایل فشرده رو باز کنید، خروجیش رو مستقیم از طریق شبکه بفرستید، یا برعکس داده‌های دریافتی رو مستقیماً داخل یک فایل ذخیره کنید، همه این‌ها فقط با چند خط کد.</p><p>در واقع پکیج <code>io</code> نقش یک زبان مشترک رو بین اجزای مختلف Go بازی می‌کنه. وقتی هر منبع یا مقصد داده این رابط‌ها رو پیاده‌سازی می‌کنه، شما می‌تونید اون‌ها رو به صورت ماژولار ترکیب کنید و بدون دغدغه از تفاوت‌های داخلی هر منبع، به یک جریان داده واحد برسید. این دقیقاً همون چیزی هست که Go رو در پروژه‌های بزرگ و چندبخشی، ساده و قابل اعتماد نگه می‌داره.</p><h2 id=4272-اینترفیسهای-اصلی-پکیج-io>4.27.2 اینترفیس‌های اصلی پکیج io
<a class=anchor href=#4272-%d8%a7%db%8c%d9%86%d8%aa%d8%b1%d9%81%db%8c%d8%b3%d9%87%d8%a7%db%8c-%d8%a7%d8%b5%d9%84%db%8c-%d9%be%da%a9%db%8c%d8%ac-io>#</a></h2><p>پکیج <code>io</code> بر پایه چند <span class=tooltip data-tooltip=رابط ontouchend=toggleTooltip(this)>Interface</span>
کلیدی ساخته شده که هر کدوم رفتار مشخصی رو تعریف می‌کنن. این اینترفیس‌ها شبیه یک قرارداد عمل می‌کنن؛ هر نوعی که این قرارداد رو پیاده‌سازی کنه، می‌تونه به عنوان ورودی یا خروجی در هر کدی که با اون اینترفیس کار می‌کنه استفاده بشه. این رویکرد باعث میشه کدها انعطاف‌پذیر، قابل توسعه و ماژولار باقی بمونن.</p><h3 id=42721-ioreader-و-متد-read>4.27.2.1 io.Reader و متد Read
<a class=anchor href=#42721-ioreader-%d9%88-%d9%85%d8%aa%d8%af-read>#</a></h3><p><code>io.Reader</code> مهم‌ترین و پرکاربردترین اینترفیس پکیج <code>io</code> است:</p><pre><code class=language-go>type Reader interface {
    Read(p []byte) (n int, err error)
}
</code></pre><ul><li><p><strong>پارامتر <code>p</code></strong>: یک <span class=tooltip data-tooltip="برش بایت" ontouchend=toggleTooltip(this)>Byte Slice</span>
است که داده‌ها در آن قرار می‌گیرند.</p></li><li><p><strong>برگشتی <code>n</code></strong>: تعداد بایت‌هایی که خوانده شده.</p></li><li><p><strong>برگشتی <code>err</code></strong>: اگر خطایی رخ دهد برگردانده می‌شود، که ممکن است <code>io.EOF</code> باشد تا پایان داده را نشان دهد.</p></li></ul><p>هر نوعی که این متد را پیاده‌سازی کند، می‌تواند به عنوان یک Reader استفاده شود. این منبع داده می‌تواند یک فایل، شبکه، حافظه یا هر چیز دیگری باشد.</p><p>مثال ساده خواندن از یک رشته:</p><pre><code class=language-go>r := strings.NewReader(&quot;Hello IO&quot;)
buf := make([]byte, 4)
for {
    n, err := r.Read(buf)
    fmt.Printf(&quot;Read: %s\n&quot;, buf[:n])
    if err == io.EOF {
        break
    }
}
</code></pre><p>یک مثال کامل:</p><div class=go-playground><pre class=line-numbers><code class=language-go>package main

import (
	"fmt"
	"io"
	"strings"
)

func main() {
	r := strings.NewReader("Hello IO")
	buf := make([]byte, 4)

	for {
		n, err := r.Read(buf)
		if n > 0 {
			fmt.Printf("Read: %s\n", buf[:n])
		}
		if err == io.EOF {
			break
		}
		if err != nil {
			fmt.Println("Error:", err)
			break
		}
	}
}</code></pre><button class=run-code>▶ اجرای کد</button>
<button class=copy-code>کپی</button>
<button class=hide-output>✖ بستن خروجی</button><pre class="run-output hidden"></pre></div><h3 id=42722-iowriter-و-متد-write>4.27.2.2 io.Writer و متد Write
<a class=anchor href=#42722-iowriter-%d9%88-%d9%85%d8%aa%d8%af-write>#</a></h3><p><code>io.Writer</code> مکمل <code>io.Reader</code> است:</p><pre><code class=language-go>type Writer interface {
    Write(p []byte) (n int, err error)
}
</code></pre><ul><li><strong>پارامتر <code>p</code></strong>: داده‌هایی که باید نوشته شوند.</li><li><strong>برگشتی <code>n</code></strong>: تعداد بایت‌هایی که نوشته شده‌اند.</li><li><strong>برگشتی <code>err</code></strong>: خطا هنگام نوشتن (مثلاً فضای ناکافی یا قطع ارتباط).</li></ul><p>هر چیزی که متد <code>Write</code> را داشته باشد، می‌تواند مقصد داده باشد، چه این مقصد یک فایل باشد، چه یک اتصال شبکه یا حتی یک بافر حافظه.</p><p>مثال ساده نوشتن روی خروجی استاندارد:</p><pre><code class=language-go>msg := []byte(&quot;Hello Writer\n&quot;)
os.Stdout.Write(msg)
</code></pre><p>مثال کامل:<div class=go-playground><pre class=line-numbers><code class=language-go>package main

import (
	"os"
)

func main() {
	msg := []byte("Hello Writer\n")
	_, err := os.Stdout.Write(msg)
	if err != nil {
		panic(err)
	}
}</code></pre><button class=run-code>▶ اجرای کد</button>
<button class=copy-code>کپی</button>
<button class=hide-output>✖ بستن خروجی</button><pre class="run-output hidden"></pre></div></p><h3 id=42723-ترکیب-اینترفیسها>4.27.2.3 ترکیب اینترفیس‌ها
<a class=anchor href=#42723-%d8%aa%d8%b1%da%a9%db%8c%d8%a8-%d8%a7%db%8c%d9%86%d8%aa%d8%b1%d9%81%db%8c%d8%b3%d9%87%d8%a7>#</a></h3><p>در پکیج <code>io</code>، اینترفیس‌ها می‌توانند با هم ترکیب شوند تا قابلیت‌های بیشتری ارائه دهند:</p><ul><li><code>io.ReadWriter</code>: ترکیب Reader و Writer.</li><li><code>io.ReadCloser</code>: ترکیب Reader و <span class=tooltip data-tooltip="بستن منبع داده" ontouchend=toggleTooltip(this)>Closer</span>
.</li><li><code>io.WriteCloser</code>: ترکیب Writer و Closer.</li><li><code>io.ReadWriteCloser</code>: ترکیب Reader، Writer و Closer.</li></ul><p>این ترکیب‌ها باعث می‌شوند بتوانید منابع داده‌ای داشته باشید که چندین قابلیت را همزمان ارائه می‌دهند، مثل یک فایل که هم قابل خواندن است، هم نوشتن و هم بستن.</p><p>به عنوان مثال:<div class=go-playground><pre class=line-numbers><code class=language-go>package main

import (
	"fmt"
	"os"
)

func main() {
	// os.File هم Reader است، هم Writer، هم Closer
	file, err := os.Create("example.txt")
	if err != nil {
		panic(err)
	}
	defer file.Close()

	_, err = file.Write([]byte("Hello File\n"))
	if err != nil {
		panic(err)
	}

	fmt.Println("Data written to example.txt successfully")
}</code></pre><button class=run-code>▶ اجرای کد</button>
<button class=copy-code>کپی</button>
<button class=hide-output>✖ بستن خروجی</button><pre class="run-output hidden"></pre></div></p><h3 id=42724-ioseeker-و-جابهجایی-در-دادهها>4.27.2.4 io.Seeker و جابه‌جایی در داده‌ها
<a class=anchor href=#42724-ioseeker-%d9%88-%d8%ac%d8%a7%d8%a8%d9%87%d8%ac%d8%a7%db%8c%db%8c-%d8%af%d8%b1-%d8%af%d8%a7%d8%af%d9%87%d9%87%d8%a7>#</a></h3><p><code>io.Seeker</code> امکان حرکت در یک منبع داده را فراهم می‌کند:</p><pre><code class=language-go>type Seeker interface {
    Seek(offset int64, whence int) (int64, error)
}
</code></pre><ul><li><strong>offset</strong>: تعداد بایت‌هایی که باید جابه‌جا شود.</li><li><strong>whence</strong>: نقطه مرجع برای جابه‌جایی (<code>io.SeekStart</code>, <code>io.SeekCurrent</code>, <code>io.SeekEnd</code>).</li></ul><p>مثال تغییر مکان در یک فایل:</p><pre><code class=language-go>file, _ := os.Open(&quot;data.txt&quot;)
file.Seek(10, io.SeekStart) // حرکت به بایت دهم از ابتدای فایل
</code></pre><p><code>io.Seeker</code> معمولاً همراه Reader یا Writer استفاده می‌شود و برای کار با داده‌هایی که نیاز به دسترسی تصادفی دارند (مثل پایگاه داده یا فرمت‌های باینری خاص) ضروری است.</p><p>به عنوان مثال:<div class=go-playground><pre class=line-numbers><code class=language-go>package main

import (
	"fmt"
	"io"
	"os"
)

func main() {
	file, err := os.Create("seek.txt")
	if err != nil {
		panic(err)
	}
	defer file.Close()

	// نوشتن داده اولیه
	file.Write([]byte("0123456789"))

	// رفتن به بایت پنجم
	_, err = file.Seek(5, io.SeekStart)
	if err != nil {
		panic(err)
	}

	// بازنویسی از بایت پنجم به بعد
	file.Write([]byte("XYZ"))

	fmt.Println("File updated successfully")
}</code></pre><button class=run-code>▶ اجرای کد</button>
<button class=copy-code>کپی</button>
<button class=hide-output>✖ بستن خروجی</button><pre class="run-output hidden"></pre></div></p><h2 id=4273-توابع-کمکی-کاربردی>4.27.3 توابع کمکی کاربردی
<a class=anchor href=#4273-%d8%aa%d9%88%d8%a7%d8%a8%d8%b9-%da%a9%d9%85%da%a9%db%8c-%da%a9%d8%a7%d8%b1%d8%a8%d8%b1%d8%af%db%8c>#</a></h2><p>پکیج <code>io</code> علاوه بر <span class=tooltip data-tooltip=رابط ontouchend=toggleTooltip(this)>Interface</span>
‌های پایه، یک سری <span class=tooltip data-tooltip="توابع کمکی" ontouchend=toggleTooltip(this)>Helper Functions</span>
هم دارد که خیلی از عملیات رایج I/O را ساده‌تر و بهینه‌تر انجام می‌دهند. این توابع باعث می‌شوند دیگر لازم نباشد حلقه‌های دستی برای خواندن و نوشتن بنویسیم و در عین حال از پیاده‌سازی‌های بهینه Go هم استفاده کنیم.</p><h3 id=42731-iocopy-و-iocopyn>4.27.3.1 io.Copy و io.CopyN
<a class=anchor href=#42731-iocopy-%d9%88-iocopyn>#</a></h3><p>تابع <code>io.Copy</code> داده را از یک <code>io.Reader</code> به یک <code>io.Writer</code> منتقل می‌کند تا زمانی که منبع به انتها برسد یا خطایی رخ دهد.</p><pre><code class=language-go>package main

import (
	&quot;fmt&quot;
	&quot;io&quot;
	&quot;os&quot;
	&quot;strings&quot;
)

func main() {
	src := strings.NewReader(&quot;Hello io.Copy\n&quot;)
	_, err := io.Copy(os.Stdout, src)
	if err != nil {
		panic(err)
	}

	fmt.Println(&quot;Copy completed successfully&quot;)
}
</code></pre><p>اگر بخواهیم فقط تعداد مشخصی بایت منتقل کنیم، می‌توانیم از <code>io.CopyN</code> استفاده کنیم:</p><pre><code class=language-go>package main

import (
	&quot;fmt&quot;
	&quot;io&quot;
	&quot;os&quot;
	&quot;strings&quot;
)

func main() {
	src := strings.NewReader(&quot;ABCDEFGH&quot;)
	_, err := io.CopyN(os.Stdout, src, 4)
	if err != nil {
		panic(err)
	}

	fmt.Println(&quot;\nCopyN completed successfully&quot;)
}
</code></pre><h3 id=42732-iomultireader-و-iomultiwriter>4.27.3.2 io.MultiReader و io.MultiWriter
<a class=anchor href=#42732-iomultireader-%d9%88-iomultiwriter>#</a></h3><ul><li><strong><code>io.MultiReader</code></strong> چند Reader را به هم وصل می‌کند تا خروجی‌شان پشت سر هم خوانده شود.</li></ul><pre><code class=language-go>package main

import (
	&quot;io&quot;
	&quot;os&quot;
	&quot;strings&quot;
)

func main() {
	r1 := strings.NewReader(&quot;Hello &quot;)
	r2 := strings.NewReader(&quot;World\n&quot;)

	mr := io.MultiReader(r1, r2)
	io.Copy(os.Stdout, mr)
}
</code></pre><ul><li><strong><code>io.MultiWriter</code></strong> داده را همزمان به چند Writer ارسال می‌کند.</li></ul><pre><code class=language-go>package main

import (
	&quot;io&quot;
	&quot;os&quot;
	&quot;strings&quot;
)

func main() {
	file, _ := os.Create(&quot;multi.txt&quot;)
	defer file.Close()

	mw := io.MultiWriter(os.Stdout, file)
	io.Copy(mw, strings.NewReader(&quot;Hello MultiWriter\n&quot;))
}
</code></pre><h3 id=42733-ioteereader>4.27.3.3 io.TeeReader
<a class=anchor href=#42733-ioteereader>#</a></h3><p><code>io.TeeReader</code> داده را از یک Reader می‌خواند و در حین خواندن، همان داده را در یک Writer هم می‌نویسد.</p><pre><code class=language-go>package main

import (
	&quot;io&quot;
	&quot;os&quot;
	&quot;strings&quot;
)

func main() {
	src := strings.NewReader(&quot;Hello TeeReader\n&quot;)
	tr := io.TeeReader(src, os.Stdout)

	// خواندن کامل باعث می‌شود داده هم روی stdout نوشته شود
	io.ReadAll(tr)
}
</code></pre><h3 id=42734-iolimitreader-و-iolimitwriter>4.27.3.4 io.LimitReader و io.LimitWriter
<a class=anchor href=#42734-iolimitreader-%d9%88-iolimitwriter>#</a></h3><p>این توابع حجم داده را محدود می‌کنند.</p><pre><code class=language-go>package main

import (
	&quot;io&quot;
	&quot;os&quot;
	&quot;strings&quot;
)

func main() {
	src := strings.NewReader(&quot;This is a long text&quot;)
	limited := io.LimitReader(src, 7)
	io.Copy(os.Stdout, limited) // فقط ۷ بایت اول چاپ می‌شود
}
</code></pre><h3 id=42735-ioreadall>4.27.3.5 io.ReadAll
<a class=anchor href=#42735-ioreadall>#</a></h3><p><code>io.ReadAll</code> تمام داده را تا پایان منبع (<code>io.EOF</code>) می‌خواند و در حافظه نگه می‌دارد (برای داده‌های بزرگ باید با احتیاط استفاده شود).</p><pre><code class=language-go>package main

import (
	&quot;fmt&quot;
	&quot;io&quot;
	&quot;strings&quot;
)

func main() {
	data := strings.NewReader(&quot;ReadAll example&quot;)
	all, err := io.ReadAll(data)
	if err != nil {
		panic(err)
	}
	fmt.Println(string(all))
}
</code></pre><h3 id=42736-iosectionreader>4.27.3.6 io.SectionReader
<a class=anchor href=#42736-iosectionreader>#</a></h3><p><code>io.SectionReader</code> اجازه می‌دهد فقط بخشی از یک منبع داده را بخوانیم.</p><pre><code class=language-go>package main

import (
	&quot;fmt&quot;
	&quot;io&quot;
	&quot;os&quot;
)

func main() {
	file, _ := os.Open(&quot;section.txt&quot;)
	defer file.Close()

	// فرض می‌کنیم فایل حداقل ۱۰ بایت دارد
	section := io.NewSectionReader(file, 3, 5) // از بایت سوم، ۵ بایت بخوان
	buf := make([]byte, 5)
	_, err := section.Read(buf)
	if err != nil &amp;&amp; err != io.EOF {
		panic(err)
	}

	fmt.Printf(&quot;Section data: %s\n&quot;, buf)
}
</code></pre><h2 id=4274-کار-با-iopipe-و-ارتباط-بین-goroutines>4.27.4 کار با io.Pipe و ارتباط بین Goroutines
<a class=anchor href=#4274-%da%a9%d8%a7%d8%b1-%d8%a8%d8%a7-iopipe-%d9%88-%d8%a7%d8%b1%d8%aa%d8%a8%d8%a7%d8%b7-%d8%a8%db%8c%d9%86-goroutines>#</a></h2><p>پکیج <code>io</code> یک ابزار جالب و قدرتمند به اسم <code>io.Pipe</code> داره که برای اتصال مستقیم دو <strong>goroutine</strong> به هم استفاده میشه. ایده اینه که یک goroutine داده‌ها رو به <code>PipeWriter</code> می‌نویسه و یک goroutine دیگه همون لحظه اون داده‌ها رو از <code>PipeReader</code> می‌خونه؛ یعنی بینشون یک کانال داده با API شبیه <code>io.Reader</code>/<code>io.Writer</code> ایجاد میشه.</p><p>برخلاف فایل یا بافر، <code>io.Pipe</code> داده رو جایی ذخیره نمی‌کنه؛ بلکه هر چیزی که نوشته میشه، باید همون لحظه توسط Reader خونده بشه. اگه Reader آماده نباشه، Writer بلاک میشه، و برعکس. این باعث میشه برای <strong>streaming real-time</strong> یا پردازش خط‌به‌خط داده عالی باشه، بدون اینکه کل داده تو حافظه بارگذاری بشه.</p><p>یک کاربرد مهمش وقتی هست که بخوای داده رو از یک منبع بخونی، قبل از ذخیره یا ارسال، پردازش کنی، و نتیجه رو به مقصد برسونی — و این کار رو با چند goroutine موازی انجام بدی. برای مثال <code>io.Pipe</code> برای اتصال encoder/decoder به ورودی یا خروجی در لحظه عالیه، مثل گرفتن خروجی یک پردازش و ارسال مستقیمش به gzip بدون ذخیره‌ی موقت.</p><h2 id=42741-مفاهیم-pipereader-و-pipewriter>4.27.4.1 مفاهیم PipeReader و PipeWriter
<a class=anchor href=#42741-%d9%85%d9%81%d8%a7%d9%87%db%8c%d9%85-pipereader-%d9%88-pipewriter>#</a></h2><p><code><span class=tooltip data-tooltip="PipeReader / PipeWriter" ontouchend=toggleTooltip(this)>io.Pipe</span>
</code>یه <strong>لولهٔ درون‌حافظه‌ای</strong> می‌سازه: یه سرش <code><span class=tooltip data-tooltip="انتهای خواندن pipe" ontouchend=toggleTooltip(this)>*io.PipeReader</span>
</code>و سر دیگه‌ش <code><span class=tooltip data-tooltip="انتهای نوشتن pipe" ontouchend=toggleTooltip(this)>*io.PipeWriter</span>
</code>. هر بایتی که در <code>PipeWriter</code> می‌نویسی، از <code>PipeReader</code> خونده می‌شه—معمولاً توی دو تا goroutine جدا. این برای زمانی عالیه که <strong>تولید داده (producer)</strong> و <strong>مصرف اون (consumer)</strong> هم‌زمان و بدون بافر بزرگ کار کنن. <strong>Backpressure</strong> طبیعی هم داریم: اگه خواننده کند باشه، نویسنده بلاک می‌شه (و برعکس)، پس هر دو سمت باید «زنده» باشن. ایدهٔ پایه و مثال سادهٔ همین الگو توی منابع پیوست هم اومده.</p><p>دو نکتهٔ حیاتی:</p><ul><li>همیشه انتهای <strong>Writer</strong> رو وقتی کارت تموم شد <code><span class=tooltip data-tooltip="بستن Writer" ontouchend=toggleTooltip(this)>Close</span>
</code>یا بهتر از اون <code><span class=tooltip data-tooltip="بستن با خطا برای propagate" ontouchend=toggleTooltip(this)>CloseWithError</span>
</code>کن؛ وگرنه خواننده تا ابد منتظر می‌مونه → deadlock.</li><li>مصرف‌کننده تا <strong>EOF</strong> بخونه (یا Copy کنه). قواعد خواندن/EOF رو جدی بگیر—خیلی از باگ‌های استریم همین‌جان.</li></ul><h3 id=مثال-۱-ابتداییترین-اتصال-producerconsumer-با-iocopy>مثال ۱: ابتدایی‌ترین اتصال Producer/Consumer با <code>io.Copy</code>
<a class=anchor href=#%d9%85%d8%ab%d8%a7%d9%84-%db%b1-%d8%a7%d8%a8%d8%aa%d8%af%d8%a7%db%8c%db%8c%d8%aa%d8%b1%db%8c%d9%86-%d8%a7%d8%aa%d8%b5%d8%a7%d9%84-producerconsumer-%d8%a8%d8%a7-iocopy>#</a></h3><div class=go-playground><pre class=line-numbers><code class=language-go>package main

import (
	"bytes"
	"fmt"
	"io"
	"os"
)

func main() {
	// منبع دادهٔ ما: یک بافر درون‌حافظه‌ای
	src := new(bytes.Buffer)
	src.WriteString("hello pipe\n")
	src.WriteString("line 2\n")

	pr, pw := io.Pipe()

	// Producer: می‌نویسه داخل pw
	go func() {
		defer func() {
			_ = pw.Close() // پایان جریان؛ مهم برای جلوگیری از بن‌بست
		}()
		if _, err := io.Copy(pw, src); err != nil {
			// در صورت خطا بهتره CloseWithError بدیم:
			// _ = pw.CloseWithError(err)
			fmt.Println("producer copy error:", err)
		}
	}()

	// Consumer: از pr می‌خونه و می‌ریزه روی Stdout
	if _, err := io.Copy(os.Stdout, pr); err != nil {
		fmt.Println("consumer copy error:", err)
	}
}</code></pre><button class=run-code>▶ اجرای کد</button>
<button class=copy-code>کپی</button>
<button class=hide-output>✖ بستن خروجی</button><pre class="run-output hidden"></pre></div><p>این الگو تقریباً همون چیزیه که در نمونه‌های پیوست هم می‌بینی: <code>Pipe()</code>، یک goroutine برای نوشتن، و <code>io.Copy</code> برای خواندن تا EOF.</p><h2 id=42742-استفاده-در-جریان-داده-streaming>4.27.4.2 استفاده در جریان داده (Streaming)
<a class=anchor href=#42742-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%af%d8%b1-%d8%ac%d8%b1%db%8c%d8%a7%d9%86-%d8%af%d8%a7%d8%af%d9%87-streaming>#</a></h2><p>جذابیت اصلی <code>io.Pipe</code> اینه که می‌تونی <strong>پایپ‌لاین‌های استریم</strong> بسازی: ورودی از یه جا میاد، وسط راه encode/zip/hash می‌شه، و خروجی همزمان جای دیگه می‌ره—همه بدون اینکه کل داده رو تو حافظه نگه داری. نمونه‌ها و توصیه‌های استریمی در مقالات پیوست زیاد تأکید می‌کنن که به جای <code>ReadAll</code>، <strong>جریان بده</strong> و تو مسیر پردازش کن.</p><h3 id=مثال-۲-فشردهسازی-on-the-fly-با-compressgzip-روی-pipe>مثال ۲: فشرده‌سازی on-the-fly با <code>compress/gzip</code> روی pipe
<a class=anchor href=#%d9%85%d8%ab%d8%a7%d9%84-%db%b2-%d9%81%d8%b4%d8%b1%d8%af%d9%87%d8%b3%d8%a7%d8%b2%db%8c-on-the-fly-%d8%a8%d8%a7-compressgzip-%d8%b1%d9%88%db%8c-pipe>#</a></h3><ul><li>Producer دادهٔ خام رو می‌خونه و داخل <code>gzip.Writer</code> می‌نویسه که خروجی‌ش <code>PipeWriter</code> ماست.</li><li>Consumer از <code>PipeReader</code> می‌خونه و مستقیم به فایل می‌نویسه.</li></ul><div class=go-playground><pre class=line-numbers><code class=language-go>package main

import (
	"compress/gzip"
	"fmt"
	"io"
	"os"
	"strings"
)

func main() {
	input := strings.NewReader(strings.Repeat("Go IO Pipe\n", 5))

	pr, pw := io.Pipe()

	// Producer: gzip روی pw
	go func() {
		defer func() {
			_ = pw.Close() // اول gzip.Close، بعد pw.Close
		}()
		gzw := gzip.NewWriter(pw)
		if _, err := io.Copy(gzw, input); err != nil {
			_ = gzw.Close()
			_ = pw.CloseWithError(err)
			return
		}
		_ = gzw.Close()
	}()

	// Consumer: خروجی gzip شده می‌ره توی فایل
	out, err := os.Create("out.gz")
	if err != nil {
		panic(err)
	}
	defer out.Close()

	if _, err := io.Copy(out, pr); err != nil {
		fmt.Println("copy error:", err)
	}
	fmt.Println("done -> out.gz")
}</code></pre><button class=run-code>▶ اجرای کد</button>
<button class=copy-code>کپی</button>
<button class=hide-output>✖ بستن خروجی</button><pre class="run-output hidden"></pre></div><p><strong>نکتهٔ مهم:</strong> ترتیب بستن‌ها: اول <code>gzw.Close()</code> تا footer نوشته بشه، بعد <code>pw.Close()</code> تا EOF به مصرف‌کننده برسد. این دقیقا همان الگوی «اتصال goroutine‌ها با Pipe و Copy»‌ است.</p><h3 id=مثال-۳-محاسبه-checksum-همزمان-با-عبور-داده-pipe--teereader>مثال ۳: محاسبهٔ checksum همزمان با عبور داده (Pipe + TeeReader)
<a class=anchor href=#%d9%85%d8%ab%d8%a7%d9%84-%db%b3-%d9%85%d8%ad%d8%a7%d8%b3%d8%a8%d9%87-checksum-%d9%87%d9%85%d8%b2%d9%85%d8%a7%d9%86-%d8%a8%d8%a7-%d8%b9%d8%a8%d9%88%d8%b1-%d8%af%d8%a7%d8%af%d9%87-pipe--teereader>#</a></h3><p>گاهی می‌خوای همزمان که داده رو می‌فرستی، <strong>هش/چک‌سام</strong> هم بگیری. <code><span class=tooltip data-tooltip="کپی موازی داده به یک Writer" ontouchend=toggleTooltip(this)>io.TeeReader</span>
</code>همین کارو می‌کنه.</p><div class=go-playground><pre class=line-numbers><code class=language-go>package main

import (
	"crypto/sha256"
	"fmt"
	"io"
	"os"
	"strings"
)

func main() {
	src := strings.NewReader(strings.Repeat("data...", 100))

	pr, pw := io.Pipe()

	// Producer: src -> TeeReader(hasher) -> pw
	go func() {
		defer pw.Close()
		hasher := sha256.New()
		tr := io.TeeReader(src, hasher)
		if _, err := io.Copy(pw, tr); err != nil {
			_ = pw.CloseWithError(err)
			return
		}
		sum := hasher.Sum(nil)
		fmt.Fprintf(os.Stderr, "sha256: %x\n", sum)
	}()

	// Consumer: pr -> stdout (یا هر مقصد دیگری)
	if _, err := io.Copy(os.Stdout, pr); err != nil {
		fmt.Println("copy error:", err)
	}
}</code></pre><button class=run-code>▶ اجرای کد</button>
<button class=copy-code>کپی</button>
<button class=hide-output>✖ بستن خروجی</button><pre class="run-output hidden"></pre></div><p>این الگوی «داده رد می‌شه، همزمان پردازش جانبی انجام می‌دیم».</p><h2 id=42743-الگوهای-همزمانی-با-iopipe>4.27.4.3 الگوهای همزمانی با io.Pipe
<a class=anchor href=#42743-%d8%a7%d9%84%da%af%d9%88%d9%87%d8%a7%db%8c-%d9%87%d9%85%d8%b2%d9%85%d8%a7%d9%86%db%8c-%d8%a8%d8%a7-iopipe>#</a></h2><p>چند الگوی پرکاربرد و Best Practiceها:</p><ol><li><strong>Producer/Consumer با پایان مشخص</strong><ul><li><strong>Writer را حتماً Close/CloseWithError کنید</strong>؛ در غیر این صورت خواننده هرگز EOF نمی‌گیره و گیر می‌کنه. نمونهٔ درست توی مثال‌ها و منبع پیوست هست.</li><li>سمت مصرف‌کننده از <code>io.Copy</code> استفاده کن تا قواعد <code>EOF</code> و شمارش بایت‌ها خودکار رعایت بشه.</li></ul></li><li><strong>خطا را propagate کن</strong><ul><li>اگر وسط کار producer خطا خورد، <code>CloseWithError</code> بده تا consumer مطلع شه و سریع‌تر fail کنه. این باور غلط که «همیشه Close ساده کافیه» در استریم‌های طولانی دردسرسازه. (قواعد خطا/EOF در منابع پیوست مرور شده.)</li></ul></li><li><strong>بافر جایی دیگه، Pipe اینجا</strong><ul><li><code>io.Pipe</code> خودش بافر قابل‌توجهی نداره؛ برای throughput بهتر از <code><span class=tooltip data-tooltip=بافرخوانی/نوشتن ontouchend=toggleTooltip(this)>bufio</span>
</code>یا <code><span class=tooltip data-tooltip="کپی با بافر سفارشی" ontouchend=toggleTooltip(this)>io.CopyBuffer</span>
</code>روی مقصد/مبدأ استفاده کن؛</li></ul></li><li><strong>Fan-in/Fan-out با Pipeهای زنجیره‌ای</strong><ul><li>می‌تونی چند مرحلهٔ پردازش (encode → compress → encrypt) رو با چند goroutine و چند Pipe زنجیره کنی. دقت کن هر مرحله خروجی رو <strong>تا آخر</strong> drain کنه و به‌موقع ببنده، وگرنه مرحلهٔ قبل block می‌شه.</li></ul></li><li><strong>از ReadAll پرهیز کن</strong><ul><li>برای دادهٔ بزرگ، به‌جای <code><span class=tooltip data-tooltip="خواندن کامل در حافظه" ontouchend=toggleTooltip(this)>io.ReadAll</span>
</code>استریم کن.</li></ul></li></ol><h3 id=نکات-production-ready-خلاصه>نکات Production-Ready خلاصه
<a class=anchor href=#%d9%86%da%a9%d8%a7%d8%aa-production-ready-%d8%ae%d9%84%d8%a7%d8%b5%d9%87>#</a></h3><ul><li><strong>همیشه</strong> پایان جریان را سیگنال بده: <code>Close()</code> یا <code>CloseWithError(err)</code>.</li><li>سمت مصرف‌کننده <strong>تا EOF بخونه</strong>؛ ساده‌ترین: <code>io.Copy(dst, pr)</code>. قواعد EOF/Read را رعایت کن.</li><li>در pipelineها ترتیب <strong>بستن wrapperها</strong> مهمه (مثلاً اول <code>gzip.Close</code> بعد <code>PipeWriter.Close</code>).</li><li>عملکرد: برای انتقال‌های بزرگ، از <code>io.CopyBuffer</code> یا <code>bufio.Writer/Reader</code> کمک بگیر و سایز بافر رو بسته به سناریو تنظیم کن.</li><li>اگر مرحله‌ای error داد، سریعاً <strong>propagate</strong> کن تا همهٔ goroutineها بدونن باید جمع کنن؛ لوپ‌های بی‌پایان مصرف CPU می‌شن.</li></ul><h2 id=4275-پیادهسازی-reader-و-writer-سفارشی>4.27.5 پیاده‌سازی Reader و Writer سفارشی
<a class=anchor href=#4275-%d9%be%db%8c%d8%a7%d8%af%d9%87%d8%b3%d8%a7%d8%b2%db%8c-reader-%d9%88-writer-%d8%b3%d9%81%d8%a7%d8%b1%d8%b4%db%8c>#</a></h2><p>ایده‌ی اصلی اینجاست: هر چیزی که متد <code>Read([]byte) (int, error)</code> داشته باشه یک <span class=tooltip data-tooltip="رابط خواندن داده در کتابخانه استاندارد Go" ontouchend=toggleTooltip(this)>io.Reader</span>
و هر چیزی که متد <code>Write([]byte) (int, error)</code> داشته باشه یک <span class=tooltip data-tooltip="رابط نوشتن داده در کتابخانه استاندارد Go" ontouchend=toggleTooltip(this)>io.Writer</span>
محسوب می‌شه. این دو رابط پایهٔ تمام ورودی/خروجیِ «جریان‌محور» هستن و باهاشون می‌تونیم اجزای قابل‌اتصال بسازیم.</p><h3 id=42751-ساخت-یک-custom-reader>4.27.5.1 ساخت یک Custom Reader
<a class=anchor href=#42751-%d8%b3%d8%a7%d8%ae%d8%aa-%db%8c%da%a9-custom-reader>#</a></h3><p>بیایید یک Reader بسازیم که حروف را به <strong>UpperCase</strong> تبدیل می‌کند. این Reader خودش دادهٔ خام را از یک Readerِ زیری می‌خواند و هنگام بازگشت، تبدیل را اعمال می‌کند.</p><div class=go-playground><pre class=line-numbers><code class=language-go>package main

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"strings"
)

type UpperReader struct {
	r io.Reader // زیرساخت خواندن
}

// Read باید تا حد امکان بافر p را پر کند، تعداد بایت‌های نوشته‌شده و خطا را برگرداند.
func (u *UpperReader) Read(p []byte) (int, error) {
	n, err := u.r.Read(p)
	if n > 0 {
		// فقط همان تکه‌ای را که پر شده upper کنیم
        // (تبدیل درجا روی p[:n])
		copy(p[:n], bytes.ToUpper(p[:n]))
	}
	return n, err
}

func main() {
	src := strings.NewReader("go io is composable!\n")
	ur := &UpperReader{r: src}
	if _, err := io.Copy(os.Stdout, ur); err != nil {
		fmt.Fprintln(os.Stderr, "copy error:", err)
	}
}</code></pre><button class=run-code>▶ اجرای کد</button>
<button class=copy-code>کپی</button>
<button class=hide-output>✖ بستن خروجی</button><pre class="run-output hidden"></pre></div><p>نکات مهم طراحی (طبق توصیه‌های فصل I/O):</p><ul><li>سعی کنید روی <code>p[:n]</code> کار کنید و از ایجاد <span class=tooltip data-tooltip="تخصیص حافظه" ontouchend=toggleTooltip(this)>allocation</span>
‌های اضافی پرهیز کنید.</li><li>اجازه بدید خطاهای زیری (مثل <code>io.EOF</code>) همون‌طور عبور کنن تا <span class=tooltip data-tooltip="تابع کپی داده" ontouchend=toggleTooltip(this)>io.Copy</span>
رفتار درست داشته باشه.</li></ul><h3 id=42752-ساخت-یک-custom-writer>4.27.5.2 ساخت یک Custom Writer
<a class=anchor href=#42752-%d8%b3%d8%a7%d8%ae%d8%aa-%db%8c%da%a9-custom-writer>#</a></h3><p>حالا یک Writer می‌سازیم که به ابتدای هر <strong>خط</strong> یک پیشوند اضافه کند؛ این یعنی باید مرز خطوط را مدیریت کنیم و ممکن است تکه‌خطوط بین فراخوانی‌های <code>Write</code> بمانند.</p><div class=go-playground><pre class=line-numbers><code class=language-go>package main

import (
	"bufio"
	"bytes"
	"fmt"
	"io"
	"os"
)

type LinePrefixWriter struct {
	w       io.Writer
	prefix  []byte
	pending bool   // آیا در ابتدای خط جدید هستیم؟
	buf     []byte // بافر carry برای تکه‌خط‌های بدون \n
}

func NewLinePrefixWriter(w io.Writer, prefix string) *LinePrefixWriter {
	return &LinePrefixWriter{w: w, prefix: []byte(prefix), pending: true}
}

func (lp *LinePrefixWriter) Write(p []byte) (int, error) {
	total := 0
	// دادهٔ جدید را به بافر داخلی اضافه می‌کنیم
	lp.buf = append(lp.buf, p...)
	sc := bufio.NewScanner(bytes.NewReader(lp.buf))
	sc.Split(bufio.ScanLines)

	var out bytes.Buffer
	for sc.Scan() {
		line := sc.Bytes()
		// ScanLines انتهای \n را حذف می‌کند؛ باید خودمان اضافه کنیم
		if lp.pending {
			out.Write(lp.prefix)
		}
		out.Write(line)
		out.WriteByte('\n')
		lp.pending = true // بعد از نوشتن \n ابتدای خط بعدی هستیم
		total += len(line) + 1
	}
	if err := sc.Err(); err != nil {
		return 0, err
	}

	// تشخیص اینکه آیا ورودی با \n تمام شده یا تکه‌خط نیمه‌کاره داریم
	if len(lp.buf) > 0 && lp.buf[len(lp.buf)-1] != '\n' {
		// آخرین توکن توسط Scanner برگردانده نمی‌شود؛ نگهش می‌داریم
		// و pending را false می‌کنیم چون وسط خط هستیم.
		lastNL := bytes.LastIndexByte(lp.buf, '\n')
		if lastNL >= 0 {
			lp.buf = append([]byte{}, lp.buf[lastNL+1:]...) // نگه داشتن دمِ خط
		}
		lp.pending = false
	} else {
		lp.buf = lp.buf[:0] // همه مصرف شده
		lp.pending = true
	}

	// خروجی بافر را یکجا بنویسیم
	nw, err := lp.w.Write(out.Bytes())
	if err != nil {
		return nw, err
	}
	return len(p), nil // قرارداد Writer: تعداد بایت‌های از ورودیِ p پذیرفته‌شده
}

func main() {
	lw := NewLinePrefixWriter(os.Stdout, "[LOG] ")
	_, _ = lw.Write([]byte("hello"))
	_, _ = lw.Write([]byte(" world\nnext line\npartial"))
	_, _ = lw.Write([]byte(" tail\n"))
}</code></pre><button class=run-code>▶ اجرای کد</button>
<button class=copy-code>کپی</button>
<button class=hide-output>✖ بستن خروجی</button><pre class="run-output hidden"></pre></div><p>نکات:</p><ul><li>Writer باید تا حد امکان «همهٔ p» را بپذیرد و اگر کمتر نوشت، مقدار برگشتی را دقیق بده (قابل‌استناد برای <span class=tooltip data-tooltip="فشار معکوس؛ کند کردن تولیدکننده هنگام کند بودن مصرف‌کننده" ontouchend=toggleTooltip(this)>backpressure</span>
).</li><li>استفاده از بافر داخلی برای تکه‌خط‌ها یک الگوی رایج است. مراقب رشد بافر باشید.</li></ul><h3 id=42753-پیادهسازی-ioreaderfrom-و-iowriterto-برای-بهینهسازی>4.27.5.3 پیاده‌سازی io.ReaderFrom و io.WriterTo برای بهینه‌سازی
<a class=anchor href=#42753-%d9%be%db%8c%d8%a7%d8%af%d9%87%d8%b3%d8%a7%d8%b2%db%8c-ioreaderfrom-%d9%88-iowriterto-%d8%a8%d8%b1%d8%a7%db%8c-%d8%a8%d9%87%db%8c%d9%86%d9%87%d8%b3%d8%a7%d8%b2%db%8c>#</a></h3><p>تابع <span class=tooltip data-tooltip="کپی بین Reader و Writer" ontouchend=toggleTooltip(this)>io.Copy</span>
یک میان‌بُر مهم دارد:</p><ul><li>اگر <strong>Reader</strong> متد <span class=tooltip data-tooltip="WriteTo(w) (int64, error)" ontouchend=toggleTooltip(this)>io.WriterTo</span>
را پیاده‌سازی کند، <code>io.Copy</code> به‌جای حلقهٔ پیش‌فرض، <code>r.WriteTo(dst)</code> را صدا می‌زند.</li><li>اگر <strong>Writer</strong> متد <span class=tooltip data-tooltip="ReadFrom(r) (int64, error)" ontouchend=toggleTooltip(this)>io.ReaderFrom</span>
را پیاده‌سازی کند، <code>io.Copy</code> از <code>w.ReadFrom(src)</code> استفاده می‌کند.</li></ul><p>این مسیرها اجازه می‌دهند پیاده‌سازیِ شما مسیر داده را بهینه کند (مثلاً استفاده از بافرهای بزرگ‌تر، جلوگیری از کپی‌های اضافه، یا بهره‌بردن از توابع سیستم‌عاملی). به الگوهای استاندارد I/O و توضیحات دربارهٔ <code>io.Copy</code> در منابع اشاره‌شده رجوع کنید.</p><p>در کُد زیر، برای <code>UpperReader</code>، متد <code>WriteTo</code> را اضافه می‌کنیم تا مسیر «Reader → Writer» مستقیم‌تر شود. و برای <code>LinePrefixWriter</code>، متد <code>ReadFrom</code> را می‌گذاریم تا داده را <strong>بکشد</strong>.</p><div class=go-playground><pre class=line-numbers><code class=language-go>package main

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"strings"
)

type UpperReader struct{ r io.Reader }

func (u *UpperReader) Read(p []byte) (int, error) {
	n, err := u.r.Read(p)
	if n > 0 {
		copy(p[:n], bytes.ToUpper(p[:n]))
	}
	return n, err
}

// WriterTo: به io.Copy اجازه می‌دهد مستقیماً از WriteTo استفاده کند.
func (u *UpperReader) WriteTo(w io.Writer) (int64, error) {
	var total int64
	buf := make([]byte, 32*1024) // بافر بزرگ‌تر برای throughput بهتر
	for {
		n, err := u.r.Read(buf)
		if n > 0 {
			blk := bytes.ToUpper(buf[:n])
			m, werr := w.Write(blk)
			total += int64(m)
			if werr != nil {
				return total, werr
			}
			if m < n {
				return total, io.ErrShortWrite
			}
		}
		if err != nil {
			if err == io.EOF {
				return total, nil
			}
			return total, err
		}
	}
}

type LinePrefixWriter struct {
	w       io.Writer
	prefix  []byte
	pending bool
}

// ReaderFrom: به io.Copy اجازه می‌دهد Writer خودش از منبع بخواند.
func (lp *LinePrefixWriter) ReadFrom(r io.Reader) (int64, error) {
	var total int64
	buf := make([]byte, 32*1024)
	var carry []byte

	writeLine := func(line []byte) error {
		if lp.pending {
			if _, err := lp.w.Write(lp.prefix); err != nil {
				return err
			}
		}
		if _, err := lp.w.Write(line); err != nil {
			return err
		}
		if _, err := lp.w.Write([]byte{'\n'}); err != nil {
			return err
		}
		lp.pending = true
		return nil
	}

	for {
		n, err := r.Read(buf)
		if n > 0 {
			total += int64(n)
			chunk := append(carry, buf[:n]...)
			start := 0
			for {
				i := bytes.IndexByte(chunk[start:], '\n')
				if i < 0 {
					// تکه‌خط ناقص
					carry = append([]byte{}, chunk[start:]...)
					lp.pending = false
					break
				}
				end := start + i
				if err2 := writeLine(chunk[start:end]); err2 != nil {
					return total, err2
				}
				start = end + 1
			}
		}
		if err != nil {
			if err == io.EOF {
				// هرچه مانده را بدون \n نهایی، با پیشوند بنویسیم
				if len(carry) > 0 {
					if lp.pending {
						if _, werr := lp.w.Write(lp.prefix); werr != nil {
							return total, werr
						}
					}
					if _, werr := lp.w.Write(carry); werr != nil {
						return total, werr
					}
					lp.pending = false
				}
				return total, nil
			}
			return total, err
		}
	}
}

func NewLinePrefixWriter(w io.Writer, prefix string) *LinePrefixWriter {
	return &LinePrefixWriter{w: w, prefix: []byte(prefix), pending: true}
}

func main() {
	// مسیر بهینه‌شده: io.Copy ابتدا WriterTo روی Reader را امتحان می‌کند
	r := &UpperReader{r: strings.NewReader("hello\nGo io\n")}
	w := NewLinePrefixWriter(os.Stdout, "[UP] ")
	if _, err := io.Copy(w, r); err != nil {
		fmt.Fprintln(os.Stderr, "copy error:", err)
	}
}</code></pre><button class=run-code>▶ اجرای کد</button>
<button class=copy-code>کپی</button>
<button class=hide-output>✖ بستن خروجی</button><pre class="run-output hidden"></pre></div><p>چرا این کار سریع‌تر می‌شود؟</p><ul><li><code>WriteTo</code> و <code>ReadFrom</code> به شما کنترل بافر و مسیر داده را می‌دهند، پس <strong>کپی‌های کمتر</strong> و <strong>تخصیص‌های کمتر</strong> خواهید داشت؛</li><li>مطابق توضیحات منابع I/O، <code>io.Copy</code> طبق قرارداد ابتدا <code>WriterTo</code> را روی Reader و بعد <code>ReaderFrom</code> را روی Writer چک می‌کند؛ داشتن یکی از این‌ها کافی‌ست تا حلقهٔ پیش‌فرضِ کپی کنار گذاشته شود.</li></ul><h2 id=4276-مدیریت-خطا-در-io>4.27.6 مدیریت خطا در io
<a class=anchor href=#4276-%d9%85%d8%af%db%8c%d8%b1%db%8c%d8%aa-%d8%ae%d8%b7%d8%a7-%d8%af%d8%b1-io>#</a></h2><p>کار با I/O توی Go قشنگه چون همه‌چیز «جریان بایت»‌ه؛ اما همین‌جا اکثر خطاهای ریزه‌میزه هم رخ می‌دن: از برگشتن <code>n>0</code> همراه با یک <code>err</code> گرفته تا تشخیص پایان داده با <code>io.EOF</code> و هندل کردن عملیات طولانی که باید قابل لغو باشن. این بخش خیلی جمع‌وجور ولی کاربردی می‌گه «چه خطایی عادیه، چی بحرانیه و چطور تولیدی (Production-Ready) هندلش کنیم». بر اساس مقاله‌های پیوست‌شده درباره‌ی I/O استریمی و الگوهای خطا (و چند نکته از اسناد استاندارد)، قواعد مهم <code>Read/Write</code>، تمایز <code>io.EOF</code>، و مدیریت عملیات طولانی با <span class=tooltip data-tooltip="انقضای زمان" ontouchend=toggleTooltip(this)>Timeout</span>
و <span class=tooltip data-tooltip=لغو ontouchend=toggleTooltip(this)>Cancellation</span>
رو مرور می‌کنیم.</p><h3 id=42761-تفاوت-ioeof-با-خطاهای-دیگر>4.27.6.1 تفاوت <code>io.EOF</code> با خطاهای دیگر
<a class=anchor href=#42761-%d8%aa%d9%81%d8%a7%d9%88%d8%aa-ioeof-%d8%a8%d8%a7-%d8%ae%d8%b7%d8%a7%d9%87%d8%a7%db%8c-%d8%af%db%8c%da%af%d8%b1>#</a></h3><ol><li><strong><code>io.EOF</code> خطا نیست؛ علامت پایان جریانه.</strong> وقتی منبع داده تموم می‌شه، بعضی Readerها <code>n>0</code> و <code>err==io.EOF</code> برمی‌گردونن (یعنی «این آخریشه!»). بعضی‌های دیگه ممکنه همون لحظه <code>err==nil</code> بدن و خواندن بعدی <code>io.EOF</code> بده. پس «پایان» همیشه در فراخوانی بعدی قطعی می‌شه. نتیجه؟ حلقه‌ی خواندن باید روی <code>io.EOF</code> از حلقه خارج بشه؛ ولی قبلش هر بایتی که با <code>n>0</code> اومده رو پردازش کن. این دقیقاً همون «قوانین خواندن»یه که روی Readerها تأکید شده.</li><li><strong><code>n>0</code> همراه با <code>err!=nil</code></strong>: طبق قواعد Reader، ممکنه قبل از وقوع خطا هنوز چند بایت معتبر توی <code>p[:n]</code> داشته باشید (مثلاً سوکت ناگهانی بسته شده). حواستون باشه اون بایت‌ها از دست نرن؛ اول مصرفشون کنید، بعد تصمیم بگیرید ریترای کنید یا قطع.</li><li><strong><code>io.ErrUnexpectedEOF</code> با <code>io.EOF</code> فرق داره.</strong> <code>io.ErrUnexpectedEOF</code> یعنی «داده زودتر از حد انتظار تموم شد» (مثلاً وسط یک بلاک ساختاریافته). این یکی خطای واقعی است و معمولاً باید به کاربر گزارش بشه یا عملیات رو ریترای/رول‌بک کنید. (نمونه‌های مرسوم هنگام <code>io.CopyN</code> یا <code>io.ReadFull</code> اتفاق می‌افته.)</li><li><strong>الگوی صحیح حلقه‌ی خواندن</strong>: تا وقتی <code>err==nil</code> ادامه بده؛ اگر <code>err==io.EOF</code> بود از حلقه خارج شو؛ اگر <code>err!=nil</code> بود، بسته به سناریو لاگ/بازگشت خطا. (و یادت باشه قبل از خروج هر چیزی در <code>p[:n]</code> رو مصرف کنی.</li></ol><p><strong>مثال (الگوی درستِ برخورد با EOF و خطاهای جزئی):</strong></p><div class=go-playground><pre class=line-numbers><code class=language-go>package main

import (
	"fmt"
	"io"
	"os"
	"strings"
)

func main() {
	// می‌تونی این رو با فایل هم تست کنی: f, _ := os.Open("file.txt"); defer f.Close(); r := f
	r := strings.NewReader("Clear is better than clever")

	buf := make([]byte, 4)
	for {
		n, err := r.Read(buf)
		if n > 0 {
			fmt.Print(string(buf[:n])) // قبل از بررسی خطا، داده‌های دریافت‌شده رو مصرف کن
		}
		if err != nil {
			if err == io.EOF {
				break // پایان طبیعی جریان
			}
			// خطای واقعی (شبکه، دیسک، مجوز و...)
			fmt.Fprintln(os.Stderr, "read error:", err)
			return
		}
	}
}</code></pre><button class=run-code>▶ اجرای کد</button>
<button class=copy-code>کپی</button>
<button class=hide-output>✖ بستن خروجی</button><pre class="run-output hidden"></pre></div><p>این الگو دقیقاً همون چیزیه که در منابع رویش تأکید شده: ممکنه <code>n</code> کمتر از <code>len(p)</code> باشه، ممکنه <code>n>0</code> همراه با خطا بیاد، و <code>n=0, err=nil</code> به معنی EOF نیست.</p><p><strong>نکات پروداکشنی:</strong></p><ul><li>از <code>io.Copy</code> برای ساده‌سازی حلقه‌ها استفاده کن؛ خودش شمارش بایت و EOF رو درست مدیریت می‌کنه.</li><li>موقع <code>Write</code>، <code>n!=len(p)</code> و <code>io.ErrShortWrite</code> رو جدی بگیر.</li><li>خطاهای <code>Close()</code> رو چک کن؛ مخصوصاً روی فایل/شبکه. (اگرچه مثال‌های این بخش روی Reader تمرکز دارن، اما چک کردن Close توی خروجی هم مهمه.)</li><li></li></ul><h3 id=42762-مدیریت-خطا-در-عملیات-طولانی>4.27.6.2 مدیریت خطا در عملیات طولانی
<a class=anchor href=#42762-%d9%85%d8%af%db%8c%d8%b1%db%8c%d8%aa-%d8%ae%d8%b7%d8%a7-%d8%af%d8%b1-%d8%b9%d9%85%d9%84%db%8c%d8%a7%d8%aa-%d8%b7%d9%88%d9%84%d8%a7%d9%86%db%8c>#</a></h3><p>هدف اینجاست: کد I/O طولانی شما باید <strong>قابل لغو</strong> باشه، <strong>زمان‌بندی</strong> داشته باشه، و <strong>به‌صورت پیوسته خطا/پیشرفت</strong> رو مدیریت کنه—بدون اینکه رم رو بترکونه یا فایل لاک بمونه.</p><p><strong>1) لغو با <code>context.Context</code> (سراسری و ساده):</strong><br>خیلی از APIهای خالص <code>io</code> کانتکست نمی‌گیرن، ولی می‌تونیم یک Reader «کانتکست-اگاه» بسازیم که اگر <code>ctx.Done()</code> شد، دیگه نخونه و <code>ctx.Err()</code> برگردونه. این روش برای هر منبعی جواب می‌ده (فایل، حافظه، Pipe، HTTP body و&mldr;).</p><div class=go-playground><pre class=line-numbers><code class=language-go>package main

import (
	"context"
	"fmt"
	"io"
	"os"
	"strings"
	"time"
)

type ctxReader struct {
	ctx context.Context
	r   io.Reader
}

func (c *ctxReader) Read(p []byte) (int, error) {
	select {
	case <-c.ctx.Done():
		return 0, c.ctx.Err()
	default:
		return c.r.Read(p)
	}
}

func main() {
	ctx, cancel := context.WithTimeout(context.Background(), 500*time.Millisecond)
	defer cancel()

	// منبع کند (شبیه‌سازی): هر 200ms چند بایت می‌ده
	src := io.Reader(strings.NewReader(strings.Repeat("DATA-", 1<<14)))
	r := &ctxReader{ctx: ctx, r: src}

	// خروجی: استاندارد (می‌تونی فایل هم بذاری)
	if _, err := io.Copy(os.Stdout, r); err != nil {
		fmt.Fprintln(os.Stderr, "copy stopped:", err) // deadline exceeded یا canceled
	}
}</code></pre><button class=run-code>▶ اجرای کد</button>
<button class=copy-code>کپی</button>
<button class=hide-output>✖ بستن خروجی</button><pre class="run-output hidden"></pre></div><p>نکته: برای شبکه‌ها (<code>net.Conn</code>) اصلاً لازم نیست دور Reader کُوری بپیچید؛ مستقیماً از <code>SetDeadline/SetReadDeadline</code> استفاده کنید تا Read/Write با <span class=tooltip data-tooltip="انقضای زمان" ontouchend=toggleTooltip(this)>Timeout</span>
قطع بشه. برای HTTP از <code>http.Client</code> با <code>Timeout</code> یا <code>Context</code> روی <code>Request</code> استفاده کنید. (الگوی خطا همان است: اگر <code>n>0</code> برگشته، مصرف کن و بعد خطا را مدیریت کن.)</p><p><strong>2) کنترل حافظه و اندازه‌ی داده:</strong><br>در عملیات طولانی، وسوسه نشید <code>io.ReadAll</code> بزنید؛ برای داده‌های بزرگ باعث مصرف رم می‌شه. به‌جایش جریان‌محور (<code>io.Copy</code>، <code>io.CopyBuffer</code> با بافر قابل‌استفاده‌مجدد) کار کنید. اگر باید سقف اندازه را enforce کنید، <code>io.LimitReader</code> یا <code>io.CopyN</code> بگذارید و به <code>io.ErrUnexpectedEOF</code> حساس باشید.</p><p><strong>3) پایش و لاگ خطای مرحله‌ای (Stream-aware):</strong><br>اگر هم‌زمان می‌خواید پیشرفت یا checksum بگیرید، از <code>io.TeeReader</code> استفاده کنید تا جریان یکجا هم مصرف شود هم ثبت/هش شود—و هر خطا همان‌جا متوقف کند.</p><p><strong>4) بستن منابع به‌موقع:</strong></p><ul><li>روی هر مسیر خروج (موفق/ناموفق) <code>Close()</code> را چک کنید و در حلقه‌ها <code>defer Close()</code> نگذارید (نشت دسته‌جمعی می‌ده). برای تعداد زیاد فایل‌ها، «باز کن—کار کن—ببند» را سریع انجام بده.</li></ul><p><strong>مثال (کپیِ قابل-لغو + محدودیت حجم + شمارنده‌ی پیشرفت):</strong></p><div class=go-playground><pre class=line-numbers><code class=language-go>package main

import (
	"context"
	"crypto/sha256"
	"fmt"
	"io"
	"os"
	"strings"
	"time"
)

type ctxReader struct {
	ctx context.Context
	r   io.Reader
}

func (c *ctxReader) Read(p []byte) (int, error) {
	select {
	case <-c.ctx.Done():
		return 0, c.ctx.Err()
	default:
		return c.r.Read(p)
	}
}

func main() {
	// منبع شبیه‌سازی‌شدهٔ بزرگ
	src := strings.NewReader(strings.Repeat("X", 10<<20)) // 10MB

	// 1) محدودیت 1MB
	limited := io.LimitReader(src, 1<<20) // 1 MiB

	// 2) پیشرفت/هش موازی با TeeReader
	hasher := sha256.New()
	tr := io.TeeReader(limited, hasher)

	// 3) لغو با Timeout
	ctx, cancel := context.WithTimeout(context.Background(), 300*time.Millisecond)
	defer cancel()
	cr := &ctxReader{ctx: ctx, r: tr}

	dst, err := os.Create("out.bin")
	if err != nil {
		fmt.Println("create:", err)
		return
	}
	defer func() {
		if err := dst.Close(); err != nil {
			fmt.Println("close:", err)
		}
	}()

	// کپی جریان‌محور
	written, err := io.Copy(dst, cr)
	if err != nil {
		fmt.Println("copy error:", err) // ممکنه context deadline exceeded باشه
	} else {
		fmt.Println("written bytes:", written)
	}

	fmt.Printf("sha256 (partial/complete): %x\n", hasher.Sum(nil))
}</code></pre><button class=run-code>▶ اجرای کد</button>
<button class=copy-code>کپی</button>
<button class=hide-output>✖ بستن خروجی</button><pre class="run-output hidden"></pre></div><p><strong>چند Best Practice کوتاه برای عملیات طولانی:</strong></p><ul><li>«سقف ورودی» بگذار: <code>io.LimitReader</code> روی بدنه‌ی درخواست‌ها (مثلاً آپلود) تا از سوءاستفاده و OOM جلوگیری کنی.</li><li>«بافر درست» انتخاب کن و اگر حلقه‌ی طولانیه از <code>io.CopyBuffer</code> با یک بافر reuse‌شونده استفاده کن. (افزایش کارایی روی فایل/شبکه)</li><li><code>io.Copy</code> خطاها و EOF رو درست مدیریت می‌کنه؛ وقتی خاص‌نویسی لازم نیست، از همون استفاده کن.</li></ul><h2 id=4277-best-practices-در-استفاده-از-io>4.27.7 Best Practices در استفاده از io
<a class=anchor href=#4277-best-practices-%d8%af%d8%b1-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-io>#</a></h2><p>پکیج <code>io</code> قلب عملیات ورودی/خروجی (I/O) در Go است و تقریبا همه کتابخانه‌های استاندارد مربوط به فایل، شبکه، و پردازش داده بر پایه همین abstractionها ساخته شده‌اند. اما استفاده درست از آن می‌تواند تفاوت زیادی در کارایی، مصرف حافظه، و پایداری کد شما ایجاد کند. در ادامه چند <strong>بهترین شیوه</strong>‌ی مهم برای استفاده از این پکیج را بررسی می‌کنیم.</p><h3 id=42771-استفاده-از-interface-به-جای-نوع-خاص>4.27.7.1 استفاده از Interface به جای نوع خاص
<a class=anchor href=#42771-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-interface-%d8%a8%d9%87-%d8%ac%d8%a7%db%8c-%d9%86%d9%88%d8%b9-%d8%ae%d8%a7%d8%b5>#</a></h3><p>یکی از فلسفه‌های کلیدی Go این است که به جای تکیه بر نوع خاص (مثل <code>*os.File</code>) از اینترفیس‌های عمومی مثل <code>io.Reader</code> و <code>io.Writer</code> استفاده کنیم.<br>این کار باعث می‌شود که کد ما انعطاف‌پذیر باشد و بتواند با هر منبع یا مقصد داده‌ای کار کند — چه فایل باشد، چه شبکه، چه حافظه.</p><p><strong>مثال:</strong></p><div class=go-playground><pre class=line-numbers><code class=language-go>package main

import (
	"fmt"
	"io"
	"os"
	"strings"
)

func printData(r io.Reader) {
	buf := make([]byte, 16)
	for {
		n, err := r.Read(buf)
		if n > 0 {
			fmt.Print(string(buf[:n]))
		}
		if err == io.EOF {
			break
		}
		if err != nil {
			fmt.Println("Error:", err)
			break
		}
	}
}

func main() {
	// خواندن از یک رشته
	printData(strings.NewReader("Hello Go\n"))

	// خواندن از یک فایل
	file, _ := os.Open("test.txt")
	defer file.Close()
	printData(file)
}</code></pre><button class=run-code>▶ اجرای کد</button>
<button class=copy-code>کپی</button>
<button class=hide-output>✖ بستن خروجی</button><pre class="run-output hidden"></pre></div><p>در این مثال، تابع <code>printData</code> با هر چیزی که <code>io.Reader</code> را پیاده‌سازی کند کار می‌کند، بدون وابستگی به نوع خاص.</p><h3 id=42772-بهینهسازی-با-bufio>4.27.7.2 بهینه‌سازی با bufio
<a class=anchor href=#42772-%d8%a8%d9%87%db%8c%d9%86%d9%87%d8%b3%d8%a7%d8%b2%db%8c-%d8%a8%d8%a7-bufio>#</a></h3><p>خواندن و نوشتن مستقیم روی منابع I/O می‌تواند منجر به تعداد زیادی فراخوانی سیستم (syscall) و کاهش کارایی شود. برای همین <code>bufio</code> بافرهایی ارائه می‌دهد که باعث کاهش فراخوانی‌های I/O و افزایش سرعت می‌شوند.</p><p><strong>نکته:</strong> همیشه وقتی با داده‌های زیاد یا عملیات کوچک و پرتکرار کار می‌کنید، از <code>bufio.Reader</code> یا <code>bufio.Writer</code> استفاده کنید.</p><p><strong>مثال:</strong></p><div class=go-playground><pre class=line-numbers><code class=language-go>package main

import (
	"bufio"
	"fmt"
	"os"
)

func main() {
	file, err := os.Open("bigfile.txt")
	if err != nil {
		panic(err)
	}
	defer file.Close()

	reader := bufio.NewReader(file)

	for {
		line, err := reader.ReadString('\n')
		fmt.Print(line)
		if err != nil {
			break
		}
	}
}</code></pre><button class=run-code>▶ اجرای کد</button>
<button class=copy-code>کپی</button>
<button class=hide-output>✖ بستن خروجی</button><pre class="run-output hidden"></pre></div><h3 id=42773-مدیریت-منابع-با-iocloser-و-defer>4.27.7.3 مدیریت منابع با io.Closer و defer
<a class=anchor href=#42773-%d9%85%d8%af%db%8c%d8%b1%db%8c%d8%aa-%d9%85%d9%86%d8%a7%d8%a8%d8%b9-%d8%a8%d8%a7-iocloser-%d9%88-defer>#</a></h3><p>بسیاری از منابع I/O مثل فایل‌ها و کانکشن‌های شبکه نیاز به بستن (Close) دارند. پیاده‌سازی <code>io.Closer</code> و استفاده از <code>defer</code> تضمین می‌کند که حتی در صورت بروز خطا، منابع آزاد می‌شوند.</p><p><strong>مثال:</strong></p><div class=go-playground><pre class=line-numbers><code class=language-go>package main

import (
	"fmt"
	"os"
)

func main() {
	file, err := os.Open("data.txt")
	if err != nil {
		panic(err)
	}
	defer file.Close() // تضمین آزاد شدن منبع

	buf := make([]byte, 32)
	n, _ := file.Read(buf)
	fmt.Println(string(buf[:n]))
}</code></pre><button class=run-code>▶ اجرای کد</button>
<button class=copy-code>کپی</button>
<button class=hide-output>✖ بستن خروجی</button><pre class="run-output hidden"></pre></div><h3 id=42774-انتخاب-اندازه-buffer-مناسب>4.27.7.4 انتخاب اندازه buffer مناسب
<a class=anchor href=#42774-%d8%a7%d9%86%d8%aa%d8%ae%d8%a7%d8%a8-%d8%a7%d9%86%d8%af%d8%a7%d8%b2%d9%87-buffer-%d9%85%d9%86%d8%a7%d8%b3%d8%a8>#</a></h3><p>اندازه بافر تأثیر مستقیم روی کارایی دارد. بافر کوچک ممکن است باعث افزایش تعداد فراخوانی‌ها و کندی برنامه شود؛ بافر بزرگ هم می‌تواند حافظه را هدر دهد.<br>به‌طور معمول، برای بیشتر کاربردها بافر 4KB تا 32KB مناسب است (همانند اندازه پیش‌فرض در <code>bufio</code>)، اما در عملیات شبکه‌ای یا پردازش فایل‌های بزرگ می‌توانید آزمایش و بهینه‌سازی کنید.</p><p><strong>مثال:</strong></p><div class=go-playground><pre class=line-numbers><code class=language-go>package main

import (
	"io"
	"os"
)

func main() {
	src, _ := os.Open("large.bin")
	defer src.Close()

	dst, _ := os.Create("copy.bin")
	defer dst.Close()

	buf := make([]byte, 64*1024) // 64KB buffer
	io.CopyBuffer(dst, src, buf)
}</code></pre><button class=run-code>▶ اجرای کد</button>
<button class=copy-code>کپی</button>
<button class=hide-output>✖ بستن خروجی</button><pre class="run-output hidden"></pre></div><h3 id=42775-آپلود-استریمی-فایل-بزرگ-با-ذخیرهسازی-امن-atomic-روی-دیسک>4.27.7.5 آپلود استریمیِ فایل بزرگ با ذخیره‌سازی امن (atomic) روی دیسک
<a class=anchor href=#42775-%d8%a2%d9%be%d9%84%d9%88%d8%af-%d8%a7%d8%b3%d8%aa%d8%b1%db%8c%d9%85%db%8c-%d9%81%d8%a7%db%8c%d9%84-%d8%a8%d8%b2%d8%b1%da%af-%d8%a8%d8%a7-%d8%b0%d8%ae%db%8c%d8%b1%d9%87%d8%b3%d8%a7%d8%b2%db%8c-%d8%a7%d9%85%d9%86-atomic-%d8%b1%d9%88%db%8c-%d8%af%db%8c%d8%b3%da%a9>#</a></h3><h3 id=اصول>اصول
<a class=anchor href=#%d8%a7%d8%b5%d9%88%d9%84>#</a></h3><ul><li><strong>استریم‌کردن</strong>: به‌جای نگه‌داشتن کل فایل در حافظه، ورودی را مستقیم به دیسک کپی کنید.</li><li><strong>حداکثر اندازه</strong>: حتماً روی بدنه‌ی درخواست limit بگذارید.</li><li><strong>فایل موقت + rename اتمی</strong>: اول در مسیر مقصد یک فایل موقت (<code>*.part</code>) بسازید، آخر کار که موفق بود، با <code>os.Rename</code> به نام نهایی منتقلش کنید. روی یک فایل‌سیستم، rename اتمی است.</li><li><strong>پاکسازی مطمئن</strong>: هر خطا/لغو باعث حذف فایل موقت شود.</li><li><strong>Context‑aware</strong>: اگر کلاینت آپلود را کنسل کرد، کپی متوقف شود (Go خودش روی <code>r.Context()</code> این را propagate می‌کند).</li></ul><h3 id=هندلر-نمونه-http-multipartform-data>هندلر نمونه (HTTP، <code>multipart/form-data</code>)
<a class=anchor href=#%d9%87%d9%86%d8%af%d9%84%d8%b1-%d9%86%d9%85%d9%88%d9%86%d9%87-http-multipartform-data>#</a></h3><p>این نمونه آپلود <strong>تک‌فایله</strong> را نشان می‌دهد. برای چند فایل، حلقه روی پارت‌ها بزنید.</p><pre><code class=language-go>package upload

import (
	&quot;bufio&quot;
	&quot;errors&quot;
	&quot;fmt&quot;
	&quot;io&quot;
	&quot;mime/multipart&quot;
	&quot;net/http&quot;
	&quot;os&quot;
	&quot;path/filepath&quot;
	&quot;strconv&quot;
	&quot;strings&quot;
)

const (
	maxUploadSize = 1 &lt;&lt; 30 // 1GiB نمونه؛ بسته به نیاز تغییر دهید
	uploadDir     = &quot;./uploads&quot;
)

func UploadHandler(w http.ResponseWriter, r *http.Request) {
	// 1) محدود کردن اندازه بدنۀ درخواست (حفاظت از حافظه و DoS)
	r.Body = http.MaxBytesReader(w, r.Body, maxUploadSize)

	// 2) استریم‌کردن multipart بدون بافرکردن کل فرم
	mr, err := r.MultipartReader()
	if err != nil {
		http.Error(w, &quot;invalid multipart request&quot;, http.StatusBadRequest)
		return
	}

	// 3) اطمینان از وجود مسیر ذخیره
	if err := os.MkdirAll(uploadDir, 0o755); err != nil {
		http.Error(w, &quot;cannot create upload dir&quot;, http.StatusInternalServerError)
		return
	}

	// انتظار داریم یک part فایل به نام &quot;file&quot;
	var savedName string
	for {
		part, err := mr.NextPart()
		if errors.Is(err, io.EOF) {
			break
		}
		if err != nil {
			http.Error(w, &quot;read part failed&quot;, http.StatusBadRequest)
			return
		}
		if part.FormName() != &quot;file&quot; || part.FileName() == &quot;&quot; {
			// سایر فیلدهای فرم را رد کنید (مثلاً متن و …)
			continue
		}

		// 4) ساخت فایل موقت در همان دایرکتوری مقصد (برای rename اتمی روی همان FS)
		tmp, err := os.CreateTemp(uploadDir, &quot;*.part&quot;)
		if err != nil {
			http.Error(w, &quot;cannot create temp file&quot;, http.StatusInternalServerError)
			return
		}
		tmpPath := tmp.Name()
		defer func() {
			// اگر تا آخر کار rename موفق نشود، فایل موقت پاک می‌شود
			tmp.Close()           // امن است حتی اگر قبلاً بسته شده باشد
			_ = os.Remove(tmpPath)
		}()

		// 5) استریم کپی با بافر معقول (کاهش syscall ها)
		bufw := bufio.NewWriterSize(tmp, 64*1024) // 64KiB؛ با بنچمارک تنظیم کنید

		// اگر بخواهید همزمان hash بگیرید:
		// h := sha256.New()
		// src := io.TeeReader(part, h)
		// _, err = io.CopyBuffer(bufw, src, make([]byte, 64*1024))

		_, err = io.CopyBuffer(bufw, part, make([]byte, 64*1024))
		closeErr := bufw.Flush()
		if err == nil {
			err = closeErr
		}
		// توجه: اگر کلاینت وسط کار قطع شود، copy با خطا برمی‌گردد.
		if err != nil {
			http.Error(w, &quot;upload interrupted/failed&quot;, http.StatusBadRequest)
			return
		}

		// 6) اطمینان از پایداری روی دیسک (اختیاری، برای حساسیت بالا)
		if err := tmp.Sync(); err != nil {
			http.Error(w, &quot;fsync failed&quot;, http.StatusInternalServerError)
			return
		}
		if err := tmp.Close(); err != nil {
			http.Error(w, &quot;close failed&quot;, http.StatusInternalServerError)
			return
		}

		// 7) تولید نام نهایی امن
		finalName := sanitizeFilename(part.FileName())
		finalPath := filepath.Join(uploadDir, finalName)
		// در صورت وجود فایل همنام، یک suffix یکتا اضافه کنید
		finalPath = uniquifyPath(finalPath)

		// 8) جابجایی اتمی
		if err := os.Rename(tmpPath, finalPath); err != nil {
			http.Error(w, &quot;atomic move failed&quot;, http.StatusInternalServerError)
			return
		}
		// از اینجا به بعد، فایل موقت را دیگر پاک نکنید
		savedName = filepath.Base(finalPath)
		// یک فایل را ذخیره کردیم؛ اگر فقط یک فایل می‌پذیرید، می‌توانید break کنید.
		break
	}

	if savedName == &quot;&quot; {
		http.Error(w, &quot;no file part found&quot;, http.StatusBadRequest)
		return
	}

	w.WriteHeader(http.StatusCreated)
	_, _ = fmt.Fprintf(w, &quot;uploaded: %s\n&quot;, savedName)
}

func sanitizeFilename(name string) string {
	// خیلی ساده: مسیرها را حذف و فضای خالی را _ کنیم؛ در عمل سخت‌گیرتر باشید.
	name = filepath.Base(name)
	name = strings.ReplaceAll(name, &quot; &quot;, &quot;_&quot;)
	return name
}

func uniquifyPath(path string) string {
	dir := filepath.Dir(path)
	base := filepath.Base(path)
	ext := filepath.Ext(base)
	name := strings.TrimSuffix(base, ext)
	p := path
	i := 1
	for {
		if _, err := os.Stat(p); errors.Is(err, os.ErrNotExist) {
			return p
		}
		p = filepath.Join(dir, name+&quot;(&quot;+strconv.Itoa(i)+&quot;)&quot;+ext)
		i++
	}
}
</code></pre><h3 id=نکات-کلیدی>نکات کلیدی
<a class=anchor href=#%d9%86%da%a9%d8%a7%d8%aa-%da%a9%d9%84%db%8c%d8%af%db%8c>#</a></h3><ul><li><code>http.MaxBytesReader</code> جلوی خواندن بیش از حد را می‌گیرد؛ اگر بزرگ‌تر باشد با خطای 4xx برمی‌گردید.</li><li>به‌جای <code>r.ParseMultipartForm</code> از <code>r.MultipartReader()</code> استفاده کردیم تا <strong>کاملاً استریمی</strong> باشد.</li><li>اول روی فایل موقت می‌نویسیم، بعد <code>Sync</code> و <code>Close</code> و در پایان <code>Rename</code> اتمی. اگر هر جا خطا بخورد، <code>defer</code> فایل موقت را پاک می‌کند.</li><li>اگر حجم‌ها واقعاً بزرگند، بهتر است <strong>اندازه بافر</strong> را با بنچمارک روی محیط واقعی تنظیم کنید.</li><li>اگر نیاز دارید <strong>checksum/virus‑scan/thumbnail</strong> بسازید، از <code>io.TeeReader</code> (یا کانال‌های موازی با <code>errgroup</code>) استفاده کنید تا هنگام نوشتن، داده را همزمان به پردازش ثانویه بدهید.</li></ul><h3 id=آیا-اینجا-از-iopipe-استفاده-کنیم>آیا اینجا از <code>io.Pipe</code> استفاده کنیم؟
<a class=anchor href=#%d8%a2%db%8c%d8%a7-%d8%a7%db%8c%d9%86%d8%ac%d8%a7-%d8%a7%d8%b2-iopipe-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%da%a9%d9%86%db%8c%d9%85>#</a></h3><p>برای «کپی ساده‌ی ورودی به دیسک» معمولاً <strong>لازم نیست</strong>. <code>io.Copy</code>/<code>io.TeeReader</code> ساده‌تر و کم‌ریسک‌ترند.</p><p><code>io.Pipe</code> وقتی می‌درخشد که:</p><ul><li><strong>تولیدکننده و مصرف‌کننده همزمان</strong> دارید و می‌خواهید backpressure طبیعی رخ دهد (تا وقتی مصرف‌کننده نخوانَد، تولیدکننده پیش نرود).</li><li>نیاز به <strong>تبدیل/فشرده‌سازی/اسکن</strong> در goroutine جدا دارید که داده را از همون استریم بگیرد.</li></ul><p>نمونه‌ی کوتاه با <code>io.Pipe</code> همزمان:</p><pre><code class=language-go>pr, pw := io.Pipe()

// تولیدکننده: داده‌ی آپلود را در Pipe می‌نویسد
go func() {
	defer pw.Close()
	_, err := io.Copy(pw, part) // part همان multipart.Part
	if err != nil {
		// اگر خراب شد، Pipe را با خطا می‌بندیم تا مصرف‌کننده مطلع شود
		_ = pw.CloseWithError(err)
	}
}()

// مصرف‌کننده: همزمان روی دیسک می‌نویسد و پردازش می‌کند
go func() {
	defer pr.Close()
	dst, _ := os.CreateTemp(uploadDir, &quot;*.part&quot;)
	defer dst.Close()
	// همزمان hash یا AV:
	// h := sha256.New()
	// multi := io.TeeReader(pr, h)
	_, err := io.Copy(dst, pr) // یا multi
	if err != nil {
		// خطا را log/propagate کنید و فایل موقت را حذف کنید
	}
	// ... Sync/Close/Rename مثل قبل
}()
</code></pre><p>احتیاط: با <code>io.Pipe</code> اگر یکی از طرفین خواندن/نوشتن را متوقف کند و دیگری چشم‌انتظار بماند، <strong>بن‌بست</strong> می‌گیرید. حتماً با مدیریت خطا/بستن و <code>errgroup</code> کنترل کامل جریان را داشته باشید.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/GoFarsi/book/edit/main/content/chapter%204/4.27-io-package.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt>
<span>این صفحه را ویرایش کنید</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script><div class="text-left page-navigation"><a href=/chapter-6/>فصل ششم: ژنریک ها (Generics) ◀︎</a></div><script>function toggleTooltip(e){e.classList.toggle("active")}</script><div id=graphcomment></div><script type=text/javascript>var __semio__params={graphcommentId:"book",behaviour:{}};function __semio__onload(){__semio__gc_graphlogin(__semio__params)}(function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.onload=__semio__onload,e.defer=!0,e.src="https://integration.graphcomment.com/gc_graphlogin.js?"+Date.now(),(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content></br><main><div class=wrapper><a href=https://t.me/GolangEngineers class="icon telegram" target=_blank><div class=tooltip>گروه تلگرامی مهندسین گولنگ</div><span><i class="fab fa-telegram"></i></span>
</a><a href=https://linkedin.com/in/Ja7ad class="icon linkedin" target=_blank><div class=tooltip>لینکدین نویسنده</div><span><i class="fab fa-linkedin"></i></span>
</a><a href=https://twitter.com/Ja7adR class="icon twitter" target=_blank><div class=tooltip>توییتر نویسنده</div><span><i class="fab fa-twitter"></i></span></a></div></main></br></br><nav id=TableOfContents><ul><li><ul><li><a href=#4271-معرفی-پکیج-io-و-فلسفه-طراحی>4.27.1 معرفی پکیج io و فلسفه طراحی</a><ul><li><a href=#42711-اهمیت-abstraction-در-io>4.27.1.1 اهمیت abstraction در I/O</a></li><li><a href=#42712-نقش-io-در-کتابخانه-استاندارد-go>4.27.1.2 نقش io در کتابخانه استاندارد Go</a></li></ul></li><li><a href=#4272-اینترفیسهای-اصلی-پکیج-io>4.27.2 اینترفیس‌های اصلی پکیج io</a><ul><li><a href=#42721-ioreader-و-متد-read>4.27.2.1 io.Reader و متد Read</a></li><li><a href=#42722-iowriter-و-متد-write>4.27.2.2 io.Writer و متد Write</a></li><li><a href=#42723-ترکیب-اینترفیسها>4.27.2.3 ترکیب اینترفیس‌ها</a></li><li><a href=#42724-ioseeker-و-جابهجایی-در-دادهها>4.27.2.4 io.Seeker و جابه‌جایی در داده‌ها</a></li></ul></li><li><a href=#4273-توابع-کمکی-کاربردی>4.27.3 توابع کمکی کاربردی</a><ul><li><a href=#42731-iocopy-و-iocopyn>4.27.3.1 io.Copy و io.CopyN</a></li><li><a href=#42732-iomultireader-و-iomultiwriter>4.27.3.2 io.MultiReader و io.MultiWriter</a></li><li><a href=#42733-ioteereader>4.27.3.3 io.TeeReader</a></li><li><a href=#42734-iolimitreader-و-iolimitwriter>4.27.3.4 io.LimitReader و io.LimitWriter</a></li><li><a href=#42735-ioreadall>4.27.3.5 io.ReadAll</a></li><li><a href=#42736-iosectionreader>4.27.3.6 io.SectionReader</a></li></ul></li><li><a href=#4274-کار-با-iopipe-و-ارتباط-بین-goroutines>4.27.4 کار با io.Pipe و ارتباط بین Goroutines</a></li><li><a href=#42741-مفاهیم-pipereader-و-pipewriter>4.27.4.1 مفاهیم PipeReader و PipeWriter</a><ul><li><a href=#مثال-۱-ابتداییترین-اتصال-producerconsumer-با-iocopy>مثال ۱: ابتدایی‌ترین اتصال Producer/Consumer با <code>io.Copy</code></a></li></ul></li><li><a href=#42742-استفاده-در-جریان-داده-streaming>4.27.4.2 استفاده در جریان داده (Streaming)</a><ul><li><a href=#مثال-۲-فشردهسازی-on-the-fly-با-compressgzip-روی-pipe>مثال ۲: فشرده‌سازی on-the-fly با <code>compress/gzip</code> روی pipe</a></li><li><a href=#مثال-۳-محاسبه-checksum-همزمان-با-عبور-داده-pipe--teereader>مثال ۳: محاسبهٔ checksum همزمان با عبور داده (Pipe + TeeReader)</a></li></ul></li><li><a href=#42743-الگوهای-همزمانی-با-iopipe>4.27.4.3 الگوهای همزمانی با io.Pipe</a><ul><li><a href=#نکات-production-ready-خلاصه>نکات Production-Ready خلاصه</a></li></ul></li><li><a href=#4275-پیادهسازی-reader-و-writer-سفارشی>4.27.5 پیاده‌سازی Reader و Writer سفارشی</a><ul><li><a href=#42751-ساخت-یک-custom-reader>4.27.5.1 ساخت یک Custom Reader</a></li><li><a href=#42752-ساخت-یک-custom-writer>4.27.5.2 ساخت یک Custom Writer</a></li><li><a href=#42753-پیادهسازی-ioreaderfrom-و-iowriterto-برای-بهینهسازی>4.27.5.3 پیاده‌سازی io.ReaderFrom و io.WriterTo برای بهینه‌سازی</a></li></ul></li><li><a href=#4276-مدیریت-خطا-در-io>4.27.6 مدیریت خطا در io</a><ul><li><a href=#42761-تفاوت-ioeof-با-خطاهای-دیگر>4.27.6.1 تفاوت <code>io.EOF</code> با خطاهای دیگر</a></li><li><a href=#42762-مدیریت-خطا-در-عملیات-طولانی>4.27.6.2 مدیریت خطا در عملیات طولانی</a></li></ul></li><li><a href=#4277-best-practices-در-استفاده-از-io>4.27.7 Best Practices در استفاده از io</a><ul><li><a href=#42771-استفاده-از-interface-به-جای-نوع-خاص>4.27.7.1 استفاده از Interface به جای نوع خاص</a></li><li><a href=#42772-بهینهسازی-با-bufio>4.27.7.2 بهینه‌سازی با bufio</a></li><li><a href=#42773-مدیریت-منابع-با-iocloser-و-defer>4.27.7.3 مدیریت منابع با io.Closer و defer</a></li><li><a href=#42774-انتخاب-اندازه-buffer-مناسب>4.27.7.4 انتخاب اندازه buffer مناسب</a></li><li><a href=#42775-آپلود-استریمی-فایل-بزرگ-با-ذخیرهسازی-امن-atomic-روی-دیسک>4.27.7.5 آپلود استریمیِ فایل بزرگ با ذخیره‌سازی امن (atomic) روی دیسک</a></li><li><a href=#اصول>اصول</a></li><li><a href=#هندلر-نمونه-http-multipartform-data>هندلر نمونه (HTTP، <code>multipart/form-data</code>)</a></li><li><a href=#نکات-کلیدی>نکات کلیدی</a></li><li><a href=#آیا-اینجا-از-iopipe-استفاده-کنیم>آیا اینجا از <code>io.Pipe</code> استفاده کنیم؟</a></li></ul></li></ul></li></ul></nav></div></aside></main><button onclick=topFunction() id=myBtn title="رفتن به بالا" class="fas fa-solid fa-arrow-up"></button>
<script src=prism.js></script><script>document.getElementById("currentsv").innerHTML=window.location.href</script><script async>var html=document.documentElement,switcher=document.getElementsByClassName("js-toggle")[0];typeof Storage!="undefined"&&((localStorage.getItem("themeMode")=="dark"||document.documentElement.getAttribute("data-theme")=="dark")&&switcher.classList.add("js-toggle--checked"),switcher.classList.add("js-toggle--focus")),switcher.addEventListener("click",function(){this.classList.toggle("js-toggle--checked"),this.classList.add("js-toggle--focus"),this.classList.contains("js-toggle--checked")?(html.setAttribute("data-theme","dark"),localStorage.setItem("themeMode","dark")):(html.setAttribute("data-theme","light"),localStorage.setItem("themeMode","light"))})</script><script>let mybutton=document.getElementById("myBtn");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?mybutton.style.display="block":mybutton.style.display="none"}function topFunction(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script src=/js/playground.js defer></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-go.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/line-numbers/prism-line-numbers.min.js></script><script>"serviceWorker"in navigator&&window.addEventListener("DOMContentLoaded",function(){navigator.serviceWorker.register("/sw.js")})</script></body></html>