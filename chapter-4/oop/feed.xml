<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><author/><title>4.23 شی گرایی در زبان گو on زبان گو فارسی</title><link>https://book.gofarsi.ir/chapter-4/oop/</link><description>Recent content in 4.23 شی گرایی در زبان گو on زبان گو فارسی</description><generator>Hugo -- gohugo.io</generator><language>fa</language><copyright>2023 GoFarsi All rights reserved</copyright><atom:link href="https://book.gofarsi.ir/chapter-4/oop/feed.xml" rel="self" type="application/rss+xml"/><item><author/><title>4.23.1 کپسوله سازی (Encapsulation)</title><link>https://book.gofarsi.ir/chapter-4/oop/go-encapsulation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/oop/go-encapsulation/</guid><description>&lt;p>کپسوله سازی در زبان گو یا هر زبان دیگری یک مفهوم مشترک می باشد که شما یک داده یک تابع را پشت یک آبجکت یا یک واحد مستقل بپوشانید. با اینکار شما جلوی دسترسی مستقیم برروی داده را میگیرید. این کار در شی گرایی کمک می کند شما کدهای خود را بهتر سازماندهی کنید و جلوی دسترسی مستقیم ناخواسته را بگیرید.&lt;/p>
&lt;p>در زبان گو برای Public/Private کردن یک آبجکت یا تابع کلمه کلیدی به نام public/private ندارد ولی در عوض شما می توانید داخل هر پکیج با بزرگ یا کوچک کردن حرف اول نام هر آبجکت یا تابع جلو دسترسی مستقیم را بگیرید.&lt;/p>
&lt;pre>&lt;code class="language-go">var DatabaseName string // public
var databaseName string // private
func Greeting() {} // public
func greeting() {} // private
&lt;/code>&lt;/pre>
&lt;p>زمانی که شما یک آبجکت یا تابع را به شیوه فوق private می کنید در واقع آن آبجکت یا تابع فقط در همان package level خود در دسترس می باشد.&lt;/p>
&lt;p>به عنوان مثال اگر تابع greeting داخل پکیج message باشد فقط در همان جا در دسترس می باشد.&lt;/p>
&lt;pre>&lt;code class="language-shell">└── message
├── data.go
├── message.go
└── resp.go
&lt;/code>&lt;/pre>
&lt;p>در زیر یک مثال ساده زدیم توجه کنید :&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
type Person struct {
name string
age int
}
func (p *Person) GetAge() int {
return p.age
}
func (p *Person) getName() string {
return p.name
}
func (p *Person) SetAge(age int) {
p.age = age
}
func main() {
person := Person{
name: "Javad",
}
person.SetAge(29)
fmt.Printf("%s with age %d", person.getName(), person.GetAge())
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>کد فوق ما یک ساختار (آبجکت) Person ایجاد کردیم که داخلش ۲ فیلد name, age بصورت private وجود دارد که سایر پکیج ها نمی توانند دسترسی مستقیم به فیلد های Person دسترسی داشته باشند. حال ۳ متد تعریف کردیم GetAge برای گرفتن سن شخص , SetAge برای تعیین سن شخص , getName گرفتن نام شخص که فقط داخل همان پکیج در دسترس است این متد.&lt;/p></description></item><item><author/><title>4.22.2 ارث بری</title><link>https://book.gofarsi.ir/chapter-4/oop/go-inheritance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/oop/go-inheritance/</guid><description>&lt;p>در زبان گو ارث بری در واقع type embedding هست با استفاده &lt;a href="../../../chapter-2/type-embedding/">type embedding&lt;/a> می توانید یک type را داخل type دیگری جاسازی کنید و به واسطه type والد قابل دسترس است.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
type Person struct {
Name string
}
func (p *Person) Introduce() {
fmt.Printf("Hi, my name is %s\n", p.Name)
}
type Student struct {
Person
School string
}
func main() {
s := &amp;Student{Person{"John Doe"}, "Go University"}
s.Introduce()
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div></description></item><item><author/><title>4.23.3 پلی مورفیسم (Polymorphism)</title><link>https://book.gofarsi.ir/chapter-4/oop/go-polymorphism/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/oop/go-polymorphism/</guid><description>&lt;p>پلی مورفیسم یکی از مفاهیم مهم در شی گرایی می باشد و هدف استفاده از پلی مورفیسم این است بین آبجکت ها رفتار مشترکی ایجاد کنیم. در زبان گو شما می توانید یک اینترفیس تعریف کنید و برای ساختارهای مختلف متدهای اینترفیس را پیاده سازی کنید.&lt;/p>
&lt;p>به مثال زیر توجه کنید :&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
// Shape is an interface that defines a method named `Area`
type Shape interface {
Area() float64
}
// Rectangle is a struct that represents a rectangle
type Rectangle struct {
width float64
height float64
}
// Area implements the Shape interface for Rectangle
func (r Rectangle) Area() float64 {
return r.width * r.height
}
// Circle is a struct that represents a circle
type Circle struct {
radius float64
}
// Area implements the Shape interface for Circle
func (c Circle) Area() float64 {
return 3.14 * c.radius * c.radius
}
func CalcArea(shapes ...Shape) {
for _, shape := range shapes {
fmt.Println(shape.Area())
}
}
func main() {
r := Rectangle{width: 10, height: 5}
c := Circle{radius: 5}
CalcArea(r, c)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در کد فوق ما یک اینترفیس Shape داریم که داخلش یک متد به نام Area هست حال این متد را برای ساختارهای Rectangle و Circle پیاده سازی کردیم که مساحت دایره و مستطیل را محاسبه کنیم. حال یک تابع CalcArea داریم به عنوان پارامتر slice از Shape ها میگیرد که ما داخل تابع main ساختار Rectangle و Circle که متد Area اینترفیس Shape را پیاده سازی کرده اند را پاس دادیم و در نهایت محاسبه مساحت را در خروجی چاپ می کند.&lt;/p></description></item><item><author/><title>4.23.4 overriding</title><link>https://book.gofarsi.ir/chapter-4/oop/go-overriding/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/oop/go-overriding/</guid><description>&lt;p>در زبان گو مثل سایر زبان های شی گرا امکان overriding مستقیم یک متد وجود ندارد اما در عوض شما می توانید با استفاده از &lt;a href="../../../chapter-2/type-embedding/">type embedding&lt;/a> و پیاده سازی متد یک اینترفیس این تکنیک را انجام دهید و به متدی که override انجام داده Shadow Method می گویند.&lt;/p>
&lt;p>به مثال زیر توجه کنید :&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
type User interface {
PrintName()
}
type Person struct {
Name string
}
func (p Person) PrintName() {
fmt.Println("My name is", p.Name)
}
type Student struct {
Person
}
func (s Student) PrintName() {
fmt.Println("I am a student and my name is", s.Name)
}
func main() {
p := Person{Name: "John"}
s := Student{Person{Name: "Jane"}}
p.PrintName()
s.PrintName()
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در کد فوق ما یک اینترفیس User داریم که داخلش یک متد PrintName وجود دارد که این متد نام شخص یا دانش آموز را به همراه توضیحات چاپ می کند.
حال ۲ تا ساختار داریم Person و Student که ساختار student فقط Person را جاسازی کرده است. سپس برای این ۲ ساختار متد PrintName را پیاده سازی کردیم با این تفاوت که داخل متد PrintName ساختار Student متن دیگری قرار دادیم. در تابع main ما متغیر p, s را از نوع Person و Student ایجاد و مقدار دهی کردیم. سپس متد PrintName هر دو را فراخوانی کردیم.&lt;/p></description></item><item><author/><title>4.23.5 abstraction</title><link>https://book.gofarsi.ir/chapter-4/oop/go-abstraction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/oop/go-abstraction/</guid><description>&lt;p>&lt;strong>Abstraction&lt;/strong> (به معنای انتزاع)، فرآیند حذف یا از بین بردن برخی ویژگی‌های غیرضروری یک چیز به‌منظور کاهش، خلاصه‌سازی و به کار بردن آن در مجموعه‌ای از ویژگی‌های ضروری است. در برنامه‌نویسی شیءگرا(OOP)، انتزاع یکی از سه مفهوم اصلی (به همراه مفاهیم Encapsulation و Inheritance) است.&lt;/p>
&lt;blockquote class="book-hint info">
&lt;p>به نقل از ویکی پدیا :
&lt;strong>انتزاع&lt;/strong>،&lt;a href="https://fa.wikipedia.org/wiki/%D8%A7%D9%86%D8%AA%D8%B2%D8%A7%D8%B9#cite_note-1">[۱]&lt;/a> (به &lt;a href="https://fa.wikipedia.org/wiki/%D8%B2%D8%A8%D8%A7%D9%86_%D8%A7%D9%86%DA%AF%D9%84%DB%8C%D8%B3%DB%8C" title="زبان انگلیسی">انگلیسی&lt;/a>: Abstraction) &lt;strong>تجرید&lt;/strong> یا &lt;strong>آهنجش&lt;/strong> فرایند اختصار، فشرده‌سازی، و تلخیص &lt;a href="https://fa.wikipedia.org/wiki/%D8%A7%D8%B7%D9%84%D8%A7%D8%B9%D8%A7%D8%AA" title="اطلاعات">اطّلاعات&lt;/a> از طریق شناسائی، استخراج و سپس، جداسازی و پنهان‌سازی جزئیّات&lt;a href="https://fa.wikipedia.org/wiki/%D8%A7%D9%86%D8%AA%D8%B2%D8%A7%D8%B9#cite_note-2">[۲]&lt;/a> از کلیّات&lt;a href="https://fa.wikipedia.org/wiki/%D8%A7%D9%86%D8%AA%D8%B2%D8%A7%D8%B9#cite_note-3">[۳]&lt;/a> است. &lt;em>انتزاع&lt;/em> در لغت به معنای جدا کردن، گرفتن، درآوردن جزئی از یک کل&lt;a href="https://fa.wikipedia.org/wiki/%D8%A7%D9%86%D8%AA%D8%B2%D8%A7%D8%B9#cite_note-4">[۴]&lt;/a> و به معنای بازداشتن و امتناع کردن، برکندن و از جای کشیدن، گرفتن، و دور شدن می‌باشد.&lt;a href="https://fa.wikipedia.org/wiki/%D8%A7%D9%86%D8%AA%D8%B2%D8%A7%D8%B9#cite_note-5">[۵]&lt;/a>&lt;/p>
&lt;p>انتزاع فرایند یا نتیجهٔ تعمیم بخشیدن با کاهش محتوای اطلاعاتی یک مفهوم یا یک پدیدهٔ قابل مشاهده، جهت حفظ اطلاعات برای منظور خاص می‌باشد.&lt;/p>
&lt;/blockquote>
&lt;p>در زبان گو abstraction با استفاده از اینترفیس می توان انجام داد. یک اینترفیس یکسری متد دارد که ما این متدها را برای هریک از تایپ های مختلف پیاده سازی می کنیم.&lt;/p>
&lt;p>به مثال زیر توجه کنید :&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
// Shape is an interface that defines the basic methods for a shape.
type Shape interface {
Area() float64
Perimeter() float64
}
// Rectangle is a struct that implements the Shape interface.
type Rectangle struct {
width, height float64
}
// Area returns the area of the rectangle.
func (r Rectangle) Area() float64 {
return r.width * r.height
}
// Perimeter returns the perimeter of the rectangle.
func (r Rectangle) Perimeter() float64 {
return 2 * (r.width + r.height)
}
// Circle is a struct that implements the Shape interface.
type Circle struct {
radius float64
}
// Area returns the area of the circle.
func (c Circle) Area() float64 {
return 3.14 * c.radius * c.radius
}
// Perimeter returns the perimeter of the circle.
func (c Circle) Perimeter() float64 {
return 2 * 3.14 * c.radius
}
func main() {
// Create a rectangle and a circle.
r := Rectangle{width: 10, height: 20}
c := Circle{radius: 5}
// Declare a slice of Shape interfaces.
shapes := []Shape{r, c}
// Iterate over the shapes and print their area and perimeter.
for _, shape := range shapes {
fmt.Println("Area:", shape.Area())
fmt.Println("Perimeter:", shape.Perimeter())
fmt.Println("")
}
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در کد فوق ما یک اینترفیس Shape داریم که ۲ تا متد Area و Perimeter داریم که مساحت و محیط را محاسبه می کند. در ادامه ۲ ساختار Rectangle و Circle داریم که برای این ساختارها متدهای اینترفیس Shape را پیاده سازی کردیم و در نهایت اندازه مساحت و محیط را محاسبه می کنیم.&lt;/p></description></item></channel></rss>