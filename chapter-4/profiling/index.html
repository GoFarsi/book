<!doctype html><html lang=fa dir=rtl><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="پروفایلینگ یک تکنیک مفید برای شناسایی  گلوگاه‌های
  عملکرد
، بررسی مصرف حافظه و به دست آوردن بینش درباره سربار جمع‌آوری زباله (Garbage Collection) و موارد دیگر است. اکوسیستم Go ابزارهای فوق‌العاده‌ای برای این منظور ارائه می‌دهد. امکان فعال و غیرفعال کردن پروفایلینگ به ویژه هنگام رفع اشکال در یک برنامه CLI نوشته شده با Go بسیار مفید است.

  نقل و قول نویسنده:
شاید profiling برای حال حاضر قابل اهمیت نباشد اما روزی خواهد رسید که در بخش هایی از پروژه دچار مصرف بیش از حد memory, CPU خواهید شد و اینجاس که profiling به شما کمک خواهد کرد سریز منابع را پیدا کنید."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://book.gofarsi.ir/chapter-4/profiling/"><meta property="og:site_name" content="زبان گو فارسی"><meta property="og:title" content="4.25 آموزش profiling"><meta property="og:description" content="پروفایلینگ یک تکنیک مفید برای شناسایی گلوگاه‌های عملکرد ، بررسی مصرف حافظه و به دست آوردن بینش درباره سربار جمع‌آوری زباله (Garbage Collection) و موارد دیگر است. اکوسیستم Go ابزارهای فوق‌العاده‌ای برای این منظور ارائه می‌دهد. امکان فعال و غیرفعال کردن پروفایلینگ به ویژه هنگام رفع اشکال در یک برنامه CLI نوشته شده با Go بسیار مفید است.
نقل و قول نویسنده:
شاید profiling برای حال حاضر قابل اهمیت نباشد اما روزی خواهد رسید که در بخش هایی از پروژه دچار مصرف بیش از حد memory, CPU خواهید شد و اینجاس که profiling به شما کمک خواهد کرد سریز منابع را پیدا کنید."><meta property="og:locale" content="fa"><meta property="og:type" content="article"><meta property="article:section" content="chapter-4"><title>4.25 آموزش profiling | زبان گو فارسی</title><link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://book.gofarsi.ir/chapter-4/profiling/><link rel=stylesheet href=/book.min.cd8f8bc9e4ca964b4dc52c33addd5868719653b7f329734859463db32feac679.css integrity="sha256-zY+LyeTKlktNxSwzrd1YaHGWU7fzKXNIWUY9sy/qxnk=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/fa.search.min.6f1d120c3ac92d248064741d788f685bffbca576b7f5f900d5c542de5d59554c.js integrity="sha256-bx0SDDrJLSSAZHQdeI9oW/+8pXa39fkA1cVC3l1ZVUw=" crossorigin=anonymous></script><link rel=preconnect href=https://cdn.jsdelivr.net crossorigin><link rel=stylesheet href=prism.css><meta name=keywords content><link href=https://cdn.jsdelivr.net/gh/rastikerdar/vazir-font@v30.1.0/dist/font-face.css rel=stylesheet type=text/css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.0/css/all.min.css crossorigin=anonymous><link rel=alternate type=application/rss+xml href=https://book.gofarsi.ir//feed.xml title="زبان گو فارسی"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/prism-themes@1.9.0/themes/prism-one-dark.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/line-numbers/prism-line-numbers.min.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZE44Q8PZDW"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZE44Q8PZDW")</script><script>var html=document.documentElement;localStorage.getItem("themeMode")=="dark"&&html.setAttribute("data-theme","dark"),localStorage.getItem("themeMode")=="light"&&html.setAttribute("data-theme","light")</script></head><body dir=rtl><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><img src=/favicon.png alt=Logo class=book-icon><span>زبان گو فارسی</span></a></h2><div class=magic><div class=book-search><input type=text id=book-search-input placeholder=جستجو aria-label=جستجو maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><div class=js-toggle-wrapper><div class=js-toggle><div class=js-toggle-track><div class=js-toggle-track-check><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAMAAABrrFhUAAAA2FBMVEUAAADExMTw01jg0p/w01fv1FfGxsbGxsbGxsbGxsbGxsbv1Ffv01fw01jv1Fjw1Ffw1Fbw01jv01fv1Fjv01jw01jw01jv1FjHx8fv01jw1FjHx8fFxcXExMTIyMjHx8fw01jv01jv01jv1Ffv01jv1Fnw01jw01jw1Fjv01jv01ju01bv01fv1Fjv01jv1Fjw01fq1GHv01jv01jw0ljw01jv1Ffw01fv1FjFxcXFxcXHx8fFxcXFxcXFxcXw01jFxcXGxsbw01nMzMzv1Fjv01jv01jGxsbNUVPOAAAARnRSTlMAJ0IITyrixqxrYkka2l2PD6jNmohnN+G6sqyEXTggG93GwJJ/d2y7t6BzFNSEfFY9BO+jIOov+eXd3LKoo5uVjTEmGfNjgBujdgAAB3dJREFUeNrs3Qlb2kAQBuARiFfCfRVaWxBFBJRDEHvaWv3y//9R26ctbbVKjt3szMb3H5AnJLO7803o2bNnz57pkt3/9HEvS6n15Z3/3c5rSqmv/i9blE7v/V92KJXe+GtvKI0O/LUDSqNX/torSqOX/tpLSqNdf22X0uitv7ZNKbTlf5fmSmDf/8s+pc8L/y8vKHX2/H/sUcpsbfv/2E7bimjHv+cDpcqu/8BnSpHP/loaq6HXH/z/2klJNbC37T9iOwXvgq39F/4TXuzbexe8OXj1cnfb3+jt7stXB/btkGzt+KG8/0pWee2H9oUskt3xQ3tn03nBnh/BPgWWyWQc4uyjH8EnCshtAUC+NiW2tF6ACX5bVicjYknrX6CJv6xadY7XQOdD8Aj3XBUbxI7G12AdD7UKM2JGXyGUw//kz9i9FnSVwpd4xDW7S6BpMbTCI25rHnGkejl8iEddnZeIIcUbIjU8Id9n9zhUviWWw5MqE2JI5aboCBtccHwaqtwW72CD+TGxo/JgpIyNDl3iRuHR2DECuF4QM+oOR10E0ckRL+qOxz0Ec06sKGyQWCKYMq/KUF2LzAkCGrN6FqprkqohME4vRHVtckMEd8FndaCuUbKAELps6kJ1rbIuwrji8iBQ1yzdQDh14kFZu/wNQjojFpQFJkYI65RYUBaZQWgnxIKq0NQtQhuQTZYIr00WaSKCC7LHGFFUyRoVRFIkW3Txk9B6QOUFEFoTxjVGVAxP0qPoIDJ2e6WRLBFZk8/+QAwrRNfmUMrGNEMcVQaLmZhKiOXM+HI2rgXiyZHw/L+DeCol4fn/BmIqCs//u4grJzv/30dclZLo/H8PsRVF5/8HiC8nOf/fQXyVrNz8/wwqnMnN/ztQYdUQm//PQYm22Pz/EGrcSc3/V6FG3hOa/z+EIkWZ+f8ZlMmIzP9noExLZP7/DOpkJOb/u1DnQmD+fwSVGvLy/xOodC0v/1+ESreOuPx/BUrVpOX/Hai19BIJP/NbCKwNk4i/c6yDf+vKugANKJcR9ReoQbmeqIdgHspdlQS9BnPQoCCoEDqFBi05pfBoDh0uxSyG6tDiSMxyeAAtulI2RFxocilkS6wNTY5lbIpmoMuhjG3xMrTxJByMTKFPXcLR2Cn0GQg4HG1Apxn/4/EqdHLZN0hModUR+xaZFrRqc2+SuoNeTeZtcl4emo14N0oWoVuGdatsBtods26WHkC7Mud2+T70yzMOTCyaSECWb2SmjCQ4bENTQySC2+ixtekKiRgST9kuknFNPPUQidgpI/cVkJQOcXTTRGKIozaSc0P8lJGgDLFTxgaWFwJlJKpAzJSRrD7xcgElZE7f/K6HpNWIkyMkrkeMKPj9UmcOKvr9ssfNhfv99q2GzmBEi5joISg7nwGniE3ysL2bNkw5IgYKTYRkVSmc7SEcyxZD0y7Csmo5PFzBqCkZtSjDMIdM6jdhmkfmZAYwL0umeEUwMCdT7vLgoEJmTFvgoUwmNKrgokbJm56CjzolLWP8zW/0YMhtg5cFJWhU5/DiN3Y4nDudg50OJaRR4/HaN7Ml6gwPwVSVAjuq5y4pPK9QHYOvPgWUa+KHbq/gUGAzt1gBbzcRxhjdHtYmi00/3ckNq2zv+z/ykWeYLFtHw7uJ23C8Eq3NSgun4fZ7gw6E6Clp3J83x93uuLNcQZwcn+SCGaWUX4ABBeTATscUFM8yLrYGBVWDjfJsEqyGnFJwS1howibEbUYzS8FNYJ8ehTASWOZtkuGUYzegwmKclUHnFMroCpa5ZBdlT9aA1ziX5NW5jfNI2NxjnOVLQpVCm1m1JJzK6WbWos1hvrdJLkVxDVucUCTOLSxR4DPhOhTjnVGeJfVwn6I6hw3yJYqqZEUtcM58uJFu4xFFN+N+3h1AgdH3fky4kBbvVmx+SfE4DHu9ko3LH0OyQ46fvNnI+CroXy7kKtI9KVsV5j1SYSGmCeq+AufP3jyNWTpC5qKoRXKn/ajQuSF1PM4NwE81BfL/9MsDHBbBNhSEZfpN7NCrWMYeqVbqQhCX1HMEbZHe0S8pfRCe0wOcPwP3E7slkNzz0jLdZ8H8IzbRuBNwN6b/kvQZiFiW9BiJU5B5hoM5l4QdepKI74Hxff7xb6Ks0pOsrwc21X+214RDCkbChxEljEdZmB8LZnhOYIlTQTB2KSA7X4dlj4Ky8mVwTqbkOHTQdHJkTsl8TdS6oXAsuwnMfy/A6E2QNz8l1+hNUPSIhezZCgYcusRGo42kzZl9LiXpmaEXl8RMolNjxyweft/au5sVBIEgDuDLqqfU/Ez05PemgpqVdBMi5v0fqatEwYpu7Nb+XmGGmf9p5hUO4TuMtkF8wmdgzyktxK/D9ACmCJfNP6d5V2Am4mjzfabXCbAwuD0SBc5usLGjz0nso2SZIWzHablb+xTGPIEtBBmHfzIpjUUK6wRVpyCh6SvOK6e5uLWfO+3yKFhcerfjOfAs1+DCNoBKTNxSQz9J0dR6IjG8Nzi25+ML+gN3rJpl4WVVRMJqn5em2mu64MNOkiRJGE+YnGcOWncZjQAAAABJRU5ErkJggg==" role=presentation style=pointer-events:none width=23 height=23></div><div class=js-toggle-track-x><img src=data:image/png;base64,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 role=presentation style=pointer-events:none width=23 height=23></div></div><div class=js-toggle-thumb><img src=data:image/png;base64,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 role=presentation style=pointer-events:none width=46 height=46></div><input class=js-toggle-screenreader-only type=checkbox aria-label="تغییر تم بین روشن و تاریک"></div></div></div><ul><li><a href=/preface/>پیشگفتار</a></li><li><a href=/history/>تاریخچه</a></li><li><a href=/why-go/>چرا زبان Go؟</a></li><li><a href=/installation/>آموزش نصب</a></li><li><a href=/toolchain/>ابزارها, دستورات گو و معرفی IDE</a></li><li><a href=/roadmap/>نقشه یادگیری زبان گو</a></li><li><a href=/interview/>نمونه سوالات مصاحبه</a></li><li><input type=checkbox id=section-c0c35ea61c635f6152f0c00d6a15569e class=toggle>
<label for=section-c0c35ea61c635f6152f0c00d6a15569e class=flex><a href=/chapter-1/ class=flex-auto>فصل اول: آشنایی با مفاهیم گو</a></label><ul><li><a href=/chapter-1/structure-of-go-code/>1.1 ساختار کد گو</a></li><li><a href=/chapter-1/go-built-in-keywords-identifiers/>1.2 کلید واژه و شناسه‌ها</a></li><li><a href=/chapter-1/go-basic-types/>1.3 تایپ‌های پایه</a></li><li><a href=/chapter-1/go-operators/>1.4 عملگرها</a></li><li><a href=/chapter-1/go-variables-and-consts/>1.5 متغیرها و constant</a></li><li><a href=/chapter-1/go-zero-values/>1.6 مقادیر صفر تایپ‌ها (zero values)</a></li><li><a href=/chapter-1/go-function/>1.7 تابع (function)</a></li><li><a href=/chapter-1/go-array/>1.8 آرایه و slice</a></li><li><a href=/chapter-1/go-for/>1.9 حلقه‌ها (for)</a></li><li><a href=/chapter-1/go-map/>1.10 نقشه map</a></li><li><a href=/chapter-1/go-if-switch/>1.11 شرط (if, switch)</a></li><li><a href=/chapter-1/go-package/>1.12 اضافه کردن پکیج در کد (package)</a></li><li><a href=/chapter-1/go-defer-panic-recovery/>1.13 defer, panic, recovery</a></li><li><a href=/chapter-1/go-builtins/>1.14 لیست تایپ‌ها و توابع Builtin</a></li><li><a href=/chapter-1/go-string-formatting/>1.15 قالب بندی رشته‌ها</a></li></ul></li><li><input type=checkbox id=section-ce9b5b1ec927bacdb2712b9c215a3ca1 class=toggle>
<label for=section-ce9b5b1ec927bacdb2712b9c215a3ca1 class=flex><a href=/chapter-2/ class=flex-auto>فصل دوم: مکانیزم‌های زبان</a></label><ul><li><a href=/chapter-2/pointer/>2.1 اشاره‌گر (Pointer)</a></li><li><a href=/chapter-2/struct/>2.2 ساختار (struct)</a></li><li><a href=/chapter-2/method/>2.3 متد (Method)</a></li><li><a href=/chapter-2/interface/>2.4 اینترفیس (Interface)</a></li><li><a href=/chapter-2/type-embedding/>2.5 جاسازی تایپ (type embedding)</a></li><li><a href=/chapter-2/error-handling/>2.6 مدیریت خطاها</a></li><li><a href=/chapter-2/casting-vs-conversion/>2.7 فرق casting با conversion</a></li></ul></li><li><input type=checkbox id=section-0691270142e95f82c4d2eb637f234afd class=toggle>
<label for=section-0691270142e95f82c4d2eb637f234afd class=flex><a href=/chapter-3/ class=flex-auto>فصل سوم: همزمانی (concurrency)</a></label><ul><li><a href=/chapter-3/go-concurrency/>3.1 آشنایی با همزمانی</a></li><li><a href=/chapter-3/goroutine/>3.2 گوروتین (goroutine)</a></li><li><a href=/chapter-3/go-sync-package/>3.3 پکیج sync</a></li><li><a href=/chapter-3/go-atomic/>3.4 پکیج atomic</a></li><li><a href=/chapter-3/goroutine-data-race/>3.5 آموزش مقابله با data race</a></li><li><a href=/chapter-3/go-channel/>3.6 کانال (channel)</a></li><li><a href=/chapter-3/go-select/>3.7 آموزش استفاده از select</a></li><li><a href=/chapter-3/go-context/>3.8 پکیج context</a></li><li><a href=/chapter-3/go-concurrency-teqniques/>3.9 تکنیک های همزمانی</a></li><li><a href=/chapter-3/go-concurrency-patterns/>3.10 الگو های همزمانی</a></li></ul></li><li><input type=checkbox id=section-59efe912b32b5b1290d5ec2dac84f441 class=toggle checked>
<label for=section-59efe912b32b5b1290d5ec2dac84f441 class=flex><a href=/chapter-4/ class=flex-auto>فصل چهارم: مباحث پیشرفته</a></label><ul><li><a href=/chapter-4/build-go-file/>4.1 آموزش Build پروژه</a></li><li><a href=/chapter-4/debugging-go-code/>4.2 آموزش کار با Debugging</a></li><li><a href=/chapter-4/go-mod/>4.3 آموزش کار با go mod</a></li><li><a href=/chapter-4/workspace/>4.4 آموزش کار با workspace</a></li><li><a href=/chapter-4/vendor/>4.5 آموزش کار با Vendor</a></li><li><a href=/chapter-4/command-line-go/>4.6 آموزش نوشتن برنامه command line</a></li><li><a href=/chapter-4/work-with-file-in-go/>4.7 آموزش کار با فایل</a></li><li><a href=/chapter-4/work-with-json-file-in-go/>4.8 آموزش کار با json</a></li><li><a href=/chapter-4/work-with-toml-file-in-go/>4.9 آموزش کار با toml</a></li><li><a href=/chapter-4/work-with-yaml-file-in-go/>4.10 آموزش کار با yaml</a></li><li><a href=/chapter-4/work-with-csv-file-in-go/>4.11 آموزش کار با csv</a></li><li><a href=/chapter-4/work-with-ini-file-in-go/>4.12 آموزش کار با ini</a></li><li><a href=/chapter-4/work-with-environment-variable/>4.13 آموزش کار با environment variable</a></li><li><a href=/chapter-4/go-regular-expressions/>4.14 آموزش کار با regexp</a></li><li><a href=/chapter-4/go-reflection/>4.15 آموزش reflection</a></li><li><a href=/chapter-4/go-generator/>4.16 آموزش generator</a></li><li><a href=/chapter-4/go-stringer/>4.17 آموزش stringer</a></li><li><a href=/chapter-4/effective-go/>4.18 تکنیک های کدنویسی زبان گو</a></li><li><a href=/chapter-4/go-commentry/>4.19 اصول کامنت نویسی</a></li><li><a href=/chapter-4/go-code-rules/>4.20 قوانین کدنویسی در گو</a></li><li><a href=/chapter-4/go-garbage-collector/>4.21 زباله جمع کن (garbage collector)</a></li><li><a href=/chapter-4/go-plugin/>4.22 کتابخانه Plugin</a></li><li><input type=checkbox id=section-687c92e06ed3c05242e60a3a1a266aa4 class=toggle>
<label for=section-687c92e06ed3c05242e60a3a1a266aa4 class=flex><a href=/chapter-4/oop/ class=flex-auto>4.23 شی گرایی در زبان گو</a></label><ul><li><a href=/chapter-4/oop/go-encapsulation/>4.23.1 کپسوله سازی (Encapsulation)</a></li><li><a href=/chapter-4/oop/go-inheritance/>4.22.2 ارث بری</a></li><li><a href=/chapter-4/oop/go-polymorphism/>4.23.3 پلی مورفیسم (Polymorphism)</a></li><li><a href=/chapter-4/oop/go-overriding/>4.23.4 overriding</a></li><li><a href=/chapter-4/oop/go-abstraction/>4.23.5 abstraction</a></li></ul></li><li><a href=/chapter-4/tracing/>4.24 آموزش tracing</a></li><li><a href=/chapter-4/profiling/ class=active>4.25 آموزش profiling</a></li><li><a href=/chapter-4/go-project-layout/>4.26 ساختار پروژه</a></li><li><a href=/chapter-4/go-io-package/>4.27 آموزش کار با پکیج io</a></li></ul></li><li><input type=checkbox id=section-134502b5358f6cf5c83ad497f832087a class=toggle>
<label for=section-134502b5358f6cf5c83ad497f832087a class=flex><a href=/chapter-5/ class=flex-auto>فصل پنجم: برنامه نویسی شبکه با گو</a></label><ul><li><a href=/chapter-5/network-basic/>5.1 شبکه چیست</a></li><li><a href=/chapter-5/go-tcp-server-begginer/>5.2 سرور tcp مقدماتی</a></li><li><a href=/chapter-5/go-tcp-server-advanced/>5.3 سرور tcp پیشرفته</a></li><li><a href=/chapter-5/go-udp-server-begginer/>5.4 سرور udp مقدماتی</a></li><li><a href=/chapter-5/go-udp-server-advanced/>5.5 سرور udp پیشرفته</a></li><li><a href=/chapter-5/go-http-server-begginer/>5.6 کتابخانه http سمت سرور مقدماتی</a></li><li><a href=/chapter-5/go-http-server-advanced/>5.7 کتابخانه http سمت سرور پیشرفته</a></li><li><a href=/chapter-5/go-http-client-begginer/>5.8 کتابخانه http سمت کلاینت مقدماتی</a></li><li><a href=/chapter-5/go-http-client-advanced/>5.9 کتابخانه http سمت کلاینت پیشرفته</a></li><li><a href=/chapter-5/go-quic-prtoocol/>5.10 پروتکل quic</a></li></ul></li><li><input type=checkbox id=section-6f78676abc6f42fefd423ea7de4e1c4d class=toggle>
<label for=section-6f78676abc6f42fefd423ea7de4e1c4d class=flex><a href=/chapter-6/ class=flex-auto>فصل ششم: ژنریک ها (Generics)</a></label><ul><li><a href=/chapter-6/go-generics-basic/>6.1 مقدمه و اهمیت ژنریک‌ها</a></li><li><a href=/chapter-6/go-generics-fundamentals/>6.2 مبانی ژنریک‌ها در Go</a></li><li><a href=/chapter-6/go-generics-syntax-and-structure/>6.3 سینتکس و ساختار ژنریک‌ها در Go</a></li><li><a href=/chapter-6/go-generics-type-sets-and-constraints/>6.4 Constraints و Type Sets</a></li><li><a href=/chapter-6/go-generics-examples-and-practical/>6.5 مثال‌ها و کاربردهای عملی ژنریک‌ها</a></li><li><a href=/chapter-6/comparing-generics/>6.6 مقایسه ژنریک‌ها با راهکارهای قبل از Go 1.18</a></li><li><a href=/chapter-6/limitations-errors-and-anti-patterns-in-generics/>6.7 محدودیت‌ها، خطاها و ضدالگوها در ژنریک‌ها</a></li><li><a href=/chapter-6/generics-best-practice/>6.8 بهترین شیوه‌های استفاده از ژنریک‌ها (Best Practices)</a></li><li><a href=/chapter-6/generics-advanced-examples-and-tips/>6.9 مثال‌های پیشرفته و نکات ویژه</a></li></ul></li><li><input type=checkbox id=section-8f5df719cb6867058bc4273b800e1879 class=toggle>
<label for=section-8f5df719cb6867058bc4273b800e1879 class=flex><a href=/chapter-7/ class=flex-auto>فصل هفتم: تست نویسی</a></label><ul><li><a href=/chapter-7/go-introduction-testing/>7.1 مقدمه‌ای بر تست در Go</a></li><li><a href=/chapter-7/go-unit-testing/>7.2 تست واحد (Unit Test)</a></li><li><a href=/chapter-7/go-table-driven-tests/>7.3 تست جدول‌محور (Table-Driven Test)</a></li><li><a href=/chapter-7/go-integration-testing/>7.4 تست یکپارچه (Integration Test)</a></li></ul></li><li><input type=checkbox id=section-46582e13a18a41adc7936c360b185ec8 class=toggle>
<label for=section-46582e13a18a41adc7936c360b185ec8 class=flex><a href=/chapter-8/ class=flex-auto>فصل هشتم: پکیج های استاندارد</a></label><ul></ul></li><li><input type=checkbox id=section-7b4fd75e0c8dddcfaf05d2809955458b class=toggle>
<label for=section-7b4fd75e0c8dddcfaf05d2809955458b class=flex><a href=/chapter-9/ class=flex-auto>فصل نهم: الگوهای طراحی</a></label><ul><li><input type=checkbox id=section-91fecfeb90059a6577f742161c3cc416 class=toggle>
<label for=section-91fecfeb90059a6577f742161c3cc416 class=flex><a href=/chapter-9/creational-patterns/ class=flex-auto>9.1 الگوهای طراحی سازنده</a></label><ul><li><a href=/chapter-9/creational-patterns/go-singleton-pattern/>9.1.1 الگو Singleton</a></li><li><a href=/chapter-9/creational-patterns/go-factory-method-pattern/>9.1.2 الگو Factory Method</a></li><li><a href=/chapter-9/creational-patterns/go-prototype-pattern/>9.1.3 الگو Prototype</a></li><li><a href=/chapter-9/creational-patterns/go-abstract-factory-pattern/>9.1.4 الگو Abstract Factory</a></li><li><a href=/chapter-9/creational-patterns/go-builder-pattern/>9.1.6 الگو Builder</a></li><li><a href=/chapter-9/creational-patterns/go-object-pool-pattern/>9.1.7 الگو Object Pool</a></li></ul></li><li><input type=checkbox id=section-0bf1b67244bd7a1b2067d73a9ac05c84 class=toggle>
<label for=section-0bf1b67244bd7a1b2067d73a9ac05c84 class=flex><a href=/chapter-9/structural-patterns/ class=flex-auto>9.2 الگوهای طراحی ساختاری</a></label><ul><li><a href=/chapter-9/structural-patterns/go-adaptor-pattern/>9.2.1 الگو Adaptor</a></li><li><a href=/chapter-9/structural-patterns/go-bridge-pattern/>9.2.2 الگو Bridge</a></li><li><a href=/chapter-9/structural-patterns/go-composite-pattern/>9.2.3 الگو Composite</a></li><li><a href=/chapter-9/structural-patterns/go-decorator-pattern/>9.2.1 الگو Decorator</a></li><li><a href=/chapter-9/structural-patterns/go-facade-pattern/>9.2.5 الگو Facade</a></li><li><a href=/chapter-9/structural-patterns/go-flyweight-pattern/>9.2.6 الگو Flyweight</a></li><li><a href=/chapter-9/structural-patterns/go-proxy-pattern/>9.2.7 الگو Proxy</a></li></ul></li><li><input type=checkbox id=section-67e202f99a50c1e49347339369c874b1 class=toggle>
<label for=section-67e202f99a50c1e49347339369c874b1 class=flex><a href=/chapter-9/behavioral-patterns/ class=flex-auto>9.3 الگوهای طراحی رفتاری</a></label><ul><li><a href=/chapter-9/behavioral-patterns/go-chain-of-responsibility-pattern/>9.3.1 الگو Chain Of Responsibility</a></li><li><a href=/chapter-9/behavioral-patterns/go-command-pattern/>9.3.2 الگو Command</a></li><li><a href=/chapter-9/behavioral-patterns/go-iterator-pattern/>9.3.3 الگو Iterator</a></li><li><a href=/chapter-9/behavioral-patterns/go-mediator-pattern/>9.3.4 الگو Mediator</a></li><li><a href=/chapter-9/behavioral-patterns/go-memento-pattern/>9.3.5 الگو Memento</a></li><li><a href=/chapter-9/behavioral-patterns/go-observer-pattern/>9.3.6 الگو Observer</a></li><li><a href=/chapter-9/behavioral-patterns/go-state-pattern/>9.3.7 الگو State</a></li><li><a href=/chapter-9/behavioral-patterns/go-strategy-pattern/>9.3.8 الگو Strategy</a></li><li><a href=/chapter-9/behavioral-patterns/go-template-method-pattern/>9.3.9 الگو Template Method</a></li><li><a href=/chapter-9/behavioral-patterns/go-visitor-pattern/>9.3.10 الگو Visitor</a></li></ul></li><li><input type=checkbox id=section-a8aa81f62696e9f9c69a81a3318a50eb class=toggle>
<label for=section-a8aa81f62696e9f9c69a81a3318a50eb class=flex><a href=/chapter-9/concurrency-patterns/ class=flex-auto>9.4 الگوهای همزمانی</a></label><ul><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-wait-for-result/>9.4.1 الگو Wait For Result</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-fan-out-in/>9.4.2 الگو Fan Out/In</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-wait-for-task/>9.4.3 الگو Wait For Task</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-worker-pool/>9.4.4 الگوی Worker Pool</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-drop/>9.4.5 الگو Drop</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-cancellation/>9.4.6 الگو Context Cancellation Pattern</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-semaphore/>9.4.7 الگو Semaphore</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-retry-timeout/>9.4.8 الگو Retry Timeout</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-producer-consumer/>9.4.9 الگو Producer-Consumer</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-monitor/>9.4.10 الگو Monitor</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-future/>9.4.11 الگو Future</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-pipeline/>9.4.12 الگو Pipeline</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-subscription/>9.4.13 الگو Subscription</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-brdige-channel/>9.4.14 الگو Bridge Channel</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-queuing/>9.4.15 الگو Queuing</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-ratelimit/>9.4.16 الگو Rate limit</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-deadlock-recovery/>9.4.17 الگو Deadlock Recovery</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-channel-cancellation/>9.4.18 الگو Channel Cancellation</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-lock-free-synchronization/>9.4.19 الگو Lock-free synchronization</a></li></ul></li><li><input type=checkbox id=section-d4428d0313ccb2e3380b00740324e064 class=toggle>
<label for=section-d4428d0313ccb2e3380b00740324e064 class=flex><a href=/chapter-9/cloud-native-patterns/ class=flex-auto>9.5 الگوهای Cloud Native</a></label><ul><li><a href=/chapter-9/cloud-native-patterns/go-cloud-native-circuit-breaker-pattern/>9.5.1 الگو Circuit Breaker</a></li><li><a href=/chapter-9/cloud-native-patterns/go-cloud-native-debounce-pattern/>9.5.2 الگو Debounce</a></li><li><a href=/chapter-9/cloud-native-patterns/go-cloud-native-retry-pattern/>9.5.3 الگو Retry</a></li><li><a href=/chapter-9/cloud-native-patterns/go-cloud-native-throttle-pattern/>9.5.4 الگو Throttle</a></li><li><a href=/chapter-9/cloud-native-patterns/go-cloud-native-timeout-pattern/>9.5.5 الگو Timeout</a></li></ul></li><li><input type=checkbox id=section-d2db70ad636838c12fc76435099656ac class=toggle>
<label for=section-d2db70ad636838c12fc76435099656ac class=flex><a href=/chapter-9/anti-pattern/ class=flex-auto>9.6 ضد الگوها (Anti-Patterns)</a></label><ul><li><a href=/chapter-9/anti-pattern/go-anti-patterns-in-syntax/>9.6.1 ضد الگو سینتکسی</a></li></ul></li><li><a href=/chapter-9/solid-principle-in-golang/>9.7 اصول SOLID</a></li></ul></li><li><input type=checkbox id=section-109a423730eebb4b9e804ab6e8dc6af0 class=toggle>
<label for=section-109a423730eebb4b9e804ab6e8dc6af0 class=flex><a href=/chapter-10/ class=flex-auto>فصل دهم: الگوریتم و ساختار داده</a></label><ul><li><a href=/chapter-10/10.1--data-structures-queue-stack-lists/>10.1 Data Structures (Queue Stack Lists)</a></li></ul></li><li><input type=checkbox id=section-0736842d303fef477d0a09e8de4a0d85 class=toggle>
<label for=section-0736842d303fef477d0a09e8de4a0d85 class=flex><a href=/chapter-11/ class=flex-auto>فصل یازدهم: معماری های نرم افزار</a></label><ul></ul></li><li><input type=checkbox id=section-efb5b19050ead65a76618516db266d2d class=toggle>
<label for=section-efb5b19050ead65a76618516db266d2d class=flex><a href=/chapter-12/ class=flex-auto>فصل دوازدهم: شبکه بلاکچین</a></label><ul><li><input type=checkbox id=section-ee81a41ef810f317eba2e67d447c0ec4 class=toggle>
<label for=section-ee81a41ef810f317eba2e67d447c0ec4 class=flex><a href=/chapter-12/blockchain/ class=flex-auto>12.1 بلاکچین</a></label><ul><li><a href=/chapter-12/blockchain/blockchain/>12.1.1 بلاکچین چیست</a></li><li><a href=/chapter-12/blockchain/blockchain-history/>12.1.2 تاریخچه بلاکچین</a></li><li><a href=/chapter-12/blockchain/blockchain-architecture/>12.1.3 معماری بلاکچین</a></li><li><a href=/chapter-12/blockchain/blockchain-type/>12.1.4 انواع بلاکچین</a></li><li><a href=/chapter-12/blockchain/blockchain-different-with-centerlized/>12.1.5 تفاوت سیستم متمرکز با غیرمتمرکز</a></li><li><a href=/chapter-12/blockchain/blockchain-scale/>12.1.6 مقیاس پذیری در بلاکچین</a></li><li><a href=/chapter-12/blockchain/blockchain-security/>12.1.7 امنیت در بلاکچین</a></li><li><a href=/chapter-12/blockchain/blockchain-cryptography/>12.1.8 مفاهیم رمزنگاری</a></li><li><a href=/chapter-12/blockchain/blockchain-consensus-algorithm/>12.1.10 الگوریتم اجماع (Consensus)</a></li><li><a href=/chapter-12/blockchain/blockchain-p2p-network/>12.1.11 ساختار و کاربرد شبکه P2P</a></li><li><a href=/chapter-12/blockchain/blockchain-data-management/>12.1.12 مدیریت داده در بلاکچین</a></li><li><a href=/chapter-12/blockchain/blockchain-network-testing/>12.1.13 تست پذیری شبکه</a></li><li><a href=/chapter-12/blockchain/blockchain-analyze-and-optimization/>12.1.14 ارزیابی و بهینه سازی شبکه</a></li><li><a href=/chapter-12/blockchain/blockchain-monitoring/>12.1.15 مانیتورینگ شبکه</a></li><li><a href=/chapter-12/blockchain/blockchain-forking/>12.1.16 استراتژی فورک ها</a></li><li><a href=/chapter-12/blockchain/blockchain-api-and-sdk/>12.1.17 پیاده سازی انواع API ها و SDK ها</a></li><li><a href=/chapter-12/blockchain/blockchain-keys-and-addresses/>12.1.18 کلیدها و آدرس ها</a></li><li><a href=/chapter-12/blockchain/blockchain-accounts/>12.1.19 اکانت ها</a></li><li><a href=/chapter-12/blockchain/blockchain-transactions-and-messages/>12.1.20 تراکنش ها و پیام ها</a></li><li><a href=/chapter-12/blockchain/blockchain-blocks/>12.1.21 بلوک ها (Blocks)</a></li><li><a href=/chapter-12/blockchain/blockchain-genesis/>12.1.22 جنسیس (Genesis)</a></li><li><a href=/chapter-12/blockchain/blockchain-smart-contracts/>12.1.23 قراردادهای هوشمند</a></li><li><a href=/chapter-12/blockchain/blockchain-privacy/>12.1.24 حریم خصوصی شبکه</a></li></ul></li><li><input type=checkbox id=section-3a22b13c7bb1ba964a59c01435868bd6 class=toggle>
<label for=section-3a22b13c7bb1ba964a59c01435868bd6 class=flex><a href=/chapter-12/bitcoin/ class=flex-auto>12.2 شبکه بیت کوین</a></label><ul><li><a href=/chapter-12/bitcoin/bitcoin/>12.2.1 معرفی بیت کوین</a></li><li><a href=/chapter-12/bitcoin/bitcoin-cryptography/>12.2.2 رمزنگاری در بیت کوین</a></li><li><a href=/chapter-12/bitcoin/bitcoin-addresses/>12.2.3 آدرس ها</a></li><li><a href=/chapter-12/bitcoin/bitcoin-transactions/>12.2.4 تراکنش ها</a></li><li><a href=/chapter-12/bitcoin/bitcoin-structure/>12.2.5 ساختار بلاکچین بیت کوین</a></li><li><a href=/chapter-12/bitcoin/bitcoin-consensus/>12.2.6 الگوریتم اجماع</a></li><li><a href=/chapter-12/bitcoin/bitcoin-miners/>12.2.7 ماینرها</a></li><li><a href=/chapter-12/bitcoin/bitcoin-network/>12.2.8 شبکه</a></li><li><a href=/chapter-12/bitcoin/bitcoin-wallets/>12.2.9 والت ها</a></li><li><a href=/chapter-12/bitcoin/bitcoin-in-real-world/>12.2.10 بیت کوین در دنیای واقعی</a></li><li><a href=/chapter-12/bitcoin/bitcoin-innovation/>12.2.11 نوآوری</a></li><li><a href=/chapter-12/bitcoin/bitcoin-clients/>12.2.12 کلاینت ها</a></li><li><a href=/chapter-12/bitcoin/bitcoin-programming/>12.2.13 برنامه نویسی در بیت کوین</a></li></ul></li><li><input type=checkbox id=section-b9f4acac44a727569ffab43028a36441 class=toggle>
<label for=section-b9f4acac44a727569ffab43028a36441 class=flex><a href=/chapter-12/ethereum/ class=flex-auto>12.3 شبکه اتریوم</a></label><ul><li><a href=/chapter-12/ethereum/ethereum/>12.3.1 معرفی اتریوم</a></li><li><a href=/chapter-12/ethereum/ethereum-cryptography/>12.3.2 رمزنگاری</a></li><li><a href=/chapter-12/ethereum/ethereum-keys-and-addresses/>12.3.3 آدرس ها و کلیدها</a></li><li><a href=/chapter-12/ethereum/ethereum-accounts/>12.3.4 اکانت ها</a></li><li><a href=/chapter-12/ethereum/ethereum-transactions-and-messages/>12.3.5 تراکنش ها و پیام ها</a></li><li><a href=/chapter-12/ethereum/ethereum-virtual-machine/>12.3.6 ماشین مجازی اتریوم</a></li><li><a href=/chapter-12/ethereum/ethereum-blocks/>12.3.7 بلاک ها</a></li><li><a href=/chapter-12/ethereum/ethereum-consensus/>12.3.8 الگوریتم اجماع</a></li><li><a href=/chapter-12/ethereum/ethereum-nodes-and-miners/>12.3.9 نودها و ماینرها</a></li><li><a href=/chapter-12/ethereum/ethereum-network/>12.3.10 شبکه</a></li><li><a href=/chapter-12/ethereum/ethereum-smart-contracts/>12.3.11 قراردادهای هوشمند</a></li><li><a href=/chapter-12/ethereum/ethereum-wallets-and-clients/>12.3.12 والت ها و کلاینت ها</a></li><li><a href=/chapter-12/ethereum/go-ethereum/>12.3.13 معرفی go-ethereum</a></li><li><a href=/chapter-12/ethereum/work-with-accounts/>12.3.14 کار با اکانت ها</a></li><li><a href=/chapter-12/ethereum/transactions-on-ethereum/>12.3.15 تراکنش برروی اتریوم</a></li><li><a href=/chapter-12/ethereum/read-write-in-smart-contracts/>12.3.16 نوشتن و ارتباط با قراردادهای هوشمند</a></li><li><a href=/chapter-12/ethereum/abi-and-bin-file/>12.3.17 آشنایی با فایل ABI و bytecode</a></li><li><a href=/chapter-12/ethereum/event-logs/>12.3.18 خواندن و دریافت لحظه ای لاگ های کانترکت ها</a></li><li><a href=/chapter-12/ethereum/signature/>12.3.19 ایجاد و تایید امضا</a></li><li><a href=/chapter-12/ethereum/geth/>12.3.20 کار با geth</a></li><li><a href=/chapter-12/ethereum/protocol-swarm-and-whisper/>12.3.21 کار با پروتکل whisper و swarm</a></li></ul></li><li><input type=checkbox id=section-71c1e946dcbe629ce566392c9ba8a5bd class=toggle>
<label for=section-71c1e946dcbe629ce566392c9ba8a5bd class=flex><a href=/chapter-12/pactus/ class=flex-auto>12.4 شبکه پکتوس</a></label><ul><li><a href=/chapter-12/pactus/pactus/>12.4.1 معرفی پکتوس</a></li><li><a href=/chapter-12/pactus/pactus-roadmap/>12.4.2 نقشه راه و اهداف</a></li><li><a href=/chapter-12/pactus/pactus-cryptography/>12.4.3 رمزنگاری</a></li><li><a href=/chapter-12/pactus/pactus-addresses-and-keys/>12.4.4 آدرس ها و کلیدها</a></li><li><a href=/chapter-12/pactus/pactus-accounts/>12.4.5 اکانت ها</a></li><li><a href=/chapter-12/pactus/pactus-transactions-and-messages/>12.4.6 تراکنش ها و پیغام ها</a></li><li><a href=/chapter-12/pactus/pactus-consensus/>12.4.7 الگوریتم اجماع</a></li><li><a href=/chapter-12/pactus/pactus-client/>12.4.8 کار با کلاینت</a></li><li><a href=/chapter-12/pactus/pactus-smart-contracts/>12.4.9 قراردادهای هوشمند (بزودی)</a></li></ul></li></ul></li></ul><a class="book-btn gray" href=https://github.com/GoFarsi/book>مخزن کتاب</a>
<a class=book-btn href=https://github.com/GoFarsi/book/blob/main/COUNTRIBUTING.md>مشارکت در کتاب زبان گو</a><center><p><img alt="GitHub Repo stars" src=https://img.shields.io/github/stars/GoFarsi/book> <img alt=GitHub src=https://img.shields.io/github/license/gofarsi/book> <img alt="GitHub contributors" src=https://img.shields.io/github/contributors/gofarsi/book></p></center></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>4.25 آموزش profiling</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"></br><main><div class=wrapper><a href=https://t.me/GolangEngineers class="icon telegram" target=_blank><div class=tooltip>گروه تلگرامی مهندسین گولنگ</div><span><i class="fab fa-telegram"></i></span>
</a><a href=https://linkedin.com/in/Ja7ad class="icon linkedin" target=_blank><div class=tooltip>لینکدین نویسنده</div><span><i class="fab fa-linkedin"></i></span>
</a><a href=https://twitter.com/Ja7adR class="icon twitter" target=_blank><div class=tooltip>توییتر نویسنده</div><span><i class="fab fa-twitter"></i></span></a></div></main></br></br><nav id=TableOfContents><ul><li><ul><li><a href=#4251-مدل-ذهنی-mental-برای-go>4.25.1 مدل ذهنی (mental) برای Go</a><ul><li><a href=#42511-زمانبند-scheduler-گوروتین>4.25.1.1 زمان‌بند (scheduler) گوروتین</a></li><li><a href=#42512-زباله-جمع-کن-garbage-collector>4.25.1.2 زباله جمع کن (Garbage Collector)</a></li></ul></li><li><a href=#4252-درک-عمیق-پروفایلرهای-profilers-گو>4.25.2 درک عمیق پروفایلرهای (Profilers) گو</a><ul><li><a href=#42521-پروفایلر-cpu>4.25.2.1 پروفایلر CPU</a></li><li><a href=#42522-پروفایلر-حافظه-memory>4.25.2.2 پروفایلر حافظه (Memory)</a></li><li><a href=#42523-پروفایلر-بلاک>4.25.2.3 پروفایلر بلاک</a></li><li><a href=#42524-پروفایلر-mutex>4.25.2.4 پروفایلر Mutex</a></li><li><a href=#42525-پروفایلر-goroutine>4.25.2.5 پروفایلر Goroutine</a></li><li><a href=#42526-پروفایلر-threadcreate>4.25.2.6 پروفایلر ThreadCreate</a></li></ul></li><li><a href=#4253-آموزش-کار-با-ابزار-go-pprof>4.25.3 آموزش کار با ابزار go pprof</a><ul><li><a href=#42531-ویژگیها>4.25.3.1 ویژگی‌ها</a></li><li><a href=#42532-فرمت-فایل>4.25.3.2 فرمت فایل</a></li><li><a href=#42533-فرمت-دادههای-pprof>4.25.3.3 فرمت داده‌های pprof</a></li><li><a href=#42534-رمزگشایی-decoding>4.25.3.4 رمزگشایی (Decoding)</a></li><li><a href=#42535-استفاده-از-pprofutils>4.25.3.5 استفاده از <code>pprofutils</code></a></li><li><a href=#42536-استفاده-از-go-tool-pprof>4.25.3.6 استفاده از <code>go tool pprof</code></a></li><li><a href=#42537-استفاده-از-protoc>4.25.3.7 استفاده از <code>protoc</code></a></li><li><a href=#42538-استفاده-از-nethttppprof-پروفایلینگ-ریموت>4.25.3.8 استفاده از net/http/pprof پروفایلینگ ریموت</a></li><li><a href=#42539-دستورات-pprof>4.25.3.9 دستورات pprof</a></li><li><a href=#42539-نتیجهگیری>4.25.3.9 نتیجه‌گیری</a></li></ul></li></ul></li></ul></nav></aside></header><h1>4.25 آموزش profiling</h1><article class="markdown book-article"><p>پروفایلینگ یک تکنیک مفید برای شناسایی <span class=tooltip data-tooltip=bottlenecks ontouchend=toggleTooltip(this)>گلوگاه‌های</span>
<span class=tooltip data-tooltip=performance ontouchend=toggleTooltip(this)>عملکرد</span>
، بررسی مصرف حافظه و به دست آوردن بینش درباره سربار جمع‌آوری زباله (Garbage Collection) و موارد دیگر است. اکوسیستم Go ابزارهای فوق‌العاده‌ای برای این منظور ارائه می‌دهد. امکان فعال و غیرفعال کردن پروفایلینگ به ویژه هنگام رفع اشکال در یک برنامه CLI نوشته شده با Go بسیار مفید است.</p><blockquote class="book-hint info"><p><strong>نقل و قول نویسنده:</strong></p><p>شاید profiling برای حال حاضر قابل اهمیت نباشد اما روزی خواهد رسید که در بخش هایی از پروژه دچار مصرف بیش از حد memory, CPU خواهید شد و اینجاس که profiling به شما کمک خواهد کرد سریز منابع را پیدا کنید.</p><p>سعی کنید این مطلب را یاد بگیرید قطعا یک روزی با این موضوع مواجه خواهید شد.</p></blockquote><p><strong>چه زمانی پروفایل کنیم؟</strong></p><p>موارد استفاده رایج پروفایلینگ عبارتند از:</p><ul><li>کشف <span class=tooltip data-tooltip=bottlenecks ontouchend=toggleTooltip(this)>گلوگاه‌های</span>
عملکرد و رفع آن‌ها برای بهبود عملکرد کلی</li><li>یافتن <span class=tooltip data-tooltip=allocations ontouchend=toggleTooltip(this)>تخصیص‌های</span>
اضافی حافظه و کاهش آن‌ها به منظور کاهش تاثیر منفی Garbage Collection بر عملکرد.</li><li>سرریز یا نشت حافظه یا CPU در بلند مدت (نشت منابع وقتی مشخص می شود که سرویس شما برای مدت طولانی چند روز در حال اجرا باشد.)</li></ul><h2 id=4251-مدل-ذهنی-mental-برای-go>4.25.1 مدل ذهنی (mental) برای Go
<a class=anchor href=#4251-%d9%85%d8%af%d9%84-%d8%b0%d9%87%d9%86%db%8c-mental-%d8%a8%d8%b1%d8%a7%db%8c-go>#</a></h2><p>ممکن است بتوانید در نوشتن کد Go به مهارت بالایی برسید بدون اینکه درک دقیقی از نحوه عملکرد این زبان در پشت صحنه داشته باشید. اما وقتی به عملکرد و اشکال‌زدایی می‌رسیم، داشتن یک مدل ذهنی از جزئیات داخلی زبان به شدت به نفع شما خواهد بود. بنابراین، ابتدا یک مدل ابتدایی از Go را شرح می‌دهیم. این مدل به اندازه کافی خوب است که به شما کمک کند از اشتباهات رایج اجتناب کنید، اما تمامی مدل‌ها محدودیت دارند، بنابراین توصیه می‌شود که برای حل مشکلات پیچیده‌تر در آینده، به منابع تخصصی‌تر مراجعه کنید.</p><p>وظیفه اصلی Go، مشابه یک سیستم‌عامل، این است که منابع سخت‌افزاری را چندوظیفه‌ای و انتزاعی کند. این کار عمدتاً با استفاده از دو انتزاع اصلی انجام می‌شود:</p><ol><li><span class=tooltip data-tooltip=Scheduler ontouchend=toggleTooltip(this)>زمان‌بند</span>
Goroutine: مدیریت نحوه اجرای کد شما بر روی پردازنده‌های سیستم.</li><li>جمع‌آوری زباله (Garbage Collector): حافظه مجازی را فراهم می‌کند که به طور خودکار در صورت نیاز آزاد می‌شود.</li></ol><h3 id=42511-زمانبند-scheduler-گوروتین>4.25.1.1 زمان‌بند (scheduler) گوروتین
<a class=anchor href=#42511-%d8%b2%d9%85%d8%a7%d9%86%d8%a8%d9%86%d8%af-scheduler-%da%af%d9%88%d8%b1%d9%88%d8%aa%db%8c%d9%86>#</a></h3><p>ابتدا با استفاده از مثال زیر در مورد زمان‌بند صحبت کنیم:</p><pre><code class=language-go>func main() {
    res, err := http.Get(&quot;https://example.org/&quot;)
    if err != nil {
        panic(err)
    }
    fmt.Printf(&quot;%d\n&quot;, res.StatusCode)
}
</code></pre><p>در اینجا یک goroutine واحد داریم که آن را G1 می‌نامیم و این goroutine تابع main را اجرا می‌کند. تصویر زیر یک خط زمانی ساده‌شده از نحوه اجرای این goroutine روی یک پردازنده را نشان می‌دهد. ابتدا G1 بر روی پردازنده اجرا می‌شود تا درخواست HTTP را آماده کند. سپس پردازنده بیکار می‌شود زیرا goroutine باید منتظر شبکه بماند. در نهایت، goroutine دوباره روی پردازنده زمان‌بندی می‌شود تا کد وضعیت را چاپ کند.</p><center><a href=#><img src=../../assets/img/content/chapter4/profiling/1.png alt="go scheduler"></a></center><p>از دیدگاه زمان‌بند، برنامه بالا به این صورت اجرا می‌شود. ابتدا G1 در حال اجرا روی پردازنده 1 است. سپس goroutine از پردازنده خارج می‌شود و در حال انتظار برای شبکه قرار می‌گیرد. زمانی که زمان‌بند متوجه می‌شود شبکه پاسخ داده است (با استفاده از ورودی/خروجی غیرمسدودکننده، مشابه Node.js) گوروتین را به عنوان " <span class=tooltip data-tooltip=Runnable ontouchend=toggleTooltip(this)>آماده اجرا</span>
" علامت‌گذاری می‌کند. و به محض اینکه یک هسته پردازنده آزاد شود، goroutine دوباره شروع به اجرا می‌کند. در مثال ما تمام هسته‌ها در دسترس هستند، بنابراین G1 بلافاصله بدون صرف زمانی در حالت &ldquo;آماده اجرا&rdquo; می‌تواند به اجرای تابع <code>fmt.Printf()</code> بر روی یکی از پردازنده‌ها برگردد.</p><center><a href=#><img src=../../assets/img/content/chapter4/profiling/2.gif alt=scheduler></a></center><p>در اکثر مواقع، برنامه‌های Go چندین goroutine را به طور همزمان اجرا می‌کنند، بنابراین تعدادی از goroutineها در حال اجرای روی برخی از هسته‌های پردازنده هستند، تعداد زیادی از goroutineها به دلایل مختلف در حالت &ldquo;انتظار&rdquo; قرار دارند، و ایده‌آل این است که هیچ goroutineی در حالت &ldquo;آماده اجرا&rdquo; نباشد، مگر اینکه برنامه شما بار پردازشی بسیار بالایی بر روی پردازنده ایجاد کند. یک مثال از این حالت را می‌توان در زیر مشاهده کرد.</p><center><a href=#><img src=../../assets/img/content/chapter4/profiling/3.png alt="scheduler complete"></a></center><p>البته مدل بالا بسیاری از جزئیات را نادیده می‌گیرد. در واقعیت، زمان‌بند Go بر روی نخ‌هایی (threads) که توسط سیستم‌عامل مدیریت می‌شوند، کار می‌کند و حتی خود پردازنده‌ها نیز قادر به استفاده از هایپرتردینگ (hyper-threading) هستند که می‌توان آن را نوعی زمان‌بندی در نظر گرفت.</p><p>با این حال، مدل فوق باید برای درک بخش‌های باقی‌مانده از این راهنما کافی باشد. به طور خاص، باید روشن شود که زمان اندازه‌گیری‌شده توسط پروفایلرهای مختلف Go در اصل زمانی است که goroutineهای شما در حالت &ldquo;اجرا&rdquo; (Executing) و &ldquo;انتظار&rdquo; (Waiting) صرف می‌کنند، همان‌طور که در نمودار زیر نشان داده شده است.</p><center><a href=#><img src=../../assets/img/content/chapter4/profiling/4.png alt="profile venn"></a></center><h3 id=42512-زباله-جمع-کن-garbage-collector>4.25.1.2 زباله جمع کن (Garbage Collector)
<a class=anchor href=#42512-%d8%b2%d8%a8%d8%a7%d9%84%d9%87-%d8%ac%d9%85%d8%b9-%da%a9%d9%86-garbage-collector>#</a></h3><p>دیگر انتزاع مهم در Go، جمع‌آوری زباله (Garbage Collector) است. در زبان‌هایی مانند C، برنامه‌نویس باید به صورت دستی تخصیص و آزادسازی حافظه را با استفاده از <code>malloc()</code> و <code>free()</code> مدیریت کند. این رویکرد کنترل خوبی ارائه می‌دهد، اما در عمل بسیار مستعد خطا است. یک جمع‌آوری‌کننده زباله (GC) می‌تواند این بار را کاهش دهد، اما مدیریت خودکار حافظه ممکن است به راحتی به یک گلوگاه عملکرد تبدیل شود. این بخش از راهنما یک مدل ساده برای GC در Go ارائه می‌دهد که برای شناسایی و بهینه‌سازی مشکلات مربوط به مدیریت حافظه مفید خواهد بود.</p><p>برای یک راهنمای جامع‌تر درباره GC در Go، به <a href=https://go.dev/doc/gc-guide>مستندات رسمی</a> مراجعه کنید.</p><h4 id=425121-پشته-stack>4.25.1.2.1 پشته (Stack)
<a class=anchor href=#425121-%d9%be%d8%b4%d8%aa%d9%87-stack>#</a></h4><p>با اصول اولیه شروع کنیم. Go می‌تواند حافظه را در یکی از دو مکان تخصیص دهد: پشته یا هیپ. هر goroutine پشته خاص خود را دارد که یک ناحیه پیوسته از حافظه است. علاوه بر این، یک ناحیه بزرگ از حافظه وجود دارد که بین goroutineها به اشتراک گذاشته می‌شود و به آن <span class=tooltip data-tooltip=heap ontouchend=toggleTooltip(this)>هیپ</span>
می‌گویند. این حالت را می‌توان در تصویر زیر مشاهده کرد.</p><center><a href=#><img src=../../assets/img/content/chapter4/profiling/5.png alt="sample heap"></a></center><p>وقتی یک تابع تابع دیگری را فراخوانی می‌کند، یک بخش مخصوص روی پشته به آن اختصاص داده می‌شود که به آن «فریم پشته» (stack frame) می‌گویند و می‌تواند برای قرار دادن متغیرهای محلی از آن استفاده کند. یک اشاره‌گر پشته (stack pointer) برای شناسایی محل آزاد بعدی در فریم استفاده می‌شود. زمانی که یک تابع به پایان می‌رسد، داده‌های فریم قبلی به سادگی با بازگرداندن اشاره‌گر پشته به انتهای فریم قبلی حذف می‌شوند. داده‌های فریم همچنان می‌توانند در پشته باقی بمانند و با فراخوانی بعدی تابع بازنویسی شوند. این فرآیند بسیار ساده و کارآمد است زیرا Go نیازی به پیگیری هر متغیر ندارد.</p><pre><code class=language-go>func main() {
	sum := 0
	sum = add(23, 42)
	fmt.Println(sum)
}

func add(a, b int) int {
	return a + b
}
</code></pre><p><strong>برای درک بهتر این موضوع، به مثال زیر توجه کنید:</strong></p><p>در اینجا یک تابع <code>main()</code> داریم که با رزرو مقداری فضا روی پشته برای متغیر <code>sum</code> شروع می‌شود. وقتی تابع <code>add()</code> فراخوانی می‌شود، یک فریم مخصوص برای نگه داشتن پارامترهای محلی <code>a</code> و <code>b</code> به آن اختصاص داده می‌شود. پس از اتمام اجرای <code>add()</code>، داده‌های آن با بازگرداندن اشاره‌گر پشته به انتهای فریم تابع <code>main()</code> حذف می‌شوند و متغیر <code>sum</code> با نتیجه به‌روز می‌شود. در همین حال، مقادیر قدیمی تابع <code>add()</code> فراتر از اشاره‌گر پشته باقی می‌مانند تا با فراخوانی بعدی تابع بازنویسی شوند. در زیر یک تصویرسازی از این فرآیند آمده است:</p><center><a href=#><img src=../../assets/img/content/chapter4/profiling/6.gif alt=stack></a></center><p>مثال بالا به شدت ساده شده است و بسیاری از جزئیات مانند مقادیر بازگشتی، اشاره‌گرهای فریم، آدرس‌های بازگشت و درون‌خطی‌سازی (inlining) توابع را حذف کرده است. در واقع، از نسخه Go 1.17 به بعد، ممکن است برنامه بالا نیازی به فضای پشته نداشته باشد، زیرا مقدار کم داده می‌تواند توسط کامپایلر با استفاده از ثبات‌های پردازنده (CPU registers) مدیریت شود. اما این مسئله مشکلی ایجاد نمی‌کند. این مدل همچنان به شما یک شهود معقول از نحوه تخصیص و حذف متغیرهای محلی در برنامه‌های پیچیده‌تر Go روی پشته می‌دهد.</p><p>شاید در این مرحله این سوال برای شما پیش بیاید که چه اتفاقی می‌افتد اگر فضای پشته تمام شود. در زبان‌هایی مانند C، این موضوع باعث خطای سرریز پشته (stack overflow) می‌شود. اما در Go، این مشکل به صورت خودکار با ایجاد یک نسخه کپی از پشته که دو برابر بزرگتر است، مدیریت می‌شود. این قابلیت به goroutineها اجازه می‌دهد که با پشته‌های بسیار کوچک، معمولاً 2 کیلوبایت، شروع کنند و یکی از عوامل اصلی مقیاس‌پذیری بیشتر goroutineها نسبت به نخ‌های سیستم‌عامل همین موضوع است.</p><h4 id=425122-هیپ-heap>4.25.1.2.2 هیپ (Heap)
<a class=anchor href=#425122-%d9%87%db%8c%d9%be-heap>#</a></h4><p>تخصیص‌های پشته عالی هستند، اما در بسیاری از موارد Go نمی‌تواند از آن‌ها استفاده کند. رایج‌ترین حالت زمانی است که باید اشاره‌گری به یک متغیر محلی از یک تابع بازگردانده شود. این موضوع را می‌توان در نسخه اصلاح‌شده مثال تابع <code>add()</code> که در بالا آمد، مشاهده کرد:</p><pre><code class=language-go>func main() {
	fmt.Println(*add(23, 42))
}

func add(a, b int) *int {
	sum := a + b
	return &amp;sum
}
</code></pre><p>در حالت عادی، Go می‌تواند متغیر <code>sum</code> را داخل تابع <code>add()</code> روی پشته تخصیص دهد. اما همانطور که یاد گرفتیم، این داده‌ها هنگام بازگشت تابع <code>add()</code> از بین می‌روند. بنابراین، برای بازگرداندن ایمن یک اشاره‌گر به <code>&amp;sum</code>، Go باید حافظه را از خارج از پشته تخصیص دهد. اینجا است که هیپ وارد عمل می‌شود.</p><p><strong>هیپ</strong> برای ذخیره‌سازی داده‌هایی استفاده می‌شود که ممکن است پس از پایان اجرای تابع سازنده، همچنان مورد نیاز باشند، همچنین برای هر داده‌ای که بین goroutineها با استفاده از اشاره‌گرها به اشتراک گذاشته می‌شود. اما این سوال پیش می‌آید که چگونه این حافظه آزاد می‌شود؟ چون برخلاف تخصیص‌های پشته، تخصیص‌های هیپ را نمی‌توان به محض اتمام تابعی که آن‌ها را ایجاد کرده، حذف کرد.</p><p>Go این مشکل را با استفاده از جمع‌آوری زباله داخلی (GC) خود حل می‌کند. جزئیات پیاده‌سازی آن بسیار پیچیده است، اما از یک دید کلی، GC حافظه شما را به این شکل مدیریت می‌کند. در تصویر زیر می‌بینید که سه goroutine دارای اشاره‌گرهایی به تخصیص‌های سبز رنگ روی هیپ هستند. برخی از این تخصیص‌ها همچنین به تخصیص‌های سبز دیگری اشاره می‌کنند. علاوه بر این، تخصیص‌های خاکستری وجود دارند که ممکن است به تخصیص‌های سبز یا یکدیگر اشاره کنند، اما خودشان توسط تخصیص‌های سبز مرجع نشده‌اند. این تخصیص‌ها زمانی قابل دسترس بودند، اما اکنون به عنوان زباله در نظر گرفته می‌شوند. این اتفاق ممکن است زمانی رخ دهد که تابعی که اشاره‌گرهای آن‌ها را روی پشته ایجاد کرده بود بازگردد، یا مقدارشان بازنویسی شده باشد. وظیفه GC این است که به صورت خودکار این تخصیص‌ها را شناسایی و آزاد کند.</p><center><a href=#><img src=../../assets/img/content/chapter4/profiling/7.gif alt="heap gc"></a></center><p>اجرای جمع‌آوری زباله (GC) شامل پیمایش گراف‌های پرهزینه و تخلیه کش (cache thrashing) است. این فرایند حتی نیاز به فازهای متوقف‌کننده کل جهان (stop-the-world) دارد که اجرای کل برنامه شما را متوقف می‌کند. خوشبختانه نسخه‌های اخیر Go این زمان را به کسری از یک میلی‌ثانیه کاهش داده‌اند، اما بسیاری از هزینه‌های باقی‌مانده ذاتاً به هر GC مربوط می‌شود. در واقع، معمولاً ۲۰ تا ۳۰ درصد از اجرای یک برنامه Go صرف مدیریت حافظه می‌شود.</p><p>به‌طور کلی، هزینه GC متناسب با مقدار تخصیص‌های هیپ (heap allocations) است که برنامه شما انجام می‌دهد. بنابراین وقتی صحبت از بهینه‌سازی هزینه‌های مرتبط با حافظه می‌شود، شعار این است:</p><ul><li><strong>کاهش (Reduce)</strong>: سعی کنید تخصیص‌های هیپ را به تخصیص‌های پشته تبدیل کنید یا از آن‌ها به‌طور کلی اجتناب کنید. کاهش تعداد اشاره‌گرها در هیپ نیز کمک می‌کند.</li><li><strong>بازاستفاده (Reuse)</strong>: تخصیص‌های هیپ را دوباره استفاده کنید به جای اینکه آن‌ها را با تخصیص‌های جدید جایگزین کنید.</li><li><strong>بازیافت (Recycle)</strong>: برخی از تخصیص‌های هیپ غیرقابل اجتناب هستند. بگذارید GC آن‌ها را بازیافت کند و بر روی مسائل دیگر تمرکز کنید.</li></ul><p>همانند مدل ذهنی قبلی در این راهنما، همه موارد بالا نمایی به شدت ساده شده از واقعیت است. اما امیدوارم که این مدل به اندازه کافی مفید باشد تا باقی‌مانده این راهنما را درک کنید و شما را به مطالعه مقالات بیشتری در این زمینه ترغیب کند.</p><h2 id=4252-درک-عمیق-پروفایلرهای-profilers-گو>4.25.2 درک عمیق پروفایلرهای (Profilers) گو
<a class=anchor href=#4252-%d8%af%d8%b1%da%a9-%d8%b9%d9%85%db%8c%d9%82-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1%d9%87%d8%a7%db%8c-profilers-%da%af%d9%88>#</a></h2><p>در اینجا مروری بر <span class=tooltip data-tooltip=profilers ontouchend=toggleTooltip(this)>پروفایلرهای</span>
ساخته‌شده در زمان اجرای Go (Go runtime) ارائه می‌شود. برای جزئیات بیشتر، به لینک‌ها مراجعه کنید.</p><p>در زیر جدول مربوط به پروفایلرهای مختلف موجود در Go ارائه شده است:</p><table><thead><tr><th>ویژگی</th><th><a href=#42521-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-cpu>CPU</a></th><th><a href=#42522-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-%d8%ad%d8%a7%d9%81%d8%b8%d9%87-memory>Memory</a></th><th><a href=#42523-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-%d8%a8%d9%84%d8%a7%da%a9>Block</a></th><th><a href=#42524-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-mutex>Mutex</a></th><th><a href=#42525-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-goroutine>Goroutine</a></th><th><a href=#42526-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-threadcreate>ThreadCreate</a></th></tr></thead><tbody><tr><td>Production Safety</td><td>✅</td><td>✅</td><td>⚠ (1.)</td><td>✅</td><td>⚠️ (2.)</td><td>🐞 (3.)</td></tr><tr><td><span class=tooltip data-tooltip="Safe Rate" ontouchend=toggleTooltip(this)>نرخ ایمنی</span></td><td>default</td><td>default</td><td>❌ (1.)</td><td><code>100</code></td><td><code>1000</code> goroutines</td><td>-</td></tr><tr><td><span class=tooltip data-tooltip=Accuracy ontouchend=toggleTooltip(this)>دقت</span></td><td>⭐️⭐️</td><td>⭐⭐⭐</td><td>⭐⭐⭐</td><td>⭐⭐⭐</td><td>⭐⭐⭐</td><td>-</td></tr><tr><td><span class=tooltip data-tooltip="Max Stack Depth" ontouchend=toggleTooltip(this)>عمق حداکثر پشته</span></td><td><code>64</code></td><td><code>32</code></td><td><code>32</code></td><td><code>32</code></td><td><code>32</code> - <code>100</code> (4.)</td><td>-</td></tr><tr><td><span class=tooltip data-tooltip="Profiler Labels" ontouchend=toggleTooltip(this)>برچسب‌های پروفایلر</span></td><td>✅</td><td>❌</td><td>❌</td><td>❌</td><td>✅</td><td>-</td></tr></tbody></table><ol><li><strong>پروفایلر بلوک</strong> (block profiler): اگر به درستی پیکربندی نشده باشد، پروفایلر بلوک می‌تواند منبع قابل توجهی از بار CPU باشد.</li><li><strong>توقف‌های جهانی</strong> (stop-the-world): یک توقف جهانی<code>O(N)</code> وجود دارد که N تعداد goroutineها است. انتظار می‌رود هر goroutine بین <code>~1-10</code> میکروثانیه توقف داشته باشد.</li><li><strong>پروفایلر ThreadCreate</strong>: این پروفایلر به طور کامل معیوب است و بهتر است از آن استفاده نکنید.</li><li><strong>عمق حداکثر پشته</strong>: این مورد به API وابسته است.</li></ol><h3 id=42521-پروفایلر-cpu>4.25.2.1 پروفایلر CPU
<a class=anchor href=#42521-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-cpu>#</a></h3><p>پروفایلر CPU در Go می‌تواند به شما کمک کند تا قسمت‌هایی از کد خود را که زمان CPU زیادی مصرف می‌کنند، شناسایی کنید.</p><p>⚠️ توجه داشته باشید که زمان CPU معمولاً با زمان واقعی که کاربران شما تجربه می‌کنند (که به آن تاخیر می‌گویند) متفاوت است. به عنوان مثال، یک درخواست HTTP معمولاً ممکن است ۱۰۰ میلی‌ثانیه طول بکشد، اما تنها ۵ میلی‌ثانیه از زمان CPU را مصرف کند و ۹۵ میلی‌ثانیه را در انتظار پاسخ از پایگاه داده بگذراند. همچنین ممکن است یک درخواست ۱۰۰ میلی‌ثانیه طول بکشد، اما ۲۰۰ میلی‌ثانیه از زمان CPU را صرف کند اگر دو goroutine به طور همزمان کارهای پردازشی سنگین انجام دهند. اگر این موضوع برای شما گیج‌کننده است.</p><p>شما می‌توانید پروفایلر CPU را از طریق APIهای مختلف کنترل کنید:</p><ul><li><p><code>go test -cpuprofile cpu.pprof</code>: این دستور تست‌های شما را اجرا کرده و پروفایل CPU را در فایلی به نام <strong>cpu.pprof</strong> می‌نویسد.</p></li><li><p><code>pprof.StartCPUProfile(w)</code>: این دستور پروفایل CPU را به <strong>w</strong> ضبط می‌کند و زمان را تا زمانی که <code>pprof.StopCPUProfile()</code> فراخوانی شود، پوشش می‌دهد.</p></li><li><p><code>import _ "net/http/pprof"</code>: این کد به شما اجازه می‌دهد با درخواست GET به آدرس <code>/debug/pprof/profile?seconds=30</code> از سرور HTTP پیش‌فرض که می‌توانید با استفاده از <code>http.ListenAndServe("localhost:6060", nil)</code> راه‌اندازی کنید، یک پروفایل CPU به مدت ۳۰ ثانیه درخواست کنید.</p></li><li><p><code>runtime.SetCPUProfileRate()</code>: این تابع به شما اجازه می‌دهد نرخ نمونه‌گیری پروفایلر CPU را کنترل کنید. برای محدودیت‌های فعلی به <strong>محدودیت‌های پروفایلر CPU</strong> مراجعه کنید.</p></li><li><p><code>runtime.SetCgoTraceback()</code>: این تابع می‌تواند برای دریافت ردیابی‌های پشته به کد cgo استفاده شود. <code>benesch/cgosymbolizer</code> یک پیاده‌سازی برای Linux و macOS دارد.</p></li></ul><p>اگر به یک قطعه کد سریع نیاز دارید که بتوانید در تابع <strong>main()</strong> خود قرار دهید، می‌توانید از کد زیر استفاده کنید:</p><pre><code class=language-go>file, _ := os.Create(&quot;./cpu.pprof&quot;)
pprof.StartCPUProfile(file)
defer pprof.StopCPUProfile()
</code></pre><p>صرف نظر از اینکه چگونه پروفایلر CPU را فعال می‌کنید، پروفایل به‌دست‌آمده در اصل یک جدول از ردیابی‌های پشته است که به فرمت باینری <strong>pprof</strong> قالب‌بندی شده است. در زیر نسخه‌ای ساده‌شده از چنین جدولی نشان داده شده است:</p><table><thead><tr><th>stack trace</th><th>samples/count</th><th>cpu/nanoseconds</th></tr></thead><tbody><tr><td>main;foo</td><td>5</td><td>50000000</td></tr><tr><td>main;foo;bar</td><td>3</td><td>30000000</td></tr><tr><td>main;foobar</td><td>4</td><td>40000000</td></tr></tbody></table><p>پروفایلر CPU این داده‌ها را با درخواست از سیستم‌عامل برای نظارت بر استفاده از CPU برنامه جمع‌آوری می‌کند و هر ۱۰ میلی‌ثانیه که CPU زمانی را مصرف می‌کند، سیگنال <strong>SIGPROF</strong> را به آن ارسال می‌کند. همچنین سیستم‌عامل زمان صرف‌شده توسط کرنل به نمایندگی از برنامه را در این نظارت شامل می‌کند. از آنجا که نرخ تحویل سیگنال به مصرف CPU وابسته است، این نرخ دینامیک بوده و می‌تواند به حداکثر <strong>N * 100Hz</strong> برسد که در آن <strong>N</strong> تعداد هسته‌های منطقی CPU در سیستم است.</p><p>هنگامی که سیگنال <strong>SIGPROF</strong> دریافت می‌شود، هندلر سیگنال Go یک ردیابی پشته از goroutine فعالی که در حال حاضر در حال اجرا است، جمع‌آوری می‌کند و مقادیر مربوطه در پروفایل را افزایش می‌دهد. مقدار <strong>cpu/nanoseconds</strong> در حال حاضر مستقیماً از تعداد نمونه‌ها مشتق می‌شود، بنابراین این مقدار تکراری است، اما راحت است.</p><h4 id=425211-برچسبهای-پروفایلر-profiler-labels-cpu>4.25.2.1.1 برچسب‌های پروفایلر (Profiler Labels) CPU
<a class=anchor href=#425211-%d8%a8%d8%b1%da%86%d8%b3%d8%a8%d9%87%d8%a7%db%8c-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-profiler-labels-cpu>#</a></h4><p>یکی از ویژگی‌های جالب پروفایلر CPU در Go این است که می‌توانید جفت‌های کلید و مقدار دلخواهی را به یک goroutine متصل کنید. این برچسب‌ها توسط هر goroutine‌ای که از آن goroutine متولد می‌شود، به ارث برده می‌شوند و در پروفایل نهایی نمایش داده می‌شوند.</p><p>بیایید مثالی را در نظر بگیریم که برخی از کارهای CPU را به نمایندگی از یک کاربر انجام می‌دهد. با استفاده از API های <code>pprof.Labels()</code> و <code>pprof.Do()</code>، می‌توانیم کاربر را با goroutine که در حال اجرای تابع <code>work()</code> است، مرتبط کنیم. علاوه بر این، برچسب‌ها به‌طور خودکار توسط هر goroutine‌ای که در همان بلوک کد متولد می‌شود، به ارث برده می‌شوند، برای مثال <code>goroutine backgroundWork()</code>.</p><pre><code class=language-go>func work(ctx context.Context, user string) {
	labels := pprof.Labels(&quot;user&quot;, user)
	pprof.Do(ctx, labels, func(_ context.Context) {
		go backgroundWork()
		directWork()
	})
}
</code></pre><p>پروفایل نهایی شامل یک ستون برچسب جدید خواهد بود و ممکن است به شکل زیر باشد:</p><table><thead><tr><th>stack trace</th><th>label</th><th>samples/count</th><th>cpu/nanoseconds</th></tr></thead><tbody><tr><td>main.backgroundWork</td><td>user:bob</td><td>5</td><td>50000000</td></tr><tr><td>main.backgroundWork</td><td>user:alice</td><td>2</td><td>20000000</td></tr><tr><td>main.work;main.directWork</td><td>user:bob</td><td>4</td><td>40000000</td></tr><tr><td>main.work;main.directWork</td><td>user:alice</td><td>3</td><td>30000000</td></tr></tbody></table><p>مشاهده همان پروفایل با نمای گراف pprof نیز شامل برچسب‌ها خواهد بود:</p><center><a href=#><img src=../../assets/img/content/chapter4/profiling/8.png alt="cpu profiler labels"></a></center><p>چگونگی استفاده از این برچسب‌ها به شما بستگی دارد. می‌توانید مواردی مانند شناسه‌های کاربری، شناسه‌های درخواست، نقاط پایانی HTTP، برنامه‌های اشتراک یا داده‌های دیگر را شامل کنید که به شما کمک می‌کند درک بهتری از اینکه کدام نوع درخواست‌ها باعث مصرف بالای CPU می‌شوند، حتی زمانی که توسط همان مسیرهای کد پردازش می‌شوند، به دست آورید. با این حال، استفاده از برچسب‌ها اندازه فایل‌های pprof شما را افزایش می‌دهد. بنابراین بهتر است با برچسب‌های با کاردینالیته پایین مانند نقاط پایانی شروع کنید و سپس به برچسب‌های با کاردینالیته بالا بروید، زمانی که احساس می‌کنید بر عملکرد برنامه شما تأثیر نمی‌گذارد.</p><p>⚠️ نسخه‌های Go 1.17 و پایین‌تر حاوی چندین اشکال بودند که می‌توانستند منجر به عدم وجود برخی برچسب‌های پروفایلر در پروفایل‌های CPU شوند، برای اطلاعات بیشتر به محدودیت‌های پروفایلر CPU مراجعه کنید.</p><h4 id=425212-مصرف-cpu>4.25.2.1.2 مصرف CPU
<a class=anchor href=#425212-%d9%85%d8%b5%d8%b1%d9%81-cpu>#</a></h4><p>از آنجایی که نرخ نمونه‌گیری پروفایلر CPU با توجه به مقدار CPU که برنامه شما مصرف می‌کند، تنظیم می‌شود، می‌توانید مصرف CPU را از پروفایل‌های CPU استخراج کنید. در واقع، pprof این کار را به طور خودکار برای شما انجام می‌دهد. به عنوان مثال، پروفایل زیر از برنامه‌ای استخراج شده است که دارای میانگین مصرف CPU برابر با 147.77% بود:</p><pre><code class=language-shell>$ go tool pprof guide/cpu-utilization.pprof
Type: cpu
Time: Sep 9, 2021 at 11:34pm (CEST)
Duration: 1.12s, Total samples = 1.65s (147.77%)
Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)
(pprof) 
</code></pre><p>روش دیگری که برای بیان مصرف CPU محبوب است، استفاده از هسته‌های CPU است. در مثال بالا، برنامه به‌طور میانگین از 1.47 هسته CPU در طول دوره پروفایل‌سازی استفاده می‌کرد.</p><p>⚠️ در نسخه‌های Go 1.17 و پایین‌تر، نباید به این عدد به خصوص اگر نزدیک یا بیشتر از 250% باشد، اعتماد زیادی داشته باشید. با این حال، اگر عدد بسیار پایینی مانند 10% مشاهده کردید، معمولاً نشان‌دهنده این است که مصرف CPU برای برنامه شما مشکلی نیست. یک اشتباه رایج این است که به این عدد توجه نکرده و نگران یک تابع خاص باشید که زمان زیادی نسبت به بقیه پروفایل صرف می‌کند. این معمولاً وقت تلف کردن است، زمانی که مصرف کلی CPU پایین است، زیرا از بهینه‌سازی این تابع چندان سودی نخواهید برد.</p><h4 id=425213-فراخوانیهای-سیستم-در-پروفایلهای-cpu>4.25.2.1.3 فراخوانی‌های سیستم در پروفایل‌های CPU
<a class=anchor href=#425213-%d9%81%d8%b1%d8%a7%d8%ae%d9%88%d8%a7%d9%86%db%8c%d9%87%d8%a7%db%8c-%d8%b3%db%8c%d8%b3%d8%aa%d9%85-%d8%af%d8%b1-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d9%87%d8%a7%db%8c-cpu>#</a></h4><p>اگر در پروفایل‌های CPU خود فراخوانی‌های سیستمی مانند <code>syscall.Read()</code> یا <code>syscall.Write()</code> را مشاهده کردید که زمان زیادی را صرف می‌کنند، لطفاً توجه داشته باشید که این فقط زمان CPU صرف شده در داخل این توابع در هسته است. زمان I/O خود به‌طور جداگانه پیگیری نمی‌شود. صرف زمان زیادی در فراخوانی‌های سیستمی معمولاً نشانه‌ای از انجام بیش از حد آن‌ها است، بنابراین شاید افزایش اندازه بافرها بتواند کمک کند. برای موقعیت‌های پیچیده‌تر مانند این، باید استفاده از Linux perf را در نظر بگیرید، زیرا می‌تواند stack trace های هسته را نیز به شما نشان دهد که ممکن است سرنخ‌های اضافی برای شما فراهم کند.</p><h4 id=425214-محدودیتهای-پروفایلر-cpu>4.25.2.1.4 محدودیت‌های پروفایلر CPU
<a class=anchor href=#425214-%d9%85%d8%ad%d8%af%d9%88%d8%af%db%8c%d8%aa%d9%87%d8%a7%db%8c-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-cpu>#</a></h4><p>چندین مشکل و محدودیت شناخته‌شده برای پروفایلر CPU وجود دارد که ممکن است بخواهید از آن‌ها آگاه باشید:</p><ul><li><p>🐞 <a href=https://github.com/golang/go/issues/35057><strong>GH #35057</strong></a>: پروفایل‌های CPU که با نسخه‌های Go &lt;= 1.17 گرفته شده‌اند، به‌طور نسبی برای برنامه‌هایی که از بیش از 2.5 هسته CPU استفاده می‌کنند، دقت کمتری دارند. به‌طور کلی، استفاده کلی از CPU به‌طور نادرست گزارش می‌شود و پیک‌های بارکاری ممکن است به‌درستی در پروفایل حاصل نمایان نشوند. این مشکل در Go 1.18 برطرف شده است. در عین حال، می‌توانید از Linux perf به‌عنوان یک راه‌حل موقت استفاده کنید.</p></li><li><p>🐞 <strong>برچسب‌های پروفایلر در Go &lt;= 1.17</strong> از چندین باگ رنج می‌بردند.</p><ul><li><a href=https://github.com/golang/go/issues/48577><strong>GH #48577</strong></a> و <a href=https://go-review.googlesource.com/c/go/+/367200/><strong>CL 367200</strong></a>: برچسب‌ها برای goroutineهایی که بر روی استک سیستم، کد C را اجرا می‌کنند یا فراخوانی‌های سیستمی را انجام می‌دهند، گم شده بودند.</li><li><a href=https://go-review.googlesource.com/c/go/+/369741><strong>CL 369741</strong></a>: اولین دسته از نمونه‌ها در یک پروفایل CPU دارای خطای off-by-one بودند که باعث نسبت‌گذاری نادرست برچسب‌ها می‌شد.</li><li><a href=https://go-review.googlesource.com/c/go/+/369983><strong>CL 369983</strong></a>: سیستم goroutineهایی که به نمایندگی از goroutineهای کاربر ایجاد شده‌اند (مثلاً برای جمع‌آوری زباله) به‌طور نادرست برچسب‌های والدین خود را به ارث بردند.</li></ul></li><li><p>⚠️️ می‌توانید از <a href=https://pkg.go.dev/runtime#SetCPUProfileRate><code>runtime.SetCPUProfileRate()</code></a> برای تنظیم نرخ پروفایلر CPU قبل از فراخوانی <code>runtime.StartCPUProfile()</code> استفاده کنید. این عمل یک هشدار را چاپ می‌کند که می‌گوید <code>runtime: cannot set cpu profile rate until previous profile has finished</code>. با این حال، این عمل هنوز در چارچوب محدودیت‌های باگ ذکر شده عمل می‌کند. این مسئله ابتدا در <a href=https://github.com/golang/go/issues/40094>اینجا</a> مطرح شد و یک <a href=https://github.com/golang/go/issues/42502>پیشنهاد</a> پذیرفته شده برای بهبود API وجود دارد.</p></li><li><p>⚠️ حداکثر تعداد فراخوانی‌های تو در توی تابعی که می‌تواند در stack trace ها توسط پروفایلر CPU ضبط شود، در حال حاضر <a href="https://sourcegraph.com/search?q=context:global+repo:github.com/golang/go+file:src/*+maxCPUProfStack+%3D&amp;patternType=literal">64</a> است. اگر برنامه شما از الگوهایی مانند بازگشت عمیق یا دیگر الگوهایی استفاده کند که به عمق استک بالایی منجر می‌شود، پروفایل CPU شما شامل stack trace هایی خواهد بود که برش داده شده‌اند. این به این معناست که شما بخشی از زنجیرهٔ فراخوانی که به تابعی که در زمان نمونه‌برداری فعال بود، منجر شده، را از دست خواهید داد.</p></li></ul><h3 id=42522-پروفایلر-حافظه-memory>4.25.2.2 پروفایلر حافظه (Memory)
<a class=anchor href=#42522-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-%d8%ad%d8%a7%d9%81%d8%b8%d9%87-memory>#</a></h3><p>پروفایلر حافظه در Go می‌تواند به شما کمک کند تا شناسایی کنید کدام بخش‌های کد شما دارای تعداد زیادی تخصیصات حافظه در هیپ (heap) هستند و همچنین چند تا از این تخصیصات در آخرین جمع‌آوری زباله (garbage collection) هنوز در دسترس بودند. به همین دلیل، پروفایل تولید شده توسط پروفایلر حافظه معمولاً به‌عنوان پروفایل هیپ نیز شناخته می‌شود.</p><p>مدیریت حافظه هیپ معمولاً مسئول حدود 20-30% از زمان CPU مصرفی توسط فرآیندهای Go است. علاوه بر این، حذف تخصیصات هیپ می‌تواند تأثیرات ثانویه‌ای داشته باشد که بخش‌های دیگر کد شما را به‌دلیل کاهش مقدار هدر رفت کش (cache thrashing) که در هنگام اسکن هیپ توسط جمع‌آورنده زباله (garbage collector) رخ می‌دهد، سریع‌تر می‌کند. به این معنی که بهینه‌سازی تخصیص‌های حافظه می‌تواند معمولاً بازگشت بهتری نسبت به بهینه‌سازی مسیرهای کد وابسته به CPU در برنامه شما داشته باشد.</p><p>⚠️ پروفایلر حافظه تخصیصات استک را نشان نمی‌دهد زیرا این‌ها به‌طور کلی بسیار ارزان‌تر از تخصیصات هیپ هستند. برای اطلاعات بیشتر به بخش جمع‌آورنده زباله مراجعه کنید.</p><p>شما می‌توانید پروفایلر حافظه را از طریق API های مختلف کنترل کنید:</p><ul><li><code>go test -memprofile mem.pprof</code> تست‌های شما را اجرا می‌کند و پروفایل حافظه را در فایلی به نام <code>mem.pprof</code> می‌نویسد.</li><li><code>pprof.Lookup("allocs").WriteTo(w, 0)</code> پروفایل حافظه‌ای که شامل رویدادهای تخصیص از زمان شروع فرآیند است را به <code>w</code> می‌نویسد.</li><li><code>import _ "net/http/pprof"</code> به شما امکان می‌دهد که یک پروفایل حافظه 30 ثانیه‌ای با فراخوانی <code>GET /debug/pprof/allocs?seconds=30</code> از سرور HTTP پیش‌فرض که می‌توانید با <code>http.ListenAndServe("localhost:6060", nil)</code> راه‌اندازی کنید، درخواست کنید. این پروفایل به‌طور داخلی به عنوان پروفایل دلتا (delta profile) شناخته می‌شود.</li><li><code>runtime.MemProfileRate</code> به شما اجازه می‌دهد تا نرخ نمونه‌برداری پروفایلر حافظه را کنترل کنید. برای محدودیت‌های کنونی به <strong>محدودیت‌های پروفایلر حافظه</strong> مراجعه کنید.</li></ul><p>اگر به یک قطعه کد سریع نیاز دارید که بتوانید آن را به تابع <code>main()</code> خود اضافه کنید، می‌توانید از کد زیر استفاده کنید:</p><pre><code class=language-go>file, _ := os.Create(&quot;./mem.pprof&quot;)
defer pprof.Lookup(&quot;allocs&quot;).WriteTo(file, 0)
defer runtime.GC()
</code></pre><p>صرف نظر از اینکه چگونه پروفایلر حافظه را فعال کنید، پروفایل حاصل اساساً یک جدول از ردیابی‌های پشته است که به فرمت باینری pprof فرمت‌بندی شده است. نسخه‌ای ساده‌شده از چنین جدولی در زیر نشان داده شده است:</p><table><thead><tr><th>stack trace</th><th>alloc_objects/count</th><th>alloc_space/bytes</th><th>inuse_objects/count</th><th>inuse_space/bytes</th></tr></thead><tbody><tr><td>main;foo</td><td>5</td><td>120</td><td>2</td><td>48</td></tr><tr><td>main;foo;bar</td><td>3</td><td>768</td><td>0</td><td>0</td></tr><tr><td>main;foobar</td><td>4</td><td>512</td><td>1</td><td>128</td></tr></tbody></table><p>یک پروفایل حافظه شامل دو بخش اصلی اطلاعات است:</p><ul><li><code>alloc_*</code>: مقدار تخصیص‌هایی که برنامه شما از زمان شروع فرایند (یا دوره پروفایل‌گیری برای پروفایل‌های دلتا) انجام داده است.</li><li><code>inuse_*</code>: مقدار تخصیص‌هایی که برنامه شما انجام داده و در آخرین جمع‌آوری زباله (GC) همچنان قابل دسترسی بودند.</li></ul><p>شما می‌توانید از این اطلاعات برای مقاصد مختلف استفاده کنید. به عنوان مثال، می‌توانید از داده‌های <code>alloc_*</code> برای تعیین اینکه کدام مسیرهای کد ممکن است زباله زیادی تولید کنند که GC باید با آن برخورد کند، استفاده کنید. همچنین بررسی داده‌های <code>inuse_*</code> در طول زمان می‌تواند به شما در بررسی نشت حافظه یا استفاده بالای حافظه توسط برنامه‌تان کمک کند.</p><h4 id=425221-تفاوت-پروفایلهای-allocations-و-heap>4.25.2.2.1 تفاوت پروفایل‌های Allocations و Heap
<a class=anchor href=#425221-%d8%aa%d9%81%d8%a7%d9%88%d8%aa-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d9%87%d8%a7%db%8c-allocations-%d9%88-heap>#</a></h4><p>تابع <code>pprof.Lookup()</code> و همچنین بسته <code>[net/http/pprof](https://pkg.go.dev/net/http/pprof)</code> پروفایل حافظه را تحت دو نام مختلف عرضه می‌کنند: <code>allocs</code> و <code>heap</code>. هر دو پروفایل شامل داده‌های یکسانی هستند، تنها تفاوت این است که پروفایل <code>allocs</code> به عنوان نوع نمونه پیش‌فرض <code>alloc_space/bytes</code> را دارد، در حالی که پروفایل <code>heap</code> به طور پیش‌فرض <code>inuse_space/bytes</code> را انتخاب می‌کند. این موضوع توسط ابزار <code>pprof</code> برای تصمیم‌گیری درباره نوع نمونه‌ای که باید به طور پیش‌فرض نشان داده شود، استفاده می‌شود.</p><h4 id=425222-نمونهبرداری-sampling-پروفایل-حافظه>4.25.2.2.2 نمونه‌برداری (Sampling) پروفایل حافظه
<a class=anchor href=#425222-%d9%86%d9%85%d9%88%d9%86%d9%87%d8%a8%d8%b1%d8%af%d8%a7%d8%b1%db%8c-sampling-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84-%d8%ad%d8%a7%d9%81%d8%b8%d9%87>#</a></h4><p>برای حفظ بار کم، پروفایل حافظه از نمونه‌برداری پواسون استفاده می‌کند تا به طور متوسط فقط یک تخصیص از هر 512KiB باعث شود که یک ردیابی پشته گرفته شده و به پروفایل اضافه شود. با این حال، قبل از اینکه پروفایل به فایل نهایی <code>pprof</code> نوشته شود، زمان‌اجرا مقادیر نمونه جمع‌آوری شده را با تقسیم بر احتمال نمونه‌برداری مقیاس می‌دهد. این بدان معناست که مقدار تخصیص‌های گزارش شده باید تخمینی خوب از مقدار واقعی تخصیص‌ها باشد، صرف‌نظر از نرخ <code>runtime.MemProfileRate</code> که استفاده می‌کنید.</p><p>برای پروفایل‌گیری در محیط تولید، معمولاً نیازی به تغییر نرخ نمونه‌برداری نیست. تنها دلیلی که برای این کار وجود دارد، نگرانی درباره این است که در شرایطی که تخصیص‌های بسیار کمی انجام می‌شود، ممکن است تعداد کافی نمونه‌ها جمع‌آوری نشود.</p><h4 id=425223-memory-inuse-در-مقابل-rss>4.25.2.2.3 Memory Inuse در مقابل RSS
<a class=anchor href=#425223-memory-inuse-%d8%af%d8%b1-%d9%85%d9%82%d8%a7%d8%a8%d9%84-rss>#</a></h4><p>یک اشتباه رایج این است که مقدار کل حافظه گزارش‌شده توسط نوع نمونه <code>inuse_space/bytes</code> را با مقدار استفاده از حافظه <a href=https://en.wikipedia.org/wiki/Resident_set_size>RSS</a> که توسط سیستم‌عامل گزارش می‌شود مقایسه کنید و متوجه شوید که این دو با هم مطابقت ندارند. دلایل مختلفی برای این عدم تطابق وجود دارد:</p><ul><li>به‌طور تعریف شده، RSS شامل مواردی بیشتر از فقط استفاده از حافظه پشته Go است، مانند حافظه استفاده شده توسط پشته‌های گوروتین‌ها، فایل اجرایی برنامه، کتابخانه‌های مشترک و همچنین حافظه تخصیص یافته توسط توابع C.</li><li>GC (جمع‌کننده زباله) ممکن است تصمیم بگیرد که حافظه آزاد را فوراً به سیستم‌عامل بازنگرداند، اما بعد از تغییرات زمان‌اجرا در <a href=https://golang.org/doc/go1.16#runtime>Go 1.16</a> این موضوع کمتر مشکل‌ساز شده است.</li><li>Go از GC غیرمتحرک استفاده می‌کند، بنابراین در برخی موارد، حافظه آزاد پشته ممکن است به گونه‌ای تکه‌تکه شود که مانع از بازگشت آن به سیستم‌عامل شود.</li></ul><h4 id=425224-پیادهسازی-پروفایلر-حافظه>4.25.2.2.4 پیاده‌سازی پروفایلر حافظه
<a class=anchor href=#425224-%d9%be%db%8c%d8%a7%d8%af%d9%87%d8%b3%d8%a7%d8%b2%db%8c-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-%d8%ad%d8%a7%d9%81%d8%b8%d9%87>#</a></h4><p>کد زیر باید جنبه‌های اساسی پیاده‌سازی پروفایلر حافظه را پوشش دهد تا شما درک بهتری از آن داشته باشید. همانطور که مشاهده می‌کنید، تابع <code>malloc()</code> در داخل زمان‌اجرای Go از تابع <code>poisson_sample(size)</code> برای تعیین این که آیا باید یک تخصیص نمونه‌گیری شود یا خیر استفاده می‌کند. اگر جواب مثبت باشد، یک دنباله پشته (stack trace) به نام <code>s</code> گرفته می‌شود و به عنوان کلید در <code>mem_profile</code> (یک نقشه هش) استفاده می‌شود تا شمارنده‌های <code>allocs</code> و <code>alloc_bytes</code> افزایش یابند. علاوه بر این، فراخوانی <code>track_profiled(object, s)</code>، شیء تخصیص یافته را به عنوان یک تخصیص نمونه‌گیری شده در پشته علامت‌گذاری می‌کند و دنباله پشته <code>s</code> را با آن مرتبط می‌سازد.</p><pre><code class=language-go>func malloc(size):
  object = ... // allocation magic

  if poisson_sample(size):
    s = stacktrace()
    mem_profile[s].allocs++
    mem_profile[s].alloc_bytes += size
    track_profiled(object, s)

  return object
</code></pre><p>هنگامی که GC (جمع‌آوری زباله‌ها) تعیین می‌کند که زمان آزادسازی یک شیء تخصیص یافته فرا رسیده است، تابع <code>sweep()</code> را فراخوانی می‌کند که از <code>is_profiled(object)</code> استفاده می‌کند تا بررسی کند آیا شیء به عنوان یک شیء نمونه‌گیری شده علامت‌گذاری شده است یا خیر. اگر جواب مثبت باشد، دنباله پشته <code>s</code> که منجر به تخصیص شده بود بازیابی می‌شود و شمارنده‌های <code>frees</code> و <code>free_bytes</code> برای آن داخل <code>mem_profile</code> افزایش می‌یابد.</p><pre><code class=language-go>func sweep(object):
  if is_profiled(object)
    s = alloc_stacktrace(object)
    mem_profile[s].frees++
    mem_profile[s].free_bytes += sizeof(object)

	// deallocation magic
</code></pre><p>شمارنده‌های <code>free_*</code> به‌طور مستقیم در پروفایل نهایی حافظه گنجانده نمی‌شوند. در عوض، از آن‌ها برای محاسبه شمارنده‌های <code>inuse_*</code> در پروفایل از طریق کم کردن ساده‌ی <code>frees</code> از <code>allocs</code> استفاده می‌شود. همچنین، مقادیر خروجی نهایی با تقسیم آن‌ها بر احتمال نمونه‌گیری مقیاس‌بندی می‌شوند.</p><h4 id=425225-محدودیتهای-پروفایلر-حافظه>4.25.2.2.5 محدودیت‌های پروفایلر حافظه
<a class=anchor href=#425225-%d9%85%d8%ad%d8%af%d9%88%d8%af%db%8c%d8%aa%d9%87%d8%a7%db%8c-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-%d8%ad%d8%a7%d9%81%d8%b8%d9%87>#</a></h4><p>چندین مشکل و محدودیت شناخته‌شده برای پروفایلر حافظه وجود دارد که باید از آن‌ها آگاه باشید:</p><ul><li>🐞 <a href=https://github.com/golang/go/issues/49171>GH #49171</a>: پروفایل‌های دلتا (که با مثلاً <code>GET /debug/pprof/allocs?seconds=60</code> گرفته می‌شوند) ممکن است به دلیل یک باگ در هم‌نمادسازی مرتبط با closures داخلی در Go 1.17 شمارش تخصیص منفی را گزارش کنند. این مشکل در Go 1.18 رفع شده است.</li><li>⚠️ <a href=https://pkg.go.dev/runtime#MemProfileRate><code>runtime.MemProfileRate</code></a> باید فقط یک بار و در اسرع وقت در ابتدای اجرای برنامه تغییر داده شود؛ برای مثال در ابتدای تابع <code>main()</code>. تغییر این مقدار به‌صورت چندباره در طول اجرای برنامه باعث تولید پروفایل‌های نادرست خواهد شد.</li><li>⚠ هنگام عیب‌یابی نشتی‌های حافظه احتمالی، پروفایلر حافظه می‌تواند نشان دهد که این تخصیص‌ها کجا ایجاد شده‌اند، اما نمی‌تواند نشان دهد که کدام مراجع باعث زنده نگه‌داشتن آن‌ها هستند. چندین تلاش برای حل این مشکل انجام شده است، اما هیچ‌کدام با نسخه‌های اخیر Go کار نمی‌کنند.</li><li>⚠ <a href=#425211-%d8%a8%d8%b1%da%86%d8%b3%d8%a8%d9%87%d8%a7%db%8c-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-profiler-labels-cpu>برچسب‌های پروفایلر CPU</a> یا مشابه آن توسط پروفایلر حافظه پشتیبانی نمی‌شوند. اضافه کردن این ویژگی به پیاده‌سازی فعلی سخت است زیرا می‌تواند منجر به نشتی حافظه در جدول هش داخلی داده‌های پروفایل حافظه شود.</li><li>⚠ تخصیص‌های انجام شده توسط کد C (cgo) در پروفایل حافظه نمایش داده نمی‌شوند.</li><li>⚠ داده‌های پروفایل حافظه ممکن است تا دو چرخه‌ی جمع‌آوری زباله قدیمی باشند. اگر نیاز به یک عکس فوری مداوم دارید، می‌توانید قبل از درخواست پروفایل حافظه، <code>runtime.GC()</code> را فراخوانی کنید. <a href=https://pkg.go.dev/net/http/pprof>net/http/pprof</a> از آرگومان <code>?gc=1</code> برای این منظور پشتیبانی می‌کند.</li><li>⚠ حداکثر تعداد توابع تو در تو که توسط پروفایلر حافظه در اثر فراخوانی ثبت می‌شوند، در حال حاضر <a href="https://sourcegraph.com/search?q=context:global+repo:github.com/golang/go+file:src/*+maxStack+%3D&amp;patternType=literal"><code>32</code></a> است. برای اطلاعات بیشتر در مورد این محدودیت، به <a href=#425214-%d9%85%d8%ad%d8%af%d9%88%d8%af%db%8c%d8%aa%d9%87%d8%a7%db%8c-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-cpu>محدودیت‌های پروفایلر CPU</a> مراجعه کنید.</li><li>⚠ هیچ محدودیتی برای اندازه‌ی جدول هش داخلی که پروفایل حافظه را نگه‌ می‌دارد وجود ندارد. این جدول تا زمانی که تمام مسیرهای تخصیص کد شما را پوشش دهد، بزرگ می‌شود. این مسئله در عمل مشکل‌ساز نیست اما ممکن است به‌نظر برسد که مانند یک نشتی حافظه کوچک است اگر از میزان استفاده حافظه فرآیند خود نظارت کنید.</li></ul><h3 id=42523-پروفایلر-بلاک>4.25.2.3 پروفایلر بلاک
<a class=anchor href=#42523-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-%d8%a8%d9%84%d8%a7%da%a9>#</a></h3><p>پروفایلر بلاک در Go اندازه‌گیری می‌کند که چقدر زمان گوروتین‌های شما در حالت Off-CPU صرف می‌شود، در حالی که منتظر عملیات کانال و mutexهای ارائه‌شده توسط پکیج <a href=https://pkg.go.dev/sync>sync</a> هستند. عملیات‌های Go زیر توسط پروفایلر بلاک کنترل می‌شوند:</p><ul><li><a href=https://github.com/golang/go/blob/go1.15.7/src/runtime/select.go#L511>select</a></li><li><a href=https://github.com/golang/go/blob/go1.15.7/src/runtime/chan.go#L279>chan send</a></li><li><a href=https://github.com/golang/go/blob/go1.15.7/src/runtime/chan.go#L586>chan receive</a></li><li><a href=https://github.com/golang/go/blob/go1.15.7/src/runtime/sema.go#L150>semacquire</a> (مثل <a href=https://golang.org/pkg/sync/#Mutex.Lock><code>Mutex.Lock</code></a>، <a href=https://golang.org/pkg/sync/#RWMutex.RLock><code>RWMutex.RLock</code></a>، <a href=https://golang.org/pkg/sync/#RWMutex.Lock><code>RWMutex.Lock</code></a>، <a href=https://golang.org/pkg/sync/#WaitGroup.Wait><code>WaitGroup.Wait</code></a>)</li><li><a href=https://github.com/golang/go/blob/go1.15.7/src/runtime/sema.go#L515>notifyListWait</a> (مثل <a href=https://golang.org/pkg/sync/#Cond.Wait><code>Cond.Wait</code></a>)</li></ul><p>⚠️ پروفایل‌های بلاک شامل زمان انتظار روی I/O، خواب (Sleep)، GC و سایر حالات انتظار نیستند. همچنین رویدادهای مسدود کننده تا زمانی که کامل نشوند ثبت نمی‌شوند، بنابراین پروفایل بلاک نمی‌تواند برای اشکال‌زدایی از اینکه چرا یک برنامه Go در حال حاضر قفل کرده استفاده شود. برای این منظور، از پروفایلر گوروتین می‌توان استفاده کرد.</p><h4 id=425231-کنترل-پروفایلر-بلاک-با-apiهای-مختلف>4.25.2.3.1 کنترل پروفایلر بلاک با API‌های مختلف:
<a class=anchor href=#425231-%da%a9%d9%86%d8%aa%d8%b1%d9%84-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-%d8%a8%d9%84%d8%a7%da%a9-%d8%a8%d8%a7-api%d9%87%d8%a7%db%8c-%d9%85%d8%ae%d8%aa%d9%84%d9%81>#</a></h4><ul><li>دستور <code>go test -blockprofile block.pprof</code> تست‌ها را اجرا کرده و پروفایلی از هر رویداد مسدودکننده در فایلی به نام <code>block.pprof</code> ذخیره می‌کند.</li><li>تابع <a href=https://pkg.go.dev/runtime#SetBlockProfileRate><code>runtime.SetBlockProfileRate(rate)</code></a> به شما اجازه می‌دهد نرخ نمونه‌گیری پروفایلر بلاک را کنترل کنید.</li><li>دستور <a href=https://pkg.go.dev/runtime/pprof#Lookup><code>pprof.Lookup("block").WriteTo(w, 0)</code></a> پروفایلی از رویدادهای مسدودکننده از ابتدای فرآیند تا کنون ایجاد می‌کند و در خروجی <code>w</code> می‌نویسد.</li><li>دستور <a href=https://pkg.go.dev/net/http/pprof><code>import _ "net/http/pprof"</code></a> اجازه می‌دهد تا با استفاده از درخواست <code>GET /debug/pprof/block?seconds=30</code> یک پروفایل بلاک 30 ثانیه‌ای درخواست کنید.</li></ul><h4 id=425232-کد-نمونه-برای-استفاده-از-پروفایلر-بلاک-در-برنامه>4.25.2.3.2 کد نمونه برای استفاده از پروفایلر بلاک در برنامه:
<a class=anchor href=#425232-%da%a9%d8%af-%d9%86%d9%85%d9%88%d9%86%d9%87-%d8%a8%d8%b1%d8%a7%db%8c-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-%d8%a8%d9%84%d8%a7%da%a9-%d8%af%d8%b1-%d8%a8%d8%b1%d9%86%d8%a7%d9%85%d9%87>#</a></h4><pre><code class=language-go>runtime.SetBlockProfileRate(100_000_000) // هشدار: می‌تواند باعث افزایش استفاده از CPU شود
file, _ := os.Create(&quot;./block.pprof&quot;)
defer pprof.Lookup(&quot;block&quot;).WriteTo(file, 0)
</code></pre><p>صرف‌نظر از نحوه فعال کردن پروفایلر بلاک، پروفایل نهایی یک جدول از ردپاهای پشته خواهد بود که در فرمت باینری <strong>pprof</strong> فرمت شده است.</p><table><thead><tr><th>stack trace</th><th>contentions/count</th><th>delay/nanoseconds</th></tr></thead><tbody><tr><td>main;foo;runtime.selectgo</td><td>5</td><td>867549417</td></tr><tr><td>main;foo;bar;sync.(*Mutex).Lock</td><td>3</td><td>453510869</td></tr><tr><td>main;foobar;runtime.chanrecv1</td><td>4</td><td>5351086</td></tr></tbody></table><h4 id=425233-پیادهسازی-پروفایلر-بلاک>4.25.2.3.3 پیاده‌سازی پروفایلر بلاک
<a class=anchor href=#425233-%d9%be%db%8c%d8%a7%d8%af%d9%87%d8%b3%d8%a7%d8%b2%db%8c-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-%d8%a8%d9%84%d8%a7%da%a9>#</a></h4><p>کد شبه زیر جنبه‌های اساسی از پیاده‌سازی پروفایلر بلاک را نشان می‌دهد تا درک بهتری از آن به شما بدهد. هنگام ارسال پیام به یک کانال، یعنی <code>ch &lt;- msg</code>، Go تابع <code>chansend()</code> را در runtime فراخوانی می‌کند. اگر کانال برای دریافت پیام آماده باشد (<code>ready()</code>)، عملیات <code>send()</code> بلافاصله انجام می‌شود. در غیر این صورت، پروفایلر بلاک زمان شروع رویداد مسدودکننده را ثبت می‌کند و از تابع <code>wait_until_ready()</code> استفاده می‌کند تا گوروتین از CPU خارج شود تا زمانی که کانال آماده شود. هنگامی که کانال آماده شد، مدت زمان مسدود شدن تعیین می‌شود و با استفاده از تابع <code>random_sample()</code> و نرخ نمونه‌گیری، بررسی می‌شود که آیا باید این رویداد مسدودکننده ثبت شود یا خیر. در صورت مثبت بودن پاسخ، ردپای پشته فعلی (<code>stack trace</code>) گرفته شده و به عنوان کلید درون نقشه هش <code>block_profile</code> استفاده می‌شود تا شمارنده‌های <code>count</code> و <code>delay</code> افزایش یابند. پس از آن، عملیات <code>send()</code> ادامه می‌یابد.</p><pre><code class=language-go>func chansend(channel, msg):
  if ready(channel):
    send(channel, msg)
    return

  start = now()
  wait_until_ready(channel) // Off-CPU Wait
  duration = now() - start

  if random_sample(duration, rate):
    s = stacktrace()
    // note: actual implementation is a bit trickier to correct for bias
    block_profile[s].contentions += 1
    block_profile[s].delay += duration

  send(channel, msg)
</code></pre><p>تابع <code>random_sample</code> به این صورت عمل می‌کند. اگر پروفایلر بلاک فعال باشد، همه رویدادهایی که <code>duration >= rate</code> باشند ثبت می‌شوند و رویدادهای کوتاه‌تر با احتمال <code>duration/rate</code> ثبت می‌شوند.</p><pre><code class=language-go>func random_sample(duration, rate):
  if rate &lt;= 0 || (duration &lt; rate &amp;&amp; duration/rate &gt; rand(0, 1)):
    return false
  return true
</code></pre><p>به عبارت دیگر، اگر نرخ (<code>rate</code>) را برابر <code>10,000</code> تنظیم کنید (واحد در اینجا نانوثانیه است)، همه رویدادهای مسدودکننده‌ای که <code>10 µsec</code> یا بیشتر طول می‌کشند ثبت می‌شوند. علاوه بر این، <code>10%</code> از رویدادهای با طول <code>1 µsec</code> و <code>1%</code> از رویدادهای با طول <code>100 نانوثانیه</code> و&mldr; نیز ثبت می‌شوند.</p><h4 id=425234-تفاوت-پروفایلر-بلاک-و-پروفایلر-mutex>4.25.2.3.4 تفاوت پروفایلر بلاک و پروفایلر Mutex
<a class=anchor href=#425234-%d8%aa%d9%81%d8%a7%d9%88%d8%aa-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-%d8%a8%d9%84%d8%a7%da%a9-%d9%88-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-mutex>#</a></h4><p>هر دو پروفایلر بلاک و mutex زمان انتظار روی mutexها را گزارش می‌دهند. تفاوت این است که پروفایلر بلاک زمان انتظار برای به دست آوردن <code>Lock()</code> را ثبت می‌کند، در حالی که پروفایلر mutex زمانی که گوروتین دیگری منتظر <code>Unlock()</code> است تا اجرا شود را ثبت می‌کند.</p><h4 id=425235-محدودیتهای-پروفایلر-بلاک>4.25.2.3.5 محدودیت‌های پروفایلر بلاک
<a class=anchor href=#425235-%d9%85%d8%ad%d8%af%d9%88%d8%af%db%8c%d8%aa%d9%87%d8%a7%db%8c-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-%d8%a8%d9%84%d8%a7%da%a9>#</a></h4><ul><li>🚨 پروفایلر بلاک می‌تواند باعث افزایش قابل توجه مصرف CPU در محیط تولید شود. توصیه می‌شود که تنها برای توسعه و تست استفاده شود. اگر نیاز به استفاده از آن در محیط تولید دارید، با نرخ بسیار بالا شروع کنید، مثلاً 100 میلیون، و تنها در صورت نیاز آن را کاهش دهید.</li><li>⚠ پروفایل‌های بلاک تنها شامل زیر مجموعه کوچکی از حالات انتظار Off-CPU هستند که یک گوروتین می‌تواند وارد آن‌ها شود.</li><li>⚠ حداکثر تعداد توابع تو در تو که می‌توانند در ردپاهای پشته توسط پروفایلر بلاک ثبت شوند، فعلاً برابر <a href="https://sourcegraph.com/search?q=context:global+repo:github.com/golang/go+file:src/*+maxStack+%3D&amp;patternType=literal"><code>32</code></a> است.</li><li>⚠ نقشه هش داخلی که پروفایل بلاک را نگه می‌دارد هیچ محدودیتی در اندازه ندارد.</li></ul><h3 id=42524-پروفایلر-mutex>4.25.2.4 پروفایلر Mutex
<a class=anchor href=#42524-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-mutex>#</a></h3><p>پروفایلر mutex زمانی را اندازه‌گیری می‌کند که گوروتین‌ها صرف مسدود کردن سایر گوروتین‌ها می‌کنند. به عبارتی، این پروفایلر منابع رقابت برای قفل‌ها را ثبت می‌کند. پروفایلر mutex می‌تواند رقابت ناشی از <code>sync.Mutex</code> و <code>sync.RWMutex</code> را ثبت کند.</p><p>⚠️ پروفایل‌های mutex شامل سایر منابع رقابت مثل <code>sync.WaitGroup</code>، <code>sync.Cond</code> یا دسترسی به توصیف‌کننده‌های فایل نمی‌شوند. همچنین، رقابت mutex تا زمانی که mutex آزاد نشود، ثبت نمی‌شود. بنابراین، پروفایل mutex برای اشکال‌زدایی از دلیل معلق بودن برنامه Go قابل استفاده نیست؛ برای این کار می‌توانید از پروفایلر گوروتین استفاده کنید.</p><h4 id=425241-کنترل-پروفایلر-mutex>4.25.2.4.1 کنترل پروفایلر Mutex
<a class=anchor href=#425241-%da%a9%d9%86%d8%aa%d8%b1%d9%84-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-mutex>#</a></h4><p>چندین API برای کنترل پروفایلر mutex در دسترس است:</p><ul><li><code>go test -mutexprofile mutex.pprof</code> تست‌ها را اجرا می‌کند و پروفایل mutex را در یک فایل با نام <code>mutex.pprof</code> می‌نویسد.</li><li><a href=https://pkg.go.dev/runtime#SetMutexProfileRate><code>runtime.SetMutexProfileRate(rate)</code></a> به شما امکان می‌دهد نرخ نمونه‌گیری پروفایلر mutex را فعال و کنترل کنید. اگر نرخ نمونه‌گیری برابر با <code>R</code> تنظیم شود، به طور متوسط <code>1/R</code> از رویدادهای رقابت mutex ثبت می‌شوند. اگر نرخ برابر 0 یا کمتر باشد، هیچ رویدادی ثبت نمی‌شود.</li><li><a href=https://pkg.go.dev/runtime/pprof#Lookup><code>pprof.Lookup("mutex").WriteTo(w, 0)</code></a> پروفایل mutex را از شروع پردازش تا زمان نوشتن به <code>w</code> ثبت می‌کند.</li><li><a href=https://pkg.go.dev/net/http/pprof><code>import _ "net/http/pprof"</code></a> به شما امکان می‌دهد با ارسال درخواست به مسیر <code>GET /debug/pprof/mutex?seconds=30</code> یک پروفایل 30 ثانیه‌ای از mutex‌ها دریافت کنید.</li></ul><h4 id=425242-نمونه-سریع-استفاده-از-پروفایلر-mutex>4.25.2.4.2 نمونه سریع استفاده از پروفایلر Mutex
<a class=anchor href=#425242-%d9%86%d9%85%d9%88%d9%86%d9%87-%d8%b3%d8%b1%db%8c%d8%b9-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-mutex>#</a></h4><p>اگر نیاز به کد سریع برای قرار دادن در تابع <code>main()</code> دارید، می‌توانید از کد زیر استفاده کنید:</p><pre><code class=language-go>runtime.SetMutexProfileFraction(100)
file, _ := os.Create(&quot;./mutex.pprof&quot;)
defer pprof.Lookup(&quot;mutex&quot;).WriteTo(file, 0)
</code></pre><p>پروفایل mutex به دست آمده در اصل جدولی از ردپای پشته‌ها (<code>stack traces</code>) خواهد بود که به صورت فرمت دودویی pprof ذخیره می‌شود.</p><table><thead><tr><th>stack trace</th><th>contentions/count</th><th>delay/nanoseconds</th></tr></thead><tbody><tr><td>main;foo;sync.(*Mutex).Unlock</td><td>5</td><td>867549417</td></tr><tr><td>main;bar;baz;sync.(*Mutex).Unlock</td><td>3</td><td>453510869</td></tr><tr><td>main;foobar;sync.(*RWMutex).RUnlock</td><td>4</td><td>5351086</td></tr></tbody></table><h4 id=425243-تفاوت-پروفایلهای-block-و-mutex>4.25.2.4.3 تفاوت پروفایل‌های Block و Mutex
<a class=anchor href=#425243-%d8%aa%d9%81%d8%a7%d9%88%d8%aa-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d9%87%d8%a7%db%8c-block-%d9%88-mutex>#</a></h4><p>پروفایل‌های block و mutex هر دو زمان انتظار روی mutex‌ها را ثبت می‌کنند، اما تفاوت در این است که پروفایل block زمانی که گوروتین در حال انتظار برای قفل شدن است را ثبت می‌کند، در حالی که پروفایل mutex زمانی که یک گوروتین قفل را در اختیار دارد و باعث جلوگیری از ادامه کار سایر گوروتین‌ها می‌شود، را ثبت می‌کند.</p><h4 id=425244-پیادهسازی-پروفایلر-mutex>4.25.2.4.4 پیاده‌سازی پروفایلر Mutex
<a class=anchor href=#425244-%d9%be%db%8c%d8%a7%d8%af%d9%87%d8%b3%d8%a7%d8%b2%db%8c-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-mutex>#</a></h4><p>پروفایلر mutex با ثبت زمانی که یک گوروتین تلاش می‌کند قفلی را بگیرد (مثلاً <code>mu.Lock()</code>)، تا زمانی که گوروتین صاحب قفل آن را آزاد کند (مثلاً <code>mu.Unlock()</code>)، کار می‌کند. ابتدا یک گوروتین <code>semacquire()</code> را برای گرفتن قفل فراخوانی می‌کند و اگر قفل در حال حاضر توسط گوروتین دیگری گرفته شده باشد، زمان شروع انتظار ثبت می‌شود. وقتی گوروتین صاحب قفل آن را با فراخوانی <code>semrelease()</code> آزاد می‌کند، گوروتین منتظر بررسی می‌شود و زمان انتظار آن محاسبه می‌گردد. در نهایت، اگر رویداد به صورت تصادفی برای ثبت انتخاب شود، زمان مسدودی به یک نقشه هش (<code>hash map</code>) اضافه می‌شود که کلید آن پشته فراخوانی گوروتین آزادکننده قفل است.</p><h4 id=425245-محدودیتهای-پروفایلر-mutex>4.25.2.4.5 محدودیت‌های پروفایلر Mutex
<a class=anchor href=#425245-%d9%85%d8%ad%d8%af%d9%88%d8%af%db%8c%d8%aa%d9%87%d8%a7%db%8c-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-mutex>#</a></h4><ul><li>⚠️ حداکثر تعداد فراخوانی‌های تو در تو که می‌توان در پشته فراخوانی‌های پروفایل mutex ثبت کرد، در حال حاضر <a href="https://sourcegraph.com/search?q=context:global+repo:github.com/golang/go+file:src/*+maxStack+%3D&amp;patternType=literal"><code>32</code></a> است. برای اطلاعات بیشتر درباره محدودیت‌های پروفایلر CPU، به مستندات مرتبط مراجعه کنید.</li><li>⚠️ هیچ محدودیتی برای اندازه نقشه هش داخلی که داده‌های پروفایل mutex را نگه می‌دارد وجود ندارد. این بدان معناست که اندازه آن تا زمانی که تمام مسیرهای مسدودکننده در کد شما پوشش داده شوند، رشد خواهد کرد. در عمل، این مشکل چندانی ایجاد نمی‌کند، اما ممکن است به عنوان یک نشت حافظه کوچک به نظر برسد.</li><li>⚠️ برچسب‌های پروفایلر CPU در پروفایل mutex پشتیبانی نمی‌شوند. اضافه کردن این ویژگی به پیاده‌سازی فعلی ممکن است باعث ایجاد نشت حافظه در نقشه هش داخلی که داده‌های پروفایل حافظه را نگه می‌دارد، شود.</li><li>⚠️ تعداد رقابت‌ها و زمان‌های تأخیر در یک پروفایل mutex بر اساس <strong>آخرین</strong> نرخ نمونه‌برداری تنظیم شده، تنظیم می‌شوند، نه در زمان نمونه‌برداری. در نتیجه، برنامه‌هایی که نرخ نمونه‌برداری پروفایل mutex را در میانه اجرای خود تغییر می‌دهند، ممکن است نتایج نادقیقی را مشاهده کنند.</li></ul><h3 id=42525-پروفایلر-goroutine>4.25.2.5 پروفایلر Goroutine
<a class=anchor href=#42525-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-goroutine>#</a></h3><p>در زمان اجرای Go، تمام گوروتین‌ها در یک آرایه ساده به نام <a href=https://github.com/golang/go/blob/3a778ff50f7091b8a64875c8ed95bfaacf3d334c/src/runtime/proc.go#L500>allgs</a> نگهداری می‌شوند. این آرایه شامل گوروتین‌های فعال و غیرفعال (مرده) است. گوروتین‌های مرده برای استفاده مجدد زمانی که گوروتین‌های جدید ایجاد می‌شوند، نگه داشته می‌شوند.</p><p>Go دارای API‌های مختلفی برای بررسی گوروتین‌های فعال در <code>allgs</code> است که به همراه استک ترِیس و برخی دیگر از ویژگی‌های آنها اطلاعاتی ارائه می‌دهند. برخی از این API‌ها اطلاعات آماری ارائه می‌دهند، در حالی که برخی دیگر اطلاعات مربوط به هر گوروتین را به صورت جداگانه فراهم می‌کنند.</p><p>علیرغم تفاوت‌های بین این API‌ها، تعریف <a href=https://github.com/golang/go/blob/9b955d2d3fcff6a5bc8bce7bafdc4c634a28e95b/src/runtime/mprof.go#L729>مشترک</a> از گوروتین &ldquo;فعال&rdquo; به نظر می‌رسد که شامل موارد زیر باشد:</p><ul><li>گوروتین <a href=https://github.com/golang/go/blob/go1.15.6/src/runtime/runtime2.go#L65-L71>از بین رفته</a> نباشد.</li><li>گوروتین <a href=https://github.com/golang/go/blob/9b955d2d3fcff6a5bc8bce7bafdc4c634a28e95b/src/runtime/traceback.go#L1013-L1021>سیستمی</a> یا گوروتین نهایی‌کننده نباشد.</li></ul><p>به عبارت دیگر، گوروتین‌هایی که در حال اجرا هستند و همچنین آنهایی که منتظر ورودی/خروجی (I/O)، قفل‌ها، کانال‌ها، برنامه‌ریزی و غیره هستند، همه به عنوان &ldquo;فعال&rdquo; در نظر گرفته می‌شوند، حتی اگر به نظر برسد که برخی از این حالت‌ها غیرفعال هستند.</p><h4 id=425251-سربار-overhead>4.25.2.5.1 سربار (Overhead)
<a class=anchor href=#425251-%d8%b3%d8%b1%d8%a8%d8%a7%d8%b1-overhead>#</a></h4><p>همه پروفایل‌گیری‌های گوروتین در Go نیاز به یک فاز <strong>متوقف‌سازی جهان (stop-the-world)</strong> به اندازه <code>O(N)</code> دارند، که در آن <code>N</code> تعداد گوروتین‌های تخصیص داده شده است. یک <a href=https://github.com/felixge/fgprof/blob/fe01e87ceec08ea5024e8168f88468af8f818b62/fgprof_test.go#L35-L78>بنچمارک ساده</a> <a href=https://github.com/felixge/fgprof/blob/master/BenchmarkProfilerGoroutines.txt>نشان می‌دهد</a> که جهان به طور تقریبی به ازای هر گوروتین حدود ~1µs متوقف می‌شود، وقتی از API <a href=https://golang.org/pkg/runtime/#GoroutineProfile><code>runtime.GoroutineProfile()</code></a> استفاده می‌شود. اما این مقدار ممکن است بسته به عواملی مانند عمق استک برنامه، تعداد گوروتین‌های مرده و غیره تغییر کند.</p><p>به طور کلی، برنامه‌هایی که بسیار حساس به تأخیر هستند و از هزاران گوروتین فعال استفاده می‌کنند، ممکن است بخواهند در پروفایل‌گیری گوروتین در محیط تولید با دقت بیشتری عمل کنند. با این حال، تعداد زیاد گوروتین‌ها و حتی شاید خود زبان Go ممکن است برای چنین برنامه‌هایی ایده‌ی مناسبی نباشد.</p><p>بیشتر برنامه‌هایی که تعداد زیادی گوروتین ایجاد نمی‌کنند و می‌توانند چند میلی‌ثانیه تأخیر اضافی را تحمل کنند، نباید مشکلی با پروفایل‌گیری مستمر گوروتین در محیط تولید داشته باشند.</p><h4 id=425252-ویژگیهای-گوروتین>4.25.2.5.2 ویژگی‌های گوروتین
<a class=anchor href=#425252-%d9%88%db%8c%da%98%da%af%db%8c%d9%87%d8%a7%db%8c-%da%af%d9%88%d8%b1%d9%88%d8%aa%db%8c%d9%86>#</a></h4><p>گوروتین‌ها دارای بسیاری از <a href=https://github.com/golang/go/blob/go1.15.6/src/runtime/runtime2.go#L406-L486>ویژگی‌ها</a> هستند که می‌توانند به اشکال‌زدایی برنامه‌های Go کمک کنند. موارد زیر جالب توجه هستند و به طرق مختلف از طریق API‌هایی که در ادامه این سند توضیح داده شده‌اند، در دسترس قرار دارند:</p><ul><li><a href=https://github.com/golang/go/blob/go1.15.6/src/runtime/runtime2.go#L428><code>goid</code></a>: شناسه‌ی یکتای گوروتین؛ گوروتین اصلی دارای شناسه <code>1</code> است.</li><li><a href=https://github.com/golang/go/blob/go1.15.6/src/runtime/runtime2.go#L14-L105><code>atomicstatus</code></a>: وضعیت گوروتین، یکی از موارد زیر:<ul><li><code>idle</code>: تازه تخصیص داده شده است.</li><li><code>runnable</code>: در صف اجرا، منتظر زمان‌بندی.</li><li><code>running</code>: در حال اجرا روی یک نخ (thread) سیستم‌عامل.</li><li><code>syscall</code>: مسدود شده در یک فراخوان سیستمی.</li><li><code>waiting</code>: توسط زمان‌بندی‌کننده متوقف شده، نگاه کنید به <code>g.waitreason</code>.</li><li><code>dead</code>: تازه خارج شده یا در حال دوباره‌سازی.</li><li><code>copystack</code>: استک در حال انتقال است.</li><li><code>preempted</code>: تازه از اجرا خودداری کرده است.</li></ul></li><li><a href=https://github.com/golang/go/blob/go1.15.6/src/runtime/runtime2.go#L996-L1024><code>waitreason</code></a>: دلیلی که گوروتین در وضعیت <code>waiting</code> قرار دارد، مانند خواب، عملیات کانال، I/O، جمع‌آوری زباله (GC) و غیره.</li><li><a href=https://github.com/golang/go/blob/go1.15.6/src/runtime/runtime2.go#L430><code>waitsince</code></a>: زمان تقریبی که گوروتین وارد وضعیت <code>waiting</code> یا <code>syscall</code> شده است که توسط اولین GC بعد از شروع انتظار تعیین می‌شود.</li><li><a href=https://github.com/golang/go/blob/go1.15.6/src/runtime/runtime2.go#L472><code>labels</code></a>: مجموعه‌ای از کلید/مقدار <a href=https://rakyll.org/profiler-labels/>برچسب‌های پروفایل‌گیر</a> که می‌توانند به گوروتین‌ها متصل شوند.</li><li><code>stack trace</code>: تابعی که در حال اجراست و همچنین توابع فراخواننده آن. این به صورت خروجی متنی شامل نام فایل‌ها، نام توابع و شماره خطوط یا به صورت یک آرایه از آدرس‌های شمارنده برنامه (PCs) نمایش داده می‌شود. 🚧تحقیق بیشتر درباره این موضوع: آیا می‌توان متن تابع/فایل/خط را به PCs تبدیل کرد؟</li><li><a href=https://github.com/golang/go/blob/go1.15.6/src/runtime/runtime2.go#L466><code>gopc</code></a>: آدرس شمارنده برنامه (PC) مربوط به فراخوانی <code>go ...</code> که باعث ایجاد این گوروتین شده است. این می‌تواند به فایل، نام تابع و شماره خط تبدیل شود.</li><li><a href=https://github.com/golang/go/blob/go1.15.6/src/runtime/runtime2.go#L460><code>lockedm</code></a>: نخی که این گوروتین به آن قفل شده است، در صورتی که وجود داشته باشد.</li></ul><h4 id=425253-ماتریس-ویژگیها-feature-matrix>4.25.2.5.3 ماتریس ویژگی‌ها (Feature Matrix)
<a class=anchor href=#425253-%d9%85%d8%a7%d8%aa%d8%b1%db%8c%d8%b3-%d9%88%db%8c%da%98%da%af%db%8c%d9%87%d8%a7-feature-matrix>#</a></h4><p>جدول ماتریس ویژگی‌های زیر به شما یک ایده کلی از دسترسی کنونی این ویژگی‌ها از طریق APIهای مختلف ارائه می‌دهد.</p><center><a href=#><img src=../../assets/img/content/chapter4/profiling/9.png alt="goroutine matrix"></a></center><h4 id=425254-apiها>4.25.2.5.4 APIها
<a class=anchor href=#425254-api%d9%87%d8%a7>#</a></h4><p><a href=https://golang.org/pkg/runtime/#Stack><code>runtime.Stack()</code></a> / <a href=https://golang.org/pkg/runtime/pprof/#Lookup><code>pprof.Lookup(debug=2)</code></a></p><p>این تابع خروجی متنی بدون ساختار بازمی‌گرداند که شامل استک (Stack) تمام گوروتین‌های فعال و ویژگی‌هایی که در ماتریس ویژگی‌ها ذکر شده است، می‌باشد.</p><p>ویژگی <code>waitsince</code> به عنوان <code>nanotime() - gp.waitsince()</code> بر حسب دقیقه نمایش داده می‌شود، اما تنها زمانی که مدت زمان بیش از 1 دقیقه باشد.</p><p><code>pprof.Lookup(debug=2)</code> یک نام مستعار ساده‌شده برای استفاده از این پروفایل است. فراخوانی واقعی به این شکل است:</p><pre><code class=language-go>profile := pprof.Lookup(&quot;goroutine&quot;)
profile.WriteTo(os.Stdout, 2)
</code></pre><p>پیاده‌سازی پروفایل به سادگی <code>runtime.Stack()</code> را فراخوانی می‌کند.</p><p>در زیر مثالی کوتاه از خروجی بازگردانده شده آمده است.</p><pre><code class=language-shell>goroutine 1 [running]:
main.glob..func1(0x14e5940, 0xc0000aa7b0, 0xc000064eb0, 0x2)
	/Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:29 +0x6f
main.writeProfiles(0x2, 0xc0000c4008, 0x1466424)
	/Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:106 +0x187
main.main()
	/Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:152 +0x3d2

goroutine 22 [sleep, 1 minutes]:
time.Sleep(0x3b9aca00)
	/usr/local/Cellar/go/1.15.6/libexec/src/runtime/time.go:188 +0xbf
main.shortSleepLoop()
	/Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:165 +0x2a
created by main.indirectShortSleepLoop2
	/Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:185 +0x35

goroutine 3 [IO wait, 1 minutes]:
internal/poll.runtime_pollWait(0x1e91e88, 0x72, 0x0)
	/usr/local/Cellar/go/1.15.6/libexec/src/runtime/netpoll.go:222 +0x55
internal/poll.(*pollDesc).wait(0xc00019e018, 0x72, 0x0, 0x0, 0x1465786)
	/usr/local/Cellar/go/1.15.6/libexec/src/internal/poll/fd_poll_runtime.go:87 +0x45
internal/poll.(*pollDesc).waitRead(...)
	/usr/local/Cellar/go/1.15.6/libexec/src/internal/poll/fd_poll_runtime.go:92
internal/poll.(*FD).Accept(0xc00019e000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0)
	/usr/local/Cellar/go/1.15.6/libexec/src/internal/poll/fd_unix.go:394 +0x1fc
net.(*netFD).accept(0xc00019e000, 0x7d667d63cbbded3e, 0x1789ccbbded3e, 0x100000001)
	/usr/local/Cellar/go/1.15.6/libexec/src/net/fd_unix.go:172 +0x45
net.(*TCPListener).accept(0xc000188060, 0x60006709, 0xc000196da8, 0x109abe6)
	/usr/local/Cellar/go/1.15.6/libexec/src/net/tcpsock_posix.go:139 +0x32
net.(*TCPListener).Accept(0xc000188060, 0xc000196df8, 0x18, 0xc000001200, 0x12e9eec)
	/usr/local/Cellar/go/1.15.6/libexec/src/net/tcpsock.go:261 +0x65
net/http.(*Server).Serve(0xc00019c000, 0x14ec6e0, 0xc000188060, 0x0, 0x0)
	/usr/local/Cellar/go/1.15.6/libexec/src/net/http/server.go:2937 +0x266
net/http.(*Server).ListenAndServe(0xc00019c000, 0xc00019c000, 0x1475536)
	/usr/local/Cellar/go/1.15.6/libexec/src/net/http/server.go:2866 +0xb7
net/http.ListenAndServe(...)
	/usr/local/Cellar/go/1.15.6/libexec/src/net/http/server.go:3120
main.main.func1(0xc000032120)
	/Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:123 +0x126
created by main.main
	/Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:121 +0xc5

goroutine 4 [sleep, 1 minutes]:
time.Sleep(0x3b9aca00)
	/usr/local/Cellar/go/1.15.6/libexec/src/runtime/time.go:188 +0xbf
main.shortSleepLoop()
	/Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:165 +0x2a
created by main.main
	/Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:130 +0x195

goroutine 5 [sleep, 1 minutes]:
time.Sleep(0x34630b8a000)
	/usr/local/Cellar/go/1.15.6/libexec/src/runtime/time.go:188 +0xbf
main.sleepLoop(0x34630b8a000)
	/Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:171 +0x2b
created by main.main
	/Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:131 +0x1bc

goroutine 6 [chan receive, 1 minutes]:
main.chanReceiveForever()
	/Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:177 +0x4d
created by main.main
	/Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:132 +0x1d4

goroutine 24 [select, 1 minutes]:
net/http.(*persistConn).writeLoop(0xc0000cea20)
	/usr/local/Cellar/go/1.15.6/libexec/src/net/http/transport.go:2340 +0x11c
created by net/http.(*Transport).dialConn
	/usr/local/Cellar/go/1.15.6/libexec/src/net/http/transport.go:1709 +0xcdc

goroutine 23 [IO wait, 1 minutes]:
internal/poll.runtime_pollWait(0x1e91da0, 0x72, 0x14e6ca0)
	/usr/local/Cellar/go/1.15.6/libexec/src/runtime/netpoll.go:222 +0x55
internal/poll.(*pollDesc).wait(0xc00010e198, 0x72, 0x14e6c00, 0x16db878, 0x0)
	/usr/local/Cellar/go/1.15.6/libexec/src/internal/poll/fd_poll_runtime.go:87 +0x45
internal/poll.(*pollDesc).waitRead(...)
	/usr/local/Cellar/go/1.15.6/libexec/src/internal/poll/fd_poll_runtime.go:92
internal/poll.(*FD).Read(0xc00010e180, 0xc000256000, 0x1000, 0x1000, 0x0, 0x0, 0x0)
	/usr/local/Cellar/go/1.15.6/libexec/src/internal/poll/fd_unix.go:159 +0x1a5
net.(*netFD).Read(0xc00010e180, 0xc000256000, 0x1000, 0x1000, 0x103b1dc, 0xc000199b58, 0x10680e0)
	/usr/local/Cellar/go/1.15.6/libexec/src/net/fd_posix.go:55 +0x4f
net.(*conn).Read(0xc000010008, 0xc000256000, 0x1000, 0x1000, 0x0, 0x0, 0x0)
	/usr/local/Cellar/go/1.15.6/libexec/src/net/net.go:182 +0x8e
net/http.(*persistConn).Read(0xc0000cea20, 0xc000256000, 0x1000, 0x1000, 0xc00009e300, 0xc000199c58, 0x10074b5)
	/usr/local/Cellar/go/1.15.6/libexec/src/net/http/transport.go:1887 +0x77
bufio.(*Reader).fill(0xc0001801e0)
	/usr/local/Cellar/go/1.15.6/libexec/src/bufio/bufio.go:101 +0x105
bufio.(*Reader).Peek(0xc0001801e0, 0x1, 0x0, 0x0, 0x1, 0x0, 0xc0001d0060)
	/usr/local/Cellar/go/1.15.6/libexec/src/bufio/bufio.go:139 +0x4f
net/http.(*persistConn).readLoop(0xc0000cea20)
	/usr/local/Cellar/go/1.15.6/libexec/src/net/http/transport.go:2040 +0x1a8
created by net/http.(*Transport).dialConn
	/usr/local/Cellar/go/1.15.6/libexec/src/net/http/transport.go:1708 +0xcb7

goroutine 41 [IO wait, 1 minutes]:
internal/poll.runtime_pollWait(0x1e91cb8, 0x72, 0x14e6ca0)
	/usr/local/Cellar/go/1.15.6/libexec/src/runtime/netpoll.go:222 +0x55
internal/poll.(*pollDesc).wait(0xc00019e098, 0x72, 0x14e6c00, 0x16db878, 0x0)
	/usr/local/Cellar/go/1.15.6/libexec/src/internal/poll/fd_poll_runtime.go:87 +0x45
internal/poll.(*pollDesc).waitRead(...)
	/usr/local/Cellar/go/1.15.6/libexec/src/internal/poll/fd_poll_runtime.go:92
internal/poll.(*FD).Read(0xc00019e080, 0xc000326000, 0x1000, 0x1000, 0x0, 0x0, 0x0)
	/usr/local/Cellar/go/1.15.6/libexec/src/internal/poll/fd_unix.go:159 +0x1a5
net.(*netFD).Read(0xc00019e080, 0xc000326000, 0x1000, 0x1000, 0x203000, 0x203000, 0x203000)
	/usr/local/Cellar/go/1.15.6/libexec/src/net/fd_posix.go:55 +0x4f
net.(*conn).Read(0xc000186028, 0xc000326000, 0x1000, 0x1000, 0x0, 0x0, 0x0)
	/usr/local/Cellar/go/1.15.6/libexec/src/net/net.go:182 +0x8e
net/http.(*connReader).Read(0xc00007c300, 0xc000326000, 0x1000, 0x1000, 0x100000006, 0x10, 0x1819408)
	/usr/local/Cellar/go/1.15.6/libexec/src/net/http/server.go:798 +0x1ad
bufio.(*Reader).fill(0xc000290060)
	/usr/local/Cellar/go/1.15.6/libexec/src/bufio/bufio.go:101 +0x105
bufio.(*Reader).ReadSlice(0xc000290060, 0xa, 0x1819408, 0xc000337988, 0x100f6d0, 0xc000110000, 0x100)
	/usr/local/Cellar/go/1.15.6/libexec/src/bufio/bufio.go:360 +0x3d
bufio.(*Reader).ReadLine(0xc000290060, 0xc000110000, 0x1079694, 0xc0001a4000, 0x0, 0x1010038, 0x30)
	/usr/local/Cellar/go/1.15.6/libexec/src/bufio/bufio.go:389 +0x34
net/textproto.(*Reader).readLineSlice(0xc000182300, 0xc000110000, 0x10d7c4d, 0xc00019e080, 0x1068000, 0xc000282900)
	/usr/local/Cellar/go/1.15.6/libexec/src/net/textproto/reader.go:58 +0x6c
net/textproto.(*Reader).ReadLine(...)
	/usr/local/Cellar/go/1.15.6/libexec/src/net/textproto/reader.go:39
net/http.readRequest(0xc000290060, 0x0, 0xc000110000, 0x0, 0x0)
	/usr/local/Cellar/go/1.15.6/libexec/src/net/http/request.go:1012 +0xaa
net/http.(*conn).readRequest(0xc0000c6320, 0x14ed4a0, 0xc000322000, 0x0, 0x0, 0x0)
	/usr/local/Cellar/go/1.15.6/libexec/src/net/http/server.go:984 +0x19a
net/http.(*conn).serve(0xc0000c6320, 0x14ed4a0, 0xc000322000)
	/usr/local/Cellar/go/1.15.6/libexec/src/net/http/server.go:1851 +0x705
created by net/http.(*Server).Serve
	/usr/local/Cellar/go/1.15.6/libexec/src/net/http/server.go:2969 +0x36c
</code></pre><p><strong><a href=https://golang.org/pkg/runtime/pprof/#Lookup><code>pprof.Lookup(debug=1)</code></a></strong></p><p>این روش پروفایل‌گیری مشابه <code>pprof.Lookup(debug=2)</code> فراخوانی می‌شود، اما داده‌های کاملاً متفاوتی تولید می‌کند:</p><ul><li>به جای لیست کردن هر گوروتین به صورت جداگانه، گوروتین‌هایی با استک و برچسب‌های یکسان فقط یک بار همراه با تعداد آنها لیست می‌شوند.</li><li>برچسب‌های pprof در این حالت گنجانده می‌شوند، در حالی که <code>debug=2</code> آنها را شامل نمی‌شود.</li><li>بیشتر ویژگی‌های دیگر گوروتین که در <code>debug=2</code> وجود دارند، در اینجا وجود ندارند.</li><li>فرمت خروجی همچنان به صورت متنی است، اما ظاهری بسیار متفاوت نسبت به <code>debug=2</code> دارد.</li></ul><p>در زیر یک نمونه کوتاه از خروجی برگردانده شده آورده شده است.</p><pre><code class=language-shell>goroutine profile: total 9
2 @ 0x103b125 0x106cd1f 0x13ac44a 0x106fd81
# labels: {&quot;test_label&quot;:&quot;test_value&quot;}
#	0x106cd1e	time.Sleep+0xbe			/usr/local/Cellar/go/1.15.6/libexec/src/runtime/time.go:188
#	0x13ac449	main.shortSleepLoop+0x29	/Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:165

1 @ 0x103b125 0x10083ef 0x100802b 0x13ac4ed 0x106fd81
# labels: {&quot;test_label&quot;:&quot;test_value&quot;}
#	0x13ac4ec	main.chanReceiveForever+0x4c	/Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:177

1 @ 0x103b125 0x103425b 0x106a1d5 0x10d8185 0x10d91c5 0x10d91a3 0x11b8a8f 0x11cb72e 0x12df52d 0x11707c5 0x117151d 0x1171754 0x1263c2c 0x12d96ca 0x12d96f9 0x12e09ba 0x12e5085 0x106fd81
#	0x106a1d4	internal/poll.runtime_pollWait+0x54		/usr/local/Cellar/go/1.15.6/libexec/src/runtime/netpoll.go:222
#	0x10d8184	internal/poll.(*pollDesc).wait+0x44		/usr/local/Cellar/go/1.15.6/libexec/src/internal/poll/fd_poll_runtime.go:87
#	0x10d91c4	internal/poll.(*pollDesc).waitRead+0x1a4	/usr/local/Cellar/go/1.15.6/libexec/src/internal/poll/fd_poll_runtime.go:92
#	0x10d91a2	internal/poll.(*FD).Read+0x182			/usr/local/Cellar/go/1.15.6/libexec/src/internal/poll/fd_unix.go:159
#	0x11b8a8e	net.(*netFD).Read+0x4e				/usr/local/Cellar/go/1.15.6/libexec/src/net/fd_posix.go:55
#	0x11cb72d	net.(*conn).Read+0x8d				/usr/local/Cellar/go/1.15.6/libexec/src/net/net.go:182
#	0x12df52c	net/http.(*connReader).Read+0x1ac		/usr/local/Cellar/go/1.15.6/libexec/src/net/http/server.go:798
#	0x11707c4	bufio.(*Reader).fill+0x104			/usr/local/Cellar/go/1.15.6/libexec/src/bufio/bufio.go:101
#	0x117151c	bufio.(*Reader).ReadSlice+0x3c			/usr/local/Cellar/go/1.15.6/libexec/src/bufio/bufio.go:360
#	0x1171753	bufio.(*Reader).ReadLine+0x33			/usr/local/Cellar/go/1.15.6/libexec/src/bufio/bufio.go:389
#	0x1263c2b	net/textproto.(*Reader).readLineSlice+0x6b	/usr/local/Cellar/go/1.15.6/libexec/src/net/textproto/reader.go:58
#	0x12d96c9	net/textproto.(*Reader).ReadLine+0xa9		/usr/local/Cellar/go/1.15.6/libexec/src/net/textproto/reader.go:39
#	0x12d96f8	net/http.readRequest+0xd8			/usr/local/Cellar/go/1.15.6/libexec/src/net/http/request.go:1012
#	0x12e09b9	net/http.(*conn).readRequest+0x199		/usr/local/Cellar/go/1.15.6/libexec/src/net/http/server.go:984
#	0x12e5084	net/http.(*conn).serve+0x704			/usr/local/Cellar/go/1.15.6/libexec/src/net/http/server.go:1851

...
</code></pre><p><strong><a href=https://golang.org/pkg/runtime/pprof/#Lookup><code>pprof.Lookup(debug=0)</code></a></strong></p><p>این روش پروفایل‌گیری دقیقاً مانند <code>pprof.Lookup(debug=1)</code> فراخوانی می‌شود و همان داده‌ها را تولید می‌کند. تنها تفاوت این است که فرمت داده‌ها به صورت پروتکل بافر pprof است.</p><p>در زیر یک نمونه کوتاه از خروجی برگشتی که توسط <code>go tool pprof -raw</code> گزارش شده است آورده شده است.</p><pre><code class=language-shell>PeriodType: goroutine count
Period: 1
Time: 2021-01-14 16:46:23.697667 +0100 CET
Samples:
goroutine/count
          2: 1 2 3 
                test_label:[test_value]
          1: 1 4 5 6 
                test_label:[test_value]
          1: 1 7 8 9 10 11 12 13 14 15 16 17 18 19 20 
          1: 1 7 8 9 10 11 12 21 14 22 23 
                test_label:[test_value]
          1: 1 7 8 9 24 25 26 27 28 29 30 
          1: 1 31 32 
                test_label:[test_value]
          1: 1 2 33 
                test_label:[test_value]
          1: 34 35 36 37 38 39 40 41 
                test_label:[test_value]
Locations
     1: 0x103b124 M=1 runtime.gopark /usr/local/Cellar/go/1.15.6/libexec/src/runtime/proc.go:306 s=0
     2: 0x106cd1e M=1 time.Sleep /usr/local/Cellar/go/1.15.6/libexec/src/runtime/time.go:188 s=0
     3: 0x13ac449 M=1 main.shortSleepLoop /Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:165 s=0
     4: 0x10083ee M=1 runtime.chanrecv /usr/local/Cellar/go/1.15.6/libexec/src/runtime/chan.go:577 s=0
     5: 0x100802a M=1 runtime.chanrecv1 /usr/local/Cellar/go/1.15.6/libexec/src/runtime/chan.go:439 s=0
     6: 0x13ac4ec M=1 main.chanReceiveForever /Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:177 s=0
...
Mappings
1: 0x0/0x0/0x0   [FN]
</code></pre><p><strong><a href=https://golang.org/pkg/runtime/#GoroutineProfile><code>runtime.GoroutineProfile()</code></a></strong></p><p>این تابع در واقع یک slice از تمام گوروتین‌های فعال و trace استک فعلی آنها را برمی‌گرداند. استک ترِیس‌ها به صورت آدرس‌های برنامه ارائه می‌شوند که می‌توان آنها را با استفاده از تابع <a href=https://golang.org/pkg/runtime/#CallersFrames><code>runtime.CallersFrames()</code></a> به نام‌های توابع ترجمه کرد.</p><p>این روش توسط <a href=https://github.com/felixge/fgprof>fgprof</a> برای پیاده‌سازی پروفایل‌گیری دیوار ساعت استفاده می‌شود.</p><p>ویژگی‌های زیر در حال حاضر در دسترس نیستند، اما ممکن است برای پیشنهاد به پروژه Go در آینده جالب باشند:</p><ul><li>شامل کردن ویژگی‌های گوروتین‌هایی که هنوز در دسترس نیستند، به خصوص برچسب‌ها.</li><li>فیلتر کردن بر اساس برچسب‌های pprof، این کار می‌تواند <strong>stop-the-world</strong> را کاهش دهد، اما نیاز به نگهداری اضافی توسط runtime خواهد داشت.</li><li>محدود کردن تعداد گوروتین‌های بازگشتی به یک زیرمجموعه تصادفی، که می‌تواند <strong>stop-the-world</strong> را کاهش دهد و ممکن است پیاده‌سازی آن نسبت به فیلتر بر اساس برچسب آسان‌تر باشد.</li></ul><p>در زیر یک مثال کوتاه از خروجی بازگشتی آورده شده است.</p><pre><code class=language-json>[
  {
    &quot;Stack0&quot;: [
      20629256,
      20629212,
      20627047,
      20628306,
      17018153,
      17235329,
      ...
    ]
  },
  {
    &quot;Stack0&quot;: [
      17019173,
      17222943,
      20628554,
      17235329,
      ...
    ]
  },
  ...
]
</code></pre><p><strong><a href=https://golang.org/pkg/net/http/pprof/><code>net/http/pprof</code></a></strong></p><p>این پکیج پروفایل‌های توصیف‌شده در بخش <a href=https://golang.org/pkg/runtime/pprof/#Lookup><code>pprof.Lookup("goroutine")</code></a> را از طریق endpointهای HTTP فراهم می‌کند. خروجی دقیقاً همان چیزی است که در روش‌های دیگر دیده می‌شود.</p><h4 id=425255-تاریخچه>4.25.2.5.5 تاریخچه
<a class=anchor href=#425255-%d8%aa%d8%a7%d8%b1%db%8c%d8%ae%da%86%d9%87>#</a></h4><p>پروفایل‌گیری گوروتین توسط <a href=https://github.com/rsc>Russ Cox</a> <a href=https://codereview.appspot.com/5687076/>پیاده‌سازی شد</a> و برای اولین بار در نسخه <a href=https://golang.org/doc/devel/weekly.html#2012-02-22>weekly.2012-02-22</a> پیش از انتشار go1 ظاهر شد.</p><h3 id=42526-پروفایلر-threadcreate>4.25.2.6 پروفایلر ThreadCreate
<a class=anchor href=#42526-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%d8%b1-threadcreate>#</a></h3><p>🐞 پروفایل threadcreate برای نمایش استک ترِیس‌هایی طراحی شده که منجر به ایجاد نخ‌های (threads) جدید سیستم‌عامل شده‌اند. با این حال، از سال ۲۰۱۳ <a href=https://github.com/golang/go/issues/6104>خراب شده است</a>، بنابراین بهتر است از آن دوری کنید.</p><h2 id=4253-آموزش-کار-با-ابزار-go-pprof>4.25.3 آموزش کار با ابزار go pprof
<a class=anchor href=#4253-%d8%a2%d9%85%d9%88%d8%b2%d8%b4-%da%a9%d8%a7%d8%b1-%d8%a8%d8%a7-%d8%a7%d8%a8%d8%b2%d8%a7%d8%b1-go-pprof>#</a></h2><p>پروفایلرهای مختلف داخلی در Go برای کار با ابزار بصری‌سازی <a href=https://github.com/google/pprof>pprof</a> طراحی شده‌اند. pprof خود یک پروژه غیررسمی از گوگل است که برای تحلیل داده‌های پروفایل‌گیری از برنامه‌های C++، Java و Go طراحی شده است. این پروژه یک فرمت پروتکل بافر را تعریف می‌کند که توسط تمام پروفایلرهای Go استفاده می‌شود و در این سند توضیح داده شده است.</p><p>پروژه Go خود یک نسخه از pprof را <a href=https://github.com/golang/go/tree/master/src/cmd/pprof>به‌همراه</a> دارد که می‌توان آن را از طریق دستور <code>go tool pprof</code> فراخوانی کرد. این ابزار تا حد زیادی با ابزار اصلی مشابه است، به‌جز چند تغییر جزئی. Go توصیه می‌کند که برای کار با پروفایل‌های Go همیشه از <code>go tool pprof</code> به‌جای ابزار اصلی استفاده شود.</p><h3 id=42531-ویژگیها>4.25.3.1 ویژگی‌ها
<a class=anchor href=#42531-%d9%88%db%8c%da%98%da%af%db%8c%d9%87%d8%a7>#</a></h3><p>ابزار pprof دارای یک رابط خط فرمان تعاملی است، اما همچنین یک رابط کاربری وب و گزینه‌های مختلف فرمت خروجی دیگر نیز دارد.</p><h3 id=42532-فرمت-فایل>4.25.3.2 فرمت فایل
<a class=anchor href=#42532-%d9%81%d8%b1%d9%85%d8%aa-%d9%81%d8%a7%db%8c%d9%84>#</a></h3><p>فرمت pprof در تعریف پروتکل بافر <a href=https://github.com/google/pprof/blob/master/proto/profile.proto>profile.proto</a> تعریف شده است که شامل نظرات مفیدی است. علاوه بر این، یک <a href=https://github.com/google/pprof/blob/master/proto/README.md>README</a> رسمی برای آن وجود دارد. فایل‌های pprof همیشه با فشرده‌سازی gzip در دیسک ذخیره می‌شوند.</p><p>یک تصویر به اندازه هزار کلمه می‌ارزد، بنابراین در زیر یک تجسم خودکار <a href=https://github.com/seamia/protodot>تولید شده</a> از این فرمت قرار داده شده است. لطفاً توجه داشته باشید که فیلدهایی مانند <code>filename</code> اشاره‌گرهایی به <code>string_table</code> هستند که در تجسم نشان داده نمی‌شوند و بهبودهای این حوزه خوش‌آمد است!</p><center><a href=#><img src=../../assets/img/content/chapter4/profiling/10.png alt=profile></a></center><h3 id=42533-فرمت-دادههای-pprof>4.25.3.3 فرمت داده‌های pprof
<a class=anchor href=#42533-%d9%81%d8%b1%d9%85%d8%aa-%d8%af%d8%a7%d8%af%d9%87%d9%87%d8%a7%db%8c-pprof>#</a></h3><p>فرمت داده‌های pprof به نظر می‌رسد که برای کارایی، زبان‌های مختلف و انواع پروفایل‌های مختلف (CPU، Heap و غیره) طراحی شده است، اما به دلیل این موضوع، بسیار انتزاعی و پر از اشاره‌گری است. اگر می‌خواهید جزئیات کامل را مشاهده کنید، به لینک‌های بالا مراجعه کنید. اگر به دنبال <strong>خلاصه‌ای مختصر</strong> هستید، ادامه دهید:</p><p>یک فایل pprof شامل فهرستی از <strong>پشته‌های تراشه</strong> است که به آن‌ها نمونه‌ها گفته می‌شود و یک یا چند <strong>مقدار</strong> عددی با آن‌ها مرتبط است. برای یک پروفایل CPU، مقدار ممکن است مدت زمان CPU در نانوثانیه باشد که پشته تراشه در طول پروفایل‌سازی مشاهده شده است. برای یک پروفایل Heap، ممکن است تعداد بایت‌های تخصیص‌یافته باشد. <strong>نوع‌های مقداری</strong> خود در ابتدای فایل توصیف شده و برای پر کردن فهرست &ldquo;نمونه&rdquo; در رابط کاربری pprof استفاده می‌شوند. علاوه بر مقادیر، هر پشته تراشه می‌تواند شامل مجموعه‌ای از <strong>برچسب‌ها</strong> نیز باشد. برچسب‌ها زوج‌های کلید-مقدار هستند و حتی می‌توانند شامل واحد نیز باشند. در Go، این برچسب‌ها برای <a href=https://rakyll.org/profiler-labels/>برچسب‌های پروفایلر</a> استفاده می‌شوند.</p><p>این پروفایل همچنین شامل <strong>زمان</strong> (در UTC) است که پروفایل ثبت شده و <strong>مدت زمان</strong> ضبط را نشان می‌دهد.</p><p>علاوه بر این، فرمت امکان استفاده از <strong>عبارات منظم drop/keep</strong> برای حذف یا شامل کردن برخی از پشته‌های تراشه را فراهم می‌کند، اما آن‌ها <a href=https://github.com/golang/go/blob/go1.15.6/src/runtime/pprof/proto.go#L375-L376>توسط Go استفاده نمی‌شوند</a>. همچنین فضایی برای فهرستی از <strong>نظرات</strong> (<a href="https://github.com/golang/go/search?q=tagProfile_Comment">توسط Go نیز استفاده نمی‌شود</a>) و توصیف <strong>فاصله</strong> دوره‌ای که در آن نمونه‌ها گرفته شده‌اند وجود دارد.</p><p>کد تولید خروجی pprof در Go در <a href=https://github.com/golang/go/blob/go1.15.6/src/runtime/pprof/proto.go>runtime/pprof/proto.go</a> موجود است.</p><h3 id=42534-رمزگشایی-decoding>4.25.3.4 رمزگشایی (Decoding)
<a class=anchor href=#42534-%d8%b1%d9%85%d8%b2%da%af%d8%b4%d8%a7%db%8c%db%8c-decoding>#</a></h3><p>در زیر تعدادی ابزار برای رمزگشایی فایل‌های pprof به خروجی متنی قابل خواندن انسان آورده شده است. آن‌ها بر اساس پیچیدگی فرمت خروجی خود مرتب شده‌اند، به طوری که ابزارهایی که خروجی ساده‌تری ارائه می‌دهند ابتدا فهرست شده‌اند:</p><h3 id=42535-استفاده-از-pprofutils>4.25.3.5 استفاده از <code>pprofutils</code>
<a class=anchor href=#42535-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-pprofutils>#</a></h3><p><a href=https://github.com/felixge/pprofutils>pprofutils</a> ابزاری کوچک برای تبدیل بین فایل‌های pprof و فرمت متنی جمع شده Brendan Gregg است (<a href=https://github.com/brendangregg/FlameGraph#2-fold-stacks>folded text</a>). می‌توانید از آن به صورت زیر استفاده کنید:</p><pre><code class=language-bash>$ pprof2text &lt; examples/cpu/pprof.samples.cpu.001.pb.gz

golang.org/x/sync/errgroup.(*Group).Go.func1;main.run.func2;main.computeSum 19
golang.org/x/sync/errgroup.(*Group).Go.func1;main.run.func2;main.computeSum;runtime.asyncPreempt 5
runtime.mcall;runtime.gopreempt_m;runtime.goschedImpl;runtime.schedule;runtime.findrunnable;runtime.stopm;runtime.notesleep;runtime.semasleep;runtime.pthread_cond_wait 1
runtime.mcall;runtime.park_m;runtime.schedule;runtime.findrunnable;runtime.checkTimers;runtime.nanotime;runtime.nanotime1 1
runtime.mcall;runtime.park_m;runtime.schedule;runtime.findrunnable;runtime.stopm;runtime.notesleep;runtime.semasleep;runtime.pthread_cond_wait 2
runtime.mcall;runtime.park_m;runtime.resetForSleep;runtime.resettimer;runtime.modtimer;runtime.wakeNetPoller;runtime.netpollBreak;runtime.write;runtime.write1 7
runtime.mstart;runtime.mstart1;runtime.sysmon;runtime.usleep 3
</code></pre><h3 id=42536-استفاده-از-go-tool-pprof>4.25.3.6 استفاده از <code>go tool pprof</code>
<a class=anchor href=#42536-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-go-tool-pprof>#</a></h3><p>خود <code>pprof</code> دارای یک حالت خروجی به نام <code>-raw</code> است که محتوای یک فایل pprof را نمایش می‌دهد. با این حال، باید توجه داشت که این حالت آنچنان <code>-raw</code> نیست که می‌توان به آن رسید، به <code>protoc</code> زیر نگاه کنید:</p><pre><code class=language-bash>$ go tool pprof -raw examples/cpu/pprof.samples.cpu.001.pb.gz

PeriodType: cpu nanoseconds
Period: 10000000
Time: 2021-01-08 17:10:32.116825 +0100 CET
Duration: 3.13
Samples:
samples/count cpu/nanoseconds
         19  190000000: 1 2 3
          5   50000000: 4 5 2 3
          1   10000000: 6 7 8 9 10 11 12 13 14
          1   10000000: 15 16 17 11 18 14
          2   20000000: 6 7 8 9 10 11 18 14
          7   70000000: 19 20 21 22 23 24 14
          3   30000000: 25 26 27 28
Locations
     1: 0x1372f7f M=1 main.computeSum /Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/cpu/main.go:39 s=0
     2: 0x13730f2 M=1 main.run.func2 /Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/cpu/main.go:31 s=0
     3: 0x1372cf8 M=1 golang.org/x/sync/errgroup.(*Group).Go.func1 /Users/felix.geisendoerfer/go/pkg/mod/golang.org/x/sync@v0.0.0-20201207232520-09787c993a3a/errgroup/errgroup.go:57 s=0
     ...
Mappings
1: 0x0/0x0/0x0   [FN]
</code></pre><h3 id=42537-استفاده-از-protoc>4.25.3.7 استفاده از <code>protoc</code>
<a class=anchor href=#42537-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-protoc>#</a></h3><p>برای کسانی که به دنبال دیدن داده‌ها نزدیک به ذخیره‌سازی باینری خام هستند، ما به کامپایلر پروتکل بافر <code>protoc</code> نیاز داریم. در macOS می‌توانید از <code>brew install protobuf</code> برای نصب آن استفاده کنید، برای سایر پلتفرم‌ها به بخش نصب <a href=https://github.com/protocolbuffers/protobuf#protocol-compiler-installation>README</a> مراجعه کنید.</p><p>حالا بیایید به همان پروفایل CPU از بالا نگاهی بیندازیم:</p><pre><code class=language-bash>$ gzcat examples/cpu/pprof.samples.cpu.001.pb.gz | protoc --decode perftools.profiles.Profile ./profile.proto

sample_type {
  type: 1
  unit: 2
}
sample_type {
  type: 3
  unit: 4
}
sample {
  location_id: 1
  location_id: 2
  location_id: 3
  value: 19
  value: 190000000
}
sample {
  location_id: 4
  location_id: 5
  location_id: 2
  location_id: 3
  value: 5
  value: 50000000
}
...
mapping {
  id: 1
  has_functions: true
}
location {
  id: 1
  mapping_id: 1
  address: 20393855
  line {
    function_id: 1
    line: 39
  }
}
location {
  id: 2
  mapping_id: 1
  address: 20394226
  line {
    function_id: 2
    line: 31
  }
}
...
function {
  id: 1
  name: 5
  system_name: 5
  filename: 6
}
function {
  id: 2
  name: 7
  system_name: 7
  filename: 6
}
...
string_table: &quot;&quot;
string_table: &quot;samples&quot;
string_table: &quot;count&quot;
string_table: &quot;cpu&quot;
string_table: &quot;nanoseconds&quot;
string_table: &quot;main.computeSum&quot;
string_table: &quot;/Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/cpu/main.go&quot;
...
time_nanos: 1610122232116825000
duration_nanos: 3135113726
period_type {
  type: 3
  unit: 4
}
period: 

10000000
</code></pre><p>این دستورات به ما این امکان را می‌دهند که ساختارهای ورودی و مقادیر خود را مشاهده کنیم، به ما کمک می‌کنند تا در نهایت فرمت را بهتر درک کنیم.</p><h3 id=42538-استفاده-از-nethttppprof-پروفایلینگ-ریموت>4.25.3.8 استفاده از net/http/pprof پروفایلینگ ریموت
<a class=anchor href=#42538-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-nethttppprof-%d9%be%d8%b1%d9%88%d9%81%d8%a7%db%8c%d9%84%db%8c%d9%86%da%af-%d8%b1%db%8c%d9%85%d9%88%d8%aa>#</a></h3><p>امکان دیباگ سرویس با استفاده از pprof برروی <code>http.Server</code> یا سایر وب سرورها. شما می توانید از پکیج <a href=https://pkg.go.dev/net/http/pprof@go1.23.2><code>net/http/pprof</code></a> استفاده کنید اما دقت کنید ۲ مسئله وجود دارد باید در نظر بگیرید هنگام استفاده:</p><ol><li>زمانیکه این پکیج را در هر جایی از پروژه خود فراخوانی کنید تابع <code>init()</code> داخل پکیج اجرا می شود و خودکار به <code>http.Handler</code> سرور mux اضافه می شود و نیازی به ریجستر کردن handler نیست اما اگر web framework های دیگر را استفاده میکنید باید بصورت دستی استفاده کنید.</li><li>امکان اینکه پکیج pprof قابلیت configuration شدن را داشته باشد ندارد و اطلاعات دیباگ خیلی حساس هستند اگر سرویس شما روی پروداکشن هست ممکن است اطلاعات حساسی بیرون درز دهد, به عنوان مثال <code>debug/pprof/cmdline</code> اطلاعات flag, switch هایی که سرویس شما اجرا شده است را نمایش می دهد و در صورتیکه فلگی داشته باشید شامل اطلاعات حساسی نظیر secret key, password و&mldr; باشد دیده می شود.</li></ol><p>برای مورد دوم راه حلی داریم که می توانید جلو خودکار ریجستر شدن handler های pprof را بگیرید و موارد مورد نیاز را ریجستر کنید.</p><blockquote class="book-hint info"><p>برای مورد دوم راه حلی داریم که می توانید جلو خودکار ریجستر شدن handler های pprof را بگیرید و موارد مورد نیاز را ریجستر کنید.</p><p>به نمونه کد زیر توجه کنید:</p><pre><code class=language-go>package main  
  
import (  
    &quot;flag&quot;  
    &quot;fmt&quot;    &quot;github.com/PacViewer/synker/internal/logger&quot;    _ &quot;go.uber.org/automaxprocs&quot;  
    &quot;net/http&quot;    &quot;net/http/pprof&quot;)  
  
var (  
    pprofAddr      *string  
)  
  
func init() {  
    pprofAddr = flag.String(&quot;pprof-addr&quot;, &quot;&quot;, &quot;start pprof on server&quot;)  
    flag.Parse()  
  
    // init disables default pprof handlers registered by importing net/http/pprof.  
    // Your pprof is showing (https://mmcloughlin.com/posts/your-pprof-is-showing)    
    http.DefaultServeMux = http.NewServeMux()  
}  
  
func main() {  
    log := logger.DefaultLogger  
  
    if *pprofAddr != &quot;&quot; {  
       mux := http.NewServeMux()  
       mux.HandleFunc(&quot;/debug/pprof/&quot;, pprof.Index)  
       mux.HandleFunc(&quot;/debug/pprof/profile&quot;, pprof.Profile)  
       mux.HandleFunc(&quot;/debug/pprof/symbol&quot;, pprof.Symbol)  
       mux.HandleFunc(&quot;/debug/pprof/trace&quot;, pprof.Trace)  
  
       sv := &amp;http.Server{  
          Addr:    *pprofAddr,  
          Handler: mux,  
       }  
  
       log.Info(&quot;pprof listened&quot;, &quot;addr&quot;, fmt.Sprintf(&quot;http://%s/debug/pprof&quot;, *pprofAddr))  
       go func() {  
          if err := sv.ListenAndServe(); err != nil {  
             log.Fatal(&quot;failed to listen pprof server&quot;, &quot;err&quot;, err)  
          }  
       }()  
    }  
}
</code></pre></blockquote><p>پس از اینکه <code>net/http/pprof</code> را ریجستر کردید برروی سرور روی روت <code>/debug/pprof</code> در دسترس است.</p><center><a href=#><img src=../../assets/img/content/chapter4/profiling/11.png alt=pprof></a></center><h3 id=42539-دستورات-pprof>4.25.3.9 دستورات pprof
<a class=anchor href=#42539-%d8%af%d8%b3%d8%aa%d9%88%d8%b1%d8%a7%d8%aa-pprof>#</a></h3><p>در زیر ما یکسری دستوارت کاربردی pprof را معرفی میکنیم که میتوانید بصورت visualization اطلاعات پروفایل را در لوکال یا ریموت ببینید.</p><h4 id=425391-دیدن-cpu-profile-آنلاین-روی-لوکال>4.25.3.9.1 دیدن CPU Profile آنلاین روی لوکال
<a class=anchor href=#425391-%d8%af%db%8c%d8%af%d9%86-cpu-profile-%d8%a2%d9%86%d9%84%d8%a7%db%8c%d9%86-%d8%b1%d9%88%db%8c-%d9%84%d9%88%da%a9%d8%a7%d9%84>#</a></h4><p>برای دیدن اطلاعات CPU Profile بصورت آنلاین روی لوکال دستور زیر را بزنید:</p><pre><code class=language-shell>go tool pprof -http=:8081 http://localhost:8080/debug/pprof/profile
</code></pre><center><a href=#><img src=../../assets/img/content/chapter4/profiling/12.png alt="cpu profile"></a></center><h4 id=425392-دیدن-memory-profile-آنلاین-روی-لوکال>4.25.3.9.2 دیدن Memory Profile آنلاین روی لوکال
<a class=anchor href=#425392-%d8%af%db%8c%d8%af%d9%86-memory-profile-%d8%a2%d9%86%d9%84%d8%a7%db%8c%d9%86-%d8%b1%d9%88%db%8c-%d9%84%d9%88%da%a9%d8%a7%d9%84>#</a></h4><p>برای دیدن اطلاعات Memory Profile بصورت آنلاین روی لوکال دستور زیر را بزنید:</p><ul><li><strong>دیدن allocation ها</strong></li></ul><pre><code class=language-shell>go tool pprof -http=:8081 http://localhost:8080/debug/pprof/allocs
</code></pre><center><a href=#><img src=../../assets/img/content/chapter4/profiling/13.png alt="memory allocs profile"></a></center><ul><li><strong>دیدن heap ها</strong></li></ul><pre><code class=language-shell>go tool pprof -http=:8081 http://localhost:8080/debug/pprof/heap
</code></pre><center><a href=#><img src=../../assets/img/content/chapter4/profiling/13.png alt="heap profile"></a></center><p>برای دیدن در قالب flame graph می توانید به آدرس زیر برروید:</p><pre><code class=language-shell>http://localhost:8082/ui/flamegraph
</code></pre><center><a href=#><img src=../../assets/img/content/chapter4/profiling/15.png alt="flame graph"></a></center><h4 id=425393-گرفتن-خروجی-pdf-png-svg>4.25.3.9.3 گرفتن خروجی pdf, png, svg
<a class=anchor href=#425393-%da%af%d8%b1%d9%81%d8%aa%d9%86-%d8%ae%d8%b1%d9%88%d8%ac%db%8c-pdf-png-svg>#</a></h4><p>برای اینکه بتوانید از اطلاعات profiling خروجی فایل بگیرید دستور زیر را بزنید.</p><ul><li><strong>PDF</strong></li></ul><pre><code class=language-shell>go tool pprof -pdf heap_profile.pprof
</code></pre><ul><li><strong>SVG</strong></li></ul><pre><code class=language-shell>go tool pprof -svg heap_profile.pprof
</code></pre><ul><li><strong>PNG</strong></li></ul><pre><code class=language-shell>go tool pprof -png heap_profile.pprof
</code></pre><h3 id=42539-نتیجهگیری>4.25.3.9 نتیجه‌گیری
<a class=anchor href=#42539-%d9%86%d8%aa%db%8c%d8%ac%d9%87%da%af%db%8c%d8%b1%db%8c>#</a></h3><p>مدیریت کارآمد حافظه در Go، به همراه ابزارهای پروفایل‌سازی‌اش، به توسعه‌دهندگان پلتفرمی قوی برای ساخت برنامه‌های کارآمد ارائه می‌دهد. با درک رفتار حافظه در Go و پروفایل‌سازی منظم برنامه خود، می‌توانید اطمینان حاصل کنید که این برنامه حتی در بارهای سنگین نیز کارآمد و پاسخگو باقی می‌ماند.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/GoFarsi/book/edit/main/content/chapter%204/4.25-profiling.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt>
<span>این صفحه را ویرایش کنید</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script><div class="text-left page-navigation"><a href=/chapter-5/>فصل پنجم: برنامه نویسی شبکه با گو ◀︎</a></div><script>function toggleTooltip(e){e.classList.toggle("active")}</script><div id=graphcomment></div><script type=text/javascript>var __semio__params={graphcommentId:"book",behaviour:{}};function __semio__onload(){__semio__gc_graphlogin(__semio__params)}(function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.onload=__semio__onload,e.defer=!0,e.src="https://integration.graphcomment.com/gc_graphlogin.js?"+Date.now(),(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content></br><main><div class=wrapper><a href=https://t.me/GolangEngineers class="icon telegram" target=_blank><div class=tooltip>گروه تلگرامی مهندسین گولنگ</div><span><i class="fab fa-telegram"></i></span>
</a><a href=https://linkedin.com/in/Ja7ad class="icon linkedin" target=_blank><div class=tooltip>لینکدین نویسنده</div><span><i class="fab fa-linkedin"></i></span>
</a><a href=https://twitter.com/Ja7adR class="icon twitter" target=_blank><div class=tooltip>توییتر نویسنده</div><span><i class="fab fa-twitter"></i></span></a></div></main></br></br><nav id=TableOfContents><ul><li><ul><li><a href=#4251-مدل-ذهنی-mental-برای-go>4.25.1 مدل ذهنی (mental) برای Go</a><ul><li><a href=#42511-زمانبند-scheduler-گوروتین>4.25.1.1 زمان‌بند (scheduler) گوروتین</a></li><li><a href=#42512-زباله-جمع-کن-garbage-collector>4.25.1.2 زباله جمع کن (Garbage Collector)</a></li></ul></li><li><a href=#4252-درک-عمیق-پروفایلرهای-profilers-گو>4.25.2 درک عمیق پروفایلرهای (Profilers) گو</a><ul><li><a href=#42521-پروفایلر-cpu>4.25.2.1 پروفایلر CPU</a></li><li><a href=#42522-پروفایلر-حافظه-memory>4.25.2.2 پروفایلر حافظه (Memory)</a></li><li><a href=#42523-پروفایلر-بلاک>4.25.2.3 پروفایلر بلاک</a></li><li><a href=#42524-پروفایلر-mutex>4.25.2.4 پروفایلر Mutex</a></li><li><a href=#42525-پروفایلر-goroutine>4.25.2.5 پروفایلر Goroutine</a></li><li><a href=#42526-پروفایلر-threadcreate>4.25.2.6 پروفایلر ThreadCreate</a></li></ul></li><li><a href=#4253-آموزش-کار-با-ابزار-go-pprof>4.25.3 آموزش کار با ابزار go pprof</a><ul><li><a href=#42531-ویژگیها>4.25.3.1 ویژگی‌ها</a></li><li><a href=#42532-فرمت-فایل>4.25.3.2 فرمت فایل</a></li><li><a href=#42533-فرمت-دادههای-pprof>4.25.3.3 فرمت داده‌های pprof</a></li><li><a href=#42534-رمزگشایی-decoding>4.25.3.4 رمزگشایی (Decoding)</a></li><li><a href=#42535-استفاده-از-pprofutils>4.25.3.5 استفاده از <code>pprofutils</code></a></li><li><a href=#42536-استفاده-از-go-tool-pprof>4.25.3.6 استفاده از <code>go tool pprof</code></a></li><li><a href=#42537-استفاده-از-protoc>4.25.3.7 استفاده از <code>protoc</code></a></li><li><a href=#42538-استفاده-از-nethttppprof-پروفایلینگ-ریموت>4.25.3.8 استفاده از net/http/pprof پروفایلینگ ریموت</a></li><li><a href=#42539-دستورات-pprof>4.25.3.9 دستورات pprof</a></li><li><a href=#42539-نتیجهگیری>4.25.3.9 نتیجه‌گیری</a></li></ul></li></ul></li></ul></nav></div></aside></main><button onclick=topFunction() id=myBtn title="رفتن به بالا" class="fas fa-solid fa-arrow-up"></button>
<script src=prism.js defer></script><script>document.getElementById("currentsv").innerHTML=window.location.href</script><script async>var html=document.documentElement,switcher=document.getElementsByClassName("js-toggle")[0];typeof Storage!="undefined"&&((localStorage.getItem("themeMode")=="dark"||document.documentElement.getAttribute("data-theme")=="dark")&&switcher.classList.add("js-toggle--checked"),switcher.classList.add("js-toggle--focus")),switcher.addEventListener("click",function(){this.classList.toggle("js-toggle--checked"),this.classList.add("js-toggle--focus"),this.classList.contains("js-toggle--checked")?(html.setAttribute("data-theme","dark"),localStorage.setItem("themeMode","dark")):(html.setAttribute("data-theme","light"),localStorage.setItem("themeMode","light"))})</script><script>let mybutton=document.getElementById("myBtn");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?mybutton.style.display="block":mybutton.style.display="none"}function topFunction(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script src=/js/playground.js defer></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js defer></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-go.min.js defer></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/line-numbers/prism-line-numbers.min.js defer></script><script>"serviceWorker"in navigator&&window.addEventListener("DOMContentLoaded",function(){navigator.serviceWorker.register("/sw.js")})</script></body></html>