<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><author/><title>صفحه اصلی on زبان گو فارسی</title><link>https://book.gofarsi.ir/</link><description>Recent content in صفحه اصلی on زبان گو فارسی</description><generator>Hugo -- gohugo.io</generator><language>fa</language><copyright>2023 GoFarsi All rights reserved</copyright><atom:link href="https://book.gofarsi.ir/feed.xml" rel="self" type="application/rss+xml"/><item><author/><title>پیشگفتار</title><link>https://book.gofarsi.ir/preface/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/preface/</guid><description>&lt;ul>
&lt;li>
&lt;p>چرا از گو استفاده می‌کنیم؟&lt;/p>
&lt;p>وقتی در نوامبر سال ۲۰۰۹ رابرت گریسیمر، راب پایک و کن تامپسون برای اولین‌بار گو را بصورت عمومی انتشار دادند، خودشان مطمئن نبودند که به‌صورت گسترده مورد استفاده قرار می‌گیرد یا خیر. تا به تاریخ انتشار این مطلب، مشخص شده،‌گو بسیار فراگیرتر و رشد آن در صنعت وسیع‌تر از چیزی بوده‌است که ایجادکنندگان آن حدس می‌زدند.
این‌ها نمونه‌هایی از کاربرد گو در دنیای امروز تکنولوژی هستند:&lt;/p>
&lt;ul>
&lt;li>Google’s Core Data Solutions Team Uses Go
تیم راهکار هسته‌ی داده گوگل از گو استفاده می‌کند&lt;/li>
&lt;li>Chrome Content Optimization Service Runs on Go
سرویس بهینه‌سازی محتوا در گوگل‌کروم توسط گو در حال اجراست&lt;/li>
&lt;li>Chrome’s user experience strategy, operating in the critical path for users is implemented in Go
استراتژی حیاتی تجربه کاربری در کروم توسط گو پیاده‌سازی شده است&lt;/li>
&lt;li>Firebase Hosting Team Scaled With Go
ابزار قدرتمند فایربیس توسط گو گسترش یافته است
همچنین در صفحه رسمی گو می‌توانید لیستی از شرکت‌ها از Netflix و PayPal تا Uber و Microsoft رو به‌همراه خدماتی که از گو گرفته‌اند رو ملاحظه کنید.
&lt;a href="https://go.dev/solutions/#case-studies">https://go.dev/solutions/#case-studies&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>شناخت نیازمندی و ابزارهای پیاده‌سازی وابسته به آن.&lt;/p>
&lt;ul>
&lt;li>Cloud &amp;amp; Network Services&lt;/li>
&lt;li>Command-line Interfaces&lt;/li>
&lt;li>Web Development&lt;/li>
&lt;li>DevOps &amp;amp; Site Reliability&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>انواع منابع موجود جهت کسب اطلاعات و مقایسه‌ی آن‌ها.&lt;/p>
&lt;ul>
&lt;li>منابع مکتوب.
&lt;ul>
&lt;li>سایت رسمی زبان گو. &lt;a href="https://go.dev">https://go.dev&lt;/a> در نسخه حال‌حاضر وب‌سایت رسمی گو، مستندات لازم برای شناخت انواع جزئیات وجود دارد. ضمن‌اینکه یک خودآموز مختصر، جهت آشنایی ابتدایی مفاهیم را می‌توانید پیدا کنید.&lt;/li>
&lt;li>کتاب‌ها. اصولاً استفاده از کتاب‌ها بدلیل اینکه عمدتاً توسط اساتید، متخصصین شناخته‌شده نگارش می‌شود، توصیه می‌گردد. ضمن اینکه کتاب‌ها معمولاً امکان اصلاحات مستمر و انتشار نسخه‌های جدید و به‌روزتر رو دارا هستند و توسط ناشران معتبر منتشر می‌شوند.&lt;/li>
&lt;li>مقالات. بدلیل راحت‌تر بودن نشر مقالات، طبیعتاً امکان وجود هرنوع مطلبی با هر سطح و کیفیتی از محتوا وجود دارد. بنابراین، در استفاده از این نوع منابع، احتیاط و حساسیت بالاتری مورد نیاز است.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>منابع صوتی و تصویری. مزیت بزرگ این نوع از منابع، سرعت و امکانات کافی در انتقال مطلب است. اما اشکالی که وجود دارد عدم امکان ساده‌ی اصلاح محتوا و به‌روزرسانی آن است. ضمن‌اینکه این نوع از منابع، مانند مقالات توسط افراد مختلف و با طیفی از انواع کیفیت‌های متفاوت، وجود دارد.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>بررسی وضعیت منابع فارسی زبان گو در زمان تهیه این کتاب.
درحال‌حاضر منابع نگارشی با کیفیت مناسب به‌زبان فارسی بسیار محدود است. این یکی از دلایل «چرایی» نگارش این کتاب به‌زبان فارسی است. ما امیدواریم با مشارکت همه اساتید و متخصصین این حوزه، این کتاب منبع آموزشی باکیفیت، دردسترس عموم متقاضیان، جهت توسعه ابزارهای حرفه‌ای با زبان گو باشد.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>چرا به زبان فارسی می‌نویسیم.
دوستان و همکاران بسیاری هستند،‌که این سوال را مطرح می‌کنند که وقتی نیاز به دانش زبان انگلیسی، برای کسب مهارت در این تخصص، یک «باید» محسوب می‌شود، چرا مطلب فارسی؟
جواب این سوال ساده‌تر از پیچیدگی‌هایی هست که بنظر می‌رسد:
− ایجاد و رونق جامعه تخصصی فارسی‌زبان توسط موضوع «کتاب»
− ایجاد فضایی جهت ایجاد پرسش و پاسخ فارسی‌زبان‌ها
− ارائه یک ترجمه فارسی، از منابع اصلی تخصصی، با امکان مقایسه برداشت افراد مختلف از زبان تخصصی
− سرعت دادن به یادگیری، حداقل در مفاهیم ابتدایی
− برای نوجوانان و افرادی که به‌هر دلیل، درحال‌حاضر تسلط کافی روی زبان انگلیسی ندارند و ارائه راهکار جهت تمرین و شروع یادگیری منابع روی زبان تخصصی&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>برای چگونگی نگارش کتاب می‌توان به موارد زیر اشاره کرد:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>چگونه از جامعه تخصصی، می‌توان در آموزش،بهینه‌سازی و رشد دانش متقاضیان این تخصص استفاده کرد.
یکی از وظایف هر استاد، تربیت «شاگرد» و توسعه دانش است. افراد تازه‌کار با دانش و تجربه پیشکسوتان، با سرعت و کیفیت بالاتر، تبدیل به متخصصین جدید خواهند شد. کیفیت جامعه متخصصین، امکان کنترل مصرف منابع و تولید ابزارهای مفید را تعیین خواهد کرد.
کار تیمی، به فرهنگ «با هم کار کردن» نیازمند است.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>چرخ را از نو نسازیم، تجربه‌ها را از نو «تجربه» نکنیم، آموزش ببینیم و آموزش بدهیم.
با کمی دقت و تجربه، کاملاً بدیهی‌ست در مقام قیاس بین چند جامعه تخصصی همسان، برتری از آن کسانی‌ست که در انتقال دانش-تجربه دست‌و‌دل‌بازتر هستند. جامعه تخصصی با دانش و تجربه عمیق، نیازمند وجود «مبتدیان» با پتانسیل حداکثری است و این میسر نیست مگر با جریان ساده و پایدار آموزش.
دانش امروز، در هر رشته و هر سطح برآیند «انتقال» پیشینیان ما است. به جای غرور ناشی از آن می‌توان از انتقال آن به دیگران لذت برد.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>«کلمات» قدرت دارند. به درک و استفاده از کلمات احترام بگذاریم. در جامعه تخصصی حتی چند‌برابر !!!
تا جای ممکن، در استفاده از کلمات تخصصی در محل درست خود دقت شده تا مفهوم نادرست منتقل نشود. از شما خواننده عزیز هم تقاضا داریم، هرکجا ایرادی هرچند کوچک ملاحظه فرمودید، به ما اطلاع دهید یا درخواست اصلاح آن را ارسال کنید.&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><author/><title>تاریخچه</title><link>https://book.gofarsi.ir/history/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/history/</guid><description>&lt;p>زبان گو (Go) در سال ۲۰۰۷ (به شمسی: ۱۳۸۶) توسط «شرکت گوگل» با هدف افزایش بهره‌وری برنامه‌نویسی در محیط چندهسته‌ای، رایانه‌های شبکه‌ای و کدبیس‌های بزرگ طراحی شد [&lt;a href="https://fa.wikipedia.org/wiki/%DA%AF%D9%88_%28%D8%B2%D8%A8%D8%A7%D9%86_%D8%A8%D8%B1%D9%86%D8%A7%D9%85%D9%87%E2%80%8C%D9%86%D9%88%DB%8C%D8%B3%DB%8C%29">به نقل از ویکی‌پدیا&lt;/a>] و سپس به عنوان یک زبان کامپایلری و تایپ استاتیک در نوامبر سال ۲۰۰۹ به‌صورت عمومی با هدف &lt;span class="tooltip" data-tooltip="efficient compilation" ontouchend="toggleTooltip(this)">کامپایل کارآمد&lt;/span>
، &lt;span class="tooltip" data-tooltip="efficient execution" ontouchend="toggleTooltip(this)">اجرای کارآمد&lt;/span>
و &lt;span class="tooltip" data-tooltip="ease of programming" ontouchend="toggleTooltip(this)">سهولت برنامه‌نویسی&lt;/span>
عرضه شد. بسیاری از اعضای تیم طراحی و توسعه زبان گو [&lt;a href="https://en.wikipedia.org/wiki/Ken_Thompson">Ken Thompson&lt;/a>, &lt;a href="https://en.wikipedia.org/wiki/Rob_Pike">Rob Pike&lt;/a>, &lt;a href="https://en.wikipedia.org/wiki/Robert_Griesemer">Robert Griesemer&lt;/a>] سال‌ها تجربه در زمینه تحقیق و توسعه زبان برنامه‌نویسی دارند.&lt;/p>
&lt;p>تاریخچه زبان گولنگ به سال ۲۰۰۷ میلادی برمیگردد.وقتی که سه برنامه‌نویس تصمیم گرفتند یک زبان برنامه‌نویسی جدید با ترکیبی از ویژگی‌های مختلف را توسعه دهند. هدف آنها این بود که زبانی سریع، ساده، قابل استفاده و مؤثر برای توسعه نرم‌افزارهای همزمان و مقیاس‌پذیر بسازند.&lt;/p>
&lt;p>گولنگ از زبان‌هایی چون pascal، c و oberon الهام گرفته است. هدف توسعه دهندگان گولنگ ساده‌تر کردن فرایند طراحی و ساخت نرم افزارهای مقایس‌پذیر بوده.
آن‌ها در طراحی گولنگ تلاش کردند تا عملکرد زبان را بهبود بخشند و یک سینتکس ساده و خوانا ارائه دهند.&lt;/p>
&lt;p>از آن زمان تا به امروز، گولنگ رشد و پیشرفت چشمگیری کرده است و استفاده از آن در صنعت نرم‌افزار روز به روز بیشتر می‌شود. شرکت‌های بزرگی مانند Google، Dropbox، YouTube و Docker از گولنگ به عنوان یکی از زبان‌های اصلی خود استفاده می‌کنند. همچنین جامعه برنامه‌نویسی گولنگ به طور فزاینده‌ای در حال رشد است و ابزارها و کتابخانه‌های زیادی با استقاده از گولنگ توسعه داده شده است.&lt;/p>
&lt;p>زبان گو دارای یک سری ویژگی‌های منحصر به فرد می‌باشد و برخی از ویژگی‌هایش از سایر زبان‌ها الهام گرفته شده است :&lt;/p>
&lt;ul>
&lt;li>پشتیبانی از برنامه‌نویسی  &lt;span class="tooltip" data-tooltip="Concurrency" ontouchend="toggleTooltip(this)">همزمانی&lt;/span>
بصورت Built-in &lt;/li>
&lt;li> &lt;span class="tooltip" data-tooltip="Goroutine" ontouchend="toggleTooltip(this)">گوروتین&lt;/span>
‌ها امکان اجرای همزمانی توابع را فراهم می‌کنند و همچنین گوروتین‌ها واقعا خیلی سبک هستند به طوری که شما می‌توانید هزاران گوروتین را همزمان در سخت افزارهای مدرن بدون هیچ مشکل عملکردی اجرا کنید. سایز اولیه یک گروتین بین 2 تا 3 کیلوبایت است، در صورتی که سایز اولیه یک ترد معمولا از 1 تا 2 مگابایت شروع می شود. این حافظه از استک تخصیص داده می شود.&lt;/li>
&lt;li>&lt;span class="tooltip" data-tooltip="Channel" ontouchend="toggleTooltip(this)">کانال&lt;/span>
‌ها برپایه مدل CSP می‌باشد که امکان همگام سازی داده‌ها بین گوروتین‌ها را فراهم می‌کند.&lt;/li>
&lt;li>پشتیبانی از تایپ‌های map و slice&lt;/li>
&lt;li>امکان پیاده سازی &lt;span class="tooltip" data-tooltip="Polymorphism" ontouchend="toggleTooltip(this)">پلی مورفیسم&lt;/span>
با استفاده از &lt;span class="tooltip" data-tooltip="Interface" ontouchend="toggleTooltip(this)">اینترفیس&lt;/span>
‌ها&lt;/li>
&lt;li>پوینترها&lt;/li>
&lt;li>&lt;span class="tooltip" data-tooltip="Closures" ontouchend="toggleTooltip(this)">کلوژر&lt;/span>
توابع (یک تابع معمولی که داخل یک تابع دیگر به عنوان &lt;span class="tooltip" data-tooltip="return" ontouchend="toggleTooltip(this)">بازگشت&lt;/span>
تعریف می‌شود)&lt;/li>
&lt;li>&lt;span class="tooltip" data-tooltip="Method" ontouchend="toggleTooltip(this)">متدها&lt;/span>
&lt;/li>
&lt;li>امکان defer برای تعویق فراخوانی یک تابع&lt;/li>
&lt;li>قابلیت &lt;span class="tooltip" data-tooltip="Embedding" ontouchend="toggleTooltip(this)">جاسازی&lt;/span>
تایپ‌ها&lt;/li>
&lt;li>ایمنی حافظه در زبان گو&lt;/li>
&lt;li>قابلیت &lt;span class="tooltip" data-tooltip="Garbage Collector" ontouchend="toggleTooltip(this)">زباله جمع کن&lt;/span>
خودکار&lt;/li>
&lt;li>سازگاری کامل با انواع پلتفرم‌ها نظیر [linux, windows, mac, AIX, android, freeBSD] جهت توسعه و کامپایل&lt;/li>
&lt;li>امکان Cross-compile با این امکان می‌توانید در هر پلتفرمی برای سایر پلتفرم‌ها کامپایل کنید&lt;/li>
&lt;li>پشتیبانی از &lt;span class="tooltip" data-tooltip="Generics" ontouchend="toggleTooltip(this)">جنریک&lt;/span>
یا تایپ پارامتر (از نسخه ۱.۱۸)&lt;/li>
&lt;li>تست نویسی آسان&lt;/li>
&lt;li>&lt;span class="tooltip" data-tooltip="Interface" ontouchend="toggleTooltip(this)">اینترفیس&lt;/span>
و &lt;span class="tooltip" data-tooltip="Reflection" ontouchend="toggleTooltip(this)">رفلکشن&lt;/span>
&lt;/li>
&lt;li>زبان گو برخلاف زبان‌هایی نظیر c, cpp یا java نیاز به نقطه ویرگول (Semicolons) ندارد و به نسبت زبان‌هایی که معرفی کردیم پرانتز کمتری استفاده می‌کند و همچنین ظاهر سینتکس گو خیلی خواناتر و راحت‌تر می‌باشد.&lt;/li>
&lt;/ul>
&lt;p>علاوه بر ویژگی‌هایی که در بالا معرفی کردیم یک سری نکات برجسته در خصوص زبان گو وجود دارد که به شرح زیر می‌باشند:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>سینتکس این زبان به گونه‌ای ساده و تمیز طراحی شده که فرآیند یادگیری آن را آسان‌تر می‌کند و از همه مهم‌تر توسعه پروژه‌های &lt;span class="tooltip" data-tooltip="Scale up" ontouchend="toggleTooltip(this)">مقیاس‌پذیر&lt;/span>
با زبان گو به دلیل سادگی و آشکار بودن مفاهیم خیلی سریع‌تر صورت می‌گیرد.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>زبان گو دارای تعداد زیادی &lt;span class="tooltip" data-tooltip="Standard packages" ontouchend="toggleTooltip(this)">پکیج‌های استاندارد&lt;/span>
و کاربردی جهت توسعه می‌باشد که همه این پکیج‌ها در انواع پلتفرم‌ها جهت توسعه قابل استفاده است.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>زبان گو دارای یک جامعه بزرگ از توسعه دهندگان و انجمن‌های فعال می‌باشد که خیلی سریع می‌توانید به پاسخ سوالات خود برسید.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;blockquote class="book-hint info">
برنامه نویس‌های زبان گو را &lt;span class="tooltip" data-tooltip="Gopher" ontouchend="toggleTooltip(this)">گوفر&lt;/span>
صدا می‌زنند.
گوفر نام یک نوع موش و همچنین نماد گولنگ است.
&lt;/blockquote></description></item><item><author/><title>چرا زبان Go؟</title><link>https://book.gofarsi.ir/why-go/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/why-go/</guid><description>&lt;p>زبان Go (یا Golang) با تأکید بر &lt;strong>سادگی سینتکسی، سرعت بالا، و پشتیبانی قوی از همزمانی&lt;/strong>، گزینه‌ای بی‌نظیر برای توسعه‌دهندگان و تیم‌های مهندسی نرم‌افزار به‌شمار می‌آید. Go با بهره‌گیری از &lt;strong>کامپایل سریع و استاتیک&lt;/strong>، اجرای باینری‌های مستقل با سرعتی نزدیک به زبان‌های سطح پایین را ممکن می‌سازد. یکی از برجسته‌ترین قابلیت‌های آن، مدل درون‌ساختاری همزمانی مبتنی بر &lt;strong>goroutine&lt;/strong> و &lt;strong>channel&lt;/strong> است که پردازش موازی با مصرف حافظه بهینه را تسهیل می‌کند. علاوه بر این، وجود &lt;strong>جمع‌آوری خودکار حافظه (GC)&lt;/strong> و مجموعه ابزار استاندارد (از جمله go fmt، go test، go doc و…) روند توسعه را شفاف و قابل‌پیش‌بینی می‌کند. با پشتوانه رسمی گوگل و پذیرش گسترده در پروژه‌های ابری، زیرساخت‌ها و شرکت‌های مطرح (مثل Docker، Kubernetes، Uber)، Go به ابزاری کلیدی در اکوسیستم مدرن توسعه نرم‌افزار تبدیل شده است.&lt;/p>
&lt;h2 id="-۱-سادگی-و-خوانایی-دقیق-در-طراحی-زبان">
🎯 ۱. &lt;strong>سادگی و خوانایی دقیق در طراحی زبان&lt;/strong>
&lt;a class="anchor" href="#-%db%b1-%d8%b3%d8%a7%d8%af%da%af%db%8c-%d9%88-%d8%ae%d9%88%d8%a7%d9%86%d8%a7%db%8c%db%8c-%d8%af%d9%82%db%8c%d9%82-%d8%af%d8%b1-%d8%b7%d8%b1%d8%a7%d8%ad%db%8c-%d8%b2%d8%a8%d8%a7%d9%86">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>Go برای افرادی طراحی شده که به دنبال زبانی با سینتکسی ساده و بدون پیچیدگی‌های مرسوم هستند. نحو آن الهام‌گرفته از خانواده C است اما خبری از ساختارهای پیچیده‌ای مثل «وراثت کلاسیک» نیست.&lt;/p>
&lt;ul>
&lt;li>این سادگی کمک می‌کند توسعه‌دهنده بتواند زبان را در عرض یک روز یاد بگیرد و سریع وارد برنامه‌نویسی واقعی شود (&lt;a href="https://appliedgo.net/why-go/" title="15 Reasons I Love Go - Applied Go">Applied Go&lt;/a>).&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>ابزار یکپارچه &lt;code>go fmt&lt;/code> استانداردسازی کد را تضمین می‌کند و باعث می‌شود تیم‌ها همیشه بر روی قالب یکسانی کد بزنند (&lt;a href="https://sariasan.com/featured/go-programming-language/" title="زبان برنامه نویسی go (معرفی، کاربردها، معایب و مزایا) - سریع آسان">Sariasan&lt;/a>, &lt;a href="https://en.wikipedia.org/wiki/Go_%28programming_language%29" title="Go (programming language)">Wikipedia&lt;/a>).&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="-۲-سرعت-در-کامپایل-و-اجرا">
⚡ ۲. &lt;strong>سرعت در کامپایل و اجرا&lt;/strong>
&lt;a class="anchor" href="#-%db%b2-%d8%b3%d8%b1%d8%b9%d8%aa-%d8%af%d8%b1-%da%a9%d8%a7%d9%85%d9%be%d8%a7%db%8c%d9%84-%d9%88-%d8%a7%d8%ac%d8%b1%d8%a7">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>Go یک زبان &lt;strong>کامپایل‌شده و دارای تایپ استاتیک&lt;/strong> است—کد مستقیم به باینری اجراشده تبدیل می‌شود، بدون وابستگی به ماشین مجازی. نتیجه: سرعت فوق‌العاده در زمان اجرا.&lt;/li>
&lt;li>در واقع، گوگل با طراحی Go توانست هزاران خط کد را در کمتر از ۱۰ ثانیه کامپایل کند (&lt;a href="https://www.wired.com/2009/11/google-announces-a-new-programming-language-google-go" title="Meet Go, Google&amp;#39;s New Programming Language">WIRED&lt;/a>).&lt;/li>
&lt;/ul>
&lt;h2 id="-۳-همزمانی-قدرتمند-با-goroutines-و-channels">
♾️ ۳. &lt;strong>همزمانی قدرتمند با Goroutines و Channels&lt;/strong>
&lt;a class="anchor" href="#-%db%b3-%d9%87%d9%85%d8%b2%d9%85%d8%a7%d9%86%db%8c-%d9%82%d8%af%d8%b1%d8%aa%d9%85%d9%86%d8%af-%d8%a8%d8%a7-goroutines-%d9%88-channels">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>Go با &lt;strong>goroutine&lt;/strong>‌ها (ریسمان‌های سبُک‌وزن) و &lt;strong>channel&lt;/strong>هایی برای ارتباط امن بین آنها، همزمانی را در سطح زبان نهادینه کرده (&lt;a href="https://blog.faradars.org/why-should-you-learn-go/" title="چرا باید زبان برنامه نویسی Go را بیاموزیم؟ — راهنمای جامع - مجله فرادرس">Faradars Blog&lt;/a>).&lt;/li>
&lt;li>این ساختار، اجرای میلیون‌ها goroutine را با استفاده‌ی بسیار کمتر از حافظه امکان‌پذیر می‌سازد — برخلاف thread‌های سنگین جاوا — که مناسب سرویس‌های مقیاس‌پذیر و پرکار است (&lt;a href="https://www.uptech.team/blog/why-use-golang-for-your-project" title="Best practices: Why use Golang for your project - UPTech Team">uptech.team&lt;/a>, &lt;a href="https://sariasan.com/featured/go-programming-language/" title="زبان برنامه نویسی go (معرفی، کاربردها، معایب و مزایا) - سریع آسان">Sariasan&lt;/a>).&lt;/li>
&lt;li>فلسفه Go در همزمانی این است: «با ارتباط بین حافظه به اشتراک‌گذاری انجام می‌شود، نه با اشتراک‌گذاری حافظه» (&lt;a href="https://sariasan.com/featured/go-programming-language/" title="زبان برنامه نویسی go (معرفی، کاربردها، معایب و مزایا) - سریع آسان">Sariasan&lt;/a>).&lt;/li>
&lt;/ul>
&lt;h2 id="-۴-مدیریت-حافظه-خودکار-garbage-collection">
🧠 ۴. &lt;strong>مدیریت حافظه خودکار (Garbage Collection)&lt;/strong>
&lt;a class="anchor" href="#-%db%b4-%d9%85%d8%af%db%8c%d8%b1%db%8c%d8%aa-%d8%ad%d8%a7%d9%81%d8%b8%d9%87-%d8%ae%d9%88%d8%af%da%a9%d8%a7%d8%b1-garbage-collection">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>Go مجهز به سیستم &lt;strong>جمع‌آوری زباله (GC)&lt;/strong> داخلی است که حافظه را به‌صورت خودکار آزاد می‌کند. این موضوع باعث افزایش بهره‌وری و کاهش پیچیدگی برای توسعه‌دهندگان می‌شود، بدون کاهش محسوس کارایی (&lt;a href="https://www.mobinhost.com/mag/go-programming-language/" title="زبان برنامه نویسی Go، زبانی برای سرعت، کارایی و امنیت - مبین هاست">مبین هاست&lt;/a>).&lt;/li>
&lt;/ul>
&lt;h2 id="-۵-کتابخانه-استاندارد-کامل-و-ابزارهای-توسعه">
📚 ۵. &lt;strong>کتابخانه استاندارد کامل و ابزارهای توسعه&lt;/strong>
&lt;a class="anchor" href="#-%db%b5-%da%a9%d8%aa%d8%a7%d8%a8%d8%ae%d8%a7%d9%86%d9%87-%d8%a7%d8%b3%d8%aa%d8%a7%d9%86%d8%af%d8%a7%d8%b1%d8%af-%da%a9%d8%a7%d9%85%d9%84-%d9%88-%d8%a7%d8%a8%d8%b2%d8%a7%d8%b1%d9%87%d8%a7%db%8c-%d8%aa%d9%88%d8%b3%d8%b9%d9%87">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>زبان Go همراه با مجموعه استاندارد بزرگی از کتابخانه‌های داخلی برای مواردی مانند تست، قالب‌سازی، همگام‌سازی و مدیریت بسته است (&lt;a href="https://quera.org/blog/golang-explained/" title="گولنگ چیست ؟ - بررسی مزایا، معایب و کاربردهای زبان برنامه‌نویسی Go">Quera&lt;/a>).&lt;/li>
&lt;li>ابزارهایی مانند &lt;code>go build&lt;/code>, &lt;code>go test&lt;/code>, &lt;code>go vet&lt;/code>, &lt;code>go doc&lt;/code> و پروفایل‌سازی/debugging داخلی، محیطی حرفه‌ای برای تمام سطوح توسعه را فراهم می‌کنند (&lt;a href="https://en.wikipedia.org/wiki/Go_%28programming_language%29" title="Go (programming language)">Wikipedia&lt;/a>).&lt;/li>
&lt;/ul>
&lt;h2 id="-۶-پشتوانه-گوگل-و-اکوسیستم-بالغ">
🏢 ۶. &lt;strong>پشتوانه گوگل و اکوسیستم بالغ&lt;/strong>
&lt;a class="anchor" href="#-%db%b6-%d9%be%d8%b4%d8%aa%d9%88%d8%a7%d9%86%d9%87-%da%af%d9%88%da%af%d9%84-%d9%88-%d8%a7%da%a9%d9%88%d8%b3%db%8c%d8%b3%d8%aa%d9%85-%d8%a8%d8%a7%d9%84%d8%ba">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>Go در ۲۰۰۷ توسط راب گرایسمر، راب پایک و کن تامپسون در گوگل طراحی شد و در سال ۲۰۱۲ به نسخه ۱.۰ رسید. گوگل هنوز از آن در زیرساخت‌های بزرگ خود بهره می‌برد (&lt;a href="https://jobvision.ir/blog/go-developer-recruitment/" title="بررسی کاربرد زبان go، میزان درآمد و بازار کار آن - جاب ویژن">JobVision&lt;/a>).&lt;/li>
&lt;li>اکوسیستم متنوعی از شرکت‌های بزرگ مثل Docker، Kubernetes، Uber، Dropbox، Netflix و … از Go استفاده می‌کنند (&lt;a href="https://www.mytaskpanel.com/go-programming-language/" title="Go programming language: utilities, characteristics and advantages">mytaskpanel.com&lt;/a>).&lt;/li>
&lt;/ul>
&lt;h2 id="-۷-مقیاسپذیری-طبیعی-برای-زیرساختها-و-کلاد-نیتیو">
🧩 ۷. &lt;strong>مقیاس‌پذیری طبیعی برای زیرساخت‌ها و کلاد نیتیو&lt;/strong>
&lt;a class="anchor" href="#-%db%b7-%d9%85%d9%82%db%8c%d8%a7%d8%b3%d9%be%d8%b0%db%8c%d8%b1%db%8c-%d8%b7%d8%a8%db%8c%d8%b9%db%8c-%d8%a8%d8%b1%d8%a7%db%8c-%d8%b2%db%8c%d8%b1%d8%b3%d8%a7%d8%ae%d8%aa%d9%87%d8%a7-%d9%88-%da%a9%d9%84%d8%a7%d8%af-%d9%86%db%8c%d8%aa%db%8c%d9%88">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>طراحی نیتیو Go برای &lt;strong>شبکه، موازی‌سازی، پردازش سرویس&lt;/strong> باعث شده گزینه‌ای بسیار مناسب برای توسعه برنامه‌های &lt;strong>میکروسرویس، ابزارهای DevOps&lt;/strong> و &lt;strong>سرویس‌های ابری&lt;/strong> باشد (&lt;a href="https://www.mobinhost.com/mag/go-programming-language/" title="زبان برنامه نویسی Go، زبانی برای سرعت، کارایی و امنیت - مبین هاست">مبین هاست&lt;/a>, &lt;a href="https://sariasan.com/featured/go-programming-language/" title="زبان برنامه نویسی go (معرفی، کاربردها، معایب و مزایا) - سریع آسان">Sariasan&lt;/a>, &lt;a href="https://en.wikipedia.org/wiki/Go_%28programming_language%29" title="Go (programming language)">Wikipedia&lt;/a>).&lt;/li>
&lt;li>پروژه‌های بزرگی مانند &lt;strong>Docker&lt;/strong> و &lt;strong>Kubernetes&lt;/strong> کاملًا با Go نوشته شده‌اند، که نشانه پختگی زبان در حوزه زیرساخت است (&lt;a href="https://www.mobinhost.com/mag/go-programming-language/" title="زبان برنامه نویسی Go، زبانی برای سرعت، کارایی و امنیت - مبین هاست">مبین هاست&lt;/a>, &lt;a href="https://sariasan.com/featured/go-programming-language/" title="زبان برنامه نویسی go (معرفی، کاربردها، معایب و مزایا) - سریع آسان">Sariasan&lt;/a>).&lt;/li>
&lt;/ul>
&lt;h2 id="-منابع-پیشنهادی">
📚 منابع پیشنهادی:
&lt;a class="anchor" href="#-%d9%85%d9%86%d8%a7%d8%a8%d8%b9-%d9%be%db%8c%d8%b4%d9%86%d9%87%d8%a7%d8%af%db%8c">#&lt;/a>
&lt;/h2>
&lt;ol>
&lt;li>مقاله فارسی «مهم‌ترین مزایای زبان برنامه‌نویسی گولنگ چیست؟» در ویرگول (&lt;a href="https://sariasan.com/featured/go-programming-language/" title="زبان برنامه نویسی go (معرفی، کاربردها، معایب و مزایا) - سریع آسان">Sariasan&lt;/a>, &lt;a href="https://en.wikipedia.org/wiki/Go_%28programming_language%29" title="Go (programming language)">Wikipedia&lt;/a>, &lt;a href="https://nikamooz.com/the-future-of-go-programming-language/" title="آینده زبان گو: بررسی ۰ تا ۱۰۰ بازار کار &amp;#43; ۹ مرحله یادگیری - نیک آموز">نیک آموز&lt;/a>, &lt;a href="https://jobvision.ir/blog/go-developer-recruitment/" title="بررسی کاربرد زبان go، میزان درآمد و بازار کار آن - جاب ویژن">JobVision&lt;/a>, &lt;a href="https://quera.org/blog/golang-explained/" title="گولنگ چیست ؟ - بررسی مزایا، معایب و کاربردهای زبان برنامه‌نویسی Go">Quera&lt;/a>)&lt;/li>
&lt;li>بررسی جامع ابزارها و فلسفه همزمانی در ویکی‌پدیا Go (&lt;a href="https://en.wikipedia.org/wiki/Go_%28programming_language%29" title="Go (programming language)">Wikipedia&lt;/a>)&lt;/li>
&lt;li>مقاله evaluate‌شده در Medium درباره سادگی و مدیریت حافظه (&lt;a href="https://medium.com/%40julienetienne/why-go-the-benefits-of-golang-6c39ea6cff7e" title="Why Go: The benefits of Golang - by Julien Etienne - Medium">medium.com&lt;/a>)&lt;/li>
&lt;li>پست رسمی گوگل در Wired (2009) درباره معرفی Go و ویژگی‌های کلیدی (&lt;a href="https://www.wired.com/2009/11/google-announces-a-new-programming-language-google-go" title="Meet Go, Google&amp;#39;s New Programming Language">WIRED&lt;/a>)&lt;/li>
&lt;/ol></description></item><item><author/><title>آموزش نصب</title><link>https://book.gofarsi.ir/installation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/installation/</guid><description>&lt;p>جهت نصب زبان گو بر روی سیستم عامل مورد نظر خود در ابتدا باید نسخه مناسب با پلت‌فرم خود را &lt;a href="https://go.dev/dl/">دانلود&lt;/a> کنید.&lt;/p>
&lt;p>&lt;img src="../assets/img/content/installation/1.png" alt="Featured downloads golang" />&lt;/p>
&lt;p>نکته:&lt;/p>
&lt;p>وب سایت گولنگ ایران را تحریم کرده است و احتمالا برای دانلود کردن گولنگ با مشکل مواجه می شوید. برای اینکه بتوانید تحریم ها را دور بزنید، روش های زیادی وجود دارد. یکی از مرسوم ترین روش ها استفاده از یک سرویس دی ان اس مانند &lt;a href="https://shecan.ir/">شکن&lt;/a> است.&lt;/p>
&lt;div class="book-tabs">&lt;input type="radio" class="toggle" name="tabs-uniqueid" id="tabs-uniqueid-0" checked="checked" />
&lt;label for="tabs-uniqueid-0">لینوکس&lt;/label>
&lt;div class="book-tabs-content markdown-inner">&lt;ol>
&lt;li>در &lt;a href="https://go.dev/dl/">اینجا&lt;/a> نسخه مرتبط با لینوکس خود را دانلود کنید.&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-shell">$ wget -c https://go.dev/dl/go1.xx.x.linux-amd64.tar.gz
&lt;/code>&lt;/pre>
&lt;ol start="2">
&lt;li>سپس دستور زیر را بزنید تا اگر نسخه قبلی وجود دارد پاک شود و نسخه جدید در مسیر &lt;code>usr/local/go/&lt;/code> جایگزین شود.&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-shell">$ sudo rm -rf /usr/local/go &amp;amp;&amp;amp; sudo tar -C /usr/local -xzf go1.xx.x.linux-amd64.tar.gz
&lt;/code>&lt;/pre>
&lt;ol start="3">
&lt;li>افزودن مسیر &lt;code>usr/local/go/bin/&lt;/code> به &lt;span class="tooltip" data-tooltip="environment variable" ontouchend="toggleTooltip(this)">متغیرهای محیطی&lt;/span>&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-shell">export PATH=$PATH:/usr/local/go/bin
&lt;/code>&lt;/pre>
&lt;blockquote class="book-hint info">
بهتر است برای اینکه هر بار ترمینال را باز می‌کنید و فایل go توسط shell شناخته شود دستور فوق را به فایل &lt;code>home/{user}/.profile/&lt;/code> اضافه کنید.
&lt;/blockquote>
&lt;ol start="4">
&lt;li>جهت اطمینان از اینکه زبان گو به‌درستی بر روی سیستم عامل شما نصب شده است دستور زیر را داخل ترمینال بزنید.&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-shell">$ go version
&lt;/code>&lt;/pre>
&lt;/div>&lt;input type="radio" class="toggle" name="tabs-uniqueid" id="tabs-uniqueid-1" />
&lt;label for="tabs-uniqueid-1">ویندوز&lt;/label>
&lt;div class="book-tabs-content markdown-inner">&lt;h2 id="روش-اول">
روش اول
&lt;a class="anchor" href="#%d8%b1%d9%88%d8%b4-%d8%a7%d9%88%d9%84">#&lt;/a>
&lt;/h2>
&lt;ol>
&lt;li>در &lt;a href="https://go.dev/dl/">اینجا&lt;/a> نسخه مرتبط با ویندوز خود را دانلود کنید.&lt;/li>
&lt;li>سپس فایل &lt;strong>go1.xx.x.windows-{arch}.msi&lt;/strong> را اجرا کنید.&lt;/li>
&lt;li>مراحل نصب را به‌صورت پیش فرض طی کنید تا زبان گو برروی ویندوز نصب شود.&lt;/li>
&lt;li>پس از نصب، جهت اطمینان از نصب بودن زبان گو، مراحل زیر را انجام دهید:
&lt;ul>
&lt;li>وارد منو استارت شوید.&lt;/li>
&lt;li>در منو استارت کلمه &lt;strong>cmd&lt;/strong> را جستجو کنید و سپس آن را اجرا کنید.&lt;/li>
&lt;li>داخل &lt;span class="tooltip" data-tooltip="Command prompt" ontouchend="toggleTooltip(this)">خط فرمان&lt;/span>
دستور زیر را بزنید تا از نصب بودن زبان گو اطمینان حاصل فرمایید.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-shell">go version
&lt;/code>&lt;/pre>
&lt;h2 id="روش-دوم">
روش دوم
&lt;a class="anchor" href="#%d8%b1%d9%88%d8%b4-%d8%af%d9%88%d9%85">#&lt;/a>
&lt;/h2>
&lt;p>برای نصب گو می‌توانید از &lt;a href="https://community.chocolatey.org/">Chocolatey Package Manager&lt;/a> استفاده کنید.&lt;/p>
&lt;ol>
&lt;li>خط فرمان PowerShell را به صورت Administrator باز کنید و دستور زیر را داخل PowerShell بزنید.&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-shell">Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))
&lt;/code>&lt;/pre>
&lt;ol start="2">
&lt;li>بعد از نصب می‌توانید از دستور choco برای نصب گو استفاده کنید.&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-shell">choco install golang
&lt;/code>&lt;/pre>
&lt;ol start="3">
&lt;li>جهت اطمینان از اینکه زبان گو به‌درستی بر روی سیستم عامل شما نصب شده است دستور زیر را داخل ترمینال بزنید.&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-shell">$ go version
&lt;/code>&lt;/pre>
&lt;blockquote class="book-hint info">
دقت داشته باشید برای نصب برنامه‌های مختلف مثل git و یا ابزارهای دیگر در محیط Administrator باید از دستور choco استفاده کنید.
&lt;/blockquote>&lt;/div>&lt;input type="radio" class="toggle" name="tabs-uniqueid" id="tabs-uniqueid-2" />
&lt;label for="tabs-uniqueid-2">مکینتاش&lt;/label>
&lt;div class="book-tabs-content markdown-inner">&lt;h2 id="روش-اول">
روش اول
&lt;a class="anchor" href="#%d8%b1%d9%88%d8%b4-%d8%a7%d9%88%d9%84">#&lt;/a>
&lt;/h2>
&lt;ol>
&lt;li>در &lt;a href="https://go.dev/dl/">اینجا&lt;/a> نسخه مرتبط با مکینتاش خود را دانلود کنید.&lt;/li>
&lt;li>سپس فایل &lt;strong>go1.xx.x.darwin-{arch}.pkg&lt;/strong> را اجرا کنید.&lt;/li>
&lt;li>مراحل نصب را به‌صورت پیش فرض طی کنید تا زبان گو برروی مکینتاش نصب شود.&lt;/li>
&lt;li>پس از نصب اگر ترمینال باز بود آن را کامل ببندید تا تغییرات صورت گیرد.&lt;/li>
&lt;li>جهت اطمینان از اینکه زبان گو به‌درستی بر روی سیستم عامل شما نصب شده است دستور زیر را داخل ترمینال بزنید.&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-shell">$ go version
&lt;/code>&lt;/pre>
&lt;h2 id="روش-دوم">
روش دوم
&lt;a class="anchor" href="#%d8%b1%d9%88%d8%b4-%d8%af%d9%88%d9%85">#&lt;/a>
&lt;/h2>
&lt;p>برای نصب گو میتوانید از &lt;a href="https://brew.sh/">Homebrew Package Manager&lt;/a> استفاده کنید.&lt;/p>
&lt;ol>
&lt;li>برای نصب brew می‌توانید ترمینال خود را باز کنید و از دستور زیر استفاده کنید.&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-shell">$ /bin/bash -c &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&amp;quot;
&lt;/code>&lt;/pre>
&lt;ol start="2">
&lt;li>بعد از نصب brew از دستور زیر برای نصب گو داخل ترمینال استفاده کنید.&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-shell">$ brew update &amp;amp;&amp;amp; brew install golang
&lt;/code>&lt;/pre>
&lt;ol start="3">
&lt;li>جهت اطمینان از اینکه زبان گو به‌درستی بر روی سیستم عامل شما نصب شده است، دستور زیر را داخل ترمینال بزنید.&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-shell">$ go version
&lt;/code>&lt;/pre>&lt;/div>&lt;/div></description></item><item><author/><title>ابزارها, دستورات گو و معرفی IDE</title><link>https://book.gofarsi.ir/toolchain/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/toolchain/</guid><description>&lt;p>پس از اینکه زبان گو را برروی سیستم خود نصب کردید از طریق &lt;span class="tooltip" data-tooltip="Terminal" ontouchend="toggleTooltip(this)">ترمینال&lt;/span>
و یا &lt;span class="tooltip" data-tooltip="Command prompt" ontouchend="toggleTooltip(this)">خط فرمان&lt;/span>
ویندوز قابل دسترس است که می‌توانید با زدن کلمه &lt;code>go&lt;/code> یکسری عملیات انجام دهید:&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go
Go is a tool for managing Go source code.
Usage:
go &amp;lt;command&amp;gt; [arguments]
The commands are:
bug start a bug report
build compile packages and dependencies
clean remove object files and cached files
doc show documentation for package or symbol
env print Go environment information
fix update packages to use new APIs
fmt gofmt (reformat) package sources
generate generate Go files by processing source
get add dependencies to current module and install them
install compile and install packages and dependencies
list list packages or modules
mod module maintenance
work workspace maintenance
run compile and run Go program
test test packages
tool run specified go tool
version print Go version
vet report likely mistakes in packages
Use &amp;quot;go help &amp;lt;command&amp;gt;&amp;quot; for more information about a command.
Additional help topics:
buildconstraint build constraints
buildmode build modes
c calling between Go and C
cache build and test caching
environment environment variables
filetype file types
go.mod the go.mod file
gopath GOPATH environment variable
gopath-get legacy GOPATH go get
goproxy module proxy protocol
importpath import path syntax
modules modules, module versions, and more
module-get module-aware go get
module-auth module authentication using go.sum
packages package lists and patterns
private configuration for downloading non-public code
testflag testing flags
testfunc testing functions
vcs controlling version control with GOVCS
Use &amp;quot;go help &amp;lt;topic&amp;gt;&amp;quot; for more information about that topic.
&lt;/code>&lt;/pre>
&lt;h2 id="جدول-دستورات-commands">
جدول دستورات (Commands)
&lt;a class="anchor" href="#%d8%ac%d8%af%d9%88%d9%84-%d8%af%d8%b3%d8%aa%d9%88%d8%b1%d8%a7%d8%aa-commands">#&lt;/a>
&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>دستور&lt;/th>
&lt;th>توضیحات&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>build&lt;/td>
&lt;td>با این دستور (&lt;code>go build main.go&lt;/code>) می‌توانید فایل &lt;code>go&lt;/code> را کامپایل کنید.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>clean&lt;/td>
&lt;td>با این دستور می‌توانید فایل‌های کش‌شده را پاکسازی کنید.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>doc&lt;/td>
&lt;td>با این دستور (&lt;code>go doc fmt.Println&lt;/code>) می‌توانید داکیومنت هر یک از توابع عمومی را ببینید.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>env&lt;/td>
&lt;td>با این دستور می‌توانید &lt;span class="tooltip" data-tooltip="environment variable" ontouchend="toggleTooltip(this)">متغیرهای محیطی&lt;/span>
تنظیم شده زبان گو را ببینید و آن‌ها را با دستور &lt;code>go env -w key=value&lt;/code> مقداردهی کنید.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>fmt&lt;/td>
&lt;td>با این دستور می‌توانید کدهای خود را مرتب &lt;code>go fmt ./...&lt;/code> کنید.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>install&lt;/td>
&lt;td>با استفاده از این دستور می‌توانید یکسری پکیج‌ها را گرفته و کامپایل کنید.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>list&lt;/td>
&lt;td>لیست پکیج‌ها و ماژول‌های دانلود شده.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>generate&lt;/td>
&lt;td>با این دستور می‌توانید از قابلیت Generator زبان گو استفاده کنید و فایل generate کنید.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>mod&lt;/td>
&lt;td>برای مدیریت و ایجاد فایل mod به ازای هر پروژه.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>get&lt;/td>
&lt;td>با این دستور می‌توانید پکیجی را دانلود یا بروزرسانی کنید و همچنین برای استفاده از این دستور نیاز به &lt;code>git&lt;/code> دارید که نصب باشد.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>work&lt;/td>
&lt;td>با این دستور می‌توانید یک workspace ایجاد کنید و آن را مدیریت کنید.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>run&lt;/td>
&lt;td>با این دستور (&lt;code>go run main.go&lt;/code>) می‌توانید فایل‌های گو یا پروژه را اجرا کنید.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>test&lt;/td>
&lt;td>با این دستور (&lt;code>go test example_test.go&lt;/code>) می‌توانید فایل‌های تست را اجرا کنید.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>version&lt;/td>
&lt;td>با این دستور می‌توانید نسخه نصب شده زبان گو را ببینید.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>vet&lt;/td>
&lt;td>با این دستور می‌توانید اشتباهات کدهای خود را ببینید.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="اجرای-کد-ساده-در-زبان-گو">
اجرای کد ساده در زبان گو
&lt;a class="anchor" href="#%d8%a7%d8%ac%d8%b1%d8%a7%db%8c-%da%a9%d8%af-%d8%b3%d8%a7%d8%af%d9%87-%d8%af%d8%b1-%d8%b2%d8%a8%d8%a7%d9%86-%da%af%d9%88">#&lt;/a>
&lt;/h2>
&lt;p>در زیر یک نمونه کد ساده قرار دادیم که به سادگی می‌توانید با دستور &lt;code>go run main.go&lt;/code> اجرا کنید و خروجی را ببینید.&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import &amp;quot;fmt&amp;quot;
func main() {
fmt.Println(&amp;quot;Hello world!!!&amp;quot;)
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-shell">$ go run main.go
Hello world!!!
&lt;/code>&lt;/pre>
&lt;p>در کد فوق، ما یکسری &lt;span class="tooltip" data-tooltip="keyword" ontouchend="toggleTooltip(this)">کلید واژه&lt;/span>
نظیر package , import , func استفاده کردیم که در بخش &lt;a href="https://book.gofarsi.ir/chapter-1/go-built-in-keywords-identifiers/">1.2 کلید واژه و شناسه‌ها&lt;/a> با آن‌ها آشنا می‌شوید.&lt;/p>
&lt;h2 id="انواع-نرمافزارهای-محیط-توسعه-ide-و-ویرایشگر-کد-code-editor">
انواع نرم‌افزارهای محیط توسعه (IDE) و ویرایشگر کد (Code Editor)
&lt;a class="anchor" href="#%d8%a7%d9%86%d9%88%d8%a7%d8%b9-%d9%86%d8%b1%d9%85%d8%a7%d9%81%d8%b2%d8%a7%d8%b1%d9%87%d8%a7%db%8c-%d9%85%d8%ad%db%8c%d8%b7-%d8%aa%d9%88%d8%b3%d8%b9%d9%87-ide-%d9%88-%d9%88%db%8c%d8%b1%d8%a7%db%8c%d8%b4%da%af%d8%b1-%da%a9%d8%af-code-editor">#&lt;/a>
&lt;/h2>
&lt;p>در زبان برنامه‌نویسی گو نیز مثل سایر زبان‌ها، می‌توان از ابزارهای کدنویسی مانند &lt;span class="tooltip" data-tooltip="IDE(s)" ontouchend="toggleTooltip(this)">نرم‌افزارهای محیط توسعه&lt;/span>
و همچنین از &lt;span class="tooltip" data-tooltip="Code Editor(s)" ontouchend="toggleTooltip(this)">ویرایشگرهای کد&lt;/span>
استفاده کرد که محبوب‌ترین‌ها معرفی می‌شوند:&lt;/p>
&lt;ol>
&lt;li>نرم‌افزار &lt;a href="https://www.jetbrains.com/go/">Jetbrains Goland&lt;/a> اگر با سایر محصولات جت‌برینز آشنا باشید به‌راحتی می‌توانید از این &lt;span class="tooltip" data-tooltip="IDE" ontouchend="toggleTooltip(this)">نرم‌افزار محیط توسعه&lt;/span>
استفاده کنید.&lt;/li>
&lt;li>نرم‌افزار &lt;a href="https://code.visualstudio.com/">VsCode&lt;/a> تقریباً همه برنامه‌نویس‌ها با آن آشنا هستند. یک &lt;span class="tooltip" data-tooltip="Code Editor" ontouchend="toggleTooltip(this)">ویرایشگر کد&lt;/span>
متن‌باز می‌باشد که بین برنامه‌نویس‌ها خیلی محبوب است و برای استفاده زبان گو در این نرم‌افزار می‌توان افزونه&lt;a href="https://code.visualstudio.com/docs/languages/go"> vscode-go&lt;/a> را نصب کنید.&lt;/li>
&lt;li>نرم‌افزار &lt;a href="https://www.vim.org/">Vim&lt;/a> یک نرم‌افزار متن‌باز و معروف می‌باشد که داخل &lt;span class="tooltip" data-tooltip="Terminal" ontouchend="toggleTooltip(this)">ترمینال&lt;/span>
قابل استفاده است و از آن می‌توانید جهت توسعه با زبان گو استفاده کنید و البته نیازمند &lt;a href="https://github.com/fatih/vim-go">نصب پلاگین&lt;/a> می‌باشد.&lt;/li>
&lt;/ol></description></item><item><author/><title>نقشه یادگیری زبان گو</title><link>https://book.gofarsi.ir/roadmap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/roadmap/</guid><description>&lt;p>نقشه یادگیری زیر &lt;a href="https://roadmap.sh/">roadmap.sh&lt;/a> به ترتیب مسیر توصیه شده ی یادگیری ابزارها و مفاهیم اولیه گو، سپس سمت سرور و در نهایت معماری نرم افزار را نشان می‌دهد.&lt;/p>
&lt;p>&lt;img src="../assets/img/content/roadmap/go.jpg" alt="roadmap go" />
&lt;img src="../assets/img/content/roadmap/backend.jpg" alt="roadmap backend" />
&lt;img src="../assets/img/content/roadmap/software-design.jpg" alt="software design" />
&lt;img src="../assets/img/content/roadmap/software-architect.jpg" alt="software architect" />&lt;/p></description></item><item><author/><title>نمونه سوالات مصاحبه</title><link>https://book.gofarsi.ir/interview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/interview/</guid><description>&lt;p>در این بخش ما یکسری سوالات مصاحبه به زبان فارسی ارائه دادیم که برای یافتن ضعف‌ها کاربردی می‌باشد.&lt;/p>
&lt;details >&lt;summary>1: چه تایپ‌هایی مقدار zero آن‌ها nil است؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;ul>
&lt;li>interfaces&lt;/li>
&lt;li>slices&lt;/li>
&lt;li>channels&lt;/li>
&lt;li>maps&lt;/li>
&lt;li>pointers&lt;/li>
&lt;li>functions&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>2: تایپ‌های نوع Reference؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;ul>
&lt;li>Pointers&lt;/li>
&lt;li>slices&lt;/li>
&lt;li>maps&lt;/li>
&lt;li>functions&lt;/li>
&lt;li>channels&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>3: تایپ‌های نوع Aggregate؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;ul>
&lt;li>Array&lt;/li>
&lt;li>structs&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>4: چه وقت باید از پوینتر استفاده کنیم؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;p>&lt;strong>1- تابعی که یکی از پارامترهای خود را تغییر می‌دهد&lt;/strong>
-وقتی تابعی را فراخوانی می‌کنیم که یک پوینتر را به عنوان پارامتر می‌گیرد، انتظار داریم که متغیر ما تغییر داده شود. اگر شما متغیر را در تابع خود تغییر نمی‌دهید، پس احتمالا نباید از پوینتر استفاده کنید.&lt;/p>
&lt;p>&lt;strong>2- عملکرد بهتر&lt;/strong>
-اگر رشته‌ای داشته باشید که شامل یک رمان کامل در حافظه باشد، کپی کردن این متغیر هر بار که به یک تابع جدید ارسال می‌شود، کاری بسیار گران است. ممکن است ارزشمند باشد که به جای این کار یک پوینتر را ارسال کنید، که باعث صرفه‌جویی در پردازنده و حافظه می‌شود. با این حال انجام این کار به قیمت خوانا بودن است، بنابراین فقط در صورت لزوم این بهینه‌سازی را انجام دهید.&lt;/p>
&lt;p>&lt;strong>3- به گزینه nil نیاز دارید&lt;/strong>
-گاهی اوقات یک تابع باید بداند که مقدار یک چیزی چیست، همچنین باید وجود یا عدم وجود آن را بداند. معمولا هنگام خواندن JSON از این استفاده می‌کنیم تا بدانیم فیلدی وجود دارد یا خیر.&lt;/p>
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>5: زبان گولنگ از موارد زیر پشتیبانی نمی‌کند؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;ul>
&lt;li>type inheritance&lt;/li>
&lt;li>operator overloading&lt;/li>
&lt;li>method overloading&lt;/li>
&lt;li>pointer arithmetic&lt;/li>
&lt;li>struct type in consts&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>6: برای گوروتین ها چه مواقعی از channel و چه مواقعی از mutex استفاده می شود؟&lt;/summary>
&lt;div class="markdown-inner">
معمولاً در مواقعی که گوروتین ها نیاز به برقراری ارتباط با یکدیگر دارند، از channels استفاده می کنیم. درصورتی که قسمتی از کد ما(برای مثال مقدار متغیری را تغییر می دهیم) که در آن واحد فقط باید یک گوروتین به آن دسترسی داشته باشد، از یک قفل مانند mutext استفاده می کنیم.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>7: تفاوت بین goroutine و thread را توضیح دهید.&lt;/summary>
&lt;div class="markdown-inner">
Goroutines سبک وزن هستند و دارای یک استک اولیه کوچک‌تر که به صورت پویا گسترش می‌یابد هستند، این در حالی است که threads استک ثابت دارند. Goroutines هم‌زمانی را در سطح زبان با استفاده از channelها مدیریت می‌کنند، در حالی که threads ممکن است نیاز به lockهای صریح داشته باشند. همچنین، سوئیچینگ بین goroutines کارایی بیشتری نسبت به thread switching دارد.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>8: توضیح دهید که interface در Golang چیست و چگونه می‌تواند مورد استفاده قرار گیرد.&lt;/summary>
&lt;div class="markdown-inner">
یک interface در Go یک نوع خاص است که مجموعه‌ای از method signatures را تعریف می‌کند. هر نوع داده‌ای که این متدها را پیاده‌سازی کند، می‌تواند به عنوان آن interface مورد استفاده قرار گیرد. این بدون نیاز به ارث بری صورت می‌گیرد و امکان داکتایپینگ را فراهم می‌کند.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>9: چطور می‌توانید memory leak در برنامه‌های نوشته شده به وسیله Golang را شناسایی و مدیریت کنید؟&lt;/summary>
&lt;div class="markdown-inner">
برای شناسایی memory leaks در Golang، می‌توان از ابزارهایی مانند pprof به همراه نمودارهای ساخته شده بر اساس heap dumps استفاده کرد. برای پیشگیری از memory leaks، باید دقت کرد که از داده‌ها به درستی استفاده شود، حافظه رزرو شده آزاد گردد و منابع بسته شوند هنگامی که دیگر نیازی به آنها نیست.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>10: در Golang چگونه می‌توانیم dependency management را انجام دهیم؟&lt;/summary>
&lt;div class="markdown-inner">
Golang از Go Modules برای مدیریت وابستگی‌ها استفاده می‌کند که به توسعه دهندگان امکان می‌دهد پروژه‌ها را به صورت مستقل از GOPATH راحت‌تر مدیریت کنند. با استفاده از دستوراتی مانند &lt;code>go mod init&lt;/code>, &lt;code>go mod tidy&lt;/code>, و &lt;code>go mod vendor&lt;/code> می‌توان وابستگی‌های لازم برای پروژه را مدیریت کرد.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>11: چه زمانی یک channel در Golang باید با buffer مورد استفاده قرار گیرد؟&lt;/summary>
&lt;div class="markdown-inner">
یک channel با buffer زمانی مورد استفاده قرار گیرد که شما می‌خواهید ارتباطات بین goroutines را بدون ایجاد blocking فوری داشته باشید. این امر می‌تواند بازده کدها را در مواقعی که عملیات‌ها از لحاظ عملکرد اندکی نابرابر هستند، بهبود بخشد.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>12: توضیح دهید که defer statement چیست و چرا ممکن است از آن استفاده کنیم.&lt;/summary>
&lt;div class="markdown-inner">
Defer statement برای تضمین اجرای یک تابع مشخص، درست قبل از خارج شدن از تابع فعلی استفاده می‌شود. این برای راحتی در مدیریت منابع مثل بستن فایل‌ها و ارتباطات شبکه استفاده می‌شود که می‌خواهیم اطمینان حاصل کنیم که به‌درستی بسته خواهند شد.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>13: در Golang چگونه می‌توانید اطمینان حاصل کنید که یک goroutine نتیجه‌ای تولید می‌کند قبل از اینکه برنامه کار خود را به طور کامل متوقف کند؟&lt;/summary>
&lt;div class="markdown-inner">
برای اطمینان از اینکه یک goroutine کار خود را به اتمام برساند، معمولا از sync.WaitGroup برای همچین مدیریتی استفاده می‌کنیم. ساختار WaitGroup اجازه می‌دهد تا اصلی‌ترین goroutine صبر کند تا یک یا چند goroutines دیگر کار خود را تمام کنند.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>14: توضیح دهید که واحد ایزوله برای کد نویسی در Golang چیست (table-driven tests) و چرا مفید است.&lt;/summary>
&lt;div class="markdown-inner">
Table-driven tests شیوه‌ای برای نوشتن تست‌ها است که از جداول داده برای تعریف چندین case تست بهره می‌برد. این شیوه مفید است زیرا کد تست را می‌توان برای بسیاری از داده‌ها به راحتی توسعه داد و به خوبی سازماندهی می‌شود.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>15: چرا Go از ارث بری (inheritance) پشتیبانی نمی‌کند و از composition به عنوان جایگزین استفاده می‌کند؟&lt;/summary>
&lt;div class="markdown-inner">
Go ارث بری را پیاده‌سازی نمی‌کند زیرا می‌تواند پیچیده شود و معماری نرم‌افزار را سخت‌تر مدیریت کند. در عوض، از composition استفاده می‌کند که می‌تواند code reuse را تشویق کند و طراحی سیستم را ساده‌تر و ماژولارتر می‌کند.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>16: آیا در Golang می‌توان از polymorphism استفاده کرد؟ اگر بله، چگونه؟&lt;/summary>
&lt;div class="markdown-inner">
بله، در Go می‌توان از polymorphism استفاده کرد از طریق استفاده از interfaces. یک interface می‌تواند برای تعریف یک مجموعه از روش‌ها به کار رود و هر نوع که این روش‌ها را پیاده‌سازی کند به عنوان آن نوع interface شناخته شود.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>17: چه تفاوتی میان make و new در Golang وجود دارد؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;code>make&lt;/code> در Go برای ایجاد sliceها، maps و channels استفاده می‌شود و یک ابجکت از نوع مورد نظر را با مقدار اولیه مشخصی برمی‌گرداند. از طرفی &lt;code>new&lt;/code> یک pointer به یک ابجکت از یک نوع داده‌ای تعریف شده توسط کاربر را برمی‌گرداند که صفر اولیه شده است.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>18: متود (method) receivers در Golang چگونه کار می‌کند و تفاوت بین استفاده از pointer receiver و value receiver چیست؟&lt;/summary>
&lt;div class="markdown-inner">
Method receivers در Go اجازه می‌دهند تا روی نوع معینی از مقادیر عملیات انجام دهیم. استفاده از pointer receiver به ما اجازه می‌دهد تا تغییراتی که در method روی receiver اعمال می‌شوند را بر روی خود آبجکت اصلی اعمال کنیم، در حالیکه استفاده از value receiver یک کپی از مقدار را می‌گیرد و تغییرات او روی کپی صورت می‌گیرد و بر آبجکت اصلی اثر نمی‌گذارد.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>19: چگونه می‌توان در Golang یک پکیج اختصاصی ایجاد کرد و چگونه می‌توان آن را در دیگر فایل‌های Go مورد استفاده قرار داد؟&lt;/summary>
&lt;div class="markdown-inner">
برای ایجاد پکیج اختصاصی در Go، کد مربوطه باید در یک دایرکتوری قرار داده شود و بالای فایل‌های Go باید &lt;code>package mypackage&lt;/code> تعریف شود. برای استفاده از پکیج، &lt;code>import &amp;quot;path/to/mypackage&amp;quot;&lt;/code> باید در دیگر فایل‌ها قرار داده شود.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>20: در Golang، چگونه می‌توانید error handling را اجرا کنید و چه روش‌هایی برای پیاده‌سازی custom error types وجود دارد؟&lt;/summary>
&lt;div class="markdown-inner">
Error handling در Go اغلب از طریق بازگرداندن ارور از توابع و بررسی آنها انجام می‌شود. برای ایجاد custom error types، می‌توانید از &lt;code>errors.New()&lt;/code> برای ایجاد یک ارور ساده استفاده کنید یا یک تایپ که ارور را پیاده‌سازی می‌کند با متدهای اضافی برای داده‌های اضافی مرتبط با ارور ایجاد کرد.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>21: کامپایلر گولنگ از نوع AOT است یا JIT؟ تفاوت بین AOT و JIT را بگو.&lt;/summary>
&lt;div class="markdown-inner">
کامپایلر گو یک Ahead Of Time compilation است. تفاوت AOT با JIT در این است که کامپایلر های AOT مستقیم کد ما را تبدیل به machine code می کنند اما در کامپایتر های JIT کد ما تبدیل به یک کد میانی Bytecode می شود و در زمان اجرا توسط runtime engine هر قسمت از برنامه که مورد استفاده قرار می گیرد، تفسیر می شود و تبدیل به machine code می شود.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>22: تفاوت بین nil و مقدار صفر در انواع داده چیست؟&lt;/summary>
&lt;div class="markdown-inner">
در Go مقدار &lt;strong>nil&lt;/strong> مخصوص انواع reference است (مانند slice, map, channel, function, pointer, interface) و به معنای عدم وجود داده یا ارجاع است.
مقدار صفر (zero value) برای انواع مقداری مانند int، bool، struct و غیره تعریف می‌شود (مثلاً 0 برای int یا false برای bool) و همیشه یک مقدار معتبر است.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>23: تفاوت بین close(channel) و خواندن از یک کانال بسته چیست؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;ul>
&lt;li>&lt;code>close(channel)&lt;/code> تنها برای ارسال‌کننده استفاده می‌شود تا به دریافت‌کننده‌ها اطلاع دهد داده‌ای دیگر ارسال نخواهد شد.&lt;/li>
&lt;li>خواندن از یک کانال بسته مقدار صفر نوع داده را برمی‌گرداند بدون این که بلاک شود.&lt;/li>
&lt;li>ارسال روی کانال بسته &lt;strong>panic&lt;/strong> ایجاد می‌کند.&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>24: چه زمانی باید از context استفاده کنیم؟&lt;/summary>
&lt;div class="markdown-inner">
زمانی که نیاز داریم پردازش‌ها یا درخواست‌های طولانی را لغو کنیم یا timeout بگذاریم، از &lt;code>context.Context&lt;/code> استفاده می‌کنیم. این ابزار برای همگام‌سازی لغو عملیات بین goroutineها و جلوگیری از resource leak بسیار مهم است.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>25: تفاوت sync.Mutex و sync.RWMutex چیست؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;ul>
&lt;li>&lt;code>sync.Mutex&lt;/code> قفل ساده‌ای است که در یک زمان فقط اجازه دسترسی به یک goroutine را می‌دهد.&lt;/li>
&lt;li>&lt;code>sync.RWMutex&lt;/code> دو حالت دارد: قفل خواندن (می‌تواند همزمان توسط چند goroutine گرفته شود) و قفل نوشتن (انحصاری). این باعث بهبود عملکرد در سناریوهایی با خواندن زیاد و نوشتن کم می‌شود.&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>26: data race چیست و چگونه می‌توان از آن جلوگیری کرد؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;strong>Data race&lt;/strong> زمانی رخ می‌دهد که چند goroutine همزمان به یک متغیر مشترک دسترسی پیدا کرده و حداقل یکی از آنها عملیات نوشتن انجام دهد، بدون هماهنگ‌سازی مناسب.
جلوگیری: استفاده از &lt;code>sync.Mutex&lt;/code>، &lt;code>sync.RWMutex&lt;/code>، channelها یا اجتناب از اشتراک داده‌ها. ابزار &lt;code>go run -race&lt;/code> می‌تواند این مشکلات را پیدا کند.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>27: در چه شرایطی slice باعث memory leak می‌شود؟&lt;/summary>
&lt;div class="markdown-inner">
زمانی که slice‌ای کوچک ایجاد می‌کنیم ولی همچنان به یک آرایه بزرگ‌تر در حافظه اشاره دارد، GC نمی‌تواند آرایه اصلی را آزاد کند. راه‌حل: ایجاد یک کپی slice جدید با &lt;code>copy&lt;/code> یا ساختن slice از ابتدا.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>28: تفاوت len و cap در slice چیست؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;ul>
&lt;li>&lt;code>len&lt;/code> تعداد عناصر موجود در slice را برمی‌گرداند.&lt;/li>
&lt;li>&lt;code>cap&lt;/code> ظرفیت slice را برمی‌گرداند، یعنی تعداد عناصر از اندیس صفر تا انتهای آرایه زیرین که می‌توان بدون تخصیص حافظه جدید استفاده کرد.&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>29: آیا map در Go thread-safe است؟&lt;/summary>
&lt;div class="markdown-inner">
خیر. map به صورت پیش‌فرض thread-safe نیست و دسترسی همزمان بدون قفل یا sync.Map باعث panic می‌شود. برای ایمنی، باید از &lt;code>sync.Mutex&lt;/code>، &lt;code>sync.RWMutex&lt;/code> یا &lt;code>sync.Map&lt;/code> استفاده کرد.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>30: چگونه می‌توان یک panic را مدیریت کرد بدون اینکه برنامه متوقف شود؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;p>با استفاده از &lt;code>recover&lt;/code> در داخل یک defer می‌توان panic را گرفتن و از توقف کامل برنامه جلوگیری کرد:&lt;/p>
&lt;pre>&lt;code class="language-go">defer func() {
if r := recover(); r != nil {
fmt.Println(&amp;quot;Recovered:&amp;quot;, r)
}
}()
&lt;/code>&lt;/pre>
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>31: تفاوت بین unbuffered و buffered channel چیست؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;ul>
&lt;li>&lt;strong>Unbuffered channel&lt;/strong>: ارسال‌کننده تا زمانی که دریافت‌کننده آماده نباشد بلاک می‌شود.&lt;/li>
&lt;li>&lt;strong>Buffered channel&lt;/strong>: ارسال‌کننده می‌تواند تا ظرفیت کانال داده بفرستد بدون بلاک شدن. دریافت‌کننده فقط زمانی بلاک می‌شود که کانال خالی باشد.&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>32: چرا نباید از pointer به متغیر loop variable در goroutine استفاده کرد؟&lt;/summary>
&lt;div class="markdown-inner">
چون همه goroutineها به همان آدرس حافظه اشاره می‌کنند که مقدار آن در هر iteration تغییر می‌کند و باعث نتایج غیرمنتظره می‌شود. باید از یک متغیر محلی کپی‌شده استفاده کرد.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>33: تفاوت := و var در تعریف متغیر چیست؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;ul>
&lt;li>&lt;code>:=&lt;/code> فقط در داخل توابع و برای تعریف و مقداردهی اولیه استفاده می‌شود.&lt;/li>
&lt;li>&lt;code>var&lt;/code> در هر جایی (داخل یا بیرون تابع) می‌تواند استفاده شود و امکان تعریف بدون مقدار اولیه (با مقدار صفر) را می‌دهد.&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>34: چه زمانی باید از sync.Once استفاده کنیم؟&lt;/summary>
&lt;div class="markdown-inner">
زمانی که می‌خواهیم یک قطعه کد فقط یک‌بار در کل طول عمر برنامه اجرا شود (مثل بارگذاری تنظیمات یا ایجاد اتصال اولیه).
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>35: تفاوت nil interface و interface حاوی nil چیست؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;ul>
&lt;li>&lt;strong>nil interface&lt;/strong>: مقدار و نوع هر دو nil هستند.&lt;/li>
&lt;li>&lt;strong>interface حاوی nil&lt;/strong>: نوع مشخص شده است ولی مقدار nil است. این تفاوت باعث می‌شود مقایسه مستقیم با nil نتیجه متفاوتی بدهد.&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>36: آیا گوروتین‌ها به صورت موازی اجرا می‌شوند یا همزمانی (Concurrency) دارند؟&lt;/summary>
&lt;div class="markdown-inner">
گوروتین‌ها ذاتاً همزمانی دارند و Go scheduler آنها را روی چندین thread اجرا می‌کند. اگر سیستم چند هسته‌ای باشد و &lt;code>GOMAXPROCS&lt;/code> متناسب تنظیم شده باشد، گوروتین‌ها می‌توانند موازی اجرا شوند.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>37: تفاوت rune و byte چیست؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;ul>
&lt;li>&lt;code>byte&lt;/code> معادل &lt;code>uint8&lt;/code> است و برای نمایش داده‌های خام یا کاراکترهای ASCII استفاده می‌شود.&lt;/li>
&lt;li>&lt;code>rune&lt;/code> معادل &lt;code>int32&lt;/code> است و برای نمایش یک کاراکتر یونیکد استفاده می‌شود.&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>38: چرا استفاده بیش از حد از defer می‌تواند بر عملکرد تأثیر بگذارد؟&lt;/summary>
&lt;div class="markdown-inner">
هر &lt;code>defer&lt;/code> یک فراخوانی اضافه ایجاد می‌کند که در خروج از تابع اجرا می‌شود. در مسیرهای پر فراخوانی (hot path)، این می‌تواند باعث افت کارایی شود. در این موارد بهتر است منابع را به صورت دستی آزاد کرد.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>39: garbage collector در Go چه زمانی اجرا می‌شود؟&lt;/summary>
&lt;div class="markdown-inner">
GC در Go به صورت خودکار و همزمان با اجرای برنامه، بر اساس تخصیص حافظه و فشار heap اجرا می‌شود. این فرآیند stop-the-world بسیار کوتاهی دارد تا حافظه غیرقابل دسترسی را آزاد کند.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>40: آیا slice به صورت مقادیر (value) پاس داده می‌شود یا ارجاع (reference)؟&lt;/summary>
&lt;div class="markdown-inner">
Slice خود یک ساختار کوچک است (pointer به آرایه، طول و ظرفیت) که به صورت value پاس داده می‌شود، ولی اشاره‌گر داخل آن باعث می‌شود به آرایه زیرین ارجاع دهد.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>41: چه زمانی استفاده از map به جای slice بهینه‌تر است؟&lt;/summary>
&lt;div class="markdown-inner">
وقتی که نیاز به دسترسی سریع بر اساس کلیدهای غیر ترتیبی داریم یا جستجوی O(1) می‌خواهیم. در مقابل، slice برای داده‌های ترتیبی کوچک و قابل پیمایش سریع‌تر است.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>42: چگونه می‌توان ظرفیت اولیه یک map را تعیین کرد و چرا این کار مهم است؟&lt;/summary>
&lt;div class="markdown-inner">
با استفاده از &lt;code>make(map[KeyType]ValueType, initialCapacity)&lt;/code> می‌توان ظرفیت اولیه تعیین کرد. این باعث کاهش عملیات rehash و بهبود عملکرد می‌شود.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>43: تفاوت select بدون case و select با default چیست؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;ul>
&lt;li>&lt;code>select {}&lt;/code> بدون case باعث بلاک شدن دائمی گوروتین می‌شود.&lt;/li>
&lt;li>&lt;code>select { default: ... }&lt;/code> بلافاصله default را اجرا می‌کند اگر هیچ کانالی آماده نباشد.&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>44: چرا باید منابع مانند فایل یا connection را در defer بلافاصله بعد از ایجاد آن ببندیم؟&lt;/summary>
&lt;div class="markdown-inner">
این کار تضمین می‌کند که حتی در صورت بروز خطا یا panic، منبع به درستی آزاد شود و از resource leak جلوگیری شود.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>45: تفاوت channel جهت‌دار (send-only/receive-only) با channel دوطرفه چیست؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;ul>
&lt;li>Send-only: &lt;code>chan&amp;lt;- T&lt;/code> فقط اجازه ارسال دارد.&lt;/li>
&lt;li>Receive-only: &lt;code>&amp;lt;-chan T&lt;/code> فقط اجازه دریافت دارد.&lt;/li>
&lt;li>دوطرفه: &lt;code>chan T&lt;/code> می‌تواند هم ارسال و هم دریافت انجام دهد.&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>46: چگونه می‌توان benchmark در Go نوشت و اجرا کرد؟&lt;/summary>
&lt;div class="markdown-inner">
با نوشتن تابع‌هایی با امضای &lt;code>func BenchmarkXxx(b *testing.B)&lt;/code> و اجرای &lt;code>go test -bench=.&lt;/code> می‌توان benchmark گرفت. مقدار &lt;code>b.N&lt;/code> مشخص می‌کند چند بار تست اجرا می‌شود.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>47: sync.Pool چیست و چه کاربردی دارد؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;code>sync.Pool&lt;/code> یک ساختار برای ذخیره و بازیابی موقت اشیاء قابل استفاده مجدد است که فشار روی GC را کاهش می‌دهد. برای داده‌های موقتی که ایجادشان هزینه‌بر است استفاده می‌شود.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>48: تفاوت testing.T و testing.B در پکیج testing چیست؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;ul>
&lt;li>&lt;code>testing.T&lt;/code> برای تست‌های معمولی و مدیریت خطاها استفاده می‌شود.&lt;/li>
&lt;li>&lt;code>testing.B&lt;/code> برای benchmark استفاده می‌شود و شامل حلقه اجرای تکرارها (&lt;code>b.N&lt;/code>) است.&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>49: آیا Go از tail call optimization پشتیبانی می‌کند؟&lt;/summary>
&lt;div class="markdown-inner">
خیر، Go به صورت رسمی tail call optimization ندارد. بنابراین توابع بازگشتی عمیق می‌توانند منجر به مصرف زیاد stack شوند.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>50: چه تفاوتی بین make و append برای ایجاد slice وجود دارد؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;ul>
&lt;li>&lt;code>make&lt;/code> یک slice با طول و ظرفیت مشخص ایجاد می‌کند.&lt;/li>
&lt;li>&lt;code>append&lt;/code> برای افزودن عناصر به slice موجود استفاده می‌شود و در صورت پر بودن ظرفیت، یک آرایه جدید ایجاد می‌کند.&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>51: تفاوت بین زمان‌بندی گوروتین‌ها در Go و threadها در سیستم‌عامل چیست؟&lt;/summary>
&lt;div class="markdown-inner">
Scheduler گوروتین‌ها در Go به صورت &lt;strong>M:N&lt;/strong> کار می‌کند، یعنی تعداد زیادی گوروتین (M) روی تعداد محدودی thread سیستم‌عامل (N) نگاشت می‌شوند. این مدل سبک‌تر از زمان‌بندی مستقیم threadها توسط سیستم‌عامل است.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>52: آیا استفاده از global variable در Go توصیه می‌شود؟ چرا؟&lt;/summary>
&lt;div class="markdown-inner">
به طور کلی خیر، چون باعث کاهش تست‌پذیری، افزایش coupling و خطر data race می‌شود. در صورت نیاز، باید با قفل یا سایر روش‌های همگام‌سازی محافظت شود.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>53: چرا تغییر دادن slice در یک goroutine می‌تواند روی goroutineهای دیگر تأثیر بگذارد؟&lt;/summary>
&lt;div class="markdown-inner">
چون همه sliceها به یک آرایه زیرین اشاره می‌کنند. تغییر عناصر باعث تغییر در آرایه مشترک و در نتیجه مشاهده تغییرات توسط سایر goroutineها می‌شود.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>54: تفاوت string و []byte در Go چیست؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;code>string&lt;/code> غیرقابل تغییر (immutable) است و تغییر مستقیم آن ممکن نیست. &lt;code>[]byte&lt;/code> قابل تغییر است و برای عملیات پردازشی روی داده‌ها بهینه‌تر است.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>55: چرا map در Go iteration order ثابت ندارد؟&lt;/summary>
&lt;div class="markdown-inner">
برای جلوگیری از وابستگی برنامه‌ها به ترتیب کلیدها و بهبود کارایی، Go عمداً ترتیب پیمایش map را تصادفی می‌کند.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>56: چه زمانی باید از atomic operations استفاده کرد؟&lt;/summary>
&lt;div class="markdown-inner">
زمانی که نیاز به عملیات خواندن/نوشتن thread-safe روی انواع عددی یا آدرس حافظه داریم، بدون استفاده از قفل‌های سنگین مانند Mutex. پکیج &lt;code>sync/atomic&lt;/code> برای این منظور استفاده می‌شود.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>57: تفاوت nil slice با empty slice چیست؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;ul>
&lt;li>Nil slice: &lt;code>nil&lt;/code> است، طول و ظرفیت صفر دارد.&lt;/li>
&lt;li>Empty slice: مقدار غیر nil با طول صفر است، ولی به یک آرایه صفر‌ظرفیت اشاره می‌کند.&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>58: چرا استفاده از pointer receiver برای struct بزرگ بهینه‌تر است؟&lt;/summary>
&lt;div class="markdown-inner">
چون از کپی شدن struct بزرگ جلوگیری می‌کند و تغییرات در method روی نمونه اصلی اعمال می‌شود.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>59: تفاوت fallthrough در switch چیست؟&lt;/summary>
&lt;div class="markdown-inner">
در Go، caseها به طور پیش‌فرض break می‌شوند. استفاده از &lt;code>fallthrough&lt;/code> باعث می‌شود اجرای case بعدی بدون بررسی شرط ادامه یابد.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>60: چرا باید بعد از استفاده از ticker آن را متوقف کنیم؟&lt;/summary>
&lt;div class="markdown-inner">
عدم توقف (&lt;code>ticker.Stop()&lt;/code>) باعث نشت منابع و ادامه کار goroutine داخلی آن می‌شود.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>61: تفاوت new و literal برای struct چیست؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;ul>
&lt;li>&lt;code>new(T)&lt;/code> یک pointer به مقدار صفر نوع T برمی‌گرداند.&lt;/li>
&lt;li>&lt;code>&amp;amp;T{}&lt;/code> نیز یک pointer می‌سازد ولی می‌توان فیلدها را مقداردهی کرد.&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>62: چرا حلقه for range روی map ممکن است نتیجه متفاوتی در هر اجرا بدهد؟&lt;/summary>
&lt;div class="markdown-inner">
چون ترتیب پیمایش map در Go عمداً تصادفی است تا از وابستگی برنامه به ترتیب کلیدها جلوگیری شود.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>63: تفاوت deep copy و shallow copy در Go چیست؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;ul>
&lt;li>Shallow copy فقط مقادیر سطح اول را کپی می‌کند و referenceها همچنان مشترک می‌مانند.&lt;/li>
&lt;li>Deep copy تمام داده‌ها را بازگشتی کپی می‌کند تا هیچ اشتراک حافظه وجود نداشته باشد.&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>64: چه زمانی باید از select با context.Done استفاده کنیم؟&lt;/summary>
&lt;div class="markdown-inner">
وقتی که می‌خواهیم عملیات منتظر روی channel را در صورت لغو context یا timeout متوقف کنیم.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>65: تفاوت بین runtime.GOMAXPROCS و تعداد گوروتین‌ها چیست؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;code>GOMAXPROCS&lt;/code> حداکثر تعداد threadهای همزمانی که می‌توانند کد Go اجرا کنند را مشخص می‌کند، ولی تعداد گوروتین‌ها می‌تواند بسیار بیشتر باشد و توسط scheduler مدیریت می‌شود.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>66: چرا string در Go غیرقابل تغییر است؟&lt;/summary>
&lt;div class="markdown-inner">
برای بهینه‌سازی عملکرد و امنیت، string به داده‌های فقط خواندنی اشاره می‌کند. این طراحی اجازه می‌دهد رشته‌ها را به‌طور ایمن بین goroutineها به اشتراک گذاشت بدون نیاز به قفل.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>67: تفاوت بین time.Sleep و استفاده از time.After چیست؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;ul>
&lt;li>&lt;code>time.Sleep&lt;/code> اجرای گوروتین را برای مدت مشخص متوقف می‌کند.&lt;/li>
&lt;li>&lt;code>time.After&lt;/code> یک channel برمی‌گرداند که بعد از گذشت مدت زمان مشخص سیگنال ارسال می‌کند و می‌تواند در &lt;code>select&lt;/code> استفاده شود.&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>68: چرا نباید از panic برای کنترل جریان عادی برنامه استفاده کرد؟&lt;/summary>
&lt;div class="markdown-inner">
panic برای شرایط غیرمنتظره و خطاهای بحرانی طراحی شده است. استفاده از آن در منطق عادی باعث سختی در خواندن کد، مشکلات تست و مدیریت منابع می‌شود.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>69: sync.Cond چیست و چه زمانی استفاده می‌شود؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;code>sync.Cond&lt;/code> ابزاری برای هماهنگ‌سازی پیشرفته است که به goroutineها اجازه می‌دهد تا تا زمان برآورده شدن یک شرط منتظر بمانند و توسط دیگر goroutineها بیدار شوند.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>70: تفاوت بین context.Background و context.TODO چیست؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;ul>
&lt;li>&lt;code>context.Background&lt;/code> برای شروع زنجیره context در برنامه‌های سطح بالا استفاده می‌شود.&lt;/li>
&lt;li>&lt;code>context.TODO&lt;/code> زمانی استفاده می‌شود که هنوز مشخص نیست چه contextی باید استفاده شود یا در حال توسعه هستیم.&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>71: چرا mapهای بزرگ می‌توانند باعث فشار روی GC شوند؟&lt;/summary>
&lt;div class="markdown-inner">
چون map ممکن است مقادیر زیادی حافظه تخصیص دهد و GC باید همه کلیدها و مقادیر را بررسی کند. حذف مقادیر غیرضروری یا بازسازی map می‌تواند فشار را کاهش دهد.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>72: تفاوت بین کانال بسته و nil channel چیست؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;ul>
&lt;li>کانال بسته: خواندن از آن مقدار صفر و وضعیت بسته بودن را برمی‌گرداند. ارسال روی آن panic ایجاد می‌کند.&lt;/li>
&lt;li>nil channel: هر عملیات ارسال یا دریافت روی آن برای همیشه بلاک می‌شود.&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>73: چرا استفاده از range روی string با کاراکترهای یونیکد خاص می‌تواند کند باشد؟&lt;/summary>
&lt;div class="markdown-inner">
زیرا Go هر بار کاراکترها را به صورت rune دیکد می‌کند که شامل تبدیل UTF-8 به int32 است. برای داده‌های ASCII این تبدیل سریع‌تر است.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>74: چه زمانی باید از copy برای slice استفاده کنیم؟&lt;/summary>
&lt;div class="markdown-inner">
وقتی که می‌خواهیم داده‌ها را از یک slice به دیگری منتقل کنیم بدون اینکه به آرایه زیرین مشترک اشاره کنند، مخصوصاً برای جلوگیری از مشکلات memory leak یا تغییرات ناخواسته.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>75: تفاوت بین defer با تابع معمولی در مدیریت منابع چیست؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;code>defer&lt;/code> تضمین می‌کند که تابع در پایان محدوده اجرا شود، حتی در صورت panic یا بازگشت زودهنگام، ولی تابع معمولی بلافاصله اجرا می‌شود.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>76: چرا نباید روی کانال nil عملیات انجام داد؟&lt;/summary>
&lt;div class="markdown-inner">
هر ارسال یا دریافت روی کانال nil باعث بلاک شدن بی‌پایان goroutine می‌شود، که معمولاً به صورت ناخواسته deadlock ایجاد می‌کند.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>77: تفاوت بین append به slice و append به nil slice چیست؟&lt;/summary>
&lt;div class="markdown-inner">
هر دو معتبر هستند. append به nil slice باعث ایجاد slice جدید با ظرفیت مورد نیاز می‌شود.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>78: چرا حلقه‌های for بدون شرط در Go می‌توانند مشکل‌ساز شوند؟&lt;/summary>
&lt;div class="markdown-inner">
یک حلقه &lt;code>for {}&lt;/code> بدون شرط توقف می‌تواند CPU را ۱۰۰٪ مشغول کند مگر اینکه شامل عملیات بلاک‌کننده یا sleep باشد.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>79: sync.Map چه مزیتی نسبت به map با Mutex دارد؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;code>sync.Map&lt;/code> برای سناریوهایی با خواندن زیاد و نوشتن کم بهینه‌سازی شده و نیازی به قفل دستی ندارد، ولی در همه موارد سریع‌تر از map+Mutex نیست.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>80: چرا تبدیل بین []byte و string در Go معمولاً باعث کپی می‌شود؟&lt;/summary>
&lt;div class="markdown-inner">
برای جلوگیری از تغییر داده‌های string (که immutable است)، Go معمولاً داده‌ها را کپی می‌کند. این رفتار هزینه زمانی و حافظه دارد.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>81: چرا استفاده از time.Tick بدون توقف می‌تواند memory leak ایجاد کند؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;code>time.Tick&lt;/code> یک channel بازگشتی ایجاد می‌کند که هرگز متوقف نمی‌شود. برای جلوگیری از نشت منابع، بهتر است از &lt;code>time.NewTicker&lt;/code> استفاده کرده و در زمان مناسب &lt;code>Stop()&lt;/code> را فراخوانی کنید.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>82: تفاوت بین interface خالی و interface با متد چیست؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;ul>
&lt;li>Interface خالی (&lt;code>interface{}&lt;/code>) می‌تواند هر نوعی را نگه دارد.&lt;/li>
&lt;li>Interface با متدها فقط می‌تواند نوع‌هایی را نگه دارد که تمام متدهای تعریف‌شده را پیاده‌سازی کرده باشند.&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>83: چرا استفاده از goroutine در حلقه for بدون همگام‌سازی می‌تواند مشکل‌ساز باشد؟&lt;/summary>
&lt;div class="markdown-inner">
چون متغیرهای حلقه بین goroutineها به اشتراک گذاشته می‌شوند و مقدارشان در زمان اجرا ممکن است تغییر کند. باید متغیر را به صورت محلی کپی یا با آرگومان به goroutine پاس داد.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>84: تفاوت بین make برای map و literal map چیست؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;ul>
&lt;li>&lt;code>make(map[Key]Value, cap)&lt;/code> ظرفیت اولیه را مشخص می‌کند.&lt;/li>
&lt;li>Literal map (&lt;code>map[Key]Value{...}&lt;/code>) بلافاصله داده‌ها را مقداردهی می‌کند.&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>85: چرا نباید روی کانالی که چند تولیدکننده دارد بدون هماهنگی close انجام داد؟&lt;/summary>
&lt;div class="markdown-inner">
چون ممکن است چند goroutine همزمان تلاش به بستن کانال کنند که باعث panic می‌شود. معمولاً فقط یک تولیدکننده مسئول close است.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>86: تفاوت بین string literal با backtick و با quote چیست؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;ul>
&lt;li>با quote (&lt;code>&amp;quot;...&amp;quot;&lt;/code>): رشته escape می‌شود و می‌توان از &lt;code>\n&lt;/code> و غیره استفاده کرد.&lt;/li>
&lt;li>با backtick (&lt;code>`...`&lt;/code>): رشته raw است و escape interpretation انجام نمی‌شود.&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>87: چرا garbage collector نمی‌تواند فایل‌های باز را ببندد؟&lt;/summary>
&lt;div class="markdown-inner">
GC فقط حافظه را آزاد می‌کند، ولی منابع سیستم‌عاملی مثل فایل‌ها یا socketها را باید به صورت صریح با &lt;code>Close()&lt;/code> آزاد کرد.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>88: تفاوت بین untyped constant و typed constant چیست؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;ul>
&lt;li>Untyped constant می‌تواند با هر نوع سازگار استفاده شود تا زمانی که مقدارش در محدوده باشد.&lt;/li>
&lt;li>Typed constant نوع مشخص دارد و فقط با همان نوع یا نوع‌های سازگار استفاده می‌شود.&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>89: چرا استفاده از recover خارج از defer بی‌اثر است؟&lt;/summary>
&lt;div class="markdown-inner">
چون &lt;code>recover&lt;/code> فقط زمانی panic را می‌گیرد که درون یک defer اجرا شود که در همان گوروتین panic اتفاق افتاده باشد.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>90: تفاوت بین range روی slice و روی array چیست؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;ul>
&lt;li>روی slice: مقدار و اندیس عناصر slice را برمی‌گرداند.&lt;/li>
&lt;li>روی array: مشابه slice، ولی آرایه به صورت کامل پاس داده می‌شود که می‌تواند هزینه‌بر باشد مگر اینکه با reference پاس شود.&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>91: چرا capacity slice بعد از append ممکن است چند برابر شود؟&lt;/summary>
&lt;div class="markdown-inner">
برای بهینه‌سازی تخصیص حافظه، Go هنگام نیاز به افزایش ظرفیت معمولاً آن را به صورت نمایی (دو برابر یا بیشتر) افزایش می‌دهد.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>92: تفاوت بین runtime.Gosched و time.Sleep چیست؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;ul>
&lt;li>&lt;code>runtime.Gosched&lt;/code> به scheduler اجازه می‌دهد گوروتین‌های دیگر را اجرا کند بدون توقف زمان مشخص.&lt;/li>
&lt;li>&lt;code>time.Sleep&lt;/code> گوروتین را برای مدت مشخص متوقف می‌کند.&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>93: چرا nil pointer در method receiver ممکن است باعث panic نشود؟&lt;/summary>
&lt;div class="markdown-inner">
اگر متد به فیلد یا داده‌ای از struct دسترسی نداشته باشد، حتی اگر receiver nil باشد، panic ایجاد نمی‌شود.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>94: تفاوت بین map[string]struct{} و map[string]bool چیست؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;ul>
&lt;li>&lt;code>map[string]struct{}&lt;/code> حافظه کمتری مصرف می‌کند چون struct خالی صفر بایت است.&lt;/li>
&lt;li>&lt;code>map[string]bool&lt;/code> نیاز به یک بایت برای مقدار دارد.&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>95: چرا استفاده از for-select بدون default می‌تواند کارایی را کاهش دهد؟&lt;/summary>
&lt;div class="markdown-inner">
چون گوروتین بلاک می‌ماند تا یکی از caseها آماده شود، که ممکن است باعث استفاده ناکارآمد از CPU شود.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>96: تفاوت بین var x = y و x := y چیست؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;ul>
&lt;li>&lt;code>var x = y&lt;/code> می‌تواند در سطح package یا تابع استفاده شود.&lt;/li>
&lt;li>&lt;code>x := y&lt;/code> فقط در داخل توابع مجاز است و همیشه تعریف جدید انجام می‌دهد.&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>97: چرا استفاده از init function باید محدود باشد؟&lt;/summary>
&lt;div class="markdown-inner">
چون باعث اجرای مخفیانه کد در هنگام بارگذاری پکیج می‌شود و می‌تواند تست و اشکال‌زدایی را سخت کند. بهتر است منطق راه‌اندازی به صراحت در main یا سازنده‌ها باشد.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>98: تفاوت بین context.WithCancel و context.WithTimeout چیست؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;ul>
&lt;li>&lt;code>WithCancel&lt;/code> فقط با فراخوانی تابع cancel لغو می‌شود.&lt;/li>
&lt;li>&lt;code>WithTimeout&lt;/code> به صورت خودکار بعد از زمان مشخص لغو می‌شود.&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>99: چرا حلقه‌های بازگشتی بدون شرط توقف می‌توانند باعث stack overflow شوند؟&lt;/summary>
&lt;div class="markdown-inner">
چون Go tail call optimization ندارد و هر فراخوانی بازگشتی stack را افزایش می‌دهد.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>100: تفاوت بین log.Fatal و panic چیست؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;ul>
&lt;li>&lt;code>log.Fatal&lt;/code> پیام را چاپ کرده و برنامه را بلافاصله با &lt;code>os.Exit&lt;/code> متوقف می‌کند.&lt;/li>
&lt;li>&lt;code>panic&lt;/code> اجرای عادی را متوقف کرده و chain فراخوانی deferها را اجرا می‌کند قبل از توقف.&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>101: تفاوت بین unsafe.Pointer و uintptr چیست؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;ul>
&lt;li>&lt;code>unsafe.Pointer&lt;/code> برای تبدیل بین انواع اشاره‌گر استفاده می‌شود.&lt;/li>
&lt;li>&lt;code>uintptr&lt;/code> یک نوع عددی است که آدرس را به عنوان یک عدد ذخیره می‌کند. تبدیل بین آنها باید با احتیاط انجام شود چون ممکن است GC آدرس را جابجا کند.&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>102: چرا استفاده از reflect می‌تواند کارایی را کاهش دهد؟&lt;/summary>
&lt;div class="markdown-inner">
پکیج &lt;code>reflect&lt;/code> باعث عملیات‌های زمان اجرا و type checking پویا می‌شود که نسبت به کد معمولی کندتر است.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>103: تفاوت بین constant expression و runtime value چیست؟&lt;/summary>
&lt;div class="markdown-inner">
Constant expression در زمان کامپایل مشخص می‌شود و می‌تواند در تعریف ثابت‌ها استفاده شود. Runtime value فقط در زمان اجرای برنامه مشخص می‌شود.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>104: چرا nil channel برای همگام‌سازی گاهی مفید است؟&lt;/summary>
&lt;div class="markdown-inner">
با nil کردن یک channel می‌توانیم آن را از انتخاب در &lt;code>select&lt;/code> حذف کنیم و رفتار برنامه را به صورت پویا کنترل کنیم.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>105: تفاوت بین stack و heap allocation در Go چیست؟&lt;/summary>
&lt;div class="markdown-inner">
Stack سریع‌تر و برای داده‌های کوتاه‌مدت استفاده می‌شود. Heap برای داده‌هایی که طول عمر نامعلوم دارند و بین goroutineها به اشتراک گذاشته می‌شوند.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>106: چرا slicing از یک array بزرگ می‌تواند باعث نگه‌داشتن حافظه اضافی شود؟&lt;/summary>
&lt;div class="markdown-inner">
چون slice به آرایه زیرین اشاره می‌کند و GC نمی‌تواند آرایه بزرگ را آزاد کند تا زمانی که slice زنده باشد.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>107: تفاوت بین break و continue در حلقه چیست؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;ul>
&lt;li>&lt;code>break&lt;/code> حلقه را کامل متوقف می‌کند.&lt;/li>
&lt;li>&lt;code>continue&lt;/code> فقط iteration جاری را رد کرده و iteration بعدی را شروع می‌کند.&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>108: چرا append ممکن است باعث تغییر آدرس حافظه slice شود؟&lt;/summary>
&lt;div class="markdown-inner">
وقتی ظرفیت پر شود، append یک آرایه جدید می‌سازد و داده‌ها را کپی می‌کند که آدرس حافظه متفاوت خواهد داشت.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>109: تفاوت بین go vet و go fmt چیست؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;ul>
&lt;li>&lt;code>go fmt&lt;/code> کد را قالب‌بندی می‌کند.&lt;/li>
&lt;li>&lt;code>go vet&lt;/code> مشکلات احتمالی کد را شناسایی می‌کند ولی تغییرات ظاهری ایجاد نمی‌کند.&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>110: چرا باید از io.Reader و io.Writer در طراحی API استفاده کنیم؟&lt;/summary>
&lt;div class="markdown-inner">
برای انعطاف‌پذیری بیشتر و امکان استفاده از منابع مختلف (فایل، شبکه، حافظه) بدون تغییر کد.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>111: تفاوت بین os.Exit و return در main چیست؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;code>os.Exit&lt;/code> فوراً برنامه را متوقف می‌کند و deferها اجرا نمی‌شوند، ولی &lt;code>return&lt;/code> اجازه اجرای deferها را می‌دهد.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>112: چرا map نمی‌تواند به عنوان کلید slice داشته باشد؟&lt;/summary>
&lt;div class="markdown-inner">
چون slice قابل مقایسه نیست و hash آن ثابت نیست. فقط انواع قابل مقایسه (comparable) می‌توانند کلید باشند.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>113: تفاوت بین io.Pipe و channel چیست؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;code>io.Pipe&lt;/code> برای اتصال مستقیم بین io.Reader و io.Writer استفاده می‌شود، ولی channel برای ارسال هر نوع داده بین goroutineها استفاده می‌شود.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>114: چرا نباید از pointer به local variable بعد از پایان تابع استفاده کنیم؟&lt;/summary>
&lt;div class="markdown-inner">
چون متغیر ممکن است از بین برود یا آدرسش تغییر کند، که باعث رفتار غیرقابل پیش‌بینی می‌شود.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>115: تفاوت بین testing.Short و تست‌های عادی چیست؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;code>testing.Short()&lt;/code> می‌تواند در تست‌ها استفاده شود تا تست‌های طولانی در حالت کوتاه اجرا نشوند.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>116: چرا باید برای عملیات‌های سنگین I/O از buffered channel استفاده کرد؟&lt;/summary>
&lt;div class="markdown-inner">
برای جلوگیری از بلاک شدن تولیدکننده یا مصرف‌کننده و افزایش throughput.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>117: تفاوت بین go build و go install چیست؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;ul>
&lt;li>&lt;code>go build&lt;/code> فایل اجرایی را در دایرکتوری جاری می‌سازد.&lt;/li>
&lt;li>&lt;code>go install&lt;/code> آن را در مسیر bin در &lt;code>$GOPATH&lt;/code> یا &lt;code>$GOBIN&lt;/code> نصب می‌کند.&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>118: چرا استفاده از strings.Builder به جای + برای رشته‌ها بهتر است؟&lt;/summary>
&lt;div class="markdown-inner">
چون از تخصیص‌های متعدد جلوگیری می‌کند و حافظه را بهینه‌تر مدیریت می‌کند.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>119: تفاوت بین cap و len در array چیست؟&lt;/summary>
&lt;div class="markdown-inner">
برای array هر دو برابر طول آرایه هستند، ولی برای slice ممکن است متفاوت باشند.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>120: چرا باید بعد از استفاده از bufio.Writer حتماً Flush کرد؟&lt;/summary>
&lt;div class="markdown-inner">
چون داده‌ها در بافر ذخیره می‌شوند و تا زمانی که Flush نشوند به مقصد نهایی ارسال نمی‌شوند.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>121: تفاوت بین import _ و import alias چیست؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;ul>
&lt;li>&lt;code>import _&lt;/code> فقط برای اجرای init پکیج است.&lt;/li>
&lt;li>Import alias برای استفاده از نام متفاوت جهت ارجاع به پکیج.&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>122: چرا باید از context در عملیات‌های شبکه استفاده کنیم؟&lt;/summary>
&lt;div class="markdown-inner">
برای امکان لغو یا timeout در صورت طولانی شدن عملیات.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>123: تفاوت بین interface value و concrete value چیست؟&lt;/summary>
&lt;div class="markdown-inner">
Interface value شامل نوع و مقدار واقعی است، concrete value فقط مقدار واقعی است.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>124: چرا استفاده از constant برای magic number بهتر است؟&lt;/summary>
&lt;div class="markdown-inner">
باعث خوانایی بهتر، کاهش خطا و امکان تغییر راحت در آینده می‌شود.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>125: تفاوت بین log.Println و fmt.Println چیست؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;code>log.Println&lt;/code> علاوه بر چاپ پیام، timestamp هم اضافه می‌کند.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>126: چرا sync.WaitGroup باید با Add قبل از اجرای goroutine استفاده شود؟&lt;/summary>
&lt;div class="markdown-inner">
برای جلوگیری از شرایطی که goroutine قبل از افزایش شمارنده شروع شود و WaitGroup صفر بماند.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>127: تفاوت بین path و filepath در Go چیست؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;ul>
&lt;li>&lt;code>path&lt;/code> برای مسیرهای URL و forward slash استفاده می‌شود.&lt;/li>
&lt;li>&lt;code>filepath&lt;/code> برای مسیرهای سیستم فایل وابسته به سیستم‌عامل استفاده می‌شود.&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>128: چرا استفاده از http.Client پیش‌فرض می‌تواند مشکل‌ساز باشد؟&lt;/summary>
&lt;div class="markdown-inner">
چون connectionها را cache نمی‌کند و ممکن است باعث نشت اتصال شود مگر اینکه timeout یا Transport سفارشی تعریف شود.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>129: تفاوت بین sync.Mutex و sync.RWMutex در خواندن زیاد چیست؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;code>sync.RWMutex&lt;/code> اجازه می‌دهد چندین خواننده همزمان کار کنند، ولی Mutex فقط یک قفل کلی می‌دهد.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>130: چرا panic در گوروتین جداگانه باید به صورت جداگانه recover شود؟&lt;/summary>
&lt;div class="markdown-inner">
چون recover فقط panic در همان goroutine را می‌گیرد.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>131: تفاوت بین os.Create و os.OpenFile چیست؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;ul>
&lt;li>&lt;code>os.Create&lt;/code> فایل را با truncate ایجاد یا باز می‌کند.&lt;/li>
&lt;li>&lt;code>os.OpenFile&lt;/code> کنترل کامل روی mode و flagها می‌دهد.&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>132: چرا context باید به صورت اولین آرگومان به توابع پاس داده شود؟&lt;/summary>
&lt;div class="markdown-inner">
این یک قرارداد استاندارد Go است که خوانایی و یکپارچگی API را بهبود می‌دهد.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>133: تفاوت بین errors.Is و errors.As چیست؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;ul>
&lt;li>&lt;code>errors.Is&lt;/code> برای بررسی تطابق با یک خطای خاص استفاده می‌شود.&lt;/li>
&lt;li>&lt;code>errors.As&lt;/code> برای استخراج و استفاده از نوع خاص خطا.&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>134: چرا نباید از defer در حلقه‌های شدیداً پرتکرار استفاده کرد؟&lt;/summary>
&lt;div class="markdown-inner">
چون هر defer تا پایان تابع ذخیره می‌شود و باعث سربار می‌شود.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>135: تفاوت بین nil slice و empty slice در JSON چیست؟&lt;/summary>
&lt;div class="markdown-inner">
Nil slice به &lt;code>null&lt;/code> سریالایز می‌شود، ولی empty slice به &lt;code>[]&lt;/code>.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>136: چرا map در Go به صورت داخلی rehash انجام می‌دهد؟&lt;/summary>
&lt;div class="markdown-inner">
برای حفظ کارایی O(1) در دسترسی و جلوگیری از افزایش بیش از حد load factor.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>137: تفاوت بین encoding/json و jsoniter چیست؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;code>jsoniter&lt;/code> سریع‌تر و انعطاف‌پذیرتر است ولی encoding/json رسمی و پایدار است.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>138: چرا باید کانال را فقط توسط ارسال‌کننده ببندیم؟&lt;/summary>
&lt;div class="markdown-inner">
برای جلوگیری از panic ناشی از ارسال به کانال بسته.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>139: تفاوت بین context.WithValue و متغیر global چیست؟&lt;/summary>
&lt;div class="markdown-inner">
Context برای داده‌های کوتاه‌مدت مرتبط با درخواست استفاده می‌شود، global برای داده‌های بلندمدت.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>140: چرا time.AfterFunc می‌تواند به جای time.Sleep مفید باشد؟&lt;/summary>
&lt;div class="markdown-inner">
چون به صورت asynchronous عمل می‌کند و callback مشخصی را بعد از مدت معین اجرا می‌کند.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>141: تفاوت بین select با یک case و استفاده مستقیم از channel چیست؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;code>select&lt;/code> حتی با یک case هم امکان اضافه کردن default یا caseهای دیگر را در آینده می‌دهد و ساختار کد را منعطف‌تر می‌کند، ولی دریافت مستقیم ساده‌تر است.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>142: چرا استفاده از buffer بزرگ‌تر در bufio.Reader می‌تواند کارایی را بهبود دهد؟&lt;/summary>
&lt;div class="markdown-inner">
چون تعداد فراخوانی‌های سیستم‌عاملی (syscall) را کاهش می‌دهد و داده‌ها را یک‌جا می‌خواند.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>143: تفاوت بین defer با anonymous function و با نام تابع چیست؟&lt;/summary>
&lt;div class="markdown-inner">
در defer با anonymous function می‌توان پارامترها را در زمان اجرای defer ارزیابی کرد، ولی در تابع نام‌دار پارامترها در لحظه تعریف defer ارزیابی می‌شوند.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>144: چرا از sync/atomic برای شمارنده‌ها استفاده می‌شود؟&lt;/summary>
&lt;div class="markdown-inner">
چون عملیات‌های اتمیک بدون نیاز به Mutex انجام می‌شوند و سرعت بیشتری دارند.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>145: تفاوت بین byte buffer و byte slice چیست؟&lt;/summary>
&lt;div class="markdown-inner">
Byte buffer (مثل bytes.Buffer) امکانات بیشتری مثل نوشتن و خواندن با رشد خودکار دارد، ولی byte slice ساده‌تر است و امکانات اضافی ندارد.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>146: چرا استفاده از fallthrough باید محدود باشد؟&lt;/summary>
&lt;div class="markdown-inner">
چون می‌تواند باعث اجرای غیرمنتظره caseها شود و خوانایی کد را کاهش دهد.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>147: تفاوت بین log.Fatal و os.Exit چیست؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;code>log.Fatal&lt;/code> قبل از توقف پیام خطا را چاپ می‌کند، ولی &lt;code>os.Exit&lt;/code> فقط برنامه را متوقف می‌کند.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>148: چرا map در Go به‌صورت همزمان توسط چند goroutine قابل استفاده نیست؟&lt;/summary>
&lt;div class="markdown-inner">
چون پیاده‌سازی داخلی map thread-safe نیست و همزمانی بدون قفل باعث panic می‌شود.
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>149: تفاوت بین os.Getenv و os.LookupEnv چیست؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;ul>
&lt;li>&lt;code>os.Getenv&lt;/code> رشته را برمی‌گرداند و اگر وجود نداشته باشد مقدار خالی می‌دهد.&lt;/li>
&lt;li>&lt;code>os.LookupEnv&lt;/code> مقدار و وضعیت وجود داشتن را برمی‌گرداند.&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>150: چرا range روی channel تا زمان بسته شدن ادامه دارد؟&lt;/summary>
&lt;div class="markdown-inner">
چون range از channel تا زمانی که همه مقادیر خوانده و کانال بسته نشود، بلاک می‌ماند.
&lt;/div>
&lt;/details></description></item><item><author/><title>فصل اول: آشنایی با مفاهیم گو</title><link>https://book.gofarsi.ir/chapter-1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-1/</guid><description>&lt;p>در فصل اول به مفاهیم پایه زبان برنامه‌نویسی گو بطور عمیق می‌پردازیم. این فصل شامل چندین بخش هست:&lt;/p>
&lt;ul>
&lt;li>1.1&lt;a href="structure-of-go-code"> ساختار کد گو&lt;/a>&lt;/li>
&lt;li>1.2&lt;a href="go-built-in-keywords-identifiers"> کلید واژه و شناسه‌ها&lt;/a>&lt;/li>
&lt;li>1.3 &lt;a href="go-basic-types">تایپ های پایه&lt;/a>&lt;/li>
&lt;li>1.4 &lt;a href="go-operators">عملگرها&lt;/a>&lt;/li>
&lt;li>1.5 &lt;a href="go-variables-and-consts">متغیرها و constant&lt;/a>&lt;/li>
&lt;li>1.6 &lt;a href="go-zero-values">مقادیر صفر تایپ ها (zero values)&lt;/a>&lt;/li>
&lt;li>1.7 &lt;a href="go-function">تابع (function)&lt;/a>&lt;/li>
&lt;li>1.8 &lt;a href="go-array">آرایه و slice&lt;/a>&lt;/li>
&lt;li>1.9 &lt;a href="go-for">حلقه ها (for)&lt;/a>&lt;/li>
&lt;li>1.10 &lt;a href="go-map">نقشه map&lt;/a>&lt;/li>
&lt;li>1.11 &lt;a href="go-if-switch">شرط (if, switch)&lt;/a>&lt;/li>
&lt;li>1.12 &lt;a href="go-package">اضافه کردن پکیج در کد (package)&lt;/a>&lt;/li>
&lt;li>1.13 &lt;a href="go-defer-panic-recovery">defer, panic, recovery&lt;/a>&lt;/li>
&lt;li>1.14 &lt;a href="go-builtins">لیست تایپ ها و توابع Builtin&lt;/a>&lt;/li>
&lt;li>1.15&lt;a href="go-string-formatting">آشنایی با رشته و توابع آن&lt;/a>&lt;/li>
&lt;/ul></description></item><item><author/><title>فصل دوم: مکانیزم‌های زبان</title><link>https://book.gofarsi.ir/chapter-2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-2/</guid><description>&lt;p>در این فصل به مکانیزیم‌های زبان گو می‌پردازیم و برخی از اصطلاحات زبان گو را با هم برسی می‌کنیم.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="pointer">در بخش 2.1 در خصوص &lt;span class="tooltip" data-tooltip="pointer" ontouchend="toggleTooltip(this)">اشاره‌گر&lt;/span>
آموزش خواهیم داد.&lt;/a>&lt;/li>
&lt;li>&lt;a href="struct">در بخش 2.2 به مهم‌ترین تایپ در زبان گو، یعنی &lt;span class="tooltip" data-tooltip="struct" ontouchend="toggleTooltip(this)">ساختار&lt;/span>
می‌پردازیم و آموزش می‌دهیم چطور با استفاده از ساختار دیتامدل‌های پروژه‌های خود را پیاده سازی کنید.&lt;/a>&lt;/li>
&lt;li>&lt;a href="method">در بخش 2.3 به بحث متدها می‌پردازیم و برسی می‌کنیم که &lt;code>چطور این نوع توابع را پیاده سازی کنیم&lt;/code>.&lt;/a>&lt;/li>
&lt;li>&lt;a href="interface">در بخش 2.4 در خصوص اینترفیس در زبان گو توضیح می‌دهیم. &lt;code>دقیقا چی هستند و چطور میشه ازشون استفاده کرد&lt;/code>.&lt;/a>&lt;/li>
&lt;li>&lt;a href="type-embedding">در بخش 2.5 به &lt;span class="tooltip" data-tooltip="embedding" ontouchend="toggleTooltip(this)">جاسازی&lt;/span>
ساختار و اینترفیس می‌پردازیم.&lt;/a>&lt;/li>
&lt;li>&lt;a href="error-handling">در بخش 2.6 به مدیریت خطاها در زبان گو می‌پردازیم و برسی می‌کنیم که چه ویژگی‌هایی دارد.&lt;/a>&lt;/li>
&lt;li>&lt;a href="casting-vs-conversion">2.7 تفاوت castin با conversion را آموزش می‌دهیم.&lt;/a>&lt;/li>
&lt;/ul></description></item><item><author/><title>فصل سوم: همزمانی (concurrency)</title><link>https://book.gofarsi.ir/chapter-3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-3/</guid><description>&lt;p>در این فصل به صورت عمیق به مباحث همزمانی در زبان گو پرداخته شده است که شامل عناوین زیر می‌باشد.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="go-concurrency">۳.۱ آشنایی با مبحث همزمانی.&lt;/a>&lt;/li>
&lt;li>&lt;a href="goroutine">۳.۲ گوروتین چیست.&lt;/a>&lt;/li>
&lt;li>&lt;a href="go-sync-package">۳.۳ کالبدشکافی پکیج sync و تشریح &lt;span class="tooltip" data-tooltip="Types" ontouchend="toggleTooltip(this)">انواع&lt;/span>
و توابع کاربردی آن برای مباحث همگام‌سازی همزمانی.&lt;/a>&lt;/li>
&lt;li>&lt;a href="go-atomic">۳.۴ آشنایی با پکیج atomic و کاربردهای آن.&lt;/a>&lt;/li>
&lt;li>&lt;a href="goroutine-data-race">۳.۵ آشنایی با Data Race و روش‌های پیشگیری از آن.&lt;/a>&lt;/li>
&lt;li>&lt;a href="go-channel">۳.۶ کانال‌ها و روش‌ اشتراک‌گذاری داده از طریق آن.&lt;/a>&lt;/li>
&lt;li>&lt;a href="go-select">۳.۷ آشنایی با کلید‌واژه select و بررسی کاربردهای متنوع آن.&lt;/a>&lt;/li>
&lt;li>&lt;a href="go-context">۳.۸ پکیج context و اهمیت آن.&lt;/a>&lt;/li>
&lt;li>&lt;a href="go-concurrency-teqniques">۳.۹ تکنیک‌های مورد استفاده در همزمانی.&lt;/a>&lt;/li>
&lt;li>&lt;a href="go-concurrency-patterns">۳.۱۰ الگوهای متداول همزمانی و کاربردهای آن.&lt;/a>&lt;/li>
&lt;/ul></description></item><item><author/><title>فصل چهارم: مباحث پیشرفته</title><link>https://book.gofarsi.ir/chapter-4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/</guid><description>&lt;p>در این بخش به مباحث پیشرفته تری از زبان گو می پردازیم که شامل بخش های زیر می باشد.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="build-go-file">۴.۱ پروژه Build آموزش ‌.&lt;/a>&lt;/li>
&lt;li>&lt;a href="debugging-go-code">۴.۲ Debuggingآموزش کار با.&lt;/a>&lt;/li>
&lt;li>&lt;a href="go-mod">۴.۳ go mod آموزش کار با .&lt;/a>&lt;/li>
&lt;li>&lt;a href="workspace">۴.۴ workspace آموزش کار با.&lt;/a>&lt;/li>
&lt;li>&lt;a href="vendor">۴.۵ Vendor آموزش کار با.&lt;/a>&lt;/li>
&lt;li>&lt;a href="command-line-go">۴.۶ command line آموزش نوشتن برنامه.&lt;/a>&lt;/li>
&lt;li>&lt;a href="work-with-file-in-go">آموزش کار با فایل ۴.۷.&lt;/a>&lt;/li>
&lt;li>&lt;a href="work-with-json-file-in-go">۴.۸ json آموزش کار با.&lt;/a>&lt;/li>
&lt;li>&lt;a href="work-with-toml-file-in-go">۴.۹ toml آموزش کار با.&lt;/a>&lt;/li>
&lt;li>&lt;a href="work-with-yaml-file-in-go">۴.۱۰ yaml آموزش کار با.&lt;/a>&lt;/li>
&lt;li>&lt;a href="work-with-csv-file-in-go">۴.۱۱ CSV آموزش کار با.&lt;/a>&lt;/li>
&lt;li>&lt;a href="work-with-ini-file-in-go">۴.۱۲ ini آموزش کار با.&lt;/a>&lt;/li>
&lt;li>&lt;a href="work-with-environment-variable">۴.۱۳ enviroment variable آموزش کار با.&lt;/a>&lt;/li>
&lt;li>&lt;a href="go-regular-expressions">۴.۱۴ regexp آموزش کار با.&lt;/a>&lt;/li>
&lt;li>&lt;a href="go-reflection">۴.۱۵ reflection آموزش.&lt;/a>&lt;/li>
&lt;li>&lt;a href="go-generator">۴.۱۶ generator آموزش.&lt;/a>&lt;/li>
&lt;li>&lt;a href="go-stringer">۴.۱۷ stringerآموزش.&lt;/a>&lt;/li>
&lt;li>&lt;a href="effective-go">تکنیک های کد نویسی زبان گو ۴.۱۸.&lt;/a>&lt;/li>
&lt;li>&lt;a href="go-commentry">اصول کامنت نویسی ۴.۱۹.&lt;/a>&lt;/li>
&lt;li>&lt;a href="go-code-rules">قوانین کد نویسی در زبان گو ۴.۲۰.&lt;/a>&lt;/li>
&lt;li>&lt;a href="go-garbage-collector">۴.۲۱ (garbage collector)زباله جمع کن.&lt;/a>&lt;/li>
&lt;li>&lt;a href="go-plugin">۴.۲۲ Plugin کتابخانه.&lt;/a>&lt;/li>
&lt;li>&lt;a href="oop">۴.۲۳ شی گرایی در زبان گو.&lt;/a>&lt;/li>
&lt;li>&lt;a href="tracing">۴.۲۴ tracing آموزش&lt;/a>&lt;/li>
&lt;li>&lt;a href="profiling">۴.۲۵ profiling آموزش&lt;/a>&lt;/li>
&lt;/ul></description></item><item><author/><title>فصل پنجم: برنامه نویسی شبکه با گو</title><link>https://book.gofarsi.ir/chapter-5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-5/</guid><description>&lt;p>در این فصل به مباحث برنامه نویسی شبکه در زبان گو میپردازیم&amp;hellip;&lt;/p></description></item><item><author/><title>فصل ششم: ژنریک ها (Generics)</title><link>https://book.gofarsi.ir/chapter-6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-6/</guid><description>&lt;p>در این بخش قصد داریم به بحث ژنریک ها بپردازیم که از نسخه &lt;a href="https://go.dev/blog/go1.18">go1.18&lt;/a> اضافه شد که تقریبا یکی از اساسی ترین تغییرات در سینتکس زبان گو بود و در قالب یک &lt;a href="https://go.googlesource.com/proposal/&amp;#43;/HEAD/design/43651-type-parameters.md">پروپوزال&lt;/a> ارائه شد و سپس از نسخه ۱.۱۸ منتشر شد و تا الان تغییرات و بهبودهای زیادی داشته است.&lt;/p>
&lt;p>ژنریک به زبان برنامه‌نویسی امکانات مهمی اضافه می‌کند:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>پارامترهای نوع برای توابع و انواع داده&lt;/strong>: با ژنریک، می‌توانید توابع و انواع داده‌ای را با پارامترهای نوع مخصوص بسازید. به این ترتیب می‌توانید یک تابع یا یک نوع داده را برای کار با انواع مختلف داده تعریف کنید.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>تعریف انواع رابط به عنوان مجموعه‌ای از انواع&lt;/strong>: با ژنریک، می‌توانید انواع اینترفیس را به عنوان مجموعه‌هایی از انواع تعریف کنید، حتی انواعی که متدهای خاصی ندارند. این به شما امکان می‌دهد تا انواع داده‌ای را به عنوان پارامترها در تعریف اینترفیس‌ها استفاده کنید.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>استفاده از استنباط نوع (Type Inference)&lt;/strong>: ژنریک اجازه می‌دهد که در بسیاری از موارد، پارامترهای نوع را در فراخوانی توابع حذف کنید. به این ترتیب کد شما ساده‌تر و خواناتر می‌شود و نیازی به تعیین دقیق نوع در همه جا ندارید.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;blockquote class="book-hint info">
&lt;p>&lt;strong>نکات کاربردی&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>زمانی از ژنریک ها استفاده کنید که کدهای شما فقط با تغییر تایپ در حال تکرار است آنجا شما می توانید از ژنریک ها برای کاهش کد خود کمک بگیرید.&lt;/li>
&lt;li>از ژنریک ها می توانید برای کاهش Assertion اینترفیس ها استفاده کنید.&lt;/li>
&lt;li>با اینکه ژنریک یک ویژگی خوب است اما استفاده زیاد باعث پیچیدگی و سربار حافظه خواهد شد.&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;h2 id="ژنریک-چیست">
ژنریک چیست؟
&lt;a class="anchor" href="#%da%98%d9%86%d8%b1%db%8c%da%a9-%da%86%db%8c%d8%b3%d8%aa">#&lt;/a>
&lt;/h2>
&lt;p>ژنریک یک ویژگی مهم در Go است که به شما این امکان را می‌دهد تا کدهای کلی و قابل استفاده مجدد بنویسید بدون اینکه به تایپ‌های خاصی محدود شوید. به عبارت ساده‌تر، با ژنریک می‌توانید توابع و ساختارهای داده را بنویسید که با انواع مختلف داده‌ها کار کنند.&lt;/p>
&lt;p>به عنوان مثال، فرض کنید یک تابع بخواهید بنویسید که دو عدد را با هم جمع کند. بدون استفاده از ژنریک، شما باید تابع‌های مجزایی برای جمع دو عدد از نوع مختلف (مثلاً عدد صحیح و عدد اعشاری) بنویسید. اما با ژنریک، می‌توانید یک تابع جمع کننده عمومی بنویسید که با هر نوع داده‌ای کار کند.&lt;/p>
&lt;p>در اصطلاحات Go، از انواع نمادگذاری ژنریک می‌کنیم. این انواع می‌توانند به صورت متغیر باشند و از آن‌ها در تابع‌ها و ساختارهای داده استفاده کنید تا کدی ایجاد کنید که قابل استفاده با انواع مختلف داده‌ها باشد.&lt;/p>
&lt;p>از مزیت‌های ژنریک در Go می‌توان به کاهش تکرار کد، افزایش قابلیت خوانایی کد و افزایش انعطاف‌پذیری برنامه اشاره کرد. با استفاده از این قابلیت، می‌توانید کدهای بهینه‌تری بنویسید و طراحی بهتری داشته باشید.&lt;/p>
&lt;p>بنابراین، ژنریک در Go به شما این امکان را می‌دهد که کدهای کلی‌تر و کاربردی‌تری بنویسید که با انواع مختلف داده‌ها سازگار باشند و به عنوان یک توسعه‌دهنده جوان، این ابزار قدرتمند را در توسعه نرم‌افزار‌های خود بهره‌بری کنید.&lt;/p></description></item><item><author/><title>فصل هفتم: تست نویسی</title><link>https://book.gofarsi.ir/chapter-7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-7/</guid><description>&lt;p>در این فصل به صورت عمیق به مباحث تست‌نویسی در زبان Go پرداخته شده است که شامل عناوین زیر می‌باشد.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="go-introduction-testing">۷.۱ مقدمه‌ای بر تست در Go.&lt;/a>&lt;/li>
&lt;li>&lt;a href="go-unit-testing">۷.۲ تست واحد &lt;span class="tooltip" data-tooltip="Unit Test" ontouchend="toggleTooltip(this)">Unit Test&lt;/span>
.&lt;/a>&lt;/li>
&lt;li>&lt;a href="go-table-driven-tests">۷.۳ تست جدول‌محور &lt;span class="tooltip" data-tooltip="table-driven test" ontouchend="toggleTooltip(this)">Table-Driven Test&lt;/span>
.&lt;/a>&lt;/li>
&lt;li>&lt;a href="go-integration-testing">۷.۴ تست یکپارچه &lt;span class="tooltip" data-tooltip="integration test" ontouchend="toggleTooltip(this)">Integration Test&lt;/span>
.&lt;/a>&lt;/li>
&lt;li>&lt;a href="go-end-to-end-tests">۷.۵ تست انتها به انتها &lt;span class="tooltip" data-tooltip="end-to-end test" ontouchend="toggleTooltip(this)">End-to-End Test&lt;/span>
.&lt;/a>&lt;/li>
&lt;li>&lt;a href="go-benchmarking">۷.۶ تست عملکرد &lt;span class="tooltip" data-tooltip="benchmark" ontouchend="toggleTooltip(this)">Benchmark&lt;/span>
.&lt;/a>&lt;/li>
&lt;li>&lt;a href="go-fuzz-testing">۷.۷ تست فازی &lt;span class="tooltip" data-tooltip="fuzz testing" ontouchend="toggleTooltip(this)">Fuzz Testing&lt;/span>
.&lt;/a>&lt;/li>
&lt;li>&lt;a href="go-mocking">۷.۸ ماک و شبیه‌سازی وابستگی‌ها &lt;span class="tooltip" data-tooltip="mocking dependencies" ontouchend="toggleTooltip(this)">Mocking&lt;/span>
.&lt;/a>&lt;/li>
&lt;li>&lt;a href="go-testify">۷.۹ استفاده از کتابخانه testify برای assertions، mock و ساختاردهی تست‌ها.&lt;/a>&lt;/li>
&lt;li>&lt;a href="go-ginkgo-testing">۷.۱۰ استفاده از فریم‌ورک ginkgo برای تست‌های سبک BDD.&lt;/a>&lt;/li>
&lt;li>&lt;a href="go-concurrent-testing">۷.۱۱ تست‌های همزمانی و تحلیل race conditions.&lt;/a>&lt;/li>
&lt;li>&lt;a href="go-code-coverage">۷.۱۲ سنجش پوشش کد &lt;span class="tooltip" data-tooltip="code coverage" ontouchend="toggleTooltip(this)">Code Coverage&lt;/span>
و گزارش‌گیری.&lt;/a>&lt;/li>
&lt;li>&lt;a href="go-test-suites">۷.۱۳ مدیریت و گروه‌بندی تست‌ها با Test Suite.&lt;/a>&lt;/li>
&lt;li>&lt;a href="go-production-testing">۷.۱۴ تست‌نویسی حرفه‌ای در پروژه‌های واقعی.&lt;/a>&lt;/li>
&lt;/ul></description></item><item><author/><title>فصل هشتم: پکیج های استاندارد</title><link>https://book.gofarsi.ir/chapter-8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-8/</guid><description>&lt;p>در این فصل به مباحث پکیج های استاندارد در زبان گو میپردازیم&amp;hellip;&lt;/p></description></item><item><author/><title>فصل نهم: الگوهای طراحی</title><link>https://book.gofarsi.ir/chapter-9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/</guid><description>&lt;p>در این فصل، به مباحث الگوهای طراحی در زبان گو می‌پردازیم و سعی می‌کنیم به طور کلی و با مثال‌های مناسب، هر الگو را به شما آموزش دهیم و همچنین برخی از کاربردهای الگوها را نام ببریم.&lt;/p>
&lt;h2 id="الگوی-طراحی-چیست">
الگوی طراحی چیست؟
&lt;a class="anchor" href="#%d8%a7%d9%84%da%af%d9%88%db%8c-%d8%b7%d8%b1%d8%a7%d8%ad%db%8c-%da%86%db%8c%d8%b3%d8%aa">#&lt;/a>
&lt;/h2>
&lt;p>&lt;span class="tooltip" data-tooltip="Design patterns" ontouchend="toggleTooltip(this)">الگوهای طراحی&lt;/span>
، به عنوان راه‌حل‌های معمول برای مسائلی که در طراحی نرم‌افزار به طور متداول رخ می‌دهند، استفاده می‌شوند. آنها دستورالعمل‌هایی پیش‌فرض هستند که می‌توانید برای حل یک مسئله تکراری در کد خود استفاده کنید.&lt;/p>
&lt;h2 id="چرا-باید-الگوهای-طراحی-را-یاد-بگیریم">
چرا باید الگوهای طراحی را یاد بگیریم؟
&lt;a class="anchor" href="#%da%86%d8%b1%d8%a7-%d8%a8%d8%a7%db%8c%d8%af-%d8%a7%d9%84%da%af%d9%88%d9%87%d8%a7%db%8c-%d8%b7%d8%b1%d8%a7%d8%ad%db%8c-%d8%b1%d8%a7-%db%8c%d8%a7%d8%af-%d8%a8%da%af%db%8c%d8%b1%db%8c%d9%85">#&lt;/a>
&lt;/h2>
&lt;p>الگوهای طراحی، به شما کدهای برنامه برای حل یک مسئله ارائه نمی‌دهند. بلکه، آنها یک مفهوم کلی را برای حل یک مسئله در اختیار شما قرار می‌دهند و بر عهده شماست که این مفهوم را چگونه در برنامه خود پیاده‌سازی کنید.&lt;/p>
&lt;p>الگوهای طراحی، یک زبان مشترک را تعریف می‌کنند تا شما بتوانید با سایر توسعه‌دهندگان به طور موثرتری ارتباط برقرار کنید. به عنوان مثال، می‌توانید به هم‌تیمی خود بگویید: &amp;ldquo;می‌توانی این مسئله را با استفاده از الگوی &lt;span class="tooltip" data-tooltip="Singleton" ontouchend="toggleTooltip(this)">سینگلتون&lt;/span>
حل کنی.&amp;rdquo; و او همه ایده‌های پشت این الگو را درک خواهد کرد، بدون اینکه نیاز به توضیح اضافی داشته باشید.&lt;/p>
&lt;blockquote class="book-hint info">
بسیار مهم است، از الگوهای طراحی زمانی استفاده کنید که واقعاً نیاز دارید. این امر دقت و درک دقیق از مسئله و نیازهای طراحی شما را می‌طلبد. این موضوع کمک می‌کند تا شما کد &lt;span class="tooltip" data-tooltip="Maintainability" ontouchend="toggleTooltip(this)">قابل نگهداری&lt;/span>
، &lt;span class="tooltip" data-tooltip="Scalable" ontouchend="toggleTooltip(this)">قابل توسعه&lt;/span>
و &lt;span class="tooltip" data-tooltip="Readable" ontouchend="toggleTooltip(this)">خوانا&lt;/span>
توسعه دهید و همچنین از تجربه و دانش جمعی الگوها بهره‌برداری کنید. در نتیجه، درست استفاده کردن از الگوهای طراحی می‌تواند بهبود قابل توجهی در کیفیت و عملکرد برنامه شما ایجاد کند.
&lt;/blockquote>
&lt;h2 id="طبقهبندی-الگوهای-طراحی">
طبقه‌بندی الگوهای طراحی
&lt;a class="anchor" href="#%d8%b7%d8%a8%d9%82%d9%87%d8%a8%d9%86%d8%af%db%8c-%d8%a7%d9%84%da%af%d9%88%d9%87%d8%a7%db%8c-%d8%b7%d8%b1%d8%a7%d8%ad%db%8c">#&lt;/a>
&lt;/h2>
&lt;p>الگوهای طراحی با توجه به پیچیدگی، سطح جزئیات و مقیاس کاربرد در برنامه، متفاوت هستند.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>الگوهای طراحی &lt;span class="tooltip" data-tooltip="Creational" ontouchend="toggleTooltip(this)">سازنده&lt;/span>
&lt;/strong> مکانیزم‌های ایجاد شیء را ارائه می‌دهند که &lt;span class="tooltip" data-tooltip="Flexibility" ontouchend="toggleTooltip(this)">انعطاف‌پذیری&lt;/span>
و &lt;span class="tooltip" data-tooltip="Reusability" ontouchend="toggleTooltip(this)">استفاده مجدد&lt;/span>
از کد موجود را افزایش می‌دهند.&lt;/li>
&lt;li>&lt;strong>الگوهای طراحی &lt;span class="tooltip" data-tooltip="Structural" ontouchend="toggleTooltip(this)">ساختاری&lt;/span>
&lt;/strong> چگونگی ترکیب اشیاء و کلاس‌ها را به ساختارهای بزرگتر توضیح می‌دهد، در حالی که این ساختارها انعطاف‌پذیری و کارآمدی خود را حفظ می‌کنند.&lt;/li>
&lt;li>&lt;strong>الگوهای طراحی &lt;span class="tooltip" data-tooltip="Behavioral" ontouchend="toggleTooltip(this)">رفتاری&lt;/span>
&lt;/strong> مراقبت از ارتباطات مؤثر و تخصیص مسئولیت‌ها بین اشیاء را بر عهده دارند.&lt;/li>
&lt;/ul></description></item><item><author/><title>فصل دهم: الگوریتم و ساختار داده</title><link>https://book.gofarsi.ir/chapter-10/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-10/</guid><description>&lt;p>در این فصل به مباحث الگوریتم و ساختار داده در زبان گو میپردازیم&amp;hellip;&lt;/p></description></item><item><author/><title>فصل یازدهم: معماری های نرم افزار</title><link>https://book.gofarsi.ir/chapter-11/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-11/</guid><description>&lt;p>در این فصل به مباحث معماری های نرم افزار در زبان گو میپردازیم&amp;hellip;&lt;/p></description></item><item><author/><title>فصل دوازدهم: شبکه بلاکچین</title><link>https://book.gofarsi.ir/chapter-12/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/</guid><description>&lt;p>بلاکچین یک دفتر دیجیتال توزیع‌شده است که در آن تراکنش‌ها در یک ردیف متوالی بلوک‌ها ذخیره می‌شوند. هر بلوک حاوی مجموعه‌ای از تراکنش‌ها است و هر تراکنش پس از تأیید توسط رایانه‌های متعدد در شبکه، به طور دائمی به بلاکچین اضافه می‌شود. این پروسه تأیید، معمولاً از طریق فرایندی به نام استخراج انجام می‌گیرد که در آن معماهای ریاضی پیچیده‌ای حل می‌شوند. خاصیت مهم بلاکچین نامتمرکز بودن آن است که این امکان را فراهم می‌آورد تا هیچ شخص یا سازمانی به تنهایی نتواند داده‌ها را کنترل و یا تغییر دهد، این امر به افزایش امنیت و شفافیت در سیستم‌های مالی و دیگر بخش‌ها کمک می‌کند.&lt;/p>
&lt;p>علاوه بر کاربردهای مالی مانند ارز دیجیتال (مثلاً بیت کوین)، بلاکچین می‌تواند در زمینه‌های متعددی به اشتراک‌گذاری اطلاعات مورد استفاده قرار گیرد. به عنوان مثال، در زمینه حفظ حقوق مالکیت معنوی، ردیابی زنجیره تامین و حتی رأی‌گیری‌های الکترونیکی. ویژگی‌های منحصر به فرد آن مانند تغییرناپذیری داده‌ها، شفافیت و امنیت بالا، ظرفیت فراوانی برای ایجاد تحول دیجیتالی و اعتماد در تقریباً هر صنعتی را داراست. این فناوری هنوز در ابتدای راه خود قرار دارد و پتانسیل تغییرات عظیمی در نحوه تعاملات ما در دنیای دیجیتال را دارد.&lt;/p>
&lt;blockquote class="book-hint info">
&lt;p>&lt;strong>به نقل از ویکی پدیا:&lt;/strong>&lt;/p>
&lt;p>&lt;strong>زنجیرهٔ بلوکی&lt;/strong>&lt;a href="https://fa.wikipedia.org/wiki/%D8%B2%D9%86%D8%AC%DB%8C%D8%B1%D9%87_%D8%A8%D9%84%D9%88%DA%A9%DB%8C#cite_note-1">[۱]&lt;/a> (به &lt;a href="https://fa.wikipedia.org/wiki/%D8%B2%D8%A8%D8%A7%D9%86_%D8%A7%D9%86%DA%AF%D9%84%DB%8C%D8%B3%DB%8C" title="زبان انگلیسی">انگلیسی&lt;/a>: Blockchain)&lt;a href="https://fa.wikipedia.org/wiki/%D8%B2%D9%86%D8%AC%DB%8C%D8%B1%D9%87_%D8%A8%D9%84%D9%88%DA%A9%DB%8C#cite_note-fortune20160415-2">[۲]&lt;/a>&lt;a href="https://fa.wikipedia.org/wiki/%D8%B2%D9%86%D8%AC%DB%8C%D8%B1%D9%87_%D8%A8%D9%84%D9%88%DA%A9%DB%8C#cite_note-nyt201605210-3">[۳]&lt;/a> یک فناوری برای ثبت و ضبط داده‌ها به حساب می‌آید که به آن &lt;a href="https://fa.wikipedia.org/wiki/%D9%BE%D8%A7%DB%8C%DA%AF%D8%A7%D9%87_%D8%AF%D8%A7%D8%AF%D9%87" title="پایگاه داده">پایگاه داده&lt;/a> نیز گفته میشود. این داده‌ها می‌توانند برای نمونه تراکنش‌های بانکی باشند یا اسناد مالکیت، قرارها، پیام‌های شخصی یا دیگر اطلاعات. یکی از ویژگی های زنجیرهٔ بلوکی این است که کار ذخیرهٔ این داده‌ها بدون وجود یک مدیر و صاحب‌اختیار مرکزی امکان‌پذیر است و نمی‌توان با تخریب یک نقطهٔ مرکزی داده‌های ذخیره‌شده را تحریف یا نابود کرد که نام این ویژگی شبکه عمومی و غیرمتمرکز نام دارد. معروف‌ترین شبکه عمومی و غیرمتمرکزی که از این ویژگی بلاکچین استفاده میکند، رمز ارز &lt;a href="https://fa.wikipedia.org/wiki/%D8%A8%DB%8C%D8%AA%E2%80%8C%DA%A9%D9%88%DB%8C%D9%86" title="بیت‌کوین">بیت‌کوین&lt;/a>، &lt;a href="https://fa.wikipedia.org/wiki/%D8%A7%D8%AA%D8%B1%DB%8C%D9%88%D9%85" title="اتریوم">اتریوم&lt;/a> و &lt;a href="https://fa.wikipedia.org/wiki/%D8%AA%D8%AA%D8%B1_%28%D8%B1%D9%85%D8%B2%D8%A7%D8%B1%D8%B2%29" title="تتر (رمزارز)">تتر&lt;/a> است.&lt;/p>
&lt;/blockquote>
&lt;p>در این فصل ما بطور کلی بصورت پایه تا پیشرفته به مباحث بلاکچین میپردازیم و هدف از گذارندن این بخش رسیدن به بازار کار و یادگیری کامل بلاکچین خواهد بود.&lt;/p>
&lt;h2 id="بخش-ها">
بخش ها
&lt;a class="anchor" href="#%d8%a8%d8%ae%d8%b4-%d9%87%d8%a7">#&lt;/a>
&lt;/h2>
&lt;p>در این فصل ما 4 بخش داریم که به شرح زیر می باشد:&lt;/p>
&lt;ul>
&lt;li>آموزش صفر تا صد عناوین بلاکچین&lt;/li>
&lt;li>آموزش درخصوص شبکه بیت کوین&lt;/li>
&lt;li>آموزش درخصوص شبکه اتریوم&lt;/li>
&lt;li>آموزش درخصوص شبکه پکتوس&lt;/li>
&lt;/ul></description></item></channel></rss>