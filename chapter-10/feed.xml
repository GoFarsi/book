<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><author/><title>فصل دهم: الگوریتم و ساختار داده on زبان گو فارسی</title><link>https://book.gofarsi.ir/chapter-10/</link><description>Recent content in فصل دهم: الگوریتم و ساختار داده on زبان گو فارسی</description><generator>Hugo -- gohugo.io</generator><language>fa</language><copyright>2023 GoFarsi All rights reserved</copyright><atom:link href="https://book.gofarsi.ir/chapter-10/feed.xml" rel="self" type="application/rss+xml"/><item><author/><title/><link>https://book.gofarsi.ir/chapter-10/10.1--data-structures-queue-stack-lists/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-10/10.1--data-structures-queue-stack-lists/</guid><description>&lt;p>در این قسمت به بررسی مواردی مهم از ساختمان داده در زبان گو می‌پردازیم و این آموزش مناسب افرادی هست که با مباحث ساختمان داده آشنایی داشته باشند.&lt;/p>
&lt;h2 id="1011--queue-in-golang">
10.1.1 Queue in Golang
&lt;a class="anchor" href="#1011--queue-in-golang">#&lt;/a>
&lt;/h2>
&lt;p>یک صف (queue) ساده را می توان با استفاده از GO به کمک موارد زیر پیاده سازی کرد:&lt;/p>
&lt;ol>
&lt;li>container/list package&lt;/li>
&lt;li>slice&lt;/li>
&lt;/ol>
&lt;p>یک صف عملیات زیر را انجام می‌دهد:&lt;/p>
&lt;ol>
&lt;li>Enqueue&lt;/li>
&lt;li>Dequeue&lt;/li>
&lt;li>Front&lt;/li>
&lt;li>Size&lt;/li>
&lt;li>Empty&lt;/li>
&lt;/ol>
&lt;h3 id="10111---list-implementation">
10.1.1.1 &lt;strong>List Implementation&lt;/strong>
&lt;a class="anchor" href="#10111---list-implementation">#&lt;/a>
&lt;/h3>
&lt;p>پیاده سازی صف به کمک لیست‌ها&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;container/list&amp;quot;
&amp;quot;fmt&amp;quot;
)
type customQueue struct {
queue *list.List
}
func (c *customQueue) Enqueue(value string) {
c.queue.PushBack(value)
}
func (c *customQueue) Dequeue() error {
if c.queue.Len() &amp;gt; 0 {
ele := c.queue.Front()
c.queue.Remove(ele)
}
return fmt.Errorf(&amp;quot;Pop Error: Queue is empty&amp;quot;)
}
func (c *customQueue) Front() (string, error) {
if c.queue.Len() &amp;gt; 0 {
if val, ok := c.queue.Front().Value.(string); ok {
return val, nil
}
return &amp;quot;&amp;quot;, fmt.Errorf(&amp;quot;Peep Error: Queue Datatype is incorrect&amp;quot;)
}
return &amp;quot;&amp;quot;, fmt.Errorf(&amp;quot;Peep Error: Queue is empty&amp;quot;)
}
func (c *customQueue) Size() int {
return c.queue.Len()
}
func (c *customQueue) Empty() bool {
return c.queue.Len() == 0
}
func main() {
customQueue := &amp;amp;customQueue{
queue: list.New(),
}
fmt.Printf(&amp;quot;Enqueue: A\n&amp;quot;)
customQueue.Enqueue(&amp;quot;A&amp;quot;)
fmt.Printf(&amp;quot;Enqueue: B\n&amp;quot;)
customQueue.Enqueue(&amp;quot;B&amp;quot;)
fmt.Printf(&amp;quot;Size: %d\n&amp;quot;, customQueue.Size())
for customQueue.Size() &amp;gt; 0 {
frontVal, _ := customQueue.Front()
fmt.Printf(&amp;quot;Front: %s\n&amp;quot;, frontVal)
fmt.Printf(&amp;quot;Dequeue: %s\n&amp;quot;, frontVal)
customQueue.Dequeue()
}
fmt.Printf(&amp;quot;Size: %d\n&amp;quot;, customQueue.Size())
}
&lt;/code>&lt;/pre>
&lt;p>خروجی برنامه بالا:&lt;/p>
&lt;pre>&lt;code class="language-shell">Enqueue: A
Enqueue: B
Size: 2
Front: A
Dequeue: A
Front: B
Dequeue: B
Size: 0
&lt;/code>&lt;/pre>
&lt;h3 id="10112--slice-implementation">
10.1.1.2 &lt;strong>Slice Implementation&lt;/strong>
&lt;a class="anchor" href="#10112--slice-implementation">#&lt;/a>
&lt;/h3>
&lt;p>پیاده سازی صف به کمک slice&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;fmt&amp;quot;
&amp;quot;sync&amp;quot;
)
type customQueue struct {
queue []string
lock sync.RWMutex
}
func (c *customQueue) Enqueue(name string) {
c.lock.Lock()
defer c.lock.Unlock()
c.queue = append(c.queue, name)
}
func (c *customQueue) Dequeue() error {
if len(c.queue) &amp;gt; 0 {
c.lock.Lock()
defer c.lock.Unlock()
c.queue = c.queue[1:]
return nil
}
return fmt.Errorf(&amp;quot;Pop Error: Queue is empty&amp;quot;)
}
func (c *customQueue) Front() (string, error) {
if len(c.queue) &amp;gt; 0 {
c.lock.Lock()
defer c.lock.Unlock()
return c.queue[0], nil
}
return &amp;quot;&amp;quot;, fmt.Errorf(&amp;quot;Peep Error: Queue is empty&amp;quot;)
}
func (c *customQueue) Size() int {
return len(c.queue)
}
func (c *customQueue) Empty() bool {
return len(c.queue) == 0
}
func main() {
customQueue := &amp;amp;customQueue{
queue: make([]string, 0),
}
fmt.Printf(&amp;quot;Enqueue: A\n&amp;quot;)
customQueue.Enqueue(&amp;quot;A&amp;quot;)
fmt.Printf(&amp;quot;Enqueue: B\n&amp;quot;)
customQueue.Enqueue(&amp;quot;B&amp;quot;)
fmt.Printf(&amp;quot;Len: %d\n&amp;quot;, customQueue.Size())
for customQueue.Size() &amp;gt; 0 {
frontVal, _ := customQueue.Front()
fmt.Printf(&amp;quot;Front: %s\n&amp;quot;, frontVal)
fmt.Printf(&amp;quot;Dequeue: %s\n&amp;quot;, frontVal)
customQueue.Dequeue()
}
fmt.Printf(&amp;quot;Len: %d\n&amp;quot;, customQueue.Size())
}
&lt;/code>&lt;/pre>
&lt;p>خروجی برنامه بالا:&lt;/p>
&lt;pre>&lt;code class="language-none">Enqueue: A
Enqueue: B
Size: 2
Front: A
Dequeue: A
Front: B
Dequeue: B
Size: 0
&lt;/code>&lt;/pre>
&lt;h2 id="1012---stack-in-golang">
10.1.2 Stack in Golang
&lt;a class="anchor" href="#1012---stack-in-golang">#&lt;/a>
&lt;/h2>
&lt;p>یک پشته (Stack) ساده را می توان با استفاده از GO به کمک موارد زیر پیاده سازی کرد:&lt;/p>
&lt;ol>
&lt;li>container/list package&lt;/li>
&lt;li>slice&lt;/li>
&lt;/ol>
&lt;p>یک stack عملیات زیر را انجام می‌دهد:&lt;/p>
&lt;ol>
&lt;li>Push&lt;/li>
&lt;li>Pop&lt;/li>
&lt;li>Front&lt;/li>
&lt;li>Size&lt;/li>
&lt;li>Empty&lt;/li>
&lt;/ol>
&lt;h3 id="10121---list-implementation">
10.1.2.1 &lt;strong>List Implementation&lt;/strong>
&lt;a class="anchor" href="#10121---list-implementation">#&lt;/a>
&lt;/h3>
&lt;p>پیاده سازی پشته به کمک لیست‌ها&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;container/list&amp;quot;
&amp;quot;fmt&amp;quot;
)
type customStack struct {
stack *list.List
}
func (c *customStack) Push(value string) {
c.stack.PushFront(value)
}
func (c *customStack) Pop() error {
if c.stack.Len() &amp;gt; 0 {
ele := c.stack.Front()
c.stack.Remove(ele)
}
return fmt.Errorf(&amp;quot;Pop Error: Stack is empty&amp;quot;)
}
func (c *customStack) Front() (string, error) {
if c.stack.Len() &amp;gt; 0 {
if val, ok := c.stack.Front().Value.(string); ok {
return val, nil
}
return &amp;quot;&amp;quot;, fmt.Errorf(&amp;quot;Peep Error: Stack Datatype is incorrect&amp;quot;)
}
return &amp;quot;&amp;quot;, fmt.Errorf(&amp;quot;Peep Error: Stack is empty&amp;quot;)
}
func (c *customStack) Size() int {
return c.stack.Len()
}
func (c *customStack) Empty() bool {
return c.stack.Len() == 0
}
func main() {
customStack := &amp;amp;customStack{
stack: list.New(),
}
fmt.Printf(&amp;quot;Push: A\n&amp;quot;)
customStack.Push(&amp;quot;A&amp;quot;)
fmt.Printf(&amp;quot;Push: B\n&amp;quot;)
customStack.Push(&amp;quot;B&amp;quot;)
fmt.Printf(&amp;quot;Size: %d\n&amp;quot;, customStack.Size())
for customStack.Size() &amp;gt; 0 {
frontVal, _ := customStack.Front()
fmt.Printf(&amp;quot;Front: %s\n&amp;quot;, frontVal)
fmt.Printf(&amp;quot;Pop: %s\n&amp;quot;, frontVal)
customStack.Pop()
}
fmt.Printf(&amp;quot;Size: %d\n&amp;quot;, customStack.Size())
}
&lt;/code>&lt;/pre>
&lt;p>خروجی برنامه بالا:&lt;/p>
&lt;pre>&lt;code class="language-go">Push: A
Push: B
Size: 2
Front: B
Pop: B
Front: A
Pop: A
Size: 0
&lt;/code>&lt;/pre>
&lt;h3 id="10122---slice-implementation">
10.1.2.2 &lt;strong>Slice Implementation&lt;/strong>
&lt;a class="anchor" href="#10122---slice-implementation">#&lt;/a>
&lt;/h3>
&lt;p>پیاده سازی پشته به کمک slice&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;fmt&amp;quot;
&amp;quot;sync&amp;quot;
)
type customStack struct {
stack []string
lock sync.RWMutex
}
func (c *customStack) Push(name string) {
c.lock.Lock()
defer c.lock.Unlock()
c.stack = append(c.stack, name)
}
func (c *customStack) Pop() error {
len := len(c.stack)
if len &amp;gt; 0 {
c.lock.Lock()
defer c.lock.Unlock()
c.stack = c.stack[:len-1]
return nil
}
return fmt.Errorf(&amp;quot;Pop Error: Stack is empty&amp;quot;)
}
func (c *customStack) Front() (string, error) {
len := len(c.stack)
if len &amp;gt; 0 {
c.lock.Lock()
defer c.lock.Unlock()
return c.stack[len-1], nil
}
return &amp;quot;&amp;quot;, fmt.Errorf(&amp;quot;Peep Error: Stack is empty&amp;quot;)
}
func (c *customStack) Size() int {
return len(c.stack)
}
func (c *customStack) Empty() bool {
return len(c.stack) == 0
}
func main() {
customStack := &amp;amp;customStack{
stack: make([]string, 0),
}
fmt.Printf(&amp;quot;Push: A\n&amp;quot;)
customStack.Push(&amp;quot;A&amp;quot;)
fmt.Printf(&amp;quot;Push: B\n&amp;quot;)
customStack.Push(&amp;quot;B&amp;quot;)
fmt.Printf(&amp;quot;Size: %d\n&amp;quot;, customStack.Size())
for customStack.Size() &amp;gt; 0 {
frontVal, _ := customStack.Front()
fmt.Printf(&amp;quot;Front: %s\n&amp;quot;, frontVal)
fmt.Printf(&amp;quot;Pop: %s\n&amp;quot;, frontVal)
customStack.Pop()
}
fmt.Printf(&amp;quot;Size: %d\n&amp;quot;, customStack.Size())
}
&lt;/code>&lt;/pre>
&lt;p>خروجی برنامه بالا:&lt;/p>
&lt;pre>&lt;code class="language-go">Push: A
Push: B
Size: 2
Front: B
Pop: B
Front: A
Pop: A
Size: 0
&lt;/code>&lt;/pre>
&lt;h2 id="1013--set-implementation-in-golang">
10.1.3 Set implementation in Golang
&lt;a class="anchor" href="#1013--set-implementation-in-golang">#&lt;/a>
&lt;/h2>
&lt;p>مجموعه (set) یک ساختار داده ای است که عناصر را بدون نظم خاصی در خود نگه می دارد. یک عنصر فقط یک بار در یک مجموعه ظاهر می شود.&lt;/p>
&lt;p>Set را می توان با استفاده از map در GO پیاده سازی کرد. ما از map[string]struct{} برای مجموعه استفاده خواهیم کرد زیرا &lt;strong>struct{}&lt;/strong> هیچ حافظه ای اشغال نمی کند، بنابراین از نظر ذخیره سازی کارآمدتر است.&lt;br>
در زیر مثال ساده مجموعه (set) که دارای عملیات زیر است را داریم:&lt;/p>
&lt;ol>
&lt;li>Add&lt;/li>
&lt;li>Remove&lt;/li>
&lt;li>Exists&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;fmt&amp;quot;
)
//MakeSet initialize the set
func makeSet() *customSet {
return &amp;amp;customSet{
container: make(map[string]struct{}),
}
}
type customSet struct {
container map[string]struct{}
}
func (c *customSet) Exists(key string) bool {
_, exists := c.container[key]
return exists
}
func (c *customSet) Add(key string) {
c.container[key] = struct{}{}
}
func (c *customSet) Remove(key string) error {
_, exists := c.container[key]
if !exists {
return fmt.Errorf(&amp;quot;Remove Error: Item doesn't exist in set&amp;quot;)
}
delete(c.container, key)
return nil
}
func (c *customSet) Size() int {
return len(c.container)
}
func main() {
customSet := makeSet()
fmt.Printf(&amp;quot;Add: B\n&amp;quot;)
customSet.Add(&amp;quot;A&amp;quot;)
fmt.Printf(&amp;quot;Add: B\n&amp;quot;)
customSet.Add(&amp;quot;B&amp;quot;)
fmt.Printf(&amp;quot;Size: %d\n&amp;quot;, customSet.Size())
fmt.Printf(&amp;quot;A Exists?: %t\n&amp;quot;, customSet.Exists(&amp;quot;A&amp;quot;))
fmt.Printf(&amp;quot;B Exists?: %t\n&amp;quot;, customSet.Exists(&amp;quot;B&amp;quot;))
fmt.Printf(&amp;quot;C Exists?: %t\n&amp;quot;, customSet.Exists(&amp;quot;C&amp;quot;))
fmt.Printf(&amp;quot;Remove: B\n&amp;quot;)
customSet.Remove(&amp;quot;B&amp;quot;)
fmt.Printf(&amp;quot;B Exists?: %t\n&amp;quot;, customSet.Exists(&amp;quot;B&amp;quot;))
}
&lt;/code>&lt;/pre>
&lt;p>خروجی برنامه بالا:&lt;/p>
&lt;pre>&lt;code class="language-go">Add: B
Add: B
Size: 2
A Exists?: true
B Exists?: true
C Exists?: false
Remove: B
B Exists?: false
&lt;/code>&lt;/pre>
&lt;h2 id="1014--linked-list--in-golang">
10.1.4 Linked List in Golang
&lt;a class="anchor" href="#1014--linked-list--in-golang">#&lt;/a>
&lt;/h2>
&lt;p>لیست منفرد یک نوع ساده از لیست پیوندی است که امکان پیمایش در یک جهت یعنی جلو را فراهم می کند. هر گره در لیست پیوندی شامل بخش داده و اشاره گر به گره بعدی در لیست پیوند شده است.&lt;/p>
&lt;p>لیست پیوندی اجرا شده در مثال زیر از عملیات زیر پشتیبانی می کند.&lt;/p>
&lt;ol>
&lt;li>AddFront&lt;/li>
&lt;li>AddBack&lt;/li>
&lt;li>RemoveFront&lt;/li>
&lt;li>RemoveBack&lt;/li>
&lt;li>Traverse&lt;/li>
&lt;li>Front&lt;/li>
&lt;li>Size&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-go">package main
import &amp;quot;fmt&amp;quot;
type ele struct {
name string
next *ele
}
type singleList struct {
len int
head *ele
}
func initList() *singleList {
return &amp;amp;singleList{}
}
func (s *singleList) AddFront(name string) {
ele := &amp;amp;ele{
name: name,
}
if s.head == nil {
s.head = ele
} else {
ele.next = s.head
s.head = ele
}
s.len++
return
}
func (s *singleList) AddBack(name string) {
ele := &amp;amp;ele{
name: name,
}
if s.head == nil {
s.head = ele
} else {
current := s.head
for current.next != nil {
current = current.next
}
current.next = ele
}
s.len++
return
}
func (s *singleList) RemoveFront() error {
if s.head == nil {
return fmt.Errorf(&amp;quot;List is empty&amp;quot;)
}
s.head = s.head.next
s.len--
return nil
}
func (s *singleList) RemoveBack() error {
if s.head == nil {
return fmt.Errorf(&amp;quot;removeBack: List is empty&amp;quot;)
}
var prev *ele
current := s.head
for current.next != nil {
prev = current
current = current.next
}
if prev != nil {
prev.next = nil
} else {
s.head = nil
}
s.len--
return nil
}
func (s *singleList) Front() (string, error) {
if s.head == nil {
return &amp;quot;&amp;quot;, fmt.Errorf(&amp;quot;Single List is empty&amp;quot;)
}
return s.head.name, nil
}
func (s *singleList) Size() int {
return s.len
}
func (s *singleList) Traverse() error {
if s.head == nil {
return fmt.Errorf(&amp;quot;TranverseError: List is empty&amp;quot;)
}
current := s.head
for current != nil {
fmt.Println(current.name)
current = current.next
}
return nil
}
func main() {
singleList := initList()
fmt.Printf(&amp;quot;AddFront: A\n&amp;quot;)
singleList.AddFront(&amp;quot;A&amp;quot;)
fmt.Printf(&amp;quot;AddFront: B\n&amp;quot;)
singleList.AddFront(&amp;quot;B&amp;quot;)
fmt.Printf(&amp;quot;AddBack: C\n&amp;quot;)
singleList.AddBack(&amp;quot;C&amp;quot;)
fmt.Printf(&amp;quot;Size: %d\n&amp;quot;, singleList.Size())
err := singleList.Traverse()
if err != nil {
fmt.Println(err.Error())
}
fmt.Printf(&amp;quot;RemoveFront\n&amp;quot;)
err = singleList.RemoveFront()
if err != nil {
fmt.Printf(&amp;quot;RemoveFront Error: %s\n&amp;quot;, err.Error())
}
fmt.Printf(&amp;quot;RemoveBack\n&amp;quot;)
err = singleList.RemoveBack()
if err != nil {
fmt.Printf(&amp;quot;RemoveBack Error: %s\n&amp;quot;, err.Error())
}
fmt.Printf(&amp;quot;RemoveBack\n&amp;quot;)
err = singleList.RemoveBack()
if err != nil {
fmt.Printf(&amp;quot;RemoveBack Error: %s\n&amp;quot;, err.Error())
}
fmt.Printf(&amp;quot;RemoveBack\n&amp;quot;)
err = singleList.RemoveBack()
if err != nil {
fmt.Printf(&amp;quot;RemoveBack Error: %s\n&amp;quot;, err.Error())
}
err = singleList.Traverse()
if err != nil {
fmt.Println(err.Error())
}
fmt.Printf(&amp;quot;Size: %d\n&amp;quot;, singleList.Size())
}
&lt;/code>&lt;/pre>
&lt;p>خروجی برنامه بالا:&lt;/p>
&lt;pre>&lt;code class="language-shell">AddFront: A
AddFront: B
AddBack: C
Size: 3
B
A
C
RemoveFront
RemoveBack
RemoveBack
RemoveBack
RemoveBack Error: removeBack: List is empty
TranverseError: List is empty
Size: 0
&lt;/code>&lt;/pre>
&lt;h2 id="1015--doubly-linked-list-in-go">
10.1.5 Doubly Linked List in Go
&lt;a class="anchor" href="#1015--doubly-linked-list-in-go">#&lt;/a>
&lt;/h2>
&lt;p>یک لیست مضاعف (Doubly Linked) شامل سه قسمت در گره خود است.&lt;/p>
&lt;ul>
&lt;li>فیلد داده.&lt;/li>
&lt;li>یک اشاره گر بعدی به گره بعدی در لیست اشاره می کند.&lt;/li>
&lt;li>یک اشاره گر قبلی که به گره قبلی در لیست اشاره می کند.&lt;/li>
&lt;/ul>
&lt;p>در اینجا فیلدهای «داده‌ها» و «بعدی» مانند لیست‌های پیوندی منفرد هستند. فیلد اشاره گر «قبلی» ویژگی جدیدی است که لیست پیوندی را به لیست پیوندی دوگانه تبدیل می کند.&lt;/p>
&lt;p>در زیر نمونه ای از یک لیست با پیوند دوگانه آورده شده است. اشاره گر قبلی گره head (start) به Null اشاره می کند. به طور مشابه، اشاره گر Next آخرین گره به Null اشاره می کند.&lt;/p>
&lt;p>&lt;img src="../../assets/img/content/chapter10/data_struct/double_list.png" alt="array" />
برای پیاده‌سازی یک  doubly linked list در زبان Go، یک ساختار گره با داده‌ها، اشاره‌گر قبلی و اشاره‌گر بعدی، روش‌هایی برای افزودن گره‌ها در  doubly linked list (از قسمت جلویی یا از انتهای هر دو) و روش‌هایی برای پیمایش به جلو/عقب ایجاد کنید.&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import &amp;quot;fmt&amp;quot;
type node struct {
data string
prev *node
next *node
}
type doublyLinkedList struct {
len int
tail *node
head *node
}
func initDoublyList() *doublyLinkedList {
return &amp;amp;doublyLinkedList{}
}
func (d *doublyLinkedList) AddFrontNodeDLL(data string) {
newNode := &amp;amp;node{
data: data,
}
if d.head == nil {
d.head = newNode
d.tail = newNode
} else {
newNode.next = d.head
d.head.prev = newNode
d.head = newNode
}
d.len++
return
}
func (d *doublyLinkedList) AddEndNodeDLL(data string) {
newNode := &amp;amp;node{
data: data,
}
if d.head == nil {
d.head = newNode
d.tail = newNode
} else {
currentNode := d.head
for currentNode.next != nil {
currentNode = currentNode.next
}
newNode.prev = currentNode
currentNode.next = newNode
d.tail = newNode
}
d.len++
return
}
func (d *doublyLinkedList) TraverseForward() error {
if d.head == nil {
return fmt.Errorf(&amp;quot;TraverseError: List is empty&amp;quot;)
}
temp := d.head
for temp != nil {
fmt.Printf(&amp;quot;value = %v, prev = %v, next = %v\n&amp;quot;, temp.data, temp.prev, temp.next)
temp = temp.next
}
fmt.Println()
return nil
}
func (d *doublyLinkedList) TraverseReverse() error {
if d.head == nil {
return fmt.Errorf(&amp;quot;TraverseError: List is empty&amp;quot;)
}
temp := d.tail
for temp != nil {
fmt.Printf(&amp;quot;value = %v, prev = %v, next = %v\n&amp;quot;, temp.data, temp.prev, temp.next)
temp = temp.prev
}
fmt.Println()
return nil
}
func (d *doublyLinkedList) Size() int {
return d.len
}
func main() {
doublyList := initDoublyList()
fmt.Printf(&amp;quot;Add Front Node: C\n&amp;quot;)
doublyList.AddFrontNodeDLL(&amp;quot;C&amp;quot;)
fmt.Printf(&amp;quot;Add Front Node: B\n&amp;quot;)
doublyList.AddFrontNodeDLL(&amp;quot;B&amp;quot;)
fmt.Printf(&amp;quot;Add Front Node: A\n&amp;quot;)
doublyList.AddFrontNodeDLL(&amp;quot;A&amp;quot;)
fmt.Printf(&amp;quot;Add End Node: D\n&amp;quot;)
doublyList.AddEndNodeDLL(&amp;quot;D&amp;quot;)
fmt.Printf(&amp;quot;Add End Node: E\n&amp;quot;)
doublyList.AddEndNodeDLL(&amp;quot;E&amp;quot;)
fmt.Printf(&amp;quot;Size of doubly linked ist: %d\n&amp;quot;, doublyList.Size())
err := doublyList.TraverseForward()
if err != nil {
fmt.Println(err.Error())
}
err = doublyList.TraverseReverse()
if err != nil {
fmt.Println(err.Error())
}
}
&lt;/code>&lt;/pre>
&lt;p>خروجی مورد انتظار برابر حالت زیر است:&lt;/p>
&lt;pre>&lt;code class="language-shell">Add Front Node: C
Add Front Node: B
Add Front Node: A
Add End Node: D
Add End Node: E
Size of doubly linked ist: 5
value = A, prev = , next = &amp;amp;{B 0xc000070060 0xc000070020}
value = B, prev = &amp;amp;{A 0xc000070040}, next = &amp;amp;{C 0xc000070040 0xc000070080}
value = C, prev = &amp;amp;{B 0xc000070060 0xc000070020}, next = &amp;amp;{D 0xc000070020 0xc0000700a0}
value = D, prev = &amp;amp;{C 0xc000070040 0xc000070080}, next = &amp;amp;{E 0xc000070080 }
value = E, prev = &amp;amp;{D 0xc000070020 0xc0000700a0}, next =
value = E, prev = &amp;amp;{D 0xc000070020 0xc0000700a0}, next =
value = D, prev = &amp;amp;{C 0xc000070040 0xc000070080}, next = &amp;amp;{E 0xc000070080 }
value = C, prev = &amp;amp;{B 0xc000070060 0xc000070020}, next = &amp;amp;{D 0xc000070020 0xc0000700a0}
value = B, prev = &amp;amp;{A 0xc000070040}, next = &amp;amp;{C 0xc000070040 0xc000070080}
value = A, prev = , next = &amp;amp;{B 0xc000070060 0xc000070020}
&lt;/code>&lt;/pre>
&lt;h2 id="1016--tree-in-go">
10.1.6 Tree in Go
&lt;a class="anchor" href="#1016--tree-in-go">#&lt;/a>
&lt;/h2>
&lt;p>درخت به عنوان یک ساختمان داده غیرخطی تعریف می‌شود که از مجموعه‌ای از گره‌ها تشکیل شده است، و این گره‌ها توسط یال‌ها به یکدیگر متصل شده‌اند&lt;/p>
&lt;p>خواص یک درخت:&lt;/p>
&lt;ul>
&lt;li>درخت از یک گره ریشه و صفر یا چند درخت فرعی متصل به آن تشکیل شده است&lt;/li>
&lt;li>گره ریشه بالاترین گره درخت است&lt;/li>
&lt;li>گره‌های برگ گره‌هایی هستند که هیچ فرزندی ندارند&lt;/li>
&lt;li>عمق یک گره تعداد یال‌ها بین ریشه و خودش است&lt;/li>
&lt;li>ارتفاع یک گره تعداد یال‌ها بین خودش و دورترین گره برگ در زیردرخت خود است&lt;/li>
&lt;/ul>
&lt;p>‍‍&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import &amp;quot;fmt&amp;quot;
// Tree represents a tree structure.
type Tree struct {
root *TreeNode
}
// TreeNode represents a node in the tree.
type TreeNode struct {
data int
children []*TreeNode
}
// insertTree adds a new node with the given data as the root node of the tree.
func (tree *Tree) insertTree(data int) {
if tree.root == nil {
tree.root = &amp;amp;TreeNode{data: data}
}
}
// InsertNode adds a new node with the given data as a child of the specified node.
func (node *TreeNode) insertNode(data int) *TreeNode {
newNode := &amp;amp;TreeNode{data: data}
node.children = append(node.children, newNode)
return newNode
}
// deleteTree removes the specified node, starting from the root of the tree.
func (tree *Tree) deleteFromRoot(nodeToDelete *TreeNode) {
if tree.root != nil {
tree.root = tree.root.deleteNode(nodeToDelete)
}
}
// deleteNode recursively removes the specified node and its descendants from the current node's children.
func (node *TreeNode) deleteNode(nodeToDelete *TreeNode) *TreeNode {
var updatedChildren []*TreeNode
for _, child := range node.children {
if child != nodeToDelete {
updatedChildren = append(updatedChildren, child.deleteNode(nodeToDelete))
}
}
node.children = updatedChildren
return node
}
// searchFromRoot searches for a node with the specified data starting from the tree's root.
func (tree *Tree) searchFromRoot(data int) *TreeNode {
if tree.root != nil {
node := tree.root.searchFromNode(data)
return node
}
return nil
}
// searchFromNode searches for a node with the specified data starting from the current node.
func (node *TreeNode) searchFromNode(data int) *TreeNode {
if node.data == data {
return node
}
for _, child := range node.children {
if foundNode := child.searchFromNode(data); foundNode != nil {
return foundNode
}
}
return nil
}
// traverseFromRoot initiates a traversal of the tree starting from the root node.
func (tree *Tree) traverseFromRoot() {
if tree.root != nil {
tree.root.traverse()
}
}
// traverse performs a recursive traversal starting from the current node.
func (node *TreeNode) traverse() {
if node == nil {
return
}
fmt.Printf(&amp;quot;%d &amp;quot;, node.data)
for _, child := range node.children {
child.traverse()
}
}
func main() {
// Creating a Tree instance
tree := Tree{}
// Inserting nodes
tree.insertTree(1)
tree.root.insertNode(2)
node3 := tree.root.insertNode(3)
node4 := tree.root.insertNode(4)
node3.insertNode(5)
node3.insertNode(6)
node4.insertNode(7)
// Traversing and printing nodes
fmt.Println(&amp;quot;Traverse from root:&amp;quot;)
tree.root.traverse()
// Searching for node
fmt.Println(&amp;quot;\nSearch for node 3:&amp;quot;)
node := tree.searchFromRoot(3)
if node != nil {
fmt.Println(&amp;quot;node found&amp;quot;)
} else {
fmt.Println(&amp;quot;node not found&amp;quot;)
}
fmt.Println(&amp;quot;Search for node 8:&amp;quot;)
node8 := tree.searchFromRoot(8)
if node8 != nil {
fmt.Println(&amp;quot;node found&amp;quot;)
} else {
fmt.Println(&amp;quot;node not found&amp;quot;)
}
// Deleting a node
fmt.Println(&amp;quot;After deleting node 3:&amp;quot;)
tree.deleteFromRoot(node3)
tree.root.traverse()
}
&lt;/code>&lt;/pre>
&lt;p>خروجی برنامه بالا:&lt;/p>
&lt;pre>&lt;code class="language-go">Traverse from root:
1 2 3 5 6 4 7
Search for node 3
node found
Search for node 8
node not found
After deleting node 3:
1 2 4 7
&lt;/code>&lt;/pre>
&lt;h2 id="1017--binary-tree-in-go">
10.1.7 Binary Tree in Go
&lt;a class="anchor" href="#1017--binary-tree-in-go">#&lt;/a>
&lt;/h2>
&lt;p>درخت دودویی، نوعی ساختار داده‌ای درخت است که هر گره آن می‌تواند حداکثر دو فرزند (یک فرزند چپ و یک فرزند راست) داشته باشد&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import &amp;quot;fmt&amp;quot;
// BinaryTree represents a binary tree.
type BinaryTree struct {
root *BinaryNode
}
// BinaryNode represents a node in the binary tree.
type BinaryNode struct {
data int
left *BinaryNode
right *BinaryNode
}
// insertFromRoot inserts a new node with the given data into the tree.
func (tree *BinaryTree) insertFromRoot(data int) *BinaryTree {
if tree.root != nil {
tree.root.insertNode(data)
} else {
tree.root = &amp;amp;BinaryNode{data: data}
}
return tree
}
// insertNode inserts a new node with the given data into the subtree rooted at the current node using level-order traversal.
func (node *BinaryNode) insertNode(data int) *BinaryNode {
var tempNode *BinaryNode
queue := []*BinaryNode{node}
for len(queue) &amp;gt; 0 {
tempNode, queue = queue[0], queue[1:]
if tempNode.left == nil {
tempNode.left = &amp;amp;BinaryNode{data: data}
break
}
queue = append(queue, tempNode.left)
if tempNode.right == nil {
tempNode.right = &amp;amp;BinaryNode{data: data}
break
}
queue = append(queue, tempNode.right)
}
return node
}
// deleteFromRoot deletes a specific node from the binary tree starting from the root.
func (tree *BinaryTree) deleteFromRoot(nodeToDelete *BinaryNode) {
if tree.root != nil {
tree.root.deleteNode(nodeToDelete)
}
}
// deletetNode attempts to delete a specific node from the subtree rooted at the current node.
func (node *BinaryNode) deleteNode(nodeToDelete *BinaryNode) *BinaryNode {
var keyNode, lastNode, tempNode *BinaryNode
queue := []*BinaryNode{node}
for len(queue) &amp;gt; 0 {
tempNode, queue = queue[0], queue[1:]
if tempNode == nodeToDelete {
keyNode = tempNode
}
if tempNode.left != nil {
lastNode, queue = tempNode, append(queue, tempNode.left)
}
if tempNode.right != nil {
lastNode, queue = tempNode, append(queue, tempNode.right)
}
}
if keyNode != nil {
keyNode.data = tempNode.data
if lastNode.right == tempNode {
lastNode.right = nil
} else {
lastNode.left = nil
}
}
return node
}
// searchFromRoot searches for a node with the given data in the binary tree starting from the root.
func (tree *BinaryTree) searchFromRoot(data int) *BinaryNode {
if tree.root != nil {
return tree.root.searchFromNode(data)
}
return nil
}
// searchFromNode performs a level-order traversal to find a node with the given data
func (node *BinaryNode) searchFromNode(data int) *BinaryNode {
var tempNode *BinaryNode
queue := []*BinaryNode{node}
for len(queue) &amp;gt; 0 {
tempNode, queue = queue[0], queue[1:]
if tempNode.data == data {
return tempNode
}
if tempNode.left != nil {
queue = append(queue, tempNode.left)
}
if tempNode.right != nil {
queue = append(queue, tempNode.right)
}
}
return nil
}
// printTreeInOrder prints the values of nodes in the binary tree starting from root using an in-order traversal.
func (tree *BinaryTree) printTreeInOrder() {
if tree.root != nil {
tree.root.printSubTreeInOrder()
}
}
// printTreePreOrder prints the values of nodes in the binary tree starting from root using a pre-order traversal.
func (tree *BinaryTree) printTreePreOrder() {
if tree.root != nil {
tree.root.printSubTreePreOrder()
}
}
// printTreePostOrder prints the values of nodes in the binary tree starting from root using a post-order traversal.
func (tree *BinaryTree) printTreePostOrder() {
if tree.root != nil {
tree.root.printSubTreePostOrder()
}
}
// printSubTreeInOrder prints the values of nodes in the subtree rooted at the given node using an in-order traversal.
func (node *BinaryNode) printSubTreeInOrder() {
if node != nil {
node.left.printSubTreeInOrder()
fmt.Printf(&amp;quot;%d &amp;quot;, node.data)
node.right.printSubTreeInOrder()
}
}
// printSubTreePreOrder prints the values of nodes in the subtree rooted at the given node using a pre-order traversal.
func (node *BinaryNode) printSubTreePreOrder() {
if node != nil {
fmt.Printf(&amp;quot;%d &amp;quot;, node.data)
node.left.printSubTreePreOrder()
node.right.printSubTreePreOrder()
}
}
// printSubTreePostOrder prints the values of nodes in the subtree rooted at the given node using a post-order traversal.
func (node *BinaryNode) printSubTreePostOrder() {
if node != nil {
node.left.printSubTreePostOrder()
node.right.printSubTreePostOrder()
fmt.Printf(&amp;quot;%d &amp;quot;, node.data)
}
}
func main() {
// Create a new binary tree
tree := BinaryTree{}
// Insert nodes
tree.insertFromRoot(1)
tree.insertFromRoot(2)
tree.insertFromRoot(3)
tree.insertFromRoot(4)
tree.insertFromRoot(5)
tree.insertFromRoot(6)
tree.insertFromRoot(7)
fmt.Println(&amp;quot;In-Order Traversal:&amp;quot;)
tree.printTreeInOrder()
fmt.Println(&amp;quot;\nPre-Order Traversal:&amp;quot;)
tree.printTreePreOrder()
fmt.Println(&amp;quot;\nPost-Order Traversal:&amp;quot;)
tree.printTreePostOrder()
// Search for a node
fmt.Println(&amp;quot;\n\nSearching for node with data 6:&amp;quot;)
nodeToSearch := tree.searchFromRoot(6)
if nodeToSearch != nil {
fmt.Println(&amp;quot;found node with data 6:&amp;quot;, nodeToSearch.data)
} else {
fmt.Println(&amp;quot;node with data 6 not found.&amp;quot;)
}
fmt.Println(&amp;quot;\nSearching for node with data 9:&amp;quot;)
nodeToSearch = tree.searchFromRoot(9)
if nodeToSearch != nil {
fmt.Println(&amp;quot;found node with data 9:&amp;quot;, nodeToSearch.data)
} else {
fmt.Println(&amp;quot;node with data 9 not found.&amp;quot;)
}
fmt.Println(&amp;quot;\nDeleting node with data 4:&amp;quot;)
nodeToDelete := tree.searchFromRoot(4)
if nodeToDelete != nil {
fmt.Println(&amp;quot;deleted node with data 4.&amp;quot;)
tree.deleteFromRoot(nodeToDelete)
} else {
fmt.Println(&amp;quot;node with data 4 not found.&amp;quot;)
}
fmt.Println(&amp;quot;\nIn-Order Traversal after deletion:&amp;quot;)
tree.printTreeInOrder()
}
&lt;/code>&lt;/pre>
&lt;p>خروجی کد بالا:&lt;/p>
&lt;pre>&lt;code class="language-go">In-Order Traversal:
4 2 5 1 6 3 7
Pre-Order Traversal:
1 2 4 5 3 6 7
Post-Order Traversal:
4 5 2 6 7 3 1
Searching for node with data 6:
found node with data 6: 6
Searching for node with data 9:
node with data 9 not found.
Deleting node with data 4:
deleted node with data 4.
In-Order Traversal after deletion:
7 2 5 1 6 3
&lt;/code>&lt;/pre>
&lt;h2 id="1018--binary-search-tree-in-go">
10.1.8 Binary Search Tree in Go
&lt;a class="anchor" href="#1018--binary-search-tree-in-go">#&lt;/a>
&lt;/h2>
&lt;p>درخت جستجو دودویی یک نوع از درخت دودویی است که ب هر گره دارای یک مقدار داده و دو زیردرخت (زیردرخت چپ و زیردرخت راست) می‌باشد. در این درخت، داده‌های کوچکتر از مقدار دادهٔ گره مورد نظر در زیردرخت چپ قرار می‌گیرند و داده‌های بزرگتر در زیردرخت راست قرار می‌گیرند . درخت جستجو دودویی به گونه ای طراحی شده است که عملیات جستجو، افزودن و حذف به طور موثر انجام شود&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import &amp;quot;fmt&amp;quot;
// BinarySearchTree represents a binary search tree.
type BinarySearchTree struct {
root *BinarySearchNode
}
// BinarySearchNode represents a node in the binary search tree.
type BinarySearchNode struct {
data int
left *BinarySearchNode
right *BinarySearchNode
}
// insertFromRoot inserts a new node with the given data into the binary search tree, starting from the root of the tree.
func (tree *BinarySearchTree) insertFromRoot(data int) *BinarySearchTree {
if tree.root != nil {
tree.root.insertNode(data)
} else {
tree.root = &amp;amp;BinarySearchNode{data: data}
}
return tree
}
// insertNode inserts a new node with the given data into the binary search tree rooted at the current node.
func (node *BinarySearchNode) insertNode(data int) *BinarySearchNode {
if node == nil {
return &amp;amp;BinarySearchNode{data: data}
} else if data == node.data {
return node
} else if data &amp;gt; node.data {
node.right = node.right.insertNode(data)
} else {
node.left = node.left.insertNode(data)
}
return node
}
// deleteFromRoot deletes a specific node from the binary search tree starting from the root node.
func (tree *BinarySearchTree) deleteFromRoot(nodeToDelete *BinarySearchNode) *BinarySearchNode {
if tree.root != nil {
return tree.root.left.deleteNode(nodeToDelete)
}
return nil
}
// deleteNode recursively deletes a specific node from the subtree rooted at the current node.
func (node *BinarySearchNode) deleteNode(nodeToDelete *BinarySearchNode) *BinarySearchNode {
if node == nil {
return nil
}
if nodeToDelete.data &amp;lt; node.data {
node.left = node.left.deleteNode(nodeToDelete)
} else if nodeToDelete.data &amp;gt; node.data {
node.right = node.right.deleteNode(nodeToDelete)
} else {
if node.left == nil {
return node.right
} else if node.right == nil {
return node.left
}
minNode := node.right.findMin()
node.data = minNode.data
node.right = node.right.deleteNode(nodeToDelete)
}
return node
}
// findMin returns the minimum node value in the subtree rooted at the current node.
func (node *BinarySearchNode) findMin() *BinarySearchNode {
for node.left != nil {
node = node.left
}
return node
}
// searchFromRoot searches for a node with the specified data in the binary search tree starting from the root node.
func (tree *BinarySearchTree) searchFromRoot(data int) *BinarySearchNode {
if tree.root != nil {
return tree.root.searchNode(data)
}
return nil
}
// searchNode recursively searches for a node with the specified data in the subtree rooted at the current node.
func (node *BinarySearchNode) searchNode(data int) *BinarySearchNode {
if node == nil {
return nil
}
if node.data == data {
return node
} else if data &amp;gt; node.data {
return node.right.searchNode(data)
} else if data &amp;lt; node.data {
return node.left.searchNode(data)
}
return nil
}
// printTreeInOrder prints the values of nodes in the binary search tree starting from root using an in-order traversal.
func (tree *BinarySearchTree) printTreeInOrder() {
if tree.root != nil {
tree.root.printSubTreeInOrder()
}
}
// printTreePreOrder prints the values of nodes in the binary search tree starting from root using a pre-order traversal.
func (tree *BinarySearchTree) printTreePreOrder() {
if tree.root != nil {
tree.root.printSubTreePreOrder()
}
}
// printTreePostOrder prints the values of nodes in the binary search tree starting from root using a post-order traversal.
func (tree *BinarySearchTree) printTreePostOrder() {
if tree.root != nil {
tree.root.printSubTreePostOrder()
}
}
// printSubTreeInOrder prints the values of nodes in the subtree rooted at the given node using an in-order traversal.
func (node *BinarySearchNode) printSubTreeInOrder() {
if node != nil {
node.left.printSubTreeInOrder()
fmt.Printf(&amp;quot;%d &amp;quot;, node.data)
node.right.printSubTreeInOrder()
}
}
// printSubTreePreOrder prints the values of nodes in the subtree rooted at the given node using a pre-order traversal.
func (node *BinarySearchNode) printSubTreePreOrder() {
if node != nil {
fmt.Printf(&amp;quot;%d &amp;quot;, node.data)
node.left.printSubTreePreOrder()
node.right.printSubTreePreOrder()
}
}
// printSubTreePostOrder prints the values of nodes in the subtree rooted at the given node using a post-order traversal.
func (node *BinarySearchNode) printSubTreePostOrder() {
if node != nil {
node.left.printSubTreePostOrder()
node.right.printSubTreePostOrder()
fmt.Printf(&amp;quot;%d &amp;quot;, node.data)
}
}
func main() {
// Create a BinarySearchTree
bst := &amp;amp;BinarySearchTree{}
bst.insertFromRoot(5).insertFromRoot(3).insertFromRoot(7).
insertFromRoot(2).insertFromRoot(4)
fmt.Println(&amp;quot;In-order traversal:&amp;quot;)
bst.printTreeInOrder()
fmt.Println(&amp;quot;\nPre-order traversal:&amp;quot;)
bst.printTreePreOrder()
fmt.Println(&amp;quot;\nPost-order traversal:&amp;quot;)
bst.printTreePostOrder()
// Search for a node
fmt.Println(&amp;quot;\n Searching for node with data 1&amp;quot;)
searchNode := bst.searchFromRoot(1)
if searchNode != nil {
fmt.Printf(&amp;quot;Node %d found.\n&amp;quot;, searchNode.data)
} else {
fmt.Println(&amp;quot;Node not found.&amp;quot;)
}
// Search for a node
fmt.Println(&amp;quot;Searching for node with data 3&amp;quot;)
searchNode = bst.searchFromRoot(3)
if searchNode != nil {
fmt.Printf(&amp;quot;Node %d found.\n&amp;quot;, searchNode.data)
} else {
fmt.Println(&amp;quot;Node not found.&amp;quot;)
}
// Delete a node
bst.deleteFromRoot(searchNode)
fmt.Println(&amp;quot;In-order traversal after deleting 3:&amp;quot;)
bst.printTreeInOrder()
}
&lt;/code>&lt;/pre>
&lt;p>خروجی کد بالا:&lt;/p>
&lt;pre>&lt;code class="language-go">In-order traversal:
2 3 4 5 7
Pre-order traversal:
5 3 2 4 7
Post-order traversal:
2 4 3 7 5
Searching for node with data 1
Node not found.
Searching for node with data 3
Node 3 found.
In-order traversal after deleting 3:
2 4 5 7
&lt;/code>&lt;/pre></description></item></channel></rss>