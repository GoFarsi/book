[{"id":0,"href":"/sponsors/","title":"اسپانسرهای کتاب","section":"صفحه اصلی","content":" سرویس ابری فینگ سکوی ابری\nبا سکوی ابری فینگ شما روی کد تمرکز کنید، فینگ آن را اجرا می‌کند.\nمشاهده سرویس\nاسپانسر کتاب شوید اسپانسر\nشما هم می توانید با ارایه خدمات خود اسپانسر کتاب شوید.\nدرخواست اسپانسر شدن\n"},{"id":1,"href":"/preface/","title":"پیشگفتار","section":"صفحه اصلی","content":" چرا از گو استفاده می‌کنیم؟\nوقتی در نوامبر سال ۲۰۰۹ رابرت گریسیمر، راب پایک و کن تامپسون برای اولین‌بار گو را بصورت عمومی انتشار دادند، خودشان مطمئن نبودند که به‌صورت گسترده مورد استفاده قرار می‌گیرد یا خیر. تا به تاریخ انتشار این مطلب، مشخص شده،‌گو بسیار فراگیرتر و رشد آن در صنعت وسیع‌تر از چیزی بوده‌است که ایجادکنندگان آن حدس می‌زدند. این‌ها نمونه‌هایی از کاربرد گو در دنیای امروز تکنولوژی هستند:\nGoogle’s Core Data Solutions Team Uses Go تیم راهکار هسته‌ی داده گوگل از گو استفاده می‌کند Chrome Content Optimization Service Runs on Go سرویس بهینه‌سازی محتوا در گوگل‌کروم توسط گو در حال اجراست Chrome’s user experience strategy, operating in the critical path for users is implemented in Go استراتژی حیاتی تجربه کاربری در کروم توسط گو پیاده‌سازی شده است Firebase Hosting Team Scaled With Go ابزار قدرتمند فایربیس توسط گو گسترش یافته است همچنین در صفحه رسمی گو می‌توانید لیستی از شرکت‌ها از Netflix و PayPal تا Uber و Microsoft رو به‌همراه خدماتی که از گو گرفته‌اند رو ملاحظه کنید. https://go.dev/solutions/#case-studies شناخت نیازمندی و ابزارهای پیاده‌سازی وابسته به آن.\nCloud \u0026amp; Network Services Command-line Interfaces Web Development DevOps \u0026amp; Site Reliability انواع منابع موجود جهت کسب اطلاعات و مقایسه‌ی آنها.\nمنابع مکتوب. سایت رسمی زبان گو. https://go.dev در نسخه حال‌حاضر وب‌سایت رسمی گو، مستندات لازم برای شناخت انواع جزئیات وجود دارد. ضمن‌اینکه یک خودآموز مختصر، جهت آشنایی ابتدایی مفاهیم را می‌توانید پیدا کنید. کتاب‌ها. اصولاً استفاده از کتاب‌ها بدلیل اینکه عمدتاً توسط اساتید، متخصصین شناخته‌شده نگارش می‌شود، توصیه می‌گردد. ضمن اینکه کتاب‌ها معمولاً امکان اصلاحات مستمر و انتشار نسخه‌های جدید و به‌روزتر رو دارا هستند و توسط ناشران معتبر منتشر می‌شوند. مقالات. بدلیل راحت‌تر بودن نشر مقالات، طبیعتاً امکان وجود هرنوع مطلبی با هر سطح و کیفیتی از محتوا وجود دارد. بنابراین، در استفاده از این نوع منابع، احتیاط و حساسیت بالاتری مورد نیاز است. منابع صوتی و تصویری. مزیت بزرگ این نوع از منابع، سرعت و امکانات کافی در انتقال مطلب است. اما اشکالی که وجود دارد عدم امکان ساده‌ی اصلاح محتوا و به‌روزرسانی آن است. ضمن‌اینکه این نوع از منابع، مانند مقالات توسط افراد مختلف و با طیفی از انواع کیفیت‌های متفاوت، وجود دارد. بررسی وضعیت منابع فارسی زبان گو در زمان تهیه این کتاب. درحال‌حاضر منابع نگارشی با کیفیت مناسب به‌زبان فارسی بسیار محدود است. این یکی از دلایل «چرایی» نگارش این کتاب به‌زبان فارسی است. ما امیدواریم با مشارکت همه اساتید و متخصصین این حوزه، این کتاب منبع آموزشی باکیفیت، دردسترس عموم متقاضیان، جهت توسعه ابزارهای حرفه‌ای با زبان گو باشد.\nچرا به زبان فارسی می‌نویسیم. دوستان و همکاران بسیاری هستند،‌که این سوال را مطرح می‌کنند که وقتی نیاز به دانش زبان انگلیسی، برای کسب مهارت در این تخصص، یک «باید» محسوب می‌شود، چرا مطلب فارسی؟ جواب این سوال ساده‌تر از پیجیدگی‌هایی هست که بنظر می‌رسد: − ایجاد و رونق جامعه تخصصی فارسی‌زبان توسط موضوع «کتاب» − ایجاد فضایی جهت ایحاد پرسش و پاسخ فارسی‌زبان‌ها − ارائه یک ترجمه فارسی، از منابع اصلی تخصصی، با امکان مقایسه برداشت افراد مختلف از زبان تخصصی − سرعت دادن به یادگیری، حداقل در مفاهیم ابتدایی − برای نوجوانان و افرادی که به‌هر دلیل، درحال‌حاضر تسلط کافی روی زبان انگلیسی ندارند و ارائه راهکار جهت تمرین و شروع یادگیری منابع روی زبان تخصصی\nبرای چگونگی نگارش کتاب می‌توان به موارد زیر اشاره کرد:\nچگونه از جامعه تخصصی، می‌توان در آموزش،بهینه‌سازی و رشد دانش متقاضیان این تخصص استفاده کرد. یکی از وظایف هر استاد، تربیت «شاگرد» و توسعه دانش است. افراد تازه‌کار با دانش و تجربه پیشکسوتان، با سرعت و کیفیت بالاتر، تبدیل به متخصصین جدید خواهند شد. کیفیت جامعه متخصصین، امکان کنترل مصرف منابع و تولید ابزارهای مفید را تعیین خواهد کرد. کار تیمی، به فرهنگ «با هم کار کردن» نیازمند هست.\nچرخ را از نو نسازیم، تجربه‌ها را از نو «تجربه» نکنیم، آموزش ببینیم و آموزش بدهیم. با کمی دقت و تجربه، کاملاً بدیهی‌ست در مقام قیاس بین چند جامعه تخصصی همسان، برتری از آن کسانی‌ست که در انتقال دانش-تجربه دست‌و‌دل‌بازتر هستند. جامعه تخصصی با دانش و تجربه عمیق، نیازمند وجود «مبتدیان» با پتانسیل حداکثری است و این میسر نیست مگر با جریان ساده و پایدار آموزش \u0026hellip; دانش امروز، در هر رشته و هر سطح برآیند «انتقال» پیشینیان ما هست. بجای غرور ناشی از آن می‌توان از انتقال با احترام آن به دیگران لذت برد.\n«کلمات» قدرت دارند. به درک و استفاده از کلمات احترام بگذاریم. در جامعه تخصصی حتی چند‌برابر !!! تا جای ممکن، در استفاده از کلمات تخصصی در محل درست خود دقت شده تا مفهوم نادرست منتقل نشود. از شما خواننده عزیز هم تقاضا داریم، هرکجا ایرادی هرچند کوچک ملاحظه فرمودید، به ما اطلاع دهید یا درخواست اصلاح آن را ارسال کنید.\n"},{"id":2,"href":"/history/","title":"تاریخچه","section":"صفحه اصلی","content":"زبان گو (Go) در سال ۲۰۰۷ (به شمسی: ۱۳۸۶) توسط «شرکت گوگل» با هدف افزایش بهره‌وری برنامه‌نویسی در محیط چندهسته‌ای، رایانه‌های شبکه‌ای و کدبیس‌های بزرگ طراحی شد [به نقل از ویکی پدیا] و سپس به عنوان یک زبان کامپایلری و تایپ استاتیک در نوامبر سال ۲۰۰۹ بصورت عمومی با هدف کامپایل کارآمد ، اجرای کارآمد وسهولت برنامه نویسی معرفی شد که توسط شرکت گوگل توسعه داده شده است و بسیاری از اعضای تیم طراحی و توسعه زبان گو [Ken Thompson, Rob Pike, Robert Griesemer] سال ها تجربه در زمینه تحقیق و توسعه زبان برنامه نویسی دارند.\nزبان گو دارای یک سری ویژگی های منحصر به فرد می باشد و برخی از ویژگی هایش از سایر زبان ها الهام گرفته شده است :\nپشتیبانی از برنامه نویسی همزمانی بصورت Built-in گوروتین ها امکان اجرای همزمانی توابع را فراهم می کند و همچنین گوروتین ها واقعا خیلی سبک هستند به طوری که شما می توانید هزاران گوروتین را همزمان در سخت افزارهای مدرن بدون هیچ مشکل عملکردی اجرا کنید. کانال ها برپایه مدل CSP می باشد که امکان همگام سازی داده ها بین گوروتین ها را فراهم می کند. پشتیبانی از تایپ های map و slice امکان پیاده سازی پلی مورفیسم با استفاده از اینترفیس ها پوینترها کلوژر توابع (یک تابع معمولی که داخل یک تابع دیگر به عنوان بازگشت تعریف می شود) متدها امکان defer برای تعویق فراخوانی یک تابع قابلیت جاسازی تایپ ها ایمنی حافظه در زبان گو قابلیت زباله جمع کن خودکار سازگاری کامل با انواع پلتفرم ها نظیر [linux, windows, mac, AIX, android, freeBSD] جهت توسعه و کامپایل امکان Cross-compile با این امکان می توانید در هر پلتفرمی برای سایر پلتفرم ها کامپایل کنید پشتیبانی از جنریک یا تایپ پارامتر (از نسخه ۱.۱۸) تست نویسی آسان اینترفیس و رفلکشن زبان گو مثل سایر زبان ها نظیر c, cpp یا java نیاز به نقطه ویرگول (Semicolons) ندارد و به نسبت زبان هایی که معرفی کردیم پرانتز کمتری استفاده می کند و همچنین ظاهر سینتکس گو خیلی خواناتر و راحتر می باشد. علاوه بر ویژگی های که در بالا معرفی کردیم یک سری نکات برجسته در خصوص زبان گو وجود دارد که به شرح زیر می باشند:\nسینتکس زبان گو به گونه ای طراحی شده که خیلی ساده و تمیز می باشد و این باعث می شود خیلی سریع زبان گو را یاد بگیرید و از همه مهم تر توسعه پروژه های مقیاس پذیر مقیاس پذیر با زبان گو به دلیل سادگی و آشکار بودن مفاهیم خیلی سریعتر صورت میگیرد.\nزبان گو دارای کلی پکیج های استاندارد و کاربردی جهت توسعه می باشد که همه این پکیج ها در انواع پلتفرم ها جهت توسعه قابل استفاده است.\nزبان گو دارای یک جامعه بزرگ از توسعه دهندگان و انجمن های فعال می باشد که خیلی سریع می توانید به پاسخ سوالات خود برسید.\nبرنامه نویس های زبان گو را گوفر صدا میزنند. "},{"id":3,"href":"/installation/","title":"آموزش نصب","section":"صفحه اصلی","content":"جهت نصب زبان گو برروی سیستم عامل مورد نظر خود در ابتدا باید نسخه مناسب با پلت فرم خود را دانلود کنید.\nلینوکس در اینجا نسخه مرتبط با لینوکس خود را دانلود کنید. 1$ wget -c https://go.dev/dl/go1.xx.x.linux-amd64.tar.gz سپس دستور زیر را بزنید تا اگر نسخه قبلی وجود دارد پاک شود و نسخه جدید در مسیر usr/local/go/ جایگزین شود. 1$ sudo rm -rf /usr/local/go \u0026amp;\u0026amp; sudo tar -C /usr/local -xzf go1.xx.x.linux-amd64.tar.gz افزودن مسیر usr/local/go/bin/ به متغیرهای محیطی 1export PATH=$PATH:/usr/local/go/bin بهتر است برای اینکه هر بار ترمینال را باز میکنید و فایل go توسط shell شناخته شود دستور فوق را به فایل home/{user}/.profile/ اضافه کنید. جهت اطمینان از اینکه زبان گو بدرستی برروی سیستم عامل شما نصب شده است دستور زیر را داخل ترمینال بزنید. 1$ go version ویندوز روش اول # در اینجا نسخه مرتبط با ویندوز خود را دانلود کنید. سپس فایل go1.xx.x.windows-{arch}.msi را اجرا کنید. مراحل نصب را بصورت پیش فرض طی کنید تا زبان گو برروی ویندوز نصب شود. پس از نصب جهت اطمینان از نصب بود زبان گو مراحل زیر را انجام دهید: وارد منو استارت شوید. در منو استارت کلمه cmd را جستجو کنید و سپس آن را اجرا کنید. داخل خط فرمان دستور زیر را بزنید تا از نصب بودن زبان گو اطمینان حاصل فرمایید. 1go version روش دوم # برای نصب گو می‌توانید از Chocolatey Package Manager استفاده کنید.\nخط فرمان PowerShell را به صورت Administrator باز کنید و دستور زیر را داخل PowerShell بزنید. 1Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString(\u0026#39;https://community.chocolatey.org/install.ps1\u0026#39;)) بعد از نصب می‌توانید از دستور choco برای نصب گو استفاده کنید. 1choco install golang جهت اطمینان از اینکه زبان گو بدرستی برروی سیستم عامل شما نصب شده است دستور زیر را داخل ترمینال بزنید. 1$ go version دقت داشته باشید برای نصب برنامه‌های مختلف مثل git و یا ابزارهای دیگر در محیط Administrator باید از دستور choco استفاده کنید. مکینتاش روش اول # در اینجا نسخه مرتبط با مکینتاش خود را دانلود کنید. سپس فایل go1.xx.x.darwin-{arch}.pkg را اجرا کنید. مراحل نصب را بصورت پیش فرض طی کنید تا زبان گو برروی مکینتاش نصب شود. پس از نصب اگر ترمینال باز بود آن را کامل ببنید تا تغییرات صورت گیرد. جهت اطمینان از اینکه زبان گو بدرستی برروی سیستم عامل شما نصب شده است دستور زیر را داخل ترمینال بزنید. 1$ go version روش دوم # برای نصب گو میتوانید از Homebrew Package Manager استفاده کنید.\nبرای نصب brew می‌توانید ترمینال خود را باز کنید و از دستور زیر استفاده کنید. 1$ /bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026#34; بعد از نصب brew از دستور زیر برای نصب گو داخل ترمینال استفاده کنید. 1$ brew update \u0026amp;\u0026amp; brew install golang جهت اطمینان از اینکه زبان گو بدرستی برروی سیستم عامل شما نصب شده است دستور زیر را داخل ترمینال بزنید. 1$ go version "},{"id":4,"href":"/toolchain/","title":"ابزارها, دستورات گو و معرفی IDE","section":"صفحه اصلی","content":"پس از اینکه زبان گو را برروی سیستم خود نصب کردید از طریق ترمینال و یا خط فرمان ویندوز قابل دسترس است که می‌توانید با زدن کلمه go یکسری عملیات انجام دهید:\n1$ go 2Go is a tool for managing Go source code. 3 4Usage: 5 6\tgo \u0026lt;command\u0026gt; [arguments] 7 8The commands are: 9 10\tbug start a bug report 11\tbuild compile packages and dependencies 12\tclean remove object files and cached files 13\tdoc show documentation for package or symbol 14\tenv print Go environment information 15\tfix update packages to use new APIs 16\tfmt gofmt (reformat) package sources 17\tgenerate generate Go files by processing source 18\tget add dependencies to current module and install them 19\tinstall compile and install packages and dependencies 20\tlist list packages or modules 21\tmod module maintenance 22\twork workspace maintenance 23\trun compile and run Go program 24\ttest test packages 25\ttool run specified go tool 26\tversion print Go version 27\tvet report likely mistakes in packages 28 29Use \u0026#34;go help \u0026lt;command\u0026gt;\u0026#34; for more information about a command. 30 31Additional help topics: 32 33\tbuildconstraint build constraints 34\tbuildmode build modes 35\tc calling between Go and C 36\tcache build and test caching 37\tenvironment environment variables 38\tfiletype file types 39\tgo.mod the go.mod file 40\tgopath GOPATH environment variable 41\tgopath-get legacy GOPATH go get 42\tgoproxy module proxy protocol 43\timportpath import path syntax 44\tmodules modules, module versions, and more 45\tmodule-get module-aware go get 46\tmodule-auth module authentication using go.sum 47\tpackages package lists and patterns 48\tprivate configuration for downloading non-public code 49\ttestflag testing flags 50\ttestfunc testing functions 51\tvcs controlling version control with GOVCS 52 53Use \u0026#34;go help \u0026lt;topic\u0026gt;\u0026#34; for more information about that topic. جدول دستورات (Commands) # دستور توضیحات build با این دستور (go build main.go) می‌توانید فایل go را کامپایل کنید. clean با این دستور می‌توانید فایل‌های کش‌شده را پاکسازی کنید. doc با این دستور (go doc fmt.Println) می‌توانید داکیومنت هر یک از توابع عمومی را ببینید. env با این دستور می‌توانید متغیرهای محیطی تنظیم شده زبان گو را ببینید و آنها را با دستور go env -w key=value مقدار دهی کنید. fmt با این دستور می‌توانید کدهای خود را مرتب go fmt ./... کنید. install با استفاده از این دستور می‌توانید یکسری پکیج‌های را گرفته و کامپایل کنید. list لیست پکیج‌ها و ماژول‌های دانلود شده. generate با این دستور می‌توانید از قابلیتGenerator زبان گو استفاده کنید و فایل generate کنید. mod برای مدیریت و ایجاد فایل mod به ازای هر پروژه. get با این دستور می‌توانید پکیجی را دانلود یا بروز رسانی کنید و همچنین برای استفاده از این دستور نیاز به git دارید که نصب باشد. work با این دستور می‌توانید یک workspace ایجاد کنید و آن را مدیریت کنید. run با این دستور (go run main.go) می‌توانید فایل‌های گو یا پروژه را اجرا کنید. test با این دستور (go test example_test.go) می‌توانید فایل‌های تست را اجرا کنید. version با این دستور می‌توانید نسخه نصب شده زبان گو را ببینید. vet با این دستور می‌توانید اشتباهات کدهای خود را ببینید. اجرای کد ساده در زبان گو # در زیر یک نمونه کد ساده قرار دادیم که به سادگی می‌توانید با دستور go run main.go اجرا کنید و خروجی را ببینید.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 fmt.Println(\u0026#34;Hello world!!!\u0026#34;) 7} 1$ go run main.go 2Hello world!!! در کد فوق ما یکسری کلید واژه نظیر package , import , func استفاده کردیم که در بخش 1.2 کلید واژه و شناسه‌ها با آنها آشنا می‌شوید.\nانواع نرم‌افزارهای محیط توسعه (IDE) و ویرایش‌گر کد (Code Editor) # در زبان برنامه‌نویسی گو نیز مثل سایر زبان‌ها، می‌توان از ابزارهای کدنویسی مانند نرم‌افزارهای محیط توسعه و همچنین از ویرایش‌گرهای کد استفاده کرد که محبوب‌ترین‌ها معرفی می‌شوند:\nنرم‌افزار Jetbrains Goland اگر با سایر محصولات جت‌برینز آشنا باشید به‌راحتی می‌توانید از این نرم‌افزار محیط توسعه استفاده کنید. نرم‌افزار VsCode تقریباً همه برنامه‌نویس‌ها با آن آشنا هستند. یک ویرایش‌گر کد متن باز می‌باشد که بین برنامه‌نویس‌ها خیلی محبوب است و برای استفاده زبان گو در این نرم‌افزار می‌توان افزونه vscode-go را نصب کنید. نرم‌افزار Vim یک نرم‌افزار متن باز و معروف می‌باشد که داخل ترمینال قابل استفاده است و از آن می‌توانید جهت توسعه با زبان گو استفاده کنید و البته نیازمند نصب پلاگین می‌باشد. "},{"id":5,"href":"/roadmap/","title":"نقشه یادگیری زبان گو","section":"صفحه اصلی","content":"در زیر ما نقشه یادگیری زبان گو را براساس داده های سایت roadmap.sh قرار دادیم که در ابتدا باید طبق نقشه یادگیری زبان گو شروع کنید و سپس برای افزایش دانش خود به نقشه یادگیری بک اند نگاهی بندازید.\nنقشه یادگیری زبان گو نقشه یادگیری بک اند "},{"id":6,"href":"/changes-log/","title":"تغییرات نسخه های زبان گو","section":"صفحه اصلی","content":"\n2022-08-02 نسخه 1.19 بزودی تکمیل می شود\n2022-03-15 نسخه 1.18 بزودی تکمیل می شود\n2021-08-16 نسخه 1.17 بزودی تکمیل می شود\n2021-02-16 نسخه 1.16 بزودی تکمیل می شود\n2020-08-11 نسخه 1.15 بزودی تکمیل می شود\n2020-02-25 نسخه 1.14 بزودی تکمیل می شود\n2019-09-03 نسخه 1.13 بزودی تکمیل می شود\n2019-02-25 نسخه 1.12 بزودی تکمیل می شود\n2018-08-24 نسخه 1.11 بزودی تکمیل می شود\n2018-02-16 نسخه 1.10 بزودی تکمیل می شود\n2017-08-24 نسخه 1.9 بزودی تکمیل می شود\n2017-02-16 نسخه 1.8 بزودی تکمیل می شود\n2016-08-15 نسخه 1.7 بزودی تکمیل می شود\n2016-02-17 نسخه 1.6 بزودی تکمیل می شود\n2015-08-19 نسخه 1.5 بزودی تکمیل می شود\n2014-12-10 نسخه 1.4 بزودی تکمیل می شود\n2014-06-18 نسخه 1.3 بزودی تکمیل می شود\n2013-12-01 نسخه 1.2 بزودی تکمیل می شود\n2013-05-13 نسخه 1.1 بزودی تکمیل می شود\n2012-03-28 نسخه 1 بزودی تکمیل می شود\n"},{"id":7,"href":"/chapter-1/","title":"فصل اول: آشنایی با مفاهیم گو","section":"صفحه اصلی","content":"در فصل اول به مفاهیم پایه زبان برنامه نویسی گو بطور عمیق می بپردازیم. این فصل شامل چندین بخش هستش که در زیر بطور مختصر توضیح دادیم :\nبخش اول : ساختار کد گو بخش دوم : کلید واژه ها و شناسه ها بخش سوم : تایپ های پایه نظیر اعداد صحیح, float, رشته و boolean بخش چهارم : عملگرها نظیر = - / * + \u0026gt; \u0026lt; بخش پنجم : متغیرها و ثابت ها بخش ششم : تابع بخش هفتم : آرایه و slice بخش هشتم : نقشه بخش نهم : عبارات شرطی و switch بخش دهم : انواع حلقه ها بخش یازدهم : کار با پکیج ها و نحوه استفاده از پکیج بخش دوازدهم : به defer , panic, recovery می پردازیم "},{"id":8,"href":"/chapter-1/structure-of-go-code/","title":"1.1 ساختار کد گو","section":"فصل اول: آشنایی با مفاهیم گو","content":"همانطور که در تاریخچه زبان گو گفتیم, زبان گو سینتکس خیلی تمیز و ساده ای دارد که به راحتی می توانید کدهای زبان گو را بخوانید. در ادامه ما سعی می کنیم با مثال های ساده شما را با ساختار کد زبان گو آشنا کنیم.\nبه نقل از تاریخچه سینتکس زبان گو به گونه ای طراحی شده که خیلی ساده و تمیز می باشد و این باعث می شود خیلی سریع زبان گو را یاد بگیرید و از همه مهم تر توسعه پروژه های مقیاس پذیر با زبان گو به دلیل سادگی و آشکار بودن مفاهیم خیلی سریعتر صورت میگیرد. زبان برنامه نویسی # یک زبان برنامه‌نویسی یک زبان مصنوعی انگلیسی است که برای بیان محاسباتی که توسط یک ماشین (مخصوصاً رایانه) قابل انجام است، طراحی شده‌است. زبان‌های برنامه‌نویسی برای ایجاد برنامه‌هایی به کار می‌روند که رفتار یک ماشین را مشخص می‌کنند، الگوریتم دقیق را بیان می‌کنند، یا روشی برای تعامل انسان و رایانه هستند. بسیاری از زبان‌های برنامه‌نویسی تعدادی قالب از ویژگی‌های نوشته شده دستوری یا نحو (syntax) و معناشناسی (semantics) دارند، چرا که رایانه‌ها دستورهای دقیقاً مشخص نیاز دارند. برخی توسط سند خصوصیات (specification document) تعیین شده‌اند (برای مثال یک استاندارد ISO)، در حالی که برخی دیگر دارای پیاده‌سازی غالبی می‌باشند[به نقل از ویکی پدیا].\nیک نمونه کد ساده زبان گو # قبل از اینکه محتوای بدنه کد زیر را بررسی کنید بهتره نحوه کامنت گذاری کد در زبان گو آشنا شوید.\nکامنت گذاری # کامنت ها در زبان گو همانند زبان سی می باشد که با قرار دادن ۲ اسلش در ابتدای خط یا قرار دادن یک یا چند خط ما بین /* و */ ایجاد میشود.\n1// کامنت عادی یک خطی 2 3/* 4بلاک کامنت برای نوشتن کامنت چند خطی 5*/ نمونه کد # در پایین یک نمونه کد قرار دادیم که با کامنت هر کدام از بخش های بدنه کد گو را توضیح دادیم\n1package main // نام پکیج فایل سورس را مشخص می کند 2 3import \u0026#34;math/rand\u0026#34; // یک پکیج استاندارد ایمپورت شده 4 5const MaxRnd = 16 // یک ثابت تعریف شده است 6 7// تابع 8func StatRandomNumbers(n int) (int, int) { 9\tvar a, b int 10\tfor i := 0; i \u0026lt; n; i++ { 11\tif rand.Intn(MaxRnd) \u0026lt; MaxRnd/2 { 12\ta = a + 1 13\t} else { 14\tb++ 15\t} 16\t} 17\treturn a, b 18} 19 20// تابع main اولین نقطه شروع اجرای کد شما می باشد که در این تابع سایر موارد تعریف می شود. 21func main() { 22\tvar num = 100 23\tx, y := StatRandomNumbers(num) 24\tprint(\u0026#34;Result: \u0026#34;, x, \u0026#34; + \u0026#34;, y, \u0026#34; = \u0026#34;, num, \u0026#34;? \u0026#34;) 25\tprintln(x+y == num) 26} سورس کد بالا را در فایلی با نام main.go ذخیره می کنیم و سپس با دستور زیر اجرا می کنیم تا خروجی کد فوق را ببینیم :\n1$ go run basic-code-element-demo.go 2Result: 46 + 54 = 100? true تابع main # در زبان گو پکیج main به عنوان یک پکیج منحصربه فرد در نظر گرفته می‌شود، به شکلی که در هنگام اجرای برنامه مشخص میکند شروع کار و خواندن برنامه از کجا باید باشد. در نهایت داخل این پکیج ما تابع ()main را داریم که این تابع نقطه شروع اجرای برنامه ما خواهد بود. این تابع هیچ ارگومانی نمیگیرد و هیچ چیزی رو هم بازگشت نخواهد داد. زبان گو به صورت خودکار تابع ()main را فراخوانی می‌کند. برای همین نیازی به فراخوانی این تابع توسط شما وجود ندارد. برای همین باید دقت داشته باشید در هر برنامه ای که می‌نویسید حتما از پکیج و تابع main باید استفاده کنید.\n1// تعریف پکیج main 2package main 3 4// تعریف تابع main 5func main() { 6\tprintln(\u0026#34;Hello GoFarsi!\u0026#34;) 7} اجرای کد # برای اجرای کدهای گو می‌توان از پارامتر run استفاده کرد.\n1$ go run main.go 2Result: Hello GoFarsi! دستور بالا ابتدا داخل پوشه temp سیستم شما یک فایل اجرایی را درست میکند و سپس آن فایل را اجرا میکند و در نهایت خروجی را به ما نشان میدهد. اگر شما بخواهید خروجی فایل اجرایی (executable) داشته باشید و سپس آن را اجرا کنید می‌توانید از دستور زیر استفاده کنید:\n1$ go build main.go 2$ ./main 3Result: Hello GoFarsi! اگر بخواهید برای خروجی فایل اجرایی اسمی در نظر بگیرید میتوانید از دستور زیر با پارامتر o- استفاده کنید.\n1$ go build -o goFarsi main.go 2$ ./goFarsi 3Result: Hello GoFarsi! دقت کنید اگر از سیستم عامل ویندوز استفاده میکنید بعد از وارد کردن اسم پسوند exe را نیز اضافه کنید. برای راحتی و سرعت بخشیدن هنگام توسعه ما از دستور go run استفاده می‌کنیم. بررسی syntax # برخلاف بیشتر زبان‌های برنامه نویسی در زبان گو شما نمی‌توانید از حالت های مختلف برای نوشتن کد خود استفاده کنید. مثلا کد زیر هنگام کامپایل کردن خطا میدهد.\n1package main 2 3func main() 4{ 5\tprintln(\u0026#34;not compiled\u0026#34;) 6} خروجی کد بالا :\n1$ go run main.go 2Result: 3# command-line-arguments 4.\\main.go:4:1: syntax error: unexpected semicolon or newline before { صرفا با تغییر براکت ما با خطا مواجه شدیم. شاید از دید شما این نوع نوشتن کد نباید خطا ایجاد کند. ولی وقتی شما داخل یک تیم هستید و مجبور هستید کدها را بازخوانی کنید تا بفهمید چه اتفاقی افتاده است، با حالتهای مختلف سینتکس مواجه نخواهید شد، و همه کدها یک دست و از یک ساختار پیروی می‌کند. که باعث خواندن سریع تر، درک بهتر و امکان توسعه سریعتر را برای ما و هم تیمی های ما ایجاد خواهد کرد.\nاستفاده از go fmt # برای آنکه از این نوع خطاها جلوگیری شود و فرمت مناسب و یک نواختی داخل کدهای ما وجود داشته باشد، خود IDEها این خطاها را بهمون نشون میدن. خود توسعه دهندگان زبان گو پارامتر fmt یا به عبارتی فرمت را در اختیار ما قرار داده اند تا هر زمان که کدی مینویسم و ذخیره میکنیم بتوانیم با استفاده از این دستور ساختار کد خود را مرتب کنید و اگر خطایی وجود داشته باشد قبل از کامپایل کردن برنامه آن را پیدا و رفع کنیم. مثلا خروجی استفاده از پارامتر fmt\n1$ go fmt main.go 2Result: 3.\\main.go:4:1: unexpected semicolon or newline before { حالا فرض کنید کدی را نوشته اید و داخل کد شما فضای زیادی وجود دارد و اندازه tab ها و space ها مشخص نیست. به مثال زیر توجه کنید:\n1package main 2 3func main(){ 4 5 6 7\tprintln(\u0026#34;print line 1\u0026#34;) 8\t9\t10\t11\t12println(\u0026#34;print line 2\u0026#34;) 13\t14\t15} وقتی کدی شبیه کد بالا را دارید و از دستور go fmt استفاده میکنیم خروجی کد بالا به شکل زیر تغییر پیدا می‌کند:\n1package main 2 3func main() { 4 5\tprintln(\u0026#34;print line 1\u0026#34;) 6\t7\tprintln(\u0026#34;print line 2\u0026#34;) 8} در برنامه فوق ما یکسری کلمات کلیدی نظیر package, import, const, func, var , for, if, else, return استفاده کردیم و سایر کلماتی که داخل کد فوق دیدید به عنوان شناسه می باشد. برای اطلاعات بیشتر در خصوص کلید واژه و شناسه لطفا بخش کلید واژه و شناسه ها را مطالعه فرمایید. "},{"id":9,"href":"/chapter-1/go-built-in-keywords-identifiers/","title":"1.2 کلید واژه و شناسه‌ها","section":"فصل اول: آشنایی با مفاهیم گو","content":"در این بخش قصد داریم به کلید واژه و شناسه های زبان گو بپردازیم.\nکلید واژه # زبان گو تا نسخه فعلی فقط ۲۵ تا کلید واژه دارد که به شرح زیر است:\n1 2 3 4 5 1 break default func interface select 2 case defer go map struct 3 chan else goto package switch 4 const fallthrough if range type 5 continue for import return var کلمات کلیدی فوق به ۴ دسته تقسیم می‌شوند که به شرح زیر می‌باشد:\nکلمات کلیدی که بصورت گلوبال در بدنه قرار می‌گیرند «package, import, type, var, const, func» کلمات کلیدی کامپوزیت «struct, inteface, map, chan» کلمات کلیدی که در جریان کنترل کد استفاده می‌شوند «break, case, continue, default, if, else, for, fallthrough, goto, range, return, switch, select» در بخش های دیگر کتاب ما بطور مفصل به مفاهیم کلمات کلیدی فوق می‌پردازیم. شناسه‌ها # شناسه توکنی است که باید از حروف یونیکد, ارقام یونیکد (اعداد دسته بندی شده در استاندارد ۸.۰ یونیکد) و خط زیرین ـ تشکیل شده باشد.\nعلامت کاربرد ـ نادیده گرفتن \u0026amp; دسترسی به آدرس حافظه * دسترسی مقدار داخل یک خانه حافظه قوانین شناسه‌ها # نامگذاری باید از حروف a-z یا A-Z و یا 0-9 باشد. نام شناسه‌ها نباید با اعداد شروع شود. نام شناسه‌ها به حروف بزرگ و کوچک حساس می‌باشد. استفاده از کلید واژه ممنوع می‌باشد. هیچ محدودیتی در تعداد حروف نام شناسه وجود ندارد و مطلوب ترین حالت ۴ الی ۱۵ حرف می‌باشد. 1// شناسه‌های معتبر 2 3_geeks23 4geeks 5gek23sd 6Geeks 7geeKs 8geeks_geeks 9 10// شناسه‌های نامعتبر 11 12212geeks 13if 14default در زبان گو یکسری شناسه‌ها از قبل برای برخی از بخش های کد تعیین شده است که در زیر می‌توانید ببینید :\n1// Constant (ثابت ها) 2 3true, false, iota, nil 4 5// Types (تایپ ها) 6 7int, int8, int16, int32, int64, uint, 8uint8, uint16, uint32, uint64, uintptr, 9float32, float64, complex128, complex64, 10bool, byte, rune, string, error 11 12// Functions (توابع) 13 14make, len, cap, new, append, copy, close, 15delete, complex, real, imag, panic, recover "},{"id":10,"href":"/chapter-1/go-basic-types/","title":"1.3 تایپ های پایه","section":"فصل اول: آشنایی با مفاهیم گو","content":" تایپ چیست؟ # یک تایپ مشخص کننده نوع داده است، که به کامپایلر می‌گوید قرار است چه نوع داده ای داخل یک متغییر ذخیره گردد. زبان ها انواع تایپ های مختلفی به صورت پیشفرض دارند که می‌توان از آن‌ها داخل برنامه خود استفاده کرد. ما می‌توانیم تایپ ها را به دو دسته کلی تعریف کنیم.\nتایپ ایستا (Static Type) # زبانی مثل زبان گو یک زبان تایپ ایستا است، یعنی وقتی ما یک داده ای از نوع عددی داخل یک متغیر تعریف می‌کنیم داخل همان متغیر امکان اضافه کردن داده ای غیر داده عددی وجود ندارد.\nتایپ پویا (Dynamic Type) # زبان‌هایی مثل PHP، JavaScript و \u0026hellip; جزو زبان‌های تایپ پویا هستند. یعنی وقتی یک متغیری از نوع عددی تعریف می‌کنیم می‌توانیم به همان متغیر مقادیر دیگه‌ای مثل مقادیر رشته‌ای اضافه کنیم.\nبرای اطلاعات بیشتر می‌توان تایپ سیستم را داخل ویکی‌پدیا مطالعه کنید.\nتایپ‌ها در زبان گو # زبان گو مثل سایر زبان‌ها یکسری تایپ‌های پایه دارد که در هر بخش از کد گو می‌توانید استفاده کنید. در ادامه ما این تایپ ها را با مقادیر پیش فرض‌شان معرفی می کنیم.\nتایپ محدوده مقدار پیش فرض یا مقدار صفر حجم استفاده از حافظه int بستگی به معماری سیستم عامل که ۳۲ بیت یا ۶۴ بیت باشد 0 ۴ یا 8 بایت int8 128- تا 127 0 ۱ بایت int16 32768- تا 32767 0 ۲ بایت int32 2147483648- تا 2147483647 0 ۴ بایت int64 9223372036854775808- تا 9223372036854775807 0 8 بایت uint بستگی به معماری سیستم عامل که ۳۲ بیت یا ۶۴ بیت باشد 0 ۴ یا 8 بایت uint8 0 تا 255 0 ۱ بایت uint16 0 تا 65535 0 ۲ بایت uint32 0 تا 6294967295 0 ۴ بایت uint64 0 تا 18446744073709551615 0 8 بایت uintptr عدد خیلی بزرگ 0 ۸ بایت float32 IEEE-754 0 ۴ بایت float64 IEEE-754 0 ۸ بایت complex64 - 0+0i ۸ بایت complex128 - 0+0i ۱۶ بایت bool - false ۱ بایت string - \u0026quot; \u0026quot; ۸ بایت زبان گو بطور پیش فرض از دو نوع تایپ با نام مستعار پشتیبانی می کند :\nتایپ byte این تایپ نام مستعار برای تایپ uint8 می باشد. تایپ rune این تایپ نام مستعار برای تایپ int32 می باشد. سفارشی‌سازی تایپ‌(ها) # نام‌گذاری جدید : برای تایپ‌های رشته‌ای، عددی و بول، می‌توان نام سفارشی جدید انتخاب و در پروژه استفاده کرد: 1 2/* type alias */ 3 4// bul and bool define the same type. 5type bul = bool 6// content and string define the same type. 7type content = string 8// UI8, uint8 and byte define the same type. 9type UI8 = uint8 10// Word, rune and int32 define the same type. 11type Word = rune ایجاد تایپ جدید معادل یک تایپ موجود : همچنین می‌توان از تایپ‌های موجود، یک نمونه جدید ایجاد کرد: 1/* type definition */ 2 3// state and bool are two different types. 4type state bool 5// str and string are two different types. 6type str string 7// ID and uint64 are two different types. 8type ID uint64 9// decimal and float32 are two different types. 10type decimal float32 مقدار پیش فرض تایپ ها # هر یک از تایپ ها در زبان گو دارای مقدار پیش فرضی می باشد که به شرح زیر است :\nتایپ بولین مقدار پیش فرضش false می باشد. تمامی تایپ اعداد (int, uint, float) مقدار پیش فرضش صفر می باشد. تایپ استرینگ مقدار پیش فرضش \u0026quot; \u0026quot; می باشد. انواع مقادیر تایپ ها # در زبان گو تایپ ها یکسری مقادیر مختلفی را دریافت می کنند که در زیر به این مقادیر می پردازیم.\nتایپ بولین # تایپ بولین فقط true و false را به عنوان مقدار دریافت می کند.\nتایپ Integer # تایپ اعداد ۴ نوع مقدار مختلف دریافت می کند که به ترتیب Decimal (پایه ۱۰), Octal (پایه ۸), Hex (پایه ۱۶) و Binrary (پایه ۲ یا دودویی) می باشد.\n10xF // the hex form (starts with a \u0026#34;0x\u0026#34; or \u0026#34;0X\u0026#34;) 20XF 3 4017 // the octal form (starts with a \u0026#34;0\u0026#34;, \u0026#34;0o\u0026#34; or \u0026#34;0O\u0026#34;) 50o17 60O17 7 80b1111 // the binary form (starts with a \u0026#34;0b\u0026#34; or \u0026#34;0B\u0026#34;) 90B1111 10 1115 // the decimal form (starts without a \u0026#34;0\u0026#34;) 1package main 2 3func main() { 4\tprintln(15 == 017) // true 5\tprintln(15 == 0xF) // true 6} تایپ Float # تایپ Float چند نوع مقدار را دریافت می کند که به ترتیب مقدار ممیز شناور اعشاری ممکن است شامل یک قسمت صحیح اعشاری، یک نقطه اعشاری، یک قسمت کسری اعشاری، و یک قسمت توانی عدد صحیح (مبتنی بر 10) باشد.\n11.23 201.23 // == 1.23 3.23 41. 5// An \u0026#34;e\u0026#34; or \u0026#34;E\u0026#34; starts the exponent part (10-based). 61.23e2 // == 123.0 7123E2 // == 12300.0 8123.E+2 // == 12300.0 91e-1 // == 0.1 10.1e0 // == 0.1 110010e-2 // == 0.1 120e+5 // == 0.0 تایپ rune # تایپ rune یک تایپ با نام مستعار int32 می باشد که از تایپ های اعداد صحیح خاصی هستند. در rune برای ذخیره نقطه یونیکد یا حروف خاص استفاده می شود که زیر به عنوان نمونه قرار دادیم.\n1\u0026#39;a\u0026#39; // an English character 2\u0026#39;π\u0026#39; 3\u0026#39;众\u0026#39; // a Chinese character 1// 141 is the octal representation of decimal number 97. 2\u0026#39;\\141\u0026#39; 3// 61 is the hex representation of decimal number 97. 4\u0026#39;\\x61\u0026#39; 5\u0026#39;\\u0061\u0026#39; 6\u0026#39;\\U00000061\u0026#39; 1package main 2 3func main() { 4\tprintln(\u0026#39;a\u0026#39; == 97) 5\tprintln(\u0026#39;a\u0026#39; == \u0026#39;\\141\u0026#39;) 6\tprintln(\u0026#39;a\u0026#39; == \u0026#39;\\x61\u0026#39;) 7\tprintln(\u0026#39;a\u0026#39; == \u0026#39;\\u0061\u0026#39;) 8\tprintln(\u0026#39;a\u0026#39; == \u0026#39;\\U00000061\u0026#39;) 9\tprintln(0x61 == \u0026#39;\\x61\u0026#39;) 10\tprintln(\u0026#39;\\u4f17\u0026#39; == \u0026#39;众\u0026#39;) 11} تایپ رشته (string) # در زبان گو مقدار تایپ رشته بطور پیش فرض از نوع یونیکد UTF-8 می باشد.\n1// The interpreted form. 2\u0026#34;Hello\\nworld!\\n\\\u0026#34;你好世界\\\u0026#34;\u0026#34; 3 4// The raw form. 5`Hello 6world! 7\u0026#34;你好世界\u0026#34;` همچنین رشته از کارکترهای خاص یونیکد مانند 0x0D پشتیبانی می کند.\nخوانایی بهتر اعداد با _ # در زبان گو شما می توانید برای خوانایی بهتر اعداد چند رقمی از _ برای جداسازی استفاده کنید.\n1// Legal ones: 26_9 // == 69 30_33_77_22 // == 0337722 40x_Bad_Face // == 0xBadFace 50X_1F_FFP-16 // == 0X1FFFP-16 60b1011_0111 + 0xA_B.Fp2i 7 8// Illegal ones: 9_69 // _ can\u0026#39;t appear as the first character 1069_ // _ can\u0026#39;t appear as the last character 116__9 // one side of _ is a illegal character 120_xBadFace // \u0026#34;x\u0026#34; is not a legal octal digit 131_.5 // \u0026#34;.\u0026#34; is not a legal octal digit 141._5 // \u0026#34;.\u0026#34; is not a legal octal digit "},{"id":11,"href":"/chapter-1/go-operators/","title":"1.4 عملگرها","section":"فصل اول: آشنایی با مفاهیم گو","content":"زبان گو هم مثل سایر زبان ها دارای یکسری عملگرها مانند: عملگرهای حسابی, عملگرهای مقایسه ای, عملگرهای منطقی و عملگرهای بیتی می باشد.\nعملگرهای حسابی # زبان گو دارای ۵ تا عملگر حسابی می باشد که به ترتیب :\nعملگر نام + جمع - تفریق * ضرب / تقسیم % باقی مانده این ۵ تا عملگر اغلب به ترتیب مجموع, تفاوت, حاصلضرب و ضریب نیز نامیده می شوند.\n1 a := 1 2 b := 2 3 4 c := a + b // 3 5 d := a - b // -1 6 e := a * b // 2 7 f := a / b // 0 8 g := a % b // 1 در کد نمونه بالا ما := که متغیر کوتاه است استفاده کردیم که در بhttps://book.gofarsi.ir/chapter-1/go-variables-and-consts/خش 1.5 متغیرها و ثابت ها معرفی خواهیم کرد. عملگرهای مقایسه ای # زبان گو دارای ۶ عملگر مقایسه ای می باشد که به ترتیب :\nعملگر نام == مساوی بودن =! مساوی نبودن با \u0026gt; کمتر از =\u0026gt; کمتر یا مساوی \u0026lt; بزرگتر =\u0026lt; بزرگتر یا مساوی نتیجه این استفاده از این عملگرهای مقایسه فوق یک نوع untyped بولین است یعنی حاصل این مقایسه ها در واقع true یا false است.\n1 a := 1 2 b := 2 3 c := 1 4 5 println(a == b) // false 6 println(a == c) // true 7 println(a \u0026lt; b) // true 8 println(b \u0026gt; c) // true 9 println(c \u0026lt;= a) // true 10 println(c \u0026gt;= b) // false 11 println(b != a) // true 12 println(c != a) // false عملگرهای منطقی # زبان گو دارای ۳ نوع عملگر منطقی می باشد که به ترتیب :\nعملگر نام \u0026amp;\u0026amp; AND || OR ! NOT عملگر \u0026amp;\u0026amp; به انگلیسی AND به فارسی و , اگر هردو عملگر true باشد مقدار بازگشتی true و در غیر اینصورت false خواهد بود. عملگر || به انگلیسی OR به فارسی یا , اگر یکی از عملگرها true باشد مقدار بازگشتی true در غیر این صورت false خواهد بود. عملگر ! به انگلیسی NOT به فارسی ‍‍منفی یا نفی , زمانیکه شما از عملگر ! استفاده می کنید معکوس نتیجه عملوند را نیاز دارید. 1a := true 2b := true 3c := false 4 5fmt.Println(a \u0026amp;\u0026amp; b) //true 6fmt.Println(a || b) //true 7fmt.Println(!a) //false 8fmt.Println(!c) //true مثال زیر نتیجه مقادیر متفاوت و عملگر های منطقی را نشان میدهد.\n1 // x y x \u0026amp;\u0026amp; y x || y !x !y 2 true true true true false false 3 true false false true false true 4 false true false true true false 5 false false false false true true عملگرهای بیتی # زبان گو داری 5عملگر بیتی می باشد که به ترتیب :\nعملگر نام \u0026gt;\u0026gt; شیفت بیتی به چپ \u0026lt;\u0026lt; شیفت بیتی به راست \u0026amp; AND | OR ^ XOR ‍‍\nعملگر \u0026gt;\u0026gt; به انگلیسی Zero fill left shift یا به اختصار left shift به فارسی که اسم مناسبی براش نیافتیم به نقل از ویکی پدیا شیفت بیتی به چپ , مقدار باینری ما را با استفاده از انتقال یا اضافه کردن صفر ها به سمت چپ انتقال میدهد. عملگر \u0026lt;\u0026lt; به انگلیسی Zero fill right shift یا به اختصار right shift به فارسی که اسم مناسبی براش نیافتیم به نقل از ویکی پدیا شیفت بیتی به راست , مقدار باینری ما را با به سمت راست انتقال میدهد. در زیر دو مثال رو مشاهده میکنید که از این دو عملگر استفاده شده:\n1//example 1 2a := 0b01000101 3b := a \u0026lt;\u0026lt; 1 4c := a \u0026gt;\u0026gt; 1 5fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, a, a) //binary:01000101,value:69 6fmt.Println(\u0026#34;\u0026#34;) 7fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, b, b) //binary:10001010,value:138 8fmt.Println(\u0026#34;\u0026#34;) 9fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, c, c) //binary:00100010,value:34 10 11fmt.Println(\u0026#34;\\n\\n---------------\\n\u0026#34;) 12//example 2 13d := 0b01010101 14e := d \u0026lt;\u0026lt; 3 15f := d \u0026gt;\u0026gt; 3 16fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, d, d) //binary:01010101,value:85 17fmt.Println(\u0026#34;\u0026#34;) 18fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, e, e) //binary:1010101000,value:680 19fmt.Println(\u0026#34;\u0026#34;) 20fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, f, f) //binary:00001010,value:10 21fmt.Println(\u0026#34;\u0026#34;) 22 */ در مثال دو همانطور که مشاهده کردید زمانی که از عملگر \u0026gt;\u0026gt; استفاده کردید در صورتی که اولین خانه ی باینری از سمت چپ مقدار 1 داشته باشه مابقی مقدار به صورتی 0 به باینری مون اضافه میشه و در غیر این صورت 1 هامون به همون مقدار به سمت چپ خواهد رفت.\nدر واقع 08b% یک شناساگر قالب (format specifier) برای نمایش باینری در هشت خانه است در اینجا میتوانید بیشتر راجب شناساگر های قالب بخوانید. عملگر \u0026amp; به انگلیسی AND به فارسی و دو مقدار باینری رو با یک دیگر مقایسه و اگر هر بیت مقدار 1 در هر دو طرف داشته باشد آن را 1 نگه میدارد و در غیر اینصورت آن بیت را 0 میکند. عملگر | به انگلیسی OR به فارسی یا دو مقدار باینری رو با یک دیگر مقایسه و اگر هر بیت مقدار 1 در یک طرف یا هر دوطرف داشته باشد آن را 1 نگه میدارد و در غیر اینصورت آن بیت را 0 میکند. عملگر | به انگلیسی XOR به فارسی نامی ندارد دو مقدار باینری رو با یک دیگر مقایسه و اگر هر بیت مقدار 1 در هر دوطرف داشته باشد آن را 0 میکند.\n1//\u0026amp; operator example 2a := 0b01000101 3b := 0b01010100 4c := a \u0026amp; b 5fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, a, a) //binary:01000101,value:69 6fmt.Println(\u0026#34;\u0026#34;) 7fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, b, b) //binary:01010100,value:84 8fmt.Println(\u0026#34;\u0026#34;) 9fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, c, c) //binary:01000100,value:68 10 11fmt.Println(\u0026#34;\\n\\n---------------\\n\u0026#34;) 12 13//| operator example 14d := 0b01000101 15e := 0b01010100 16f := d | e 17fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, d, d) //binary:01000101,value:69 18fmt.Println(\u0026#34;\u0026#34;) 19fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, e, e) //binary:01010100,value:84 20fmt.Println(\u0026#34;\u0026#34;) 21fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, f, f) //binary:01010101,value:85 22 23fmt.Println(\u0026#34;\\n\\n---------------\\n\u0026#34;) 24 25//^ operator example 26g := 0b01000101 27h := 0b01010100 28i := a ^ b 29fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, g, g) //binary:01000101,value:69 30fmt.Println(\u0026#34;\u0026#34;) 31fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, h, h) //binary:01010100,value:84 32fmt.Println(\u0026#34;\u0026#34;) 33fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, i, i) //binary:00010001,value:17 اولویت عملگرها # در زبان گو ما یکسری اولویت ها برای عملگرها داریم و همچنین در زبان گو مثل سایر زبان ها پرانتز () ترویج دهنده اولویت ها می باشد.\n1 * / % \u0026lt;\u0026lt; \u0026gt;\u0026gt; \u0026amp; \u0026amp;^ 2 + - | ^ 3 == != \u0026lt; \u0026lt;= \u0026gt; \u0026gt;= 4 \u0026amp;\u0026amp; 5 || توجه در زبان گو اولویت \u0026lt;\u0026lt; و \u0026gt;\u0026gt; بیشتر از + و - می باشد. "},{"id":12,"href":"/chapter-1/go-variables-and-consts/","title":"1.5 متغیرها و constant","section":"فصل اول: آشنایی با مفاهیم گو","content":" متغیر (Variable) # در برنامه‌نویسی رایانه، یک متغیر یک مکان در حافظه (آدرس حافظه) است که دارای یک نام نمادین با عنوان می‌باشد و می‌تواند حاوی اطلاعات یا یک مقدار معلوم یا مجهول که به آن ارزش یا مقدار گفته می‌شود باشد. به زبان دیگر، متغیر در برنامه‌نویسی به فضایی که برای ذخیره داده‌ها کنار گذاشته شده‌است می‌گویند (به نقل از سایت ویکی پدیا)\nتعریف یک متغیر رشته # 1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7func main() { 8\tvar s string = \u0026#34;Hello World\u0026#34; 9\tfmt.Println(s) 10} 1$ go run main.go 2Hello World یک متغیر با استفاده از کلید واژه var ایجاد کردیم. نام متغیر را s گذاشتیم تایپ متغیر را از نوع string تعیین کردیم سپس با عملگر = مقدار متغیر را مشخص از نوع رشته تعیین کردیم. رشته \u0026quot;Hello World\u0026quot; به عنوان مقدار متغیر s می باشد و این مقدار در خانه مشخصی از حافظه قرار گرفته از پکیج استاندارد fmt برای چاپ مقدار متغیر s استفاده کردیم که این پکیج یکسری توابع جهت انجام عملیات های مختلفی نظیر چاپ مقادیر را دارند که در کد بالا ما از تابع Println استفاده کردیم. اختصاص مقدار جدید به متغیر از قبل ایجاد شده # در کد زیر ما یک متغیر از قبل تعریف کردیم و مقدار جدید را در خط ۹ به متغیر اختصاص دادیم.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7func main() { 8\tvar s string 9\ts = \u0026#34;Hello World\u0026#34; 10\tfmt.Println(s) 11} زمانیکه شما یک متغیر بصورت var s string تعریف می کنید مقدار پیش فرض \u0026quot;\u0026quot; برای متغیر تعیین می شود. اختصاص مقدار رشته به تایپ اشتباه # 1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7func main() { 8\tvar i int 9\ti = \u0026#34;One\u0026#34; 10\tfmt.Println(i) 11} 1$ go run main.go 2./main.go:cannot use \u0026#34;One\u0026#34; (type string) as type int in assignment در کد بالا ما یک متغیر از نوع int تعریف کردیم و در خط ۹ مقدار \u0026quot;One\u0026quot; را به آن تخصیص دادیم و پس از اجرا با خطای cannot use \u0026quot;One\u0026quot; (type string) as type int in assignment اینکه شما یک مقدار رشته را به تایپ اشتباه اختصاص دادید مواجه خواهید شد.\nتعریف متغیر کوتاه # زبان گو علاوه بر اینکه از کلید واژه var برای تعریف متغیر پشتیبانی می کند, از =: می توانید یک متغیر تعریف کنید و نیازی به مشخص کردن تایپ متغیر نمی باشد چون زبان گو بر اساس مقدار تعیین شده تایپ متغیر را تشخیص می دهد.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\ts := \u0026#34;Hello World\u0026#34; 7\tfmt.Println(s) 8} توجه کنید شما متغیر کوتاه را فقط داخل تابع می توانید تعریف کنید و جهت تعریف متغیر بصورت عمومی باید از var استفاده کنید.\nبهتر است برای تعریف متغیر داخل تابع از متغیر کوتاه استفاده کنید و متغیر با var بصورت عمومی در بدنه کد باشد.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7var s string = \u0026#34;Hello World\u0026#34; 8 9func main() { 10\tfmt.Println(s) 11} تعریف چند متغیر در یک خط # در زبان گو شما می توانید همزمان چند متغیر را در یک خط تعریف کنید که در زیر یک نمونه کد مثال زدیم :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\ta, b, c := \u0026#34;hello\u0026#34;, 1, 1.5 7\tvar d, e, f = \u0026#34;world\u0026#34;, 13, 24 8\tfmt.Println(a, b, c, d, e, f) 9} 1$ go run main.go 2hello 1 1.5 world 13 24 تعریف متغیر با مقدار پیش فرض # در کد زیر ما یکسری متغیر با تایپ های مختلف تعریف کردیم که با مقدار پیش فرض ایجاد شده اند.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7func main() { 8\tvar i int 9\tvar f float 10\tvar b bool 11\tvar s string 12\tfmt.Printf(\u0026#34;%v %v %v %q\\n\u0026#34;, i, f, b, s) 13} مقدار ثابت (Constant) # constant همانند متغیر ها با کلید واژه const تعریف می شوند و مقدار بصورت const a string = \u0026quot;hello world\u0026quot; می گیرند و با این تفاوت که constant در طول اجرای کد مقدارشان غیرقابل تغییر هست و این تضمین را به شما می کنند هیچ چیزی در طول اجرا باعث تاثیر در تغییر مقدار constant نشود.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7const s string = \u0026#34;Hello World\u0026#34; 8 9func main() { 10\tfmt.Println(s) 11} 1$ go run main.go 2Hello World همانطور که در فوق گفتیم شما نمی توانید Constant را مجدد مقدار دهی کنید و در زیر خطایی که رخ می دهد در زمان اجرا را قرار دادیم :\n1package main 2 3func main() { 4 const a int = 8 5 a = 9 6} 1$ go run main.go 2main.go:5:cannot assign to a تعریف Constant بدون نیاز به تعیین تایپ # در constant شما همانند متغییر می توانید یک const به تعیین تایپ تعریف کنید و زبان گو در زمان اجرا با توجه به مقدارتان تایپ را تشخیص می دهد.\n1const a = 1 //Default hidden type is int 2const b = \u0026#34;circle\u0026#34; //Default hidden type is string 3const c = 5.4 //Default hidden type is float64 4const d = true //Default hidden type is bool 5const e = \u0026#39;a\u0026#39; //Default hidden type is rune 6const f = 3+5i //Default hidden type is complex128 نحوه مشاهده تایپ متغیر یا Constant # در زیر ما با استفاده یکی از توابع پکیج fmt نوع و مقدار متغیر یا constant ها را چاپ کردیم.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5// Named untyped constant 6const a = 123 //Default hidden type is int 7const b = \u0026#34;circle\u0026#34; //Default hidden type is string 8const c = 5.6 //Default hidden type is float64 9const d = true //Default hidden type is bool 10const e = \u0026#39;a\u0026#39; //Default hidden type is rune 11const f = 3 + 5i //Default hidden type is complex8 12 13var u = 123 //Default hidden type is int 14var v = \u0026#34;circle\u0026#34; //Default hidden type is string 15var w = 5.6 //Default hidden type is float64 16var x = true //Default hidden type is bool 17var y = \u0026#39;a\u0026#39; //Default hidden type is rune 18var z = 3 + 5i //Default hidden type is complex128 19 20func main() { 21\tfmt.Println(\u0026#34;\u0026#34;) 22\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, a, a) 23\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, b, b) 24\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, c, c) 25\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, d, d) 26\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, e, e) 27\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, f, f) 28 29\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, u, u) 30\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, v, v) 31\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, w, w) 32\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, x, x) 33\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, y, y) 34\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, z, z) 35} استفاده از iota در constant # شناسه iota فقط با constant قابل استفاده اس که با آن می توانید برای ایجاد اعداد auto increment استفاده کنید.\nایجاد auto increment بدون iota :\n1const ( 2 a = 0 3 b = 1 4 c = 2 5) ایجاد auto increment با iota :\n1const ( 2 a = iota // 0 3 b // 1 4 c // 2 5) توجه کنید مقدار پیش فرض با iota صفر می باشد و constant از نوع int می باشد. نحوه ایجاد enum # از iota و constant برای ایجاد enum استفاده می شود که در زیر یک نمونه کد برای ایجاد enum قرار دادیم.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type Size uint8 6 7const ( 8\tsmall Size = iota 9\tmedium 10\tlarge 11\textraLarge 12) 13 14func main() { 15\tfmt.Println(small) 16\tfmt.Println(medium) 17\tfmt.Println(large) 18\tfmt.Println(extraLarge) 19} 1$ go run main.go 20 31 42 53 نادیده گرفتن مقدار اول iota # وقتی که داریم از iota استفاده می‌کنیم شاید هنگام استفاده از auto increament نیاز باشد مقدار اول را نادیده بگیریم. برای اینکار می‌توان از _ استفاده کرد به شکل زیر :\n1const ( 2 _ = iota // ignore 3 a // 1 4 b // 2 5 c // 3 6) قوانین نام گذاری متغیر و constant # در زیر ما یکسری قوانین جهت نام گذاری متغیر و constant تعریف کردیم :\nنام متغیر یا constant فقط با یک حرف انگلیسی یا _ شروع می شود. نام ها می تواند ترکیبی از اعداد و حروف انگلیسی یا _ باشد. زبان گو به حروف بزرگ و کوچک در نام ها حساس است و اگر شما hello یا Hello تعریف کنید ۲ تا متغیر یا constant متفاوت محسوب می شوند. محدودیتی در تعداد حروف نام ها وجود ندارد ولی بهتر است از یک تعداد مطلوب و مشخصی برای نام ها استفاده کنید. توجه داشته باشید اصولا اسم constant ها را با حروف بزرگ و خارج از function تعریف می‌کنند. - با مشخص کردن اسم با حروف بزرگ هنگام استفاده از constant ها مشخص تر خواهد بود. - از آنجایی که constant ها فقط امکان read یا همان خواند را می‌دهند ممکن است در قسمت های مختلف به آن مقادیر نیاز داشته باشیم. - بخاطر اینکه با هر بار فراخوانی function مانع از این شویم کامپایلر عملیات مقدار دهی const را دوباره انجام نهد بهتر است آن را خارج از تابع تعریف کنیم. "},{"id":13,"href":"/chapter-1/go-function/","title":"1.6 تابع (function)","section":"فصل اول: آشنایی با مفاهیم گو","content":" تابع چیست؟ # در برنامه‌نویسی، تابع به تکه کدهایی سازمان یافته گفته می شود که برای انجام عملی خاص استفاده می شوند. به کمک توابع می توانیم تکه کدهارو از یکدیگر جدا کنیم و از تکرار کدهای تکراری جلوگیری کنیم و به برنامه مون نظم بیشتری بدیم.\nهمانند شکل زیر تابع مانند یک جعبه (یا قطعه کد) می باشد. که یک مقدار ورودی گرفته و روی آن پردازش هایی انجام می دهد و یک خروجی تولید می کند. در برنامه نویسی تابع می تواند یک یا چند ورودی و خروجی داشته باشد. و ممکن است یک تابع هیچ ورودی نداشته باشد و خروجی داشته باشد یا بلعکس.\nچرا از توابع در برنامه نویسی استفاده می کنیم؟ # با استفاده از توابع، می توانیم یک قطعه کد را یک بار بنویسیم و چندین بار از آن در برنامه استفاده کنیم. با استفاده از توابع، حجم کدنویسی ما کم تر میشه و سرعت توسعه نرم افزار بیشتر می شود. توابع به ما کمک می کنند تا کد خود را به تکه هایی تقسیم کنیم تا برنامه ما خوانا و قابل درک باشد. همچنین نگهداری و اشکال زدایی کد را آسان تر می کند. توابع در زبان گولنگ # توابع یکی از قابلیت های مهم هر زبانی محسوب می شود. توابع در زبان برنامه نویسی گولنگ داری سینتکس ساده ای هستند.\nتعریف یک تابع # 1func function_name( [parameter list] ) [return_types] { 2 3 // body of the function 4 5} Func - با این کلید واژه یک تابع تعریف می کنیم Function Name - نام تابع باید یکتا و در طول برنامه منحصر به فرد باشد. همچنین معمولاً نمی‌توان تابعی با نام توابع از پیش تعریف شده داشت Parameters - پارامترهای ورودی در این قسمت تعریف می‌شوند. پارامترها اختیاری هستند یعنی ممکن است یک تابع هیچ پارامتری نداشته باشد. Return Type - نوع داده های بازگشتی را در این قسمت مشخص می کنیم و در برخی توابع عملیات موردنظر را بدون بازگرداندن مقداری انجام می دهند در این توابع نیازی به تعیین return_type نمی باشد. Function Body - این قسمت شامل کدهایی است که نشان می دهد تابع چه کارهایی انجام می دهد مثال # 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func plus(a int, b int) int { 6\treturn a + b 7} 8 9func main() { 10\tfmt.Println(plus(4, 13)) 11} 1$ go run func.go 217 در اینجا یک تابع یا نام plus تعریف کردیم که دو پارامتر a, b را با نوع داده int را دریافت می کند و جمع دو عدد را حساب می کند. توجه کنید که همیشه باید نوع داده را مشخص کنیم. بعد از تعریف پارامترهای ورودی و قبل از قرار دادن کد داخل براکت int را می بینید که نوع خروجی داده را مشخص می کند و باید از نوع int باشد. برای صدا زدن توابع از کلیدواژه name(args) استفاده می کنیم. در صورتی که نوع پارامترهای ورودی از یک نوع باشند بجای تعریف تک تک نوع داده ها می توانیم نوع داده را در آخر همه پارامترهای هم نوع مشخص کنیم.\n1func plus(a, b int) 2// or 3func name(a string, b,c int) الگو دیگر تعریف تابع: # 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tplus := func (a int, b int) int { 7\treturn a + b 8\t} 9\tfmt.Println(plus(3, 4)) 10} 1$ go run main.go 27 قوانین نام گذاری تابع در گولنگ # نام تابع باید با یک حرف شروع شود. نام تابع فقط می تواند شامل حروف-عدد و underscores باشد. (A-z, 0-9, _ ) نام توابع به حروف کوچک و بزرگ حساس می باشد. در نام گذاری توابع از فاصله نمی توانیم استفاده کنیم. ‬ چند بازگشتی مقادیر در گولنگ (Multiple results) # همچنین در گولنگ توابع می توانند چندین مقادیر را برگردانند.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func vals() (int, int) { 6 return 3, 7 7} 8 9func main() { 10 11 a, b := vals() 12 fmt.Println(a) 13 fmt.Println(b) 14 15 _, c := vals() 16 fmt.Println(c) 17} 1$ go run main.go 23 37 47 در کد بالا تابعی ساختیم با اسم vals که دو خروجی از نوع int دارد بنابراین نوع تعریف توابع چندبازگشتی متفاوت است و بصورت (data-type, data-type, \u0026hellip; ) می باشد. در مثال اول ما با کمک دو متغیر a,b دو خروجی تابع vals را دریافت کردیم. در مثال دوم ما با استفاده از _ blank identifier از دریافت یا استخراج خروجی اول صرف نظر کردیم و فقط خروجی دوم با متغیر c را دریافت کردیم. در توابع چند بازگشتی خروجی آنها را باید با , از هم جدا کرد مقادیر بازگشتی نام گذاری شده (Named Return Values) # در گولنگ می توانیم مقدار بازگشتی یک تابع را نامگذاری کنیم. به مثال زیر توجه کنید.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func split(sum int) (x, y int) { 6\tx = sum * 4 / 9 7\ty = sum - x 8\treturn 9} 10 11func main() { 12\tfmt.Println(split(17)) 13} 1$ go run main.go 27 10 ما در این تابع مقدار بازگشتی را x, y از نوع int نام گذاری می کنیم. در اینجا یک دستور return بدون تعیین آرگومان بازگشتی، مقادیر نام گذاری شده را باز می گرداند. که به عنوان Naked return شناخته می شود. از naked return باید در توابع کوتاه مانند مثال بالا استفاده شود. استفاده آن در تابع طولانی منجر به کاهش خوانایی کد می شود. توابع متنوع در گولنگ (Variadic Functions) # یکی از قابلیت های گو وجود توابع متنوع هاست که به شما اجازه می دهد هر چقدر پارامتر نیاز دارید بدون تعریف وارد تابع کنید همانند parameter-Rest ها در JavaScript. ‍‍\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func sum(nums ...int) { 6 fmt.Print(nums, \u0026#34; \u0026#34;) 7 total := 0 8 9 for _, num := range nums { 10 total += num 11 } 12 fmt.Println(total) 13} 14 15func main() { 16 17 sum(1, 2) 18 sum(1, 2, 3) 19 20 nums := []int{1, 2, 3, 4} 21 sum(nums...) 22} 1$ go run variadic-functions.go 2[1 2] 3 3[1 2 3] 6 4[1 2 3 4] 10 در اینجا تابعی تعریف کردیم که تعداد دلخواهی از آرگومان ها از نوع int را به کمک \u0026hellip; که قبل از نوع داده قرار گرفته به داخل تابع منتقل می کند. برای صدا زدن این توابع میتوان به روش sum(num1, num2, \u0026hellip;) عمل کرد. اگر شما داده ای با نوع slice دارید می توانید آن را به کمک اپراتور \u0026hellip; به صورت sum(nums\u0026hellip;) به داخل تابع انتقال بدید. توابع نانشناس در گولنگ (Anonymous Functions) # در زبان گولنگ می توانیم تابع بدون نام تعریف کنیم. که به عنوان توابع ناشناس شناخته می شوند.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 7 // anonymous function 8 var sum = func(n1, n2 int) int { 9 sum := n1 + n2 10 11 return sum 12 } 13 14 // function call 15 result := sum(5, 3) 16 17 fmt.Println(\u0026#34;Sum is:\u0026#34;, result) 18 19} 1$ go run main.go 2Sum is: 8 از آنجایی که توابع ناشناس نامی ندارد ما معمولا آن ها را به یک متغیر اختصاص می دهیم سپس از نام متغیر برای فراخوانی تابع استفاده می کنیم. در این مثال می بینید که ما از sum برای فراخوانی تابع استفاده می کنیم. مانند توابع معمولی ما میتونیم برای تابع ناشناس پارامتر تعریف کنیم و همچنین مقداری را از تابع برگردانیم در این مثال تابع دو مقدار با نوع داده int دریافت میکنید و یک خروجی با نوع int دارد. تابع ناشناس را می توان برای عملکردهایی که نیازی به نامگذاری ندارند و معمولا برای استفاده کوتاه مدت هست، استفاده کرد. توابع از پیش تعریف شده (Built-in Function) # در گولنگ علاوه بر تابع هایی که توسط کابر تعریف میشه. یکسری توابع وجود دارد که از قبل تعریف شده اند که طراحان این زبان برای سهولت کار برنامه نویسان این توابع را نوشته اند و آن را همراه زبان گولنگ ارائه می دهند. https://pkg.go.dev/builtin\n"},{"id":14,"href":"/chapter-1/go-array/","title":"1.7 آرایه و slice","section":"فصل اول: آشنایی با مفاهیم گو","content":"آرایه و slice دو نوع تایپ با یک وجه اشتراک در زبان گو می باشند ولی این دو نوع تایپ یکسری تفاوت هایی با هم دارند که در ادامه به این دو تایپ می پردازیم.\nتعریف آرایه # آرایه یکی از عمومی ترین تایپ ها در زبان های برنامه نویسی می باشد که برای نگه داری گروهی مقادیر از یک نوع تایپ استفاده می شود. برای دسترسی به هرکدام از مقادیر درون آرایه باید از اندیس استفاده کرد. معمولا برای آرایه شما تعداد مشخص و ثابتی را برای تعداد خانه های آرایه مشخص کنید که این آرایه قرار است چندتا مقدار نگه داری کند.\nدر زیر یک نمونه کد در خصوص آرایه قرار دادیم :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tarrayInts := [5]int{1, 25, 12354, 654, 32} 7\tfmt.Println(arrayInts) 8} 1$ go run array.go 2[1 25 12354 654 32] یک متغیر کوتاه از نوع آرایه با نام arrayInts تعریف کردیم. ظرفیت آرایه را با عدد ۵ تعیین کردیم (یعنی این آرایه فقط ۵ تا مقدار بیشتر نگه داری نمی کند) سپس تایپ آرایه را از نوع int مشخص کردیم. در نهایت در همانجا آرایه را مقدار دهی کردیم. مفهوم اندازه و ظرفیت (size, capacity) # در آرایه ما ۲ تا مفهوم داریم اندازه و ظرفیت که از عنوان این مفهوم مشخص است آرایه دارای یک اندازه و ظرفیت مشخصی می باشد و اگر شما بیشتر از ظرفیت و اندازه تعیین شده مقدار دهی کنید با خطا مواجه خواهید شد.\nدر آرایه ظرفیت به نسبت اندازه تعیین می شود. 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tarrayString := [3]string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;} 7\tfmt.Println(arrayString) 8} 1$ go run array.go 2./prog.go:6:42: index 3 is out of bounds (\u0026gt;= 3) در کد فوق ما یک آرایه با اندازه ۳ تعریف کردیم و ۴ تا مقدار قرار دادیم و پس اجرا با خطای تعداد مقادیر بیشتر از اندازه و ظرفیت می باشد مواجه شدیم.\nتابع len و cap # برای آرایه و slice ما ۲ تا تابع داریم که می توانیم اندازه و ظرفیت یک آرایه یا slice را بگیریم.\nتابع len یکی از توابعی می باشد خیلی کاربردی و پراستفاده هنگام کار با آرایه یا slice می باشد که می توانید اندازه آرایه یا slice را بگیرید. تابع cap ظرفیت آرایه و slice را نمایش می دهد. 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tarrayString := [3]string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;} 7\tfmt.Printf(\u0026#34;array %v, len %d, cap %d\u0026#34;, arrayString, len(arrayString), cap(arrayString)) 8} 1$ go run main.go 2array [a b c], len 3, cap 3 تعریف آرایه و مقدارهی # در زیر ما یک آرایه با مقدار پیش فرض و اندازه مشخص تعریف کردیم و قصد داریم در ادامه کد مقداردهی کنیم.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tnums := [5]int{} 7\tfmt.Printf(\u0026#34;array nums values %v, len %d, cap %d\u0026#34;, nums, len(nums), cap(nums)) 8 9\tnums[0] = 1 10\tnums[1] = 2 11\tnums[2] = 10 12\tnums[4] = 999 13\t14\tfmt.Println(\u0026#34;\u0026#34;) 15\tfmt.Printf(\u0026#34;array nums values %v, len %d, cap %d\u0026#34;, nums, len(nums), cap(nums)) 16} 1$ go run main.go 2array nums values [0 0 0 0 0], len 5, cap 5 3array nums values [1 2 10 0 999], len 5, cap 5 در کد فوق در ابتدا ما یک آرایه بدون مقدار تعریف کردیم. سپس با استفاده از اندیس مقدار را خانه مشخص قرار دادیم. تعریف آرایه با اندازه تعیین شده توسط کامپایلر # شما در زبان گو می توانید با استفاده از ... یک آرایه با اندازه مشخص شده توسط کامپایلر تعریف کنید.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tnums := [...]int{1, 25, 45, 8797, 78, 879, 541, 11} 7\tfmt.Printf(\u0026#34;array nums values %v, len %d, cap %d\u0026#34;, nums, len(nums), cap(nums)) 8} 1$ go run main.go 2array nums values [1 25 45 8797 78 879 541 11], len 8, cap 8 توجه کنید زمانیکه ... برای تعریف آرایه استفاده می کنید فقط در همان لحظه تعریف می توانید مقدار دهی کنید. تعریف آرایه دوبعدی یا چندبعدی # در زبان گو همانند سایر زبان ها می توانید آرایه دوبعدی یا چند بعدی تعریف کنید که این برای پیاده سازی ماتریس یا یکسری سناریوهای توسعه کاربردی می باشد.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tnums := [2][2][2]int{{{1, 2}, {2, 3}}, {{4, 5}, {6, 7}}} 7\tfmt.Printf(\u0026#34;array nums values %v, len %d, cap %d\u0026#34;, nums, len(nums), cap(nums)) 8} 1$ go run main.go 2array nums values [[[1 2] [2 3]] [[4 5] [6 7]]], len 2, cap 2 مقایسه آرایه ها # در کد زیر ما یک نمونه مقایسه آرایه ها قرار دادیم که این مقایسه براساس تایپ, اندازه و مقادیر در نظر گرفته می شود.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tnums := [2]int{1, 2} 7\tnums2 := [2]int{1, 3} 8\tnums3 := [2]int{1, 2} 9\tnums4 := [3]int{1, 2, 3} 10\tchars := [2]string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;} 11 12\tfmt.Println(nums == nums2) // false 13\tfmt.Println(nums == nums3) // true 14\tfmt.Println(nums == nums4) // error: invalid operation: nums == nums4 (mismatched types [2]int and [3]int) 15\tfmt.Println(nums == chars) // error: invalid operation: nums == chars (mismatched types [2]int and [2]string) 16} برش (slice) # همانطور که می دانید آرایه یک از مهم ترین عناوین در زبان های برنامه نویسی می باشد. اما در زبان گو slice به نسبت آرایه خیلی پراستفاده کاربردی است. اگر بخواهیم خیلی ساده slice را توصیف کنیم در واقع \u0026ldquo;یک slice به عنوان یک بخش بهم پیوسته از یک آرایه تعریف می شود که شما می توانید المنت هایش را در حال اجرا افزایش یا کاهش دهید بدون آنکه ظرفیت و اندازه آن را مشخص کنید.\u0026rdquo;\nاما این سوال پیش می آید علت اینکه slice به نسبت آرایه کاربردی هست چیست؟ آرایه دارای برخی از محدودیت ها علی الخصوص اندازه ثابت می باشد اما در slice شما این محدودیت ها را نخواهید داشت و خیلی ساده می توانید المنت ها را افزایش, حذف و حتی کپی کنید.\nدر زبان گو slice ها یک پارچگی آرایه را حفظ می کند و کار با آرایه خیلی ساده و آسان تر خواهد شد. تعریف یک slice با اندازه مشخص # شما می توانید با استفاده از تابع make یک slice با اندازه مشخص تعریف کنید.\n1slice := make([]int, 5) 2 3fmt.Println(len(slice)) // Print 5 4 5fmt.Println(cap(slice)) // Print 5 تعریف یک slice با اندازه و ظرفیت مشخص # شما می توانید با استفاده از تابع make یک slice با ظرفیت و اندازه مشخصی تعریف کنید.\n1slice := make([]int, 3, 5) 2 3fmt.Println(len(slice)) // Print 3 4 5fmt.Println(cap(slice)) // Print 5 توجه کنید مقدار ظرفیت نباید کمتر از مقدار اندازه باشد.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\ttest := make([]int, 5, 4) 7\tfmt.Println(test) 8} 1$ go run main.go 2./main.go:6:22: invalid argument: length and capacity swapped تعریف یک slice با متغیر کوتاه # شما خیلی ساده می توانید یک slice را توسط متغیر کوتاه ایجاد کنید.\n1slice := []string{\u0026#34;Red\u0026#34;, \u0026#34;Blue\u0026#34;, \u0026#34;Green\u0026#34;, \u0026#34;Yellow\u0026#34;, \u0026#34;Pink\u0026#34;} 2 3fmt.Println(len(slice)) //Print 5 4 5fmt.Println(cap(slice)) //Print 5 6 7intSlice:= []int{10, 20, 30} 8 9fmt.Println(len(intSlice)) //Print 3 10 11fmt.Println(cap(intSlice)) //Print 3 تعریف یک slice با موقعیت های شاخص # شما می توانید یک slice را با موقعیت های شاخص ایجاد کنید که n تا المنت با مقدار پیش فرض ایجاد می کند و در آخر x را به آخر slice اضافه می کند.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\ttest := []int{99: 88} 7\tfmt.Println(len(test), cap(test)) 8} تعریف یک slice خالی # شما می توانید خیلی ساده یک slice خالی ایجاد کنید.\n1sliceOne := make([]int, 0) 2 3sliceTwo := []int{} 4 5fmt.Println(sliceOne == nil) // print false 6 7fmt.Println(len(sliceOne)) // print 0 8 9fmt.Println(cap(sliceOne)) // print 0 10 11fmt.Println(sliceTwo == nil) // print false 12 13fmt.Println(len(sliceTwo)) // print 0 14 15fmt.Println(cap(sliceTwo)) // print 0 مقدار دهی مجدد یکی از المنت های slice یا آرایه # شما خیلی راحت می توانید مقدار یکی از المنت های slice یا آرایه را مقدار دهی کنید.\n1slice := []int{10, 20, 30, 40} 2 3fmt.Println(slice) //print [10 20 30 40] 4 5slice[1] = 25 6 7fmt.Println(slice) // print [10 25 30 40] ایجاد یک slice جدید براساس یک slice از پیش تعریف شده # شما می توانید یک slice جدید را براساس یک slice از پیش تعریف شده تعریف کنید.\n1x := []int{10, 20, 30, 40, 50} 2 3fmt.Println(x) // Print [10 20 30 40 50] 4 5fmt.Println(len(x)) // Print 5 6 7fmt.Println(cap(x)) // Print 5 8 9y := x[1:3] 10 11fmt.Println(y) //Print [10 20 30 40 50] 12 13fmt.Println(len(y)) //Print 2 14 15fmt.Println(cap(y)) //Print 4 ما یک x با ۵ تا المنت مقدار دهی شده تعریف کردیم. سپس یک متغیر کوتاه با نام y تعریف کردیم که متغیر x را با داخلش قرار دادیم. سپس برای x گفتم المنت های از اندیس ۱ تا ۳ را به y دسترسی دهد. توجه کنید اتفاقی در بالا رخ داد ما تعیین اندیس اندازه و ظرفیت جدید برای y تعیین کردیم.\nLen: 3 - 1 = 2 Cap: 5 - 1 = 4\nخطای index out of range در slice # یک slice فقط با توجه به اندازه و اندیس هاش امکان دسترسی و مقدار دهی مجدد المنت هایش می باشد اما اگر شما خارج از اندازه تعیین شده تلاش کنید جهت مقدار دهی با خطای index out of range مواجه خواهید شد.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tslice := []int{10, 20, 30, 40, 50} 7\tnewSlice := slice[1:3] 8\tnewSlice[3] = 45 9\tfmt.Println(newSlice) 10} 1$ go run main.go 2panic: runtime error: index out of range [3] with length 2 3 4goroutine 1 [running]: 5main.main() 6\t/tmp/sandbox548843089/prog.go:8 +0x5b گسترش (append) المنت های یک slice # شما خیلی ساده می توانید با استفاده از append المنت های یک slice را گسترش دهید.\n1slice := []int{10, 20, 30, 40, 50} 2 3newSlice := slice[1:3] 4 5fmt.Println(len(newSlice)) // Print 2 6 7fmt.Println(cap(newSlice)) // Print 4 8 9newSlice = append(newSlice, 60) 10 11fmt.Println(len(newSlice)) // Print 3 12 13fmt.Println(cap(newSlice)) // Print 4 در کد زیر اتفاقی که صورت گرفته شما اگر ... را بعد از کلمه slice بزارید یعنی دارید میگید تمامی المنت های داخل slice به newSlice اضافه شود.\n1slice := []int{10, 20, 30, 40, 50} 2 3newSlice := append(newSlice, slice...) نحوه حذف یک المنت در slice # برای حذف یک المنت در slice باید بصورت تکنیکی اینکار را انجام دهید چون زبان گو یک روش built-in برای اینکار ندارد.\nدر این روش شما باید در ابتدا آخرین المنت را به المنت مورد نظر با استفاده از اندیس کپی کنید. سپس آخرین المنت را از slice حذف کنید. 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tslice := []int{10, 20, 30, 40, 50} 7\tslice[1] = slice[len(slice)-1] 8\tslice = slice[:len(slice)-1] 9\tfmt.Println(slice) 10} تابع copy در slice # شما با استفاده از تابع copy می توانید یک slice را به slice دیگری کپی کنید.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tsrc := []int{1, 2, 3, 4, 5} 7\tdst := make([]int, 5) 8\tnumberOfElementsCopied := copy(dst, src) 9\tfmt.Println(numberOfElementsCopied, dst) 10} 1$ go run main.go 25 [1 2 3 4 5] نحوه مرتب کردن (sort) یک slice # برای مرتب کردن یک slice می توانید از توابع کتابخانه sort در زبان گو استفاده کنید.\nsort.Ints sort.Float64s sort.Strings 1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;sort\u0026#34; 6) 7 8func main() { 9\ts := []int{4, 2, 3, 1} 10\tsort.Ints(s) 11\tfmt.Println(s) 12} 1$ go run main.go 2[1 2 3 4] فرق بین آرایه و slice # فرق نوع تعریف آرایه و slice برای تعریف آرایه شما باید داخل براکت [] یک مقداری را قرار دهید. برای تعریف slice هیچ مقداری داخل براکت [] هیچ مقداری نباید قرار دهید. 1array := [3]int{10, 20, 30} 2 3slice := []int{10, 20, 30} فرق بین خالی بودن آرایه و slice مقدار خالی بودن یک slice هست nil مقدار خالی یک آرایه, همان آرایه با المنت های مقدار پیش فرض می باشد. 1var slice []int32 2var array [2]int32 3 4fmt.Println(slice == nil) // print true 5fmt.Println(len(slice)) // print 0 6fmt.Println(cap(slice)) // print 0 7 8fmt.Println(array) // print [0 0] "},{"id":15,"href":"/chapter-1/go-map/","title":"1.8 نقشه map","section":"فصل اول: آشنایی با مفاهیم گو","content":" مقدمه: # نقشه ، یک نوع ساختار داده است. نقشه (ها) جهت جمع‌آوری و نگهداری مجموعه‌ای از داده‌ها استفاده می‌گردند. نقشه ، از نوع داده‌های انجمنی (هش) بصورت «کلید-مقدار» است. نقشه ، مجموعه‌ای از داده‌ها بصورت جفت‌‌های مرتب‌نشده است. تعریف: # یک مپ شبیه به فرمت زیر است:\nmap[KeyType]ValueType کلمه کلیدی map و بعد نوع کلید و در آخر هم نوع مقدار تعریف می‌شود.\nکلید: برای اشاره به یک مقدار ذخیره شده، به یک نام‌گذاری برای آن مقدار نیاز داریم و این یعنی «کلید» آن مقدار.\nمقدار کلید در یک مپ، باید یکتا باشد. محدودیت: برای تعریف کلید، از انواع تایپ‌هایی که قابل مقایسه هستند، می‌توان استفاده کرد: Boolean(s) Number(s) String(s) Array(s) Pointer(s) Struct(s) Interface(s) (تا زمانی که از مقادیر مقایسه‌پذیر استفاده می‌کند) از Slice(s) Map(s) Function(s) نمی‌توان برای تعریف «کلید» مپ استفاده کرد. در مپ می‌توان برای کلید از مقدار داخل یک متغیر بهره برد. 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tmyMap := make(map[int]string) 7\tmyKey := 13 8\tmyMap[myKey] = \u0026#34;thirteen\u0026#34; 9\tfmt.Println(myMap) //map[13:thirteen] 10\tfmt.Println(myMap[myKey]) //thirteen 11} مقدار: محتوی داده‌ای است که کلید به آن اشاره می‌کند و برخلاف کلید، هیچ محدودیت برای انتخاب «نوع» آن وجود ندارد، به‌عنوان نمونه می‌توان از یک مپ دیگر برای مقدار استفاده کرد. (مپ‌های تودرتو )\nmap[string]map[int]string ایجاد و مقداردهی اولیه: # مقدار پیش‌فرض برای یک مپ nil می‌باشد. برای مقداردهی مپ‌(ها) از روش‌های زیر استفاده می‌شود:\nاستفاده از کلمه کلیدی var 1var sampleMap = map[keyType]valueType{keyName1:value1, keyName2:value2, ...} 2var sampleMap map[keyType]valueType = map[keyType]valueType{} استفاده از علامت =: 1sampleMap := map[keyType]valueType{keyName1:value1, keyName2:value2, ...} استفاده از تابع make 1var sampleMap = make(map[keyType]valueType) 2sampleMap := make(map[keyType]valueType) تکمیل و اصلاح می‌گردد\nمپ با مقدار nil: # درصورت تعریف اولیه مپ توسط دستور var sampleMap map[keyType]valueType یک ماهیت مپ با مقدار nil تولید می‌شود که نمی‌توان بدون مقداردهی اولیه، روی آن عملیات ارسال و دریافت داده‌ انجام داد:\n1 var sampleMap map[uint8]int 2 sampleMap[13] = 9999999 3 //panic: assignment to entry in nil map برای مقداردهی یک مپ nil:\n1var m map[string]string از روش‌های زیر می‌توان بهره گرفت:\n1var m map[string]string = map[string]string{} 2m := make(map[string]string) 3m := map[string]string{} توابع مربوط به مپ: # تابع (len): برای برگشت تعداد عناصر داخل مپ از len استفاده می‌شود: 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tvar sampleMap = map[string]bool{} 7\tvar otherMap = make(map[string]uint) 8\tvar nilMap map[bool]bool 9 10\tsampleMap[\u0026#34;condition#1\u0026#34;] = true 11\tsampleMap[\u0026#34;condition#2\u0026#34;] = false 12 13\totherMap[\u0026#34;foo\u0026#34;] = 1 14 15\tfmt.Println(len(sampleMap))\t//2 16\tfmt.Println(len(otherMap))\t//1 17\tfmt.Println(len(nilMap))\t//0 (len nil is zero) 18} مقدار برگشتی برای تابع len روی مپ‌ nil برابر صفر (۰) است.\nعملیات CRUD روی مپ: # C : Create برای ایجاد مپ، در قسمت [[#ایجاد و مقداردهی اولیه:]] توضیح داده شده است.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 animals := make(map[int]string) // nil map of string-int pairs 7 animals[1] = \u0026#34;Gopher\u0026#34; 8 animals[2] = \u0026#34;owl\u0026#34; 9 animals[3] = \u0026#34;cheetah\u0026#34; 10 animals[4] = \u0026#34;eagle\u0026#34; 11 animals[5] = \u0026#34;lion\u0026#34; 12 13 fmt.Println(animals) //map[1:Gopher 2:owl 3:cheetah 4:eagle 5:lion] 14 15} R : Read جهت خواندن مقادیر مپ می‌توان از الگوی زیر استفاده کرد: mapName[\u0026quot;keyName\u0026quot;] مثال:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 animals := make(map[int]string) // nil map of string-int pairs 7 animals[1] = \u0026#34;Gopher\u0026#34; 8 animals[2] = \u0026#34;owl\u0026#34; 9 animals[3] = \u0026#34;cheetah\u0026#34; 10 animals[4] = \u0026#34;eagle\u0026#34; 11 animals[5] = \u0026#34;lion\u0026#34; 12 13 fmt.Println(animals[2]) //owl 14} U : Update برای بروزرسانی مقادیر مپ، از الگوی mapName[keyName] = newValue استفاده می‌شود. مثال:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 animals := make(map[int]string) // nil map of string-int pairs 7 animals[1] = \u0026#34;Gopher\u0026#34; 8 animals[2] = \u0026#34;owl\u0026#34; 9 animals[3] = \u0026#34;cheetah\u0026#34; 10 animals[4] = \u0026#34;eagle\u0026#34; 11 animals[5] = \u0026#34;lion\u0026#34; 12 13 fmt.Println(animals[2]) //owl 14 15 animals[2] = \u0026#34;wolf\u0026#34; 16 17 fmt.Println(animals[2]) //wolf 18} D : Delete جهت حذف مقادیر در مپ، از فانکشن delete متعلق به پکیج builtin استفاده می‌شود.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 animals := make(map[int]string) // nil map of string-int pairs 7 animals[1] = \u0026#34;Gopher\u0026#34; 8 animals[2] = \u0026#34;owl\u0026#34; 9 animals[3] = \u0026#34;cheetah\u0026#34; 10 animals[4] = \u0026#34;eagle\u0026#34; 11 animals[5] = \u0026#34;lion\u0026#34; 12 13 fmt.Println(animals) //map[1:Gopher 2:owl 3:cheetah 4:eagle 5:lion] 14 fmt.Println(len(animals)) //5 15 delete(animals, 4) 16 17 fmt.Println(animals) //map[1:Gopher 2:owl 3:cheetah 5:lion] 18 fmt.Println(len(animals)) //4 19} نکته: اگر کلید مورد استفاده در فانکشن delete() پیدا نشود، هیچ اتفاقی نخواهد افتاد. علت عدم بازگشت ارور در فانکشن delete() است\n1// The delete built-in function deletes the element with the specified key 2// (m[key]) from the map. If m is nil or there is no such element, delete 3// is a no-op. 4func delete(m map[Type]Type1, key Type) تکمیل و اصلاح می‌گردد\nبررسی وجود کلید: # یکی از خدماتی که مپ ارائه می‌دهد،‌ پاسخ به سوال وجود یک کلید خاص در مپ می‌باشد که به‌عنوان راهکاری برای حل مسائل از آن استفاده می‌شود. مثال زیر را ببینید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 7\tvar personData = map[string]string{\u0026#34;name\u0026#34;: \u0026#34;frank\u0026#34;, \u0026#34;family\u0026#34;: \u0026#34;colleti\u0026#34;, \u0026#34;dob\u0026#34;: \u0026#34;1970-05-12\u0026#34;} 8 9\tname, nameExist := personData[\u0026#34;name\u0026#34;] 10\tfamily, familyExist := personData[\u0026#34;family\u0026#34;] 11\tdob, dobExist := personData[\u0026#34;dob\u0026#34;] 12\torganization, organizationExist := personData[\u0026#34;organization\u0026#34;] 13 14\tfmt.Println(name, nameExist)\t15\t//frank true 16\tfmt.Println(family, familyExist) 17\t//colleti true 18\tfmt.Println(dob, dobExist) 19\t//1970-05-12 true 20\tfmt.Println(organization, organizationExist) 21\t// false 22} مپ، یک جدول، یک منبع: # وقتی یک مپ تعریف می‌شود، اگر مپ(های) دیگری از روی آن ساخته شو(نـ)د، دارای یک منبع برای ذخیره و دریافت اطلاعات خواهند بود. در مثال زیر، مپ editorMap از مپ companyProfile ایجاد و وقتی ویرایش می‌شود، مپ اصلی نیز،‌ ویرایش شده است.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 7\tvar companyProfile = map[string]string{ 8\t\u0026#34;name\u0026#34;: \u0026#34;companyName\u0026#34;, 9\t\u0026#34;address\u0026#34;: \u0026#34;sampleAddress\u0026#34;, 10\t} 11\tvar editorMap = companyProfile // == editorMap := companyProfile 12 13\tfmt.Println(companyProfile[\u0026#34;name\u0026#34;], \u0026#34;\\t\u0026#34;, companyProfile[\u0026#34;address\u0026#34;]) 14\t//companyName sampleAddress 15\tfmt.Println(editorMap[\u0026#34;name\u0026#34;], \u0026#34;\\t\u0026#34;, editorMap[\u0026#34;address\u0026#34;]) 16\t//companyName sampleAddress 17 18\teditorMap[\u0026#34;name\u0026#34;] = \u0026#34;new name\u0026#34; 19\teditorMap[\u0026#34;address\u0026#34;] = \u0026#34;new address\u0026#34; 20 21\t//reference map also edited when editor map edit 22\tfmt.Println(companyProfile[\u0026#34;name\u0026#34;], \u0026#34;\\t\u0026#34;, companyProfile[\u0026#34;address\u0026#34;]) 23\t//new name new address 24\tfmt.Println(editorMap[\u0026#34;name\u0026#34;], \u0026#34;\\t\u0026#34;, editorMap[\u0026#34;address\u0026#34;]) 25\t//new name new address 26} پیمایش روی مپ: # یکی از اصلی‌ترین اهداف ایجاد و نگهداری انواع تایپ‌های مربوط به مجموعه داده‌ها، امکان دسترسی به اجزای داده و انواع لوپ از ابزارهای آن است. با استفاده از for-range می‌توان به اجزای یک داده‌ از نوع کلید-مقدار دسترسی داشت\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7func main() { 8\tanimals := make(map[int][]string) // nil map of string-int pairs 9\tanimals[0] = []string{\u0026#34;Gopher\u0026#34;, \u0026#34;running\u0026#34;, \u0026#34;rodent\u0026#34;} 10\tanimals[1] = []string{\u0026#34;owl\u0026#34;, \u0026#34;flying\u0026#34;, \u0026#34;carnivorous\u0026#34;} 11\tanimals[2] = []string{\u0026#34;cheetah\u0026#34;, \u0026#34;running\u0026#34;, \u0026#34;carnivorous\u0026#34;} 12\tanimals[3] = []string{\u0026#34;eagle\u0026#34;, \u0026#34;flying\u0026#34;, \u0026#34;carnivorous\u0026#34;} 13\tanimals[4] = []string{\u0026#34;lion\u0026#34;, \u0026#34;running\u0026#34;, \u0026#34;carnivorous\u0026#34;} 14 15\tfor index, animal := range animals { 16\tfmt.Printf(\u0026#34;%v- %s is %s animal and can %s \\n\u0026#34;, index, animal[0], animal[2], animal[1]) 17\t} 18} خروجی\n1user@system:~/go/src/temp❇ GO[1.19.3] 22:29:00 2→ go run main.go 30- Gopher is rodent animal and can running 41- owl is carnivorous animal and can flying 52- cheetah is carnivorous animal and can running 63- eagle is carnivorous animal and can flying 74- lion is carnivorous animal and can running 8user@system:~/go/src/temp❇ GO[1.19.3] 22:29:00 9→ go run main.go 104- lion is carnivorous animal and can running 110- Gopher is rodent animal and can running 121- owl is carnivorous animal and can flying 132- cheetah is carnivorous animal and can running 143- eagle is carnivorous animal and can flying 15user@system:~/go/src/temp❇ GO[1.19.3] 22:29:02 16→ go run main.go 172- cheetah is carnivorous animal and can running 183- eagle is carnivorous animal and can flying 194- lion is carnivorous animal and can running 200- Gopher is rodent animal and can running 211- owl is carnivorous animal and can flying به نحوه چیدمان خروجی‌ها دقت کنید، درباره علت یکسان نبودن خروجی‌ها در اجراهای متعدد تحقیق کنید.\nتکمیل و اصلاح می‌گردد\nخودآزمون: # کد زیر را بررسی کنید و خروجی(های) آن را با ذهن خود پردازش کنید. سپس صحت آن(ها) را بررسی و درباره آن تحقیق کنید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 var myMap map[string]int 7 fmt.Println(myMap) 8 9 var otherMap = map[string]int{} 10 fmt.Println(otherMap) 11 12 myMap[\u0026#34;foo\u0026#34;] = 13 13 fmt.Println(myMap) 14 15 otherMap[\u0026#34;bar\u0026#34;] = 99 16 fmt.Println(otherMap) 17} تکمیل و اصلاح می‌گردد\n"},{"id":16,"href":"/chapter-1/go-if-switch/","title":"1.9 شرط (if, switch)","section":"فصل اول: آشنایی با مفاهیم گو","content":" شرط (if-else) # زبان گو همانند ساز سایر زبان ها دارای شرط می باشد که خیلی ساده می توانید از آن استفاده کنید و در زیر ما فرمت استاندارد شرط در زبان گو را قرار دادیم :\n1if condition { 2 //Do something 3} else if condition { 4 //Do something 5} else { 6 //Do something 7} در بالا condition عبارتی است که قرار است وضعیت شرط را مشخص کند و در صورت true شدن شرط بر قرار می شود و در صورت برقرار نشدن شرط اول وارد else if می شود و مجدد یک condition دیگری را چک می کنیم که وضعیتش true می شود یا خیر و در نهایت منتهی می شود به else.\nدر شرط ما یک یا چندتا condition می توانیم داشته باشیم که این condition ها برای تعیین وضعیت از یکسری عملگرها نظیر \u0026amp;\u0026amp; , || , \u0026gt; , \u0026lt; , \u0026lt;= , =\u0026gt; , ! و \u0026hellip; استفاده می کند.\nزبان گو از فرمت های زیر برای ایجاد شرط استفاده می کند :\nفقط if if-else تو در تو (nested) شرط کوتاه با if کلمه if به تنهایی # شما می توانید به تنهایی از if استفاده و یک condition را بررسی کنید :\n1if condition { 2 //Do something 3} برای نمونه کد زیر را ببینید :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 a := 6 7 if a \u0026gt; 5 { 8 fmt.Println(\u0026#34;a is greater than 5\u0026#34;) 9 } 10} 1$ go run main.go 2a is greater than 5 در بالا ما مقدار a را با عدد ۵ بررسی کردیم که آیا a از ۵ بزرگتر است یا خیر؟ و جواب بله a بزرگتر است و شرط برقرار شد.\nدر زیر مثال دیگر زدیم که چندتا condition را داخل یک شرط بررسی می کنیم برقرار می شود یا خیر :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 a := 4 7 if a \u0026gt; 3 \u0026amp;\u0026amp; a \u0026lt; 6 { 8 fmt.Println(\u0026#34;a is within range\u0026#34;) 9 } 10} 1$ go run main.go 2a is within range کلمه else # شرط با else فرمتش مانند زیر است :\n1if condition { 2 //Do something 3} else { 4 //Do something 5} در بالا اگر condition برقرار نشود عملیات داخل else صورت میگیرد. که در ادامه یک مثال ساده زدیم :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 a := 1 7 b := 2 8 9 if a \u0026gt; b { 10 fmt.Println(\u0026#34;a is greater than b\u0026#34;) 11 } else { 12 fmt.Println(\u0026#34;b is greater than a\u0026#34;) 13 } 14} 1$ go run main.go 2b is greater than a ادامه شرط با else if # شما با استفاده کلمه else if می توانید condition دیگر را بررسی کرده و در صورت برقرار شدن شرط عملیات را انجام دهید.\n1if condition1 { 2 //Do something 3} else if condition2 { 4 //Do something 5} else { 6 //Do something 7} در زیر ما یک نمونه مثال برای else if زدیم :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 age := 29 7 if age \u0026lt; 18 { 8 fmt.Println(\u0026#34;Kid\u0026#34;) 9 } else if age \u0026gt;= 18 \u0026amp;\u0026amp; age \u0026lt; 40 { 10 fmt.Println(\u0026#34;Young\u0026#34;) 11 } else { 12 fmt.Println(\u0026#34;Old\u0026#34;) 13 } 14} 1$ go run main.go 2Young شرط تو در تو (nested) # شما می توانید شرط تو در تو (nested) داشته باشید (برای توسعه پروژه بهتره است کمتر استفاده از کنید از شرط تو در تو)\n1if condition { 2 //Do something 3 if condition2 { 4 //Do something 5 } 6 //Do something 7} در زیر یک نمونه شرط تو در تو به همراه else قرار دادیم :\n1if condition1 { 2 //... 3} else { 4 //... 5 if condition2 { 6 //... 7 } else { 8 //.... 9 } 10 //.... 11} در زیر مثال برای شرط تو در تو زدیم :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 a := 1 7 b := 2 8 c := 3 9 if a \u0026gt; b { 10 if a \u0026gt; c { 11 fmt.Println(\u0026#34;Biggest is a\u0026#34;) 12 } else if b \u0026gt; c { 13 fmt.Println(\u0026#34;Biggest is b\u0026#34;) 14 } 15 } else if b \u0026gt; c { 16 fmt.Println(\u0026#34;Biggest is b\u0026#34;) 17 } else { 18 fmt.Println(\u0026#34;Biggest is c\u0026#34;) 19 } 20} 1$ go run main.go 2Biggest is c تعریف شرط و قرار دادن condition در متغیر کوتاه # در زبان گو شرط ها امکان تعریف متغیر کوتاه برای condition را دارد که می توانید در همان خط شرط برقراری شرط را بررسی کنید.\n1if statement; condition { 2 //Do something 3} در زیر یک مثال ساده زدیم که توضیح می دهیم :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 if a := 6; a \u0026gt; 5 { 7 fmt.Println(\u0026#34;a is greater than 5\u0026#34;) 8 } 9} 1$ go run main.go 2a is greater than 5 در بالا ما یک متغیر کوتاه با نام a داخل شرط تعریف کردیم و مقدار 6 را بهش دادیم و سپس با قرار دادن ; برقراری وضعیت شرط را بررسی کردیم.\nSwitch # زبان گو ‌مانند برخی از زبان ها از switch پشتیبانی می کند و switch یک روش خیلی خوب برای جلوگیری از else if های بیشتر در شرط می باشد.\n1switch statement; expression { 2case expression1: 3 //Dosomething 4case expression2: 5 //Dosomething 6default: 7 //Dosomething 8} زمانیکه switch را تعریف می کنید شما باید statement و expression را برای بررسی قرار دهید و سپس داخل هر یک از case ها وضعیت برقرار بررسی می کنید و در نهایت اگر هیچکدام از case ها برابر با expresstion نباشد از default استفاده میکنیم تا مقدار پیش فرض را برگردانیم.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 switch ch := \u0026#34;b\u0026#34;; ch { 7 case \u0026#34;a\u0026#34;: 8 fmt.Println(\u0026#34;a\u0026#34;) 9 case \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;: 10 fmt.Println(\u0026#34;b or c\u0026#34;) 11 default: 12 fmt.Println(\u0026#34;No matching character\u0026#34;) 13 } 14} 1$ go run main.go 2b or c در مثال فوق ما حرف b انگلیسی را به متغیر کوتاه ch دادیم و سپس ch جهت بررسی هریک case ها پس ; نقطه ویرگول قرار دادیم. و در نهایت در هر یک از case بررسی کردیم کدام مقدار برابر ch است.\nSwitch خودآزمون # تفاوت ساختار و خروجی چهار فرمت مشابه زیر را بررسی کنید:\nحالت اول 1switch f(); { 2case true: 3 println(1) 4case false: 5 println(0) 6} حالت دوم 1switch f() 2{ 3case true: 4 println(1) 5case false: 6 println(0) 7} حالت سوم 1switch f() { 2case true: 3 println(1) 4case false: 5 println(0) 6} حالت چهارم 1switch f(); true { 2case true: 3 println(1) 4case false: 5 println(0) 6} کدها در زمان اجرا یا پیش از آن، در برخی IDE یا Code Editor(ها) فرمت می‌شوند. هدف این خودآزمون دقت به ساختار ابزار switch است. "},{"id":17,"href":"/chapter-1/go-for/","title":"1.10 حلقه ها (for)","section":"فصل اول: آشنایی با مفاهیم گو","content":" حلقه # حلقه ها را در زبان گو به ساده ترین شکل ممکن و فقط با استفاده از کلید واژه for و در مدل‌های مختلف (سه بخشی, بی نهایت, foreach\u0026hellip;) می‌توان پیاده سازی کرد.\nحلقه سه بخشی # این نمونه از حلقه ها که متداول ترین نوع حلقه است با استفاده از سه بخش مقداردهی, شرط و شمارنده ایجاد می شوند. در کد زیر نمونه ای از این حلقه ها قابل مشاهده و اجرا است.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tsum := 0 7\tfor i := 1; i \u0026lt; 10; i++ { 8\tsum += i 9\t} 10 11\tfmt.Println(sum) 12} 1$ go run main.go 245 حلقه while # این مدل حلقه تماما شبیه به رفتار do-while در زبان C را دارد با این تفاوت که پیاده سازی آن تنها با کلیدواژه for و با حذف بخش مقداردهی و شمارنده حلقه سه بخشی انجام می‌گیرد. در واقع در این حلقه تنها با تعریف یک شرط کدهای داخل حلقه تا برقراری آن شرط اجرا می شوند.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\ti := 0 7\tfor i \u0026lt; 10 { 8\tfmt.Println(i) 9\ti++ 10\t} 11} 1$ go run main.go 20 31 42 53 64 75 86 97 108 119 حلقه بی‌نهایت # اگر از حلقهwhile بخش شرط را حذف کنیم چه اتفاقی می افتد؟ در این حالت ما یک شرط بی نهایت ساخته ایم (شبیه به while(1)) که تا زمانی‌ که برنامه استاپ نشود و یا کدهای داخل حلقه فرمان خروج از حلقه را ندهند چرخه زندگی حلقه ادامه خواهد داشت.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tsum := 0 7\tfor { 8\tsum++ 9\t} 10 11\tfmt.Println(\u0026#34;this line will never execute\u0026#34;) 12} با اجرای کد بالا خطای تایم اوت دریافت خواهید کرد به دلیل اینکه حلقه هیچگاه پایان نمی پذیرد.\nکلید واژه break # با استفاده از break می‌توان چرخه اجرای یک حلقه را پایان داد. به عنوان مثال در حلقه بی نهایت بالا می‌توان با تعریف یک شرط خاص از حلقه خارج شد. کد زیر نمونه استفاده از break را نمایش می‌دهد.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tsum := 0 7\tfor { 8\tsum++ 9\tif sum == 10 { 10\tbreak 11\t} 12\t} 13 14\tfmt.Println(sum) 15\tfmt.Println(\u0026#34;now this line will execute\u0026#34;) 16} 1$ go run main.go 210 3now this line will execute کلیدواژه continue # این کلیدواژه چرخه اجرای حلقه را یک مرحله جلو می‌برد. به این معنی که اگر در حلقه از این کلیدواژه استفاده شود کدهای بعد از continue اجرا نشده و چرخه بعدی (گام بعدی) اجرا خواهد شد.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 7\tfor i := 1; i \u0026lt; 10; i++ { 8\tif i%2 == 0 { 9\tcontinue 10\t} 11\tfmt.Println(i) 12\t} 13} 1$ go run main.go 21 33 45 57 69 قابل ذکر است که continue و break در حلقه های تودرتو فقط روی اولین حلقه درونی تاثیر خواهند گذاشت "},{"id":18,"href":"/chapter-1/go-package/","title":"1.11 اضافه کردن پکیج در کد (package)","section":"فصل اول: آشنایی با مفاهیم گو","content":"زبان برنامه نویسی گو به شکلی طراحی شده است تا بتوانیم شیو‌ه های خوب مهندسی نرم افزار را به خوبی و ساده پیاده سازی کنیم. یکی از الگوهای مهم برای ارتقای کیفیت یک نرم افزار استفاده از DRY principle است. کلمه DRY مخفف Don’t Repeat Yourself است. که به صورت خیلی ساده یعنی کدی که خواهید نوشت را دوبار تکرار نکنید. تا جایی که امکان دارد باید از کدهای قبلی که نوشته اید بتوانید استفاده کنید. پکیج‌ها امکاناتی از جمله:\nقابلیت استفاده مجدد از کد را به ما میدهند. امکان ماژولار، و قابل نگهداری را فراهم می‌کنند. امکان مدیریت بهتر فایل‌ها را در یک واحد ایجاد می‌کنند. پکیج‌ها در زبان گو # پکیج در اصل یک یا مجموعه از سورس فایل های شما است که داخل یک فولدر قرار ممکن است قرار بگیرد. هر سورس فایلی که دارید در زبان گو متعلق به یک پکیج است. برای تعریف یک پکیج از دستور زیر استفاده میکنیم:\n1package \u0026lt;packagename\u0026gt; برای تعریف پکیج باید در اولین خط فایل آن را با کلید واژه package تعریف کنید. داخل این پکیج شما می‌توانید کد‌هایی که لازم دارید را بنویسید و تصمیم بگیرید کدام متغییر، فانکشن یا تایپ باید به صورت عمومی باشد یا باید به صورت خصوصی فقط داخل پکیج مورد استفاده قرار بگیرد.\nقطعا میدانیم بعد از نوشتن پکیج اگر بخواهیم از آن پکیج داخل پکیج‌های دیگر استفاده کنیم باید از کلید واژه import استفاده کنیم.\nاضافه کردن پکیج # برای اضافه کردن پکیج‌های مختلف ما از کلید واژه import استفاده می‌کنیم.\n1import \u0026#34;fmt\u0026#34; برای مثال در کد بالا ما از پکیج استاندارد هسته گو استفاده کریدم. این به این معنی است همراه با تعریف کلمه fmt میتوانیم از توابعی که داخل این پکیج استفاده شده است استفاده کنیم. در مثال زیر ما از تابع Println برای چاپ مقدارHello GoFarsi!‍ استفاده کردیم.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tfmt.Println(\u0026#34;Hello GoFarsi!\u0026#34;) 7} تعریف کردن توابع به این شکل مزایای زیادی دارد از جمله:\nاگر اسم های مشابهی داشته باشید، داخل پکیج‌های مختلف می‌توانید از آن‌ها استفاده کنید و خوانایی برنامه افزایش پیدا میکند و باعث می‌شود از نام‌های طولانی استفاده نکنیم. مجموعه کدی که مربوط به هم هستن را در یک پکیج می‌توانیم قرار دهیم. و پیدا کردن و استفاده مجدد را برای ما راحتر می‌کند. فرایند تغییر و کامپایل را می‌تواند به حداقل برساند. اضافه کردن چندین پکیج # ما می‌توانیم برای اضافه کردن هر پکیج از کلید واژه import به شکل زیر استفاده کنیم :\n1import \u0026#34;fmt\u0026#34; 2import \u0026#34;time\u0026#34; 3import \u0026#34;math\u0026#34; 4import \u0026#34;math/rand\u0026#34; اما با تشکر از گو ما میتوانیم کلیدواژهایی که قرار است بیشتر از یک بار اجرا شوند را به شکل زیر نیز تعریف کنید:\n1import ( 2\t\u0026#34;fmt\u0026#34; 3\t\u0026#34;time\u0026#34; 4\t\u0026#34;math\u0026#34; 5 \u0026#34;math/rand\u0026#34; 6) یعنی یک بار از کلیدواژ import استفاده کنیم و بعد اسم پکیج ها را به ترتیب داخل آن بنویسیم.\nاسم های عمومی و خصوصی (Export و Unexport) # همه توابع، متغیر‌ها و تایپ ‌هایی که تعریف میکنید اگر اول حرف اسم‌ها را بزرگ بزارید به این منظور است که آن را به صورت عمومی تعریف کرده اید و خارج از پکیج آن تابع، متغیر یا تایپ قابل دسترسی است. و اگر شما حرف اول اسم توابع، متغیرها و تایپ‌هایی که تعریف کردید را کوچک بگذارید به این معنی است که فقط داخل این پکیج آن تابع، متغیر یا تایپ قابل تعریف و استفاده است و خارج از پکیج قابل استفاده نیست.\nبرای مثال کد زیر را مشاهده کنید:\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;math\u0026#34; 6) 7 8func main() { 9\tfmt.Println(math.MaxInt64) // result: 9223372036854775807 10} در کد بالا ما از دو پکیج fmt و math استفاده کردیم. تابع Println از پکیج fmt به دلیل اینکه اولین حرف آن بزرگ است ما می‌توانیم داخل پکیج main خود از آن تابع استفاده کنیم. و برای پکیج math دقیقا بخاطر آنکه اول حرف MaxInt64 بزرگ است می‌توانیم از آن استفاده کنیم.\nحالا فرض کنیم که داخل پکیج math ما می‌خواهیم عدد pi را برگردانیم و ممکن است این متغییر فقط داخل این پکیج تعریف شده باشد پس اگر کاراکتر اول را به صورت کوچک بذاریم با خطا مواجه خواهیم شد:\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;math\u0026#34; 6) 7 8func main() { 9\tfmt.Println(math.MaxInt64) 10\tfmt.Println(math.pi) 11} 12 13// result: 14./prog.go:10:19: undefined: math.pi 15Go build failed. برای حل خطای بالا کافی است pi را به Pi تغییر دهید.\nاضافه کردن پکیج‌های 3rd party # فرض کنید می‌خواهیم از پکیج Gin (github.com) می‌خواهیم استفاده کنیم برای اضافه کردن این پکیج ما ‌می‌توانیم به دو شکل زیر آن را اضافه کنیم.\nداخل پروژه خود از دستور زیر استفاده کنید:\n1$ go get -u github.com/gin-gonic/gin بعدا می‌توانید وارد پروژه خود شوید و با کلید واژه import از آن استفاده کنید به شکل زیر :\n1package main 2 3import ( 4 \u0026#34;net/http\u0026#34; 5 6 \u0026#34;github.com/gin-gonic/gin\u0026#34; 7) 8 9func main() { 10 r := gin.Default() 11 r.GET(\u0026#34;/ping\u0026#34;, func(c *gin.Context) { 12 c.JSON(http.StatusOK, gin.H{ 13 \u0026#34;message\u0026#34;: \u0026#34;pong\u0026#34;, 14 }) 15 }) 16 r.Run() // listen and serve on 0.0.0.0:8080 (for windows \u0026#34;localhost:8080\u0026#34;) 17} حالت دیگر استفاده از go mod tidy است به این شکل که ما از دستور go get استفاده نمیکنیم. و همان مستقیم داخل پروژه آدرس gin را داخل import وارد میکنیم.\nو همان ابتدا داخل کد یک فانکشن را با همان پکیج فراخوانی میکنیم (اینکار لازم است چون همانطور که می دانید خود go tool وقتی بداند شما پکجی را تعریف کردید و استفاده نکردید آن را اتوماتیک پاک میکند.)\nسپس از دستور زیر استفاده میکنیم:\n1$ go mod tidy این دستور کل کدهای شما را بررسی می‌کند و اگر ببینید پکیجی تعریف شده است و شما آن را ندارید سعی میکند آن پکیج را برای شما دانلود و به پروژه شما اضافه کند.\n"},{"id":19,"href":"/chapter-1/go-defer-panic-recovery/","title":"1.12 defer, panic, recovery","section":"فصل اول: آشنایی با مفاهیم گو","content":" تعویق (defer) # کلمه کلیدی defer یکی از کاربردی ترین امکانات زبان گو می باشد که شما می توانید اجرای یک تابع را به تعویق بندازید و در آخر تابع فعلی اجرا کنید. عموما defer برای توابعی کاربرد دارد که قصد دارد پاکسازی یا بستن عملیات های صورت گرفته را انجام دهد نظیر توابع Close در برخی از جاها.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7func main() { 8\tdefer fmt.Println(\u0026#34;world\u0026#34;) 9\tfmt.Println(\u0026#34;hello\u0026#34;) 10} 1$ go run main.go 2hello 3world تعویق (defer) تابع درون خطی (inline) # شما خیلی ساده می توانید توابع درون خطی را تعویق بندازید.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 defer func() { fmt.Println(\u0026#34;In inline defer\u0026#34;) }() 7 fmt.Println(\u0026#34;Executed\u0026#34;) 8} 1$ go run main.go 2Executed 3In inline defer تعویق (defer) چند تابع در یک تابع # در کد زیر ما داخل یک تابع چند تابع را تعویق (defer) کردیم.\n1package main 2import \u0026#34;fmt\u0026#34; 3func main() { 4 i := 0 5 i = 1 6 defer fmt.Println(i) 7 i = 2 8 defer fmt.Println(i) 9 i = 3 10 defer fmt.Println(i) 11} 1$ go run main.go 23 32 41 پانیک (panic) # در زبان گو panic همانند exception به معنای خروج از برنامه در شرایط غیر عادی می باشد. panic در ۲ حالت زیر پیش می آید:\nخطاهای در زمان اجرا برنامه فراخوانی تابع panic توسط برنامه نویس در بخش های مختلف برنامه 1func panic(v interface{}) از تابع فوق شما می توانید برای ایجاد panic استفاده کنید و به عنوان ورودی دلیل panic را می توانید در قالب خطا یه یک متن مشخص کنید.\nتایپ {}interface یک تایپ خیلی کاربردی می باشد برای مواقعی نمی دانیم ورودی یا خروجی تابع یا تایپ متغیر چی میخواهد باشد از اینترفیس استفاده می کنیم.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5var ( 6\ta interface{} = 123 7\tb interface{} = \u0026#34;abcd\u0026#34; 8\tc interface{} = 2.5 9) 10 11func main() { 12\tfmt.Printf(\u0026#34;%v, %T\\n\u0026#34;, a, a) 13\tfmt.Printf(\u0026#34;%v, %T\\n\u0026#34;, b, b) 14\tfmt.Printf(\u0026#34;%v, %T\\n\u0026#34;, c, c) 15} 1$ go run main.go 2123, int 3abcd, string 42.5, float64 و به عنوان یک تایپ ضمنی می باشد که در ادامه فصل بعدی بیشتر آشنا خواهیم شد.\nخطای panic در زمان اجرا (runtime) # خطاهای panic در زمان اجرا به دلایل زیر می تواند رخ دهد :\nخطای Out of bounds/range array/slice فراخوانی تابع که nil pointer باشد ارسال داده برروی کانال های بسته شده type assertion نادرست 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 7\ta := []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;} 8\tprint(a, 2) 9} 10 11func print(a []string, index int) { 12\tfmt.Println(a[index]) 13} 1$ go run main.go 2panic: runtime error: index out of range [2] with length 2 3 4goroutine 1 [running]: 5main.checkAndPrint(...) 6 main.go:12 7main.main() 8 /main.go:8 +0x1b 9exit status 2 در تابع فوق ما یک تابع جهت چاپ یک المنت در داخل slice نوشتیم و به عنوان ورودی a و اندیس ۲ را می دهیم در صورتیکه slice ما فقط ۲ تا المنت بیشتر ندارد 0 و 1 ما به اندیس ۲ اشاره کردیم که باعث بروز panic شده است.\nپانیک رخ داده شامل متن خطا محل رخ دادن panic در قالب stacktrace می باشد خطای panic از قبل تعیین شده توسط برنامه نویس # همانطور که گفتیم شما می توانید هرجایی از بدنه توابع خود تابع panic را فراخوانی که تا برنامه در آن محل خطایی را نمایش و متوقف شود.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 7\ta := []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;} 8\tcheckAndPrint(a, 2) 9} 10 11func checkAndPrint(a []string, index int) { 12\tif index \u0026gt; (len(a) - 1) { 13\tpanic(\u0026#34;Out of bound access for slice\u0026#34;) 14\t} 15\tfmt.Println(a[index]) 16} 1$ go run main.go 2panic: Out of bound access for slice 3 4goroutine 1 [running]: 5main.checkAndPrint(0xc000104f58, 0x2, 0x2, 0x2) 6 main.go:13 +0xe2 7main.main() 8 main.go:8 +0x7d 9exit status 2 توجه کنید استفاده از تابع panic در برخی مواقع مفید می باشد به عنوان مثال قصد دارید هنگام اجرا یکسری تنظیمات از سمت کاربر دریافت کنید و در صورتیکه تنظیمات دارای مشکل باشد می توانید با استفاده panic جلو ادامه روند برنامه را بگیرید تا کاربر خطا را رفع کند. بازیابی (recovery) # برخی اوقات panic ها غیرقابل پیش بینی می باشند و ممکن است در حال حاضر برنامه شما بدون هیچ خطایی اجرا شوند و به روند خود ادامه دهد اما ممکن است به دلیل اشتباه panic رخ دهد و برنامه شما کاملا متوقف و باعث از دست دادن وضعیت استیبل برنامه شود.\nبه همین منظور یک تابع به نام recover وجود دارد که پس از رخ دادن panic برنامه مجدد بتواند به وضعیت قبلی خود بازگردد تا بعدا خطای panic رخ داده را بررسی و رفع کنیم.\n1func recover() interface{} یک نمونه کد استفاده از recover :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 7\ta := []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;} 8\tcheckAndPrint(a, 2) 9\tfmt.Println(\u0026#34;Exiting normally\u0026#34;) 10} 11 12func checkAndPrint(a []string, index int) { 13\tdefer handleOutOfBounds() 14\tif index \u0026gt; (len(a) - 1) { 15\tpanic(\u0026#34;Out of bound access for slice\u0026#34;) 16\t} 17\tfmt.Println(a[index]) 18} 19 20func handleOutOfBounds() { 21\tif r := recover(); r != nil { 22\tfmt.Println(\u0026#34;Recovering from panic:\u0026#34;, r) 23\t} 24} 1$ go run main.go 2Recovering from panic: Out of bound access for slice 3Exiting normally در کد فوق ما یک تابع داریم که این تابع یک اندیسی از یک slice را چاپ می کند اما اگر این اندیس خارج از تعداد المنت های slice باشد یک خطای panic رخ می دهد. ما برای جلوگیری از خطای panic تابع handleOutOfBounds با استفاده defer درون تابع checkAndPrint قرار دادیم که پس از رخ دادن panic بصورت خودکار بازیابی صورت بگیرد تا برنامه ما متوقف نشود.\nچاپ اطلاعات stacktrace پس از بازیابی # شما می توانید پس از اینکه بازیابی کردید جزئیات بیشتر در خصوص خطای panic رخ داده بدست آوردید.\n1package main 2import ( 3 \u0026#34;fmt\u0026#34; 4 \u0026#34;runtime/debug\u0026#34; 5) 6func main() { 7 a := []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;} 8 checkAndPrint(a, 2) 9 fmt.Println(\u0026#34;Exiting normally\u0026#34;) 10} 11func checkAndPrint(a []string, index int) { 12 defer handleOutOfBounds() 13 if index \u0026gt; (len(a) - 1) { 14 panic(\u0026#34;Out of bound access for slice\u0026#34;) 15 } 16 fmt.Println(a[index]) 17} 18func handleOutOfBounds() { 19 if r := recover(); r != nil { 20 fmt.Println(\u0026#34;Recovering from panic:\u0026#34;, r) 21 fmt.Println(\u0026#34;Stack Trace:\u0026#34;) 22 debug.PrintStack() 23 } 24} 1$ go run main.go 2Recovering from panic: Out of bound access for slice 3Stack Trace: 4goroutine 1 [running]: 5runtime/debug.Stack(0xd, 0x0, 0x0) 6 stack.go:24 +0x9d 7runtime/debug.PrintStack() 8 stack.go:16 +0x22 9main.handleOutOfBounds() 10 main.go:27 +0x10f 11panic(0x10ab8c0, 0x10e8f60) 12 /Users/slohia/Documents/goversion/go1.14.1/src/runtime/panic.go:967 +0x166 13main.checkAndPrint(0xc000104f58, 0x2, 0x2, 0x2) 14 main.go:18 +0x111 15main.main() 16 main.go:11 +0x81 17Exiting normally "},{"id":20,"href":"/chapter-1/go-builtins/","title":"1.13 لیست تایپ ها و توابع Builtin","section":"فصل اول: آشنایی با مفاهیم گو","content":"در زیر لیست تایپ ها و توابع Builtin تا نسخه ۱.۱۹ را با توضیحات قرار دادیم.\n1// bool is the set of boolean values, true and false. 2type bool bool 3 4// true and false are the two untyped boolean values. 5const ( 6 true = 0 == 0 // Untyped bool. 7 false = 0 != 0 // Untyped bool. 8) 9 10// uint8 is the set of all unsigned 8-bit integers. 11// Range: 0 through 255. 12type uint8 uint8 13 14// uint16 is the set of all unsigned 16-bit integers. 15// Range: 0 through 65535. 16type uint16 uint16 17 18// uint32 is the set of all unsigned 32-bit integers. 19// Range: 0 through 4294967295. 20type uint32 uint32 21 22// uint64 is the set of all unsigned 64-bit integers. 23// Range: 0 through 18446744073709551615. 24type uint64 uint64 25 26// int8 is the set of all signed 8-bit integers. 27// Range: -128 through 127. 28type int8 int8 29 30// int16 is the set of all signed 16-bit integers. 31// Range: -32768 through 32767. 32type int16 int16 33 34// int32 is the set of all signed 32-bit integers. 35// Range: -2147483648 through 2147483647. 36type int32 int32 37 38// int64 is the set of all signed 64-bit integers. 39// Range: -9223372036854775808 through 9223372036854775807. 40type int64 int64 41 42// float32 is the set of all IEEE-754 32-bit floating-point numbers. 43type float32 float32 44 45// float64 is the set of all IEEE-754 64-bit floating-point numbers. 46type float64 float64 47 48// complex64 is the set of all complex numbers with float32 real and 49// imaginary parts. 50type complex64 complex64 51 52// complex128 is the set of all complex numbers with float64 real and 53// imaginary parts. 54type complex128 complex128 55 56// string is the set of all strings of 8-bit bytes, conventionally but not 57// necessarily representing UTF-8-encoded text. A string may be empty, but 58// not nil. Values of string type are immutable. 59type string string 60 61// int is a signed integer type that is at least 32 bits in size. It is a 62// distinct type, however, and not an alias for, say, int32. 63type int int 64 65// uint is an unsigned integer type that is at least 32 bits in size. It is a 66// distinct type, however, and not an alias for, say, uint32. 67type uint uint 68 69// uintptr is an integer type that is large enough to hold the bit pattern of 70// any pointer. 71type uintptr uintptr 72 73// byte is an alias for uint8 and is equivalent to uint8 in all ways. It is 74// used, by convention, to distinguish byte values from 8-bit unsigned 75// integer values. 76type byte = uint8 77 78// rune is an alias for int32 and is equivalent to int32 in all ways. It is 79// used, by convention, to distinguish character values from integer values. 80type rune = int32 81 82// any is an alias for interface{} and is equivalent to interface{} in all ways. 83type any = interface{} 84 85// comparable is an interface that is implemented by all comparable types 86// (booleans, numbers, strings, pointers, channels, arrays of comparable types, 87// structs whose fields are all comparable types). 88// The comparable interface may only be used as a type parameter constraint, 89// not as the type of a variable. 90type comparable interface{ comparable } 91 92// iota is a predeclared identifier representing the untyped integer ordinal 93// number of the current const specification in a (usually parenthesized) 94// const declaration. It is zero-indexed. 95const iota = 0 // Untyped int. 96 97// nil is a predeclared identifier representing the zero value for a 98// pointer, channel, func, interface, map, or slice type. 99var nil Type // Type must be a pointer, channel, func, interface, map, or slice type 100// Type is here for the purposes of documentation only. It is a stand-in// for any Go type, but represents the same type for any given function 101// invocation. 102type Type int 103 104// Type1 is here for the purposes of documentation only. It is a stand-in// for any Go type, but represents the same type for any given function 105// invocation. 106type Type1 int 107 108// IntegerType is here for the purposes of documentation only. It is a stand-in// for any integer type: int, uint, int8 etc. 109type IntegerType int 110 111// FloatType is here for the purposes of documentation only. It is a stand-in// for either float type: float32 or float64. 112type FloatType float32 113 114// ComplexType is here for the purposes of documentation only. It is a// stand-in for either complex type: complex64 or complex128. 115type ComplexType complex64 116 117// The append built-in function appends elements to the end of a slice. If 118// it has sufficient capacity, the destination is resliced to accommodate the 119// new elements. If it does not, a new underlying array will be allocated. 120// Append returns the updated slice. It is therefore necessary to store the 121// result of append, often in the variable holding the slice itself: 122// 123// slice = append(slice, elem1, elem2) 124// slice = append(slice, anotherSlice...) 125// 126// As a special case, it is legal to append a string to a byte slice, like this: 127// 128// slice = append([]byte(\u0026#34;hello \u0026#34;), \u0026#34;world\u0026#34;...) 129func append(slice []Type, elems ...Type) []Type 130 131// The copy built-in function copies elements from a source slice into a 132// destination slice. (As a special case, it also will copy bytes from a 133// string to a slice of bytes.) The source and destination may overlap. Copy 134// returns the number of elements copied, which will be the minimum of 135// len(src) and len(dst). 136func copy(dst, src []Type) int 137 138// The delete built-in function deletes the element with the specified key 139// (m[key]) from the map. If m is nil or there is no such element, delete 140// is a no-op. 141func delete(m map[Type]Type1, key Type) 142 143// The len built-in function returns the length of v, according to its type: 144// 145// Array: the number of elements in v. 146// Pointer to array: the number of elements in *v (even if v is nil). 147// Slice, or map: the number of elements in v; if v is nil, len(v) is zero. 148// String: the number of bytes in v. 149// Channel: the number of elements queued (unread) in the channel buffer; 150// if v is nil, len(v) is zero. 151// 152// For some arguments, such as a string literal or a simple array expression, the 153// result can be a constant. See the Go language specification\u0026#39;s \u0026#34;Length and 154// capacity\u0026#34; section for details. 155func len(v Type) int 156 157// The cap built-in function returns the capacity of v, according to its type: 158// 159// Array: the number of elements in v (same as len(v)). 160// Pointer to array: the number of elements in *v (same as len(v)). 161// Slice: the maximum length the slice can reach when resliced; 162// if v is nil, cap(v) is zero. 163// Channel: the channel buffer capacity, in units of elements; 164// if v is nil, cap(v) is zero. 165// 166// For some arguments, such as a simple array expression, the result can be a 167// constant. See the Go language specification\u0026#39;s \u0026#34;Length and capacity\u0026#34; section for 168// details. 169func cap(v Type) int 170 171// The make built-in function allocates and initializes an object of type 172// slice, map, or chan (only). Like new, the first argument is a type, not a 173// value. Unlike new, make\u0026#39;s return type is the same as the type of its 174// argument, not a pointer to it. The specification of the result depends on 175// the type: 176// 177// Slice: The size specifies the length. The capacity of the slice is 178// equal to its length. A second integer argument may be provided to 179// specify a different capacity; it must be no smaller than the 180// length. For example, make([]int, 0, 10) allocates an underlying array 181// of size 10 and returns a slice of length 0 and capacity 10 that is 182// backed by this underlying array. 183// Map: An empty map is allocated with enough space to hold the 184// specified number of elements. The size may be omitted, in which case 185// a small starting size is allocated. 186// Channel: The channel\u0026#39;s buffer is initialized with the specified 187// buffer capacity. If zero, or the size is omitted, the channel is 188// unbuffered. 189func make(t Type, size ...IntegerType) Type 190 191// The new built-in function allocates memory. The first argument is a type, 192// not a value, and the value returned is a pointer to a newly 193// allocated zero value of that type. 194func new(Type) *Type 195 196// The complex built-in function constructs a complex value from two 197// floating-point values. The real and imaginary parts must be of the same 198// size, either float32 or float64 (or assignable to them), and the return 199// value will be the corresponding complex type (complex64 for float32, 200// complex128 for float64). 201func complex(r, i FloatType) ComplexType 202 203// The real built-in function returns the real part of the complex number c. 204// The return value will be floating point type corresponding to the type of c. 205func real(c ComplexType) FloatType 206 207// The imag built-in function returns the imaginary part of the complex 208// number c. The return value will be floating point type corresponding to 209// the type of c. 210func imag(c ComplexType) FloatType 211 212// The close built-in function closes a channel, which must be either 213// bidirectional or send-only. It should be executed only by the sender, 214// never the receiver, and has the effect of shutting down the channel after 215// the last sent value is received. After the last value has been received 216// from a closed channel c, any receive from c will succeed without 217// blocking, returning the zero value for the channel element. The form 218// 219// x, ok := \u0026lt;-c 220// 221// will also set ok to false for a closed and empty channel. 222func close(c chan\u0026lt;- Type) 223 224// The panic built-in function stops normal execution of the current 225// goroutine. When a function F calls panic, normal execution of F stops 226// immediately. Any functions whose execution was deferred by F are run in 227// the usual way, and then F returns to its caller. To the caller G, the 228// invocation of F then behaves like a call to panic, terminating G\u0026#39;s 229// execution and running any deferred functions. This continues until all 230// functions in the executing goroutine have stopped, in reverse order. At 231// that point, the program is terminated with a non-zero exit code. This 232// termination sequence is called panicking and can be controlled by the 233// built-in function recover. 234func panic(v any) 235 236// The recover built-in function allows a program to manage behavior of a 237// panicking goroutine. Executing a call to recover inside a deferred 238// function (but not any function called by it) stops the panicking sequence 239// by restoring normal execution and retrieves the error value passed to the 240// call of panic. If recover is called outside the deferred function it will 241// not stop a panicking sequence. In this case, or when the goroutine is not 242// panicking, or if the argument supplied to panic was nil, recover returns 243// nil. Thus the return value from recover reports whether the goroutine is 244// panicking. 245func recover() any 246 247// The print built-in function formats its arguments in an 248// implementation-specific way and writes the result to standard error. 249// Print is useful for bootstrapping and debugging; it is not guaranteed 250// to stay in the language. 251func print(args ...Type) 252 253// The println built-in function formats its arguments in an 254// implementation-specific way and writes the result to standard error. 255// Spaces are always added between arguments and a newline is appended. 256// Println is useful for bootstrapping and debugging; it is not guaranteed 257// to stay in the language. 258func println(args ...Type) 259 260// The error built-in interface type is the conventional interface for 261// representing an error condition, with the nil value representing no error. 262type error interface { 263 Error() string 264} "},{"id":21,"href":"/chapter-2/","title":"فصل دوم: مکانیزم های زبان","section":"صفحه اصلی","content":"در این فصل به مکانزیم های زبان گو میپردازیم\u0026hellip;\n"},{"id":22,"href":"/chapter-2/pointer/","title":"2.1 اشاره گر (Pointer)","section":"فصل دوم: مکانیزم های زبان","content":"اشاره گر در واقع متغیری است که آدرس حافظه متغیر دیگری را نگه می دارد.\n1var ex *T در بالا ما یک متغیری تعریف کردیم که مقدار داخل آدرس حافظه متغیری T را با استفاده از * را نگه می دارد.\nدر اشاره گر ۲ تا اپراتور داریم که هر کدام از این ها را در کنار یک متغیر بزاریم به آدرس حافظه یا مقدار داخل خانه حافظه متغیر قبلی دسترسی پیدا می کنیم :\n\u0026amp; با استفاده از این می توانیم آدرس حافظه متغیر فرضا x را به متغیر دیگری بدهیم (y := \u0026amp;x) * با استفاده از این می توانیم به مقدار داخل خانه حافظه متغیر فرضا x دسترسی پیدا کنیم (x*) برای اینکه یک اشاره گر تعریف کنیم ۲ روش وجود دارد :\nاستفاده از تابع new استفاده از اپراتور \u0026amp; (آمپرسند) استفاده از تابع new # یک اشاره گر با استفاده از تابع new بصورت زیر راه اندازی می شود :\n1a := new(int) 2*a = 10 3fmt.Println(*a) //Output will be 10 در بالا ما متغیر a را از نوع int اشاره گر تعریف کردیم و سپس داخل آدرس حافظه a مقدار ۱۰ را قرار دادیم.\nتوجه کنید مقدار پیش فرض یک متغیر از نوع اشاره گر nil می باشد. و اگر جایی شما متغیر از نوع اشاره گر بصورت nil بفرستید ممکن است panic از نوع nil pointer بر بخورید و پروژه کاملا متوقف شود. استفاده از اپراتور \u0026lsquo;\u0026amp;\u0026rsquo; # برای دریافت آدرس حافظه یک متغیر از \u0026amp; استفاده می شود :\n1a := 2 2b := \u0026amp;a 3fmt.Println(*b) //Output will be 2 در زیر یک نمونه کد مثال زدیم توجه کنید :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 var b *int 7 a := 2 8 b = \u0026amp;a 9 10 fmt.Println(b) 11 fmt.Println(*b) 12 b = new(int) 13 *b = 10 14 fmt.Println(*b) 15} 1$ go run main.go 22 310 40xc0000b0018 در خروجی بالا 0xc0000b0018 آدرس حافظه متغیر a می باشد.\nاپراتور * اشاره گر # اپراتور * برای می توانیم برای عملیات زیر استفاده کنیم :\nگرفتن مقدار یک آدرس حافظه که با استفاده از اشاره گر ذخیره شده است. تغییر مقدار یک آدرس حافظه 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\ta := 2 7\tb := \u0026amp;a 8\tfmt.Println(a) 9\tfmt.Println(*b) 10 11\t*b = 3 12\tfmt.Println(a) 13\tfmt.Println(*b) 14 15\ta = 4 16\tfmt.Println(a) 17\tfmt.Println(*b) 18} 1$ go run main.go 22 32 43 53 64 74 در بالا a و b* هر دور به یک متغیر دارند اشاره می کنند. بنابرین تغییر مقدار داخل خانه حافظه روی هر دو متغیر تاثیر میگذارد.\nاشاره گر به یک اشاره گر # شما می توانید یک متغیر اشاره گر تعریف کنید و متغیر اشاره گر دیگری را بهش اختصاص دهید.\n1a := 2 2b := \u0026amp;a 3c := \u0026amp;b در بالا متغیر a مقدارش ۲ می باشد و آدرسش در حافظه 0xXXXXXX است و در مقدار متغیر b ما اشاره کردیم به آدرس حافظه متغیر a و در ادامه در متغیر c به آدرس حافظه متغیر b اشاره کردیم که آدرسش در حافظه 0xYYYYYY است.\nزمانیکه شما بخواهید مقدار c را چاپ کنید کافیه c** را استفاده کنید تا مقدار را ۲ را که داخل خانه حافظه متغیر a قرار دارد را چاپ کند.\nبه مثال زیر توجه کنید :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\ta := 2 7\tb := \u0026amp;a 8\tc := \u0026amp;b 9 10\tfmt.Printf(\u0026#34;a: %d\\n\u0026#34;, a) 11\tfmt.Printf(\u0026#34;b: %x\\n\u0026#34;, b) 12\tfmt.Printf(\u0026#34;c: %x\\n\u0026#34;, c) 13 14\tfmt.Println() 15\tfmt.Printf(\u0026#34;a: %d\\n\u0026#34;, a) 16\tfmt.Printf(\u0026#34;*\u0026amp;a: %d\\n\u0026#34;, *\u0026amp;a) 17\tfmt.Printf(\u0026#34;*b: %d\\n\u0026#34;, *b) 18\tfmt.Printf(\u0026#34;**c: %d\\n\u0026#34;, **c) 19 20\tfmt.Println() 21\tfmt.Printf(\u0026#34;\u0026amp;a: %d\\n\u0026#34;, \u0026amp;a) 22\tfmt.Printf(\u0026#34;b: %d\\n\u0026#34;, b) 23\tfmt.Printf(\u0026#34;\u0026amp;*b: %d\\n\u0026#34;, \u0026amp;*b) 24\tfmt.Printf(\u0026#34;*\u0026amp;b: %d\\n\u0026#34;, *\u0026amp;b) 25\tfmt.Printf(\u0026#34;*c: %d\\n\u0026#34;, *c) 26 27\tfmt.Println() 28\tfmt.Printf(\u0026#34;b: %d\\n\u0026#34;, \u0026amp;b) 29\tfmt.Printf(\u0026#34;*c: %d\\n\u0026#34;, c) 30} 1$ go run main.go 2a: 2 3b: c000018078 4c: c00000e028 5 6a: 2 7*\u0026amp;a: 2 8*b: 2 9**c: 2 10 11\u0026amp;a: 824633819256 12b: 824633819256 13\u0026amp;*b: 824633819256 14*\u0026amp;b: 824633819256 15*c: 824633819256 16 17b: 824633778216 18*c: 824633778216 توجه کنید زبان گو همانند زبان c استفاده از اشاره گر حسابی (Pointer Arithmetic) امکان پذیر نمی باشد و با خطای زیر مواجه خواهید شد :\n1package main 2func main() { 3 a := 1 4 b := \u0026amp;a 5 b = b + 1 6} 1$ go run main.go 2invalid operation: b + 1 (mismatched types *int and int) "},{"id":23,"href":"/chapter-2/struct/","title":"2.2 ساختار (struct)","section":"فصل دوم: مکانیزم های زبان","content":"در زبان گو ساختار به کالکشنی از فیلدها با تایپ های مختلف می گویند. شما با استفاده ساختار می توانید ساختار یا مدل کلی از بدنه پروژه خود را بنویسید. برای نمونه ما یک ساختار employee مثال زدیم تا با ساختار آشنا شوید.\n1type employee struct { 2 name string 3 age int 4 salary int 5} نکته: ساختار می‌تواند بصورت خالی نیز جهت برخی اهداف ایجاد گردد.\n1type sample struct {} متدها روی ساختار\nبرای ایجاد ساختار باید از کلمه کلیدی type استفاده کنید.\nداخل بدنه ساختار فیلدها را تعریف کنید.\nفیلد name از نوع string فیلد age از نوع int فیلد salary از نوع int ساختار زبان گو را با class در سایر زبان ها مقایسه می کنند. تعریف تایپ struct # در زیر یک مثال ساده برای اینکه بتوانید در هر جای بدنه فایل go ساختار تعریف کنید زدیم :\n1type point struct { 2 x float64 3 y float64 4} در بالا ما ۲ تا فیلد برای ساختار تعریف کردیم که هر دو فیلد از نوع float64 می باشند.\nایجاد یک متغیر ساختار (struct) # برای ایجاد یک متغیر ساختار می توانید خیلی ساده تعریف کنید و خانه ای از حافظه را برای متغیر در نظر گرفته شود.\n1emp := employee{} در بالا یک متغیر با مقدار پیش فرض صفر ساختار employee تعریف کردیم.\nزمانیکه یک متغیر ساختار تعریف می کنید مقدار استفاده از حافظه 0 بایت می باشد. ایجاد متغیر ساختار و مقدار دهی فیلدها در یک خط : 1emp := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} ایجاد متغیر ساختار و مقدار دهی فیلد در خط های مختلف (توصیه می شود) : 1emp := employee{ 2 name: \u0026#34;Sam\u0026#34;, 3 age: 31, 4 salary: 2000, 5} توجه کنید هیچ اجباری نیست حتما فیلدی را مقدار دهی کنید چون می توانید در جاهای دیگر یا هر زمانیکه نیاز داشتید مقدار دهی کنید.\n1emp := employee{ 2 name: \u0026#34;Sam\u0026#34;, 3 age: 31, 4} در بالا ما فیلد salary را مقدار دهی نکردیم و بطور پیش فرض کامپایلر با توجه به تایپ فیلد مقدار پیش فرض صفر اون تایپ را در نظر میگیرد.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type employee struct { 6 name string 7 age int 8 salary int 9} 10 11func main() { 12 emp1 := employee{} 13 fmt.Printf(\u0026#34;Emp1: %+v\\n\u0026#34;, emp1) 14 15 emp2 := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} 16 fmt.Printf(\u0026#34;Emp2: %+v\\n\u0026#34;, emp2) 17 18 emp3 := employee{ 19 name: \u0026#34;Sam\u0026#34;, 20 age: 31, 21 salary: 2000, 22 } 23 fmt.Printf(\u0026#34;Emp3: %+v\\n\u0026#34;, emp3) 24 25 emp4 := employee{ 26 name: \u0026#34;Sam\u0026#34;, 27 age: 31, 28 } 29 fmt.Printf(\u0026#34;Emp4: %+v\\n\u0026#34;, emp4) 30} 1$ go run main.go 2Emp1: {name: age:0 salary:0} 3Emp2: {name:Sam age:31 salary:2000} 4Emp3: {name:Sam age:31 salary:2000} 5Emp4: {name:Sam age:31 salary:0} ایجاد متغیر ساختار و مقدار دهی فیلدها بدون نام فیلد : شما می توانید فیلدها را بدون اینکه نام فیلد را قرار دهید مقدار دهی کنید اما از نظر تکنیکی اینکار توصیه نمی شود.\n1emp := employee{\u0026#34;Sam\u0026#34;, 31, 2000} 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type employee struct { 6 name string 7 age int 8 salary int 9} 10 11func main() { 12 emp := employee{\u0026#34;Sam\u0026#34;, 31, 2000} 13 fmt.Printf(\u0026#34;Emp: %+v\\n\u0026#34;, emp) 14} 1$ go run main.go 2Emp2: {name:Sam age:31 salary:2000} دسترسی و تنظیم فیلدهای ساختار (struct) # زمانیکه شما یک متغیر ساختار تعریف می کنید می توانید خیلی آسان با استفاده از همان متغیر به فیلدهای ساختار دسترسی پیدا کنید و مقدار هر کدام از فیلدها را تغییر دهید.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type employee struct { 6 name string 7 age int 8 salary int 9} 10 11func main() { 12 emp := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} 13 14 //Accessing a struct field 15 n := emp.name 16 fmt.Printf(\u0026#34;Current name is: %s\\n\u0026#34;, n) 17 18 //Assigning a new value 19 emp.name = \u0026#34;John\u0026#34; 20 fmt.Printf(\u0026#34;New name is: %s\\n\u0026#34;, emp.name) 21} 1$ go run main.go 2Current name is: Sam 3New name is: John کار با اشاره گر (Pointer) در ساختار (struct) # شما برای ایجاد یک struct از نوع اشاره گر از دو حالت زیر می توانید استفاده کنید :\nبا استفاده از عملگر \u0026amp; که اشاره به خانه حافظه دارد با استفاده از تابع new ایجاد ساختار با استفاده عملگر \u0026amp; # برای اینکه بتوانید یک ساختار از نوع اشاره گر ایجاد کنید می توانید از عملگر \u0026amp; استفاده کنید.\n1emp := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} 2empP := \u0026amp;emp حتی یک ساختار اشاره گر می تواند مستقیما ایجاد شود :\n1empP := \u0026amp;employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} به کد زیر توجه کنید :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type employee struct { 6 name string 7 age int 8 salary int 9} 10 11func main() { 12 emp := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} 13 empP := \u0026amp;emp 14 fmt.Printf(\u0026#34;Emp: %+v\\n\u0026#34;, empP) 15 empP = \u0026amp;employee{name: \u0026#34;John\u0026#34;, age: 30, salary: 3000} 16 fmt.Printf(\u0026#34;Emp: %+v\\n\u0026#34;, empP) 17} 1$ go run main.go 2Emp: \u0026amp;{name:Sam age:31 salary:2000} 3Emp: \u0026amp;{name:John age:30 salary:3000} ایجاد ساختار با استفاده تابع new # 1func new(Type) *Type با استفاده از تابع new :\nشما یک ساختار ایجاد می کنید. سپس فیلدها با مقدار پیش فرض صفر مقدار دهی اولیه می شوند. در نهایت ساختار شما از نوع اشاره گر بازگشت داده می شود. 1empP := new(employee) برای اینکه آدرس خانه حافظه ساختار از نوع اشاره گر را ببینید کافیه :\n1fmt.Printf(\u0026#34;Emp Pointer: %p\\n\u0026#34;, empP) برای اینکه مقدار هر یک از فیلدها را ببینید کافیه :\n1fmt.Printf(\u0026#34;Emp Value: %+v\\n\u0026#34;, *empP) 1$ go run main.go 2Emp Value: {name: age:0 salary:0} در زیر یک کد نمونه قرار دادیم به عنوان مثال :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type employee struct { 6 name string 7 age int 8 salary int 9} 10 11func main() { 12 empP := new(employee) 13 fmt.Printf(\u0026#34;Emp Pointer Address: %p\\n\u0026#34;, empP) 14 fmt.Printf(\u0026#34;Emp Pointer: %+v\\n\u0026#34;, empP) 15 fmt.Printf(\u0026#34;Emp Value: %+v\\n\u0026#34;, *empP) 16} 1$ go run main.go 2Emp Pointer Address: 0xc000130000 3Emp Pointer: \u0026amp;{name: age:0 salary:0} 4Emp Value: {name: age:0 salary:0} چاپ یک متغیر ساختار (struct) # برای اینکه بتوانید یک متغیر را چاپ کنید از دو روش زیر می توانید استفاده کنید و توجه کنید متغیر ساختار بصورت key/value هستش.\nبا استفاده از پکیج fmt چاپ متغیر ساختار با استفاده از پکیج json/encoding چاپ با استفاده از fmt # در پکیج fmt ۲ تا تابع کاربردی جهت چاپ وجود دارد که اکثر اوقات استفاده می کنیم :\nتابع Println ورودی را با فرمت پیش فرض چاپ و در نهایت خط جدید در نظر میگیرد. تابع Printf ورودی را با فرمت مشخص شده چاپ می کند و دست شما برای تعیین فرمت باز می باشد. در زیر ما یک نمونه از employee ایجاد کردیم :\n1emp := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} حال به شیوه های زیر با استفاده از تابع Printf ساختار را چاپ کردیم :\n1fmt.Printf(\u0026#34;%v\u0026#34;, emp) - {Sam 31 2000} 1fmt.Printf(\u0026#34;%+v\u0026#34;, emp) - {name:Sam age:31 salary:2000} %v - مقدار هر کدام از فیلدهای ساختار چاپ می کند. %+v - مقدار هرکدام از فیلدها به همراه اسم فیلد چاپ می کند. در زیر با استفاده از از تابع Println ساختار را چاپ کردیم :\n1fmt.Println(emp) - {Sam 31 2000} در نهایت کد زیر یک مثال کلی از چاپ با استفاده از پکیج fmt می باشد :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type employee struct { 6 name string 7 age int 8 salary int 9} 10 11func main() { 12 emp := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} 13 fmt.Printf(\u0026#34;Emp: %v\\n\u0026#34;, emp) 14 fmt.Printf(\u0026#34;Emp: %+v\\n\u0026#34;, emp) 15 fmt.Printf(\u0026#34;Emp: %#v\\n\u0026#34;, emp) 16 fmt.Println(emp) 17} 1$ go run main.go 2Emp: {Sam 31 2000} 3Emp: {name:Sam age:31 salary:2000} 4Emp: main.employee{name:\u0026#34;Sam\u0026#34;, age:31, salary:2000} 5{Sam 31 2000} چاپ ساختار با استفاده از پکیج JSON # در این روش ما با استفاده از ۲ تابع Marshal و MarshalIndent پکیج json ساختار را encode می کنیم. و در نهایت خروجی encode شده را چاپ می کنیم.\nMarshal - در این تابع به عنوان ورودی ساختار را پاس می دهیم و در نهایت ۲ خروجی از نوع بایت و خطا دریافت می کنیم. 1Marshal(v interface{}) ([]byte, error) MarhsalIndent - با استفاده از این تابع ۳ تا ورودی پاس می دهیم به ترتیب ساختار, پیشوند و indent و در نهایت ۲ خروجی از نوع بایت و خطا دریافت می کنیم. 1MarshalIndent(v interface{}, prefix, indent string) ([]byte, error) حالا با استفاده از توابع فوق یک کد نمونه مثال می زنیم چطور از این توابع استفاده کنید :\n1package main 2 3import ( 4 \u0026#34;encoding/json\u0026#34; 5 \u0026#34;fmt\u0026#34; 6 \u0026#34;log\u0026#34; 7) 8 9type employee struct { 10 Name string 11 Age int 12 salary int 13} 14 15func main() { 16 emp := employee{Name: \u0026#34;Sam\u0026#34;, Age: 31, salary: 2000} 17 //Marshal 18 empJSON, err := json.Marshal(emp) 19 if err != nil { 20 log.Fatalf(err.Error()) 21 } 22 fmt.Printf(\u0026#34;Marshal funnction output %s\\n\u0026#34;, string(empJSON)) 23 24 //MarshalIndent 25 empJSON, err = json.MarshalIndent(emp, \u0026#34;\u0026#34;, \u0026#34; \u0026#34;) 26 if err != nil { 27 log.Fatalf(err.Error()) 28 } 29 fmt.Printf(\u0026#34;MarshalIndent funnction output %s\\n\u0026#34;, string(empJSON)) 30} 1$ go run main.go 2Marshal funnction output {\u0026#34;Name\u0026#34;:\u0026#34;Sam\u0026#34;,\u0026#34;Age\u0026#34;:31} 3 4MarshalIndent funnction output { 5 \u0026#34;Name\u0026#34;: \u0026#34;Sam\u0026#34;, 6 \u0026#34;Age\u0026#34;: 31 7} برای اطلاعات بیشتر در خصوص پکیج json می توانید به بخش آموزش کار با jsonمراجعه کنید. کار با تگ ها در ساختار (struct) # در ساختار زبان گو شما امکان اضافه کردن metadata به هر یک از فیلدها را دارید که ما به عنوان تگ می شناسیم که تگ ها برای انجام یکسری عملیات خاص نظیر encode/decode, اعتبارسنجی مقادیر فیلدها و \u0026hellip; کمک می کند و یکی از کاربردی ترین عناوین در ساختار می باشد.\nدر زیر ما یک نمونه ساختار به همراه تگ تعریف کردیم :\n1type strutName struct{ 2 fieldName type `key:\u0026#34;value\u0026#34; key2:\u0026#34;value2\u0026#34;` 3} 1type employee struct { 2 Name string `json:\u0026#34;n\u0026#34;` 3 Age int `json:\u0026#34;a\u0026#34;` 4 Salary int `json:\u0026#34;s\u0026#34;` 5} تگ json به شما برای تعیین نام key داخل json کمک می کند و شما می توانید عنوان هر یک از فیلدهای بدنه json را یک نام اختصاصی قرار دهید و با استفاده از اون نام اختصاصی عملیات encode/decode در json انجام دهید.\n1package main 2 3import ( 4 \u0026#34;encoding/json\u0026#34; 5 \u0026#34;fmt\u0026#34; 6 \u0026#34;log\u0026#34; 7) 8 9type employee struct { 10 Name string `json:\u0026#34;n\u0026#34;` 11 Age int `json:\u0026#34;a\u0026#34;` 12 Salary int `json:\u0026#34;s\u0026#34;` 13} 14 15func main() { 16 emp := employee{Name: \u0026#34;Sam\u0026#34;, Age: 31, Salary: 2000} 17 //Converting to jsonn 18 empJSON, err := json.MarshalIndent(emp, \u0026#39;\u0026#39;, \u0026#39; \u0026#39;) 19 if err != nil { 20 log.Fatalf(err.Error()) 21 } 22 fmt.Println(string(empJSON)) 23} 1$ go run main.go 2{ 3 \u0026#34;n\u0026#34;: \u0026#34;Sam\u0026#34;, 4 \u0026#34;a\u0026#34;: 31, 5 \u0026#34;s\u0026#34;: 2000 6} در خروجی بالا نام key هر کدام از فیلدها تغییر کرده و دقت کنید ارتباط فیلدهای ساختار شما با فیلدهای json به واسطه تگی که تعیین کردید می باشد.\nتعریف فیلد ناشناس در ساختار (struct) # در ساختار امکان تعریف فیلدهای ناشناس را دارید و می توانید فیلد ناشناس را مقدار دهی کنید.\n1type employee struct { 2 string 3 age int 4 salary int 5} در زیر یک مثال ساده در خصوص فیلد ناشناس زدیم :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type employee struct { 6 string 7 age int 8 salary int 9} 10 11func main() { 12 emp := employee{string: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} 13 //Accessing a struct field 14 n := emp.string 15 fmt.Printf(\u0026#34;Current name is: %s\\n\u0026#34;, n) 16 //Assigning a new value 17 emp.string = \u0026#34;John\u0026#34; 18 fmt.Printf(\u0026#34;New name is: %s\\n\u0026#34;, emp.string) 19} 1$ go run main.go 2Current name is: Sam 3New name is: John تعریف ساختار تو در تو (nested) # یکی دیگر از امکانات ساختار در زبان گو بحث ساختار تو در تو می باشد. که در زیر مثالی که زدیم ساختار address را داخل employee قرار دادیم :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type employee struct { 6 name string 7 age int 8 salary int 9 address address 10} 11 12type address struct { 13 city string 14 country string 15} 16 17func main() { 18 address := address{city: \u0026#34;London\u0026#34;, country: \u0026#34;UK\u0026#34;} 19 emp := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000, address: address} 20 fmt.Printf(\u0026#34;City: %s\\n\u0026#34;, emp.address.city) 21 fmt.Printf(\u0026#34;Country: %s\\n\u0026#34;, emp.address.country) 22} 1$ go run main.go 2City: London 3Country: UK توجه کنید شما طبق روش زیر می توانید به فیلدهای تو در تو دسترسی داشته باشید :\n1emp.address.city 2emp.address.country تعریف یک ساختار عمومی یا خصوصی (Public/Private) # در زبان گو چیزی به عنوان کلمه کلیدی public یا private جهت تعیین وضعیت دسترسی به بیرون ندارد ولی در عوض کامپایلر گو براساس حرف بزرگ یا کوچک عنوان ساختار یا سایر تایپ ها تشخیص می دهد تایپ شما عمومی است یا خصوصی و در صورتیکه شما حرف اول را کوچک قرار دهید به کامپایلر دارید میگید این تایپ از بیرون این پکیج دسترسی ندارد.\n1type Person struct { 2 Name string 3 age int 4} 5 6type company struct { 7 Name string 8} برای اطلاعات بیشتر بهتره به بخش کپسوله سازی مراجعه کنید. مقایسه ساختارها # در زبان گو خیلی ساده می توانید ساختارها را بر اساس عنوان فیلد و تایپ و مقدارشان مقایسه کنید. اما باید توجه کنید ساختارها فقط براساس تایپ هایی که در زیر معرفی کردیم امکان مقایسه را خواهند داشت :\nboolean numeric string pointer channel interface types structs array اما ۳ تایپ زیر امکان مقایسه را از بین می برد :\nSlice Map Function 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type employee struct { 6 name string 7 age int 8 salary int 9} 10 11func main() { 12 emp1 := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} 13 emp2 := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} 14 if emp1 == emp2 { 15 fmt.Println(\u0026#34;emp1 annd emp2 are equal\u0026#34;) 16 } else { 17 fmt.Println(\u0026#34;emp1 annd emp2 are not equal\u0026#34;) 18 } 19} 1$ go run main.go 2emp1 annd emp2 are equal "},{"id":24,"href":"/chapter-2/method/","title":"2.3 متد (Method)","section":"فصل دوم: مکانیزم های زبان","content":"متد در واقع یک تابع گیرنده (reciver) است که به واسطه یک تایپ در دسترس خواهد, تا زمانیکه شما یک متغیر از نوع تایپی که دارای متد می باشد را راه اندازی نکنید به متدهایش دسترسی نخواهید داشت.\nاکثرا متد را یکی از عناوین شی گرایی در زبان گو میشناسند که مزایای خوبی دارد بخصوص اگر متدها برای تایپ struct تعریف شوند شما می توانید برای هریک از فیلدهای ساختارتان توابع بخصوصی در قالب متد بنویسید .\nدر زیر یک نمونه از متد را قرار دادیم :\n1func (receiver receiver_type) some_func_name(arguments) return_values توجه کنید برای تعریف تابع متد باید قبل از اسم تابع پرانتز قرار دهید و داخلش یک نام و تایپ مورد (reciver type) نظر را قرار دهید.\nمتدها برای ساختار (struct) # زبان گو یک زبان شی گرا نیست ولی برخی از مفاهیم شی گرایی را بصورت قرار دادی دارد که شما می توانید در کدهای خود استفاده کنید. ساختار در زبان گو یک تایپ می باشد که این تایپ کالکشنی از تایپ های مختلف می باشد که بخش قبلی ما بهش پرداختیم.\nدر زیر یک مثال در خصوص استفاده از متدها برای ساختار زدیم :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type employee struct { 6 name string 7 age int 8 salary int 9} 10 11func (e employee) details() { 12 fmt.Printf(\u0026#34;Name: %s\\n\u0026#34;, e.name) 13 fmt.Printf(\u0026#34;Age: %d\\n\u0026#34;, e.age) 14} 15 16func (e employee) getSalary() int { 17 return e.salary 18} 19 20func main() { 21 emp := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} 22 emp.details() 23 fmt.Printf(\u0026#34;Salary %d\\n\u0026#34;, emp.getSalary()) 24} 1$ go run main.go 2Name: Sam 3Age: 31 4Salary 2000 در کد بالا ما یک ساختار با نام employee ایجاد کردیم و سپس برایش ۲ تا متد با نام های details و getSalary تعریف کردیم. حال برای اینکه بتوانیم از این متدها استفاده کنیم داخل تابع main ما یک متغیر از نوع employee تعریف کردیم و سپس با استفاده از نقطه . پس از نام متغیر به متدها دسترسی پیدا کردیم همانند دسترسی به فیلدهای ساختار.\nآیا با استفاده از متد می توانیم مقدار یکی از فیلدهای داخل ساختار را تغییر دهیم ؟ این سوال ۲ جواب دارد هم آره و هم خیر\nحال به مثال زیر توجه کنید تا توضیح دهیم :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type employee struct { 6 name string 7 age int 8 salary int 9} 10 11func (e employee) setNewName(newName string) { 12 e.name = newName 13} 14 15func main() { 16 emp := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} 17 emp.setNewName(\u0026#34;John\u0026#34;) 18 fmt.Printf(\u0026#34;Name: %s\\n\u0026#34;, emp.name) 19} 1$ go run main.go 2Name: Sam علت اینکه می گوییم خیر : به خاطر اینکه ما داریم با یک کپی از فیلدهای ساختار کار می کنیم و با تغییر مقدار هر یک از فیلدها تغییر صورت نمی پذیرد. اما علت اینکه می گوییم آره : اگر ما با استفاده از اشاره گر به فیلدهای داخل ساختار دسترسی پیدا کنیم می توانید مستقیما داخل خانه حافظه مشخص شده مقدار فیلد مورد نظر ساختار را در هرجایی از پروژه تغییر دهیم. استفاده از اشاره گر (pointer) در متدها # در بالا ما مثالی زدیم و اشاره کردیم به اینکه آیا می توانید مقدار هر یک از فیلدهای ساختار را با استفاده از متد تغییر دهیم یا خیر و در پاسخ گفتیم آره و خیر و علت آره را توضیح دادیم. حال می خواهیم با یک مثال این مورد را توضیح دهیم.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type employee struct { 6 name string 7 age int 8 salary int 9} 10 11func (e *employee) setNewName(newName string) { 12 e.name = newName 13} 14 15func main() { 16 emp := \u0026amp;employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} 17 emp.setNewName(\u0026#34;John\u0026#34;) 18 fmt.Printf(\u0026#34;Name: %s\\n\u0026#34;, emp.name) 19} 1$ go run main.go 2Name: John در بالا متد setNewName یک نوع متد گیرنده از نوع اشاره گر است که ما داخل این تابع متد به مقدار فیلدهای داخل خانه حافظه ساختار employee دسترسی داریم و می توانیم مقدار دهی کنیم.\nآیا استفاده از گیرنده اشاره گر واقعا ضروری است؟ خیر, ضروری نیست زیرا ما وقتی به متدها دسترسی داریم که یک نمونه (instance) از تایپ مورد نظر ایجاد کنیم تا به متدهایش دسترسی داشته باشیم و همچنین اگر فرضا نیاز داشته باشیم که یکی از فیلد های ساختار را مقدار دهی کنیم بازم می توانیم به آدرس خانه متغیری که ساختار راه نگه داری می کند اشاره کنیم و مقدارش را تغییر دهیم.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type employee struct { 6 name string 7 age int 8 salary int 9} 10 11func (e *employee) setNewName(newName string) { 12 e.name = newName 13} 14 15func main() { 16 emp := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} 17 emp.setNewName(\u0026#34;John\u0026#34;) 18 19 fmt.Printf(\u0026#34;Name: %s\\n\u0026#34;, emp.name) 20 21 (\u0026amp;emp).setNewName(\u0026#34;Mike\u0026#34;) 22 fmt.Printf(\u0026#34;Name: %s\\n\u0026#34;, emp.name) 23} 1$ go run main.go 2Name: John 3Name: Mike چه موقع باید از گیرنده اشاره گر برای متد استفاده کنیم # زمانیکه قصد داریم متدهایی بنویسیم که برروی مقدار فیلدهای ساختار در زمان اجرا تغییراتی انجام دهد. زمانیکه ساختار خیلی بزرگ است و کلی فیلد دارد در اینجا بهتر از گیرنده اشاره گر استفاده کنیم تا هر بار با یکی کپی از ساختار مواجه نشویم و اینکار سربار را کم می کند. تعریف متد برای فیلدهای ساختار تو در تو (nested) # شما می توانید برای فیلدهایی که ساختار تو در تو دارد متد بنویسید :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type employee struct { 6\tname string 7\tage int 8\tsalary int 9\taddress address 10} 11 12type address struct { 13\tcity string 14\tcountry string 15} 16 17func (a address) details() { 18\tfmt.Printf(\u0026#34;City: %s\\n\u0026#34;, a.city) 19\tfmt.Printf(\u0026#34;Country: %s\\n\u0026#34;, a.country) 20} 21 22func main() { 23\taddress := address{city: \u0026#34;London\u0026#34;, country: \u0026#34;UK\u0026#34;} 24 25\temp := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000, address: address} 26 27\temp.address.details() 28} 1$ go run main.go 2City: London 3Country: UK در بالا ما یک متد برای ساختار address تعریف کردیم و سپس ساختار address را داخل ساختار employee گذاشتیم. در نهایت شما با استفاده از employee می توانید به متدهای address هم دسترسی داشته باشید و استفاده کنید.\n"},{"id":25,"href":"/chapter-2/interface/","title":"2.4 اینترفیس (Interface)","section":"فصل دوم: مکانیزم های زبان","content":"اینترفیس در زبان گو یک نوع مجموعه ای از متدها می باشد. این مجموعه متدها با توجه به ورودی و خروجی که دارند دارای رفتارهای خاصی هستند. زمانیکه شما یک اینترفیس به همراه یکسری از متدها تعریف می کنید باید در جایی این متدها را پیاده سازی کنید.\nاینترفیس ها به شما اجازه می دهد تا از Duck typing استفاده کنید. حالا این duck typing چیست؟\nduck typing روشی در برنامه نویسی کامپیوتری است که به شما امکان می دهد تست اردک را انجام دهید، جایی که ما نوع را بررسی نمی کنیم، بلکه تنها وجود برخی ویژگی ها یا روش ها را بررسی می کنیم. بنابراین آنچه واقعاً اهمیت دارد این است که آیا یک شی دارای ویژگی ها و روش های خاصی است و نه نوع آن.\nبرگردیم به بحث اینترفیس, در زیر ما یک نمونه اینترفیس را قرار دادیم :\n1type name_of_interface interface{ 2//Method signature 1 3//Method signature 2 4} برای اینکه مفهوم بالا را بهتر بفهمیم بزارید یک مثال بزنیم ساده بزنیم فرض کنید ما یک شی به نام animal که این حیوان یکسری رفتارها مانند: نفش کشید, راه رفتن را دارد که این رفتارهای باید به یک حیوان اختصاص دهیم تا بتوانیم از رفتارهای آن حیوان را مشخص کنیم.\n1type animal interface { 2 breathe() 3 walk() 4} در بالا ما یک اینترفیس تعریف کردیم ۲ تا متد دارد حالا بیاید یک متغیر از نوع اینترفیس animal درست کنیم و چاپ کنیم.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type animal interface { 6 breathe() 7 walk() 8} 9 10func main() { 11 var a animal 12 fmt.Println(a) 13} 1$ go run main.go 2nil در بالا وقتی اینترفیس را چاپ کردیم و خروجی nil بود و توجه کنید اینترفیس مقدار پیش فرض یا خالی بودنش nil هست.\nپیاده سازی اینترفیس # در بالا ما یک اینترفیس animal تعریف کردیم که ۲ متد داشت حالا قصد داریم یک شی (منظور ساختار در گو) به نام lion تعریف کنیم و متدهای اینترفیس animal را پیاده سازی کنیم.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type animal interface { 6 breathe() 7 walk() 8} 9 10type lion struct { 11 age int 12} 13 14func (l lion) breathe() { 15 fmt.Println(\u0026#34;Lion breathes\u0026#34;) 16} 17 18func (l lion) walk() { 19 fmt.Println(\u0026#34;Lion walk\u0026#34;) 20} 21 22func main() { 23 var a animal 24 a = lion{age: 10} 25 a.breathe() 26 a.walk() 27} 1$ go run main.go 2Lion breathes 3Lion walk در بالا ما یک متغیر با تایپ animal تعریف کردیم :\n1var a animal سپس ما یک نمونه از ساختار lion را بهش اختصاص دادیم :\n1a = lion{} اختصاص یک نمونه از ساختار lion به متغیر a که با تایپ lion بود موفقیت آمیز بود زیرا ما برای lion متدهای مورد مربوط animal را که breathe و walk بود پیاده سازی کردیم. این مفهوم کاملا شبیه به ducking typing هستش که در بالا گفتیم. یک شیر می تواند نفش بکشد و راه برود از این رو او یک حیوان است.\nتوجه کنید اگر شما متد جدیدی را اضافه یا کم کنید و همچنین اگر تغییر ایجاد کنید باید این تغییرات برروی اشیایی که با اینترفیس شما در ارتباط هست صورت بگیرید.\nبه عنوان مثال شما اگر به اینترفیس animal یک متد جدیدی اضافه کنید حتما باید برای ساختار lion باید پیاده سازی کنید.\nاینترفیس ها بطور ضمنی (implicitly) پیاده سازی می شود # برای اینترفیس هیچ حالت صریح (explicit) هنگام تعریف وجود ندارد و همه چی بصورت ضمنی است و تا زمانیکه یک اینترفیس برای یک شی (ساختار) متدهایش پیاده سازی نشود هیچ کاربردی نخواهد داشت.\nتوجه کنید هیچ حالت صریحی وجود ندارد که بگوید شما تمامی متدهای اینترفیس animal را برای ساختار lion پیاده سازی کردید یا خیر و فقط در زمان کامپایل اگر ایرادی وجود داشته باشد کامپایلر به شما خطا می دهد. و البته IDE هایی مانند: Goland , Vscode به شما هنگام نوشتن کد در خصوص این مورد کمک میکنند قبل از کامپایل متوجه خطاهای مرتبط با پیاده سازی اینترفیس شوید.\nخب بزارید یک مثال پیچیده برای اینترفیس animal بزنیم و یک شی (ساختار) دیگر به نام dog اضافه کنیم و متدهای اینترفیس animal را برای این شی پیاده سازی کنیم.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type animal interface { 6 breathe() 7 walk() 8} 9 10type lion struct { 11 age int 12} 13 14func (l lion) breathe() { 15 fmt.Println(\u0026#34;Lion breathes\u0026#34;) 16} 17 18func (l lion) walk() { 19 fmt.Println(\u0026#34;Lion walk\u0026#34;) 20} 21 22type dog struct { 23 age int 24} 25 26func (l dog) breathe() { 27 fmt.Println(\u0026#34;Dog breathes\u0026#34;) 28} 29 30func (l dog) walk() { 31 fmt.Println(\u0026#34;Dog walk\u0026#34;) 32} 33 34func main() { 35 var a animal 36 37 a = lion{age: 10} 38 a.breathe() 39 a.walk() 40 41 a = dog{age: 5} 42 a.breathe() 43 a.walk() 44} 1$ go run main.go 2Lion breathes 3Lion walk 4Dog breathes 5Dog walk در مثال بالا ما یک ساختار با نام dog تعریف کردیم و سپس متدهای animal را برای ساختار dog پیاده سازی کردیم و در نهایت ساختار dog را به متغیر اینترفیس a اختصاص دادیم. همانطور که میبینیم dog هم همانند lion نفس میکشد و راه می رود.\nتوجه کنید در بالا ما برای ۲ تا شی lion و dog یک وجه مشترک به نام animal به همراه رفتار مشترک تعریف کردیم که به اینکار پلی مورفیسم می گویند و یکی از عناوین پرکاربرد در شی گرایی می باشد که در بخش شی گرایی زبان گو بیشتر می پردازیم. دو نکته مهم در خصوص اینترفیس :\nاینترفیس ها فقط زمان کامپایل مشخص می شود که برای اشیا به درستی پیاده سازی شده اند یا خیر و اگر فرضا ما برای ساختار lion در کد بالا متد walk را حذف کنیم با خطای زیر رو به رو خواهیم شد : 1cannot use lion literal (type lion) as type animal in assignment: ورود و خروجی های هر متدی که پیاده سازی می کنید برای اشیا (ساختارها) بستگی به تعریف ضمنی متد داخل اینترفیس دارد و اگر شما متدی را داخل اینترفیس تغییر دهید حتما باید آن متد در اشیایی که قبلا پیاده سازی شده تغییر یابد. "},{"id":26,"href":"/chapter-2/type-embedding/","title":"2.5 جاسازی تایپ (type embedding)","section":"فصل دوم: مکانیزم های زبان","content":"جاسازی تایپ\u0026hellip;\n"},{"id":27,"href":"/chapter-2/error-handling/","title":"2.6 مدیریت خطاها","section":"فصل دوم: مکانیزم های زبان","content":"مدیریت خطاها\u0026hellip;\n"},{"id":28,"href":"/chapter-2/casting-vs-conversion/","title":"2.7 فرق casting با conversion","section":"فصل دوم: مکانیزم های زبان","content":"فرق casting با conversion\u0026hellip;\n"},{"id":29,"href":"/chapter-3/","title":"فصل سوم: همزمانی (concurrency)","section":"صفحه اصلی","content":"در این فصل به مباحث همزمانی در زبان گو میپردازیم\u0026hellip;\n"},{"id":30,"href":"/chapter-3/go-concurrency/","title":"3.1 آشنایی با همزمانی","section":"فصل سوم: همزمانی (concurrency)","content":"آشنایی با همزمانی\u0026hellip;\n"},{"id":31,"href":"/chapter-3/goroutine/","title":"3.2 گوروتین (goroutine)","section":"فصل سوم: همزمانی (concurrency)","content":"گوروتین (goroutine)\u0026hellip;\n"},{"id":32,"href":"/chapter-3/go-sync-package/","title":"3.3 پکیج sync","section":"فصل سوم: همزمانی (concurrency)","content":"پکیج sync\u0026hellip;\n"},{"id":33,"href":"/chapter-3/go-atomic/","title":"3.4 پکیج atomic","section":"فصل سوم: همزمانی (concurrency)","content":"پکیج atomic\u0026hellip;\n"},{"id":34,"href":"/chapter-3/goroutine-data-race/","title":"3.5 آموزش مقابله با data race","section":"فصل سوم: همزمانی (concurrency)","content":"آموزش مقابله با data race\u0026hellip;\n"},{"id":35,"href":"/chapter-3/go-channel/","title":"3.6 کانال (channel)","section":"فصل سوم: همزمانی (concurrency)","content":"کانال (channel)\u0026hellip;\n"},{"id":36,"href":"/chapter-3/go-select/","title":"3.7 آموزش استفاده از select","section":"فصل سوم: همزمانی (concurrency)","content":"آموزش استفاده از select\u0026hellip;\n"},{"id":37,"href":"/chapter-3/go-context/","title":"3.8 پکیج context","section":"فصل سوم: همزمانی (concurrency)","content":"پکیج context\u0026hellip;\n"},{"id":38,"href":"/chapter-3/go-concurrency-patterns/","title":"3.9 الگوهای همزمانی (concurrency patterns)","section":"فصل سوم: همزمانی (concurrency)","content":"الگوهای همزمانی (sconcurrency pattern)\u0026hellip;\n"},{"id":39,"href":"/chapter-3/go-channel-patterns/","title":"3.10 الگوهای کانال (channel patterns)","section":"فصل سوم: همزمانی (concurrency)","content":"الگوهای کانال (channel patterns)\u0026hellip;\n"},{"id":40,"href":"/chapter-3/go-concurrency-teqnique/","title":"3.11 تکنیک های همزمانی","section":"فصل سوم: همزمانی (concurrency)","content":"تکنیک های همزمانی\u0026hellip;\n"},{"id":41,"href":"/chapter-4/","title":"فصل چهارم: مباحث پیشرفته","section":"صفحه اصلی","content":"در این فصل به مباحث پیشرفته زبان گو میپردازیم\u0026hellip;\n"},{"id":42,"href":"/chapter-4/build-go-file/","title":"4.1 آموزش Build پروژه","section":"فصل چهارم: مباحث پیشرفته","content":"آموزش Build پروژه\u0026hellip;\n"},{"id":43,"href":"/chapter-4/debugging-go-code/","title":"4.2 آموزش کار با Debugging","section":"فصل چهارم: مباحث پیشرفته","content":"آموزش کار با Debugging\u0026hellip;\n"},{"id":44,"href":"/chapter-4/go-mod/","title":"4.3 آموزش کار با go mod","section":"فصل چهارم: مباحث پیشرفته","content":"آموزش کار با go mod\u0026hellip;\n"},{"id":45,"href":"/chapter-4/workspace/","title":"4.4 آموزش کار با workspace","section":"فصل چهارم: مباحث پیشرفته","content":"آموزش کار با workspace\u0026hellip;\n"},{"id":46,"href":"/chapter-4/command-line-go/","title":"4.5 آموزش نوشتن برنامه command line","section":"فصل چهارم: مباحث پیشرفته","content":"آموزش نوشتن برنامه command line\u0026hellip;\n"},{"id":47,"href":"/chapter-4/work-with-file-in-go/","title":"4.6 آموزش کار با فایل","section":"فصل چهارم: مباحث پیشرفته","content":"آموزش کار با فایل\u0026hellip;\n"},{"id":48,"href":"/chapter-4/work-with-json-file-in-go/","title":"4.7 آموزش کار با json","section":"فصل چهارم: مباحث پیشرفته","content":"آموزش کار با json\u0026hellip;\n"},{"id":49,"href":"/chapter-4/work-with-yaml-file-in-go/","title":"4.8 آموزش کار با yaml","section":"فصل چهارم: مباحث پیشرفته","content":"آموزش کار با yaml\u0026hellip;\n"},{"id":50,"href":"/chapter-4/work-with-toml-file-in-go/","title":"4.9 آموزش کار با toml","section":"فصل چهارم: مباحث پیشرفته","content":"آموزش کار با toml\u0026hellip;\n"},{"id":51,"href":"/chapter-4/work-with-csv-file-in-go/","title":"4.10 آموزش کار با csv","section":"فصل چهارم: مباحث پیشرفته","content":"آموزش کار با csv\u0026hellip;\n"},{"id":52,"href":"/chapter-4/work-with-ini-file-in-go/","title":"4.11 آموزش کار با ini","section":"فصل چهارم: مباحث پیشرفته","content":"آموزش کار با ini\u0026hellip;\n"},{"id":53,"href":"/chapter-4/work-with-environment-variable/","title":"4.12 آموزش کار با environment variable","section":"فصل چهارم: مباحث پیشرفته","content":"آموزش کار با environment variable\u0026hellip;\n"},{"id":54,"href":"/chapter-4/go-regular-expressions/","title":"4.13 آموزش کار با regexp","section":"فصل چهارم: مباحث پیشرفته","content":"آموزش کار با regexp\u0026hellip;\n"},{"id":55,"href":"/chapter-4/go-reflection/","title":"4.14 آموزش reflection","section":"فصل چهارم: مباحث پیشرفته","content":"آموزش reflection\u0026hellip;\n"},{"id":56,"href":"/chapter-4/go-generator/","title":"4.15 آموزش generator","section":"فصل چهارم: مباحث پیشرفته","content":"آموزش generator\u0026hellip;\n"},{"id":57,"href":"/chapter-4/go-stringer/","title":"4.16 آموزش stringer","section":"فصل چهارم: مباحث پیشرفته","content":"آموزش stringer\u0026hellip;\n"},{"id":58,"href":"/chapter-4/effective-go/","title":"4.17 تکنیک های کدنویسی زبان گو","section":"فصل چهارم: مباحث پیشرفته","content":"آموزش تکنیک های کدنویسی\u0026hellip;\n"},{"id":59,"href":"/chapter-4/go-code-rules/","title":"4.18 قوانین کدنویسی در گو","section":"فصل چهارم: مباحث پیشرفته","content":"قوانین کدنویسی در گو\u0026hellip;\n"},{"id":60,"href":"/chapter-4/go-garbage-collector/","title":"4.19 زباله جمع کن (garbage collector)","section":"فصل چهارم: مباحث پیشرفته","content":"زباله جمع کن (garbage collector)\u0026hellip;\n"},{"id":61,"href":"/chapter-4/oop/","title":"4.20 شی گرایی در زبان گو","section":"فصل چهارم: مباحث پیشرفته","content":"الگوهای طراحی ساختاری\u0026hellip;\n"},{"id":62,"href":"/chapter-4/oop/go-inhertance/","title":"4.20.1 ارث بری","section":"4.20 شی گرایی در زبان گو","content":"ارث بری\n"},{"id":63,"href":"/chapter-4/oop/go-encapsulation/","title":"4.20.2 کپسوله سازی (Encapsulation)","section":"4.20 شی گرایی در زبان گو","content":"کپسوله سازیdenotes\n"},{"id":64,"href":"/chapter-4/oop/go-polymorphism/","title":"4.20.3 پلی مورفیسم (Polymorphism)","section":"4.20 شی گرایی در زبان گو","content":"پلی مورفیسم\n"},{"id":65,"href":"/chapter-5/","title":"فصل پنجم: برنامه نویسی شبکه با گو","section":"صفحه اصلی","content":"در این فصل به مباحث برنامه نویسی شبکه در زبان گو میپردازیم\u0026hellip;\n"},{"id":66,"href":"/chapter-5/go-http-server-begginer/","title":"5.1 کتابخانه http سمت سرور مقدماتی","section":"فصل پنجم: برنامه نویسی شبکه با گو","content":"آموزش کتابخانه http سمت سرور مقدماتی\u0026hellip;\n"},{"id":67,"href":"/chapter-5/go-http-server-advanced/","title":"5.2 کتابخانه http سمت سرور پیشرفته","section":"فصل پنجم: برنامه نویسی شبکه با گو","content":"آموزش کتابخانه http سمت سرور پیشرفته\u0026hellip;\n"},{"id":68,"href":"/chapter-5/go-http-client-begginer/","title":"5.3 کتابخانه http سمت کلاینت مقدماتی","section":"فصل پنجم: برنامه نویسی شبکه با گو","content":"آموزش کتابخانه http سمت کلاینت مقدماتی\u0026hellip;\n"},{"id":69,"href":"/chapter-5/go-http-client-advanced/","title":"5.4 کتابخانه http سمت کلاینت پیشرفته","section":"فصل پنجم: برنامه نویسی شبکه با گو","content":"آموزش کتابخانه http سمت کلاینت پیشرفته\u0026hellip;\n"},{"id":70,"href":"/chapter-6/","title":"فصل ششم: جنریک (Generics)","section":"صفحه اصلی","content":"در این فصل به مباحث جنریک در زبان گو میپردازیم\u0026hellip;\n"},{"id":71,"href":"/chapter-7/","title":"فصل هفتم: تست نویسی","section":"صفحه اصلی","content":"در این فصل به مباحث تست نویسی در زبان گو میپردازیم\u0026hellip;\n"},{"id":72,"href":"/chapter-8/","title":"فصل هشتم: پکیج های استاندارد","section":"صفحه اصلی","content":"در این فصل به مباحث پکیج های استاندارد در زبان گو میپردازیم\u0026hellip;\n"},{"id":73,"href":"/chapter-9/","title":"فصل نهم: الگوهای طراحی","section":"صفحه اصلی","content":"در این فصل به مباحث الگوهای طراحی در زبان گو میپردازیم\u0026hellip;\n"},{"id":74,"href":"/chapter-9/creational-patterns/","title":"9.1 الگوهای طراحی سازنده","section":"فصل نهم: الگوهای طراحی","content":"الگوهای طراحی سازنده\u0026hellip;\n"},{"id":75,"href":"/chapter-9/structural-patterns/","title":"9.2 الگوهای طراحی ساختاری","section":"فصل نهم: الگوهای طراحی","content":"الگوهای طراحی ساختاری\u0026hellip;\n"},{"id":76,"href":"/chapter-9/behavioral-patterns/","title":"9.3 الگوهای طراحی رفتاری","section":"فصل نهم: الگوهای طراحی","content":"الگوهای طراحی رفتاری\u0026hellip;\n"},{"id":77,"href":"/chapter-10/","title":"فصل دهم: الگوریتم و ساختار داده","section":"صفحه اصلی","content":"در این فصل به مباحث الگوریتم و ساختار داده در زبان گو میپردازیم\u0026hellip;\n"},{"id":78,"href":"/chapter-11/","title":"فصل یازدهم: معماری های نرم افزار","section":"صفحه اصلی","content":"در این فصل به مباحث معماری های نرم افزار در زبان گو میپردازیم\u0026hellip;\n"},{"id":79,"href":"/chapter-9/creational-patterns/go-singleton-pattern/","title":"9.1.1 الگو Singleton","section":"9.1 الگوهای طراحی سازنده","content":"الگو Singleton\u0026hellip;\n"},{"id":80,"href":"/chapter-9/creational-patterns/go-factory-method-pattern/","title":"9.1.2 الگو Factory Method","section":"9.1 الگوهای طراحی سازنده","content":"الگو Factory Method\u0026hellip;\n"},{"id":81,"href":"/chapter-9/creational-patterns/go-prototype-pattern/","title":"9.1.3 الگو Prototype","section":"9.1 الگوهای طراحی سازنده","content":"الگو Prototype\u0026hellip;\n"},{"id":82,"href":"/chapter-9/creational-patterns/go-abstract-factory-pattern/","title":"9.1.4 الگو Abstract Factory","section":"9.1 الگوهای طراحی سازنده","content":"الگو Abstract Factory\u0026hellip;\n"},{"id":83,"href":"/chapter-9/creational-patterns/go-builder-pattern/","title":"9.1.6 الگو Builder","section":"9.1 الگوهای طراحی سازنده","content":"الگو Builder\u0026hellip;\n"},{"id":84,"href":"/chapter-9/creational-patterns/go-object-pool-pattern/","title":"9.1.7 الگو Object Pool","section":"9.1 الگوهای طراحی سازنده","content":"الگو Object Pool\u0026hellip;\n"},{"id":85,"href":"/chapter-9/structural-patterns/go-adaptor-pattern/","title":"9.2.1 الگو Adaptor","section":"9.2 الگوهای طراحی ساختاری","content":"الگو Adaptor\u0026hellip;\n"},{"id":86,"href":"/chapter-9/structural-patterns/go-bridge-pattern/","title":"9.2.2 الگو Bridge","section":"9.2 الگوهای طراحی ساختاری","content":"الگو Bridge\u0026hellip;\n"},{"id":87,"href":"/chapter-9/structural-patterns/go-composite-pattern/","title":"9.2.3 الگو Composite","section":"9.2 الگوهای طراحی ساختاری","content":"الگو Composite\u0026hellip;\n"},{"id":88,"href":"/chapter-9/structural-patterns/go-decorator-pattern/","title":"9.2.1 الگو Decorator","section":"9.2 الگوهای طراحی ساختاری","content":"الگو Decorator\u0026hellip;\n"},{"id":89,"href":"/chapter-9/structural-patterns/go-facade-pattern/","title":"9.2.5 الگو Facade","section":"9.2 الگوهای طراحی ساختاری","content":"الگو Facade\u0026hellip;\n"},{"id":90,"href":"/chapter-9/structural-patterns/go-flyweight-pattern/","title":"9.2.6 الگو Flyweight","section":"9.2 الگوهای طراحی ساختاری","content":"الگو Flyweight\u0026hellip;\n"},{"id":91,"href":"/chapter-9/structural-patterns/go-proxy-pattern/","title":"9.2.7 الگو Proxy","section":"9.2 الگوهای طراحی ساختاری","content":"الگو Proxy\u0026hellip;\n"},{"id":92,"href":"/chapter-9/behavioral-patterns/go-chain-of-responsibility-pattern/","title":"5.3.1 الگو Chain Of Responsibility","section":"9.3 الگوهای طراحی رفتاری","content":"الگو Chain Of Responsibility\u0026hellip;\n"},{"id":93,"href":"/chapter-9/behavioral-patterns/go-command-pattern/","title":"9.3.2 الگو Command","section":"9.3 الگوهای طراحی رفتاری","content":"الگو Command\u0026hellip;\n"},{"id":94,"href":"/chapter-9/behavioral-patterns/go-iterator-pattern/","title":"9.3.3 الگو Iterator","section":"9.3 الگوهای طراحی رفتاری","content":"الگو Iterator\u0026hellip;\n"},{"id":95,"href":"/chapter-9/behavioral-patterns/go-mediator-pattern/","title":"9.3.4 الگو Mediator","section":"9.3 الگوهای طراحی رفتاری","content":"الگو Mediator\u0026hellip;\n"},{"id":96,"href":"/chapter-9/behavioral-patterns/go-memento-pattern/","title":"9.3.5 الگو Memento","section":"9.3 الگوهای طراحی رفتاری","content":"الگو Memento\u0026hellip;\n"},{"id":97,"href":"/chapter-9/behavioral-patterns/go-observer-pattern/","title":"9.3.6 الگو Observer","section":"9.3 الگوهای طراحی رفتاری","content":"الگو Observer\u0026hellip;\n"},{"id":98,"href":"/chapter-9/behavioral-patterns/go-state-pattern/","title":"9.3.7 الگو State","section":"9.3 الگوهای طراحی رفتاری","content":"الگو State\u0026hellip;\n"},{"id":99,"href":"/chapter-9/behavioral-patterns/go-strategy-pattern/","title":"9.3.8 الگو Strategy","section":"9.3 الگوهای طراحی رفتاری","content":"الگو Strategy\u0026hellip;\n"},{"id":100,"href":"/chapter-9/behavioral-patterns/go-template-method-pattern/","title":"9.3.9 الگو Template Method","section":"9.3 الگوهای طراحی رفتاری","content":"الگو Template Method\u0026hellip;\n"},{"id":101,"href":"/chapter-9/behavioral-patterns/go-visitor-pattern/","title":"9.3.10 الگو Visitor","section":"9.3 الگوهای طراحی رفتاری","content":"الگو Visitor\u0026hellip;\n"}]