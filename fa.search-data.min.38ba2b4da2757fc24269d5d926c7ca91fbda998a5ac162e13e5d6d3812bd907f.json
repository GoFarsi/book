[{"id":0,"href":"/preface/","title":"پیشگفتار","section":"صفحه اصلی","content":" چرا از گو استفاده می‌کنیم؟\nوقتی در نوامبر سال ۲۰۰۹ رابرت گریسیمر، راب پایک و کن تامپسون برای اولین‌بار گو را بصورت عمومی انتشار دادند، خودشان مطمئن نبودند که به‌صورت گسترده مورد استفاده قرار می‌گیرد یا خیر. تا به تاریخ انتشار این مطلب، مشخص شده،‌گو بسیار فراگیرتر و رشد آن در صنعت وسیع‌تر از چیزی بوده‌است که ایجادکنندگان آن حدس می‌زدند. این‌ها نمونه‌هایی از کاربرد گو در دنیای امروز تکنولوژی هستند:\nGoogle’s Core Data Solutions Team Uses Go تیم راهکار هسته‌ی داده گوگل از گو استفاده می‌کند Chrome Content Optimization Service Runs on Go سرویس بهینه‌سازی محتوا در گوگل‌کروم توسط گو در حال اجراست Chrome’s user experience strategy, operating in the critical path for users is implemented in Go استراتژی حیاتی تجربه کاربری در کروم توسط گو پیاده‌سازی شده است Firebase Hosting Team Scaled With Go ابزار قدرتمند فایربیس توسط گو گسترش یافته است همچنین در صفحه رسمی گو می‌توانید لیستی از شرکت‌ها از Netflix و PayPal تا Uber و Microsoft رو به‌همراه خدماتی که از گو گرفته‌اند رو ملاحظه کنید. https://go.dev/solutions/#case-studies شناخت نیازمندی و ابزارهای پیاده‌سازی وابسته به آن.\nCloud \u0026amp; Network Services Command-line Interfaces Web Development DevOps \u0026amp; Site Reliability انواع منابع موجود جهت کسب اطلاعات و مقایسه‌ی آن‌ها.\nمنابع مکتوب. سایت رسمی زبان گو. https://go.dev در نسخه حال‌حاضر وب‌سایت رسمی گو، مستندات لازم برای شناخت انواع جزئیات وجود دارد. ضمن‌اینکه یک خودآموز مختصر، جهت آشنایی ابتدایی مفاهیم را می‌توانید پیدا کنید. کتاب‌ها. اصولاً استفاده از کتاب‌ها بدلیل اینکه عمدتاً توسط اساتید، متخصصین شناخته‌شده نگارش می‌شود، توصیه می‌گردد. ضمن اینکه کتاب‌ها معمولاً امکان اصلاحات مستمر و انتشار نسخه‌های جدید و به‌روزتر رو دارا هستند و توسط ناشران معتبر منتشر می‌شوند. مقالات. بدلیل راحت‌تر بودن نشر مقالات، طبیعتاً امکان وجود هرنوع مطلبی با هر سطح و کیفیتی از محتوا وجود دارد. بنابراین، در استفاده از این نوع منابع، احتیاط و حساسیت بالاتری مورد نیاز است. منابع صوتی و تصویری. مزیت بزرگ این نوع از منابع، سرعت و امکانات کافی در انتقال مطلب است. اما اشکالی که وجود دارد عدم امکان ساده‌ی اصلاح محتوا و به‌روزرسانی آن است. ضمن‌اینکه این نوع از منابع، مانند مقالات توسط افراد مختلف و با طیفی از انواع کیفیت‌های متفاوت، وجود دارد. بررسی وضعیت منابع فارسی زبان گو در زمان تهیه این کتاب. درحال‌حاضر منابع نگارشی با کیفیت مناسب به‌زبان فارسی بسیار محدود است. این یکی از دلایل «چرایی» نگارش این کتاب به‌زبان فارسی است. ما امیدواریم با مشارکت همه اساتید و متخصصین این حوزه، این کتاب منبع آموزشی باکیفیت، دردسترس عموم متقاضیان، جهت توسعه ابزارهای حرفه‌ای با زبان گو باشد.\nچرا به زبان فارسی می‌نویسیم. دوستان و همکاران بسیاری هستند،‌که این سوال را مطرح می‌کنند که وقتی نیاز به دانش زبان انگلیسی، برای کسب مهارت در این تخصص، یک «باید» محسوب می‌شود، چرا مطلب فارسی؟ جواب این سوال ساده‌تر از پیچیدگی‌هایی هست که بنظر می‌رسد: − ایجاد و رونق جامعه تخصصی فارسی‌زبان توسط موضوع «کتاب» − ایجاد فضایی جهت ایجاد پرسش و پاسخ فارسی‌زبان‌ها − ارائه یک ترجمه فارسی، از منابع اصلی تخصصی، با امکان مقایسه برداشت افراد مختلف از زبان تخصصی − سرعت دادن به یادگیری، حداقل در مفاهیم ابتدایی − برای نوجوانان و افرادی که به‌هر دلیل، درحال‌حاضر تسلط کافی روی زبان انگلیسی ندارند و ارائه راهکار جهت تمرین و شروع یادگیری منابع روی زبان تخصصی\nبرای چگونگی نگارش کتاب می‌توان به موارد زیر اشاره کرد:\nچگونه از جامعه تخصصی، می‌توان در آموزش،بهینه‌سازی و رشد دانش متقاضیان این تخصص استفاده کرد. یکی از وظایف هر استاد، تربیت «شاگرد» و توسعه دانش است. افراد تازه‌کار با دانش و تجربه پیشکسوتان، با سرعت و کیفیت بالاتر، تبدیل به متخصصین جدید خواهند شد. کیفیت جامعه متخصصین، امکان کنترل مصرف منابع و تولید ابزارهای مفید را تعیین خواهد کرد. کار تیمی، به فرهنگ «با هم کار کردن» نیازمند است.\nچرخ را از نو نسازیم، تجربه‌ها را از نو «تجربه» نکنیم، آموزش ببینیم و آموزش بدهیم. با کمی دقت و تجربه، کاملاً بدیهی‌ست در مقام قیاس بین چند جامعه تخصصی همسان، برتری از آن کسانی‌ست که در انتقال دانش-تجربه دست‌و‌دل‌بازتر هستند. جامعه تخصصی با دانش و تجربه عمیق، نیازمند وجود «مبتدیان» با پتانسیل حداکثری است و این میسر نیست مگر با جریان ساده و پایدار آموزش. دانش امروز، در هر رشته و هر سطح برآیند «انتقال» پیشینیان ما است. به جای غرور ناشی از آن می‌توان از انتقال آن به دیگران لذت برد.\n«کلمات» قدرت دارند. به درک و استفاده از کلمات احترام بگذاریم. در جامعه تخصصی حتی چند‌برابر !!! تا جای ممکن، در استفاده از کلمات تخصصی در محل درست خود دقت شده تا مفهوم نادرست منتقل نشود. از شما خواننده عزیز هم تقاضا داریم، هرکجا ایرادی هرچند کوچک ملاحظه فرمودید، به ما اطلاع دهید یا درخواست اصلاح آن را ارسال کنید.\n"},{"id":1,"href":"/history/","title":"تاریخچه","section":"صفحه اصلی","content":"زبان گو (Go) در سال ۲۰۰۷ (به شمسی: ۱۳۸۶) توسط «شرکت گوگل» با هدف افزایش بهره‌وری برنامه‌نویسی در محیط چندهسته‌ای، رایانه‌های شبکه‌ای و کدبیس‌های بزرگ طراحی شد [به نقل از ویکی‌پدیا] و سپس به عنوان یک زبان کامپایلری و تایپ استاتیک در نوامبر سال ۲۰۰۹ به‌صورت عمومی با هدف کامپایل کارآمد ، اجرای کارآمد و سهولت برنامه‌نویسی عرضه شد. بسیاری از اعضای تیم طراحی و توسعه زبان گو [Ken Thompson, Rob Pike, Robert Griesemer] سال‌ها تجربه در زمینه تحقیق و توسعه زبان برنامه‌نویسی دارند.\nتاریخچه زبان گولنگ به سال ۲۰۰۷ میلادی برمیگردد.وقتی که سه برنامه‌نویس تصمیم گرفتند یک زبان برنامه‌نویسی جدید با ترکیبی از ویژگی‌های مختلف را توسعه دهند. هدف آنها این بود که زبانی سریع، ساده، قابل استفاده و مؤثر برای توسعه نرم‌افزارهای همزمان و مقیاس‌پذیر بسازند.\nگولنگ از زبان‌هایی چون pascal، c و oberon الهام گرفته است. هدف توسعه دهندگان گولنگ ساده‌تر کردن فرایند طراحی و ساخت نرم افزارهای مقایس‌پذیر بوده. آن‌ها در طراحی گولنگ تلاش کردند تا عملکرد زبان را بهبود بخشند و یک سینتکس ساده و خوانا ارائه دهند.\nاز آن زمان تا به امروز، گولنگ رشد و پیشرفت چشمگیری کرده است و استفاده از آن در صنعت نرم‌افزار روز به روز بیشتر می‌شود. شرکت‌های بزرگی مانند Google، Dropbox، YouTube و Docker از گولنگ به عنوان یکی از زبان‌های اصلی خود استفاده می‌کنند. همچنین جامعه برنامه‌نویسی گولنگ به طور فزاینده‌ای در حال رشد است و ابزارها و کتابخانه‌های زیادی با استقاده از گولنگ توسعه داده شده است.\nزبان گو دارای یک سری ویژگی‌های منحصر به فرد می‌باشد و برخی از ویژگی‌هایش از سایر زبان‌ها الهام گرفته شده است :\nپشتیبانی از برنامه‌نویسی همزمانی بصورت Built-in گوروتین ‌ها امکان اجرای همزمانی توابع را فراهم می‌کنند و همچنین گوروتین‌ها واقعا خیلی سبک هستند به طوری که شما می‌توانید هزاران گوروتین را همزمان در سخت افزارهای مدرن بدون هیچ مشکل عملکردی اجرا کنید. سایز اولیه یک گروتین بین 2 تا 3 کیلوبایت است، در صورتی که سایز اولیه یک ترد معمولا از 1 تا 2 مگابایت شروع می شود. این حافظه از استک تخصیص داده می شود. کانال ‌ها برپایه مدل CSP می‌باشد که امکان همگام سازی داده‌ها بین گوروتین‌ها را فراهم می‌کند. پشتیبانی از تایپ‌های map و slice امکان پیاده سازی پلی مورفیسم با استفاده از اینترفیس ‌ها پوینترها کلوژر توابع (یک تابع معمولی که داخل یک تابع دیگر به عنوان بازگشت تعریف می‌شود) متدها امکان defer برای تعویق فراخوانی یک تابع قابلیت جاسازی تایپ‌ها ایمنی حافظه در زبان گو قابلیت زباله جمع کن خودکار سازگاری کامل با انواع پلتفرم‌ها نظیر [linux, windows, mac, AIX, android, freeBSD] جهت توسعه و کامپایل امکان Cross-compile با این امکان می‌توانید در هر پلتفرمی برای سایر پلتفرم‌ها کامپایل کنید پشتیبانی از جنریک یا تایپ پارامتر (از نسخه ۱.۱۸) تست نویسی آسان اینترفیس و رفلکشن زبان گو برخلاف زبان‌هایی نظیر c, cpp یا java نیاز به نقطه ویرگول (Semicolons) ندارد و به نسبت زبان‌هایی که معرفی کردیم پرانتز کمتری استفاده می‌کند و همچنین ظاهر سینتکس گو خیلی خواناتر و راحت‌تر می‌باشد. علاوه بر ویژگی‌هایی که در بالا معرفی کردیم یک سری نکات برجسته در خصوص زبان گو وجود دارد که به شرح زیر می‌باشند:\nسینتکس این زبان به گونه‌ای ساده و تمیز طراحی شده که فرآیند یادگیری آن را آسان‌تر می‌کند و از همه مهم‌تر توسعه پروژه‌های مقیاس‌پذیر با زبان گو به دلیل سادگی و آشکار بودن مفاهیم خیلی سریع‌تر صورت می‌گیرد.\nزبان گو دارای تعداد زیادی پکیج‌های استاندارد و کاربردی جهت توسعه می‌باشد که همه این پکیج‌ها در انواع پلتفرم‌ها جهت توسعه قابل استفاده است.\nزبان گو دارای یک جامعه بزرگ از توسعه دهندگان و انجمن‌های فعال می‌باشد که خیلی سریع می‌توانید به پاسخ سوالات خود برسید.\nبرنامه نویس‌های زبان گو را گوفر صدا می‌زنند. گوفر نام یک نوع موش و همچنین نماد گولنگ است. "},{"id":2,"href":"/why-go/","title":"چرا زبان Go؟","section":"صفحه اصلی","content":"زبان Go (یا Golang) با تأکید بر سادگی سینتکسی، سرعت بالا، و پشتیبانی قوی از همزمانی، گزینه‌ای بی‌نظیر برای توسعه‌دهندگان و تیم‌های مهندسی نرم‌افزار به‌شمار می‌آید. Go با بهره‌گیری از کامپایل سریع و استاتیک، اجرای باینری‌های مستقل با سرعتی نزدیک به زبان‌های سطح پایین را ممکن می‌سازد. یکی از برجسته‌ترین قابلیت‌های آن، مدل درون‌ساختاری همزمانی مبتنی بر goroutine و channel است که پردازش موازی با مصرف حافظه بهینه را تسهیل می‌کند. علاوه بر این، وجود جمع‌آوری خودکار حافظه (GC) و مجموعه ابزار استاندارد (از جمله go fmt، go test، go doc و…) روند توسعه را شفاف و قابل‌پیش‌بینی می‌کند. با پشتوانه رسمی گوگل و پذیرش گسترده در پروژه‌های ابری، زیرساخت‌ها و شرکت‌های مطرح (مثل Docker، Kubernetes، Uber)، Go به ابزاری کلیدی در اکوسیستم مدرن توسعه نرم‌افزار تبدیل شده است.\n🎯 ۱. سادگی و خوانایی دقیق در طراحی زبان # Go برای افرادی طراحی شده که به دنبال زبانی با سینتکسی ساده و بدون پیچیدگی‌های مرسوم هستند. نحو آن الهام‌گرفته از خانواده C است اما خبری از ساختارهای پیچیده‌ای مثل «وراثت کلاسیک» نیست.\nاین سادگی کمک می‌کند توسعه‌دهنده بتواند زبان را در عرض یک روز یاد بگیرد و سریع وارد برنامه‌نویسی واقعی شود (Applied Go). ابزار یکپارچه go fmt استانداردسازی کد را تضمین می‌کند و باعث می‌شود تیم‌ها همیشه بر روی قالب یکسانی کد بزنند (Sariasan, Wikipedia).\n⚡ ۲. سرعت در کامپایل و اجرا # Go یک زبان کامپایل‌شده و دارای تایپ استاتیک است—کد مستقیم به باینری اجراشده تبدیل می‌شود، بدون وابستگی به ماشین مجازی. نتیجه: سرعت فوق‌العاده در زمان اجرا. در واقع، گوگل با طراحی Go توانست هزاران خط کد را در کمتر از ۱۰ ثانیه کامپایل کند (WIRED). ♾️ ۳. همزمانی قدرتمند با Goroutines و Channels # Go با goroutine‌ها (ریسمان‌های سبُک‌وزن) و channelهایی برای ارتباط امن بین آنها، همزمانی را در سطح زبان نهادینه کرده (Faradars Blog). این ساختار، اجرای میلیون‌ها goroutine را با استفاده‌ی بسیار کمتر از حافظه امکان‌پذیر می‌سازد — برخلاف thread‌های سنگین جاوا — که مناسب سرویس‌های مقیاس‌پذیر و پرکار است (uptech.team, Sariasan). فلسفه Go در همزمانی این است: «با ارتباط بین حافظه به اشتراک‌گذاری انجام می‌شود، نه با اشتراک‌گذاری حافظه» (Sariasan). 🧠 ۴. مدیریت حافظه خودکار (Garbage Collection) # Go مجهز به سیستم جمع‌آوری زباله (GC) داخلی است که حافظه را به‌صورت خودکار آزاد می‌کند. این موضوع باعث افزایش بهره‌وری و کاهش پیچیدگی برای توسعه‌دهندگان می‌شود، بدون کاهش محسوس کارایی (مبین هاست). 📚 ۵. کتابخانه استاندارد کامل و ابزارهای توسعه # زبان Go همراه با مجموعه استاندارد بزرگی از کتابخانه‌های داخلی برای مواردی مانند تست، قالب‌سازی، همگام‌سازی و مدیریت بسته است (Quera). ابزارهایی مانند go build, go test, go vet, go doc و پروفایل‌سازی/debugging داخلی، محیطی حرفه‌ای برای تمام سطوح توسعه را فراهم می‌کنند (Wikipedia). 🏢 ۶. پشتوانه گوگل و اکوسیستم بالغ # Go در ۲۰۰۷ توسط راب گرایسمر، راب پایک و کن تامپسون در گوگل طراحی شد و در سال ۲۰۱۲ به نسخه ۱.۰ رسید. گوگل هنوز از آن در زیرساخت‌های بزرگ خود بهره می‌برد (JobVision). اکوسیستم متنوعی از شرکت‌های بزرگ مثل Docker، Kubernetes، Uber، Dropbox، Netflix و … از Go استفاده می‌کنند (mytaskpanel.com). 🧩 ۷. مقیاس‌پذیری طبیعی برای زیرساخت‌ها و کلاد نیتیو # طراحی نیتیو Go برای شبکه، موازی‌سازی، پردازش سرویس باعث شده گزینه‌ای بسیار مناسب برای توسعه برنامه‌های میکروسرویس، ابزارهای DevOps و سرویس‌های ابری باشد (مبین هاست, Sariasan, Wikipedia). پروژه‌های بزرگی مانند Docker و Kubernetes کاملًا با Go نوشته شده‌اند، که نشانه پختگی زبان در حوزه زیرساخت است (مبین هاست, Sariasan). 📚 منابع پیشنهادی: # مقاله فارسی «مهم‌ترین مزایای زبان برنامه‌نویسی گولنگ چیست؟» در ویرگول (Sariasan, Wikipedia, نیک آموز, JobVision, Quera) بررسی جامع ابزارها و فلسفه همزمانی در ویکی‌پدیا Go (Wikipedia) مقاله evaluate‌شده در Medium درباره سادگی و مدیریت حافظه (medium.com) پست رسمی گوگل در Wired (2009) درباره معرفی Go و ویژگی‌های کلیدی (WIRED) "},{"id":3,"href":"/installation/","title":"آموزش نصب","section":"صفحه اصلی","content":"جهت نصب زبان گو بر روی سیستم عامل مورد نظر خود در ابتدا باید نسخه مناسب با پلت‌فرم خود را دانلود کنید.\nنکته:\nوب سایت گولنگ ایران را تحریم کرده است و احتمالا برای دانلود کردن گولنگ با مشکل مواجه می شوید. برای اینکه بتوانید تحریم ها را دور بزنید، روش های زیادی وجود دارد. یکی از مرسوم ترین روش ها استفاده از یک سرویس دی ان اس مانند شکن است.\nلینوکس در اینجا نسخه مرتبط با لینوکس خود را دانلود کنید. 1$ wget -c https://go.dev/dl/go1.xx.x.linux-amd64.tar.gz سپس دستور زیر را بزنید تا اگر نسخه قبلی وجود دارد پاک شود و نسخه جدید در مسیر usr/local/go/ جایگزین شود. 1$ sudo rm -rf /usr/local/go \u0026amp;\u0026amp; sudo tar -C /usr/local -xzf go1.xx.x.linux-amd64.tar.gz افزودن مسیر usr/local/go/bin/ به متغیرهای محیطی 1export PATH=$PATH:/usr/local/go/bin بهتر است برای اینکه هر بار ترمینال را باز می‌کنید و فایل go توسط shell شناخته شود دستور فوق را به فایل home/{user}/.profile/ اضافه کنید. جهت اطمینان از اینکه زبان گو به‌درستی بر روی سیستم عامل شما نصب شده است دستور زیر را داخل ترمینال بزنید. 1$ go version ویندوز روش اول # در اینجا نسخه مرتبط با ویندوز خود را دانلود کنید. سپس فایل go1.xx.x.windows-{arch}.msi را اجرا کنید. مراحل نصب را به‌صورت پیش فرض طی کنید تا زبان گو برروی ویندوز نصب شود. پس از نصب، جهت اطمینان از نصب بودن زبان گو، مراحل زیر را انجام دهید: وارد منو استارت شوید. در منو استارت کلمه cmd را جستجو کنید و سپس آن را اجرا کنید. داخل خط فرمان دستور زیر را بزنید تا از نصب بودن زبان گو اطمینان حاصل فرمایید. 1go version روش دوم # برای نصب گو می‌توانید از Chocolatey Package Manager استفاده کنید.\nخط فرمان PowerShell را به صورت Administrator باز کنید و دستور زیر را داخل PowerShell بزنید. 1Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString(\u0026#39;https://community.chocolatey.org/install.ps1\u0026#39;)) بعد از نصب می‌توانید از دستور choco برای نصب گو استفاده کنید. 1choco install golang جهت اطمینان از اینکه زبان گو به‌درستی بر روی سیستم عامل شما نصب شده است دستور زیر را داخل ترمینال بزنید. 1$ go version دقت داشته باشید برای نصب برنامه‌های مختلف مثل git و یا ابزارهای دیگر در محیط Administrator باید از دستور choco استفاده کنید. مکینتاش روش اول # در اینجا نسخه مرتبط با مکینتاش خود را دانلود کنید. سپس فایل go1.xx.x.darwin-{arch}.pkg را اجرا کنید. مراحل نصب را به‌صورت پیش فرض طی کنید تا زبان گو برروی مکینتاش نصب شود. پس از نصب اگر ترمینال باز بود آن را کامل ببندید تا تغییرات صورت گیرد. جهت اطمینان از اینکه زبان گو به‌درستی بر روی سیستم عامل شما نصب شده است دستور زیر را داخل ترمینال بزنید. 1$ go version روش دوم # برای نصب گو میتوانید از Homebrew Package Manager استفاده کنید.\nبرای نصب brew می‌توانید ترمینال خود را باز کنید و از دستور زیر استفاده کنید. 1$ /bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026#34; بعد از نصب brew از دستور زیر برای نصب گو داخل ترمینال استفاده کنید. 1$ brew update \u0026amp;\u0026amp; brew install golang جهت اطمینان از اینکه زبان گو به‌درستی بر روی سیستم عامل شما نصب شده است، دستور زیر را داخل ترمینال بزنید. 1$ go version "},{"id":4,"href":"/toolchain/","title":"ابزارها, دستورات گو و معرفی IDE","section":"صفحه اصلی","content":"پس از اینکه زبان گو را برروی سیستم خود نصب کردید از طریق ترمینال و یا خط فرمان ویندوز قابل دسترس است که می‌توانید با زدن کلمه go یکسری عملیات انجام دهید:\n1$ go 2Go is a tool for managing Go source code. 3 4Usage: 5 6\tgo \u0026lt;command\u0026gt; [arguments] 7 8The commands are: 9 10\tbug start a bug report 11\tbuild compile packages and dependencies 12\tclean remove object files and cached files 13\tdoc show documentation for package or symbol 14\tenv print Go environment information 15\tfix update packages to use new APIs 16\tfmt gofmt (reformat) package sources 17\tgenerate generate Go files by processing source 18\tget add dependencies to current module and install them 19\tinstall compile and install packages and dependencies 20\tlist list packages or modules 21\tmod module maintenance 22\twork workspace maintenance 23\trun compile and run Go program 24\ttest test packages 25\ttool run specified go tool 26\tversion print Go version 27\tvet report likely mistakes in packages 28 29Use \u0026#34;go help \u0026lt;command\u0026gt;\u0026#34; for more information about a command. 30 31Additional help topics: 32 33\tbuildconstraint build constraints 34\tbuildmode build modes 35\tc calling between Go and C 36\tcache build and test caching 37\tenvironment environment variables 38\tfiletype file types 39\tgo.mod the go.mod file 40\tgopath GOPATH environment variable 41\tgopath-get legacy GOPATH go get 42\tgoproxy module proxy protocol 43\timportpath import path syntax 44\tmodules modules, module versions, and more 45\tmodule-get module-aware go get 46\tmodule-auth module authentication using go.sum 47\tpackages package lists and patterns 48\tprivate configuration for downloading non-public code 49\ttestflag testing flags 50\ttestfunc testing functions 51\tvcs controlling version control with GOVCS 52 53Use \u0026#34;go help \u0026lt;topic\u0026gt;\u0026#34; for more information about that topic. جدول دستورات (Commands) # دستور توضیحات build با این دستور (go build main.go) می‌توانید فایل go را کامپایل کنید. clean با این دستور می‌توانید فایل‌های کش‌شده را پاکسازی کنید. doc با این دستور (go doc fmt.Println) می‌توانید داکیومنت هر یک از توابع عمومی را ببینید. env با این دستور می‌توانید متغیرهای محیطی تنظیم شده زبان گو را ببینید و آن‌ها را با دستور go env -w key=value مقداردهی کنید. fmt با این دستور می‌توانید کدهای خود را مرتب go fmt ./... کنید. install با استفاده از این دستور می‌توانید یکسری پکیج‌ها را گرفته و کامپایل کنید. list لیست پکیج‌ها و ماژول‌های دانلود شده. generate با این دستور می‌توانید از قابلیت Generator زبان گو استفاده کنید و فایل generate کنید. mod برای مدیریت و ایجاد فایل mod به ازای هر پروژه. get با این دستور می‌توانید پکیجی را دانلود یا بروزرسانی کنید و همچنین برای استفاده از این دستور نیاز به git دارید که نصب باشد. work با این دستور می‌توانید یک workspace ایجاد کنید و آن را مدیریت کنید. run با این دستور (go run main.go) می‌توانید فایل‌های گو یا پروژه را اجرا کنید. test با این دستور (go test example_test.go) می‌توانید فایل‌های تست را اجرا کنید. version با این دستور می‌توانید نسخه نصب شده زبان گو را ببینید. vet با این دستور می‌توانید اشتباهات کدهای خود را ببینید. اجرای کد ساده در زبان گو # در زیر یک نمونه کد ساده قرار دادیم که به سادگی می‌توانید با دستور go run main.go اجرا کنید و خروجی را ببینید.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 fmt.Println(\u0026#34;Hello world!!!\u0026#34;) 7} 1$ go run main.go 2Hello world!!! در کد فوق، ما یکسری کلید واژه نظیر package , import , func استفاده کردیم که در بخش 1.2 کلید واژه و شناسه‌ها با آن‌ها آشنا می‌شوید.\nانواع نرم‌افزارهای محیط توسعه (IDE) و ویرایشگر کد (Code Editor) # در زبان برنامه‌نویسی گو نیز مثل سایر زبان‌ها، می‌توان از ابزارهای کدنویسی مانند نرم‌افزارهای محیط توسعه و همچنین از ویرایشگرهای کد استفاده کرد که محبوب‌ترین‌ها معرفی می‌شوند:\nنرم‌افزار Jetbrains Goland اگر با سایر محصولات جت‌برینز آشنا باشید به‌راحتی می‌توانید از این نرم‌افزار محیط توسعه استفاده کنید. نرم‌افزار VsCode تقریباً همه برنامه‌نویس‌ها با آن آشنا هستند. یک ویرایشگر کد متن‌باز می‌باشد که بین برنامه‌نویس‌ها خیلی محبوب است و برای استفاده زبان گو در این نرم‌افزار می‌توان افزونه vscode-go را نصب کنید. نرم‌افزار Vim یک نرم‌افزار متن‌باز و معروف می‌باشد که داخل ترمینال قابل استفاده است و از آن می‌توانید جهت توسعه با زبان گو استفاده کنید و البته نیازمند نصب پلاگین می‌باشد. "},{"id":5,"href":"/roadmap/","title":"نقشه یادگیری زبان گو","section":"صفحه اصلی","content":"نقشه یادگیری زیر roadmap.sh به ترتیب مسیر توصیه شده ی یادگیری ابزارها و مفاهیم اولیه گو، سپس سمت سرور و در نهایت معماری نرم افزار را نشان می‌دهد.\n"},{"id":6,"href":"/interview/","title":"نمونه سوالات مصاحبه","section":"صفحه اصلی","content":"در این بخش ما یکسری سوالات مصاحبه به زبان فارسی ارائه دادیم که برای یافتن ضعف‌ها کاربردی می‌باشد.\n1: چه تایپ‌هایی مقدار zero آن‌ها nil است؟ interfaces slices channels maps pointers functions 2: تایپ‌های نوع Reference؟ Pointers slices maps functions channels 3: تایپ‌های نوع Aggregate؟ Array structs 4: چه وقت باید از پوینتر استفاده کنیم؟ 1- تابعی که یکی از پارامترهای خود را تغییر می‌دهد\n-وقتی تابعی را فراخوانی می‌کنیم که یک پوینتر را به عنوان پارامتر می‌گیرد، انتظار داریم که متغیر ما تغییر داده شود. اگر شما متغیر را در تابع خود تغییر نمی‌دهید، پس احتمالا نباید از پوینتر استفاده کنید.\n2- عملکرد بهتر\n-اگر رشته‌ای داشته باشید که شامل یک رمان کامل در حافظه باشد، کپی کردن این متغیر هر بار که به یک تابع جدید ارسال می‌شود، کاری بسیار گران است. ممکن است ارزشمند باشد که به جای این کار یک پوینتر را ارسال کنید، که باعث صرفه‌جویی در پردازنده و حافظه می‌شود. با این حال انجام این کار به قیمت خوانا بودن است، بنابراین فقط در صورت لزوم این بهینه‌سازی را انجام دهید.\n3- به گزینه nil نیاز دارید\n-گاهی اوقات یک تابع باید بداند که مقدار یک چیزی چیست، همچنین باید وجود یا عدم وجود آن را بداند. معمولا هنگام خواندن JSON از این استفاده می‌کنیم تا بدانیم فیلدی وجود دارد یا خیر.\n5: زبان گولنگ از موارد زیر پشتیبانی نمی‌کند؟ type inheritance operator overloading method overloading pointer arithmetic struct type in consts 6: برای گوروتین ها چه مواقعی از channel و چه مواقعی از mutex استفاده می شود؟ معمولاً در مواقعی که گوروتین ها نیاز به برقراری ارتباط با یکدیگر دارند، از channels استفاده می کنیم. درصورتی که قسمتی از کد ما(برای مثال مقدار متغیری را تغییر می دهیم) که در آن واحد فقط باید یک گوروتین به آن دسترسی داشته باشد، از یک قفل مانند mutext استفاده می کنیم. 7: تفاوت بین goroutine و thread را توضیح دهید. Goroutines سبک وزن هستند و دارای یک استک اولیه کوچک‌تر که به صورت پویا گسترش می‌یابد هستند، این در حالی است که threads استک ثابت دارند. Goroutines هم‌زمانی را در سطح زبان با استفاده از channelها مدیریت می‌کنند، در حالی که threads ممکن است نیاز به lockهای صریح داشته باشند. همچنین، سوئیچینگ بین goroutines کارایی بیشتری نسبت به thread switching دارد. 8: توضیح دهید که interface در Golang چیست و چگونه می‌تواند مورد استفاده قرار گیرد. یک interface در Go یک نوع خاص است که مجموعه‌ای از method signatures را تعریف می‌کند. هر نوع داده‌ای که این متدها را پیاده‌سازی کند، می‌تواند به عنوان آن interface مورد استفاده قرار گیرد. این بدون نیاز به ارث بری صورت می‌گیرد و امکان داکتایپینگ را فراهم می‌کند. 9: چطور می‌توانید memory leak در برنامه‌های نوشته شده به وسیله Golang را شناسایی و مدیریت کنید؟ برای شناسایی memory leaks در Golang، می‌توان از ابزارهایی مانند pprof به همراه نمودارهای ساخته شده بر اساس heap dumps استفاده کرد. برای پیشگیری از memory leaks، باید دقت کرد که از داده‌ها به درستی استفاده شود، حافظه رزرو شده آزاد گردد و منابع بسته شوند هنگامی که دیگر نیازی به آنها نیست. 10: در Golang چگونه می‌توانیم dependency management را انجام دهیم؟ Golang از Go Modules برای مدیریت وابستگی‌ها استفاده می‌کند که به توسعه دهندگان امکان می‌دهد پروژه‌ها را به صورت مستقل از GOPATH راحت‌تر مدیریت کنند. با استفاده از دستوراتی مانند go mod init, go mod tidy, و go mod vendor می‌توان وابستگی‌های لازم برای پروژه را مدیریت کرد. 11: چه زمانی یک channel در Golang باید با buffer مورد استفاده قرار گیرد؟ یک channel با buffer زمانی مورد استفاده قرار گیرد که شما می‌خواهید ارتباطات بین goroutines را بدون ایجاد blocking فوری داشته باشید. این امر می‌تواند بازده کدها را در مواقعی که عملیات‌ها از لحاظ عملکرد اندکی نابرابر هستند، بهبود بخشد. 12: توضیح دهید که defer statement چیست و چرا ممکن است از آن استفاده کنیم. Defer statement برای تضمین اجرای یک تابع مشخص، درست قبل از خارج شدن از تابع فعلی استفاده می‌شود. این برای راحتی در مدیریت منابع مثل بستن فایل‌ها و ارتباطات شبکه استفاده می‌شود که می‌خواهیم اطمینان حاصل کنیم که به‌درستی بسته خواهند شد. 13: در Golang چگونه می‌توانید اطمینان حاصل کنید که یک goroutine نتیجه‌ای تولید می‌کند قبل از اینکه برنامه کار خود را به طور کامل متوقف کند؟ برای اطمینان از اینکه یک goroutine کار خود را به اتمام برساند، معمولا از sync.WaitGroup برای همچین مدیریتی استفاده می‌کنیم. ساختار WaitGroup اجازه می‌دهد تا اصلی‌ترین goroutine صبر کند تا یک یا چند goroutines دیگر کار خود را تمام کنند. 14: توضیح دهید که واحد ایزوله برای کد نویسی در Golang چیست (table-driven tests) و چرا مفید است. Table-driven tests شیوه‌ای برای نوشتن تست‌ها است که از جداول داده برای تعریف چندین case تست بهره می‌برد. این شیوه مفید است زیرا کد تست را می‌توان برای بسیاری از داده‌ها به راحتی توسعه داد و به خوبی سازماندهی می‌شود. 15: چرا Go از ارث بری (inheritance) پشتیبانی نمی‌کند و از composition به عنوان جایگزین استفاده می‌کند؟ Go ارث بری را پیاده‌سازی نمی‌کند زیرا می‌تواند پیچیده شود و معماری نرم‌افزار را سخت‌تر مدیریت کند. در عوض، از composition استفاده می‌کند که می‌تواند code reuse را تشویق کند و طراحی سیستم را ساده‌تر و ماژولارتر می‌کند. 16: آیا در Golang می‌توان از polymorphism استفاده کرد؟ اگر بله، چگونه؟ بله، در Go می‌توان از polymorphism استفاده کرد از طریق استفاده از interfaces. یک interface می‌تواند برای تعریف یک مجموعه از روش‌ها به کار رود و هر نوع که این روش‌ها را پیاده‌سازی کند به عنوان آن نوع interface شناخته شود. 17: چه تفاوتی میان make و new در Golang وجود دارد؟ make در Go برای ایجاد sliceها، maps و channels استفاده می‌شود و یک ابجکت از نوع مورد نظر را با مقدار اولیه مشخصی برمی‌گرداند. از طرفی new یک pointer به یک ابجکت از یک نوع داده‌ای تعریف شده توسط کاربر را برمی‌گرداند که صفر اولیه شده است. 18: متود (method) receivers در Golang چگونه کار می‌کند و تفاوت بین استفاده از pointer receiver و value receiver چیست؟ Method receivers در Go اجازه می‌دهند تا روی نوع معینی از مقادیر عملیات انجام دهیم. استفاده از pointer receiver به ما اجازه می‌دهد تا تغییراتی که در method روی receiver اعمال می‌شوند را بر روی خود آبجکت اصلی اعمال کنیم، در حالیکه استفاده از value receiver یک کپی از مقدار را می‌گیرد و تغییرات او روی کپی صورت می‌گیرد و بر آبجکت اصلی اثر نمی‌گذارد. 19: چگونه می‌توان در Golang یک پکیج اختصاصی ایجاد کرد و چگونه می‌توان آن را در دیگر فایل‌های Go مورد استفاده قرار داد؟ برای ایجاد پکیج اختصاصی در Go، کد مربوطه باید در یک دایرکتوری قرار داده شود و بالای فایل‌های Go باید package mypackage تعریف شود. برای استفاده از پکیج، import \u0026quot;path/to/mypackage\u0026quot; باید در دیگر فایل‌ها قرار داده شود. 20: در Golang، چگونه می‌توانید error handling را اجرا کنید و چه روش‌هایی برای پیاده‌سازی custom error types وجود دارد؟ Error handling در Go اغلب از طریق بازگرداندن ارور از توابع و بررسی آنها انجام می‌شود. برای ایجاد custom error types، می‌توانید از errors.New() برای ایجاد یک ارور ساده استفاده کنید یا یک تایپ که ارور را پیاده‌سازی می‌کند با متدهای اضافی برای داده‌های اضافی مرتبط با ارور ایجاد کرد. 21: کامپایلر گولنگ از نوع AOT است یا JIT؟ تفاوت بین AOT و JIT را بگو. کامپایلر گو یک Ahead Of Time compilation است. تفاوت AOT با JIT در این است که کامپایلر های AOT مستقیم کد ما را تبدیل به machine code می کنند اما در کامپایتر های JIT کد ما تبدیل به یک کد میانی Bytecode می شود و در زمان اجرا توسط runtime engine هر قسمت از برنامه که مورد استفاده قرار می گیرد، تفسیر می شود و تبدیل به machine code می شود. "},{"id":7,"href":"/chapter-1/","title":"فصل اول: آشنایی با مفاهیم گو","section":"صفحه اصلی","content":"در فصل اول به مفاهیم پایه زبان برنامه‌نویسی گو بطور عمیق می‌پردازیم. این فصل شامل چندین بخش هست:\n1.1 ساختار کد گو 1.2 کلید واژه و شناسه‌ها 1.3 تایپ های پایه 1.4 عملگرها 1.5 متغیرها و constant 1.6 مقادیر صفر تایپ ها (zero values) 1.7 تابع (function) 1.8 آرایه و slice 1.9 حلقه ها (for) 1.10 نقشه map 1.11 شرط (if, switch) 1.12 اضافه کردن پکیج در کد (package) 1.13 defer, panic, recovery 1.14 لیست تایپ ها و توابع Builtin 1.15آشنایی با رشته و توابع آن "},{"id":8,"href":"/chapter-1/structure-of-go-code/","title":"1.1 ساختار کد گو","section":"فصل اول: آشنایی با مفاهیم گو","content":"همانطور که در تاریخچه زبان گو گفتیم, زبان گو سینتکس خیلی تمیز و ساده‌ای دارد که به راحتی می‌توانید کدهای زبان گو را بخوانید. در ادامه ما سعی می‌کنیم با مثال‌های ساده شما را با ساختار کد زبان گو آشنا کنیم.\nبه نقل از تاریخچه سینتکس زبان گو به گونه‌ای طراحی شده که خیلی ساده و تمیز است و این باعث می‌شود خیلی سریع زبان گو را یاد بگیرید و از همه مهم‌تر توسعه پروژه‌های مقیاس پذیر با زبان گو به دلیل سادگی و آشکار بودن مفاهیم خیلی سریع‌تر صورت‌ گیرد. 1.1.0 زبان برنامه‌نویسی # یک زبان برنامه‌نویسی یک زبان مصنوعی انگلیسی است که برای بیان محاسباتی که توسط یک ماشین (مخصوصاً رایانه) قابل انجام است، طراحی شده‌ است. زبان‌های برنامه‌نویسی برای ایجاد برنامه‌هایی به کار می‌روند که رفتار یک ماشین را مشخص می‌کنند، الگوریتم دقیق را بیان می‌کنند، یا روشی برای تعامل انسان و رایانه هستند. بسیاری از زبان‌های برنامه‌نویسی تعدادی قالب از ویژگی‌های نوشته شده دستوری یا نحو (syntax) و معناشناسی (semantics) دارند، چرا که رایانه‌ها دستورهای دقیقاً مشخص نیاز دارند. برخی توسط سند خصوصیات (specification document) تعیین شده‌اند (برای مثال یک استاندارد ISO)، در حالی که برخی دیگر دارای پیاده‌سازی غالبی هستند. [به نقل از ویکی‌پدیا].\n1.1.1 پکیج # هر برنامه‌ای که با ساختار گو ایجاد شده باشد، از پکیج(ها) ساخته شده است. درواقع زبان گو یک زبان بر پایه پکیج است. برخلاف برخی دیگر که بر پایه فایل هستند. این به‌ این‌ معنی است که به «مجموعه»ای از ابزارها اعم از ثابت‌ها، متغیرها و عملیات مختلف که زیرمجموعه یک نام تعریف می‌شوند، پکیج می‌گوئیم. تفاوتی ندارد در یک «فایل» یا «چند» فایل، بشرطی که ابتدای همگی package name باشند.\n1.1.2 یک نمونه کد ساده زبان گو # قبل از اینکه محتوای بدنه کد زیر را بررسی کنیم؛ بهتر است با نحوه کامنت‌گذاری کد در زبان گو آشنا شوید.\n1.1.2.1 کامنت گذاری # کامنت‌ها در زبان گو همانند زبان سی هستند که با قرار دادن ۲ اسلش در ابتدای خط یا قرار دادن یک یا چند خط ما بین /* و */ ایجاد می‌شود.\n1// کامنت عادی یک خطی 2 3/* 4بلاک کامنت برای نوشتن کامنت چند خطی 5*/ 1.1.2.2 نمونه کد # در پایین یک نمونه کد قرار دادیم که با کامنت هر کدام از بخش‌های بدنه کد گو را توضیح دادیم.\n1package main // نام پکیج فایل سورس را مشخص می کند 2 3import \u0026#34;math/rand\u0026#34; // یک پکیج استاندارد ایمپورت شده 4 5const MaxRnd = 16 // یک ثابت تعریف شده است 6 7// تابع 8func StatRandomNumbers(n int) (int, int) { 9\tvar a, b int 10\tfor i := 0; i \u0026lt; n; i++ { 11\tif rand.Intn(MaxRnd) \u0026lt; MaxRnd/2 { 12\ta = a + 1 13\t} else { 14\tb++ 15\t} 16\t} 17\treturn a, b 18} 19 20// تابع main اولین نقطه شروع اجرای کد شما می باشد که در این تابع سایر موارد تعریف می شود. 21func main() { 22\tvar num = 100 23\tx, y := StatRandomNumbers(num) 24\tprint(\u0026#34;Result: \u0026#34;, x, \u0026#34; + \u0026#34;, y, \u0026#34; = \u0026#34;, num, \u0026#34;? \u0026#34;) 25\tprintln(x+y == num) 26} سورس کد بالا را در فایلی با نام basic-code-element-demo.go ذخیره می‌کنیم و سپس با دستور زیر اجرا می‌کنیم تا خروجی کد فوق را ببینیم :\n1$ go run basic-code-element-demo.go 2Result: 46 + 54 = 100? true 1.1.3 تابع main # در زبان گو پکیج main به عنوان یک پکیج منحصر به فرد در نظر گرفته شده است، به شکلی که در هنگام اجرای برنامه مشخص می‌کند شروع کار و خواندن برنامه از کجا باید باشد. در نهایت داخل این پکیج ما تابع ()main را داریم که این تابع نقطه شروع اجرای برنامه ما خواهد بود. این تابع هیچ ارگومانی نمی‌گیرد و هیچ چیزی رو هم بازگشت نخواهد داد. زبان گو به صورت خودکار تابع ()main را فراخوانی می‌کند. برای همین نیازی به فراخوانی این تابع توسط شما وجود ندارد. برای همین باید دقت داشته باشید در هر برنامه‌ای که می‌نویسید حتما از پکیج و تابع main باید استفاده کنید.\n1// تعریف پکیج main 2package main 3 4// تعریف تابع main 5func main() { 6\tprintln(\u0026#34;Hello GoFarsi!\u0026#34;) 7} 1.1.4 اجرای کد # برای اجرای کدهای گو می‌توان از پارامتر run استفاده کرد.\n1$ go run main.go 2Result: Hello GoFarsi! دستور بالا ابتدا داخل پوشه temp سیستم شما یک فایل اجرایی را درست می‌کند و سپس آن فایل را اجرا می‌کند و در نهایت خروجی را به ما نشان می‌دهد. اگر شما بخواهید خروجی فایل اجرایی (executable) داشته باشید و سپس آن را اجرا کنید می‌توانید از دستور زیر استفاده کنید:\n1$ go build main.go 2$ ./main 3Result: Hello GoFarsi! اگر بخواهید برای خروجی فایل اجرایی اسمی در نظر بگیرید می‌توانید از دستور زیر با پارامتر o- استفاده کنید.\n1$ go build -o goFarsi main.go 2$ ./goFarsi 3Result: Hello GoFarsi! دقت کنید اگر از سیستم‌عامل ویندوز استفاده می‌کنید بعد از وارد کردن اسم، پسوند .exe را نیز اضافه کنید. برای راحتی و سرعت بخشیدن هنگام توسعه ما از دستور go run استفاده می‌کنیم. تابع init # همانطور که گفتیم نقطه شروع برنامه ما تابع main است. اما اگر بخواهیم قبل از اجرای برنامه مقداری را ست کنیم و یا چیزی را لود کنیم، می توانیم در داخل تابع init اینکار را انجام دهیم. تابع init قبل از تابع main اجرا می شود\n1// تعریف پکیج main 2package main 3 4// تعریف تابع init 5func init() { 6 println(\u0026#34;init\u0026#34;) 7} 8 9// تعریف تابع main 10func main() { 11\tprintln(\u0026#34;Hello GoFarsi!\u0026#34;) 12} پس از اجرای کد. خروجی زیر را مشاهده می کنید.\n1$ go run main.go 2Result: 3init 4Hello GoFarsi! 1.1.5 بررسی syntax # برخلاف بیشتر زبان‌های برنامه نویسی در زبان گو شما نمی‌توانید از حالت‌های مختلف برای نوشتن کد خود استفاده کنید. مثلاً کد زیر هنگام کامپایل کردن خطا می‌دهد.\n1package main 2 3func main() 4{ 5\tprintln(\u0026#34;not compiled\u0026#34;) 6} خروجی کد بالا :\n1$ go run main.go 2Result: 3# command-line-arguments 4.\\main.go:4:1: syntax error: unexpected semicolon or newline before { صرفاً با تغییر براکت ما با خطا مواجه شدیم. شاید از دید شما این نوع نوشتن کد نباید خطا ایجاد کند. ولی وقتی شما داخل یک تیم هستید و مجبور هستید کدها را بازخوانی کنید تا بفهمید چه اتفاقی افتاده است، با حالت‌های مختلف سینتکس مواجه نخواهید شد، و همه کدها یک دست و از یک ساختار پیروی می‌کنند، که باعث خواندن سریع‌تر، درک بهتر و امکان توسعه سریع‌تر را برای ما و هم‌تیمی‌های ما ایجاد خواهد کرد.\n1.1.5.1 استفاده از go fmt # برای آن که بتوان از این نوع خطاها جلوگیری کرد و فرمت مناسب و یک نواختی داخل کدهای ما وجود داشته باشد، خود IDEها این خطاها را به ما نشان می‌دهد. خود توسعه‌دهندگان زبان گو پارامتر fmt یا به عبارتی فرمت را در اختیار ما قرار داده‌اند تا هر زمان که کدی می‌نویسم و ذخیره می‌کنیم بتوانیم با استفاده از این دستور ساختار کد خود را مرتب کنیم و اگر خطایی وجود داشته باشد قبل از کامپایل کردن برنامه آن را پیدا و رفع کنیم. مثلاً خروجی استفاده از پارامتر fmt\n1$ go fmt main.go 2Result: 3.\\main.go:4:1: unexpected semicolon or newline before { حالا فرض کنید کدی را نوشته‌اید و داخل کد شما فضای زیادی وجود دارد و اندازه tab‌ها و space‌ها مشخص نیست. به مثال زیر توجه کنید:\n1package main 2 3func main(){ 4 5 6 7\tprintln(\u0026#34;print line 1\u0026#34;) 8\t9\t10\t11\t12println(\u0026#34;print line 2\u0026#34;) 13\t14\t15} وقتی کدی شبیه کد بالا را دارید و از دستور go fmt استفاده می‌کنیم خروجی کد بالا به شکل زیر تغییر پیدا می‌کند:\n1package main 2 3func main() { 4 5\tprintln(\u0026#34;print line 1\u0026#34;) 6\t7\tprintln(\u0026#34;print line 2\u0026#34;) 8} در برنامه فوق ما یکسری کلمات کلیدی نظیر package, import, const, func, var , for, if, else, return استفاده کردیم و سایر کلماتی که داخل کد فوق دیدید به عنوان شناسه هستند. برای اطلاعات بیشتر در خصوص کلید واژه و شناسه لطفاً بخش کلید واژه و شناسه ها را مطالعه فرمایید. "},{"id":9,"href":"/chapter-1/go-built-in-keywords-identifiers/","title":"1.2 کلید واژه و شناسه‌ها","section":"فصل اول: آشنایی با مفاهیم گو","content":"در این بخش قصد داریم به کلید واژه و شناسه های زبان گو بپردازیم.\n1.2.1 کلید واژه # زبان گو تا نسخه فعلی فقط ۲۵ تا کلید واژه دارد که به شرح زیر ست:\n1 2 3 4 5 1 break default func interface select 2 case defer go map struct 3 chan else goto package switch 4 const fallthrough if range type 5 continue for import return var کلمات کلیدی فوق به ۴ دسته تقسیم می‌شوند که به شرح زیر است:\nکلمات کلیدی که بصورت گلوبال در بدنه قرار می‌گیرند «package, import, type, var, const, func» کلمات کلیدی کامپوزیت «struct, interface, map, chan» کلمات کلیدی که در جریان کنترل کد استفاده می‌شوند «break, case, continue, default, if, else, for, fallthrough, goto, range, return, switch, select» در بخش‌های دیگر کتاب ما بطور مفصل به مفاهیم کلمات کلیدی فوق می‌پردازیم. 1.2.2 شناسه‌ها # شناسه توکنی است که باید از حروف یونیکد, ارقام یونیکد (اعداد دسته‌بندی شده در استاندارد ۸.۰ یونیکد) و خط زیرین ـ تشکیل شده باشد.\nعلامت کاربرد ـ نادیده گرفتن \u0026amp; دسترسی به آدرس حافظه * دسترسی مقدار داخل یک خانه حافظه 1.2.2.1 قوانین شناسه‌ها # نامگذاری باید از حروف a-z یا A-Z و یا 0-9 باشد. نام شناسه‌ها نباید با اعداد شروع شود. نام شناسه‌ها به حروف بزرگ و کوچک حساس است. استفاده از کلید واژه ممنوع است. هیچ محدودیتی در تعداد حروف نام شناسه وجود ندارد و مطلوب‌ترین حالت ۴ الی ۱۵ حرف است. 1// شناسه‌های معتبر 2 3_geeks23 4geeks 5gek23sd 6Geeks 7geeKs 8geeks_geeks 9 10// شناسه‌های نامعتبر 11 12212geeks 13if 14default در زبان گو یکسری شناسه‌ها از قبل برای برخی از بخش‌های کد تعیین شده است که در زیر می‌توانید ببینید:\n1// Constant (ثابت ها) 2 3true, false, iota, nil 4 5// Types (تایپ ها) 6 7int, int8, int16, int32, int64, uint, 8uint8, uint16, uint32, uint64, uintptr, 9float32, float64, complex128, complex64, 10bool, byte, rune, string, error 11 12// Functions (توابع) 13 14make, len, cap, new, append, copy, close, 15delete, complex, real, imag, panic, recover "},{"id":10,"href":"/chapter-1/go-basic-types/","title":"1.3 تایپ‌های پایه","section":"فصل اول: آشنایی با مفاهیم گو","content":" 1.3.1 تایپ چیست؟ # یک تایپ مشخص کننده نوع داده است، که به کامپایلر می‌گوید قرار است چه نوع داده‌ای داخل یک متغیر ذخیره گردد. زبان‌ها انواع تایپ‌های مختلفی به صورت پیش‌فرض دارند که می‌توان از آن‌ها داخل برنامه خود استفاده کرد. ما می‌توانیم تایپ‌ها را به دو دسته کلی تعریف کنیم.\n1.3.1.1 تایپ ایستا (Static Type) # زبانی مثل زبان گو یک زبان تایپ ایستا است، یعنی وقتی ما یک داده‌ای از نوع عددی داخل یک متغیر تعریف می‌کنیم داخل همان متغیر امکان اضافه کردن داده‌ای، غیر داده عددی وجود ندارد.\n1.3.1.2 تایپ پویا (Dynamic Type) # زبان‌هایی مثل PHP، JavaScript و \u0026hellip; جزو زبان‌های تایپ پویا هستند. یعنی وقتی یک متغیری از نوع عددی تعریف می‌کنیم می‌توانیم به همان متغیر مقادیر دیگه‌ای مثل مقادیر رشته‌ای اضافه کنیم.\nتفاوت تایپ ایستا با پویا به نقل از آقای استقامت:\nدر زبان‌هایی مثل گو که جزو زبان‌های نوع ایستا هستند، وقتی بخوایم متغیر یا ثابتی ایجاد کنیم، حتما می بایست نوع متغیر یا ثابت را به صورت مستقیم و صریح اعلان کنیم تا کامپایلر متوجه بشه که درون این متغیر یا ثابت قراره چه نوع داده ای ذخیره بشه.\nبه عنوان مثال در زبان گو باید بنویسیم: ‎var a, b int = 1, 2\nو اگر نوع داده یا در این مثال(int) را مشخص نکنیم با ارور مواجه می‌شویم.\nاکنون که این دو متغیر از نوع int اعلان شدند، فقط و فقط می‌توان مقادیری از نوع اعداد صحیح را درون آن‌ها ذخیره کرد و نمی‌توان به عنوان مثال، یک رشته متنی یا اعداد اعشاری و \u0026hellip; را درون آن‌ها ذخیره نمود.\n▪️ اما در مورد زبان‌های نوع پویا مانند زبان پایتون، ما نیازی به اعلان صریح نوع متغیر نداریم. بلکه کافیست یک شناسه را به عنوان نام متغیر در نظر گرفته و مقداری را به آن انتساب دهیم. در اینجا، کامپایلر یا مفسر زبان به صورت خودکار نوع داده متغیر را بر اساس مقداری که به آن انتساب داده ایم شناسایی می کند: به عنوان مثال در زبان پایتون داریم: ‎n = 300\nدر این جا متغیر n دارای نوع int است که به صورت خودکار توسط زبان شناسایی می‌شود.\nاکنون ما می‌توانیم همین متغیر را در جاهای دیگری از کد استفاده کنیم و مقادیری از انواع داده‌ای دیگر به آن انتساب دهیم بدون اینکه هیچ مشکلی یا اروری پیش بیاید: \u0026quot;‎n = \u0026quot;Hello\nدر حال حاضر متغیر n از نوع string می باشد!\nبرای اطلاعات بیشتر می‌توانید تایپ سیستم را داخل ویکی‌پدیا مطالعه کنید.\n1.3.2 تایپ‌ها در زبان گو # زبان گو مثل سایر زبان‌ها یکسری تایپ‌های پایه دارد که در هر بخش از کد گو می‌توانید استفاده کنید. در ادامه این تایپ‌ها با مقادیر پیش‌فرض‌ معرفی شده است.\nتایپ محدوده مقدار پیش فرض یا مقدار صفر حجم استفاده از حافظه int بستگی به معماری سیستم عامل که ۳۲ بیت یا ۶۴ بیت باشد 0 ۴ یا ۸ بایت int8 128- تا 127 0 ۱ بایت int16 32768- تا 32767 0 ۲ بایت int32 2147483648- تا 2147483647 0 ۴ بایت int64 9223372036854775808- تا 9223372036854775807 0 ۸ بایت uint بستگی به معماری سیستم عامل که ۳۲ بیت یا ۶۴ بیت باشد 0 ۴ یا ۸ بایت uint8 0 تا 255 0 ۱ بایت uint16 0 تا 65535 0 ۲ بایت uint32 0 تا 6294967295 0 ۴ بایت uint64 0 تا 18446744073709551615 0 ۸ بایت uintptr عدد خیلی بزرگ 0 ۸ بایت float32 IEEE-754 0 ۴ بایت float64 IEEE-754 0 ۸ بایت complex64 - 0+0i ۸ بایت complex128 - 0+0i ۱۶ بایت bool - false ۱ بایت string - \u0026quot; \u0026quot; ۱۶ بایت زبان گو به‌طور پیش‌فرض از دو نوع تایپ با نام مستعار پشتیبانی می‌کند :\nتایپ byte این تایپ نام مستعار برای تایپ uint8 است. تایپ rune این تایپ نام مستعار برای تایپ int32 است. تفاوت int و uint در این است که نوع داده int به عنوان Signed Integer شناخته می‌شود و توانایی ذخیره اعداد منفی ، 0 و اعداد مثبت را دارد اما نوع داده uint به معنای Unsigned Integer بوده و فقط توانایی نگهداری اعداد مثبت و 0 را داراست.\nتایپ uintptr به نقل از آقای استقامت:\nدر مورد نوع داده uintptr که در متن بالا در مورد آن گفته شده \u0026ldquo;عدد خیلی بزرگ\u0026quot;، با بیان این مطلب که چنین توضیحی نادرست است، توجه شما رو به ادامه این یادداشت جلب می‌کنم:\nکلمه uintptr همان‌طور که قابل حدس زدن است کوتاه شده Unsigned Integer Pointer است.\nاز این نوع داده برای ذخیره و نگهداری آدرس‌های حافظه(RAM) استفاده می‌شود.\nفضایی که این نوع داده در سیستم اِشغال می‌کند، به نوع معماری سیستم عامل بستگی دارد.\nو در نهایت، به جای عبارت \u0026ldquo;عدد خیلی بزرگ\u0026rdquo; که مفهوم اشتباه و نادرستی می‌رساند، باید اینگونه بگوییم که این نوع داده به اندازه کافی بزرگ است تا بتواند اشاره گرهایی(Pointers) به هر آدرس از حافظه را درون خودش ذخیره کند.(منبع)\n1package main 2import \u0026#34;fmt\u0026#34; 3 4func main() { 5 var var1 uintptr = 0xc82000c290 6 fmt.Println(\u0026#34;Value of var1:\u0026#34;, var1) 7 fmt.Printf(\u0026#34;Type of var1: %T\u0026#34;, var1) 8 } 1$ go run main.go 2Value of var1: 859530379920 3⁦‎Type of var1: uintptr 1.3.3 سفارشی‌سازی تایپ‌(ها) # نام‌گذاری جدید : برای تایپ‌های رشته‌ای، عددی و بول، می‌توان نام سفارشی جدید انتخاب و در پروژه استفاده کرد: 1 2/* type alias */ 3 4// bul and bool define the same type. 5type bul = bool 6// content and string define the same type. 7type content = string 8// UI8, uint8 and byte define the same type. 9type UI8 = uint8 10// Word, rune and int32 define the same type. 11type Word = rune ایجاد تایپ جدید معادل یک تایپ موجود : همچنین می‌توان از تایپ‌های موجود، یک نمونه جدید ایجاد کرد: 1/* type definition */ 2 3// state and bool are two different types. 4type state bool 5// str and string are two different types. 6type str string 7// ID and uint64 are two different types. 8type ID uint64 9// decimal and float32 are two different types. 10type decimal float32 1.3.4 مقدار پیش فرض تایپ‌ها # مقدار پیش‌فرض تایپ‌ها در زبان گو به شرح زیر است :\nمقدار پیش‌فرض تایپ بولین false است. مقدار پیش‌فرض تمامی تایپ اعداد (int, uint, float) صفر است. مقدار پیش‌فرض تایپ string برابر با رشته تهی یا empty string است . رشته تهی معادل عبارت \u0026quot;\u0026quot; است (دو علامت نقل قول بدون هیچ کاراکتری در بین آن‌ها) و عبارت \u0026quot; \u0026ldquo; که دارای یک فاصله خالی(Space) در بین دو نقل قول است، یک رشته تهی نیست و بنابراین اشتباه است!\n1.3.5 انواع مقادیر تایپ‌ها # در زبان گو تایپ‌ها یکسری مقادیر مختلفی را دریافت می‌کنند که در زیر به این مقادیر می‌پردازیم.\n1.3.5.1 تایپ بولین # تایپ بولین فقط true و false را به عنوان مقدار دریافت می‌کند.\n1.3.5.2 تایپ Integer # تایپ اعداد ۴ نوع مقدار مختلف دریافت می‌کند که به ترتیب Decimal (پایه ۱۰), Octal (پایه ۸), Hex (پایه ۱۶) و Binrary (پایه ۲ یا دودویی) است.\n10xF // the hex form (starts with a \u0026#34;0x\u0026#34; or \u0026#34;0X\u0026#34;) 20XF 3 4017 // the octal form (starts with a \u0026#34;0\u0026#34;, \u0026#34;0o\u0026#34; or \u0026#34;0O\u0026#34;) 50o17 60O17 7 80b1111 // the binary form (starts with a \u0026#34;0b\u0026#34; or \u0026#34;0B\u0026#34;) 90B1111 10 1115 // the decimal form (starts without a \u0026#34;0\u0026#34;) 1package main 2 3func main() { 4\tprintln(15 == 017) // true 5\tprintln(15 == 0xF) // true 6} 1.3.5.3 تایپ Float # تایپ Float چند نوع مقدار را دریافت می‌کند که به ترتیب مقدار ممیز شناور اعشاری ممکن است شامل یک قسمت صحیح اعشاری، یک نقطه اعشاری، یک قسمت کسری اعشاری، و یک قسمت توانی عدد صحیح (مبتنی بر 10) باشد.\n11.23 201.23 // == 1.23 3.23 41. 5// An \u0026#34;e\u0026#34; or \u0026#34;E\u0026#34; starts the exponent part (10-based). 61.23e2 // == 123.0 7123E2 // == 12300.0 8123.E+2 // == 12300.0 91e-1 // == 0.1 10.1e0 // == 0.1 110010e-2 // == 0.1 120e+5 // == 0.0 1.3.5.4 تایپ rune # تایپ rune یک تایپ با نام مستعار int32 است که از تایپ‌های اعداد صحیح خاص هستند. از rune می‌توان برای ذخیره کاراکترهای یونیکد استفاده کرد که در مثال زیر چند نمونه قرار داده شده است:\n1\u0026#39;a\u0026#39; // an English character 2\u0026#39;π\u0026#39; 3\u0026#39;众\u0026#39; // a Chinese character 1// 141 is the octal representation of decimal number 97. 2\u0026#39;\\141\u0026#39; 3// 61 is the hex representation of decimal number 97. 4\u0026#39;\\x61\u0026#39; 5\u0026#39;\\u0061\u0026#39; 6\u0026#39;\\U00000061\u0026#39; 1package main 2 3func main() { 4\tprintln(\u0026#39;a\u0026#39; == 97) 5\tprintln(\u0026#39;a\u0026#39; == \u0026#39;\\141\u0026#39;) 6\tprintln(\u0026#39;a\u0026#39; == \u0026#39;\\x61\u0026#39;) 7\tprintln(\u0026#39;a\u0026#39; == \u0026#39;\\u0061\u0026#39;) 8\tprintln(\u0026#39;a\u0026#39; == \u0026#39;\\U00000061\u0026#39;) 9\tprintln(0x61 == \u0026#39;\\x61\u0026#39;) 10\tprintln(\u0026#39;\\u4f17\u0026#39; == \u0026#39;众\u0026#39;) 11} ◾️استاندارد یونیکد، مجموعه‌ای از تمام کاراکترهای موجود در جهان است (کاراکترهای زبان‌های لاتین، فارسی، عربی، چینی و \u0026hellip;، اموجی‌ها (مانند😊)، کاراکترهای غیرقابل نمایش و \u0026hellip;).\n◾️هر کدام از این کاراکترها در استاندارد یونیکد، توسط یک عدد یکتا و منحصر به فرد مشخص شده است. به این عدد Unicode Code Point می‌گویند.\n◾️به عنوان مثال، کد پوینت کاراکتر «😊» برابر است با U+1F60A یا کد پوینت کاراکتر «ن» در زبان فارسی برابر است با U+0646.\n◾️این کد پوینت‌ها دقیقا همان چیزهایی هستند که در runeها ذخیره می‌شوند.\n◾️از آنجا که زبان گو، از استاندارد UTF-8 (ارائه شده توسط کنسرسیوم یونیکد) برای encoding کاراکترها استفاده می‌کند و در این استاندارد، هر کاراکتر فضایی بین 1 تا 4 بایت(8 بیت تا 32 بیت) را در حافظه اِشغال می‌کند. به همین دلیل نوع داده rune یک نام مستعار برای نوع داده int32 در زبان گو است.\n1package main 2import \u0026#34;fmt\u0026#34; 3 4func main() { 5 var r rune = \u0026#39;k\u0026#39; 6 fmt.Printf(\u0026#34;%c %T %U\u0026#34;, r, r, r) 7} 1$ go run main.go 2k int32 U+006B 3Program exited. 1.3.5.5 byte، string و rune # مقادیر string و rune[] قابل تبدیل به یک دیگر هستند. اما تفاوت این دو در چیست؟ هر string از مجموعه ای از byte ها تشکیل شده که هر یک 8 بیت هستند. هر کاراکتر در UTF-8 از 1 تا 4 بایت تشکیل شده. مثلا حرف \u0026lsquo;a\u0026rsquo; از یک بایت و کاراکتر \u0026lsquo;你\u0026rsquo; از 3 بایت تشکیل میشه. به کد زیر توجه کنید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func stringAndRuneCompare() { 6 s := \u0026#34;hello你好\u0026#34; 7 fmt.Printf(\u0026#34;%s, type: %T, len: %d\\n\u0026#34;, s, s, len(s)) 8 9 rs := []rune(s) 10 fmt.Printf(\u0026#34;%v, type: %T, len: %d\\n\u0026#34;, rs, rs, len(rs)) 11 12} 13 14func main() { 15 stringAndRuneCompare() 16} خروجی:\n1hello你好, type: string, len: 11 2[104 101 108 108 111 20320 22909], type: []int32, len: 7 طول رشته در تایپ string یازده و در تایپ rune[] برابر 7 است. علت چیست؟ رشته در تایپ string یازده است، زیرا 5 نویسه اول هر کدام فقط 1 بایت می گیرند، در حالی که 2 نویسه چینی آخر هر کدام 3 بایت می گیرند. بنابراین، کل بایت 3 * 2 + 1 * 5 = 11 است.\nهنگام تبدیل رشته به rune[]، گو 7 کاراکتر 32 بیتی پیدا می کند. از انجایی که هر rune برابر 32 بیت است، کاراکتر های انگلیسی و چینی هر کدام یک rune را اشغال می کنند. در نتیجه مجموعا 7 rune وجود دارد.\n1.3.5.6 تایپ رشته (string) # در زبان گو مقدار تایپ رشته بطور پیش‌فرض از نوع یونیکد UTF-8 است.\n1// The interpreted form. 2\u0026#34;Hello\\nworld!\\n\\\u0026#34;你好世界\\\u0026#34;\u0026#34; 3 4// The raw form. 5`Hello 6world! 7\u0026#34;你好世界\u0026#34;` همچنین رشته از کارکترهای خاص یونیکد مانند 0x0D پشتیبانی می‌کند.\n1.3.6 خوانایی بهتر اعداد با _ # در زبان گو می‌توان برای خوانایی بهتر اعداد چند رقمی، از _ برای جداسازی استفاده کرد.\n1// Legal ones: 26_9 // == 69 30_33_77_22 // == 0337722 40x_Bad_Face // == 0xBadFace 50X_1F_FFP-16 // == 0X1FFFP-16 60b1011_0111 + 0xA_B.Fp2i 7 8// Illegal ones: 9_69 // _ can\u0026#39;t appear as the first character 1069_ // _ can\u0026#39;t appear as the last character 116__9 // one side of _ is a illegal character 120_xBadFace // \u0026#34;x\u0026#34; is not a legal octal digit 131_.5 // \u0026#34;.\u0026#34; is not a legal octal digit 141._5 // \u0026#34;.\u0026#34; is not a legal octal digit "},{"id":11,"href":"/chapter-1/go-operators/","title":"1.4 عملگرها","section":"فصل اول: آشنایی با مفاهیم گو","content":"زبان گو مثل سایر زبان‌ها دارای یکسری عملگرها مانند: عملگرهای حسابی, عملگرهای مقایسه‌ای, عملگرهای منطقی و عملگرهای بیتی است.\n1.4.1 عملگرهای حسابی # زبان گو دارای ۵ تا عملگر حسابی است که به ترتیب:\nعملگر نام + جمع - تفریق * ضرب / تقسیم % باقی مانده این ۵ تا عملگر اغلب به ترتیب مجموع, تفاوت, حاصل‌ضرب و ضریب نیز نامیده می‌شوند.\n1 a := 1 2 b := 2 3 4 c := a + b // 3 5 d := a - b // -1 6 e := a * b // 2 7 f := a / b // 0 8 g := a % b // 1 در نمونه کد بالا ما از عملگر := که شیوه تعریف متغیر به روش کوتاه است استفاده کردیم که در بخش 1.5 متغیرها و ثابت ها معرفی خواهیم کرد. 1.4.2 عملگرهای مقایسه‌ای # زبان گو دارای ۶ عملگر مقایسه‌ای است که به ترتیب:\nعملگر نام == مساوی بودن =! مساوی نبودن با \u0026gt; کوچکتر از =\u0026gt; کوچکتر یا مساوی \u0026lt; بزرگتر =\u0026lt; بزرگتر یا مساوی نتیجه استفاده از این عملگرهای مقایسه‌ای, یک نوع untyped بولین است. یعنی حاصل این مقایسه‌ها در واقع true یا false است.\n1 a := 1 2 b := 2 3 c := 1 4 5 println(a == b) // false 6 println(a == c) // true 7 println(a \u0026lt; b) // true 8 println(b \u0026gt; c) // true 9 println(c \u0026lt;= a) // true 10 println(c \u0026gt;= b) // false 11 println(b != a) // true 12 println(c != a) // false 1.4.3 عملگرهای منطقی # زبان گو دارای ۳ نوع عملگر منطقی است که به ترتیب:\nعملگر نام \u0026amp;\u0026amp; AND || OR ! NOT عملگر \u0026amp;\u0026amp; به انگلیسی AND به فارسی و , اگر هردو عملگر true باشد مقدار بازگشتی true و در غیر اینصورت false خواهد بود. عملگر || به انگلیسی OR به فارسی یا , اگر یکی از عملگرها true باشد مقدار بازگشتی true در غیر این صورت false خواهد بود. عملگر ! به انگلیسی NOT به فارسی ‍‍منفی یا نفی , زمانیکه شما از عملگر ! استفاده می کنید معکوس نتیجه عملوند را نیاز دارید. 1a := true 2b := true 3c := false 4 5fmt.Println(a \u0026amp;\u0026amp; b) //true 6fmt.Println(a || b) //true 7fmt.Println(!a) //false 8fmt.Println(!c) //true مثال زیر نتیجه مقادیر متفاوت و عملگرهای منطقی را نشان می‌دهد.\n1 // x y x \u0026amp;\u0026amp; y x || y !x !y 2 true true true true false false 3 true false false true false true 4 false true false true true false 5 false false false false true true 1.4.4 عملگرهای بیتی # زبان گو داری 5 عملگر بیتی است که به ترتیب:\nعملگر نام \u0026lt;\u0026lt; شیفت بیتی به چپ \u0026gt;\u0026gt; شیفت بیتی به راست \u0026amp; AND | OR ^ XOR ‍‍\nعملگر \u0026lt;\u0026lt; به انگلیسی Zero fill left shift یا به اختصار left shift که به فارسی اسم مناسبی نیافتیم به نقل از ویکی پدیا شیفت بیتی به چپ, مقدار باینری ما را با استفاده از انتقال یا اضافه کردن صفرها به سمت چپ انتقال می‌دهد. عملگر \u0026gt;\u0026gt; به انگلیسی Zero fill right shift یا به اختصار right shift که به فارسی اسم مناسبی نیافتیم به نقل از ویکی پدیا شیفت بیتی به راست, مقدار باینری ما را با به سمت راست انتقال می‌دهد. در زیر دو مثال رو مشاهده می‌کنید که از این دو عملگر استفاده شده:\n1//example 1 2a := 0b01000101 3b := a \u0026lt;\u0026lt; 1 4c := a \u0026gt;\u0026gt; 1 5fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, a, a) //binary:01000101,value:69 6fmt.Println(\u0026#34;\u0026#34;) 7fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, b, b) //binary:10001010,value:138 8fmt.Println(\u0026#34;\u0026#34;) 9fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, c, c) //binary:00100010,value:34 10 11fmt.Println(\u0026#34;\\n\\n---------------\\n\u0026#34;) 12//example 2 13d := 0b01010101 14e := d \u0026lt;\u0026lt; 3 15f := d \u0026gt;\u0026gt; 3 16fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, d, d) //binary:01010101,value:85 17fmt.Println(\u0026#34;\u0026#34;) 18fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, e, e) //binary:1010101000,value:680 19fmt.Println(\u0026#34;\u0026#34;) 20fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, f, f) //binary:00001010,value:10 21fmt.Println(\u0026#34;\u0026#34;) 22 */ در مثال دو همانطور که مشاهده کردید زمانی که از عملگر \u0026gt;\u0026gt; استفاده کردید در صورتی که اولین خانه باینری از سمت چپ مقدار 1 داشته باشد مابقی مقدار به صورت 0 به باینری اضافه می‌شود و در غیر این صورت 1 ها به همان مقدار به سمت چپ خواهد رفت.\nدر واقع 08b% یک شناساگر قالب (format specifier) برای نمایش باینری در هشت خانه است در اینجا می‌توانید بیشتر راجب شناساگرهای قالب بخوانید. عملگر \u0026amp; به انگلیسی AND به فارسی و دو مقدار باینری رو با یک دیگر مقایسه و اگر هر بیت مقدار 1 در هر دو طرف داشته باشد آن را 1 نگه می‌دارد و در غیر اینصورت آن بیت را 0 می‌کند. عملگر | به انگلیسی OR به فارسی یا دو مقدار باینری رو با یک دیگر مقایسه و اگر هر بیت مقدار 1 در یک طرف یا هر دوطرف داشته باشد آن را 1 نگه می‌دارد و در غیر اینصورت آن بیت را 0 می‌کند. عملگر ^ به انگلیسی XOR به فارسی نامی ندارد دو مقدار باینری رو با یک دیگر مقایسه و اگر هر بیت مقدار 1 در هر دوطرف داشته باشد آن را 0 می‌کند.\n1//\u0026amp; operator example 2a := 0b01000101 3b := 0b01010100 4c := a \u0026amp; b 5fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, a, a) //binary:01000101,value:69 6fmt.Println(\u0026#34;\u0026#34;) 7fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, b, b) //binary:01010100,value:84 8fmt.Println(\u0026#34;\u0026#34;) 9fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, c, c) //binary:01000100,value:68 10 11fmt.Println(\u0026#34;\\n\\n---------------\\n\u0026#34;) 12 13//| operator example 14d := 0b01000101 15e := 0b01010100 16f := d | e 17fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, d, d) //binary:01000101,value:69 18fmt.Println(\u0026#34;\u0026#34;) 19fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, e, e) //binary:01010100,value:84 20fmt.Println(\u0026#34;\u0026#34;) 21fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, f, f) //binary:01010101,value:85 22 23fmt.Println(\u0026#34;\\n\\n---------------\\n\u0026#34;) 24 25//^ operator example 26g := 0b01000101 27h := 0b01010100 28i := a ^ b 29fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, g, g) //binary:01000101,value:69 30fmt.Println(\u0026#34;\u0026#34;) 31fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, h, h) //binary:01010100,value:84 32fmt.Println(\u0026#34;\u0026#34;) 33fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, i, i) //binary:00010001,value:17 1.4.5 اولویت عملگرها # در زبان گو یکسری اولویت‌ها برای عملگرها وجود دارد و همچنین در زبان گو مثل سایر زبان‌ها پرانتز () ترویج دهنده اولویت‌ها است.\n1 * / % \u0026lt;\u0026lt; \u0026gt;\u0026gt; \u0026amp; \u0026amp;^ 2 + - | ^ 3 == != \u0026lt; \u0026lt;= \u0026gt; \u0026gt;= 4 \u0026amp;\u0026amp; 5 || توجه در زبان گو اولویت \u0026lt;\u0026lt; و \u0026gt;\u0026gt; بیشتر از + و - است. "},{"id":12,"href":"/chapter-1/go-variables-and-consts/","title":"1.5 متغیرها و constant","section":"فصل اول: آشنایی با مفاهیم گو","content":" 1.5.1 متغیر (Variable) # در برنامه‌نویسی رایانه، یک متغیر یک مکان در حافظه (آدرس حافظه) است که دارای یک نام نمادین با عنوان است و می‌تواند حاوی اطلاعات یا یک مقدار معلوم یا مجهول که به آن ارزش یا مقدار می‌گویند، باشد. به زبان دیگر، متغیر در برنامه‌نویسی به فضایی که برای ذخیره داده‌ها کنار گذاشته شده‌ است می‌گویند (به نقل از سایت ویکی‌پدیا)\nتعریف یک متغیر رشته # 1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7func main() { 8\tvar s string = \u0026#34;Hello World\u0026#34; 9\tfmt.Println(s) 10} 1$ go run main.go 2Hello World یک متغیر با استفاده از کلید واژه var ایجاد کردیم. نام متغیر را s گذاشتیم. تایپ متغیر را از نوع string تعیین کردیم. سپس با عملگر = مقدار متغیر را مشخص از نوع رشته تعیین کردیم. رشته \u0026quot;Hello World\u0026quot; به عنوان مقدار متغیر s است و این مقدار در خانه مشخصی از حافظه قرار داده شده است. از پکیج استاندارد fmt برای چاپ مقدار متغیر s استفاده کردیم که این پکیج یکسری توابع جهت انجام عملیات‌های مختلفی نظیر چاپ مقادیر را دارد که در کد بالا ما از تابع Println استفاده کردیم. 1.5.1.1 اختصاص مقدار جدید به متغیر از قبل ایجاد شده # در کد زیر ما یک متغیر از قبل تعریف کردیم و مقدار جدید را در خط ۹ به متغیر اختصاص دادیم.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7func main() { 8\tvar s string 9\ts = \u0026#34;Hello World\u0026#34; 10\tfmt.Println(s) 11} زمانی که شما یک متغیر بصورت var s string تعریف می‌کنید مقدار پیش‌فرض \u0026quot;\u0026quot; برای متغیر تعیین شده است. 1.5.1.2 اختصاص مقدار رشته به تایپ اشتباه # 1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7func main() { 8\tvar i int 9\ti = \u0026#34;One\u0026#34; 10\tfmt.Println(i) 11} 1$ go run main.go 2./main.go:cannot use \u0026#34;One\u0026#34; (type string) as type int in assignment در کد بالا ما یک متغیر از نوع int تعریف کردیم و در خط ۹ مقدار \u0026quot;One\u0026quot; را به آن تخصیص دادیم و پس از اجرا با خطای cannot use \u0026quot;One\u0026quot; (type string) as type int in assignment مواجه شدیم. این خطا یعنی اینکه شما یک مقدار رشته را به تایپ اشتباه اختصاص داده‌اید.\n1.5.1.3 تعریف متغیر به صورت خلاصه # زبان گو علاوه بر اینکه از کلید واژه var برای تعریف متغیر پشتیبانی می‌کند, از =: به انگلیسی short variable declaration نیز برای تعریف متغیرها پشتیبانی می‌کند. شما می‌توانید یک متغیر تعریف کنید و نیازی به مشخص کردن تایپ متغیر نیست، چون زبان گو بر اساس مقدار تعیین شده تایپ متغیر را تشخیص می‌دهد.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\ts := \u0026#34;Hello World\u0026#34; 7\tfmt.Println(s) 8} توجه کنید شما فقط داخل تابع می‌توانید به صورت مختصر متغیر تعریف کنید و جهت تعریف متغیر به‌صورت عمومی باید از کلید واژه var استفاده کنید.\nبهتر است برای تعریف متغیر داخل تابع از روش مختصر استفاده کنید و متغیر با var بصورت عمومی در بدنه کد باشد.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7var s string = \u0026#34;Hello World\u0026#34; 8 9func main() { 10\tfmt.Println(s) 11} 1.5.1.4 تعریف چند متغیر در یک خط # در زبان گو شما می‌توانید همزمان چند متغیر را در یک خط تعریف کنید که در زیر یک نمونه کد مثال زدیم :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\ta, b, c := \u0026#34;hello\u0026#34;, 1, 1.5 7\tvar d, e, f = \u0026#34;world\u0026#34;, 13, 24 8\tfmt.Println(a, b, c, d, e, f) 9} 1$ go run main.go 2hello 1 1.5 world 13 24 1.5.1.5 تعریف متغیر با مقدار پیش‌فرض # در کد زیر ما یکسری متغیر با تایپ‌های مختلف تعریف کردیم که با مقدار پیش‌فرض ایجاد شده‌اند.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 var i int 7 var f float32 8 var b bool 9 var s string 10 fmt.Printf(\u0026#34;%v %v %v %q\\n\u0026#34;, i, f, b, s) //0 0 false \u0026#34;\u0026#34; 11} 1.5.2 مقدار ثابت (Constant) # ثابت (Constant)‌ها بر خلاف متغیر‌ها که با کلید واژه var تعریف می‌شود, با کلید واژه const تعریف می‌شوند با این تفاوت که ثابت‌ها در طول اجرای کد مقدارشان غیرقابل تغییر هست به انگلیسی Immutable, و تضمین می‌کنند هیچ چیزی در طول اجرای برنامه, باعث تغییر مقدار ثابت نشود.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7const s string = \u0026#34;Hello World\u0026#34; 8 9func main() { 10\tfmt.Println(s) 11} 1$ go run main.go 2Hello World همانطور که در مثال فوق گفتیم شما نمی‌توانید ثابت‌ها را مجددا مقدار دهی کنید. در مثال زیر خطایی که بعد از مقدار دهی دوباره یک ثابت در زمان اجرا رخ داده است را قرار دادیم :\n1package main 2 3func main() { 4 const a int = 8 5 a = 9 6} 1$ go run main.go 2main.go:5:cannot assign to a 1.5.2.1 تعریف Constant بدون نیاز به تعیین تایپ # در تعریف ثابت‌ها همانند متغیر ها شما می‌توانید یک ثابت بدون تعیین تایپ تعریف کنید و زبان گو در زمان اجرا با توجه به مقدار اختصاص داده شده به ثابت شما, تایپ را تشخیص می دهد.\n1const a = 1 //Default hidden type is int 2const b = \u0026#34;circle\u0026#34; //Default hidden type is string 3const c = 5.4 //Default hidden type is float64 4const d = true //Default hidden type is bool 5const e = \u0026#39;a\u0026#39; //Default hidden type is rune 6const f = 3+5i //Default hidden type is complex128 1.5.3 نحوه مشاهده تایپ متغیر یا Constant # در مثال زیر ما با استفاده از یکی از توابع پکیج fmt نوع و مقدار متغیر یا ثابت ها را چاپ کردیم.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5// Named untyped constant 6const a = 123 //Default hidden type is int 7const b = \u0026#34;circle\u0026#34; //Default hidden type is string 8const c = 5.6 //Default hidden type is float64 9const d = true //Default hidden type is bool 10const e = \u0026#39;a\u0026#39; //Default hidden type is rune 11const f = 3 + 5i //Default hidden type is complex8 12 13var u = 123 //Default hidden type is int 14var v = \u0026#34;circle\u0026#34; //Default hidden type is string 15var w = 5.6 //Default hidden type is float64 16var x = true //Default hidden type is bool 17var y = \u0026#39;a\u0026#39; //Default hidden type is rune 18var z = 3 + 5i //Default hidden type is complex128 19 20func main() { 21\tfmt.Println(\u0026#34;\u0026#34;) 22\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, a, a) 23\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, b, b) 24\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, c, c) 25\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, d, d) 26\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, e, e) 27\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, f, f) 28 29\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, u, u) 30\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, v, v) 31\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, w, w) 32\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, x, x) 33\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, y, y) 34\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, z, z) 35} 1.5.3.1 استفاده از iota در constant # شناسه iota فقط با ثابت‌ها قابل استفاده است و با آن می‌توانید اعداد auto increment ایجاد کنید.\nایجاد auto increment بدون iota :\n1const ( 2 a = 0 3 b = 1 4 c = 2 5) ایجاد auto increment با iota :\n1const ( 2 a = iota // 0 3 b // 1 4 c // 2 5) توجه کنید مقدار پیش‌فرض iota صفر, و ثابت ما از نوع int است. 1.5.3.2 نحوه ایجاد enum # از iota و ثابت برای ایجاد enum ها هم می‌توان استفاده کرد که در مثال زیر یک نمونه کد برای ایجاد enum را نیز قرار داده‌ایم.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type Size uint8 6 7const ( 8\tsmall Size = iota 9\tmedium 10\tlarge 11\textraLarge 12) 13 14func main() { 15\tfmt.Println(small) 16\tfmt.Println(medium) 17\tfmt.Println(large) 18\tfmt.Println(extraLarge) 19} 1$ go run main.go 20 31 42 53 1.5.3.3 نادیده گرفتن مقدار اول iota # وقتی که داریم از iota استفاده می‌کنیم شاید هنگام استفاده از auto increament نیاز باشد مقدار اول را نادیده بگیریم. برای اینکار می‌توان از _ استفاده کرد به شکل زیر :\n1const ( 2 _ = iota // ignore 3 a // 1 4 b // 2 5 c // 3 6) 1.5.3.4 خودآزمون iota # خروجی کد زیر را در ذهن محاسبه کنید و با اجرای کد صحت آن را بررسی کنید.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tconst ( 7\tA = iota 8\tB 9\tC 10\tD = B + C 11\tE 12\tF 13\tG = iota 14\tH 15\tI = H 16\tJ 17\tK 18\t) 19\tfmt.Println(A, B, C, D, E, F, G, H, I, J, K) 20} 1.5.4 قوانین نام‌گذاری متغیر و constant # در زیر ما یکسری قوانین جهت نام‌گذاری متغیر و تابت‌ها تعریف کرده‌ایم :\nنام متغیر یا ثابت باید با یک حرف انگلیسی یا _ شروع شود. نام‌ها می‌توانند ترکیبی از اعداد و حروف انگلیسی یا _ باشد. زبان گو به حروف بزرگ و کوچک در نام ها حساس است و اگر شما hello یا Hello را تعریف کنید, ۲ متغیر یا ثابت متفاوت محسوب می‌شوند. محدودیتی در تعداد حروف نام‌ها وجود ندارد ولی بهتر است از یک تعداد مطلوب و مشخصی برای نام‌ها استفاده کنید. توجه داشته باشید اصولا اسم ثابت‌ها را با حروف بزرگ و خارج از توابع تعریف می‌کنند.\nبا تعریف کردن ثابت‌ها با حروف بزرگ, هنگام استفاده مشخص‌تر خواهند بود. از آنجایی که ثابت‌ها فقط امکان read یا همان خواندن را می‌دهند ممکن است در قسمت‌های مختلف به آن مقادیر نیاز داشته باشیم. به دلیل اینکه با هر بار فراخوانی تابع, کامپایلر عملیات مقدار دهی ثابت را دوباره انجام می‌دهد, بهتر است آن را خارج از تابع تعریف کنیم. "},{"id":13,"href":"/chapter-1/go-zero-values/","title":"1.6 مقادیر صفر تایپ‌ها (zero values)","section":"فصل اول: آشنایی با مفاهیم گو","content":"در جدول زیر فهرست تمامی تایپ‌ها را با مقادیر صفرشان (پیش‌فرض) قرار دادیم:\nتایپ مقدار پیش فرض یا مقدار صفر int 0 int8 0 int16 0 int32 0 int64 0 uint 0 uint8 0 uint16 0 uint32 0 uint64 0 uintptr 0 float32 0 float64 0 complex64 0+0i complex128 0+0i bool false string \u0026quot;\u0026quot; interface nil slice nil channel nil map nil pointer nil function nil struct براساس مقدار پیش فرض فیلدها نمونه کد نمایش مقدار صفر تایپ‌ها:\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7func main() { 8\tvar ( 9\ta int 10\tb int8 11\tc int16 12\td int32 13\te int64 14\tf uint 15\tg uint8 16\th uint16 17\ti uint32 18\tj uint64 19\tk uintptr 20\tl float32 21\tm float64 22\tn complex64 23\to complex128 24\tp bool 25\tq string 26\tr interface{} 27\ts []int 28\tt chan int 29\tu map[string]int 30\tv *int 31\tw func() 32\tx struct{} 33\ty struct { 34\tya int 35\tyb bool 36\tyc rune 37\t} 38\t) 39 40\tfmt.Println(\u0026#34;int:\u0026#34;, a) 41\tfmt.Println(\u0026#34;int8:\u0026#34;, b) 42\tfmt.Println(\u0026#34;int16:\u0026#34;, c) 43\tfmt.Println(\u0026#34;int32:\u0026#34;, d) 44\tfmt.Println(\u0026#34;int64:\u0026#34;, e) 45\tfmt.Println(\u0026#34;uint:\u0026#34;, f) 46\tfmt.Println(\u0026#34;uint8:\u0026#34;, g) 47\tfmt.Println(\u0026#34;uint16:\u0026#34;, h) 48\tfmt.Println(\u0026#34;uint32:\u0026#34;, i) 49\tfmt.Println(\u0026#34;uint64:\u0026#34;, j) 50\tfmt.Println(\u0026#34;uintptr:\u0026#34;, k) 51\tfmt.Println(\u0026#34;float32:\u0026#34;, l) 52\tfmt.Println(\u0026#34;float64:\u0026#34;, m) 53\tfmt.Println(\u0026#34;complex64:\u0026#34;, n) 54\tfmt.Println(\u0026#34;complex128:\u0026#34;, o) 55\tfmt.Println(\u0026#34;bool:\u0026#34;, p) 56\tfmt.Println(\u0026#34;string:\u0026#34;, q) 57\tfmt.Println(\u0026#34;interface:\u0026#34;, r) 58\tfmt.Println(\u0026#34;slice:\u0026#34;, s) 59\tfmt.Println(\u0026#34;channel:\u0026#34;, t) 60\tfmt.Println(\u0026#34;map:\u0026#34;, u) 61\tfmt.Println(\u0026#34;pointer:\u0026#34;, v) 62\tfmt.Println(\u0026#34;function:\u0026#34;, w) 63\tfmt.Println(\u0026#34;struct:\u0026#34;, x) 64\tfmt.Println(\u0026#34;struct:\u0026#34;, y) 65} "},{"id":14,"href":"/chapter-1/go-function/","title":"1.7 تابع (function)","section":"فصل اول: آشنایی با مفاهیم گو","content":" 1.7.1 تابع چیست؟ # در برنامه‌نویسی، تابع به تکه کدهایی گفته می‌شود که برای انجام عملی خاص استفاده می‌شوند. به کمک توابع می‌توانیم تکه کدها را از یکدیگر جدا کنیم و از تکرار کدها جلوگیری کنیم.\nهمانند شکل زیر تابع مانند یک جعبه (یا قطعه کد) است. که یک مقدار ورودی گرفته و روی آن پردازش‌هایی انجام می‌دهد و یک خروجی تولید می‌کند. تابع می‌تواند هر چندتا ورودی یا خروجی داشته باشد. 1.7.1.1 چرا از توابع در برنامه نویسی استفاده می‌کنیم؟ # با استفاده از توابع، می‌توانیم یک قطعه کد را یک بار بنویسیم و چندین بار از آن استفاده کنیم. با استفاده از توابع، حجم کدنویسی ما کم‌تر می‌شود و سرعت توسعه نرم‌افزار بیشتر می‌شود. توابع به ما کمک می‌کنند تا کد خود را به تکه‌هایی کوچک‌تر تقسیم کنیم تا برنامه ی ما خوانا و قابل درک‌تر باشد. همچنین نگهداری و اشکال زدایی کد را آسان‌تر می‌کند. 1.7.2 توابع در زبان گولنگ # توابع یکی از قابلیت‌های مهم هر زبانی محسوب می‌شوند. توابع در گولنگ داری سینتکس ساده‌ای هستند.\n1.7.2.1 تعریف یک تابع # 1func function_name( [Parameter-list] ) [return_types] { 2 3 // body of the function 4 5} func - با این کلید واژه یک تابع تعریف می‌کنیم. function_name - نام تابع باید یکتا و در طول برنامه منحصر به فرد باشد. Parameter-list - پارامترهای ورودی در این قسمت تعریف می‌شوند. پارامترها اختیاری هستند یعنی ممکن است یک تابع هیچ پارامتری نداشته باشد. Return_type - نوع داده‌های بازگشتی را در این قسمت مشخص می‌کنیم و در برخی توابع عملیات موردنظر را بدون بازگرداندن مقداری انجام می‌دهند در این توابع نیازی به تعیین return_type نیست. Function Body - این قسمت شامل کدهایی است که نشان می‌دهد تابع چه کارهایی انجام می‌دهد. 1.7.2.1.1 مثال # 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func plus(a int, b int) int { 6\treturn a + b 7} 8 9func main() { 10\tfmt.Println(plus(4, 13)) 11} 1$ go run func.go 217 در اینجا یک تابع با نام plus تعریف کردیم که دو پارامتر a, b را با نوع داده int دریافت می‌کند و جمع این دو عدد را حساب می‌کند. توجه کنید که همیشه باید نوع داده را مشخص کنیم. بعد از تعریف پارامترهای ورودی و قبل از قرار دادن کد داخل براکت int را می‌بینید که نوع خروجی داده را مشخص می‌کند، یعنی خروجی این تابع باید از نوع int باشد. برای صدا زدن توابع کافی است نام تابع رو همراه با پرانتز باز و بسته تایپ کنید, برای مثال ()plus. در صورتی که پارامترهای ورودی از یک نوع باشند بجای تعریف نوع به‌صورت تکی، می‌توانیم نوع داده را در آخر همه پارامترهای هم نوع مشخص کنیم.\n1func plus(a, b int) 2// or 3func name(a string, b,c int) 1.7.2.1.2 الگو دیگر تعریف تابع: # 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tplus := func (a int, b int) int { 7\treturn a + b 8\t} 9\tfmt.Println(plus(3, 4)) 10} 1$ go run main.go 27 1.7.3 قوانین نام گذاری تابع در گولنگ # نام تابع باید با یک حرف شروع شود. نام تابع فقط می‌تواند شامل حروف-عدد و underscores باشد. (A-z, 0-9, _ ) نام تابع به حروف کوچک و بزرگ حساس است. در نام‌گذاری تابع از فاصله نمی‌توانیم استفاده کنیم. ‬1.7.4 توابع چند بازگشتی در گولنگ (Multiple results) # همچنین در گولنگ توابع می‌توانند چندین مقادیر را برگردانند.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func vals() (int, int) { 6 return 3, 7 7} 8 9func main() { 10 11 a, b := vals() 12 fmt.Println(a) 13 fmt.Println(b) 14 15 _, c := vals() 16 fmt.Println(c) 17} 1$ go run main.go 23 37 47 در کد بالا تابعی ساختیم با اسم vals که دو خروجی از نوع int دارد بنابراین نوع تعریف توابع چندبازگشتی متفاوت است و بصورت (data-type, data-type, \u0026hellip; ) است. در مثال اول ما با کمک دو متغیر a,b دو خروجی تابع vals را دریافت کردیم. در مثال دوم ما با استفاده از _ blank identifier از دریافت یا استخراج خروجی اول صرف نظر کردیم و فقط خروجی دوم با متغیر c را دریافت کردیم. در توابع چند بازگشتی خروجی آنها را باید با , از هم جدا کرد 1.7.4.1 مقادیر بازگشتی نام گذاری شده (Named Return Values) # در گولنگ می‌توانیم مقدار بازگشتی یک تابع را نامگذاری کنیم. به مثال زیر توجه کنید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func split(sum int) (x, y int) { 6\tx = sum * 4 / 9 7\ty = sum - x 8\treturn 9} 10 11func main() { 12\tfmt.Println(split(17)) 13} 1$ go run main.go 27 10 ما در این تابع مقدار بازگشتی را x, y از نوع int نام گذاری می‌کنیم. در اینجا یک دستور return بدون تعیین آرگومان بازگشتی، مقادیر نام گذاری شده را باز می‌گرداند، که به عنوان Naked return شناخته می‌شود. از naked return باید در توابع کوتاه مانند مثال بالا استفاده شود. استفاده آن در تابع طولانی منجر به کاهش خوانایی کد می شود. 1.7.5 توابع متنوع در گولنگ (Variadic Functions) # یکی از قابلیت‌های گو وجود توابع متنوع است. منظور از توابع متنوع توابعی هستند که بدون محدودیت پارامتر دریافت می‌کنند (این نکته رو در نظر بگیرین که نباید تایپ ورودی‌ها با یکدیگر فرق کند، برای مثال همه باید int باشند). ‍‍\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func sum(nums ...int) { 6 fmt.Print(nums, \u0026#34; \u0026#34;) 7 total := 0 8 9 for _, num := range nums { 10 total += num 11 } 12 fmt.Println(total) 13} 14 15func main() { 16 17 sum(1, 2) 18 sum(1, 2, 3) 19 20 nums := []int{1, 2, 3, 4} 21 sum(nums...) 22} 1$ go run variadic-functions.go 2[1 2] 3 3[1 2 3] 6 4[1 2 3 4] 10 در اینجا تابعی تعریف کردیم که تعداد دلخواهی از آرگومان‌ها از نوع int را به کمک \u0026hellip; (بهش میگن Ellipsis) که قبل از نوع داده قرار گرفته به داخل تابع منتقل می‌کند. برای صدا زدن این توابع می‌توان به روش sum(num1, num2, \u0026hellip;) عمل کرد. اگر شما داده‌ای با نوع slice دارید می‌توانید آن را به کمک اپراتور \u0026hellip;(Ellipsis) به صورت sum(nums\u0026hellip;) به داخل تابع انتقال بدید. 1.7.6 توابع ناشناس در گولنگ (Anonymous Functions) # در زبان گولنگ می‌توانیم تابع بدون نام تعریف کنیم، که به عنوان توابع ناشناس شناخته می‌شوند.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 7 // anonymous function 8 var sum = func(n1, n2 int) int { 9 sum := n1 + n2 10 11 return sum 12 } 13 14 // function call 15 result := sum(5, 3) 16 17 fmt.Println(\u0026#34;Sum is:\u0026#34;, result) 18 19} 1$ go run main.go 2Sum is: 8 از آنجایی که توابع ناشناس نامی ندارد ما در بعضی اوقات آن‌ها را به یک متغیر اختصاص می‌دهیم سپس از نام متغیر برای فراخوانی تابع استفاده می‌کنیم. در این مثال می‌بینید که ما از sum برای فراخوانی تابع استفاده می‌کنیم. مانند توابع معمولی ما می‌توانیم برای تابع ناشناس پارامتر تعریف کنیم و همچنین مقداری را از تابع برگردانیم در این مثال تابع دو مقدار با نوع داده int دریافت می‌کنید و یک خروجی با نوع int دارد. تابع ناشناس را می‌توان برای عملکردهایی که نیازی به نام‌گذاری ندارند و معمولا برای استفاده کوتاه مدت هست، استفاده کرد. اما یکی از موارد کاربردی توابع ناشناس در گولنگ پاس دادن آن‌ها به توابعی هستند که تابعی را تحت عنوان پارامتر ورودی دریافت میکنند. در مثال زیر ما یک تابع تعریف کردیم که در پارامتر سوم یک تابع دریافت می‌کند که باید دو ورودی int و یک خروجی int داشته باشد.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func add10AndSum(num1 int, num2 int, sum func(n1, n2 int) int) { 6 result := sum(num1+10, num2+10) 7 fmt.Println(\u0026#34;Sum by adding 10 is:\u0026#34;, result) 8} 9 10func main() { 11 add10AndSum(5, 3, func(n1, n2 int) int { 12 sum := n1 + n2 13 14 return sum 15 }) 16} 1$ go run main.go 2Sum by adding 10 is: 28 1.7.7 توابع از پیش تعریف شده (Built-in Function) # در گولنگ علاوه بر تابع‌هایی که توسط کاربر تعریف می‌شود یکسری توابع وجود دارد که از قبل تعریف شده‌اند که طراحان این زبان برای سهولت کار برنامه‌نویسان این توابع را نوشته‌اند و آن را همراه زبان گولنگ ارائه می‌دهند.\nhttps://book.gofarsi.ir/chapter-1/go-builtins/\n1.7.7 کلوژر(Function closure) # یک نوع دیگری از anonymous function ها در زبان گولنگ، کلوژر ها هستند. به بیان ساده زمانی که یک فانکشن درون خودش، متغیر هایی که اسکوپ آنها خارج از اسکوپ خودش قرار دارد استفاده کند. کلوژر میگوییم.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tnumber := 1 7 8\tfunc() { 9\tfmt.Println(number * 2) 10\t}() 11} در مثال بالا ما یک anonymous function داریم که درون خودش از متغیر اسکوپی که خارج از خودش قرار دارد استفاده کرده است. به این عمل کلوژر می گوییم.\nزمانی که از کلوژر ها استفاده می کنید. برخی مواقع بهتر است به‌جای اینکه به‌صورت مستقیم به متغیر اسکوپ خارجی دسترسی داشته باشید، در پارامتر های ورودی مقدار را دریافت کنید. به مثال زیر دقت کنید(در این مثال از concurrency استفاده کردیم. اگر آشنایی ندارید با مطالعه مقدمه ای از فصل سوم مثال را متوجه می شوید)\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;time\u0026#34; 6) 7 8func main() { 9\tfor i := 0; i \u0026lt; 10; i++ { 10\tgo func() { 11\tfmt.Println(i) 12\t}() 13\t} 14 15\ttime.Sleep(time.Second * 1) 16} خروجی کد برخلاف چیزی که تصور می کنیم به این شکل است:\n1$ go run main.go 210 310 410 510 610 710 810 910 1010 1110 این اتفاق به این دلیل می افتد چون کلوژر ها به‌صورت مستقیم به مقدار اسکوپ بالایی خود دسترسی دارند. قبل از اینکه گوروتین ها مقدار را چاپ کنند حلقه به انتها می رسد و مقدار i برابر با 10 می شود. برای همین در خروجی همه گوروتین ها مقدار 10 چاپ می شود. برای حل این مشکل مقدار i را در پارامتر فانکشن دریافت می کنیم:\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;time\u0026#34; 6) 7 8func main() { 9\tfor i := 0; i \u0026lt; 10; i++ { 10\tgo func(num int) { 11\tfmt.Println(num) 12\t}(i) 13\t} 14 15\ttime.Sleep(time.Second * 1) 16} پس زمانی که از کلوژر ها استفاده می کنید به این نکات دقت کنید.\n"},{"id":15,"href":"/chapter-1/go-array/","title":"1.8 آرایه و slice","section":"فصل اول: آشنایی با مفاهیم گو","content":"آرایه و slice دو نوع تایپ با یک وجه اشتراک در زبان گو هستند ولی این دو نوع تایپ یکسری تفاوت‌هایی نیز با هم دارند که در ادامه به آن‌ها می‌پردازیم.\n1.8.1 تعریف آرایه # آرایه یکی از عمومی‌ترین تایپ‌ها در زبان‌های برنامه‌نویسی آرایه‌ها هستند که برای نگه داری گروهی مقادیر از یک نوع تایپ استفاده می‌شود. برای دسترسی به هر کدام از مقادیر درون آرایه باید از اندیس استفاده کرد. معمولا برای تعریف آرایه تعداد مشخص و ثابتی را برای تعداد مقادیر مشخص میکنید. یعنی این آرایه قرار است چند تا مقدار نگه داری کند.\nدر مثال زیر یک نمونه کد در خصوص چگونگی تعریف آرایه قرار داده‌ایم :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tarrayInts := [5]int{1, 25, 12354, 654, 32} 7\tfmt.Println(arrayInts) 8} 1$ go run array.go 2[1 25 12354 654 32] یک متغیر کوتاه از نوع آرایه با نام arrayInts تعریف کردیم. ظرفیت آرایه را با عدد ۵ تعیین کردیم (یعنی این آرایه فقط ۵ تا مقدار بیشتر نگه داری نمی‌کند) سپس تایپ آرایه را از نوع int مشخص کردیم. در نهایت در همانجا آرایه را مقدار دهی کردیم. در زبان گو مقدار دهی با باز کردن {} به انگلیسی curly bracket انجام می‌شود. 1.8.2 مفهوم اندازه و ظرفیت (size, capacity) # در آرایه ما ۲ تا مفهوم داریم: اندازه و ظرفیت که از عنوان این مفهوم مشخص است آرایه دارای یک اندازه و ظرفیت مشخصی است و اگر شما بیشتر از ظرفیت و اندازه تعیین شده مقدار دهی کنید با خطا مواجه خواهید شد.\nدر آرایه ظرفیت به نسبت اندازه تعیین می‌شود. 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tarrayString := [3]string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;} 7\tfmt.Println(arrayString) 8} 1$ go run array.go 2./prog.go:6:42: index 3 is out of bounds (\u0026gt;= 3) در کد فوق ما یک آرایه با اندازه ۳ تعریف کردیم و ۴ تا مقدار داخلش قرار دادیم و پس از اجرا, با خطای تعداد مقادیر بیشتر از اندازه و ظرفیت می باشد مواجه شدیم.\n1.8.2.1 تابع len و cap # برای آرایه و slice ما ۲ تا تابع داریم که می‌توانیم اندازه و ظرفیت یک آرایه یا slice را بگیریم.\nتابع len یکی از توابع بسیار کاربردی و پراستفاده هنگام کار با آرایه یا slice است که می‌توانید اندازه آرایه یا slice را بگیرید. تابع cap ظرفیت آرایه و slice را نمایش می‌دهد. 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tarrayString := [3]string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;} 7\tfmt.Printf(\u0026#34;array %v, len %d, cap %d\u0026#34;, arrayString, len(arrayString), cap(arrayString)) 8} 1$ go run main.go 2array [a b c], len 3, cap 3 1.8.3 تعریف آرایه و مقدارهی # در مثال زیر ما یک آرایه با مقدار 5 تعریف کردیم و قصد داریم در ادامه کد، آرایه رو مقداردهی کنیم.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tnums := [5]int{} 7\tfmt.Printf(\u0026#34;array nums values %v, len %d, cap %d\u0026#34;, nums, len(nums), cap(nums)) 8 9\tnums[0] = 1 10\tnums[1] = 2 11\tnums[2] = 10 12\tnums[4] = 999 13\t14\tfmt.Println(\u0026#34;\u0026#34;) 15\tfmt.Printf(\u0026#34;array nums values %v, len %d, cap %d\u0026#34;, nums, len(nums), cap(nums)) 16} 1$ go run main.go 2array nums values [0 0 0 0 0], len 5, cap 5 3array nums values [1 2 10 0 999], len 5, cap 5 در کد فوق در ابتدا ما یک آرایه بدون مقدار تعریف کردیم. سپس با استفاده از اندیس مقدار را در خانه مشخص قرار دادیم. 1.8.3.1 تعریف آرایه با اندازه تعیین شده توسط کامپایلر (شما اندازه رو بهش نمیدین.) # شما در زبان گو می‌توانید با استفاده از ... (Ellipsis) یک آرایه با اندازه مشخص شده توسط کامپایلر تعریف کنید.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tnums := [...]int{1, 25, 45, 8797, 78, 879, 541, 11} 7\tfmt.Printf(\u0026#34;array nums values %v, len %d, cap %d\u0026#34;, nums, len(nums), cap(nums)) 8} 1$ go run main.go 2array nums values [1 25 45 8797 78 879 541 11], len 8, cap 8 توجه کنید زمانی که ... (Ellipsis) برای تعریف آرایه استفاده می‌کنید فقط در همان لحظه تعریف می‌توانید آرایه رو مقدار دهی کنید. 1.8.3.2 تعریف آرایه دو بعدی یا چند بعدی # در زبان گو همانند سایر زبان‌ها می‌توانید آرایه دو بعدی یا چند بعدی تعریف کنید. این نوع آرایه‌ها برای پیاده‌سازی ماتریس یا یکسری سناریوهای توسعه کاربردی مناسب هستند.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tnums := [2][2][2]int{{{1, 2}, {2, 3}}, {{4, 5}, {6, 7}}} 7\tfmt.Printf(\u0026#34;array nums values %v, len %d, cap %d\u0026#34;, nums, len(nums), cap(nums)) 8} 1$ go run main.go 2array nums values [[[1 2] [2 3]] [[4 5] [6 7]]], len 2, cap 2 1.8.3.3 مقایسه آرایه‌ها # در کد زیر ما یک نمونه از مقایسه آرایه‌ها را قرار داده‌ایم که این مقایسه براساس تایپ، اندازه و مقادیر در نظر گرفته شده است.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tnums := [2]int{1, 2} 7\tnums2 := [2]int{1, 3} 8\tnums3 := [2]int{1, 2} 9\tnums4 := [3]int{1, 2, 3} 10\tchars := [2]string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;} 11 12\tfmt.Println(nums == nums2) // false 13\tfmt.Println(nums == nums3) // true 14\tfmt.Println(nums == nums4) // error: invalid operation: nums == nums4 (mismatched types [2]int and [3]int) 15\tfmt.Println(nums == chars) // error: invalid operation: nums == chars (mismatched types [2]int and [2]string) 16} 1.8.4 برش (slice) # همانطور که می‌دانید آرایه یکی از مهم‌ترین عناوین در زبان‌های برنامه‌نویسی است، اما در زبان گو slice نسبت به آرایه بسیار پر استفاده و کاربردی‌تر است. اگر بخواهیم خیلی ساده slice را توصیف کنیم در واقع \u0026ldquo;یک slice به عنوان یک بخش بهم پیوسته از یک آرایه تعریف می‌شود که شما می‌توانید المنت‌ها را در حال اجرا افزایش یا کاهش دهید بدون آنکه ظرفیت و اندازه آن را مشخص کنید.\u0026rdquo;\nاما این سوال پیش می‌آید علت اینکه slice به نسبت آرایه کاربرد بیشتری دارد چیست؟ آرایه دارای برخی از محدودیت‌ها علی الخصوص، اندازه ثابت می‌باشد اما در slice شما این محدودیت‌ها را نخواهید داشت و خیلی ساده می‌توانید المنت‌ها را افزایش، حذف و حتی کپی کنید.\nدر زبان گو slice‌ها یک پارچگی آرایه را حفظ می‌کنند و کار با آرایه خیلی ساده و آسان‌تر خواهد شد. 1.8.4.1 تعریف یک slice با اندازه مشخص # شما می توانید با استفاده از تابع make یک slice با اندازه مشخص تعریف کنید.\n1slice := make([]int, 5) 2 3fmt.Println(len(slice)) // Print 5 4 5fmt.Println(cap(slice)) // Print 5 1.8.4.2 تعریف یک slice با اندازه و ظرفیت مشخص # شما می‌توانید با استفاده از تابع make یک slice با ظرفیت و اندازه مشخص تعریف کنید.\n1slice := make([]int, 3, 5) 2 3fmt.Println(len(slice)) // Print 3 4 5fmt.Println(cap(slice)) // Print 5 توجه کنید مقدار ظرفیت نباید کمتر از مقدار اندازه باشد.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\ttest := make([]int, 5, 4) 7\tfmt.Println(test) 8} 1$ go run main.go 2./main.go:6:22: invalid argument: length and capacity swapped 1.8.4.3 تعریف یک slice با متغیر کوتاه short variable declaration # شما خیلی ساده می‌توانید یک slice را توسط متغیر کوتاه ایجاد کنید.\n1slice := []string{\u0026#34;Red\u0026#34;, \u0026#34;Blue\u0026#34;, \u0026#34;Green\u0026#34;, \u0026#34;Yellow\u0026#34;, \u0026#34;Pink\u0026#34;} 2 3fmt.Println(len(slice)) //Print 5 4 5fmt.Println(cap(slice)) //Print 5 6 7intSlice:= []int{10, 20, 30} 8 9fmt.Println(len(intSlice)) //Print 3 10 11fmt.Println(cap(intSlice)) //Print 3 1.8.4.4 تعریف یک slice با موقعیت‌های شاخص # شما می‌توانید یک slice را با موقعیت‌های شاخص ایجاد کنید که n تا المنت با مقدار پیش‌فرض ایجاد می‌کند و در آخر x را به آخر slice اضافه می‌کند. (در مثال زیر ۹۹ تا المنت با مقدار 0 و در اخر یک المنت با مقدار 88) درست می‌کند.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\ttest := []int{99: 88} 7\tfmt.Println(len(test), cap(test)) 8} 1.8.4.5 تعریف یک slice خالی # شما می‌توانید خیلی ساده یک slice خالی ایجاد کنید.\n1sliceOne := make([]int, 0) 2 3sliceTwo := []int{} 4 5fmt.Println(sliceOne == nil) // print false 6 7fmt.Println(len(sliceOne)) // print 0 8 9fmt.Println(cap(sliceOne)) // print 0 10 11fmt.Println(sliceTwo == nil) // print false 12 13fmt.Println(len(sliceTwo)) // print 0 14 15fmt.Println(cap(sliceTwo)) // print 0 1.8.5 مقدار دهی مجدد یکی از المنت های slice یا آرایه # شما خیلی راحت می‌توانید مقدار یکی از المنت‌های slice یا آرایه را مقدار دهی کنید.\n1slice := []int{10, 20, 30, 40} 2 3fmt.Println(slice) //print [10 20 30 40] 4 5slice[1] = 25 6 7fmt.Println(slice) // print [10 25 30 40] 1.8.6 ایجاد یک slice جدید بر اساس یک slice از پیش تعریف شده # شما می‌توانید یک slice جدید را بر اساس یک slice از پیش تعریف شده ایجاد کنید.\n1x := []int{10, 20, 30, 40, 50} 2 3fmt.Println(x) // Print [10 20 30 40 50] 4 5fmt.Println(len(x)) // Print 5 6 7fmt.Println(cap(x)) // Print 5 8 9y := x[1:3] 10 11fmt.Println(y) //Print [20 30] 12 13fmt.Println(len(y)) //Print 2 14 15fmt.Println(cap(y)) //Print 4 ما یک متغیر با نام x با ۵ تا المنت مقدار دهی شده تعریف کردیم. سپس یک متغیر کوتاه با نام y تعریف کردیم که متغیر x را داخلش قرار دادیم. سپس به متغیر x گفتیم از اندیس ۱ تا ۳ را به y اختصاص بدهد. توجه کنید اتفاقی که مثال بالا رخ داد این بود که ما اندازه و ظرفیت جدیدی برای متغیر y تعیین کردیم.\nLen: 3 - 1 = 2 Cap: 5 - 1 = 4\n1.8.7 خطای index out of range در slice # یک slice فقط با توجه به اندازه و اندیس‌هایش امکان دسترسی و مقدار دهی مجدد المنت هایش را می‌دهد، اما اگر شما بخواهید خارج از اندازه تعیین شده جهت مقداری دهی و یا دسترسی به slice اقدام کنید با خطای index out of range مواجه خواهید شد.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tslice := []int{10, 20, 30, 40, 50} 7\tnewSlice := slice[1:3] 8\tnewSlice[3] = 45 9\tfmt.Println(newSlice) 10} 1$ go run main.go 2panic: runtime error: index out of range [3] with length 2 3 4goroutine 1 [running]: 5main.main() 6\t/tmp/sandbox548843089/prog.go:8 +0x5b 1.8.8 افرودن (append) المنت‌های یک slice # شما خیلی ساده می‌توانید با استفاده از تابع append به المنت‌های یک slice بیفزایید.\n1slice := []int{10, 20, 30, 40, 50} 2 3newSlice := slice[1:3] 4 5fmt.Println(len(newSlice)) // Print 2 6 7fmt.Println(cap(newSlice)) // Print 4 8 9newSlice = append(newSlice, 60) 10 11fmt.Println(len(newSlice)) // Print 3 12 13fmt.Println(cap(newSlice)) // Print 4 در کد زیر اتفاقی که صورت گرفته است این است که اگر شما ... Ellipsis را بعد از کلمه slice بزارید یعنی دارید می‌گید تمامی المنت‌های داخل slice به newSlice اضافه شود.\n1slice := []int{10, 20, 30, 40, 50} 2 3newSlice := []int{} 4 5newSlice = append(newSlice, slice...) 1.8.9 نحوه حذف یک المنت در slice # برای حذف یک المنت در slice باید بصورت تکنیکی اینکار را انجام دهید چون زبان گو یک روش built-in برای این کار ندارد.\nدر این روش شما باید در ابتدا آخرین المنت را به المنت مورد نظر با استفاده از اندیس کپی کنید. سپس آخرین المنت را از slice حذف کنید. 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tslice := []int{10, 20, 30, 40, 50} 7\tslice[1] = slice[len(slice)-1] 8\tslice = slice[:len(slice)-1] 9\tfmt.Println(slice) 10} یک روش دیگر برای حذف یک المنت از slice استفاده از تابع append است. به مثال زیر توجه کنید. 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tslice := []int{1, 2, 3, 4, 5} 7\tindex := 2 // ایندکس المنتی که میخاییم حذفش کنیم 8\tslice = append(slice[:index], slice[index+1:]...) 9\tfmt.Println(slice) // خروجی: [1 2 4 5] 10} 1.8.10 تابع copy در slice # شما با استفاده از تابع copy می‌توانید یک slice را به slice دیگری کپی کنید.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tsrc := []int{1, 2, 3, 4, 5} 7\tdst := make([]int, 5) 8\tnumberOfElementsCopied := copy(dst, src) 9\tfmt.Println(numberOfElementsCopied, dst) 10} 1$ go run main.go 25 [1 2 3 4 5] 1.8.11 نحوه مرتب کردن (sort) یک slice # برای مرتب کردن یک slice می‌توانید از توابع کتابخانه sort در زبان گو استفاده کنید.\nsort.Ints sort.Float64s sort.Strings 1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;sort\u0026#34; 6) 7 8func main() { 9\ts := []int{4, 2, 3, 1} 10\tsort.Ints(s) 11\tfmt.Println(s) 12} 1$ go run main.go 2[1 2 3 4] 1.8.12 فرق بین آرایه و slice # فرق نوع تعریف آرایه و slice برای تعریف آرایه شما باید داخل براکت [] یک مقداری را قرار دهید. برای تعریف slice هیچ مقداری را داخل براکت [] نباید قرار دهید. 1array := [3]int{10, 20, 30} 2 3slice := []int{10, 20, 30} فرق بین مقدار صفر آرایه و slice مقدار خالی slice ها nil است. مقدار خالی یک آرایه، همان آرایه با المنت‌های مقدار پیش‌فرض است. 1var slice []int32 2var array [2]int32 3 4fmt.Println(slice == nil) // print true 5fmt.Println(len(slice)) // print 0 6fmt.Println(cap(slice)) // print 0 7 8fmt.Println(array) // print [0 0] "},{"id":16,"href":"/chapter-1/go-for/","title":"1.9 حلقه‌ها (for)","section":"فصل اول: آشنایی با مفاهیم گو","content":" 1.9.1 حلقه # حلقه‌ها را در زبان گو به ساده‌ترین شکل ممکن و فقط با استفاده از کلید واژه for و در مدل‌های مختلف (سه‌بخشی، بی نهایت، foreach و \u0026hellip;) می‌توان پیاده‌سازی کرد.\n1.9.2 حلقه سه بخشی # این نمونه که متداول‌ترین نوع حلقه for نیز هستند با استفاده از سه‌ بخش:\nمقداردهی شرط شمارنده ایجاد می‌شوند.\n1for initialization ; condition ; counter { 2\t//loop codes 3} در مثال زیر نمونه‌ای از این حلقه‌ قابل مشاهده و اجرا است.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tsum := 0 7\tfor i := 1; i \u0026lt; 10; i++ { 8\tsum += i 9\t} 10 11\tfmt.Println(sum) 12} 1$ go run main.go 245 1.9.3 حلقه while # این مدل حلقه شبیه while در بیشتر زبان ها مثل پایتون و C است. با این تفاوت که پیاده‌سازی آن، تنها با کلیدواژه‌ی for و با حذف بخش مقداردهی و شمارنده حلقه سه‌بخشی انجام می‌گیرد. در واقع در این حلقه تنها یک شرط تعریف می‌شود و تا برقرار بودن آن شرط حلقه اجرا می‌شود. به مثال زیر توجه کنید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\ti := 0 7\tfor i \u0026lt; 10 { 8\tfmt.Println(i) 9\ti++ 10\t} 11} 1$ go run main.go 20 31 42 53 64 75 86 97 108 119 1.9.4 حلقه بی‌نهایت # اگر از حلقه‌ی while که در مثال بالا تعریف کردیم بخش شرط را حذف کنیم چه اتفاقی می‌افتد؟ در این حالت ما یک شرط بی نهایت ساخته‌ایم (شبیه به while(1)) که تا زمانی‌ که برنامه متوقف نشود و یا کدهای داخل حلقه، فرمان خروج از حلقه را ندهند، چرخه ی اجرای حلقه ادامه خواهد یافت.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tsum := 0 7\tfor { 8\tsum++ 9\t} 10 11\tfmt.Println(\u0026#34;this line will never execute\u0026#34;) 12} با اجرای کد بالا خطای تایم‌اوت دریافت خواهید کرد (اگر در playground سایت گو اجراش کنین)، به‌ دلیل اینکه حلقه هیچ‌گاه تمام نمی‌شود.\n1.9.5 حلقه for-range # حلقه for-range یکی از پرکاربردترین حلقه‌ها در زبان گو می‌باشد که شما می‌توانید برای slice، آرایه و map یا رشته از این حلقه استفاده کنید.\n1for index, value := range slice/array {} 1for key, value := range map {} 1.9.5.1 حلقه for-range برای slice و آرایه # شما با استفاده از حلقه for-range می‌توانید به المنت‌های آرایه یا slice و همچنین اندیس‌شان (Index) دسترسی پیدا کنید. دقت کنید ۲ حالت وجود دارد:\n1.9.5.1.1 دسترسی با استفاده از یک کپی از المنت # در کد زیر ما با استفاده از for-range به یک کپی از المنت‌های اسلایس letter دسترسی پیدا کردیم.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 letters := []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;} 7 8 //With index and value 9 fmt.Println(\u0026#34;Both Index and Value\u0026#34;) 10 for i, letter := range letters { 11 fmt.Printf(\u0026#34;Index: %d Value:%s\\n\u0026#34;, i, letter) 12 } 13 14\t//Only value 15 fmt.Println(\u0026#34;\\nOnly value\u0026#34;) 16 for _, letter := range letters { 17 fmt.Printf(\u0026#34;Value: %s\\n\u0026#34;, letter) 18 } 19} 1$ go run main.go 2Both Index and Value 3Index: 0 Value:a 4Index: 1 Value:b 5Index: 2 Value:c 6 7Only value 8Value: a 9Value: b 10Value: c 1.9.5.1.2 دسترسی مستقیم به خانه حافظه المنت # شما با استفاده از اندیس (index) می‌توانید مستقیماً به خانه حافظه المنت دسترسی پیدا کنید و آن المنت رو با استفاده از اندیس (Index) نمایش بدید. به مثال زیر توجه کنید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 letters := []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;} 7 8 fmt.Println(\u0026#34;\\nOnly letter\u0026#34;) 9 for i := range letters { 10 fmt.Printf(\u0026#34;letter: %s\\n\u0026#34;, letters[i]) 11 } 12} 1$go run main.go 2Only letter 3letter: a 4letter: b 5letter: c 1.9.1.2 حلقه for-range برای map # شما با استفاده از حلقه for-range برروی map, میتوانید به کلید و مقدار هر یک از مقادیر map دسترسی پیدا کنید.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 sample := map[string]string{ 7 \u0026#34;a\u0026#34;: \u0026#34;x\u0026#34;, 8 \u0026#34;b\u0026#34;: \u0026#34;y\u0026#34;, 9 } 10 11 //Iterating over all keys and values 12 fmt.Println(\u0026#34;Both Key and Value\u0026#34;) 13 for k, v := range sample { 14 fmt.Printf(\u0026#34;key :%s value: %s\\n\u0026#34;, k, v) 15 } 16 17 //Iterating over only keys 18 fmt.Println(\u0026#34;\\nOnly keys\u0026#34;) 19 for k := range sample { 20 fmt.Printf(\u0026#34;key :%s\\n\u0026#34;, k) 21 } 22 23 //Iterating over only values 24 fmt.Println(\u0026#34;\\nOnly values\u0026#34;) 25 for _, v := range sample { 26 fmt.Printf(\u0026#34;value :%s\\n\u0026#34;, v) 27 } 28} 1$go run main.go 2Both Key and Value 3key :a value: x 4key :b value: y 5 6Only keys 7key :a 8key :b 9 10Only values 11value :x 12value :y 1.9.1.3 حلقه for-range برای رشته (string) # شما با استفاده از حلقه for-range می توانید به هرکدام از کارکترهای رشته دسترسی پیدا کنید.\n1for index, character := range string { 2 //Do something with index and character 3} به کد نمونه زیر توجه کنید :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 sample := \u0026#34;a£b\u0026#34; 7 8 //With index and value 9 fmt.Println(\u0026#34;Both Index and Value\u0026#34;) 10 for i, letter := range sample { 11 fmt.Printf(\u0026#34;Start Index: %d Value:%s\\n\u0026#34;, i, string(letter)) 12 } 13 14 //Only value 15 fmt.Println(\u0026#34;\\nOnly value\u0026#34;) 16 for _, letter := range sample { 17 fmt.Printf(\u0026#34;Value:%s\\n\u0026#34;, string(letter)) 18 } 19 20 //Only index 21 fmt.Println(\u0026#34;\\nOnly Index\u0026#34;) 22 for i := range sample { 23 fmt.Printf(\u0026#34;Start Index: %d\\n\u0026#34;, i) 24 } 25} 1$ go run main.go 2Both Index and Value 3Start Index: 0 Value:a 4Start Index: 1 Value:£ 5Start Index: 3 Value:b 6 7Only value 8Value:a 9Value:£ 10Value:b 11 12Only Index 13Start Index: 0 14Start Index: 1 15Start Index: 3 1.9.6 کلید واژه break # با استفاده از break می‌توان چرخه‌ی اجرای یک حلقه را پایان داد. به عنوان مثال در حلقه بی‌نهایتی که در بخش 1.9.4 مشاهده کردید، می‌توان با تعریف یک شرط خاص از حلقه خارج شد. کد زیر نمونه استفاده از break را نمایش می‌دهد.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tsum := 0 7\tfor { 8\tsum++ 9\tif sum == 10 { 10\tbreak 11\t} 12\t} 13 14\tfmt.Println(sum) 15\tfmt.Println(\u0026#34;now this line will execute\u0026#34;) 16} 1$ go run main.go 210 3now this line will execute 1.9.7 label در حلقه ها # شما با قابلیت label در زبان گو می‌توانید لیبلی را به یک حلقه خاص اختصاص دهید و بعد از چند حلقه تو در تو حلقه مورد نظر را break کنید.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 letters := []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;} 7 8\tfor i := 1; i \u0026lt; 10; i++ { 9 // define a lable with name \u0026#39;second\u0026#39; for this loop 10 second: 11 for i := 2; i \u0026lt; 9; i++ { 12 for _, l := range letters { 13 if l == \u0026#34;b\u0026#34; { 14 // break the loop with second lable 15 break second 16 } 17 } 18 } 19\t} 20} در کد بالا زمانی که از لیبل استفاده نشود سومین حلقه درونی break خواهد شد. اما با استفاده از لیبل‌ها هرکدام از حلقه‌های مورد نظر را می‌توان break کرد.\n1.9.8 کلیدواژه continue # این کلید‌واژه چرخه‌ اجرای حلقه را یک مرحله جلو می‌برد. به این‌ معنی که اگر در حلقه از این کلید‌واژه استفاده شود، کدهای بعد از continue اجرا نشده و چرخه بعدی (گام بعدی) اجرا خواهد شد.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 7\tfor i := 1; i \u0026lt; 10; i++ { 8\tif i%2 == 0 { 9\tcontinue 10\t} 11\tfmt.Println(i) 12\t} 13} 1$ go run main.go 21 33 45 57 69 قابل ذکر است که continue و break در حلقه‌های تو در تو، فقط روی اولین حلقه درونی تاثیر خواهند گذاشت. 1.9.9 خودآزمون حلقه # سوال با استفاده از زبان گو برنامه‌ای بنویسید که سری‌ زیر را ایجاد کند:\n11 222 3333 455555 588888888 613131313131313131313131313 7212121212121212121212121212121212121212121 الگوریتم پاسخ ‍1 + 0 = 1 1 + 1 = 2 2 + 1 = 3 3 + 2 = 5 5 + 3 = 8 8 + 5 = 13 13 + 8 = 21 a + b = c b = a a = c کد پاسخ 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 var ( 7 n = 6 // can define any result count ... 8 a, b, c = 1, 0, 0 9 ) 10 for i := 0; i \u0026lt;= n; i++ { 11 c = a + b 12 for j := 1; j \u0026lt;= c; j++ { 13 fmt.Print(c) 14 } 15 fmt.Println() 16 b, a = a, c 17 } 18} "},{"id":17,"href":"/chapter-1/go-map/","title":"1.10 نقشه map","section":"فصل اول: آشنایی با مفاهیم گو","content":" 1.10.1 مقدمه # نقشه ، یک نوع ساختار داده است. نقشه ها جهت جمع‌آوری و نگهداری مجموعه‌ای از داده‌ها استفاده می‌گردند. نقشه ، از نوع داده‌های انجمنی (هش) بصورت «کلید-مقدار» است. نقشه ، مجموعه‌ای از داده‌ها بصورت جفت‌‌های مرتب‌نشده است. 1.10.2 تعریف # یک مپ شبیه به فرمت زیر است:\n1map[KeyType]ValueType کلمه کلیدی map و بعد نوع کلید و در آخر هم نوع مقدار تعریف می‌شود.\nکلید: برای اشاره به یک مقدار ذخیره شده، نیاز به یک نام‌ داریم و این یعنی «کلید» آن مقدار.\nمقدار کلید در یک مپ، باید یکتا باشد. محدودیت: برای تعریف کلید، از انواع تایپ‌هایی که قابل مقایسه هستند، می‌توان استفاده کرد: Boolean(s) Number(s) String(s) Array(s) Pointer(s) Struct(s) Interface(s) (تا زمانی که از مقادیر مقایسه‌پذیر استفاده می‌کند) از Slice(s) Map(s) Function(s) نمی‌توان برای تعریف «کلید» مپ استفاده کرد. در مپ می‌توان برای کلید از مقدار داخل یک متغیر بهره برد. 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tmyMap := make(map[int]string) 7\tmyKey := 13 8\tmyMap[myKey] = \u0026#34;thirteen\u0026#34; 9\tfmt.Println(myMap) //map[13:thirteen] 10\tfmt.Println(myMap[myKey]) //thirteen 11} مقدار: حاوی داده‌ای است که کلید به آن اشاره می‌کند و برخلاف کلید، هیچ محدودیت برای انتخاب «نوع» آن وجود ندارد، به‌عنوان نمونه می‌توان از یک مپ دیگر برای مقدار استفاده کرد. (مپ‌های تودرتو )\n1map[string]map[int]string 1.10.3 ایجاد و مقداردهی اولیه # مقدار پیش‌فرض برای یک مپ nil می‌باشد. برای مقداردهی مپ‌ ها از روش‌های زیر استفاده می‌شود:\nاستفاده از کلمه کلیدی var 1var sampleMap = map[keyType]valueType{keyName1:value1, keyName2:value2, ...} 2var sampleMap map[keyType]valueType = map[keyType]valueType{} استفاده از علامت =: short variable declaration 1sampleMap := map[keyType]valueType{keyName1:value1, keyName2:value2, ...} استفاده از تابع make 1var sampleMap = make(map[keyType]valueType) 2sampleMap := make(map[keyType]valueType) 1.10.4 مپ با مقدار nil # درصورت تعریف اولیه مپ توسط دستور var sampleMap map[keyType]valueType یک مپ با مقدار nil ساخته می‌شود که نمی‌توان بدون مقداردهی اولیه، روی آن عملیات ارسال و دریافت داده‌ انجام داد:\n1 var sampleMap map[uint8]int 2 sampleMap[13] = 9999999 3 //panic: assignment to entry in nil map برای مقداردهی یک مپ nil که به روش زیر ساخته اید:\n1var m map[string]string از روش‌های زیر می‌توان بهره گرفت:\n1var m map[string]string = map[string]string{} 2m := make(map[string]string) 3m := map[string]string{} 1.10.5 توابع مربوط به مپ # تابع (len): برای برگشت تعداد عناصر داخل مپ از len استفاده می‌شود: 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tvar sampleMap = map[string]bool{} 7\tvar otherMap = make(map[string]uint) 8\tvar nilMap map[bool]bool 9 10\tsampleMap[\u0026#34;condition#1\u0026#34;] = true 11\tsampleMap[\u0026#34;condition#2\u0026#34;] = false 12 13\totherMap[\u0026#34;foo\u0026#34;] = 1 14 15\tfmt.Println(len(sampleMap))\t//2 16\tfmt.Println(len(otherMap))\t//1 17\tfmt.Println(len(nilMap))\t//0 (len nil is zero) 18} مقدار برگشتی برای تابع len روی مپ‌ nil برابر صفر (۰) است.\n1.10.6 عملیات CRUD روی مپ # C : Create برای ایجاد مپ، اغلب از تابع make استفاده می شود:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 animals := make(map[int]string) // nil map of string-int pairs 7 animals[1] = \u0026#34;Gopher\u0026#34; 8 animals[2] = \u0026#34;owl\u0026#34; 9 animals[3] = \u0026#34;cheetah\u0026#34; 10 animals[4] = \u0026#34;eagle\u0026#34; 11 animals[5] = \u0026#34;lion\u0026#34; 12 13 fmt.Println(animals) //map[1:Gopher 2:owl 3:cheetah 4:eagle 5:lion] 14 15} R : Read جهت خواندن مقادیر مپ می‌توان از الگوی زیر استفاده کرد: mapName[\u0026quot;keyName\u0026quot;] مثال:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 animals := make(map[int]string) // nil map of string-int pairs 7 animals[1] = \u0026#34;Gopher\u0026#34; 8 animals[2] = \u0026#34;owl\u0026#34; 9 animals[3] = \u0026#34;cheetah\u0026#34; 10 animals[4] = \u0026#34;eagle\u0026#34; 11 animals[5] = \u0026#34;lion\u0026#34; 12 13 fmt.Println(animals[2]) //owl 14} U : Update برای بروزرسانی مقادیر مپ، از الگوی mapName[keyName] = newValue استفاده می‌شود. مثال:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 animals := make(map[int]string) // nil map of string-int pairs 7 animals[1] = \u0026#34;Gopher\u0026#34; 8 animals[2] = \u0026#34;owl\u0026#34; 9 animals[3] = \u0026#34;cheetah\u0026#34; 10 animals[4] = \u0026#34;eagle\u0026#34; 11 animals[5] = \u0026#34;lion\u0026#34; 12 13 fmt.Println(animals[2]) //owl 14 15 animals[2] = \u0026#34;wolf\u0026#34; 16 17 fmt.Println(animals[2]) //wolf 18} D : Delete جهت حذف مقادیر در مپ، از تابع delete متعلق به پکیج builtin استفاده می‌شود.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 animals := make(map[int]string) // nil map of string-int pairs 7 animals[1] = \u0026#34;Gopher\u0026#34; 8 animals[2] = \u0026#34;owl\u0026#34; 9 animals[3] = \u0026#34;cheetah\u0026#34; 10 animals[4] = \u0026#34;eagle\u0026#34; 11 animals[5] = \u0026#34;lion\u0026#34; 12 13 fmt.Println(animals) //map[1:Gopher 2:owl 3:cheetah 4:eagle 5:lion] 14 fmt.Println(len(animals)) //5 15 delete(animals, 4) 16 17 fmt.Println(animals) //map[1:Gopher 2:owl 3:cheetah 5:lion] 18 fmt.Println(len(animals)) //4 19} نکته: اگر کلید مورد استفاده در فانکشن delete() پیدا نشود، هیچ اتفاقی نخواهد افتاد. علت عدم بازگشت ارور در فانکشن delete() است\n1// The delete built-in function deletes the element with the specified key 2// (m[key]) from the map. If m is nil or there is no such element, delete 3// is a no-op. 4func delete(m map[Type]Type1, key Type) 1.10.7 بررسی وجود کلید # یکی از خدماتی که مپ ارائه می‌دهد،‌ پاسخ به سوال وجود یک کلید خاص در مپ می‌باشد که به‌عنوان راهکاری برای حل مسائل از آن استفاده می‌شود. مثال زیر را ببینید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 7\tvar personData = map[string]string{\u0026#34;name\u0026#34;: \u0026#34;frank\u0026#34;, \u0026#34;family\u0026#34;: \u0026#34;colleti\u0026#34;, \u0026#34;dob\u0026#34;: \u0026#34;1970-05-12\u0026#34;} 8 9\tname, nameExist := personData[\u0026#34;name\u0026#34;] 10\tfamily, familyExist := personData[\u0026#34;family\u0026#34;] 11\tdob, dobExist := personData[\u0026#34;dob\u0026#34;] 12\torganization, organizationExist := personData[\u0026#34;organization\u0026#34;] 13 14\tfmt.Println(name, nameExist)\t15\t//frank true 16\tfmt.Println(family, familyExist) 17\t//colleti true 18\tfmt.Println(dob, dobExist) 19\t//1970-05-12 true 20\tfmt.Println(organization, organizationExist) 21\t// false 22} این روش بیشتر به اسم comma, ok شناخته می‌شود و بسیاری از توابع چه در کتابخانه استاندارد و چه کتابخانه‌های عمومی در گولنگ، از این نوع نام‌گذاری برای برگشت دادن مقدار و ارور پشتیبانی می‌کنند. در مثال بالا تمامی متغیرهایی که با Exist تمام می‌شوند برای برسی وجود و عدم وجود یک کلید در مپ استفاده می‌شوند، به این صورت که اگر مقدار مشخص شده در مپ وجود داشت مقدار برگشتی در این متغیرها true خواهد بود و در غیر این صورت مقدار برگشتی false. 1.10.8 مپ، یک جدول، یک منبع # وقتی یک مپ تعریف می‌شود، اگر مپ(های) دیگری از روی آن ساخته شود، دارای یک منبع (reference type) برای ذخیره و دریافت اطلاعات خواهند بود. در مثال زیر، مپ editorMap از مپ companyProfile ایجاد و وقتی ویرایش می‌شود، مپ اصلی نیز،‌ ویرایش می‌شود.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 7\tvar companyProfile = map[string]string{ 8\t\u0026#34;name\u0026#34;: \u0026#34;companyName\u0026#34;, 9\t\u0026#34;address\u0026#34;: \u0026#34;sampleAddress\u0026#34;, 10\t} 11\tvar editorMap = companyProfile // == editorMap := companyProfile 12 13\tfmt.Println(companyProfile[\u0026#34;name\u0026#34;], \u0026#34;\\t\u0026#34;, companyProfile[\u0026#34;address\u0026#34;]) 14\t//companyName sampleAddress 15\tfmt.Println(editorMap[\u0026#34;name\u0026#34;], \u0026#34;\\t\u0026#34;, editorMap[\u0026#34;address\u0026#34;]) 16\t//companyName sampleAddress 17 18\teditorMap[\u0026#34;name\u0026#34;] = \u0026#34;new name\u0026#34; 19\teditorMap[\u0026#34;address\u0026#34;] = \u0026#34;new address\u0026#34; 20 21\t//reference map also edited when editor map edit 22\tfmt.Println(companyProfile[\u0026#34;name\u0026#34;], \u0026#34;\\t\u0026#34;, companyProfile[\u0026#34;address\u0026#34;]) 23\t//new name new address 24\tfmt.Println(editorMap[\u0026#34;name\u0026#34;], \u0026#34;\\t\u0026#34;, editorMap[\u0026#34;address\u0026#34;]) 25\t//new name new address 26} برای اینکه بتوانید مقادیر یک مپ را درون یک مپ دیگر کپی کنید، راه حل این است داخل آن مپ پیمایش کنید و مقادیرش را در مپ جدید قرار دهید.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tvar companyProfile = map[string]string{ 7\t\u0026#34;name\u0026#34;: \u0026#34;companyName\u0026#34;, 8\t\u0026#34;address\u0026#34;: \u0026#34;sampleAddress\u0026#34;, 9\t} 10 11\tvar editorMap = map[string]string{} 12 13\tfor key, value := range companyProfile { 14\teditorMap[key] = value 15\t} 16\t17\tfmt.Println(companyProfile[\u0026#34;name\u0026#34;], \u0026#34;\\t\u0026#34;, companyProfile[\u0026#34;address\u0026#34;]) 18\tfmt.Println(editorMap[\u0026#34;name\u0026#34;], \u0026#34;\\t\u0026#34;, editorMap[\u0026#34;address\u0026#34;]) 19 20\teditorMap[\u0026#34;name\u0026#34;] = \u0026#34;new address\u0026#34; 21\teditorMap[\u0026#34;address\u0026#34;] = \u0026#34;new address\u0026#34; 22 23\tfmt.Println(companyProfile[\u0026#34;name\u0026#34;], \u0026#34;\\t\u0026#34;, companyProfile[\u0026#34;address\u0026#34;]) 24\tfmt.Println(editorMap[\u0026#34;name\u0026#34;], \u0026#34;\\t\u0026#34;, editorMap[\u0026#34;address\u0026#34;]) 25} 1.10.9 پیمایش روی مپ # یکی از اصلی‌ترین اهداف ایجاد و نگهداری انواع تایپ‌های مربوط به مجموعه داده‌ها، امکان دسترسی به اجزای داده و انواع لوپ از ابزارهای آن است. با استفاده از for-range می‌توان به اجزای یک داده‌ از نوع کلید-مقدار دسترسی داشت\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7func main() { 8\tanimals := make(map[int][]string) // nil map of string-int pairs 9\tanimals[0] = []string{\u0026#34;Gopher\u0026#34;, \u0026#34;running\u0026#34;, \u0026#34;rodent\u0026#34;} 10\tanimals[1] = []string{\u0026#34;owl\u0026#34;, \u0026#34;flying\u0026#34;, \u0026#34;carnivorous\u0026#34;} 11\tanimals[2] = []string{\u0026#34;cheetah\u0026#34;, \u0026#34;running\u0026#34;, \u0026#34;carnivorous\u0026#34;} 12\tanimals[3] = []string{\u0026#34;eagle\u0026#34;, \u0026#34;flying\u0026#34;, \u0026#34;carnivorous\u0026#34;} 13\tanimals[4] = []string{\u0026#34;lion\u0026#34;, \u0026#34;running\u0026#34;, \u0026#34;carnivorous\u0026#34;} 14 15\tfor index, animal := range animals { 16\tfmt.Printf(\u0026#34;%v- %s is %s animal and can %s \\n\u0026#34;, index, animal[0], animal[2], animal[1]) 17\t} 18} خروجی کد بالا:\n1user@system:~/go/src/temp❇ GO[1.19.3] 22:29:00 2→ go run main.go 30- Gopher is rodent animal and can running 41- owl is carnivorous animal and can flying 52- cheetah is carnivorous animal and can running 63- eagle is carnivorous animal and can flying 74- lion is carnivorous animal and can running 8user@system:~/go/src/temp❇ GO[1.19.3] 22:29:00 9→ go run main.go 104- lion is carnivorous animal and can running 110- Gopher is rodent animal and can running 121- owl is carnivorous animal and can flying 132- cheetah is carnivorous animal and can running 143- eagle is carnivorous animal and can flying 15user@system:~/go/src/temp❇ GO[1.19.3] 22:29:02 16→ go run main.go 172- cheetah is carnivorous animal and can running 183- eagle is carnivorous animal and can flying 194- lion is carnivorous animal and can running 200- Gopher is rodent animal and can running 211- owl is carnivorous animal and can flying به نحوه چیدمان خروجی‌ها دقت کنید، درباره علت یکسان نبودن خروجی‌ها در اجراهای متعدد تحقیق کنید تقلب کوچیک بهتون بدم :). مپ ها unordered هستن.\n1.10.10 تبدیل اطلاعات رشته − مپ − اسلایس # نمونه کد زیر یک رشته را به مپ و یک مپ را به اسلایس تبدیل می‌کند.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7func seriesStringToMap(inputs ...string) map[int]string { 8\tresult := make(map[int]string) 9\tfor index, input := range inputs { 10\tresult[index] = input 11\t} 12\treturn result 13} 14 15func mapToSlice(inputs map[int]string) []string { 16\tresult := make([]string, len(inputs)) 17\tfor index, input := range inputs { 18\tresult[index] = input 19\t} 20\treturn result 21} 22 23func main() { 24\tmyAnimal := \u0026#34;Eagle Cheetah Owl Lion Gopher\u0026#34; 25 26\tmyMappedAnimal := seriesStringToMap(myAnimal) 27\tfmt.Println(myMappedAnimal) 28\t//map[0:Eagle Cheetah Owl Lion Gopher] 29 30\tmySlicedAnimal := mapToSlice(myMappedAnimal) 31\tfmt.Println(mySlicedAnimal) 32\t//[Eagle Cheetah Owl Lion Gopher] 33} 1.10.11 خودآزمون # کد زیر را بررسی کنید و خروجی(های) آن را با ذهن خود پردازش کنید. سپس صحت آن(ها) را بررسی و درباره آن تحقیق کنید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 var myMap map[string]int 7 fmt.Println(myMap) 8 9 var otherMap = map[string]int{} 10 fmt.Println(otherMap) 11 12 myMap[\u0026#34;foo\u0026#34;] = 13 13 fmt.Println(myMap) 14 15 otherMap[\u0026#34;bar\u0026#34;] = 99 16 fmt.Println(otherMap) 17} "},{"id":18,"href":"/chapter-1/go-if-switch/","title":"1.11 شرط (if, switch)","section":"فصل اول: آشنایی با مفاهیم گو","content":" 1.11.1 شرط (if-else) # زبان گو همانند سایر زبان‌ها دارای شرط است که شما خیلی ساده می‌توانید از آن استفاده کنید. در مثال زیر ما فرمت استاندارد شرط در زبان گو را قرار دادیم:\n1if condition { 2 //Do something 3} else if condition { 4 //Do something 5} else { 6 //Do something 7} در بالا condition عبارتی است که قرار است وضعیت شرط را مشخص کند و در صورت true شدن شرط بر قرار می‌شود و در صورت برقرار نشدن شرط اول، برنامه وارد else if می‌شود و مجدد یک condition دیگری را چک می‌کند که وضعیتش true می‌شود یا خیر و در نهایت منتهی می‌شود به else.\nدر شرط ما یک یا چندتا condition می‌توانیم داشته باشیم که این condition‌ ها برای تعیین وضعیت از یکسری عملگرها نظیر \u0026amp;\u0026amp; , || , \u0026gt; , \u0026lt; , \u0026lt;= , =\u0026gt; , ! و \u0026hellip; استفاده می کنند.\nزبان گو از فرمت‌های زیر برای ایجاد شرط استفاده می‌کند:\nفقط if if-else تو در تو (nested) شرط کوتاه با if 1.11.2 کلمه if به تنهایی # شما می‌توانید به تنهایی از if استفاده و یک condition را بررسی کنید:\n1if condition { 2 //Do something 3} برای نمونه کد زیر را ببینید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 a := 6 7 if a \u0026gt; 5 { 8 fmt.Println(\u0026#34;a is greater than 5\u0026#34;) 9 } 10} 1$ go run main.go 2a is greater than 5 در مثال بالا ما مقدار a را با عدد ۵ مقایسه کردیم، شرط ما به این صورت بود که آیا a از ۵ بزرگتر است یا خیر؟ جواب true است. a بزرگتر از 5 است و شرط برقرار میشود.\nدر مثال زیر ما چند condition را داخل یک شرط بررسی کردیم. آیا a بزرگتر از 3 و a کوچک تر از 6 است؟\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 a := 4 7 if a \u0026gt; 3 \u0026amp;\u0026amp; a \u0026lt; 6 { 8 fmt.Println(\u0026#34;a is within range\u0026#34;) 9 } 10} 1$ go run main.go 2a is within range 1.11.3 کلمه else # فرمت شرط همراه با else مانند مثال زیر است:\n1if condition { 2 //Do something 3} else { 4 //Do something 5} در مثال بالا اگر condition برقرار نشود، کدهای داخل else اجرا خواهند شد. به مثال زیر توجه کنید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 a := 1 7 b := 2 8 9 if a \u0026gt; b { 10 fmt.Println(\u0026#34;a is greater than b\u0026#34;) 11 } else { 12 fmt.Println(\u0026#34;b is greater than a\u0026#34;) 13 } 14} 1$ go run main.go 2b is greater than a 1.11.4 ادامه شرط با else if # شما با استفاده از کلید واژه else if دقیقا به همین فرمت که اینجا نوشته شده می‌توانید condition دیگری را بررسی کرده و در صورت برقرار شدن شرط، عملیات را انجام دهید.\n1if condition1 { 2 //Do something 3} else if condition2 { 4 //Do something 5} else { 6 //Do something 7} به مثال زیر توجه کنید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 age := 29 7 if age \u0026lt; 18 { 8 fmt.Println(\u0026#34;Kid\u0026#34;) 9 } else if age \u0026gt;= 18 \u0026amp;\u0026amp; age \u0026lt; 40 { 10 fmt.Println(\u0026#34;Young\u0026#34;) 11 } else { 12 fmt.Println(\u0026#34;Old\u0026#34;) 13 } 14} 1$ go run main.go 2Young 1.11.5 شرط تو در تو (nested) # در زبان گولنگ شما می‌توانید شرط‌های تو در تو (nested) داشته باشید (برای توسعه بهتر پروژه، بهتر است کمتر از شرطهای تو در تو استفاده کنید، زیرا این گونه شرط نویسی خوانایی کد را پایین می‌آورد)\n1if condition { 2 //Do something 3 if condition2 { 4 //Do something 5 } 6 //Do something 7} در مثال زیر یک نمونه شرط تو در تو به همراه else قرار دادیم:\n1if condition1 { 2 //... 3} else { 4 //... 5 if condition2 { 6 //... 7 } else { 8 //.... 9 } 10 //.... 11} در کد زیر مثالی برای شروط تو در تو زدیم:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 a := 1 7 b := 2 8 c := 3 9 10 if a \u0026gt; b \u0026amp;\u0026amp; a \u0026gt; c { 11 fmt.Println(\u0026#34;Biggest is a\u0026#34;) 12 } else if b \u0026gt; a \u0026amp;\u0026amp; b \u0026gt; c { 13 fmt.Println(\u0026#34;Biggest is b\u0026#34;) 14 } else { 15 fmt.Println(\u0026#34;Biggest is c\u0026#34;) 16 } 17} 1$ go run main.go 2Biggest is c 1.11.6 تعریف شرط و قرار دادن condition در متغیر کوتاه # در زبان گو شرط‌ها, امکان تعریف متغیر به روش کوتاه در شرط برای condition را دارند و شما می‌توانید قبل از بررسی کردن condition اون رو در همان خط مقدار دهی کنید.\n1if statement; condition { 2 //Do something 3} به مثال زیر توجه کنید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 if a := 6; a \u0026gt; 5 { 7 fmt.Println(\u0026#34;a is greater than 5\u0026#34;) 8 } 9} 1$ go run main.go 2a is greater than 5 در مثال بالا ما یک متغیر کوتاه با نام a را داخل شرط تعریف کردیم و مقدار 6 را بهش دادیم، سپس با قرار دادن ; semi-colon برقراری وضعیت شرط را بررسی کردیم.\n1.11.7 Switch # زبان گو ‌مانند برخی از زبان‌ها از switch پشتیبانی می‌کند. switch یک روش بسیار ساده‌تر و همچنین روشی برای جلوگیری از else if های مکرر در شرط است.\n1switch statement; expression { 2case expression1: 3 //Dosomething 4case expression2: 5 //Dosomething 6default: 7 //Dosomething 8} زمانیکه switch رو تعریف می‌کنیم, هم می‌توانیم مقداری که قبلا تعریف کردیم رو برای بررسی بهش بدیم و هم می‌توانیم از روش (تعریف متغیر به روش کوتاه) یک مقدار جدید تعریف کنیم و ازش استفاده کنیم. بعد از کلمه switch باید یک مقدار رو بهش بدیم و داخل switch با استفاده از case بررسی کنیم که مقداری که داده شده با اون چیزی که مد نظر ما هست برابر هست یا خیر. اگر هیج کدام از شرط ها برقرار نبود، کد های بعد از default اجرا میشن. استفاده از شرط default اجباری نیست.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 switch ch := \u0026#34;b\u0026#34;; ch { 7 case \u0026#34;a\u0026#34;: 8 fmt.Println(\u0026#34;a\u0026#34;) 9 case \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;: 10 fmt.Println(\u0026#34;b or c\u0026#34;) 11 default: 12 fmt.Println(\u0026#34;No matching character\u0026#34;) 13 } 14} 1$ go run main.go 2b or c در مثال بالا ما یک متغیر با نام ch رو به روش تعریف متغیر به روش کوتاه مقدار دهی کردم و همون متغیر را برای بررسی به switch دادیم. سپس با استفاده از کلید واژه case بررسی کردیم که آیا ch برابر است با اون مقادیری که ما تعریف کردیم یا خیر. اگر برابر بود کدهای درون اون case اجرا خواهند شد و اگر برابر نبود ما با استفاده از کلید واژه default مقدار پیش‌فرضی را در خروجی چاپ می‌کنیم.\n1.11.8 fallthrough # اگر در آخر یک case از این keyword استفاده شود، case بعدی بدون هیچ شرطی اجرا می‌شود. نکته ای که حتی بسیاری از منابع انگلیسی هم به صورت واضح اشاره نکرده اند، این است وقتی از fallthrough استفاده می کنیم، کیس بعد از آن بدون بررسی اجرا می شود حتی اگر شرطش برقرار نباشد. در ادامه اول یک مثال صحیح از استفاده ی fallthrough و سپس یک مثال اشتباه می زنیم.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tvar dayOfWeek int 7 8\tfmt.Printf(\u0026#34;Enter a day of week: \u0026#34;) 9\tfmt.Scanln(\u0026amp;dayOfWeek) 10 11\tswitch dayOfWeek { 12\tcase 1: 13\tfmt.Println(\u0026#34;Monday\u0026#34;) 14\tfallthrough 15\tcase 2: 16\tfmt.Println(\u0026#34;Tuesday\u0026#34;) 17\tfallthrough 18\tcase 3: 19\tfmt.Println(\u0026#34;Wednesday\u0026#34;) 20\tfallthrough 21\tcase 4: 22\tfmt.Println(\u0026#34;Thursday\u0026#34;) 23\tfallthrough 24\tcase 5: 25\tfmt.Println(\u0026#34;Friday\u0026#34;) 26\tfallthrough 27\tcase 6: 28\tfmt.Println(\u0026#34;Saturday\u0026#34;) 29\tfallthrough 30\tcase 7: 31\tfmt.Println(\u0026#34;Sunday\u0026#34;) 32\tdefault: 33\tfmt.Println(\u0026#34;Invalid Day\u0026#34;) 34\t} 35} در این مثال از کاربر یک روز هفته را می گیریم، سپس اسم آن روز به علاوه ی اسم تعداد روز های باقی مانده از هفته را چاپ می کنیم. با استفاده از fallthrough به سادگی می توان اینکار را انجام داد.\nخروجی کد ما اگر روز سوم هفته را وارد کنیم به این صورت است:\n1Enter a day of week: 3 2Wednesday 3Thursday 4Friday 5Saturday 6Sunday اما اگر از fallthrough به‌صورت اشتباه استفاده کنیم، کد ما ازنظر منطقی با مشکل مواجه می شود. به مثال زیر دقت کنید:\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;strings\u0026#34; 6) 7 8func main() { 9\tvar notificationType string = \u0026#34;sms,email\u0026#34; 10 11\tswitch { 12\tcase strings.Contains(notificationType, \u0026#34;sms\u0026#34;): 13\tfmt.Println(\u0026#34;Sent sms\u0026#34;) 14\tfallthrough 15\tcase strings.Contains(notificationType, \u0026#34;email\u0026#34;): 16\tfmt.Println(\u0026#34;Sent email\u0026#34;) 17\tfallthrough 18\tcase strings.Contains(notificationType, \u0026#34;push\u0026#34;): 19\tfmt.Println(\u0026#34;Sent push\u0026#34;) 20\tdefault: 21\tfmt.Println(\u0026#34;Unknown\u0026#34;) 22\t} 23} در این مثال، برنامه نویس اینگونه در نظر گرفته است که fallthrough روشی است تا بتواند در صورت درست بودن یک شرط، سراغ شرط بعدی برود و آن را هم چک کند. اما fallthrough بدون اینکه شرط کیس بعدی را چک کند. آن را اجرا می کند. در این مثال با اینکه مشخص کردیم فقط sms و email شود، push هم می کند.\n1Sent sms 2Sent email 3Sent push 1.11.9 Switch خودآزمون # تفاوت ساختار و خروجی چهار فرمت مشابه زیر را بررسی کنید:\nحالت اول 1switch f(); { 2case true: 3 println(1) 4case false: 5 println(0) 6} حالت دوم 1switch f() 2{ 3case true: 4 println(1) 5case false: 6 println(0) 7} حالت سوم 1switch f() { 2case true: 3 println(1) 4case false: 5 println(0) 6} حالت چهارم 1switch f(); true { 2case true: 3 println(1) 4case false: 5 println(0) 6} کدها در زمان اجرا یا پیش از آن، در برخی IDE یا Code Editor(ها) فرمت می‌شوند. هدف این خودآزمون دقت به ساختار ابزار switch است. "},{"id":19,"href":"/chapter-1/go-package/","title":"1.12 اضافه کردن پکیج در کد (package)","section":"فصل اول: آشنایی با مفاهیم گو","content":"زبان برنامه‌نویسی گو به شکلی طراحی شده است تا بتوانیم شیو‌ه‌های خوب مهندسی نرم‌افزار را به سادگی پیاده‌سازی کنیم. یکی از الگوهای مهم برای ارتقای کیفیت یک نرم افزار استفاده از DRY principle است. کلمه DRY مخفف Don’t Repeat Yourself همون چرخ رو دوباره اختراع نکن خودمون است, که اگر به صورت خیلی ساده بیانش کنیم یعنی، کدی که خواهید نوشت را دوبار تکرار نکنید. تا جایی که امکان دارد باید بتوانید از کدهای قبلی که نوشته اید استفاده کنید. پکیج‌ها امکاناتی از جمله:\nقابلیت استفاده مجدد از کد را به ما میدهند. امکان ماژولار، و قابل نگهداری بودن کد را فراهم می‌کنند. امکان مدیریت بهتر فایل‌ها را در یک واحد ایجاد می‌کنند. 1.12.1 پکیج‌ها در زبان گو # پکیج در اصل یک یا مجموعه‌ای از سورس فایل‌های شما است که ممکن است داخل یک فولدر قرار بگیرد. هر سورس فایلی که در زبان گو دارید متعلق به یک پکیج است. برای تعریف یک پکیج از دستور زیر استفاده می‌کنیم:\n1package \u0026lt;packagename\u0026gt; برای تعریف پکیج باید در اولین خط فایل، آن را با کلید واژه package تعریف کنید. داخل این پکیج شما می‌توانید کد‌هایی که لازم دارید را بنویسید و تصمیم بگیرید کدام متغییر، فانکشن یا تایپ باید به صورت عمومی باشد و یا باید به صورت خصوصی فقط داخل پکیج مورد استفاده قرار بگیرد.\nقطعا می‌دانیم بعد از نوشتن پکیج اگر بخواهیم از آن پکیج داخل پکیج‌های دیگر استفاده کنیم باید از کلید واژه import استفاده کنیم.\n1.12.2 اضافه کردن پکیج # برای اضافه کردن پکیج‌های مختلف ما از کلید واژه import استفاده می‌کنیم.\n1import \u0026#34;fmt\u0026#34; برای مثال, در کد بالا ما از پکیج fmt که در کتابخانه استاندارد گو وجود دارد استفاده کردیم. این به این معنی است همراه با تعریف کلمه fmt میتوانیم از توابعی که داخل این پکیج نوشته شده است استفاده کنیم. در مثال زیر ما از تابع Println برای چاپ مقدارHello GoFarsi!‍ استفاده کردیم.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tfmt.Println(\u0026#34;Hello GoFarsi!\u0026#34;) 7} تعریف کردن توابع به این شکل مزایای زیادی دارد از جمله:\nاگر اسم‌های مشابهی داشته باشید، داخل پکیج‌های مختلف می‌توانید از آن‌ها استفاده کنید، همچنین خوانایی برنامه افزایش پیدا می‌کند و باعث می‌شود از نام‌های طولانی استفاده نکنیم. مجموعه کدهایی که مربوط به هم هستن را در یک پکیج می‌توانیم قرار دهیم, که باعث می‌شود پیدا کردن و استفاده مجدد از کد را برای ما راحت‌تر کند. فرایند تغییر و کامپایل را می‌تواند به حداقل برساند. 1.12.2.1 اضافه کردن چندین پکیج # ما می‌توانیم برای اضافه کردن هر پکیج از کلید واژه import به شکل زیر استفاده کنیم:\n1import \u0026#34;fmt\u0026#34; 2import \u0026#34;time\u0026#34; 3import \u0026#34;math\u0026#34; 4import \u0026#34;math/rand\u0026#34; اما با تشکر از زبان گو, ما می‌توانیم چندین پکیج رو به صورت زیر و فقط با یک بار نوشتن کلید واژه import فراخوانی کنیم:\n1import ( 2\t\u0026#34;fmt\u0026#34; 3\t\u0026#34;time\u0026#34; 4\t\u0026#34;math\u0026#34; 5 \u0026#34;math/rand\u0026#34; 6) یعنی یک بار از کلید واژه import استفاده کنیم و بعد اسم پکیج‌ها را به ترتیب داخل آن بنویسیم.\nهمینطور ما می‌توانیم به پکیج هایی که import کردیم یک alias هم بدیم، یعنی همون اسم مستعار, به مثال زیر توجه کنید:\n1import ( 2\tformat \u0026#34;fmt\u0026#34; 3) و مانند مثال زیر از آن ها استفاده کنیم:‌\n1package main 2 3import format \u0026#34;fmt\u0026#34; 4 5func main() { 6\tformat.Println(\u0026#34;Hello from Gofarsi\u0026#34;) 7} 1.12.3 اسم‌های عمومی و خصوصی (Export و Unexport) # همه توابع، متغیر‌ها، ثابت ها و تایپ‌هایی که با حروف کوچک شروع می‌شوند، فقط در همان پکیج قابل دسترس هستند. برای عمومی کردن آنها، حرف اول آنها را به صورت Capital می‌نویسیم. برای مثال به کد زیر نگاه کنید:\n1package main 2 3import \u0026#34;encoding/json\u0026#34; 4 5type jSON struct { 6 Name string `json:\u0026#34;name\u0026#34;` 7} 8 9func main() { 10 var data []byte 11 json.Unmarshal(data, \u0026amp;jSON{}) 12} چون پکیج json نیاز داره تا فیلد Name رو تغییر بده پس در نتیجه در کد بالا حتما باید این فیلد رو با حرف بزرگ می‌نوشتیم.\n1.12.4 اضافه کردن پکیج‌های 3rd party # فرض کنید می‌خواهیم از پکیج Gin (github.com) استفاده کنیم، برای اضافه کردن این پکیج ما ‌می‌توانیم به دو شکل زیر آن را اضافه کنیم.\nداخل پروژه خود از دستور زیر استفاده کنید:\n1$ go get -u github.com/gin-gonic/gin بعدا می‌توانید وارد پروژه خود شوید و با کلید واژه import از آن استفاده کنید. به مثال زیر نگاه کنید:\n1package main 2 3import ( 4 \u0026#34;net/http\u0026#34; 5 6 \u0026#34;github.com/gin-gonic/gin\u0026#34; 7) 8 9func main() { 10 r := gin.Default() 11 r.GET(\u0026#34;/ping\u0026#34;, func(c *gin.Context) { 12 c.JSON(http.StatusOK, gin.H{ 13 \u0026#34;message\u0026#34;: \u0026#34;pong\u0026#34;, 14 }) 15 }) 16 r.Run() // listen and serve on 0.0.0.0:8080 (for windows \u0026#34;localhost:8080\u0026#34;) 17} حالت دیگر استفاده از go mod tidy است, به این شکل که ما از دستور go get استفاده نمی‌کنیم و به صورت مستقیم داخل پروژه آدرس gin را import می‌کنیم.\nو همان ابتدا داخل کد یک فانکشن را از همان پکیج فراخوانی می‌کنیم (اینکار لازم است چون همانطور که می‌دانید خود go tool وقتی بداند شما پکیجی را تعریف کردید و استفاده نکردید آن را خودکار پاک می‌کند. البته که کد ادیتورهای معروف هم مانند goland,vsCode و \u0026hellip;، همین کارو رو در حین نوشتن کد برای شما انجام می‌دهند.)\nسپس از دستور زیر استفاده میکنیم:\n1$ go mod tidy این دستور کل کدهای شما را بررسی می‌کند و اگر ببینید پکیجی تعریف شده است و شما آن را ندارید سعی میکند آن پکیج را برای شما دانلود و به پروژه شما اضافه کند.\n"},{"id":20,"href":"/chapter-1/go-defer-panic-recovery/","title":"1.13 defer, panic, recovery","section":"فصل اول: آشنایی با مفاهیم گو","content":" 1.13.1 تعویق (defer) # کلمه کلیدی defer یکی از کاربردی‌ترین امکانات زبان گو را برای ما فراهم می‌سازد. شما می‌توانید اجرای یک تابع را به تعویق بندازید‍‍. عموماً defer برای توابعی کاربرد دارد که قصد پاک‌سازی یا بستن عملیات‌های صورت گرفته را دارند، نظیر توابع Close در برخی از جاها.\nبه مثال زیر توجه کنید:\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7func main() { 8\tdefer fmt.Println(\u0026#34;world\u0026#34;) 9\tfmt.Println(\u0026#34;hello\u0026#34;) 10} 1$ go run main.go 2hello 3world 1.13.1.1 تعویق (defer) در توابع (Anonymous) # شما خیلی ساده می‌توانید با استفاده از توابع Anonymous توابع بینام یا گمنام :) اجرای قسمتی از برنامه خودتان را به تعویق بندازید. به مثال زیر توجه کنید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 defer func() { fmt.Println(\u0026#34;In inline defer\u0026#34;) }() 7 fmt.Println(\u0026#34;Executed\u0026#34;) 8} 1$ go run main.go 2Executed 3In inline defer به این نکته توجه کنید که defer قبل از return صدا زده می‌شود. یعنی قبل از اینکه تابع شما خروجی را برگشت بدهد اگه تابع خروجی داشته باشه defer اجرا خواهد شد.\n1.13.1.2 تعویق (defer) چندین تابع درون یک تابع # در کد زیر, ما داخل یک تابع چند تابع را با استفاده از (defer) به تعویق انداختیم. به مثال زیر توجه کنید:\n1package main 2import \u0026#34;fmt\u0026#34; 3func main() { 4 i := 0 5 i = 1 6 defer fmt.Println(i) 7 i = 2 8 defer fmt.Println(i) 9 i = 3 10 defer fmt.Println(i) 11} 1$ go run main.go 23 32 41 دقت داشته باشید که مقداردهی پارامترهای ورودی، برای تابعی که آن را defer کردیم در همان لحظه call شدن آن انجام می‌شود. به مثال زیر توجه کنید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\ti:=1 7\tdefer fmt.Println(i) 8\ti++ 9\tfmt.Println(i) 10\tfmt.Println(\u0026#34;First\u0026#34;) 11} 1$ go run main.go 22 3First 41 در این مرحله شما باید پی برده باشید که defer در همان خطی که نوشته شده است صدا زده می‌شود، ولی اجرای آن دقیقاً به قبل از return در تابع موکول می‌شود.\n1.13.2 پنیک (panic) # در زبان گو panic همانند exception به معنای خروج از برنامه در شرایط غیر عادی است. panic در ۲ حالت زیر پیش می‌آید:\nخطاهای در زمان اجرای برنامه فراخوانی تابع panic توسط برنامه نویس در بخش های مختلف برنامه 1func panic(v interface{}) شما می‌توانید با استفاده از تابع داخلی فوق، panic ایجاد کنید و به عنوان ورودی دلیل panic را در قالب یک رشته به تابع ارسال کنید.\n1.13.2.1 خطای panic در زمان اجرا (runtime) # خطاهای panic در زمان اجرا به دلایل زیر می‌تواند رخ دهد:\nخطای Out of bounds/range array/slice فراخوانی متغیری که nil pointer باشد یعنی به هیچ آدرسی از حافظه memory اشاره نمی‌کند ارسال داده برروی کانال‌های بسته شده type assertion نادرست 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 7\ta := []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;} 8\tprint(a, 2) 9} 10 11func print(a []string, index int) { 12\tfmt.Println(a[index]) 13} 1$ go run main.go 2panic: runtime error: index out of range [2] with length 2 3 4goroutine 1 [running]: 5main.checkAndPrint(...) 6 main.go:12 7main.main() 8 /main.go:8 +0x1b 9exit status 2 در تابع فوق ما یک تابع نوشتیم که به عنوان ورودی یک اسلایس از نوع رشته و یک ایندکس از نوع عدد از ما دریافت می‌کند و المنت ایندکسم‌ اون اسلایس را برای ما چاپ میکند در مثال بالا یعنی اندیس شماره 2. این کار ما باعث بروز یک panic میشود, فکر میکنید به چه دلیل ؟ بله به این دلیل که اسلایس ما اندیس شماره 2 ندارد و دلیل آن هم این است که اسلایس, لیست و \u0026hellip;. از 0 شروع می‌شوند.\nپنیک یک سری اطلاعات در مورد چرایی بوجود آمدنش به ما می‌دهد که در ادامه آن‌ها را توضیح دادیم:\nپنیک رخ داده شامل متن خطا محل رخ دادن panic در قالب stacktrace 1.13.2.2 خطای panic از قبل تعیین شده توسط برنامه‌نویس # همانطور که گفتیم شما می‌توانید هرجایی از بدنه توابع خود، تابع panic را فراخوانی کنید البته این روش پیشنهاد نمی‌شود و روش پیشنهادی استفاده از شیوه ارور هندلینگ خود گولنگ است و فقط در صورت لزوم بهتر است از پنیک استفاده شود. همینطور شما باید در داکیومنت برنامه ذکر کنید که کدام قسمت برنامه امکان پنیک را دارد تا دیگران بتوانند در صورت لزوم آن را recover کنند. recover را در ادمه توضیح خواهم داد. تا برنامه در آن محل خطایی را نمایش داده و متوقف شود.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 7\ta := []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;} 8\tcheckAndPrint(a, 2) 9} 10 11func checkAndPrint(a []string, index int) { 12\tif index \u0026gt; (len(a) - 1) { 13\tpanic(\u0026#34;Out of bound access for slice\u0026#34;) 14\t} 15\tfmt.Println(a[index]) 16} 1$ go run main.go 2panic: Out of bound access for slice 3 4goroutine 1 [running]: 5main.checkAndPrint(0xc000104f58, 0x2, 0x2, 0x2) 6 main.go:13 +0xe2 7main.main() 8 main.go:8 +0x7d 9exit status 2 توجه کنید استفاده از تابع panic در برخی مواقع مفید می‌باشد. به عنوان مثال قصد دارید هنگام اجرای برنامه، یکسری تنظیمات از سمت کاربر دریافت کنید و در صورتی‌که تنظیمات دارای مشکل بودند، می‌توانید با استفاده panic جلوی ادامه روند برنامه را بگیرید تا کاربر خطا را رفع کند. 1.13.3 بازیابی (recovery) # برخی اوقات panic‌ها غیرقابل پیش‌ بینی می‌شوند. ممکن است برنامه شما بدون هیچ خطایی اجرا شود و به روند خود ادامه دهد، اما این هم ممکن است که به یک دلیل نامعلوم یا بهتر است بگوییم پیش بینی نشده، panic رخ دهد و برنامه شما کاملاً متوقف و باعث از دست دادن وضعیت استیبل برنامه شود.\nبه همین منظور در گولنگ یک تابع به نام recover وجود دارد که پس از رخ دادن panic در برنامه، این قابلیت را به ما می‌دهد تا بتوانیم برنامه را به وضعیت قبلی خود بازگردانیم تا بعداً خطای panic رخ داده را بررسی و رفع کنیم.\n1func recover() interface{} همینطور که شما هم میبینید، تابع ریکاور هیچ ورودی نمی‌گیرد و یک خروجی از تایپ interface را برمی‌گرداند.\nبه مثالی که در مورد تابع recover زدیم نگاه کنید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 7\ta := []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;} 8\tcheckAndPrint(a, 2) 9\tfmt.Println(\u0026#34;Exiting normally\u0026#34;) 10} 11 12func checkAndPrint(a []string, index int) { 13\tdefer handleOutOfBounds() 14\tif index \u0026gt; (len(a) - 1) { 15\tpanic(\u0026#34;Out of bound access for slice\u0026#34;) 16\t} 17\tfmt.Println(a[index]) 18} 19 20func handleOutOfBounds() { 21\tif r := recover(); r != nil { 22\tfmt.Println(\u0026#34;Recovering from panic:\u0026#34;, r) 23\t} 24} 1$ go run main.go 2Recovering from panic: Out of bound access for slice 3Exiting normally در کد فوق ما یک تابع داریم که در این تابع یک المنت از یک اسلایس را چاپ می‌کند، اما اگر این اندیس خارج از تعداد المنت‌های اسلایس باشد یک خطای panic رخ می‌دهد. ما برای جلوگیری از خطای panic تابع handleOutOfBounds را با استفاده defer درون تابع checkAndPrint قرار دادیم که پس از رخ دادن panic بصورت خودکار بازیابی صورت بگیرد تا برنامه ما متوقف نشود.\n1.13.4 چاپ اطلاعات stacktrace پس از بازیابی # شما می‌توانید پس از اینکه بازیابی را انجام دادید، جزئیات بیشتری در خصوص خطای panic رخ داده بدست آوردید. به مثال زیر توجه کنید:\n1package main 2import ( 3 \u0026#34;fmt\u0026#34; 4 \u0026#34;runtime/debug\u0026#34; 5) 6func main() { 7 a := []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;} 8 checkAndPrint(a, 2) 9 fmt.Println(\u0026#34;Exiting normally\u0026#34;) 10} 11func checkAndPrint(a []string, index int) { 12 defer handleOutOfBounds() 13 if index \u0026gt; (len(a) - 1) { 14 panic(\u0026#34;Out of bound access for slice\u0026#34;) 15 } 16 fmt.Println(a[index]) 17} 18func handleOutOfBounds() { 19 if r := recover(); r != nil { 20 fmt.Println(\u0026#34;Recovering from panic:\u0026#34;, r) 21 fmt.Println(\u0026#34;Stack Trace:\u0026#34;) 22 debug.PrintStack() 23 } 24} 1$ go run main.go 2Recovering from panic: Out of bound access for slice 3Stack Trace: 4goroutine 1 [running]: 5runtime/debug.Stack(0xd, 0x0, 0x0) 6 stack.go:24 +0x9d 7runtime/debug.PrintStack() 8 stack.go:16 +0x22 9main.handleOutOfBounds() 10 main.go:27 +0x10f 11panic(0x10ab8c0, 0x10e8f60) 12 /Users/slohia/Documents/goversion/go1.14.1/src/runtime/panic.go:967 +0x166 13main.checkAndPrint(0xc000104f58, 0x2, 0x2, 0x2) 14 main.go:18 +0x111 15main.main() 16 main.go:11 +0x81 17Exiting normally برای چاپ اطلاعات stacktrace همانطور که می‌بینید ما از پکیج runtime که در کتابخانه استاندارد گولنگ وجود دارد استفاده کردیم\nتوضیح کوتاه در خصوص stacktrace:\nدر برنامه نویسی مفهومی به اسم stack trace و یا stack backtrace مطرح است. بصورت خیلی مختصر کاری که انجام می دهد این است مسیر اجرای کد شمارا از نقطه شروع اجرای کد تا زمانی که به اتمام برسد در استک ذخیره میکند. برای مثال زمانی که با یک panic مواجه میشوید شما می توانید مسیری که برنامه از آن عبور کرده تا به panic خورده را مشاهده کنید که این کار با کمک stack trace انجام میشود.\n"},{"id":21,"href":"/chapter-1/go-builtins/","title":"1.14 لیست تایپ‌ها و توابع Builtin","section":"فصل اول: آشنایی با مفاهیم گو","content":"در مثال زیر لیست تایپ‌ها و توابع Builtin تا نسخه ۱.۲۱ را با توضیحات قرار دادیم.\n1// bool is the set of boolean values, true and false. 2type bool bool 3 4// true and false are the two untyped boolean values. 5const ( 6 true = 0 == 0 // Untyped bool. 7 false = 0 != 0 // Untyped bool. 8) 9 10// uint8 is the set of all unsigned 8-bit integers. 11// Range: 0 through 255. 12type uint8 uint8 13 14// uint16 is the set of all unsigned 16-bit integers. 15// Range: 0 through 65535. 16type uint16 uint16 17 18// uint32 is the set of all unsigned 32-bit integers. 19// Range: 0 through 4294967295. 20type uint32 uint32 21 22// uint64 is the set of all unsigned 64-bit integers. 23// Range: 0 through 18446744073709551615. 24type uint64 uint64 25 26// int8 is the set of all signed 8-bit integers. 27// Range: -128 through 127. 28type int8 int8 29 30// int16 is the set of all signed 16-bit integers. 31// Range: -32768 through 32767. 32type int16 int16 33 34// int32 is the set of all signed 32-bit integers. 35// Range: -2147483648 through 2147483647. 36type int32 int32 37 38// int64 is the set of all signed 64-bit integers. 39// Range: -9223372036854775808 through 9223372036854775807. 40type int64 int64 41 42// float32 is the set of all IEEE-754 32-bit floating-point numbers. 43type float32 float32 44 45// float64 is the set of all IEEE-754 64-bit floating-point numbers. 46type float64 float64 47 48// complex64 is the set of all complex numbers with float32 real and 49// imaginary parts. 50type complex64 complex64 51 52// complex128 is the set of all complex numbers with float64 real and 53// imaginary parts. 54type complex128 complex128 55 56// string is the set of all strings of 8-bit bytes, conventionally but not 57// necessarily representing UTF-8-encoded text. A string may be empty, but 58// not nil. Values of string type are immutable. 59type string string 60 61// int is a signed integer type that is at least 32 bits in size. It is a 62// distinct type, however, and not an alias for, say, int32. 63type int int 64 65// uint is an unsigned integer type that is at least 32 bits in size. It is a 66// distinct type, however, and not an alias for, say, uint32. 67type uint uint 68 69// uintptr is an integer type that is large enough to hold the bit pattern of 70// any pointer. 71type uintptr uintptr 72 73// byte is an alias for uint8 and is equivalent to uint8 in all ways. It is 74// used, by convention, to distinguish byte values from 8-bit unsigned 75// integer values. 76type byte = uint8 77 78// rune is an alias for int32 and is equivalent to int32 in all ways. It is 79// used, by convention, to distinguish character values from integer values. 80type rune = int32 81 82// any is an alias for interface{} and is equivalent to interface{} in all ways. 83type any = interface{} 84 85// comparable is an interface that is implemented by all comparable types 86// (booleans, numbers, strings, pointers, channels, arrays of comparable types, 87// structs whose fields are all comparable types). 88// The comparable interface may only be used as a type parameter constraint, 89// not as the type of a variable. 90type comparable interface{ comparable } 91 92// iota is a predeclared identifier representing the untyped integer ordinal 93// number of the current const specification in a (usually parenthesized) 94// const declaration. It is zero-indexed. 95const iota = 0 // Untyped int. 96 97// nil is a predeclared identifier representing the zero value for a 98// pointer, channel, func, interface, map, or slice type. 99var nil Type // Type must be a pointer, channel, func, interface, map, or slice type 100// Type is here for the purposes of documentation only. It is a stand-in// for any Go type, but represents the same type for any given function 101// invocation. 102type Type int 103 104// Type1 is here for the purposes of documentation only. It is a stand-in// for any Go type, but represents the same type for any given function 105// invocation. 106type Type1 int 107 108// IntegerType is here for the purposes of documentation only. It is a stand-in// for any integer type: int, uint, int8 etc. 109type IntegerType int 110 111// FloatType is here for the purposes of documentation only. It is a stand-in// for either float type: float32 or float64. 112type FloatType float32 113 114// ComplexType is here for the purposes of documentation only. It is a// stand-in for either complex type: complex64 or complex128. 115type ComplexType complex64 116 117// The append built-in function appends elements to the end of a slice. If 118// it has sufficient capacity, the destination is resliced to accommodate the 119// new elements. If it does not, a new underlying array will be allocated. 120// Append returns the updated slice. It is therefore necessary to store the 121// result of append, often in the variable holding the slice itself: 122// 123// slice = append(slice, elem1, elem2) 124// slice = append(slice, anotherSlice...) 125// 126// As a special case, it is legal to append a string to a byte slice, like this: 127// 128// slice = append([]byte(\u0026#34;hello \u0026#34;), \u0026#34;world\u0026#34;...) 129func append(slice []Type, elems ...Type) []Type 130 131// The copy built-in function copies elements from a source slice into a 132// destination slice. (As a special case, it also will copy bytes from a 133// string to a slice of bytes.) The source and destination may overlap. Copy 134// returns the number of elements copied, which will be the minimum of 135// len(src) and len(dst). 136func copy(dst, src []Type) int 137 138// The delete built-in function deletes the element with the specified key 139// (m[key]) from the map. If m is nil or there is no such element, delete 140// is a no-op. 141func delete(m map[Type]Type1, key Type) 142 143// The len built-in function returns the length of v, according to its type: 144// 145// Array: the number of elements in v. 146// Pointer to array: the number of elements in *v (even if v is nil). 147// Slice, or map: the number of elements in v; if v is nil, len(v) is zero. 148// String: the number of bytes in v. 149// Channel: the number of elements queued (unread) in the channel buffer; 150// if v is nil, len(v) is zero. 151// 152// For some arguments, such as a string literal or a simple array expression, the 153// result can be a constant. See the Go language specification\u0026#39;s \u0026#34;Length and 154// capacity\u0026#34; section for details. 155func len(v Type) int 156 157// The cap built-in function returns the capacity of v, according to its type: 158// 159// Array: the number of elements in v (same as len(v)). 160// Pointer to array: the number of elements in *v (same as len(v)). 161// Slice: the maximum length the slice can reach when resliced; 162// if v is nil, cap(v) is zero. 163// Channel: the channel buffer capacity, in units of elements; 164// if v is nil, cap(v) is zero. 165// 166// For some arguments, such as a simple array expression, the result can be a 167// constant. See the Go language specification\u0026#39;s \u0026#34;Length and capacity\u0026#34; section for 168// details. 169func cap(v Type) int 170 171// The make built-in function allocates and initializes an object of type 172// slice, map, or chan (only). Like new, the first argument is a type, not a 173// value. Unlike new, make\u0026#39;s return type is the same as the type of its 174// argument, not a pointer to it. The specification of the result depends on 175// the type: 176// 177// Slice: The size specifies the length. The capacity of the slice is 178// equal to its length. A second integer argument may be provided to 179// specify a different capacity; it must be no smaller than the 180// length. For example, make([]int, 0, 10) allocates an underlying array 181// of size 10 and returns a slice of length 0 and capacity 10 that is 182// backed by this underlying array. 183// Map: An empty map is allocated with enough space to hold the 184// specified number of elements. The size may be omitted, in which case 185// a small starting size is allocated. 186// Channel: The channel\u0026#39;s buffer is initialized with the specified 187// buffer capacity. If zero, or the size is omitted, the channel is 188// unbuffered. 189func make(t Type, size ...IntegerType) Type 190 191// The new built-in function allocates memory. The first argument is a type, 192// not a value, and the value returned is a pointer to a newly 193// allocated zero value of that type. 194func new(Type) *Type 195 196// The complex built-in function constructs a complex value from two 197// floating-point values. The real and imaginary parts must be of the same 198// size, either float32 or float64 (or assignable to them), and the return 199// value will be the corresponding complex type (complex64 for float32, 200// complex128 for float64). 201func complex(r, i FloatType) ComplexType 202 203// The real built-in function returns the real part of the complex number c. 204// The return value will be floating point type corresponding to the type of c. 205func real(c ComplexType) FloatType 206 207// The imag built-in function returns the imaginary part of the complex 208// number c. The return value will be floating point type corresponding to 209// the type of c. 210func imag(c ComplexType) FloatType 211 212// The close built-in function closes a channel, which must be either 213// bidirectional or send-only. It should be executed only by the sender, 214// never the receiver, and has the effect of shutting down the channel after 215// the last sent value is received. After the last value has been received 216// from a closed channel c, any receive from c will succeed without 217// blocking, returning the zero value for the channel element. The form 218// 219// x, ok := \u0026lt;-c 220// 221// will also set ok to false for a closed and empty channel. 222func close(c chan\u0026lt;- Type) 223 224// The panic built-in function stops normal execution of the current 225// goroutine. When a function F calls panic, normal execution of F stops 226// immediately. Any functions whose execution was deferred by F are run in 227// the usual way, and then F returns to its caller. To the caller G, the 228// invocation of F then behaves like a call to panic, terminating G\u0026#39;s 229// execution and running any deferred functions. This continues until all 230// functions in the executing goroutine have stopped, in reverse order. At 231// that point, the program is terminated with a non-zero exit code. This 232// termination sequence is called panicking and can be controlled by the 233// built-in function recover. 234func panic(v any) 235 236// The recover built-in function allows a program to manage behavior of a 237// panicking goroutine. Executing a call to recover inside a deferred 238// function (but not any function called by it) stops the panicking sequence 239// by restoring normal execution and retrieves the error value passed to the 240// call of panic. If recover is called outside the deferred function it will 241// not stop a panicking sequence. In this case, or when the goroutine is not 242// panicking, or if the argument supplied to panic was nil, recover returns 243// nil. Thus the return value from recover reports whether the goroutine is 244// panicking. 245func recover() any 246 247// The print built-in function formats its arguments in an 248// implementation-specific way and writes the result to standard error. 249// Print is useful for bootstrapping and debugging; it is not guaranteed 250// to stay in the language. 251func print(args ...Type) 252 253// The println built-in function formats its arguments in an 254// implementation-specific way and writes the result to standard error. 255// Spaces are always added between arguments and a newline is appended. 256// Println is useful for bootstrapping and debugging; it is not guaranteed 257// to stay in the language. 258func println(args ...Type) 259 260// The error built-in interface type is the conventional interface for 261// representing an error condition, with the nil value representing no error. 262type error interface { 263 Error() string 264} "},{"id":22,"href":"/chapter-1/go-string-formatting/","title":"1.15 قالب بندی رشته‌ها","section":"فصل اول: آشنایی با مفاهیم گو","content":"در زبان گو مانند سایر زبان‌ها یکسری عناوین برای قالب‌بندی رشته وجود دارد که برخی از این عناوین مشترک بین همه زبان‌ها هست و برخی مختص زبان گو.\n1.15.1 قالب بندی با توابع Printf و Sprintf # زمانیکه شما از تابع Printf یا Sprintf استفاده می‌کنید می‌توانید رشته خروجی را با استفاده از پارامترهای بعد از رشته قالب‌بندی کنید، و در نهایت به‌صورت یک رشته نمایش دهید.\n1fmt.Printf(\u0026#34;{{Verb}}\u0026#34;, value1, value2, value3, ..., valueN) 1fmt.Sprintf(\u0026#34;{{Verb}}\u0026#34;, value1, value2, value3, ..., valueN) توجه کنید هر دو تابع فوق خیلی کاربردی و پر استفاده هستند. این ۲ تابع کارکردشان مشترک است ولی خروجی متفاوتی دارند.\nبه عنوان مثال :\nشما با استفاده از Printf می‌توانید یک رشته را قالب‌بندی کنید و در نهایت به عنوان خروجی چاپ کنید. ولی با استفاده از Sprintf می‌توانید یک رشته را قالب‌بندی کنید و در نهایت به جای اینکه مقدار خروجی را چاپ کنید، اون رو داخل یک متغیر قرار بریزید. به مثال زیر توجه کنید: 1x := fmt.Sprintf(\u0026#34;age %s is %d years\u0026#34;, \u0026#34;Javad\u0026#34;, 30) 1.15.1.1 قالب‌بندی یک slice # Verb fmt.Printf(\u0026quot;{{Verb}}\u0026quot;, []int64{0, 1}) خروجی توضیحات %v [0 1] فرمت پیش‌فرض %#v []int64{0, 1} قالب‌بندی کد گو %T []int64 تایپ مقدار توجه کنید v% یکی از پرکاربرد‌ترین Verb‌ها در گولنگ است و مواقعی مورد استفاده قرار می‌گیرد که شما قصد دارید یک مقدار را داخل رشته بزارید، ولی از تایپ اون مقدار خبر ندارید. 1.15.1.2 قالب‌بندی اعداد صحیح # Verb fmt.Printf(\u0026quot;{{Verb}}\u0026quot;, 15) خروجی توضیحات %d 15 عدد پایه ۱۰ %+d +15 نمایش + در کنار عدد %4d ␣␣15 ۴ کارکتر با فاصله از راست %-4d 15␣␣ ۴ کارکتر با فاصله از چپ %04d 0015 نمایش عدد با پیشوند صفر %b 1111 عدد با پایه باینری %o 17 عدد با پایه ۸ اکتال %x f عدد با پایه ۱۶ هگز حروف کوچک %X F عدد با پایه ۱۶ هگز حروف بزرگ %#x 0xf عدد با پایه ۱۶ هگز به همراه 0x 1.15.1.3 قالب‌بندی اعداد اعشاری # Verb fmt.Printf(\u0026quot;{{Verb}}\u0026quot;, 123.456) خروجی توضیحات %e 1.234560e+02 نمایش بصورت نماد عملی %f 123.456000 نقطه اعشاری، بدون نما. دقت پیش فرض 6 است %.2f 123.46 عرض پیش فرض، دقت 2 رقم بعد از نقطه اعشار %8.2f ␣␣123.46 عرض 8 کاراکتر، دقت 2 رقم بعد از نقطه اعشار. کاراکتر پیش‌فرض padding space است %08.2f 00123.46 عرض 8 کاراکتر، دقت 2 رقم بعد از نقطه اعشار. لایه سمت چپ با نویسه مشخص شده (اینجا، 0) %g 123.456 نما در صورت نیاز، فقط ارقام ضروری 1.15.1.4 قالب‌بندی کارکترها # Verb fmt.Printf(\u0026quot;{{Verb}}\u0026quot;, 'A') خروجی توضیحات %c A کارکتر %q \u0026quot;A\u0026quot; کارکتر به همراه دابل کوتیشن %U U+0041 یونیکد %#U U+0041 'A' یونیکد به همراه کارکتر 1.15.1.5 قالب‌بندی رشته (string) و slice بایت # Verb fmt.Printf(\u0026quot;{{Verb}}\u0026quot;, \u0026quot;gophers\u0026quot;) خروجی توضیحات %s gophers رشته ساده %8s ␣␣gophers با ۸ پدینگ راست چین شده %-8s gophers␣␣ با ۸ پدینگ چپ چین شده %q \u0026quot;gophers\u0026quot; رشته به همراه دابل کوتیشن %x 676f7068657273 خروجی هگز مقدار % x 67 6f 70 68 65 72 73 خروجی هگز مقدار با فاصله 1.15.1.6 قالب‌بندی بولین # Verb fmt.Printf(\u0026quot;{{Verb}}\u0026quot;, true) خروجی توضیحات %t true نمایش مقدار بولین در رشته 1.15.1.6 قالب‌بندی اشاره‌گر (pointer) # Verb fmt.Printf(\u0026quot;{{Verb}}\u0026quot;, new(int)) خروجی توضیحات %p 0xc0000b2000 نمایش آدرس حافظه با پایه ۱۶ به همراه 0x 1.15.2 مقادیر خاص در رشته # همانطور که گفتیم زبان گو یکسری کارکترهای خاص دارد که باعث تغییراتی در خروجی رشته خواهد شد و این کارکترهای خاص بین همه زبان‌ها مشترک هستند. در ادامه لیست این کاراکتر‌ها را آورده‌ایم:\nVerb توضیحات \\a U+0007 هشدار یا زنگ \\b U+0008 بک اسپیس backspace \\\\ U+005c بک اسلش backslash \\t U+0009 تب بصورت افقی \\n U+000A خط جدید \\f U+000C حالت فرم \\r U+000D حالت برگشت \\v U+000b تب بصورت عمودی %% نمایش درصد برای حالت‌های خاص نظیر fmt.Printf(\u0026quot;%05.2f%%\u0026quot;, math.Pi) 1.15.3 پکیج strings و متد های پر کاربرد آن # برای کار با رشته ها، یکی از پکیج های پرکاربرد strings است که به‌صورت built-in در گولنگ وجود دارد. در این قسمت با برخی از متد های این پکیج آشنا می شویم.\n1.15.3.1 متد Contains و ContainsAny # با استفاده از این دو متد می توانید چک کنید که در رشته مدنظر شما، آن چیزی که می خواهید وجود دارد یا نه. فرق بین Contains و ContainsAny در این است که Contains باید دقیقا همان الگویی که داده اید داخل رشته پیدا شود اما ContainsAny حتی اگر یکی از کاراکتر ها وجود داشته باشد true بر میگرداند.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;strings\u0026#34; 6) 7 8func main() { 9 10\ttext := \u0026#34;Go will make you love programming again. We promise\u0026#34; 11 12\tfmt.Println(strings.Contains(text, \u0026#34;Golang\u0026#34;)) 13\tfmt.Println(strings.ContainsAny(text, \u0026#34;Golang\u0026#34;)) 14} پس از اجرای کد. خروجی زیر را مشاهده می کنید.\n1$ go run main.go 2Result: 3false 4true 1.15.3.2 متد Count # با استفاده از این متد، می توانید تعداد تکرار یک الگو را بدست بیاورید. Count نسبت به بزرگ و کوچک بودن کلمات حساس است.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;strings\u0026#34; 6) 7 8func main() { 9 10\ttext := \u0026#34;Golang go Go will make you love programming again. We promise\u0026#34; 11 12\tfmt.Println(strings.Count(text, \u0026#34;Go\u0026#34;)) 13} پس از اجرای کد. خروجی زیر را مشاهده می کنید.\n1$ go run main.go 2Result: 32 1.15.3.3 متد Index و LastIndex # با استفاده از متد های Index می توانیم اندیس قرارگرفتن کاراکتر مدنظر را پیدا کنیم. فرق بین Index و LastIndex این است که متد Index اولین کاراکتری که پیدا می کند اندیسش را برمیگرداند، اما LastIndex آخرین کاراکتری که پیدا می کند.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;strings\u0026#34; 6) 7 8func main() { 9 10\ttext := \u0026#34;Go will make you love programming again. We promise\u0026#34; 11 12\tfmt.Println(strings.Index(text, \u0026#34;o\u0026#34;)) 13\tfmt.Println(strings.LastIndex(text, \u0026#34;o\u0026#34;)) 14} پس از اجرای کد. خروجی زیر را مشاهده می کنید.\n1$ go run main.go 2Result: 31 446 1.15.3.4 متد Split # با استفاده از متد Split می توانیم یک رشته را بر اساس یک الگویی(برای مثال space) تکه تکه کنیم. خروجی این متد یک slice از جنس string است.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;strings\u0026#34; 6) 7 8func main() { 9\ttext := \u0026#34;Go will make you love programming again. We promise\u0026#34; 10 11\ttextSlice := strings.Split(text, \u0026#34; \u0026#34;) 12\tfor _, item := range textSlice { 13\tfmt.Println(item) 14\t} 15} پس از اجرای کد. خروجی زیر را مشاهده می کنید.\n1$ go run main.go 2Result: 3Go 4will 5make 6you 7love 8programming 9again. 10We 11promise 1.15.3.5 متد Join # با Join می توانیم المنت های یک اسلایس از جنس string را با یک الگویی به یکدیگر بچسبانیم و در خروجی یک string از المنت های داخل اسلایس بدست بیاوریم. در این مثال text قبلی را که با Split تکه تکه کردیم و داخل textSlice ریختیم، با Join تبدیل به text می کنیم.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;strings\u0026#34; 6) 7 8func main() { 9\t// array of strings 10 textSlice := []string{\u0026#34;Go\u0026#34;, \u0026#34;will\u0026#34;, \u0026#34;make\u0026#34;, \u0026#34;you\u0026#34;, \u0026#34;love\u0026#34;, \u0026#34;programming\u0026#34;, \u0026#34;again.\u0026#34;, \u0026#34;We\u0026#34;, \u0026#34;promise\u0026#34;} 11 12 // joining the string by separator 13 fmt.Println(strings.Join(textSlice, \u0026#34; \u0026#34;)) 14} پس از اجرای کد. خروجی زیر را مشاهده می کنید.\n1$ go run main.go 2Result: 3Go will make you love programming again. We promise 1.15.3.6 متد HasPrefix و HasSuffix # با استفاده از HasPrefix می توانیم چک کنیم که اول رشته با چیزی که ما می خواهیم شروع شده است یا خیر. با HasSuffix می توانیم چک کنیم که اتمام رشته با آن چیزی که ما می خواهیم هست یا خیر.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;strings\u0026#34; 6) 7 8func main() { 9\ttext := \u0026#34;Go will make you love programming again. We promise\u0026#34; 10 11\tfmt.Println(\u0026#34;HasPrefix Go:\u0026#34;, strings.HasPrefix(text, \u0026#34;Go\u0026#34;)) 12\tfmt.Println(\u0026#34;HasPrefix se:\u0026#34;, strings.HasPrefix(text, \u0026#34;se\u0026#34;)) 13 14\tfmt.Println(\u0026#34;HasSuffix se:\u0026#34;, strings.HasSuffix(text, \u0026#34;se\u0026#34;)) 15\tfmt.Println(\u0026#34;HasSuffix Go:\u0026#34;, strings.HasSuffix(text, \u0026#34;Go\u0026#34;)) 16} پس از اجرای کد. خروجی زیر را مشاهده می کنید.\n1$ go run main.go 2Result: 3HasPrefix Go: true 4HasPrefix se: false 5HasSuffix se: true 6HasSuffix Go: false متد های پرکاربرد دیگری مانند Replace, ReplaceAll برای جاگزین کردن. متد های Compare و EqualFold برای مقایسه بین دو رشته. متد های Trim, TrimLeft, TrimRight برای حذف کردن کاراکتر های اضافی از اول و آخر رشته و \u0026hellip; نیز وجود دارند که پیشنهاد می کنم حتما مطالعه کنید.\n"},{"id":23,"href":"/chapter-2/","title":"فصل دوم: مکانیزم‌های زبان","section":"صفحه اصلی","content":"در این فصل به مکانیزیم‌های زبان گو می‌پردازیم و برخی از اصطلاحات زبان گو را با هم برسی می‌کنیم.\nدر بخش 2.1 در خصوص اشاره‌گر آموزش خواهیم داد. در بخش 2.2 به مهم‌ترین تایپ در زبان گو، یعنی ساختار می‌پردازیم و آموزش می‌دهیم چطور با استفاده از ساختار دیتامدل‌های پروژه‌های خود را پیاده سازی کنید. در بخش 2.3 به بحث متدها می‌پردازیم و برسی می‌کنیم که چطور این نوع توابع را پیاده سازی کنیم. در بخش 2.4 در خصوص اینترفیس در زبان گو توضیح می‌دهیم. دقیقا چی هستند و چطور میشه ازشون استفاده کرد. در بخش 2.5 به جاسازی ساختار و اینترفیس می‌پردازیم. در بخش 2.6 به مدیریت خطاها در زبان گو می‌پردازیم و برسی می‌کنیم که چه ویژگی‌هایی دارد. 2.7 تفاوت castin با conversion را آموزش می‌دهیم. "},{"id":24,"href":"/chapter-2/pointer/","title":"2.1 اشاره‌گر (Pointer)","section":"فصل دوم: مکانیزم‌های زبان","content":"اشاره‌گر در واقع متغیری است که، آدرس حافظه یک مقدار را نگه می‌دارد.\n1var ex *T درک اشاره‌گرها (Pointers) برای بسیاری از مبتدیان ترسناک به نظر می‌رسد، اما در واقع اگر با یک مثال ساده آن را توضیح دهیم، می‌تواند بسیار قابل فهم باشد. اجازه بدهید ترجمه و توضیحی روان بر پایه مثالی که دادی ارائه کنم:\nاشاره‌گرها پیچیده به نظر می‌رسند،\nاما واقعاً نیازی نیست که این‌طور باشند.\nاشاره‌گرها را می‌توان شبیه \u0026ldquo;فهرست مطالب یک کتاب\u0026rdquo; در نظر گرفت.\nبرای مثال، همین کتاب را در نظر بگیر. فهرست مطالب این کتاب مثل پنج اشاره‌گر است.\nشما می‌توانید آن‌ها را بخوانید و بفهمید که اطلاعات مربوط به هر فصل در کجا قرار دارد.\nمثلاً فصل «زندگی من» در صفحه ۱ است (یعنی به صفحه ۱ اشاره می‌کند).\nو فصل «شغل من» در صفحه ۲۳ است.\nدر بین برنامه نویسان زبان Go همیشه این مسئله بوده که کی و کجا باید از Pointer استفاده کنیم؟!\nدیدگاه من نسبت به Pointer :\nزمانی باید از Pointer استفاده کنید که قصد دارید یک متغیری را در scope ها و توابع مختلف مقدار دهی کنید در اینجا بهتر است از Pointer استفاده کنیم تا جلو کپی شدن متغیر در خانه های مختلف حافظه گرفته شود.\nساده تر بهش بخواهیم نگاه کنیم وقتی حس کردی میخوای یک متغیر را در چند جای مختلف خارج از اونجایی که تعریف شده مقدار دهی کنی بهتر است آن متغیر را بصورت Pointer برای مقدار دهی پاس دهید.\nحتی این قضیه برای اینکه method تعریف کنیم صدق میکنه که چرا باید متد با Pointer یا بدون Pointer تعریف کنیم.\nنکته مهم 1: استفاده از Pointer باید با دقت انجام شود تا از مشکلاتی مانند دسترسی همزمان به متغیرها و اشتباهات مرتبط با حافظه جلوگیری شود.\nنکته مهم 2: استفاده از Pointer خیلی خوب و مفید است اما در جای درست چون اگر نتوانیم تشخیص دهیم کی و کجا استفاده کنیم به مرور باعث کاهش عملکرد برنامه خواهد شد.\nدر مثال بالا ما شیوه تعریف یک متغیر اشاره‌گر را توضیح دادیم. اول کلید واژه ی var بعد اسم متغیر و در آخر هم *T یعنی تایپ متغیر. به مثال زیر توجه کنید:\n1var ptr *string در تعریف اشاره‌گر ‌ها, ما ۲ تا اپراتور داریم که کارکرد هر کدام از این اپراتورها رو در ادامه توضیح میدم:\n\u0026amp; بهش میگن ampersand با استفاده از این می‌توانیم آدرس حافظه متغیر فرضا x را به متغیر دیگری بدهیم (y := \u0026amp;x) * بهش میگن asterisk با استفاده از این می‌توانیم به مقدار داخل حافظه متغیر فرضا x دسترسی پیدا کنیم (x*) برای اینکه یک اشاره گر تعریف کنیم ۲ روش وجود دارد:\nاستفاده از تابع new استفاده از اپراتور \u0026amp; (آمپرسند) مثال 1 # فرض کنید شما 1 متغیر دارید و قصد دارید داخل 3 تابع مختلف مقدارش را بروز کنید و با یک تابع دیگر نمایش دهید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 var count int 7 8 addCount(\u0026amp;count) 9 10 addCount(\u0026amp;count) 11 12 addCountWithoutPointer(count) 13 fmt.Printf(\u0026#34;value = %d, address in memory = %p\\n\u0026#34;, count, \u0026amp;count) 14 15 printCount(count) 16 17} 18 19func addCount(x *int) { 20 *x++ 21 fmt.Printf(\u0026#34;value = %d, address in memory = %p\\n\u0026#34;, *x, x) 22} 23 24func addCountWithoutPointer(x int) { 25 x++ 26 fmt.Printf(\u0026#34;value = %d, address in memory = %p\\n\u0026#34;, x, \u0026amp;x) 27} 28 29func printCount(x int) { 30 fmt.Printf(\u0026#34;value = %d, address in memory = %p\\n\u0026#34;, x, \u0026amp;x) 31} 1value = 1, address in memory = 0xc000110068 2value = 2, address in memory = 0xc000110068 3value = 3, address in memory = 0xc000110088 4value = 2, address in memory = 0xc000110068 5value = 2, address in memory = 0xc0001100b0 در کد فوق ما یک متغیر به نام count ساختیم که داخل تابع (scope) main می باشد.\nرخداد اول: حال این متغیر را 2 بار بصورت Pointer به تابع addCount پاس دادیم و داخل همان تابع مقدار دهیش کردیم و پس از مقدار دهی در همان تابع print ش کردیم. اتفاقی که افتاد مقدار متغیر در همان خانه حافظه که 0xc0000a6068 هست مقدار دهی شد و عملا بخشی دیگر از حافظه گرفته نشد.\nرخداد دوم: متغیر را بدون Pointer به تابع addCountWithoutPointer پاس دادیم و در همان تابع مقدار دهید و print کردیم, اتفاقی که افتاد ما متغیر را اینبار بدون Pointer پاس دادیم یعنی عملا یک کپی از متغیر را به تابع addCountWithoutPointer فرستادیم و اگر به آدرس حافظه مقدار دقت کنید 0xc0000a6088 عملا یک خانه جدید به این کپی تخصیص داده شد و مقدارش در همان خانه بروز شده و اون متغیر x تنها در همان تابع زنده اس و در صورتیکه اگر x را از تابع بازگشت دهید دوباره یک کپی از آن به بیرون منتقل می شود.\nمثال 2 # فرض کنید یک تایپ count دارید که نام مستعار تایپ int می باشد و 3 تا متد (متد را در بخش 2.3 می توانید بخوانید) گیرنده Pointer با نام های increase , decrease و print دارند.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type count int 6 7func main() { 8 x := new(count) 9 x.increase() 10 x.increase() 11 x.decrease() 12 x.increase() 13 14 x.printWithoutPointer() 15 16} 17 18func (c *count) increase() { 19 *c++ 20 c.print() 21} 22 23func (c *count) decrease() { 24 *c-- 25 c.print() 26} 27 28func (c *count) print() { 29 fmt.Printf(\u0026#34;value = %d, address in memory = %p\\n\u0026#34;, *c, c) 30} 31 32func (c count) printWithoutPointer() { 33 fmt.Printf(\u0026#34;value = %d, address in memory = %p\\n\u0026#34;, c, \u0026amp;c) 34} 1value = 1, address in memory = 0xc0000a4068 2value = 2, address in memory = 0xc0000a4068 3value = 1, address in memory = 0xc0000a4068 4value = 2, address in memory = 0xc0000a4068 5value = 2, address in memory = 0xc0000a4088 ما در مثال فوق با استفاده از تابع new اومدیم متغیر x را ایجاد کردیم سپس متد increase برای افزایش مقدار متغیر x و متد decrease را برای کاهش مقدار x و در نهایت print را برای چاپ استفاده کردیم.\nدر اینجا به دلیل گیرنده Pointer بودن تایپ count توانستیم درهمان خانه حافظه مقدار x را افزایش یا کاهش دهیم و در نهایت با استفاده از متد print اومدیم مقدار و خانه حافظه را چاپ کردیم.\nاما یک متد printWithoutPointer داریم که یک کپی از مقدار x را چاپ میکند و عملا مقدار را از یک خانه حافظه جدید را به نمایش میگذارد.\nمتد printWithoutPointer بدون Pointer می باشد و زمانیکه سایر متدهایتان با یا بدون Pointer هست بهتر است متدهای جدیدتان با Pointer باشد تا جلو سردرگمی گرفته شود. طبق داکیومنت های ارائه شده برای Go چندان لزومی ندارد چنین ترکیبی انجام دهید. 2.1.1 استفاده از تابع new # یک اشاره‌گر با استفاده از تابع new بصورت مثال زیر تعریف شده است:\n1a := new(int) 2*a = 10 3fmt.Println(*a) //Output will be 10 در مثال بالا ما متغیر a را از نوع int اشاره‌گر pointer a تعریف کردیم و سپس داخل آدرس حافظه a مقدار ۱۰ را قرار دادیم.\nتوجه کنید مقدار پیش‌فرض یک متغیر از نوع اشاره‌گر nil است. اگر جایی شما متغیر از نوع اشاره‌گر را بصورت nil بفرستید ممکن است به panic از نوع nil pointer بر بخورید و اجرای برنامه شما کاملا متوقف شود. 2.1.2 استفاده از اپراتور \u0026lsquo;\u0026amp;\u0026rsquo; # برای دریافت آدرس حافظه یک متغیر از \u0026amp; می‌توان استفاده کرد:\n1a := 2 2b := \u0026amp;a 3fmt.Println(*b) //Output will be 2 به مثال زیر توجه کنید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 var b *int 7 a := 2 8 b = \u0026amp;a 9 10 fmt.Println(b) 11 fmt.Println(*b) 12 b = new(int) 13 *b = 10 14 fmt.Println(*b) 15} 1$ go run main.go 20xc0000b0018 32 410 در خروجی بالا 0xc0000b0018 آدرس حافظه متغیر a است. در واقع متغیر a ساخته شد و ما آدرس حافظه آن را به متغیر b دادیم. یعنی هر دو متغیر به یک آدرس از حافظه اشاره می‌کنند.\n2.1.3 اپراتور * اشاره‌گر # ما می‌توانیم اپراتور * را برای عملیات‌های زیر به کار ببریم:\nگرفتن مقدار یک آدرس حافظه که با استفاده از اشاره‌گر ذخیره شده است. تغییر مقدار یک آدرس حافظه. به مثال زیر توجه کنید: # 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\ta := 2 7\tb := \u0026amp;a 8\tfmt.Println(a) 9\tfmt.Println(*b) 10 11\t*b = 3 12\tfmt.Println(a) 13\tfmt.Println(*b) 14 15\ta = 4 16\tfmt.Println(a) 17\tfmt.Println(*b) 18} 1$ go run main.go 22 32 43 53 64 74 در مثال بالا a و b* هر دو دارند به یک آدرس از حافظه اشاره می‌کنند. بنابرین تغییر مقدار یکی از آن‌ها، روی هر دو متغیر تاثیر می‌گذارد.\n2.1.4 اشاره‌گر به یک اشاره‌گر (Double Pointers) # شما می‌‌توانید یک متغیر اشاره‌گر تعریف کنید و متغیر اشاره‌گر دیگری را بهش اختصاص دهید.\n1a := 2 2b := \u0026amp;a 3c := \u0026amp;b همانطور که در مثال و عکس بالا می‌بینید، متغیر a مقدارش ۲ و آدرسش در حافظه 0xXXXXXX است. در مقدار متغیر b ما اشاره کردیم به آدرس حافظه متغیر a و در ادامه در متغیر c به آدرس حافظه متغیر b اشاره کردیم.\nزمانیکه شما بخواهید مقدار c را چاپ کنید کافیست از c** استفاده کنید تا مقدار ۲ را چاپ کند.\nبه مثال زیر توجه کنید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\ta := 2 7\tb := \u0026amp;a 8\tc := \u0026amp;b 9 10\tfmt.Printf(\u0026#34;a: %d\\n\u0026#34;, a) 11\tfmt.Printf(\u0026#34;b: %x\\n\u0026#34;, b) 12\tfmt.Printf(\u0026#34;c: %x\\n\u0026#34;, c) 13 14\tfmt.Println() 15\tfmt.Printf(\u0026#34;a: %d\\n\u0026#34;, a) 16\tfmt.Printf(\u0026#34;*\u0026amp;a: %d\\n\u0026#34;, *\u0026amp;a) 17\tfmt.Printf(\u0026#34;*b: %d\\n\u0026#34;, *b) 18\tfmt.Printf(\u0026#34;**c: %d\\n\u0026#34;, **c) 19 20\tfmt.Println() 21\tfmt.Printf(\u0026#34;\u0026amp;a: %d\\n\u0026#34;, \u0026amp;a) 22\tfmt.Printf(\u0026#34;b: %d\\n\u0026#34;, b) 23\tfmt.Printf(\u0026#34;\u0026amp;*b: %d\\n\u0026#34;, \u0026amp;*b) 24\tfmt.Printf(\u0026#34;*\u0026amp;b: %d\\n\u0026#34;, *\u0026amp;b) 25\tfmt.Printf(\u0026#34;*c: %d\\n\u0026#34;, *c) 26 27\tfmt.Println() 28\tfmt.Printf(\u0026#34;\u0026amp;b: %d\\n\u0026#34;, \u0026amp;b) 29\tfmt.Printf(\u0026#34;c: %d\\n\u0026#34;, c) 30\tfmt.Printf(\u0026#34;*c: %d\\n\u0026#34;, *c) 31\tfmt.Printf(\u0026#34;**c: %d\\n\u0026#34;, **c) 32\t33} 1$ go run main.go 2a: 2 3b: c000018078 4c: c00000e028 5 6a: 2 7*\u0026amp;a: 2 8*b: 2 9**c: 2 10 11\u0026amp;a: 824633819256 12b: 824633819256 13\u0026amp;*b: 824633819256 14*\u0026amp;b: 824633819256 15*c: 824633819256 16 17\u0026amp;b: 824633778216 18c: 824633778216 19*c:824633819256 20**c:2 توجه کنید در زبان گو علی رغم زبان c استفاده از اشاره‌گر حسابی (Pointer Arithmetic) امکان پذیر نمی‌باشد و در صورت استفاده با خطای زیر مواجه خواهید شد:\n1package main 2func main() { 3 a := 1 4 b := \u0026amp;a 5 b = b + 1 6} 1$ go run main.go 2invalid operation: b + 1 (mismatched types *int and int) "},{"id":25,"href":"/chapter-2/struct/","title":"2.2 ساختار (struct)","section":"فصل دوم: مکانیزم‌های زبان","content":"در زبان گو ساختار کالکشنی از فیلدها با تایپ‌های مختلف است. شما با استفاده از ساختار می‌توانید یک مدل کلی از بدنه پروژه خود را تعریف کنید. برای نمونه ما در مثال زیر یک نمونه از ساختار employee کارمند را مثال زدیم تا شما کمی با مفهوم ساختار آشنا شوید.\n1type employee struct { 2 name string 3 age int 4 salary int 5} نکته: ساختار می‌تواند بصورت خالی جهت برخی اهداف ایجاد گردد. به مثال زیر دقت کنید:‌\n1type sample struct {} اگر می‌خواهید در مورد متودها اطلاعات کسب کنید به بخش متدها روی ساختار سر بزنید، هر چند توصیه می‌کنم اول این قسمت رو بخونید و تمرین کنید و بعد به قسمت متودها بروید.\nبرای ایجاد ساختار باید از کلمه کلیدی type اسم ساختار و در ادامه کلمه کلیدی struct استفاده کنید.\nسپس داخل بدنه ساختار فیلدها را تعریف کنید.\nفیلد name از نوع string فیلد age از نوع int فیلد salary از نوع int ساختار را در زبان گو، با class در سایر زبان‌ها مقایسه می‌کنند. هرچند زبان گو یک زبان شی‌گرا محسوب نمی‌شود. 2.2.1 تعریف تایپ struct # به مثال زیر توجه کنید:\n1type point struct { 2 x float64 3 y float64 4} در مثال بالا ما ۲ تا فیلد برای ساختار تعریف کردیم که هر دو فیلد از نوع float64 هستند.\n2.2.2 ایجاد یک متغیر ساختار (struct) # برای ایجاد یک متغیر ساختار می‌توانید یک متغیر تعریف کنید و ساختار را به عنوان مقدار به آن بدهید. به مثال زیر توجه کنید:\n1emp := employee{} در مثال بالا ما یک متغیر با مقدار پیش‌فرض صفر ساختار employee تعریف کردیم.\nزمانیکه یک متغیر ساختار خالی، مانند مثال بالا تعریف می‌کنید مقدار استفاده شده از حافظه 0 بایت است. ایجاد متغیر ساختار و مقدار دهی فیلدها در یک خط: 1emp := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} ایجاد متغیر ساختار و مقدار دهی فیلد در خط‌های مختلف (این روش برای خوانایی و درک بهتر توصیه می‌شود) : 1emp := employee{ 2 name: \u0026#34;Sam\u0026#34;, 3 age: 31, 4 salary: 2000, 5} توجه کنید هیچ اجباری نیست که حتماً شما باید فیلدی را مقدار دهی کنید، شما می‌توانید هر زمانیکه نیاز داشتید ساختار خودتان رو مقدار دهی کنید.\n1emp := employee{ 2 name: \u0026#34;Sam\u0026#34;, 3 age: 31, 4} در مثال بالا ما فیلد salary را مقدار دهی نکردیم. کامپایلر بطور پیش‌فرض با توجه به تایپ فیلد، مقدار پیش‌فرض صفر را برای اون تایپ در نظر می‌گیرد. در ادامه به مثالی که از نحوه ایجاد ساختارها زدیم، توجه کنید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type employee struct { 6 name string 7 age int 8 salary int 9} 10 11func main() { 12 emp1 := employee{} 13 fmt.Printf(\u0026#34;Emp1: %+v\\n\u0026#34;, emp1) 14 15 emp2 := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} 16 fmt.Printf(\u0026#34;Emp2: %+v\\n\u0026#34;, emp2) 17 18 emp3 := employee{ 19 name: \u0026#34;Sam\u0026#34;, 20 age: 31, 21 salary: 2000, 22 } 23 fmt.Printf(\u0026#34;Emp3: %+v\\n\u0026#34;, emp3) 24 25 emp4 := employee{ 26 name: \u0026#34;Sam\u0026#34;, 27 age: 31, 28 } 29 fmt.Printf(\u0026#34;Emp4: %+v\\n\u0026#34;, emp4) 30} 1$ go run main.go 2Emp1: {name: age:0 salary:0} 3Emp2: {name:Sam age:31 salary:2000} 4Emp3: {name:Sam age:31 salary:2000} 5Emp4: {name:Sam age:31 salary:0} ایجاد متغیر ساختار و مقدار دهی فیلدها بدون نام فیلد: شما می‌توانید فیلدها را بدون اینکه نام فیلد را قرار دهید مقدار دهی کنید اما از نظر تکنیکی این کار توصیه نمی‌شود، دلیل این توصیه هم این است که اگر شما فیلدها رو به این روش مقدار دهی کنید، باید ترتیب رو در نظر بگیرید یعنی 1: باید نام باشد، 2: باید سن باشد، 3: باید درآمد باشد و اگر این ترتیب رعایت نشود شما دیتای اشتباهی خواهید داشت.\n1emp := employee{\u0026#34;Sam\u0026#34;, 31, 2000} 2 3{Sam 31 2000} // حروجی در مثال بالا ترتیب رعایت شده. به مثال زیر توجه کنید:\n1emp := employee{\u0026#34;Sam\u0026#34;, 2000, 31} 2 3{Sam 2000 31} // حروجی همانطور که در مثال بالا دیدین الان با ترتیب اشتباه سن کارمند و درآمدش جابه جا شدن و ما دیتای اشتباهی از کارمند خواهیم داشت.\n2.2.3 دسترسی و تنظیم فیلدهای ساختار (struct) # زمانیکه شما یک متغیر ساختار تعریف می‌کنید، می‌توانید خیلی آسان با استفاده از همان متغیر به فیلدهای ساختار دسترسی پیدا کنید و مقدار هر کدام از فیلدها را تغییر دهید. به مثال زیر توجه کنید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type employee struct { 6 name string 7 age int 8 salary int 9} 10 11func main() { 12 emp := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} 13 14 //Accessing a struct field 15 fmt.Printf(\u0026#34;Current name is: %s\\n\u0026#34;, emp.name) 16 17 //Assigning a new value to name field 18 emp.name = \u0026#34;John\u0026#34; 19 fmt.Printf(\u0026#34;New name is: %s\\n\u0026#34;, emp.name) 20} 1$ go run main.go 2Current name is: Sam 3New name is: John 2.2.4 کار با اشاره‌گر (Pointer) در ساختار (struct) # شما برای ایجاد یک struct از نوع اشاره‌گر می‌توانید از دو حالت زیر استفاده کنید:\nبا استفاده از عملگر \u0026amp; که اشاره به خانه حافظه دارد با استفاده از تابع new 2.2.4.1 ایجاد ساختار با استفاده از عملگر \u0026amp; # برای اینکه بتوانید یک ساختار از نوع اشاره گر ایجاد کنید می‌توانید از عملگر \u0026amp; استفاده کنید. به مثال زیر توجه کنید:\n1emp := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} 2empP := \u0026amp;emp حتی شما می‌توانید یک ساختار اشاره‌گر را مستقیماً ایجاد کنید این روش پیشنهاد می‌شود. به مثال زیر توجه کنید:\n1empP := \u0026amp;employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} در مثال زیر هر دو روش رو برای شما توضیح دادیم. با دقت به کد و خروجی کد نگاه کنید:‌\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type employee struct { 6 name string 7 age int 8 salary int 9} 10 11func main() { 12 emp := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} 13 empP := \u0026amp;emp 14 fmt.Printf(\u0026#34;Emp: %+v\\n\u0026#34;, empP) 15 empP = \u0026amp;employee{name: \u0026#34;John\u0026#34;, age: 30, salary: 3000} 16 fmt.Printf(\u0026#34;Emp: %+v\\n\u0026#34;, empP) 17} 1$ go run main.go 2Emp: \u0026amp;{name:Sam age:31 salary:2000} 3Emp: \u0026amp;{name:John age:30 salary:3000} 2.2.4.2 ایجاد ساختار با استفاده تابع new # 1func new(Type) *Type همینطور که در تعریف تابع new هم می‌بینید، این تابع یک تایپ از ما می‌گیرد و مقدار دهی می‌کند، و در آخر هم تایپ را از نوع اشاره‌گر برای ما بر می‌گرداند.\nبا استفاده از تابع new :\nشما یک ساختار ایجاد می‌کنید. سپس فیلدها، با مقدار پیش‌فرض صفر مقدار دهی اولیه می‌شوند. در نهایت ساختار شما از نوع اشاره‌گر بازگشت داده می‌شود. به مثال زیر توجه کنید:\n1empP := new(employee) برای اینکه آدرس خانه حافظه ساختار، از نوع اشاره‌گر را ببینید کافی است با استفاده از p% اون ساختار رو چاپ کنید. به مثال زیر توجه کنید:\n1fmt.Printf(\u0026#34;Emp Pointer: %p\\n\u0026#34;, empP) برای اینکه مقدار کلی فیلدها را ببینید کافی است با استفاده از v+% اون رو چاپ کنید. به مثال زیر توجه کنید:\n1fmt.Printf(\u0026#34;Emp Value: %+v\\n\u0026#34;, *empP) در مثال زیر خروجی آنچه در بالا گفته شد رو قرار دادیم. لطفاً با دقت به مثال زیر نگاه کنید و در آخر هم مثال‌های مشابهی رو برای خودتان بنویسید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type employee struct { 6 name string 7 age int 8 salary int 9} 10 11func main() { 12 empP := new(employee) 13 fmt.Printf(\u0026#34;Emp Pointer Address: %p\\n\u0026#34;, empP) 14 fmt.Printf(\u0026#34;Emp Pointer: %+v\\n\u0026#34;, empP) 15 fmt.Printf(\u0026#34;Emp Value: %+v\\n\u0026#34;, *empP) 16} 1$ go run main.go 2Emp Pointer Address: 0xc000130000 3Emp Pointer: \u0026amp;{name: age:0 salary:0} 4Emp Value: {name: age:0 salary:0} 2.2.5 چاپ یک متغیر ساختار (struct) # برای اینکه بتوانید یک متغیر ساختار struct را چاپ کنید، از دو روش زیر می‌توانید استفاده کنید. توجه کنید متغیر ساختار بصورت key/value هست.\nبا استفاده از پکیج fmt با استفاده از پکیج json/encoding 2.2.5.1 چاپ با استفاده از fmt # در پکیج fmt ما 2 تا تابع کاربردی جهت چاپ داریم که اکثر اوقات از این دو تابع استفاده می‌کنیم:\nتابع Println ورودی را با فرمت پیش‌فرض چاپ می‌کند. تابع Printf ورودی را با فرمت مشخص شده چاپ می‌کند فرمت رو خود ما مشخص می‌کنیم. در مثال زیر ما یک نمونه از ساختار employee را ایجاد کردیم:\n1emp := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} حال با استفاده از تابع Printf ساختار را با فرمت دلخواه خودمان چاپ کردیم:\n1fmt.Printf(\u0026#34;%v\u0026#34;, emp) - {Sam 31 2000} 1fmt.Printf(\u0026#34;%+v\u0026#34;, emp) - {name:Sam age:31 salary:2000} %v - مقدار value هر کدام از فیلدهای ساختار را چاپ می‌کند. %+v - مقدار هرکدام از فیلدها به همراه اسم فیلد key-value را چاپ می‌کند. در مثال زیر ما با استفاده از از تابع Println ساختار را چاپ کردیم:\n1fmt.Println(emp) - {Sam 31 2000} در نهایت کد زیر یک مثال کلی از چاپ با استفاده از پکیج fmt است‌:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type employee struct { 6 name string 7 age int 8 salary int 9} 10 11func main() { 12 emp := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} 13 fmt.Printf(\u0026#34;Emp: %v\\n\u0026#34;, emp) 14 fmt.Printf(\u0026#34;Emp: %+v\\n\u0026#34;, emp) 15 fmt.Printf(\u0026#34;Emp: %#v\\n\u0026#34;, emp) 16 fmt.Println(emp) 17} 1$ go run main.go 2Emp: {Sam 31 2000} 3Emp: {name:Sam age:31 salary:2000} 4Emp: main.employee{name:\u0026#34;Sam\u0026#34;, age:31, salary:2000} 5{Sam 31 2000} 2.2.5.2 چاپ ساختار با استفاده از پکیج JSON # در این روش ما با استفاده از ۲ تابع Marshal و MarshalIndent پکیج json، ساختار را encode می‌کنیم و در نهایت خروجی encode شده را چاپ می‌کنیم.\nMarshal - در این تابع ما به عنوان ورودی‌، ساختار را پاس می‌دهیم و در نهایت ۲ خروجی از نوع بایت و خطا دریافت می‌کنیم. 1Marshal(v interface{}) ([]byte, error) MarhsalIndent - در این تابع ما ۳ تا ورودی به تابع می‌فرستیم, به ترتیب ساختار، پیشوند و indent و در نهایت ۲ خروجی از نوع بایت و خطا دریافت می‌کنیم. 1MarshalIndent(v interface{}, prefix, indent string) ([]byte, error) حالا با استفاده از توابع فوق یک کد نمونه مثال می‌زنیم و به شما یاد می‌دیم که چطور از این توابع استفاده کنید. به مثال زیر دقت کنید:\n1package main 2 3import ( 4 \u0026#34;encoding/json\u0026#34; 5 \u0026#34;fmt\u0026#34; 6 \u0026#34;log\u0026#34; 7) 8 9type employee struct { 10 Name string 11 Age int 12 salary int 13} 14 15func main() { 16 emp := employee{Name: \u0026#34;Sam\u0026#34;, Age: 31, salary: 2000} 17 //Marshal 18 empJSON, err := json.Marshal(emp) 19 if err != nil { 20 log.Fatalf(err.Error()) 21 } 22 fmt.Printf(\u0026#34;Marshal funnction output %s\\n\u0026#34;, string(empJSON)) 23 24 //MarshalIndent 25 empJSON, err = json.MarshalIndent(emp, \u0026#34;\u0026#34;, \u0026#34; \u0026#34;) 26 if err != nil { 27 log.Fatalf(err.Error()) 28 } 29 fmt.Printf(\u0026#34;MarshalIndent funnction output %s\\n\u0026#34;, string(empJSON)) 30} 1$ go run main.go 2Marshal funnction output {\u0026#34;Name\u0026#34;:\u0026#34;Sam\u0026#34;,\u0026#34;Age\u0026#34;:31} 3 4MarshalIndent funnction output { 5 \u0026#34;Name\u0026#34;: \u0026#34;Sam\u0026#34;, 6 \u0026#34;Age\u0026#34;: 31 7} برای اطلاعات بیشتر در خصوص پکیج json می‌توانید به بخش آموزش کار با json مراجعه کنید. 2.2.6 کار با تگ ها در ساختار (struct) # ساختار زبان گو، به شما امکان اضافه کردن metadata به هر یک از فیلدها را می‌دهد و ما این قابلیت را به عنوان تگ می‌شناسیم. تگ‌ها برای انجام یکسری عملیات خاص نظیر encode/decode، اعتبارسنجی مقادیر فیلدها و \u0026hellip; به ما کمک می‌کند و یکی از کاربردی‌ترین عناوین در ساختار هستند.\nبه مثال های زیر توجه کنید تا کارکرد تگ ها را متوجه شوید:\n1type strutName struct{ 2 fieldName type `key:\u0026#34;value\u0026#34; key2:\u0026#34;value2\u0026#34;` 3} 1type employee struct { 2 Name string 3 Age int 4 Salary int 5} در این مثال، مقدار داخل متغیری که از نوع Employee است را تبدیل به json می کنیم و چاپ می کنیم.\n1package main 2 3import ( 4 \u0026#34;encoding/json\u0026#34; 5 \u0026#34;fmt\u0026#34; 6 \u0026#34;log\u0026#34; 7) 8 9type employee struct { 10 Name string 11 Age int 12 Salary int 13} 14 15func main() { 16 emp := employee{Name: \u0026#34;Sam\u0026#34;, Age: 31, Salary: 2000} 17 //Converting to jsonn 18 empJSON, err := json.MarshalIndent(emp, \u0026#34;\u0026#34;, \u0026#34; \u0026#34;) 19 if err != nil { 20 log.Fatalf(err.Error()) 21 } 22 fmt.Println(string(empJSON)) 23} خروجی :\n1$ go run main.go 2{ 3 \u0026#34;Name\u0026#34;: \u0026#34;Sam\u0026#34;, 4 \u0026#34;Age\u0026#34;: 31, 5 \u0026#34;Salary\u0026#34;: 2000 6} حالا به ما می گویند که اول اسم فیلد ها در خروجی json با حرف بزرگ شروع نشود و حرف کوچک باشد. اولین چیزی که شاید به ذهن شما خطور کند این است که اسم فیلد ها را در ساختار تعریف شده با حروف کوچک شروع کنیم:\n1package main 2 3import ( 4\t\u0026#34;encoding/json\u0026#34; 5\t\u0026#34;fmt\u0026#34; 6\t\u0026#34;log\u0026#34; 7) 8 9type employee struct { 10\tname string 11\tage int 12\tsalary int 13} 14 15func main() { 16\temp := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} 17\t//Converting to jsonn 18\tempJSON, err := json.MarshalIndent(emp, \u0026#34;\u0026#34;, \u0026#34; \u0026#34;) 19\tif err != nil { 20\tlog.Fatalf(err.Error()) 21\t} 22\tfmt.Println(string(empJSON)) 23} خروجی :\n1$ go run main.go 2{} اما خروجی ما یک json خالی است. جرا؟ چون زمانی که اسم فیلد‌ ها با حروف کوچک شروع شوند private هستند و از بیرون قابل دسترسی نیستند. به همین دلیل خروجی یک json خالی است.\nبرای حل این مشکل ما برای ساختار خودمان یک تگ json اضافه می کنیم و می گوییم اسم فیلد تو در json چیز دیگری است:\n1package main 2 3import ( 4\t\u0026#34;encoding/json\u0026#34; 5\t\u0026#34;fmt\u0026#34; 6\t\u0026#34;log\u0026#34; 7) 8 9type employee struct { 10\tName string `json:\u0026#34;name\u0026#34;` 11\tAge int `json:\u0026#34;age\u0026#34;` 12\tSalary int `json:\u0026#34;salary\u0026#34;` 13} 14 15func main() { 16\temp := employee{Name: \u0026#34;Sam\u0026#34;, Age: 31, Salary: 2000} 17\t//Converting to jsonn 18\tempJSON, err := json.MarshalIndent(emp, \u0026#34;\u0026#34;, \u0026#34; \u0026#34;) 19\tif err != nil { 20\tlog.Fatalf(err.Error()) 21\t} 22\tfmt.Println(string(empJSON)) 23} خروجی :\n1$ go run main.go 2{ 3 \u0026#34;name\u0026#34;: \u0026#34;Sam\u0026#34;, 4 \u0026#34;age\u0026#34;: 31, 5 \u0026#34;salary\u0026#34;: 2000 6} فکر می‌کنم خروجی بالا کاملاً برای ما روشن کرد که دقیقاً اون تگ‌هایی که قرار دادیم، برای ما چه کاری انجام دادند. بله کلید-key‌های ما را به اون نام‌هایی که در تگ‌ها نوشته بودیم تغییر دادند.\n2.2.6.1 چند نمونه از کاربرد تگ ها # تگ ها کاربرد های خیلی زیادی دارند که در بخش قرار است بعضی از آنها را بررسی کنیم.\nمی توانید با تگ (-) مشخص کنید که آن فیلد موقع سریالایز نادیده گرفته شود و نمایش داده نشود. مثال:\n1package main 2 3import ( 4\t\u0026#34;encoding/json\u0026#34; 5\t\u0026#34;fmt\u0026#34; 6\t\u0026#34;log\u0026#34; 7) 8 9type employee struct { 10\tName string `json:\u0026#34;name\u0026#34;` 11\tAge int `json:\u0026#34;-\u0026#34;` 12\tSalary int `json:\u0026#34;salary\u0026#34;` 13} 14 15func main() { 16\temp := employee{Name: \u0026#34;Sam\u0026#34;, Salary: 2000} 17\t//Converting to jsonn 18\tempJSON, err := json.MarshalIndent(emp, \u0026#34;\u0026#34;, \u0026#34; \u0026#34;) 19\tif err != nil { 20\tlog.Fatalf(err.Error()) 21\t} 22\tfmt.Println(string(empJSON)) 23} خروجی :\n1$ go run main.go 2{ 3 \u0026#34;name\u0026#34;: \u0026#34;Sam\u0026#34;, 4 \u0026#34;salary\u0026#34;: 2000 5} با استفاده از تگ omitempty اگر آن فیلد مقداری نداشته باشد، نمایش داده نمی شود:\n1package main 2 3import ( 4\t\u0026#34;encoding/json\u0026#34; 5\t\u0026#34;fmt\u0026#34; 6\t\u0026#34;log\u0026#34; 7) 8 9type employee struct { 10\tName string `json:\u0026#34;name,omitempty\u0026#34;` 11\tAge int `json:\u0026#34;age,omitempty\u0026#34;` 12\tSalary int `json:\u0026#34;salary,omitempty\u0026#34;` 13} 14 15func main() { 16\temp := employee{Age: 22, Salary: 2000} 17\t//Converting to jsonn 18\tempJSON, err := json.MarshalIndent(emp, \u0026#34;\u0026#34;, \u0026#34; \u0026#34;) 19\tif err != nil { 20\tlog.Fatalf(err.Error()) 21\t} 22\tfmt.Println(string(empJSON)) 23} خروجی :\n1$ go run main.go 2{ 3 \u0026#34;age\u0026#34;: 22, 4 \u0026#34;salary\u0026#34;: 2000 5} از دیگر کاربرد های تگ ها می توان به عملیات اعتبار سنجی اشاره کرد. برای مثال می توان چک کرد فیلد شماره موبایل از یازده رقم بیشتر و کمتر نباشد. همچنین در تعریف مدل های دیتابیس با استفاده از تگ ها ارتباط بین دیتابیس و مدل را می توانیم پیاده سازی کنیم و \u0026hellip;\n2.2.7 تعریف فیلد ناشناس در ساختار (struct) # شما در ساختار struct امکان تعریف فیلدهای ناشناس را دارید و همینطور می‌توانید فیلدهای ناشناس را نیز مقدار دهی کنید.\n1type employee struct { 2 string 3 age int 4 salary int 5} در کد زیر یک مثال ساده در خصوص تعریف و مقدار دهی فیلدهای ناشناس زده‌ایم:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type employee struct { 6 string 7 age int 8 salary int 9} 10 11func main() { 12 emp := employee{string: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} 13 //Accessing a struct field 14 n := emp.string 15 fmt.Printf(\u0026#34;Current name is: %s\\n\u0026#34;, n) 16 //Assigning a new value 17 emp.string = \u0026#34;John\u0026#34; 18 fmt.Printf(\u0026#34;New name is: %s\\n\u0026#34;, emp.string) 19} 1$ go run main.go 2Current name is: Sam 3New name is: John توجه داشته باشید زمانی که از فیلد های ناشناس استفاده می کنید، از هر دیتاتایپ فقط یکبار می توانید استفاده کنید:\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7type employee struct { 8\tstring // name 9\tint // age 10\tint // salary 11} 12 13func main() { 14\temp := employee{\u0026#34;alireza\u0026#34;, 22, 10_000_000} 15 16\tfmt.Printf(\u0026#34;%+v\u0026#34;, emp) 17} 1$ go run main.go 2# command-line-arguments 3./main.go:10:2: int redeclared 4\t./main.go:9:2: other declaration of int 5./main.go:14:33: too many values in struct literal of type employee 2.2.8 تعریف ساختار تو در تو (nested) # یکی دیگر از امکانات ساختار در زبان گو بحث ساختار تو در تو است. در مثالی که در ادامه زدیم ساختار address را داخل employee قرار دادیم:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type employee struct { 6 name string 7 age int 8 salary int 9 address address 10} 11 12type address struct { 13 city string 14 country string 15} 16 17func main() { 18 address := address{city: \u0026#34;London\u0026#34;, country: \u0026#34;UK\u0026#34;} 19 emp := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000, address: address} 20 fmt.Printf(\u0026#34;City: %s\\n\u0026#34;, emp.address.city) 21 fmt.Printf(\u0026#34;Country: %s\\n\u0026#34;, emp.address.country) 22} 1$ go run main.go 2City: London 3Country: UK توجه کنید شما طبق روش زیر می‌توانید به فیلدهای تو در تو دسترسی داشته باشید:\n1emp.address.city 2emp.address.country بعضی مواقع بهتر است بصورت مستقیم به فیلد های درون ساختار تو‌در‌تو دسترسی داشته باشیم. به مثال زیر دقت کنید:\n1package main 2 3type Product struct { 4\tName string 5\tPrice int 6} 7 8type Mobile struct { 9\tProduct Product 10\tRam int 11\tSimCount int 12} 13 14func main() { 15\tvar mobile Mobile = Mobile{} 16\tmobile.Product.Name = \u0026#34;Iphone 11\u0026#34; 17\tmobile.Product.Price = 1000 18\tmobile.Ram = 8 19\tmobile.SimCount = 1 20} همانطور که می بینید برای تعریف اسم موبایل باید بگوییم mobile.Product.Name که این زیاد جالب نیست. پس به این صورت ساختار Product را درون موبایل قرار می دهیم:\n1package main 2 3type Product struct { 4\tName string 5\tPrice int 6} 7 8type Mobile struct { 9\tProduct 10\tRam int 11\tSimCount int 12} 13 14func main() { 15\tvar mobile Mobile = Mobile{} 16\tmobile.Name = \u0026#34;Iphone 11\u0026#34; 17\tmobile.Price = 1000 18\tmobile.Ram = 8 19\tmobile.SimCount = 1 20} الان بصورت مستقیم می توانیم به فیلد های درون Product دسترسی داشته باشیم.\n2.2.9 تعریف یک ساختار عمومی یا خصوصی (Public/Private) # در زبان گو، چیزی به عنوان کلمه کلیدی public یا private جهت تعیین وضعیت دسترسی struct به بیرون وجود ندارد، در عوض کامپایلر گو بر اساس حرف بزرگ یا کوچک عنوان ساختار یا سایر تایپ‌ها، تشخیص می‌دهد تایپ شما عمومی است یا خصوصی. در صورتیکه شما حرف اول را کوچک قرار دهید تایپ شما بیرون از پکیج قابل دسترس نخواهد بود مثل مثال‌های بالا و اگر حرف اول تایپ رو بزرگ قرار دهید، تایپ یا تابع شما بیرون از پکیج نیز در دسترس خواهد بود. مثال تابع fmt.Println.\n1type Person struct { 2 Name string 3 age int 4} 5 6type company struct { 7 Name string 8} برای اطلاعات بیشتر بهتر است به بخش کپسوله سازی مراجعه کنید. 2.2.10 مقایسه ساختارها # شما در زبان گو می‌توانید ساختارها را بر اساس عنوان فیلد، تایپ و مقدارشان مقایسه کنید. اما باید توجه کنید ساختارها فقط براساس تایپ‌هایی که در ادامه معرفی کردیم, امکان مقایسه را خواهند داشت:\nboolean numeric string pointer channel interface types structs array و اما ۳ تایپ زیر امکان مقایسه را به شما نمی‌دهند:\nSlice Map Function 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type employee struct { 6 name string 7 age int 8 salary int 9} 10 11func main() { 12 emp1 := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} 13 emp2 := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} 14 if emp1 == emp2 { 15 fmt.Println(\u0026#34;emp1 annd emp2 are equal\u0026#34;) 16 } else { 17 fmt.Println(\u0026#34;emp1 annd emp2 are not equal\u0026#34;) 18 } 19} 1$ go run main.go 2emp1 annd emp2 are equal "},{"id":26,"href":"/chapter-2/method/","title":"2.3 متد (Method)","section":"فصل دوم: مکانیزم‌های زبان","content":"متد در واقع یک تابع گیرنده (receiver) است که به واسطه یک تایپ در دسترس خواهد بود. توجه کنید برای تعریف متد باید قبل از اسم تابع، داخل پرانتز یک نام و یک تایپ قرار دهید. برای درک بهتر این موضوع فکر کنید نامی که داخل پرانتز قرار می‌دید یه متغیر هست که به تایپ شما اشاره می‌کند. به مثال زیر توجه کنید:\n1func (receiver receiver_type) some_func_name(arguments) return_values برای درک بهتر این مفهوم، می‌توانید متد را دقیقاً یک تابع در نظر بگیرید. نحوه تعریف به صورت متد صرفاً برای راحتی در زمان توسعه نرم افزار است و به برنامه‌نویس امکان توسعه بهتر بدون نیاز به حفظ کردن زیاد عملکرد‌های سیستم را می‌دهد.\n1func (r receiver_T) some_func_name(arg1 arg1_T, ...) return_values 2func some_func_name(r receiver_T, arg1 arg1_T, ...) return_values نکته قابل ذکر دیگر در خصوص این مفهوم این است که متد در زبان گو از رویکرد static method به صورت مستقیم پشتیبانی نمی‌‌کند، یعنی تا زمانیکه شما یک متغیر از نوع تایپی که دارای متد است را راه اندازی نکنید، به متدهایش دسترسی نخواهید داشت.\nاکثراً متد را یکی از عناوین شی‌گرایی در زبان گو می‌شناسند که مزایای خوبی دارد، بخصوص اگر متدها برای تایپ struct تعریف شوند شما می‌توانید برای هر یک از فیلدهای ساختار، توابع بخصوصی در قالب متد بنویسید، ولی اگر بخوایم کمی دقیق‌تر بگیم مفهوم متد برگرفته از الگوی Encapsulation است که بر خلاف تصور رایج صرفاً محدود به رویکرد OOP نیست و یک الگوی پذیرفته شده حتی در زبان‌های Functional programming languages نیز است.\n2.3.1 متدها برای ساختار (struct) # زبان گو یک زبان شی گرا نیست ولی برخی از مفاهیم شی‌گرایی را بصورت قرار دادی دارد. ساختار در زبان گو یک تایپ است که این تایپ نیز کالکشنی از تایپ‌های مختلف را در بر می‌گیرد که ما در بخش قبلی بهش پرداختیم.\nبه مثالی که در مورد پیاده‌سازی متد‌ها زده‌ایم توجه کنید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type employee struct { 6 name string 7 age int 8 salary int 9} 10 11func (e employee) details() { 12 fmt.Printf(\u0026#34;Name: %s\\n\u0026#34;, e.name) 13 fmt.Printf(\u0026#34;Age: %d\\n\u0026#34;, e.age) 14} 15 16func (e employee) getSalary() int { 17 return e.salary 18} 19 20func main() { 21 emp := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} 22 emp.details() 23 fmt.Printf(\u0026#34;Salary %d\\n\u0026#34;, emp.getSalary()) 24} 1$ go run main.go 2Name: Sam 3Age: 31 4Salary 2000 در کد بالا ما یک ساختار با نام employee ایجاد کردیم و سپس ۲ متد با نام‌های details و getSalary برای آن تعریف کردیم. حال برای اینکه بتوانیم از این متدها استفاده کنیم داخل تابع main، یک متغیر از نوع employee تعریف کردیم و سپس با استفاده از نقطه . پس از نام متغیر به متدها دسترسی پیدا کردیم همانند دسترسی به فیلدهای ساختار.\nآیا با استفاده از متد می‌توانیم مقدار یکی از فیلدهای داخل ساختار را تغییر دهیم ؟ این سوال ۲ جواب دارد هم بله و هم خیر\nحال به مثال زیر توجه کنید تا توضیح دهیم:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type employee struct { 6 name string 7 age int 8 salary int 9} 10 11func (e employee) setNewName(newName string) { 12 e.name = newName 13} 14 15func main() { 16 emp := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} 17 emp.setNewName(\u0026#34;John\u0026#34;) 18 fmt.Printf(\u0026#34;Name: %s\\n\u0026#34;, emp.name) 19} 1$ go run main.go 2Name: Sam علت اینکه می‌گوییم خیر : به خاطر اینکه ما داریم با یک کپی از فیلدهای ساختار کار می‌کنیم و با تغییر مقدار هر یک از فیلدها تغییر بر روی کپی آن اعمال خواهد شد. اما علت اینکه می‌گوییم بله : اگر ما با استفاده از اشاره‌گر pointer به فیلدهای داخل ساختار دسترسی پیدا کنیم می‌توانیم مستقیماً به داخل خانه حافظه تایپ دسترسی داشته باشیم و مقدار فیلد مورد نظر را در هر جایی از پروژه تغییر دهیم. 2.3.2 استفاده از اشاره‌گر (pointer) در متدها # در مثال بالا ما به این اشاره کردیم که آیا می‌شود مقدار هر یک از فیلدهای ساختار را با استفاده از متد تغییر داد یا خیر و در پاسخ گفتیم هم می شود و هم نه. سپس علتش را توضیح دادیم. حال می‌خواهیم با یک مثال این مورد را توضیح دهیم چگونه می نوانیم هر یک از فیلد های ساختار را از طریق متد تغییر دهیم. به مثال زیر توجه کنید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type employee struct { 6 name string 7 age int 8 salary int 9} 10 11func (e *employee) setNewName(newName string) { 12 e.name = newName 13} 14 15func main() { 16 emp := \u0026amp;employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} 17 emp.setNewName(\u0026#34;John\u0026#34;) 18 fmt.Printf(\u0026#34;Name: %s\\n\u0026#34;, emp.name) 19} 1$ go run main.go 2Name: John در مثال بالا متد setNewName یک نوع متد گیرنده از نوع اشاره‌گر است که ما داخل این متد به مقدار فیلدهای داخل خانه حافظه ساختار employee دسترسی داریم و می‌توانیم آن‌ها را مقدار دهی کنیم.\nآیا استفاده از گیرنده اشاره‌گر واقعا ضروری است؟ خیر، ضروری نیست زیرا ما وقتی به متدها دسترسی داریم که یک نمونه (instance) از تایپ مورد نظر ایجاد کنیم تا به متدهایش دسترسی داشته باشیم و همچنین اگر فرضاً نیاز داشته باشیم که یکی از فیلدهای ساختار را مقدار دهی کنیم، باز هم می‌توانیم به آدرس خانه متغیری که ساختار را نگه داری می‌کند اشاره کنیم و مقدارش را تغییر دهیم. به مثال زیر توجه کنید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type employee struct { 6 name string 7 age int 8 salary int 9} 10 11func (e *employee) setNewName(newName string) { 12 e.name = newName 13} 14 15func main() { 16 emp := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} 17 emp.setNewName(\u0026#34;John\u0026#34;) 18 19 fmt.Printf(\u0026#34;Name: %s\\n\u0026#34;, emp.name) 20 21 (\u0026amp;emp).setNewName(\u0026#34;Mike\u0026#34;) 22 fmt.Printf(\u0026#34;Name: %s\\n\u0026#34;, emp.name) 23} 1$ go run main.go 2Name: John 3Name: Mike 2.3.2.1 چه موقع باید از گیرنده اشاره‌گر برای متد استفاده کنیم؟ # زمانیکه قصد داریم متدهایی بنویسیم که برروی مقدار فیلدهای ساختار در زمان اجرا تغییراتی انجام میدهند. زمانیکه ساختار خیلی بزرگ است و فیلدهای زیادی دارد. در این سناریو بهتر است از گیرنده اشاره‌گر استفاده کنیم تا هر بار با یکی کپی از ساختار مواجه نشویم. 2.3.4 تعریف متد برای فیلدهای ساختار تو در تو (nested) # شما می‌توانید برای فیلدهایی که ساختار تو در تو دارند نیز متد بنویسید. به مثال زیر توجه کنید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type employee struct { 6\tname string 7\tage int 8\tsalary int 9\taddress address 10} 11 12type address struct { 13\tcity string 14\tcountry string 15} 16 17func (a address) details() { 18\tfmt.Printf(\u0026#34;City: %s\\n\u0026#34;, a.city) 19\tfmt.Printf(\u0026#34;Country: %s\\n\u0026#34;, a.country) 20} 21 22func main() { 23\taddress := address{city: \u0026#34;London\u0026#34;, country: \u0026#34;UK\u0026#34;} 24 25\temp := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000, address: address} 26 27\temp.address.details() 28} 1$ go run main.go 2City: London 3Country: UK در مثال بالا ما یک متد برای ساختار address تعریف کردیم و سپس ساختار address را داخل ساختار employee گذاشتیم. در نهایت شما با استفاده از employee می‌توانید به متدهای address هم دسترسی داشته باشید و از آن‌ها استفاده کنید.\n"},{"id":27,"href":"/chapter-2/interface/","title":"2.4 اینترفیس (Interface)","section":"فصل دوم: مکانیزم‌های زبان","content":"اینترفیس در زبان گو مجموعه‌ای از متدها است. این مجموعه متدها با توجه به ورودی و خروجی که دارند دارای رفتارهای خاصی هستند. زمانیکه شما یک اینترفیس به همراه یکسری از متدها تعریف می‌کنید باید در جایی این متدها را پیاده سازی کنید.\nاینترفیس‌ها به شما اجازه می‌دهد تا از Duck typing استفاده کنید. حالا این duck typing چیست؟\nduck typing روشی در برنامه‌نویسی کامپیوتری است که به شما امکان می‌دهد تست اردک را انجام دهید، جایی که ما نوع را بررسی نمی‌کنیم، بلکه تنها وجود برخی ویژگی‌ها یا روش‌ها را بررسی می‌کنیم. بنابراین آنچه واقعاً اهمیت دارد این است که آیا یک شی دارای ویژگی‌ها و روش‌های خاصی است و نه نوع آن.\nبرگردیم به بحث اینترفیس, در زیر ما یک نمونه اینترفیس را قرار دادیم:\n1type name_of_interface interface{ 2//Method signature 1 3//Method signature 2 4} برای درک بهتر مفهوم ارائه شده، بیایید از یک مثال ساده استفاده کنیم. فرض کنید ما یک شی به نام «animal» داریم که شامل یکسری رفتارها است، مانند نفس کشیدن و راه رفتن. این رفتارها باید به یک حیوان خاص اختصاص یابند تا بتوانیم ویژگی‌ها و رفتارهای دقیق آن حیوان را مشخص و تعریف کنیم.\n1type animal interface { 2 breathe() 3 walk() 4} در بالا ما یک اینترفیس تعریف کردیم ۲ تا متد دارد حالا بیاید یک متغیر از نوع اینترفیس animal درست کنیم و چاپ کنیم.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type animal interface { 6 breathe() 7 walk() 8} 9 10func main() { 11 var a animal 12 fmt.Println(a) 13} 1$ go run main.go 2nil در بالا وقتی اینترفیس را چاپ کردیم، خروجی nil بود. توجه کنید اینترفیس مقدار پیش‌فرض یا خالی بودنش nil هست.\n2.4.1 پیاده‌سازی اینترفیس # در بالا ما یک اینترفیس animal تعریف کردیم که ۲ متد داشت حالا قصد داریم یک شی (منظور ساختار در گو) به نام lion تعریف کنیم و متدهای اینترفیس animal را پیاده‌سازی کنیم.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type animal interface { 6 breathe() 7 walk() 8} 9 10type lion struct { 11 age int 12} 13 14func (l lion) breathe() { 15 fmt.Println(\u0026#34;Lion breathes\u0026#34;) 16} 17 18func (l lion) walk() { 19 fmt.Println(\u0026#34;Lion walk\u0026#34;) 20} 21 22func main() { 23 var a animal 24 a = lion{age: 10} 25 a.breathe() 26 a.walk() 27} 1$ go run main.go 2Lion breathes 3Lion walk در بالا ما یک متغیر با تایپ animal تعریف کردیم:\n1var a animal سپس ما یک نمونه از ساختار lion را بهش اختصاص دادیم:\n1a = lion{} اختصاص یک نمونه از ساختار lion به متغیر a که با تایپ lion بود موفقیت آمیز بود زیرا ما برای lion متدهای مربوط به animal را که breathe و walk بود، پیاده سازی کردیم. این مفهوم کاملاً شبیه به ducking typing هست که در بالا گفتیم. یک شیر می‌تواند نفس بکشد و راه برود از این رو او یک حیوان است.\nتوجه کنید اگر شما متد جدیدی را اضافه یا کم کنید و همچنین اگر تغییر ایجاد کنید باید این تغییرات بر روی اشیایی که با اینترفیس شما در ارتباط هستند صورت بگیرید.\nبه عنوان مثال شما اگر به اینترفیس animal یک متد جدیدی اضافه کنید حتما باید برای ساختار lion هم پیاده سازی کنید.\n2.4.2 اینترفیس‌ها بطور ضمنی (implicitly) پیاده سازی می‌شود # برای اینترفیس هیچ حالت صریح (explicit) هنگام تعریف وجود ندارد و همه چی بصورت ضمنی است تا زمانیکه یک اینترفیس برای یک شی (ساختار) متدهایش پیاده سازی نشود هیچ کاربردی نخواهد داشت.\nتوجه کنید هیچ حالت صریحی وجود ندارد که بگوید شما تمامی متدهای اینترفیس animal را برای ساختار lion پیاده سازی کردید یا خیر و فقط در زمان کامپایل اگر ایرادی وجود داشته باشد کامپایلر به شما خطا می‌دهد و البته IDE هایی مانند: Goland , Vscode به شما هنگام نوشتن کد در خصوص این مورد کمک می‌کنند قبل از کامپایل متوجه خطاهای مرتبط با پیاده سازی اینترفیس شوید.\nخب بزارید یک مثال پیچیده برای اینترفیس animal بزنیم و یک شی (ساختار) دیگر به نام dog اضافه کنیم و متدهای اینترفیس animal را برای این شی پیاده سازی کنیم.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type animal interface { 6 breathe() 7 walk() 8} 9 10type lion struct { 11 age int 12} 13 14func (l lion) breathe() { 15 fmt.Println(\u0026#34;Lion breathes\u0026#34;) 16} 17 18func (l lion) walk() { 19 fmt.Println(\u0026#34;Lion walk\u0026#34;) 20} 21 22type dog struct { 23 age int 24} 25 26func (l dog) breathe() { 27 fmt.Println(\u0026#34;Dog breathes\u0026#34;) 28} 29 30func (l dog) walk() { 31 fmt.Println(\u0026#34;Dog walk\u0026#34;) 32} 33 34func main() { 35 var a animal 36 37 a = lion{age: 10} 38 a.breathe() 39 a.walk() 40 41 a = dog{age: 5} 42 a.breathe() 43 a.walk() 44} 1$ go run main.go 2Lion breathes 3Lion walk 4Dog breathes 5Dog walk در مثال بالا ما یک ساختار با نام dog تعریف کردیم و سپس متدهای animal را برای ساختار dog پیاده سازی کردیم و در نهایت ساختار dog را به متغیر اینترفیس a اختصاص دادیم. همانطور که می‌بینیم dog هم همانند lion نفس می‌کشد و راه می‌رود.\nتوجه کنید در بالا ما برای ۲ تا شی lion و dog یک وجه مشترک به نام animal به همراه رفتار مشترک تعریف کردیم که به اینکار پلی مورفیسم می‌گویند و یکی از عناوین پر کاربرد در شی‌گرایی می باشد که در بخش شی گرایی زبان گو بیشتر می‌پردازیم. دو نکته مهم در خصوص اینترفیس‌:\nاینترفیس‌ها فقط زمان کامپایل مشخص می‌شود که برای اشیا به درستی پیاده سازی شده‌اند یا خیر و اگر فرضاً ما برای ساختار lion در کد بالا متد walk را حذف کنیم با خطای زیر رو به رو خواهیم شد: 1cannot use lion literal (type lion) as type animal in assignment: ورود و خروجی‌های هر متدی که پیاده سازی می‌کنید برای اشیا (ساختارها) بستگی به تعریف ضمنی متد داخل اینترفیس دارد و اگر شما متدی را داخل اینترفیس تغییر دهید حتما باید آن متد در اشیایی که قبلا پیاده سازی شده تغییر یابد. حالا فرض کنید ما برای اینترفیس animal یک متد جدیدی به نام speed تعریف کردیم که این متد به عنوان خروجی مقداری با تایپ int بر می‌گرداند:\n1type animal interface { 2 breathe() 3 walk() 4 speed() int 5} حالا ساختار lion باید متد speed را مانند کد زیر پیاده سازی کرده باشد :\n1func (l lion) speed() اگر دقت کنید ما داخل اینترفیس animal گفتیم متد speed یک مقدار خروجی از نوع int دارد ولی ما برای ساختار lion متد speed را بدون خروجی نوشتیم. اتفاقی که می‌افتد هنگام کامپایل با خطای زیر مواجه خواهیم شد :\n1cannot use lion literal (type lion) as type animal in assignment: 2 lion does not implement animal (wrong type for speed method) 3 have speed() 4 want speed() int با توجه به اتفاقی که افتاد ما نتیجه میگریم متدی که داخل اینترفیس به همراه ورودی و خروجی اضافه می‌شود باید به همان شکل برای ساختارهامون پیاده سازی کنیم.\n2.4.3 استفاده از اینترفیس به عنوان پارامتر ورودی تابع # توابع، تایپ‌های اینترفیس را به عنوان ورودی قبول می‌کنند و هر ساختار یا تایپی متدهای اینترفیس را پیاده سازی کرده باشد می‌تواند به عنوان پارامتر ورودی به تابع ارسال شود.\nبه عنوان مثال ما در کد زیر ۲ تا تابع داریم به نام های callBreathe و callWalk که به عنوان ورودی اینترفیس animal را قبول می‌کند و ما ۲ نمونه از ساختارهای lion و dog را که متدهای اینترفیس animal را پیاده سازی کرده‌اند را به این ۲ تابع پاس دادیم.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type animal interface { 6\tbreathe() 7\twalk() 8} 9 10type lion struct { 11 age int 12} 13 14func (l lion) breathe() { 15\tfmt.Println(\u0026#34;Lion breathes\u0026#34;) 16} 17 18func (l lion) walk() { 19\tfmt.Println(\u0026#34;Lion walk\u0026#34;) 20} 21 22type dog struct { 23 age int 24} 25 26func (l dog) breathe() { 27\tfmt.Println(\u0026#34;Dog breathes\u0026#34;) 28} 29 30func (l dog) walk() { 31\tfmt.Println(\u0026#34;Dog walk\u0026#34;) 32} 33 34func main() { 35\tl := lion{age: 10} 36\tcallBreathe(l) 37\tcallWalk(l) 38 39\td := dog{age: 5} 40\tcallBreathe(d) 41\tcallWalk(d) 42} 43 44func callBreathe(a animal) { 45\ta.breathe() 46} 47 48func callWalk(a animal) { 49\ta.breathe() 50} 1$ go run main.go 2Lion breathes 3Lion walk 4Dog breathes 5Dog walk 2.4.4 چرا اینترفیس؟ # شاید برای شما این سوال پیش بیاد چرا باید از اینترفیس استفاده کنیم و مزایای آن چیست؟ ما در زیر مزایای استفاده از اینترفیس و علت اینکه چرا باید از اینترفیس استفاده کنیم را توضیح خواهیم داد.\nاینترفیس به ما در نوشتن کدهای ماژولارتر و جدا شده‌‌تر بین بخش‌های مختلف کد کمک می‌کند و همچنین می‌تواند باعث کاهش وابستگی بین بخش‌های مختلف کد شود. کد باید برای تغییر بسته، و برای توسعه باز باشد. # اصل باز و بسته بودن یا اصل Open/Closed به نظر بسیاری، اساس برنامه نویسی شی گرا را تشکیل می‌دهد. رابرت مارتین (Robert C. Martin) که در بین برنامه نویسان به عمو باب (Uncle Bob) مشهور است با عبارت: \u0026ldquo;مهم‌ترین اصل طراحی شی گرا\u0026rdquo; از این اصل یاد کرده است. ما با استفاده از اینترفیس ها میتونیم این اصل مهم رو پیاده سازی کنیم.\nبزارید چند مثال کاربردی بزنیم: فرض کنید ما چند تا سرویس اس ام اس داریم و در آینده هم ممکنه که سرویس های اس ام اس تغییر کنند و از یک ارائه دهنده دیگه خدمات بگیریم. خب در این صورت ما باید چیکار کنیم که با حذف و اضافه کردن سرویس جدید کد های ما تغییر نکنند؟ میایم یک اینترفیس به اسم مثلا Sms می نویسیم و مشخص میکنیم هر کی که میخواد از این اینترفیس استفاده کنه باید متد send_sms و هر چیزی که نیاز هستش رو پیاده سازیش کنه.\nفرض کنید شما یک برنامه نوشتید که یک لایه دیتابیس دارد و داده‌ها، با توجه به کانفیگ، در یکی از دو دیتابیس mongodb یا arangodb ذخیره ‌می‌شود. حالا اگر ما بیایم در لایه دیتابیس یک اینترفیس قرار دهیم و متدهای مربوط به تعاملات با دیتابیس را ایجاد کنیم، در برنامه‌ای که نوشتیم فقط کافیست متدهای ایترفیس استفاده شود تا با توجه به نوع کانفینگ دیتابیس، پیاده سازی متود اجرا شود. یعنی اگر ما بیایم داخل کانفیگ پروژه تنظیمات arangodb را به mongodb تغییر دهیم بدون هیچ تغییری در لایه برنامه می‌توانیم به واسطه اینترفیسی که قرار دادیم با دیتابیس mongodb تعامل داشته باشیم.\nاز اینترفیس‌ها می‌توان برای پیاده‌سازی مفهوم پلی مورفیسم در زمان اجرا استفاده کرد. که به این مفهوم RunTime Polymorphism می‌گویند. بزارید یک مثال برای توضیح فوق بزنیم:\nفرض کنید کشورهای مختلف روش‌های مختلفی برای محاسبه مالیات دارند که شما می‌توانید با استفاده از یک اینترفیس این عملیات محاسبه را انجام دهید.\n1type taxCalculator interface{ 2 calculateTax() 3} در بالا ما یک اینترفیس با نام taxCalculator داریم که یک متد به نام calculateTax برای محاسبه مالیات دارد. حالا ما باید به ازای هر کشور یک ساختار داشته باشیم که این ساختارها باید متد calculateTax را با توجه شیوه محاسباتی خود پیاده سازی کرده باشند.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type taxSystem interface { 6 calculateTax() int 7} 8type indianTax struct { 9 taxPercentage int 10 income int 11} 12func (i *indianTax) calculateTax() int { 13 tax := i.income * i.taxPercentage / 100 14 return tax 15} 16type singaporeTax struct { 17 taxPercentage int 18 income int 19} 20func (i *singaporeTax) calculateTax() int { 21 tax := i.income * i.taxPercentage / 100 22 return tax 23} 24type usaTax struct { 25 taxPercentage int 26 income int 27} 28func (i *usaTax) calculateTax() int { 29 tax := i.income * i.taxPercentage / 100 30 return tax 31} 32func main() { 33 indianTax := \u0026amp;indianTax{ 34 taxPercentage: 30, 35 income: 1000, 36 } 37 singaporeTax := \u0026amp;singaporeTax{ 38 taxPercentage: 10, 39 income: 2000, 40 } 41 42 43 taxSystems := []taxSystem{indianTax, singaporeTax} 44 totalTax := calculateTotalTax(taxSystems) 45 46 47 fmt.Printf(\u0026#34;Total Tax is %d\\n\u0026#34;, totalTax) 48} 49 50func calculateTotalTax(taxSystems []taxSystem) int { 51 totalTax := 0 52 for _, t := range taxSystems { 53 totalTax += t.calculateTax() // در اینجا runtime polymorphism رخ می دهد 54 } 55 return totalTax 56} 1$ go run main.go 2Total Tax is 300 در خط زیر RunTime Polymorphism رخ داده است.\n1 totalTax += t.calculateTax() //This is where runtime polymorphism happens 2.4.5 استفاده از اشاره‌گر هنگام پیاده‌سازی اینترفیس # متدها تایپ‌های گیرنده خود را به دو صورت اشاره‌گر یا مقدار می‌توانند دریافت کنند. در بالا مثال animal را داشتیم که با حالت گیرنده مقدار بود. حالا می‌خواهیم بصورت گیرنده اشاره‌گر تعریف کنیم.\n2 نکته با توجه مثالی که خواهیم زد وجود دارد:\nاگر شما برای یک تایپ تمامی متدهای اینترفیس را بصورت گیرنده مقدار تعریف کرده باشید، هر دو متغیری که یک نمونه از تایپ را بصورت اشاره‌گر و بدون اشاره‌گر تعریف کرده باشد، می‌تواند به اینترفیس animal انتصاب شود و بدون هیچ مشکلی کار کند.\nاگر شما برای یک تایپی تمامی متدهای اینترفیس را بصورت گیرنده اشاره‌گر تعریف کرده باشید فقط متغیری که یک نمونه از تایپ که با اشاره‌گر تعریف کرده باشد می‌تواند به اینترفیس انتصاب یابد.\nمثال با حالت اولی که توضیح دادیم:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type animal interface { 6\tbreathe() 7\twalk() 8} 9 10type lion struct { 11\tage int 12} 13 14func (l lion) breathe() { 15\tfmt.Println(\u0026#34;Lion breathes\u0026#34;, l) 16} 17 18func (l lion) walk() { 19\tfmt.Println(\u0026#34;Lion walk\u0026#34;, l) 20} 21 22func main() { 23\tvar a animal 24 25\ta = lion{age: 10} 26\ta.breathe() 27\ta.walk() 28 29\ta = \u0026amp;lion{age: 5} 30\ta.breathe() 31\ta.walk() 32} 1$ go run main.go 2Lion breathes {10} 3Lion walk {10} 4Lion breathes {5} 5Lion walk {5} در بالا ما یک نمونه از ساختار lion با اشاره‌گر ایجاد کردیم و مقدار age را ۵ قرار دادیم و به اینترفیس animal انتصابش کردیم و بدون هیچ مشکلی کار کرد.\nحالا برای حالت دوم به مثال زیر توجه کنید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type animal interface { 6\tbreathe() 7\twalk() 8} 9 10type lion struct { 11\tage int 12} 13 14func (l *lion) breathe() { 15\tfmt.Println(\u0026#34;Lion breathes\u0026#34;) 16} 17 18func (l *lion) walk() { 19\tfmt.Println(\u0026#34;Lion walk\u0026#34;) 20} 21 22func main() { 23\tvar a animal 24 25\ta = lion{age: 10} 26\ta.breathe() 27\ta.walk() 28 29\ta = \u0026amp;lion{age: 5} 30\ta.breathe() 31\ta.walk() 32} 1$ go run main.go 2cannot use lion literal (type lion) as type animal in assignment: 3 lion does not implement animal (breathe method has pointer receiver) در واقع شما فقط در صورت استفاده از اشاره‌گر، می‌توانید یک نمونه از ساختار lion بسازید در غیر این صورت با خطا مواجه خواهید شد.\n2.4.6 پیاده سازی اینترفیس برای تایپ‌های غیر ساختار # همانطور که قبلاً گفتیم شما می‌توانید برای هر تایپی متد تعریف کنید و در اینجا هم می‌توانید متدهای یک اینترفیس را برای هر تایپی پیاده سازی کنید.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type animal interface { 6\tbreathe() 7\twalk() 8} 9 10type cat string 11 12func (c cat) breathe() { 13\tfmt.Println(\u0026#34;Cat breathes\u0026#34;) 14} 15 16func (c cat) walk() { 17\tfmt.Println(\u0026#34;Cat walk\u0026#34;) 18} 19 20func main() { 21\tvar a animal 22 23\ta = cat(\u0026#34;smokey\u0026#34;) 24\ta.breathe() 25\ta.walk() 26} 1$ go run main.go 2Cat breathes 3Cat walk در بالا ما یک تایپ با نام cat از نوع رشته تعریف کردیم و سپس متدهای اینترفیس animal را برای این تایپ پیاده‌سازی کردیم.\n2.4.7 پیاده‌سازی چندتایی اینترفیس برای تایپ # شما می‌توانید برای تایپ‌های خود چندین اینترفیس مختلف استفاده کنید و متدهای این اینترفیس‌ها را پیاده سازی کنید.\nدر کد زیر ما ۲ تا اینترفیس animal و mammal داریم که داخل اینترفیس mammal یک متد با نام feed وجود دارد حالا می‌خواهیم برای ساختار lion از این اینترفیس استفاده کنیم.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type animal interface { 6 breathe() 7 walk() 8} 9 10type mammal interface { 11 feed() 12} 13 14type lion struct { 15 age int 16} 17func (l lion) breathe() { 18 fmt.Println(\u0026#34;Lion breathes\u0026#34;) 19} 20func (l lion) walk() { 21 fmt.Println(\u0026#34;Lion walk\u0026#34;) 22} 23func (l lion) feed() { 24 fmt.Println(\u0026#34;Lion feeds young\u0026#34;) 25} 26func main() { 27 var a animal 28 l := lion{} 29 a = l 30 a.breathe() 31 a.walk() 32 var m mammal 33 m = l 34 m.feed() 35} 1$ go run main.go 2Lion breathes 3Lion walk 4Lion feeds young 2.4.8 مقدار صفر یا پیش‌فرض اینترفیس # اینترفیس هم همانند سایر تایپ‌ها یک مقدار پیش‌فرض دارد که این مقدار پیش‌فرض nil هست.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4type animal interface { 5 breathe() 6 walk() 7} 8 9func main() { 10 var a animal 11 fmt.Println(a) 12} 1$ go run main.go 2nil 2.4.9 بدنه اینترفیس # اینترفیس دارای یک بدنه است که از دو بخش تشکیل شده تایپ و مقدار وقتی شما یک تایپی را به اینترفیس منتصب می‌کنید در بخش مقدار نوع و مقدار تایپی که منتصب کردید به اینترفیس در دسترس است.\ngraph TD A[Interface Variable] --\u003e B(Interface Type) \u0026 C(Interface Value) C --\u003e D(تایپ داخلی) \u0026 E(مقدار داخلی) اگر بخواهیم با توجه به مثال ساختار lion توجه کنیم به شکل زیر می‌شود:\ngraph TD A[Interface Variable] --\u003e B(Interface Type) \u0026 C(Interface Value) C --\u003e D(lion) \u0026 E(\"{age: 10}\") حالا در زیر مثالی زدیم با استفاده از T% و v% نوع و مقدار را می‌توانید چاپ کنیم.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type animal interface { 6 breathe() 7 walk() 8} 9 10type lion struct { 11 age int 12} 13 14func (l lion) breathe() { 15 fmt.Println(\u0026#34;Lion breathes\u0026#34;) 16} 17 18func (l lion) walk() { 19 fmt.Println(\u0026#34;Lion walk\u0026#34;) 20} 21 22func main() { 23 var a animal 24 a = lion{age: 10} 25 fmt.Printf(\u0026#34;Underlying Type: %T\\n\u0026#34;, a) 26 fmt.Printf(\u0026#34;Underlying Value: %v\\n\u0026#34;, a) 27} 1$ go run main.go 2Concrete Type: main.lion 3Concrete Value: {10} 2.4.10 دسترسی به مقادیر داخلی اینترفیس # برای اینکه بتوانید به مقادیر داخلی اینترفیس دسترسی پیدا کنید ۲ تا روش وجود دارد‌:\nبا استفاده از Type Assertion با استفاده از Switch 2.4.10.1 با استفاده از Type Assertion # برای اینکه بتوانید به مقدار داخلی یک اینترفیس دسترسی پیدا کنید باید جلوی متغیر از نوع اینترفیس یک نقطه . و در ادامه داخل پرانتز تایپ مورد نظری که قصد دارید تشخیص دهید را باید قرار دهید.\n1val, ok := i.({type}) در بالا زمانیکه Type Assertion انجام می‌دهید ۲ تا متغیر دارید که اولیش مقدار است و دومیش تایید می‌کند تایپی که به اینترفیس دادید همان است (منظور متغیر ok است که مقدار آن از نوع bool است)\nاگر هنگام Type Assertion شما وضعیت متغیر ok را بررسی نکنید با خطای panic مواجه خواهید شد. 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type animal interface { 6\tbreathe() 7\twalk() 8} 9 10type lion struct { 11\tage int 12} 13 14func (l lion) breathe() { 15\tfmt.Println(\u0026#34;Lion breathes\u0026#34;) 16} 17 18func (l lion) walk() { 19\tfmt.Println(\u0026#34;Lion walk\u0026#34;) 20} 21 22type dog struct { 23\tage int 24} 25 26func (d dog) breathe() { 27\tfmt.Println(\u0026#34;Dog breathes\u0026#34;) 28} 29 30func (d dog) walk() { 31\tfmt.Println(\u0026#34;Dog walk\u0026#34;) 32} 33 34func main() { 35\tvar a animal 36 37\ta = lion{age: 10} 38\tprint(a) 39 40} 41 42func print(a animal) { 43\tl, ok := a.(lion) 44\tif ok { 45\tfmt.Printf(\u0026#34;Age: %d\\n\u0026#34;, l.age) 46\t} 47} 1$ go run main.go 2Age: 10 در بالا ما تایپ lion را به اینترفیس animal پاس دادیم و بررسی کردیم آیا تایپ lion از نوع تایپ داخلی اینترفیس animal هست یا خیر.\n1l := a.(lion) 2.4.10.2 با استفاده از Switch # شما با استفاده از switch می‌توانید تایپ اینترفیس را تشخیص دهید.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type animal interface { 6\tbreathe() 7\twalk() 8} 9 10type lion struct { 11\tage int 12} 13 14func (l lion) breathe() { 15\tfmt.Println(\u0026#34;Lion breathes\u0026#34;) 16} 17 18func (l lion) walk() { 19\tfmt.Println(\u0026#34;Lion walk\u0026#34;) 20} 21 22type dog struct { 23\tage int 24} 25 26func (d dog) breathe() { 27\tfmt.Println(\u0026#34;Dog breathes\u0026#34;) 28} 29 30func (d dog) walk() { 31\tfmt.Println(\u0026#34;Dog walk\u0026#34;) 32} 33 34func main() { 35\tvar a animal 36 37\ta = lion{age: 10} 38\tprint(a) 39 40} 41 42func print(a animal) { 43\tswitch v := a.(type) { 44\tcase lion: 45\tfmt.Println(\u0026#34;Type: lion\u0026#34;) 46\tcase dog: 47\tfmt.Println(\u0026#34;Type: dog\u0026#34;) 48\tdefault: 49\tfmt.Printf(\u0026#34;Unknown Type %T\u0026#34;, v) 50\t} 51} 1$ go run main.go 2Type: lion 2.4.11 اینترفیس خالی # شما می‌توانید اینترفیس بصورت خالی و بدون متد در هرجایی از کد خود استفاده کنید و هر تایپی را می‌توانید به این اینترفیس انتصاب دهید. به عنوان مثال در زیر یک تابع نوشتیم که به عنوان پارامتر ورودی یک اینترفیس خالی می‌گیرد و مقدار این پارامتر را چاپ می‌کند.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 test(\u0026#34;thisisstring\u0026#34;) 7 test(\u0026#34;10\u0026#34;) 8 test(true) 9} 10 11func test(a interface{}) { 12 fmt.Printf(\u0026#34;(%v, %T)\\n\u0026#34;, a, a) 13} 1$ go run main.go 2(thisisstring, string) 3(10, string) 4(true, bool) توجه کنید اینترفیس خالی خیلی کاربردی هست و usecase‌های مختلفی دارد.\n"},{"id":28,"href":"/chapter-2/type-embedding/","title":"2.5 جاسازی تایپ (type embedding)","section":"فصل دوم: مکانیزم‌های زبان","content":"در زبان گو برای ساختار و اینترفیس امکان جاسازی تایپ وجود دارد. یعنی شما می‌توانید یک ساختار یا یک اینترفیس را داخل ساختار دیگر جاسازی کنید و یا داخل اینترفیس یک اینترفیس دیگر را جاسازی کنید.\n1 2type animal interface { 3 breathe() 4 walk() 5} 6 7type human interface { 8 animal 9 speak() 10} 11 12type base struct { 13 num int 14} 15 16type container struct { 17\thuman 18 base 19 str string 20} در بالا ما اینترفیس animal را در اینترفیس human جاسازی کردیم و در ادامه داخل ساختار container اینترفیس human و ساختار base را جاسازی کردیم.\nبا اینکار ما به متدهای اینترفیس human و animal و همچنین به فیلدهای ساختار base دسترسی داریم و می توانیم از متدها و فیلدهای جاسازی با استفاده از ساختار container استفاده کنیم.\nتوجه کنید شما نمی‌توانید یک ساختار را داخل اینترفیس جاسازی کنید. 2.5.1 جاسازی ساختار # شما می‌توانید هر چندتا ساختاری که دارید داخل یک ساختاری جاسازی و به هرکدام از فیلدهای ساختارهای جاسازی شده دسترسی دارید.\nبه مثال زیر توجه کنید :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type base struct { 6 num int 7} 8 9func (b base) describe() string { 10 return fmt.Sprintf(\u0026#34;base with num=%v\u0026#34;, b.num) 11} 12 13type container struct { 14 base 15 str string 16} 17 18func main() { 19 20 co := container{ 21 base: base{ 22 num: 1, 23 }, 24 str: \u0026#34;some name\u0026#34;, 25 } 26 27 fmt.Printf(\u0026#34;co={num: %v, str: %v}\\n\u0026#34;, co.num, co.str) 28 29 fmt.Println(\u0026#34;also num:\u0026#34;, co.base.num) 30 31 fmt.Println(\u0026#34;describe:\u0026#34;, co.describe()) 32 33 type describer interface { 34 describe() string 35 } 36 37 var d describer = co 38 fmt.Println(\u0026#34;describer:\u0026#34;, d.describe()) 39} 1$ go run main.go 2co={num: 1, str: some name} 3also num: 1 4describe: base with num=1 5describer: base with num=1 2.5.1.1 جاسازی اینترفیس در ساختار # همانطور که گفتیم یک اینترفیس می‌‌تواند داخل یک ساختار جاسازی شود و همه متدهای اینترفیس به واسطه ساختار مورد قابل دسترس است و می‌توانید هر یک از متدها را استفاده کنید.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type animal interface { 6 breathe() 7 walk() 8} 9 10type dog struct { 11 age int 12} 13 14func (d dog) breathe() { 15 fmt.Println(\u0026#34;Dog breathes\u0026#34;) 16} 17 18func (d dog) walk() { 19 fmt.Println(\u0026#34;Dog walk\u0026#34;) 20} 21 22type pet1 struct { 23 a animal 24 name string 25} 26 27type pet2 struct { 28 animal 29 name string 30} 31 32func main() { 33 d := dog{age: 5} 34 p1 := pet1{name: \u0026#34;Milo\u0026#34;, a: d} 35 36 fmt.Println(p1.name) 37 // p1.breathe() 38 // p1.walk() 39 p1.a.breathe() 40 p1.a.walk() 41 42 p2 := pet2{name: \u0026#34;Oscar\u0026#34;, animal: d} 43 fmt.Println(p1.name) 44 p2.breathe() 45 p2.walk() 46 p1.a.breathe() 47 p1.a.walk() 48} 1$ go run main.go 2Milo 3Dog breathes 4Dod walk 5 6Oscar 7Dog breathes 8Dog walk 9Dog breathes 10Dog walk 2.5.2 جاسازی اینترفیس # شما همانند ساختارها می‌توانید اینترفیس‌ها را جاسازی کنید و فقط کافیه اینترفیس‌ها را داخل دیگر اینترفیس‌ها جاسازی کنید تا متدهای اینترفیس‌های جاسازی شده دسترسی داشته باشید.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type animal interface { 6\tbreathe() 7\twalk() 8} 9 10type human interface { 11\tanimal 12\tspeak() 13} 14 15type employee struct { 16\tname string 17} 18 19func (e employee) breathe() { 20\tfmt.Println(\u0026#34;Employee breathes\u0026#34;) 21} 22 23func (e employee) walk() { 24\tfmt.Println(\u0026#34;Employee walk\u0026#34;) 25} 26 27func (e employee) speak() { 28\tfmt.Println(\u0026#34;Employee speaks\u0026#34;) 29} 30 31func main() { 32\tvar h human 33 34\th = employee{name: \u0026#34;John\u0026#34;} 35\th.breathe() 36\th.walk() 37\th.speak() 38} 1$ go run main.go 2Employee breathes 3Employee walk 4Employee speaks یکی دیگه از مثال‌هایی که می‌توانیم بزنیم پکیج io اینترفیس ReadWriter هست که ۲ تا اینترفیس Reader و Writer داخل این اینترفیس جاسازی شده است.\n"},{"id":29,"href":"/chapter-2/error-handling/","title":"2.6 مدیریت خطاها","section":"فصل دوم: مکانیزم‌های زبان","content":"در این بخش قصد داریم به مقوله مدیریت خطاها در زبان گو بپردازیم و اینکه چطور می‌توانید خیلی ساده خطاها را مدیریت کنید. مدیریت خطا در زبان گو با سایر زبان‌ها متفاوت هست و شما با چیزی به نام try-catch یا try-except سروکار ندارید.\nمدیریت خطاها در زبان گو به دو روش صورت می گیرد:\nبا استفاده از پیاده سازی اینترفیس error که یک روش مرسوم جهت مدیریت و نمایش خطا است. با استفاده از panic/recover که در فصل اول توضیح دادیم. 2.6.1 مدیریت خطا با اینترفیس error # روش زبان گو برای مقابله با خطا این است که به صراحت، شما خطا را به عنوان خروجی تابع برگردانید. برای این کار کافیست اگر میخواهید خطای هر تابع را مدیریت کنید، اینترفیس error را در خروجی تابع بگذارید.\nhttps://pkg.go.dev/builtin#error\n1type error interface { 2 Error() string 3} به مثال زیر توجه کنید:\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;os\u0026#34; 6) 7 8func main() { 9\tfile, err := os.Open(\u0026#34;non-existing.txt\u0026#34;) 10\tif err != nil { 11\tfmt.Println(err) 12\t} else { 13\tfmt.Println(file.Name() + \u0026#34;opened succesfully\u0026#34;) 14\t} 15} 1$ go run main.go 2open non-existing.txt: no such file or directory در کد بالا ما با استفاده از تابع Open که در پکیج os وجود دارد فایل non-existing.txt را باز کرده‌ایم. اگر دقت کنید این تابع ۲ تا خروجی دارد یکی ساختار File هست و دیگری خطا هست. در ادامه ما با استفاده شرط آمدیم چک کردیم اینترفیس err آیا خالی است یا خیر؟ در کد بالا این اینترفیس خالی nil نیست و ما خطا را چاپ کردیم.\nاین روش به طور گسترده در پکیج‌های داخلی و شخص ثالث گو استفاده می‌شود.\nدقت کنید اینترفیس error یک متد دارد به نام ()Error که این متد متن خطا را بصورت رشته بر می‌گرداند.\nآیا همیشه نیاز است خطاها را مدیریت کنیم؟\nشاید بپرسید آیا واقعا نیاز هست ما همیشه خطاها را مدیریت کنیم؟ در جواب این سوال می توانیم بگیم هم بله و هم خیر\nعلت اینکه می‌گوییم بله از این بابت هست اگر خطاها بدرستی مدیریت نشود احتمال اینکه با panic در هر جا مواجه شویم خیلی زیاد است. بخصوص خطای nil pointer . پس بهتر است تا جایی که می‌توانید خطاها را بدرستی مدیریت کنید و همچنین اگر جایی احتمال می‌دهید panic پیش میاد بهتر است از recover استفاده کنید تا پایداری برنامه را بالا ببرید. علت اینکه می‌گوییم خیر از این بابت هست که در زبان گو، هیچ اجباری برای مدیریت خطاها وجود ندارد و گاهی اوقات می‌توانید خطاها را نادیده بگیرید که با استفاده از ـ امکان پذیر است. 2.6.2 مزایای استفاده از error به عنوان یک تایپ در زبان گو # به شما این امکان را می‌دهد کنترل بیشتری رو خطاها داشته باشید و تو هر قدم می‌توانید خطاها را بررسی کنید. جلوگیری از try-catch جهت مدیریت خطا (دقت کنید در سایر زبان ها باید تا جایی که ممکن است از try-catch کمتر استفاده کنید) 2.6.3 روش‌های مختلف برای ایجاد یک خطا # در زبان گو شما می‌توانید در هرجای کد خود یک خطا با محتوای مناسب ایجاد کنید و یا اینکه برخی از خطاهای برخی از کتابخانه‌ها را هم‌پوشانی کنید.\n1. با استفاده (\u0026ldquo;متن خطا\u0026rdquo;)errors.New\n1package main 2 3import ( 4 \u0026#34;errors\u0026#34; 5 \u0026#34;fmt\u0026#34; 6) 7 8func main() { 9 sampleErr := errors.New(\u0026#34;error occured\u0026#34;) 10 fmt.Println(sampleErr) 11 } 1$ go run main.go 2error occured در بالا ما با استفاده از تابع New پکیج errors یک خطا با متن مشخص ایجاد کردیم و متغیر sampleErr از نوع اینترفیس error می‌باشد که می‌توانید در هر جای کد خود مدیریتش کنید.\n2. با استفاده از (\u0026ldquo;error is %s\u0026rdquo;, \u0026ldquo;some error message\u0026rdquo;)fmt.Errorf\nشما با استفاده از تابع Errorf در پکیج fmt می‌توانید یک خطا ایجاد کنید و توجه کنید این متن خطا قابل فرمت است و حتی شما می‌توانید متن خطا را داینامیک کنید.\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5) 6 7func main() { 8\tmsg := \u0026#34;database connection issue\u0026#34; 9 sampleErr := fmt.Errorf(\u0026#34;Err is: %s\u0026#34;, msg) 10 fmt.Println(sampleErr) 11} 1$ go run main.go 2Err is: database connection issue 2.6.4 ایجاد خطا پیشرفته # در مثال زیر ما قصد داریم یک خطای پیشرفته ایجاد کنیم و آن را به آسانی مدیریت کنیم.\nویژگی‌های خطای پیشرفته :\nدر زیر inputError یک نوع ساختار است که داخلش ۲ تا فیلد message و missingField دارد و همچنین دارای یک متد ()Error است. شما می‌توانید به این ساختار خطای پیشرفته، متدهای بیشتری اضافه کنید و همچنین گسترش دهید که به عنوان مثال ما متد getMissingFields را برای گرفتن محتوای missingField اضافه کردیم. ما با استفاده از type assertion می‌توانیم اینترفیس error را به inputError تبدیل کنیم. 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type inputError struct { 6 message string 7 missingField string 8} 9 10func (i *inputError) Error() string { 11 return i.message 12} 13 14func (i *inputError) getMissingField() string { 15 return i.missingField 16} 17 18func main() { 19 err := validate(\u0026#34;\u0026#34;, \u0026#34;\u0026#34;) 20 if err != nil { 21 if err, ok := err.(*inputError); ok { 22 fmt.Println(err) 23 fmt.Printf(\u0026#34;Missing Field is %s\\n\u0026#34;, err.getMissingField()) 24 } 25 } 26} 27 28func validate(name, gender string) error { 29 if name == \u0026#34;\u0026#34; { 30 return \u0026amp;inputError{message: \u0026#34;Name is mandatory\u0026#34;, missingField: \u0026#34;name\u0026#34;} 31 } 32 if gender == \u0026#34;\u0026#34; { 33 return \u0026amp;inputError{message: \u0026#34;Gender is mandatory\u0026#34;, missingField: \u0026#34;gender\u0026#34;} 34 } 35 return nil 36} 1$ go run main.go 2Name is mandatory 3Missing Field is name 2.6.5 نادیده گرفتن خطاها # شما در هرجای کد خود با استفاده از _ می توانید متغیر خطا را نادیده بگیرید و آن را مدیریت نکنید. هر چند در بالا گفتیم نادیده گرفتن خطاها عوارضی در بر دارد و ما همیشه، تاکید می‌کنیم تا جایی که ممکن است خطاها را مدیریت کنید.\n1package main 2import ( 3 \u0026#34;fmt\u0026#34; 4 \u0026#34;os\u0026#34; 5) 6func main() { 7 file, _ := os.Open(\u0026#34;non-existing.txt\u0026#34;) 8 fmt.Println(file) 9} 1$ go run main.go 2{nil} در بالا ما خطای تابع Open را نادیده گرفتیم و مقدار file را چاپ کردیم مقدار چاپ شده nil است چون تایپ خروجی با اشاره‌گر است و قطعا مقدار خالی بودش nil است.\n2.6.6 هم‌پوشانی (Wrapping) خطا # در زبان گو، شما می‌توانید خطا را با خطا و پیغام مشخصی هم پوشانی کنید. حالا هم‌پوشانی خطا چیست؟\nبزارید با یک مثال ساده توضیح دهیم، فرض کنید شما تو لایه دیتابیس خود یکسری خطاها از سمت دیتابیس دریافت می‌کنید به عنوان مثال اگر شما سندی را در دیتابیس monogdb پیدا نکنید با خطای no documents found مواجه خواهید شد. شما در اینجا نمی‌توانید همان متن خطا را به کاربر نمایش دهید بلکه باید آن خطا را با یک متن خطای مناسب هم پوشانی کنید.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7type notPositive struct { 8\tnum int 9} 10 11func (e notPositive) Error() string { 12\treturn fmt.Sprintf(\u0026#34;checkPositive: Given number %d is not a positive number\u0026#34;, e.num) 13} 14 15type notEven struct { 16\tnum int 17} 18 19func (e notEven) Error() string { 20\treturn fmt.Sprintf(\u0026#34;checkEven: Given number %d is not an even number\u0026#34;, e.num) 21} 22 23func checkPositive(num int) error { 24\tif num \u0026lt; 0 { 25\treturn notPositive{num: num} 26\t} 27\treturn nil 28} 29 30func checkEven(num int) error { 31\tif num%2 != 0 { 32\treturn notEven{num: num} 33\t} 34\treturn nil 35} 36 37func checkPostiveAndEven(num int) error { 38\tif num \u0026gt; 100 { 39\treturn fmt.Errorf(\u0026#34;checkPostiveAndEven: Number %d is greater than 100\u0026#34;, num) 40\t} 41 42\terr := checkPositive(num) 43\tif err != nil { 44\treturn err 45\t} 46 47\terr = checkEven(num) 48\tif err != nil { 49\treturn err 50\t} 51 52\treturn nil 53} 54 55func main() { 56\tnum := 3 57\terr := checkPostiveAndEven(num) 58\tif err != nil { 59\tfmt.Println(err) 60\t} else { 61\tfmt.Println(\u0026#34;Givennnumber is positive and even\u0026#34;) 62\t} 63 64} 1$ go run main.go 2checkEven: Given number 3 is not an even number 2.6.7 Unwrap خطاها # در بخش بالا شما با نحوه هم‌پوشانی کردن آشنا شدید، اما این امکان را داریم خطاها را unwrap کنیم با استفاده از یک تابع در پکیج errors به نام Unwrap.\n1func Unwrap(err error) error منظورمان از unwrap کردن این است که، اگر خطایی را هم پوشانی کرده باشیم با استفاده unwrap می‌توانیم آن خطا را ببینیم.\n1import ( 2 \u0026#34;errors\u0026#34; 3 \u0026#34;fmt\u0026#34; 4) 5type errorOne struct{} 6func (e errorOne) Error() string { 7 return \u0026#34;Error One happened\u0026#34; 8} 9func main() { 10 e1 := errorOne{} 11 e2 := fmt.Errorf(\u0026#34;E2: %w\u0026#34;, e1) 12 e3 := fmt.Errorf(\u0026#34;E3: %w\u0026#34;, e2) 13 fmt.Println(errors.Unwrap(e3)) 14 fmt.Println(errors.Unwrap(e2)) 15 fmt.Println(errors.Unwrap(e1)) 16} 1$ go run main.go 2E2: Error One happended 3Error One happended در کد بالا متغیر e2 خطای داخل ساختار e1 را هم‌پوشانی کرده و سپس متغیر e3 خطای متغیر e2 را هم‌پوشانی می‌کند. در نهایت با تابع Unwrap متن خطای اصلی را چاپ کردیم.\n2.6.8 بررسی دو خطا اگر برابر هستند # در زبان گو شما می‌توانید ۲ اینترفیس را با هم مقایسه کنید و این مقایسه به وسیله اپراتور == یا با استفاده از تابع Is در پکیج errors صورت می‌گیرد. اساساً دو مقوله برای این مقایسه در نظر گرفته خواهد شد:\n1func Is(err, target error) bool هر دو این اینترفیس‌ها به یک نوع تایپ منصوب شده باشند. مقدار داخلی اینترفیس‌ها باید با هم برابر باشند یا اینکه هر دو (nil) باشند. 1package main 2import ( 3 \u0026#34;errors\u0026#34; 4 \u0026#34;fmt\u0026#34; 5) 6type errorOne struct{} 7func (e errorOne) Error() string { 8 return \u0026#34;Error One happended\u0026#34; 9} 10func main() { 11 var err1 errorOne 12 err2 := do() 13 if err1 == err2 { 14 fmt.Println(\u0026#34;Equality Operator: Both errors are equal\u0026#34;) 15 } 16 if errors.Is(err1, err2) { 17 fmt.Println(\u0026#34;Is function: Both errors are equal\u0026#34;) 18 } 19} 20func do() error { 21 return errorOne{} 22} 1$ go run main.go 2Equality Operator: Both errors are equal 3Is function: Both errors are equal "},{"id":30,"href":"/chapter-2/casting-vs-conversion/","title":"2.7 فرق casting با conversion","section":"فصل دوم: مکانیزم‌های زبان","content":" 2.7.1 conversion # conversion زمانی اتفاق می‌افتد که ما مقدار یک داده را به تایپ دیگری اختصاص دهیم.\nزبان‌هایی که Static Type هستند از این مقوله بطور ضمنی پشتیبانی می‌کنند ولی در زبان گو کمی متفاوت است. اگر شما بخواهید conversion انجام دهید باید بصورت دستی اینکار را انجام دهید. چون کامپایلر گو برخی از عناوین را بطور صریح در نظر می‌گیرد.\n2.7.2 type casting # در زبان گو، چیزی به نام type casting بطور کلی وجود ندارد. پس بهتر است در خصوص این مورد داخل داکیومنت‌ها یا سایت‌های مختلف نگردید. برای درک بهتر این موضوع بهتره https://go.dev/ref/spec#Conversions را مطالعه کنید.\n2.7.3 مثال conversion # در زیر یک مثال در خصوص conversion زدیم تا با این مقوله آشنا شوید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 7\tvar totalsum int = 846 8\tvar number int = 19 9\tvar avg float32 10 11\tavg = float32(totalsum) / float32(number) 12 13\tfmt.Printf(\u0026#34;Average = %f\\n\u0026#34;, avg) 14} 1$ go run main.go 2Average = 44.526318 "},{"id":31,"href":"/chapter-3/","title":"فصل سوم: همزمانی (concurrency)","section":"صفحه اصلی","content":"در این فصل به صورت عمیق به مباحث همزمانی در زبان گو پرداخته شده است که شامل عناوین زیر می‌باشد.\n۳.۱ آشنایی با مبحث همزمانی. ۳.۲ گوروتین چیست. ۳.۳ کالبدشکافی پکیج sync و تشریح انواع و توابع کاربردی آن برای مباحث همگام‌سازی همزمانی. ۳.۴ آشنایی با پکیج atomic و کاربردهای آن. ۳.۵ آشنایی با Data Race و روش‌های پیشگیری از آن. ۳.۶ کانال‌ها و روش‌ اشتراک‌گذاری داده از طریق آن. ۳.۷ آشنایی با کلید‌واژه select و بررسی کاربردهای متنوع آن. ۳.۸ پکیج context و اهمیت آن. ۳.۹ تکنیک‌های مورد استفاده در همزمانی. ۳.۱۰ الگوهای متداول همزمانی و کاربردهای آن. "},{"id":32,"href":"/chapter-3/go-concurrency/","title":"3.1 آشنایی با همزمانی","section":"فصل سوم: همزمانی (concurrency)","content":"\nنرم‌افزارهای بزرگ به منظور توسعه راحت‌تر و قابلیت نگهداری بیشتر و همچنین پرهیز از تکرار از ده‌ها زیر برنامه کوچک‌تر تشکیل می‌شوند که به آنها توابع می‌گوییم و تمامی این زیربرنامه‌های کوچک در کنار هم اما به صورت مستقل عملکرد کلی برنامه بزرگتر را شکل می‌دهند. به عنوان مثال یک وب سرور درخواست‌های ارسال شده از سمت مرورگرها را مدیریت می کند و در پاسخ صفحات وب HTML را آماده کرده و ارائه می‌دهد و هر در خواست از طریق فراخوانی چندین برنامه کوچک رسیدگی می شود تا نتیجه را به مرورگر برگردانده شود.\nدر طول آماده‌سازی نتیجه‌‌ی هر یک از این زیربرنامه‌ها، به دلایل گوناگون از جمله تاخیر(های) شبکه، IO و \u0026hellip; اجرای زیربرنامه‌ها برای مدتی هرچند کوتاه متوقف می‌شود و این وقفه‌ها، زمان پاسخگویی نرم‌افزارها را طولانی‌تر می‌کنند؛ گاهی‌اوقات اولویت ترتیب اجرا و وابستگی/استقلال زیربرنامه‌ها، به توسعه‌دهنده این اجازه را می‌دهد که اجرای بعضی از زیربرنامه‌ها را از حالت «صف/ترتیبی» به حالت «موازی» تغییر دهد، لذا به منظور استفاده بهینه‌ از منابع و افزایش عملکرد کلی نرم‌افزار از مقوله‌ای به نام همزمانی استفاده می کنند.\nیکی از نقاط قوت در زبان Go سهولت و امنیت استفاده از همزمانی با کمک گوروتین و کانال‌هاست که در ادامه‌ی این فصل به‌طور جامع، مباحث مربوط به آن را بررسی کرده و روش پیاده‌سازی همزمانی در برنامه‌های زبان Go را آموزش خواهیم داد.\n۳.۱.۱ فرق بین همزمانی (concurrency) و موازی (parallelism) # موازی‌سازی (parallelism) یعنی چندین فرآیند به‌طور همزمان توسط چند threads یا به طور دقیق‌تر هسته پردازشی انجام شود و این هسته‌ها می‌توانند از طریق حافظه اشتراکی با هم ارتباط برقرار کنند و در نهایت نتایج فرآیندها پس از پایان با هم ترکیب می‌شوند. لذا داشتن حداقل دو یا چند هسته پردازش فیزیکی از الزامات پیاده‌سازی موازی است.\nدر مقابل برنامه‌های همزمان الزاماً به‌صورت موازی اجرا نمی‌شوند و بیشتر در مورد ساختار یک برنامه است تا شیوه دقیق اجرای آن برنامه یا زیربرنامه. همزمانی به گونه‌ای است که دو یا چند کار مختلف ممکن است به طور همزمان در حال پیشرفت و انجام باشند. و در نهایت این فرآیندهای همزمان به نتایج مختلفی ختم می شوند.\nحال می‌خواهیم با یک مثال ملموس این دو مبحث را باز کنیم تا به درکی دقیق‌تر از تفاوت این‌ دو برسیم.\nتصور کنید که برنامه بزرگ ما یک کافی‌شاپ است که صفی از مشتریان سفارش خود را داده و منتظر دریافت آن می‌شوند.\nهمانطور که از تصویر بالا متوجه می‌شوید مشتری دوم تا پایان آماده‌سازی سفارش مشتری اول باید منتظر بماند لذا به منظور بالا بردن کارایی کلی سیستم می‌توان از پردازش موازی بهره برد به این منظور با استخدام یک فرد دیگر و یک دستگاه قهوه سازی دیگر پردازش مشتریان را به صورت موازی انجام خواهیم داد.\nچنانچه پیشتر هم گفته شد ما با محدودیت منابع روبرو هستیم و برای بالا بردن تعداد پردازش‌های موازی نیازمند خرید دستگاه قهوه ساز جدید و استخدام نیروی جدید هستیم. تا به اینجا هدف این بود که مشکل انتظار طولانی مدت مشتریان در صف را از طریق پردازش موازی حل کنیم اما این کار بسیار پرهزینه است راه حل دیگری هم وجود دارد که همان همزمانی است. بدیهی است وقفه ایجاد شده برای آماده‌سازی سفارش تنها محدود به دستگاه قهوه‌ساز نیست و بخشی از آن مربوط به زمان سپری شده برای دریافت سفارش از مشتریان توسط باریستا و مراجعه به دستگاه برای آماده‌سازی آن می‌شود لذا می‌توان با استخدام یک نیروی جدید بدون خرید دستگاه قهوه‌ساز جدید سفارش مشتریان را به صورت جداگانه پردازش کرده و به‌جای صف سفارش یک صف انتظار آماده‌سازی تشکیل داد به این ترتیب مدت زمان انتظار افراد برای دریافت سفارش کوتاه تر شده و عملکرد کلی سیستم افزایش می‌یابد.\nالبته هیچ چیز ما را محدود به پردازش سریال در حالت همزمانی نمی‌کند یعنی در صورت تشکیل صف طولانی می توانیم عملکرد موازی را اینجا هم اعمال کنیم به تصویر پایین دقت کنید.\nهمانطور که مشاهده می‌شود در پردازش همزمان ما با تغییر ساختار به صورت موازی یا غیرموازی عملکرد کلی سیستم را افزایش داده‌ایم.\nنکته: تا به اینجا بارها برروی عملکرد کلی سیستم تأکید نموده‌ایم. این مسئله از آنجا حائز اهمیت است که خواننده باید به درکی درست از مقوله همزمانی برسد. ما در همزمانی سرعت پردازش یک درخواست را افزایش نمی‌دهیم در حقیقت به دلیل پیچیده‌تر شدن پیاده‌سازی و روند اجرا، زمان پردازش یک درخواست منحصر به فرد طولانی‌تر هم می‌شود اما آنچه در مبحث همزمانی بهبود می‌یابد عملکرد کلی سیستم است. لذا استفاده از همزمانی تنها در صورتی می‌تواند به بهبود کارایی یک سیستم نرم‌افزاری منجر شود که صفی از درخواست‌ها تشکیل شده باشد و تأخیرات مختلف مانع از پردازش بی‌درنگ درخواست‌ها در اکثر مواقع نشود لذا با استفاده از پیاده‌سازی همزمانی از منابع سیستم در زمان انتظار درخواست‌ها به صورت بهینه استفاده خواهد شد.\nدر زبان Go با استفاده از متغیرهای محیطی GOMAXPROCS در کنار همزمانی از موازی‌سازی (parallelism) هم استفاده می‌شود. هرچند بطور پیش فرض برنامه‌ای که با زبان گو نوشته می‌شود از تمامی هسته‌های CPU استفاده می‌کند ولی شما می‌توانید با GOMAXPROCS تعداد هسته‌ها را محدود کنید. لازم به ذکر است که در زبان Go شما به طور مستقیم نمی‌توانید اجرای موازی زیربرنامه‌ای را به کامپایلر دیکته کنید و تصمیم‌گیری در این مورد به عهده Go Runtime Scheduler است.\n۳.۱.۲ توضیح مختصر در خصوص Go Runtime Scheduler # در زبان گولنگ نحوه اجرا و مدیریت گوروتین ها در سطح زبان انجام می شود، بر خلاف برخی زبان ها که مدیریت و اجرای ترد ها بر عهده سیستم عامل است.\nنحوه اجرای گوروتین ها چگونه است؟ در قدم اول گوروتین ها وارد یک صف به اسم Global run queue می شوند. سپس Go run scheduler بر اساس تعداد هسته های لاجیکال، از سیستم عامل ترد می گیرد. سپس گوروتین ها‌را بین ترد های دریافت شده تقسیم می کند تا اجرا شوند.\nنکته: همانطور که گفته شد، شما می توانید تعداد هسته هایی که گولنگ می تواند استفاده کند را به‌صورت دستی تنظیم کنید. توجه داشته باشید خود گولنگ به‌صورت پیشفرض از قدرت تمامی هسته ها استفاده می کند.\n"},{"id":33,"href":"/chapter-3/goroutine/","title":"3.2 گوروتین (goroutine)","section":"فصل سوم: همزمانی (concurrency)","content":"گوروتین ها را می توان به عنوان یک thread سبک در نظر گرفت که بصورت مستقل می توانند همزمان با سایر گوروتین های دیگر کارها را انجام دهند. و همچنین گوروتین ها می توانند به واسطه کانال داده ها را بین هم به اشتراک گذاشته و منتقل کنند.\nحداکثر اندازه stack یک گوروتین در زبان گو ۱ گیگابایت می باشد.\n1var maxstacksize uintptr = 1 \u0026lt;\u0026lt; 20 // enough until runtime.main sets it for real 2 3\tif newsize \u0026gt; maxstacksize || newsize \u0026gt; maxstackceiling { 4\tif maxstacksize \u0026lt; maxstackceiling { 5\tprint(\u0026#34;runtime: goroutine stack exceeds \u0026#34;, maxstacksize, \u0026#34;-byte limit\\n\u0026#34;) 6\t} else { 7\tprint(\u0026#34;runtime: goroutine stack exceeds \u0026#34;, maxstackceiling, \u0026#34;-byte limit\\n\u0026#34;) 8\t} 9\tprint(\u0026#34;runtime: sp=\u0026#34;, hex(sp), \u0026#34; stack=[\u0026#34;, hex(gp.stack.lo), \u0026#34;, \u0026#34;, hex(gp.stack.hi), \u0026#34;]\\n\u0026#34;) 10\tthrow(\u0026#34;stack overflow\u0026#34;) 11\t} در زیر با استفاده از کلمه کلیدی go یک نمونه گوروتین ایجاد کردیم و توجه کنید شما فقط توابع را می توانید به صورت همزمان اجرا کنید.\n1go functionName(parameters) به عنوان مثال :\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;time\u0026#34; 6) 7 8func main() { 9 go start() 10 fmt.Println(\u0026#34;Started\u0026#34;) 11 time.Sleep(1 * time.Second) 12 fmt.Println(\u0026#34;Finished\u0026#34;) 13} 14 15func start() { 16 fmt.Println(\u0026#34;In Goroutine\u0026#34;) 17} 1$ go run main.go 2Started 3In Goroutine 4Finished در کد فوق ما تابع ()start را توسط کلمه کلیدی go داخل گوروتین قرار دادیم و این تابع بصورت مستقل از تابع main اجرا شد. اما این وسط یک نکته ای وجود دارد. همانطور که گفتیم تابع اصلی جهت اجرا برنامه های زبان گو تابع main می باشد و اگر شما تابعی را توسط گوروتین از main جدا کنید ممکن است فرآیندهای داخل تابع main زود اتمام شود و شما خروجی تابعی که داخل گوروتین گذاشتید را نبینید.\nما در کد بالا با استفاده از تابع Sleep پکیج time یک وقفه ۱ ثانیه گذاشتیم و این وقفه باعث شد تا عملیات داخل تابع ()start تمام شود و خروجی نمایش داده شود.\nخب حالا بزارید مثال فوق را بدون وقفه تست کنیم :\n1package main 2import ( 3 \u0026#34;fmt\u0026#34; 4) 5func main() { 6 go start() 7 fmt.Println(\u0026#34;Started\u0026#34;) 8 fmt.Println(\u0026#34;Finished\u0026#34;) 9} 10func start() { 11 fmt.Println(\u0026#34;In Goroutine\u0026#34;) 12} 1$ go run main.go 2Started 3Finished در خروجی بالا هرگز پیغام داخل تابع ()start چاپ نمی شود.\n1In Goroutine علت اصلی این اتفاق این است که تابع main خودش داخل یک گوروتین اجرا می شود و زمانیکه شما یک تابع دیگری را داخل گوروتین قرار می دهید تا لحظه ای که تابع برای اجرا برنامه ریزی شود برنامه اتمام می شود.\n3.2.1 گوروتین تابع main # تابع main را وقتی می توانید ایجاد کنید که نام پکیج شما main و گوروتین اصلی شما main باشد. همه گوروتین ها از تابع main شروع می شوند و گوروتین ها بطور همزمان باز می توانند سایر گوروتین ها را اجرا کنند.\nزمانیکه شما تابع main را فراخوانی می کنید بخش اصلی و شروع برنامه شما است. و اگر تابع main شما به هر دلیلی متوقف شود یا اتمام شود سایر گوروتین ها از بین می روند.\nگوروتین ها چیزی به نام parent یا child ندارند. زمانیکه شما یک گوروتین را اجرا می کنید این گوروتین در کنار سایر گوروتین ها اجرا می شود و کارش را انجام می دهد. زمانی کار یک گوروتین تمام می شود که تابع بازگشت (return) داشته باشد.\nبزارید یک مثال بزنیم تا ببینید چیزی به نام parent یا child برای گوروتین نداریم :\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;time\u0026#34; 6) 7 8func main() { 9 go start() 10 fmt.Println(\u0026#34;Started\u0026#34;) 11 time.Sleep(1 * time.Second) 12 fmt.Println(\u0026#34;Finished\u0026#34;) 13} 14 15func start() { 16 go start2() 17 fmt.Println(\u0026#34;In Goroutine\u0026#34;) 18} 19func start2() { 20 fmt.Println(\u0026#34;In Goroutine2\u0026#34;) 21} 1$ go run main.go 2Started 3In Goroutine 4In Goroutine2 5Finished در کد بالا داخل تابع main ما تابع start را با گوروتین اجرا کردیم و داخل تابع start تابع start2 را با گوروتین اجرا کردیم. این ۲ تابع start و start2 در کنار هم اجرا می شود و در نهایت کارشان اتمام می شود و هیچ کدام منتظر دیگری نخواهد بود.\n3.2.2 ایجاد گوروتین چندتایی # شما می توانید n تا گوروتین بطور همزمان در کنار هم اجرا کنید, در زیر یک مثال زدیم ببینید :\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;time\u0026#34; 6) 7 8func execute(id int) { 9 fmt.Printf(\u0026#34;id: %d\\n\u0026#34;, id) 10} 11 12func main() { 13 fmt.Println(\u0026#34;Started\u0026#34;) 14 for i := 0; i \u0026lt; 10; i++ { 15 go execute(i) 16 } 17 time.Sleep(time.Second * 2) 18 fmt.Println(\u0026#34;Finished\u0026#34;) 19} 1$ go run main.go 2Started 3id: 4 4id: 9 5id: 1 6id: 0 7id: 8 8id: 2 9id: 6 10id: 3 11id: 7 12id: 5 13Finished در کد فوق ما یک حلقه قرار دادیم از i برابر ۰ تا ۱۰ که داخلش تابع execute را ۱۰ بار اجرا می کند. و هربار اجرا می شود خروجی های مختلفی دارد و ترتیبی درست نخواهید علت این اتفاق این است بطور همزمان اجرا می شوند در کنار هم و هرکدام از گوروتین ها زودتر کارش تمام شود خروجی را نمایش می دهد. به همین دلیل ترتیب درستی نخواهد داشت.\n3.2.3 زمانبندی گوروتین ها # زمانیکه یک برنامه گو اجرا می شود. go runtime رشته های (threads) سیستم عامل را راه اندازی می کند که معادل تعداد CPU های logical قابل استفاده برای فرآیند فعلی است. هر یک از logical CPU ها یک هسته مجازی دارد.\n1virtual_cores = x*number_of_physical_cores در کد بالا x برابر است با تعداد thread ها به ازای هر هسته از CPU\nدر گو ما یک تابع به نام NumCPU داخل پکیج runtime داریم که می توانید تعداد logical Proccessors موجود برای برنامه گو را ببینید.\n1package main 2import ( 3 \u0026#34;fmt\u0026#34; 4 \u0026#34;runtime\u0026#34; 5) 6func main() { 7 fmt.Println(runtime.NumCPU()) 8} روی سیستم من عدد 8 را چاپ کرد یعنی سیستم من ۴ هسته که هر هسته دارای ۲ threads است. که قابل استفاده برای برنامه گو روی سیستم من می باشد.\n"},{"id":34,"href":"/chapter-3/go-sync-package/","title":"3.3 پکیج sync","section":"فصل سوم: همزمانی (concurrency)","content":"پکیج sync یکی از کاربردی ترین پکیج ها در زمینه همزمانی می باشد و یکسری تایپ و توابع برایهمگام سازی و کنترل دسترسی همزمان به داده های مشترک ارائه می دهد. پرکاربرد ترین ویژگی های این پکیج شامل موارد زیر می شود :\nMutex : با استفاده از این تایپ می توانید آن بخش از داده ای که گوروتین ها بطور همزمان قصد دارند دسترسی داشته باشند را قفل کنید. RWMutex : با استفاده از این تایپ می توانید به چندین گوروتین اجازه خواندن دهید اما فقط یک گوروتین قابلیت نوشتن در یک زمان مشخص را دارد. WaitGroup: یک هماهنگ کننده گوروتین می باشد، برای اینکه ترتیب عملیات ها در هنگام همزمانی رعایت شود. Once: این تایپ تضمین می کند که یک تابع فقط یک بار اجرا شود. Pool: مجموعه‌ای از آبجکت های موقت که امکان ذخیره و دریافت دارند بدون اینکه بخشی از حافظه را اشغال کنند. Cond:با استفاده از Cond می توانید چندین گوروتین ایجاد کنید و اجرای فرآیند آن ها را منتظر وقوع یک رویداد قرار دهید. توجه کنید که پکیج sync فقط و فقط برای مدیریت و همگام سازی دسترسی های گوروتین ها به یک داده مشترک استفاده می شود. 3.3.1 Mutex # در پکیج sync یک تایپ به نام Mutex وجود دارد که به شما این امکان را می دهد دسترسی به داده های مشترک را همگام سازی کنید. با استفاده از این قابلیت در واقع منابع مشترک محافظت شده و این اطمینان به شما داده می شود که تنها یک گوروتین در یک زمان مشخص، به دیتای مشترک بین گوروتین ها دسترسی دارد. تایپ Mutex شامل دو متد مهم Lock و Unlock است. وقتی Lock فراخوانی می شود فقط و فقط یک گوروتین می تواند برروی آن بخش از داده کار کند و تا زمانیکه شما Unlock نکنید سایر گوروتین ها نمی توانند به دیتای مورد نظر شما دسترسی داشته باشند و تا زمانیکه Unlock صورت گیرد سایر گوروتین هادر حالت انتظار باقی می مانند.\nبه مثال زیر توجه کنید :\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;sync\u0026#34; 6\t\u0026#34;time\u0026#34; 7) 8 9var count int 10 11func main() { 12\tmu := new(sync.Mutex) 13\t14\tgo increment(mu) 15\tgo increment(mu) 16\tgo increment(mu) 17\tgo increment(mu) 18 19\ttime.Sleep(time.Second) 20} 21 22func increment(mu *sync.Mutex) { 23\tmu.Lock() 24\tdefer mu.Unlock() 25\tcount++ 26\tfmt.Printf(\u0026#34;Incrementing: %d\\n\u0026#34;, count) 27} 1$ go run main.go 2 3Incrementing: 1 4Incrementing: 2 5Incrementing: 3 6Incrementing: 4 در بالا ما یک تابع به نام increment ایجاد کردیم و به عنوان ورودی تایپ Mutex را بصورت پوینتر پاس دادیم. سپس با استفاده از توابع Lock و Unlock برای افزایش مقدار count یک قفل گذاشتیم.\nحال ۴ تا گوروتین داریم که قصد دارند همزمان روی بخش مشترک از حافظه عملیاتی را انجام دهند در اینجا ما با استفاده Mutex جلوی دسترسی همزمان گوروتین ها به حافظه را گرفتیم و فقط یک گوروتین می تواند عملیات انجام دهد و تا زمانیکه شما Unlock نکنید سایر گوروتین ها منتظر می مانند.\n3.3.1.1 سناریوهای استفاده # همگام سازی دسترسی به متغیرهای مشترک: یک mutex می تواند برای همگام سازی دسترسی به متغیرهای مشترک بین چندین گوروتین استفاده شود. این می تواند در مواردی مفید باشد که چندین گوروتین نیاز به خواندن یا به روز رسانی یک متغیر به طور همزمان دارند.\nهماهنگی دسترسی به حالت مشترک: یک mutex می تواند برای هماهنگ کردن دسترسی به حالت مشترک بین چندین گوروتین استفاده شود. به عنوان مثال، ممکن است از یک mutex استفاده کنید تا اطمینان حاصل کنید که فقط یک گوروتین می تواند یک ساختار داده مشترک را در یک زمان تغییر دهد.\nپیاده سازی الگوهای تولیدکننده-مصرف کننده (producer-consumer): یک mutex می تواند برای پیاده سازی الگوهای تولیدکننده-مصرف کننده استفاده شود، که در آن یک یا چند گوروتین داده تولید می کنند و یک یا چند گوروتین آن را مصرف می کنند. mutex می تواند برای همگام سازی دسترسی به ساختار داده مشترک که داده ها را نگه می دارد استفاده شود.\n۲ نکته خیلی مهم\nسعی کنید پس از اینکه تابع Lock را فراخوانی میکنید تابع Unlock را داخل defer قرار دهید. زمانیکه قصد دارید Mutex را به عنوان پارامتر ورودی برای توابع تعریف کنید بهتر است از نوع اشاره گر باشد. 3.3.2 RWMutex # در پکیج sync یک تایپ به نام RWMutex وجود دارد که عملیات خواندن و نوشتن برروی یک داده مشترک را همگام سازی می کند. شما می توانید به چندین گوروتین اجازه خواندن یک داده مشترک را بدهید ولی فقط یک گوروتین می تواند عملیات نوشتن را برروی آن داده مشترک انجام دهد.\nبرخی مواقع ممکن است دسترسی به یک مقدار مشترک بین گوروتین ها‌را محدود کنیم اما بر اساس شرایط خاص. مثلا همه ی گورتونین ها بتوانند عملیات خواندن را انجام دهند، اما در آن واحد فقط یک گوروتین بتواند بنویسد.\nدر زیر یک مثال قرار دادیم توجه کنید :\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;math/rand\u0026#34; 6\t\u0026#34;strings\u0026#34; 7\t\u0026#34;sync\u0026#34; 8\t\u0026#34;time\u0026#34; 9) 10 11func init() { 12\trand.Seed(time.Now().Unix()) 13} 14func sleep() { 15\ttime.Sleep(time.Duration(rand.Intn(1000))*time.Millisecond) 16} 17func reader(c chan int, m *sync.RWMutex, wg *sync.WaitGroup) { 18\tsleep() 19\tm.RLock() 20\tc \u0026lt;- 1 21\tsleep() 22\tc \u0026lt;- -1 23\tm.RUnlock() 24\twg.Done() 25} 26func writer(c chan int, m *sync.RWMutex, wg *sync.WaitGroup) { 27\tsleep() 28\tm.Lock() 29\tc \u0026lt;- 1 30\tsleep() 31\tc \u0026lt;- -1 32\tm.Unlock() 33\twg.Done() 34} 35func main() { 36\tvar m sync.RWMutex 37\tvar rs, ws int 38\trsCh := make(chan int) 39\twsCh := make(chan int) 40\tgo func() { 41\tfor { 42\tselect { 43\tcase n := \u0026lt;-rsCh: 44\trs += n 45\tcase n := \u0026lt;-wsCh: 46\tws += n 47\t} 48\tfmt.Printf(\u0026#34;%s%s\\n\u0026#34;, strings.Repeat(\u0026#34;R\u0026#34;, rs), 49\tstrings.Repeat(\u0026#34;W\u0026#34;, ws)) 50\t} 51\t}() 52\twg := sync.WaitGroup{} 53\tfor i := 0; i \u0026lt; 10; i++ { 54\twg.Add(1) 55\tgo reader(rsCh, \u0026amp;m, \u0026amp;wg) 56\t} 57\tfor i := 0; i \u0026lt; 3; i++ { 58\twg.Add(1) 59\tgo writer(wsCh, \u0026amp;m, \u0026amp;wg) 60\t} 61\twg.Wait() 62} 1$ go run main.go 2R 3RR 4R 5RR 6R 7W 8R 9RR 10RRR 11RRRR 12RRRRR 13RRRRRR 14RRRRRRR 15RRRRRR 16RRRRR 17RRRR 18RRR 19RR 20R 21W 22W 3.3.3 WaitGroup # یک ساختاری داخل پکیج sync به نام WaitGroup وجود دارد. معمولا برای منتظر ماندن برای پایان اجرای گروهی از گوروتین ها استفاده می شود. این ساختار ۳ متد دارد که به شرح زیر می باشد:\nAdd: این متد که به عنوان ورودی عدد می گیرد تعداد گوروتین هایی که قرار است منتظر بمانند را تعیین میکند. Done: این تابع زمانی استفاده می شود که فرآیند داخل هریک از گوروتین ها به اتمام برسد. Wait: این متد کد ما را بلاک می کند تا زمانیکه سیگنال Done از تمامی گوروتین ها دریافت کند. بگذارید با یک مثال توضیح دهیم:\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;sync\u0026#34; 6 \u0026#34;time\u0026#34; 7) 8 9func main() { 10 var wg sync.WaitGroup 11 wg.Add(2) 12 go sleep(\u0026amp;wg, time.Second*1) 13 go sleep(\u0026amp;wg, time.Second*2) 14 wg.Wait() 15 fmt.Println(\u0026#34;All goroutines finished\u0026#34;) 16} 17 18func sleep(wg *sync.WaitGroup, t time.Duration) { 19 defer wg.Done() 20 time.Sleep(t) 21 fmt.Println(\u0026#34;Finished Execution\u0026#34;) 22} 1$ go run main.go 2Finished Execution 3Finished Execution 4All goroutines finished در بالا ما یک متغیر از ساختار WaitGroup ایجاد کردیم و پس از ایجاد متد Add را فراخوانی کردیم و تعداد گوروتین هایی که قرار است منتظر بماند را مشخص کردیم. سپس آدرس حافظه متغیر wg را به تابع sleep به عنوان ورودی پاس دادیم و در نهایت داخل تابع sleep با استفاده از defer متد Done را فراخوانی کردیم.\nزمانیکه عملیات تابع sleep اتمام می شود متد Done فراخوانی می شود و یک گوروتین از لیست گوروتین های آبجکت WaitGroup کم می شود.\n1// Done decrements the WaitGroup counter by one. 2func (wg *WaitGroup) Done() { 3 wg.Add(-1) 4} حال وقتی فرآیند ۲ تا گوروتین اتمام شود اون بخش از کد از حالت بلاک بودن خارج می شود.\n۳ نکته خیلی مهم\nساختار WaitGroup یکی از پرکاربرد ترین قابلیت ها برای بحث همزمانی می باشد و برخی اوقات برای جلوگیری از Data race و همچنین برای ترتیب دهی عملیات همزمانی هم می توان از این استفاده کرد. سعی کنید WaitGroup را بصورت اشاره گر به توابعی که داخل گوروتین قرار دارند پاس دهید. هیچوقت تعداد گوروتین را بیشتر یا کمتر از اون تعدادی که دارید به متد Add ‌ندهید چون با خطای Panic مواجه خواهید شد. 3.3.4 Once # در پکیج sync ما یک تایپ داریم به نام Once که برای اطمینان از اینکه یک تابع فقط یکبار فراخوانی می شود استفاده می شود. شما فرض کنید قصد دارید در طول برنامه از یک آبجکت فقط یک instance داشته باشید می توانید با استفاده از Once این کار را انجام دهید (شما با استفاده از Once می توانید الگو طراحی Singleton را پیاده سازی کنید.)\nبه مثال زیر توجه کنید:\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;sync\u0026#34; 6) 7 8type singleton struct { 9\tdata string 10} 11 12var instance *singleton 13var once sync.Once 14 15func GetInstance() *singleton { 16\tonce.Do(func() { 17\tinstance = \u0026amp;singleton{data: \u0026#34;some data\u0026#34;} 18\t}) 19\treturn instance 20} 21 22func main() { 23\ts1 := GetInstance() 24\ts2 := GetInstance() 25\tif s1 == s2 { 26\tfmt.Println(\u0026#34;Same instance\u0026#34;) 27\t} else { 28\tfmt.Println(\u0026#34;Different instances\u0026#34;) 29\t} 30} 1$ go run main.go 2Same instance در مثال فوق ما یک تابع داریم به نام GetInstance که به عنوان خروجی ساختار singleton را بصورت اشاره گر ارائه می دهد. قبل از تابع ۲ تا متغیر تعریف کردیم به نام once و instance که داخل تابع GetInstance از متد Do متغیر once یک تابع inline را قرار دادیم که فقط یک آبجکت از ساختار singleton می سازد و داخل متغیر instance قرار می دهد. در نهایت instance بازگشت داده می شود.\n3.3.5 Pool # در نسخه ۱.۳ زبان گو امکانی تایپی به نام Pool در پکیج sync که امکان ایجاد استخر آبجکت ها بطور موقت بدون اینکه بخواهد بخشی از حافظه را اشتغال کند اضافه شد. هر آبجکتی که در Pool ذخیره شود بطور خودکار در هرزمانی بدون اینکه اطلاع رسانی کند حذف می شود. امکان استفاده مجدد از آبجکت هایی که داخل استخر می گیرند وجود دارد و این باعث می شود سربار استفاده حافظه کاهش یابد.\n1package main 2 3import ( 4\t\u0026#34;bytes\u0026#34; 5\t\u0026#34;io\u0026#34; 6\t\u0026#34;os\u0026#34; 7\t\u0026#34;sync\u0026#34; 8\t\u0026#34;time\u0026#34; 9) 10 11var bufPool = sync.Pool{ 12\tNew: func() any { 13\t// The Pool\u0026#39;s New function should generally only return pointer 14\t// types, since a pointer can be put into the return interface 15\t// value without an allocation: 16\treturn new(bytes.Buffer) 17\t}, 18} 19 20// timeNow is a fake version of time.Now for tests. 21func timeNow() time.Time { 22\treturn time.Unix(1136214245, 0) 23} 24 25func Log(w io.Writer, key, val string) { 26\tb := bufPool.Get().(*bytes.Buffer) 27\tb.Reset() 28\t// Replace this with time.Now() in a real logger. 29\tb.WriteString(timeNow().UTC().Format(time.RFC3339)) 30\tb.WriteByte(\u0026#39; \u0026#39;) 31\tb.WriteString(key) 32\tb.WriteByte(\u0026#39;=\u0026#39;) 33\tb.WriteString(val) 34\tw.Write(b.Bytes()) 35\tbufPool.Put(b) 36} 37 38func main() { 39\tLog(os.Stdout, \u0026#34;path\u0026#34;, \u0026#34;/search?q=flowers\u0026#34;) 40} 1$ go run main.go 22006-01-02T15:04:05Z path=/search?q=flowers در بالا ما یک متغیر به نام bufPool ایجاد کردیم که یک آبجکت از نوع bytes.Buffer ایجاد می کند. سپس داخل تابع Log ما با استفاده از متد Get آبجکت مورد نظر را از Pool خارج و داخل متغیر b قرار دادیم و پس از آن عملیات لازم را برروی Buffer انجام و در نهایت با استفاده از متد Put آبجکت را به Pool اضافه کردیم. حالا اتفاقی که صورت گرفته ما عملیاتی که نیاز داشتیم را برروی آبجکت انجام دادیم بدون اینکه بخوایم بخشی از حافظه را درگیر کنیم.\n3.3.5.1 بنچمارک در خصوص Pool # 1package main 2 3import ( 4 \u0026#34;sync\u0026#34; 5 \u0026#34;testing\u0026#34;) 6 7type Person struct { 8 Age int 9} 10 11var personPool = sync.Pool{ 12 New: func() interface{} { return new(Person) }, 13} 14 15func BenchmarkWithoutPool(b *testing.B) { 16 var p *Person 17 b.ReportAllocs() 18 b.ResetTimer() 19 for i := 0; i \u0026lt; b.N; i++ { 20 for j := 0; j \u0026lt; 10000; j++ { 21 p = new(Person) 22 p.Age = 23 23 } 24 } 25} 26 27func BenchmarkWithPool(b *testing.B) { 28 var p *Person 29 b.ReportAllocs() 30 b.ResetTimer() 31 for i := 0; i \u0026lt; b.N; i++ { 32 for j := 0; j \u0026lt; 10000; j++ { 33 p = personPool.Get().(*Person) 34 p.Age = 23 35 personPool.Put(p) 36 } 37 } 38} 1$ go test -bench=. -benchmem 2 3goos: linux 4goarch: amd64 5pkg: pool 6cpu: Intel(R) Core(TM) i5-3570 CPU @ 3.40GHz 7BenchmarkWithoutPool-4 5262 213177 ns/op 80000 B/op 10000 allocs/op 8BenchmarkWithPool-4 7699 152788 ns/op 0 B/op 0 allocs/op 9PASS 10ok pool 2.343s 3.3.5.2 مثال های کاربردی # مثال اول :\nفرض کنید شما می خواهید یک فایل csv را با کلی رکورد parse کنید. هر رکورد نیازمند این است که داخل یک ساختاری قرار بگیرد و ایجاد یک ساختار باعث می شود بخشی از حافظه اختصاص یابد به آن ساختار. حالا فکر کنید میلیون ها رکورد داشته باشید و این تخصیص حافظه می تواند باعث توقف برنامه شود.\nحالا برای اینکه بخواهیم جلوی این اتفاق را بگیریم و سربار را کاهش دهیم بهتر است ما از sync.Pool استفاده کنیم و ساختارها را داخل استخر قرار دهیم. و زمانیکه هرکدام از ساختارها مورد نیاز نباشد می توانند داخل استخر قرار گیرند و مجدد استفاده شوند. اینکار باعث می شود بطور خیلی قابل توجهی تعداد تخصیص حافظه کاهش یابد و عملکرد برنامه چند برابر شود.\nمثال دوم :\nموارد استفاده دیگر از sync.Pool برای ذخیره کردن آبجکت های پرکاربرد نظیر کانکشن دیتابیس یا شبکه و همچنین آبجکت هایی که قصد داریم برروی آن عملیات serialize و deserialize انجام دهیم.\n3.3.6 Cond # پکیج sync.Cond یکی از ابزارهای پیشرفته همزمانی در زبان Go است که امکان پیاده‌سازی الگوی \u0026ldquo;مانیتور\u0026rdquo; یا همان شرط انتظاری (Condition Variable) را فراهم می‌کند. Cond به شما اجازه می‌دهد تا مجموعه‌ای از goroutineها را تا زمانی که یک شرط یا رویداد خاص برقرار نشده، به صورت امن و کارآمد (بدون busy-waiting یا مصرف بی‌مورد CPU) منتظر نگه دارید. زمانی که شرط مورد نظر برقرار شد، می‌توانید یک یا همه goroutineهای منتظر را بیدار کنید تا کارشان را ادامه دهند. این تکنیک، در بسیاری از الگوهای معروف concurrency مانند producer-consumer، صف انتظار، صف پیام و کنترل منابع محدود کاربرد اساسی دارد.\nنحوه کار Cond و نقش قفل (Mutex / RWMutex) # برای ساخت یک شیء Cond باید یک قفل (معمولاً از نوع *sync.Mutex یا *sync.RWMutex) به آن بدهید. این قفل به Cond اجازه می‌دهد تا وضعیت مشترک (shared state) را در میان چند goroutine به طور thread-safe بررسی و کنترل کند. قفل، تضمین می‌کند که هیچ دو goroutineای همزمان نتوانند وضعیت را تغییر دهند یا به متدهای Cond دسترسی پیدا کنند، که این برای جلوگیری از race condition کاملاً حیاتی است.\n1lock := \u0026amp;sync.Mutex{} 2cond := sync.NewCond(lock) عملکرد متدها # Wait():\nوقتی یک goroutine متد Wait را صدا می‌زند، دو اتفاق پشت‌سرهم رخ می‌دهد:\nقفل داده‌شده (مثلاً Mutex) به طور موقت آزاد می‌شود تا سایر goroutineها بتوانند وضعیت مشترک را تغییر دهند. goroutine تا زمان دریافت سیگنال (Signal یا Broadcast) به حالت تعلیق (sleep) می‌رود و هیچ پردازشی انجام نمی‌دهد (کاملاً غیرمسدودکننده).\nپس از دریافت سیگنال و بیدار شدن، Wait دوباره به صورت اتمیک قفل را در اختیار می‌گیرد و اجرا از همان خط ادامه پیدا می‌کند.\nمعمولاً قبل از Wait باید شرط را داخل یک حلقه (for) بررسی کنید تا از spurious wakeup و رقابت داده‌ای جلوگیری شود: 1cond.L.Lock() 2for !شرط_برقرار_است { 3 cond.Wait() 4} 5// ادامه منطق ... 6cond.L.Unlock() Signal():\nاین متد تنها یکی از goroutineهای منتظر را بیدار می‌کند (اگر کسی در صف انتظار باشد). انتخاب اینکه کدام goroutine بیدار شود به سیاست زمان‌بندی runtime وابسته است و تضمینی برای ترتیب خاصی وجود ندارد. Signal معمولاً زمانی به کار می‌رود که انتظار دارید فقط یک مصرف‌کننده با داده جدید یا تغییر وضعیت بیدار شود.\nBroadcast():\nاین متد همه goroutineهای منتظر روی آن Cond را بیدار می‌کند تا شرط را دوباره بررسی کنند. Broadcast زمانی کاربرد دارد که یک رویداد می‌تواند برای همه‌ی منتظرها مهم باشد (مثلاً اتمام کار یا آزاد شدن منبع برای همه مصرف‌کننده‌ها).\nبه مثال زیر توجه کنید :\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;sync\u0026#34; 6) 7 8var sharedResource = make(map[string]interface{}) 9 10func main() { 11\tvar wg sync.WaitGroup 12\twg.Add(2) 13\tlocker := sync.Mutex{} 14\tcondition := sync.NewCond(\u0026amp;locker) 15 16\tgo waitForResourceUpdate(\u0026amp;wg, condition, \u0026#34;rsc1\u0026#34;) 17\tgo waitForResourceUpdate(\u0026amp;wg, condition, \u0026#34;rsc2\u0026#34;) 18 19\t// this one writes changes to sharedResource 20\tcondition.L.Lock() 21\tsharedResource[\u0026#34;rsc1\u0026#34;] = \u0026#34;a string\u0026#34; 22\tsharedResource[\u0026#34;rsc2\u0026#34;] = 123456 23\tcondition.Broadcast() 24\tcondition.L.Unlock() 25 26\twg.Wait() 27} 28 29// waitForResourceUpdate waits for a signal that a resource changed and prints it. 30func waitForResourceUpdate(wg *sync.WaitGroup, cond *sync.Cond, key string) { 31\tdefer wg.Done() 32\tcond.L.Lock() 33\tfor len(sharedResource) == 0 { 34\tcond.Wait() 35\t} 36\tfmt.Println(\u0026#34;Resource\u0026#34;, key, \u0026#34;:\u0026#34;, sharedResource[key]) 37\tcond.L.Unlock() 38} 1$ go run main.go 2Resource rsc2 : 123456 3Resource rsc1 : a string "},{"id":35,"href":"/chapter-3/go-atomic/","title":"3.4 پکیج atomic","section":"فصل سوم: همزمانی (concurrency)","content":"پکیج sync/atomic در زبان Go مجموعه‌ای از توابع سطح پایین (low-level) را برای انجام عملیات خواندن و نوشتن اتمی (atomic) روی متغیرهای حافظه فراهم می‌کند. منظور از عملیات اتمیک، عملیاتی است که به طور کامل و یکپارچه توسط CPU انجام می‌شود؛ یعنی هیچ گوروتین، thread یا پردازش دیگری نمی‌تواند مقدار متغیر را بین شروع و پایان یک عملیات اتمیک مشاهده یا تغییر دهد. این ویژگی برای پیاده‌سازی الگوهای همگام‌سازی سبک و بدون قفل (lock-free synchronization) و متغیرهای اشتراکی با دسترسی سریع و ایمن ضروری است.\nمهم‌ترین کاربردها و عملیات: # پیاده‌سازی شمارنده‌های اتمیک (atomic counters):\nمثلاً افزایش شمارنده تعداد درخواست، جمع یا کم کردن بدون نیاز به Mutex. فلگ‌ها یا وضعیت‌های اشتراکی:\nتنظیم و خواندن یک فلگ مشترک بین چند goroutine به شکلی که دچار race condition نشود. ساخت primitiveهای همگام‌سازی سفارشی:\nمثل اسپین‌لاک، قفل ساده، lock-free queue، semaphore سطح پایین و… متدهای مهم atomic: # atomic.AddInt32 / AddUint64 — جمع یا کم کردن مقدار به صورت اتمیک atomic.LoadInt32 / LoadPointer — خواندن مقدار به شکل اتمیک atomic.StoreInt32 / StorePointer — نوشتن مقدار به شکل اتمیک atomic.CompareAndSwapInt32 — عمل مقایسه و جایگزینی اتمیک (CAS)، قلب الگوریتم‌های lock-free atomic.Value — یک ساختار wrapper برای نگهداری داده با خواندن و نوشتن اتمیک (ایده‌آل برای ساخت cacheهای ساده یا حافظه به اشتراک گذاشته شده) به مثال زیر توجه کنید :\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;sync\u0026#34; 6\t\u0026#34;sync/atomic\u0026#34; 7) 8 9type Cache struct { 10\tmu sync.Mutex 11\tdata map[string]string 12} 13 14func (c *Cache) Set(key, value string) { 15\tc.mu.Lock() 16\tdefer c.mu.Unlock() 17\tc.data[key] = value 18} 19 20func (c *Cache) Get(key string) (value string, ok bool) { 21\tc.mu.Lock() 22\tdefer c.mu.Unlock() 23\tvalue, ok = c.data[key] 24\treturn 25} 26 27type AtomicCache struct { 28\tmu sync.Mutex 29\tdata atomic.Value 30} 31 32func (c *AtomicCache) Set(key, value string) { 33\tc.mu.Lock() 34\tdefer c.mu.Unlock() 35\tc.data.Store(map[string]string{key: value}) 36} 37 38func (c *AtomicCache) Get(key string) (value string, ok bool) { 39\tdata := c.data.Load().(map[string]string) 40\tvalue, ok = data[key] 41\treturn 42} 43 44func main() { 45\tcache := Cache{data: map[string]string{}} 46\tcache.Set(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;) 47\tfmt.Println(cache.Get(\u0026#34;key\u0026#34;)) // Output: value, true 48 49\tatomicCache := AtomicCache{data: atomic.Value{}} 50\tatomicCache.Set(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;) 51\tfmt.Println(atomicCache.Get(\u0026#34;key\u0026#34;)) // Output: value, true 52} 1$ go run main.go 2value true 3value true در مثال فوق ما یک ساختار به نام Cache داریم که داخلش یک فیلد از نوع map داریم و قصد داریم یکسری اطلاعات را داخل کش بریزیم حال زمانیکه Set/Get می کنیم با استفاده از Mutex اون بخش از عملیات را لاک میکنیم تا جلوی عملیات نوشتن چندین گوروتین برروی یک آدرس حافظه را بگیریم. حال این عملیات رو ما با استفاده از atomic انجام دادیم و همگام سازی داده را بردیم تو سطح خیلی پایین تر در حافظه و با استفاده از atomic.Value که یک اینترفیس است این عملیات را انجام دادیم و این عملیات Set/Get حالت atomic پیدا کرده است.\nآیا استفاده از atomic نیازمند mutex می باشد یا خیر؟\nدر این کد، mutex در متد Set برای جلوگیری از رخ دادن race condition یا داده‌های نامنظم استفاده شده است. بدون mutex، چندین گوروتین ممکن است همزمان به دسترسی و تغییر داده‌های map data بپردازند که موجب رفتار نامنظم و فساد داده می‌شود. با گرفتن mutex قبل از تغییر map data، متد Set اطمینان حاصل می‌کند که تنها یک گوروتین در هر زمان می‌تواند به داده‌ها دسترسی پیدا کند و تداخل داده‌ها را جلوگیری می‌کند.\nاستفاده از mutex در متد Get نیز مهم است، زیرا این اطمینان را به ما می‌دهد که در هنگام دسترسی به map data، هیچ گوروتین دیگری دارای مجوز تغییر داده‌ها نیست. بدون mutex، یک race condition ممکن است ایجاد شود اگر یک گوروتین دیگر در حال تغییر داده‌های map باشد در حالی که یک گوروتین دیگر سعی در خواندن از آن دارد.\nدر پیاده‌سازی AtomicCache، یک atomic.Value برای ذخیره map استفاده شده است که به انجام عملیات اتمی روی آن اجازه می‌دهد. با این حال، حتی با استفاده از یک مقدار اتمی، همچنان نیاز به mutex وجود دارد تا فقط یک گوروتین در هر زمان به map دسترسی داشته باشد و تداخل داده‌ها را جلوگیری کند.\n3.4.1 نکات و هشدارهای تولیدی (Production Caveats) # memory safety: پکیج atomic از ویژگی‌های سطح پایین CPU استفاده می‌کند و bypass کردن حافظه امن زبان Go را ممکن می‌سازد؛ یعنی اگر به درستی از آن استفاده نکنید، به‌راحتی دچار bugهای عجیب و غیرقابل ردیابی خواهید شد. استفاده اشتباه می‌تواند باعث بروز race condition، memory corruption و مشکلات شدید تولیدی شود.\nتراز حافظه (memory alignment): متغیرهایی که به صورت اتمیک تغییر می‌کنند باید به درستی روی حافظه align شوند (مثلاً در ساختار struct کنار سایر داده‌ها قرار نگیرند). بی‌توجهی به این نکته ممکن است باعث crash برنامه در معماری‌های خاص شود.\nمناسب برای عملیات ساده: atomic برای primitive data types (int32, int64, pointer, \u0026hellip;)، عملیات ساده و سناریوهایی با هماهنگی حداقلی طراحی شده است؛ اگر منطق پیچیده‌تر دارید یا باید چندین متغیر را همزمان به شکل اتمیک تغییر دهید، از sync.Mutex یا سایر ابزارهای همزمانی ایمن Go استفاده کنید.\nکاملاً lock-free نیست: گرچه atomic سریع و سبک است، اما فقط برای primitiveها کاملاً lock-free است. برای کار با داده‌های پیچیده یا ساختارهای بزرگ، باید با احتیاط و دانش کافی عمل کنید.\natomic.Value برای داده‌های ساختاری، اما فقط با خواندن و نوشتن کامل؛ عملیات mutate روی داده ذخیره‌شده (مثلاً map یا slice) اتمیک نیست مگر کل value جایگزین شود.\n3.4.2 برخی از کاربردهای atomic # در زیر چندتا use case برای استفاده از پکیج atomic معرفی کردیم :\nپیاده سازی همگام سازی بدون مسدودیت : پکیج atomic توابع سطح پایینی را برای انجام عملیات حافظه اتمی فراهم می کند که می تواند برای پیاده سازی الگوریتم های همگام سازی غیرمسدود مانند مقایسه و تعویض (CAS) یا بارگذاری لینک/ذخیره شرطی استفاده شود. LL/SC).\nپیاده سازی ساختارهای داده با همزمانی سطح (high-concurrency) بالا : با پکیج atomic می توان برای پیاده سازی ساختارهای داده ای استفاده کرد که برای دسترسی همزمان و اصلاح توسط چندین گوروتین ایمن هستند. به عنوان مثال، می توانید از بسته اتمی برای پیاده سازی نقشه یا صف همزمان استفاده کنید.\nپیاده سازی شمارنده (counter) از نوع atomic : شما با استفاده از پکیج atomic می توانید برای افزایش و کاهش شمارنده ها به صورت اتمی که می تواند برای اجرای مواردی مانند شمارش مرجع یا محدود کردن ratelimit استفاده شود.\n"},{"id":36,"href":"/chapter-3/goroutine-data-race/","title":"3.5 آموزش مقابله با data race","section":"فصل سوم: همزمانی (concurrency)","content":"معمولا تو بحث همزمانی یکی از اتفاقاتی که خیلی ممکن است رخ دهد بحث data race است و data race زمانی رخ می دهد که ۲ یا چند گوروتین قصد دارند به یک آدرس حافظه در یک زمان دسترسی داشته باشند. حال اگر ما جلوی data race را نگیریم ممکن است تغییرات نادرست برروی مقادیر داخل خانه حافظه صورت گیرد.\nراه هایی برای مقابله با data race وجود دارد که به شرح زیر است :\nاستفاده از Mutex داخل پکیج sync برای قفل گذاشتن/برداشتن یک بخش دیتا. استفاده RWMutex داخل پکیج sync می توانید داده اشتراک گذاری شده را قفل کنید فقط یک گوروتین عملیات نوشتن داشته باشد. استفاده از پکیج atomic برای عملیات بصورت atomic برروی مقادیر. 3.5.1 تشخیص Data Race # به لطف امکان جانبی زبان گو شما می توانید خیلی راحت بخش هایی که data race رخ داده را تشخیص دهید. کافیه سوییچ race- را هنگام build اضافه کنید تا در زمان data race ها را تشخیص دهید.\n1$ go run -race main.go 2 3================== 4WARNING: DATA RACE 5Write at 0x00c000522c20 by goroutine 29: 6 git.ramooz.org/ramooz/golang-components/event-driven/rabbitmq.(*Connection).handleReconnect() 7 /home/user/Project/go/ramooz.org/medx/software-builder/vendor/git.ramooz.org/ramooz/golang-components/event-driven/rabbitmq/rabbit.go:86 +0x89 8 git.ramooz.org/ramooz/golang-components/event-driven/rabbitmq.NewConnection.func1() 9 /home/user/Project/go/ramooz.org/medx/software-builder/vendor/git.ramooz.org/ramooz/golang-components/event-driven/rabbitmq/rabbit.go:35 +0x58 10 11Previous read at 0x00c000522c20 by main goroutine: 12 git.ramooz.org/ramooz/golang-components/event-driven/rabbitmq.NewConnection() 13 /home/user/Project/go/ramooz.org/medx/software-builder/vendor/git.ramooz.org/ramooz/golang-components/event-driven/rabbitmq/rabbit.go:37 +0x324 14 git.ramooz.org/ramooz/golang-components/logger.initializeRabbitMQ() 15 /home/user/Project/go/ramooz.org/medx/software-builder/vendor/git.ramooz.org/ramooz/golang-components/logger/rabbit.conn.go:11 +0x226 16 git.ramooz.org/ramooz/golang-components/logger.NewLogger() 17 /home/user/Project/go/ramooz.org/medx/software-builder/vendor/git.ramooz.org/ramooz/golang-components/logger/logger.go:37 +0x456 18 ramooz.org/ramooz/user-service/configs.initNewLogger() 19 /home/user/Project/go/ramooz.org/medx/software-builder/configs/configs.go:158 +0x938 20 ramooz.org/ramooz/user-service/configs.ConfigServer() 21 /home/user/Project/go/ramooz.org/medx/software-builder/configs/configs.go:54 +0x15a 22 main.main() 23 /home/user/Project/go/ramooz.org/medx/software-builder/main.go:17 +0x29 24 25Goroutine 29 (running) created at: 26 git.ramooz.org/ramooz/golang-components/event-driven/rabbitmq.NewConnection() 27 /home/user/Project/go/ramooz.org/medx/software-builder/vendor/git.ramooz.org/ramooz/golang-components/event-driven/rabbitmq/rabbit.go:35 +0x2da 28 git.ramooz.org/ramooz/golang-components/logger.initializeRabbitMQ() 29 /home/user/Project/go/ramooz.org/medx/software-builder/vendor/git.ramooz.org/ramooz/golang-components/logger/rabbit.conn.go:11 +0x226 30 git.ramooz.org/ramooz/golang-components/logger.NewLogger() 31 /home/user/Project/go/ramooz.org/medx/software-builder/vendor/git.ramooz.org/ramooz/golang-components/logger/logger.go:37 +0x456 32 ramooz.org/ramooz/user-service/configs.initNewLogger() 33 /home/user/Project/go/ramooz.org/medx/software-builder/configs/configs.go:158 +0x938 34 ramooz.org/ramooz/user-service/configs.ConfigServer() 35 /home/user/Project/go/ramooz.org/medx/software-builder/configs/configs.go:54 +0x15a 36 main.main() 37 /home/user/Project/go/ramooz.org/medx/software-builder/main.go:17 +0x29 38================== در خروجی بالا یک هشدار data race داده است که در فلان خط کد شما فلان گوروتین ها در یک زمان دسترسی برروی یک داده را دارند. و شما با توجه به خروجی می توانید سناریو های جلوگیری را انجام دهید.\n"},{"id":37,"href":"/chapter-3/go-channel/","title":"3.6 کانال (channel)","section":"فصل سوم: همزمانی (concurrency)","content":" کانال یک نوع تایپ است که داده از نوع خاصی را نگه داری میکند و امکان برقراری ارتباط و همگام سازی داده بین گوروتین ها را فراهم می کند. شما می توانید کانال ها را به عنوان خط لوله هایی در نظر بگیرید که این خط لوله ها به گوروتین ها متصل می شوند و باعث برقراری ارتباط بین گوروتین ها می شوند. این ارتباط بین گوروتین ها به هیچ قفل صریحی نیاز ندارد (منظورم mutex و \u0026hellip;) چون کانال ها بصورت داخلی قفل ها را مدیریت میکنند و در زمان های مناسب و مشخص Lock و UnLock می کنند.\nبه نقل از رابرت گریزمر که یکی از توسعه دهنده های اصلی زبان برنامه نویسی گو می باشد در خصوص کانال ها می گوید : با برقراری ارتباط حافظه را به اشتراک بزارید ولی با اشتراک گذاری حافظه ارتباط برقرار نکنید.\nمنظور از نقل فوق این است شما برای اینکه بخوای بین گوروتین ها ارتباط برقرار کنی این کار را با اشتراک گذاری حافظه نکنید. بلکه باید بواسطه کانال ها حافظه را بین گوروتین ها به اشتراک بزارید.\nزبان گو برای بحث همزمانی ۲ تا مقوله خیلی مهم دارد که این دو با هم در ارتباط هستند :\nگوروتین ها : یک thread مستقل و سبک وزن در زبان گو که قابلیت برنامه نویسی همزمان (concurrency) را فراهم می کند. کانال ها : فراهم کننده ارتباط و همگام سازی داده ها بین گوروتین ها. 3.6.1 تعریف کانال ها # همانطور که گفتیم کانال یک نوع تایپ است که داده از نوع خاصی را نگه داری میکند. برای استفاده از کانال ها، شما باید این تایپ را برای متغیری تعریف کنید تا بتوانید بواسطه آن متغیر از کانال استفاده کنید و بین گوروتین ها ارتباط برقرار کنید.\n1var \u0026lt;variable_name\u0026gt; chan \u0026lt;type\u0026gt; به مثال زیر توجه کنید :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 var a chan int 7 fmt.Println(a) 8} 1$ go run main.go 2{nil} در بالا ما یک متغیر با نام a تعریف کردیم که از نوع کانال با تایپ int می باشد و این کانال فقط انتقال داده از نوع int را انجام می دهد. و مقدار پیش فرض کانال nil می باشد که در خروجی می توانید ببینید.\nتوجه کنید همیشه سعی کنید کانال را با استفاده از تابع make ایجاد کنید. 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 a := make(chan int) 7 fmt.Println(a) 8} 1$ go run main.go 20xc0000240c0 در خروجی کد بالا همانطور که مشاهده می کنید به جای nil آدرس حافظه داده را نمایش می دهد.\nزمانیکه شما یک کانال را به واسطه make ایجاد می کنید در واقع دارید یک instance از ساختار hchan ایجاد می کنید و تمامی فیلدهای این ساختار مقدار پیش فرض میگیرند.\n1type hchan struct { 2 qcount uint // total data in the queue 3 dataqsiz uint // size of the circular queue 4 buf unsafe.Pointer // points to an array of dataqsiz elements 5 elemsize uint16 6 closed uint32 // denotes weather channel is closed or not 7 elemtype *_type // element type 8 sendx uint // send index 9 recvx uint // receive index 10 recvq waitq // list of recv waiters 11 sendq waitq // list of send waiters 12 lock mutex 13} 3.6.2 عملیات ها برروی کانال # زمانیکه شما یک کانال ایجاد می کنید، دو عملیات اصلی بر روی کانال می توانید انجام دهید :\nارسال : ارسال داده به داخل کانال دریافت : دریافت داده از کانال 3.6.2.1 عملیات ارسال # برای ارسال داده به داخل کانال یک اپراتور استاندارد وجود دارد که بهتر است همیشه به خاطر بسپارید :\n1ch \u0026lt;- val متغیر ch همان کانالی است که با استفاده از تایپ chan ساخته شده است. متغیر val هم مقداری است که توسط اپراتور \u0026lt;- به کانال ارسال شده است. توجه کنید تایپ val باید با تایپی که برای کانال مشخص کردید حتما یکی باشد. 3.6.2.2 عملیات دریافت # عملیات دریافت در کانال صرفا جهت خواندن داده از طریق کانال می باشد که یک قالب استاندارد همانند عملیات ارسال دارد :\n1val := \u0026lt;- ch در اینجاهم ch همان متغیر کانال می باشد. متغیر val هم منتظر دریافت داده به واسطه \u0026gt;- از طریق کانال ch می باشد. 3.6.2.3 مثال عملیات ارسال و دریافت # در زیر یک مثال میزنیم که داده ای را بواسطه کانال ارسال/دریافت می کنیم بین گوروتین ها.\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;time\u0026#34; 6) 7 8func main() { 9 ch := make(chan int) 10 11 fmt.Println(\u0026#34;Sending value to channel\u0026#34;) 12 go send(ch) 13 14 fmt.Println(\u0026#34;Receiving from channel\u0026#34;) 15 go receive(ch) 16 17 time.Sleep(time.Second * 1) 18} 19 20func send(ch chan int) { 21 ch \u0026lt;- 1 22} 23 24func receive(ch chan int) { 25 val := \u0026lt;-ch 26 fmt.Printf(\u0026#34;Value Received=%d in receive function\\n\u0026#34;, val) 27} 1$ go run main.go 2Sending value to channel 3Receiving from channel 4Value Received=1 in receive function در کد فوق ما یک کانال با نام ch از نوع int ایجاد کردیم. سپس ۲ تابع send و received را داخل گوروتین قرار دادیم که هر دو تابع به عنوان پارامتر ورودی تایپ int را بصورت کانال میگیرد. حال متغیر کانال ch را به هر دو تابع پاس دادیم. و در هر دو تابع ۲ تا عملیات صورت گرفته :\nتابع send مقدار عدد ۱ را به داخل کانال ارسال کرده تابع recived مقدار را از کانال ch دریافت کرده و داخل متغیر val قرار داده است و در نهایت متغیر val را چاپ کرده است. در انتهای تابع main ما یک sleep به مدت ۱ ثانیه قرار دادیم که بتوانیم خروجی برنامه را ببینیم. اگر اینکار را نکنیم گوروتین main ممکن است سریع تر از اینکه دو گوروتین دیگر اجرا شوند و خروجی آنها را ببینیم، کارش به اتمام برسد و برنامه متوقف شود.\nیک نکته بسیار مهمی که در مورد کانال ها وجود دارد و باید به آن توجه کنید این است که یک مقدار زمانی که داخل کانال ارسال می شود، فقط یکبار قابل دریافت کردن است. همانطور که می بینید هیچ قفلی در گوروتین ها موقع ارسال و دریافت استفاده نشده است و قفل ها توسط خود کانال مدیریت می شوند و نیازی به استفاده از قفل ها در کد نیست.\nبزارید یک مثال ساده برای اینکه ببینید چطور کانال ها Lock و UnLock می شوند بزنیم :\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;time\u0026#34; 6) 7 8func main() { 9 ch := make(chan int) 10 go send(ch) 11 12 go receive(ch) 13 time.Sleep(time.Second * 2) 14} 15 16func send(ch chan int) { 17 time.Sleep(time.Second * 1) 18 fmt.Println(\u0026#34;Timeout finished\u0026#34;) 19 ch \u0026lt;- 1 20} 21 22func receive(ch chan int) { 23 val := \u0026lt;-ch 24 fmt.Printf(\u0026#34;Receiving Value from channel finished. Value received: %d\\n\u0026#34;, val) 25} 1$ go run main.go 2Timeout finished 3Receiving Value from channel finished. Value received: 1 در کد فوق ما داخل تابع send یک sleep به مدت ۱ ثانیه قرار دادیم. و پس از اینکه ۱ ثانیه تمام شد مقدار را داخل کانال ch ارسال کردیم و سپس مقدار داخل تابع recived دریافت شد.\nاتفاقی که در کد فوق رخداد زمانیکه شما عملیات دریافت را انجام می دهید تا زمانیکه مقداری از کانال دریافت نشود اون بخش از کد شما Lock می شود و پس از اینکه دریافت شد مقدار از کانال آن بخش Unlock خواهد شد.\n3.6.3 ایجاد کانال بافر شده # تا اینجای کار ما از کانال های Un Buffered استفاده کردیم. در این نوع کانال ها تا زمانی که یک دریافت کننده نداشته باشیم نمی توانیم چیزی را در کانال ارسال کنیم و کد ما در آن خط لاک می شود تا دریافت کننده ای پیدا شود. برای درک کانال های Un Buffered بازی تنیس را درنظر بگیرید. فقط یک توپ داریم و یک شخص منتظر دریافت کردن توپ است و شخص دیگر در حال ارسال توپ.\nدر زبان گو شما می توانید کانال های بافر شده ایجاد کنید. یک کانال بافر دارای ظرفیتی مشخص برای نگه داری داده است. در این صورت نیازی نیست حتما یک دریافت کننده منتظر دریافت داده باشد تا بتوانیم داخل کانال چیزی ارسال کنیم. بلکه تا زمانی که ظرفیت کانال پر نشده باشد، می توانیم داده ارسال کنیم.\nبزارید کمی ساده تر توضیح دهیم شما برای کانال همانند آرایه و slice می توانید یک ظرفیت مشخصی تعیین کنید که این کانال فقط می تواند این مقدار از داده را نگه داری کند و تا زمانیکه مقادیر از کانال خارج نشود ظرفیت کانال پرخواهد بود و مقدار جدیدی را نمی توانید به کانال ارسال کنید.\nبرای ایجاد یک کانال بافر شده از روش زیر استفاده کنید :\n1a := make(chan , capacity) مقدار capacity که بصورت عدد هست تعداد بافر کانال را مشخص می کند که این کانال فقط می تواند این حجم از داده را داخل کانال نگه داری کند.\nبه مثال زیر توجه کنید :\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5) 6 7func main() { 8 ch := make(chan int, 1) 9 ch \u0026lt;- 1 10 fmt.Println(\u0026#34;Sending value to channnel complete\u0026#34;) 11 val := \u0026lt;-ch 12 fmt.Printf(\u0026#34;Receiving Value from channel finished. Value received: %d\\n\u0026#34;, val) 13} 1$ go run main.go 2Sending value to channnel complete 3Receiving Value from channel finished. Value received: 1 در کد فوق ما یک کانال بافر شده با ظرفیت ۱ ایجاد کردیم و مقدار ۱ را به کانال ارسال کردیم و در ادامه این مقدار را از کانال دریافت کردیم.\n1ch := make(chan int, 1) 3.6.3.1 ارسال داده برروی کانال با ظرفیت پر # حالا فرض کنید می خواهیم به کانال بافر شده کد فوق یک مقدار دیگری را ارسال کنیم :\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7func main() { 8\tch := make(chan int, 1) 9\tch \u0026lt;- 1 10\tch \u0026lt;- 2 11\tfmt.Println(\u0026#34;Sending value to channnel complete\u0026#34;) 12\tval := \u0026lt;-ch 13\tfmt.Printf(\u0026#34;Receiving Value from channel finished. Value received: %d\\n\u0026#34;, val) 14} 1$ go run main.go 2fatal error: all goroutines are asleep - deadlock! 3 4goroutine 1 [chan send]: 5main.main() 6\t/tmp/sandbox2390960160/prog.go:10 +0x4b در کد فوق اتفاقی که افتاد ما یک کانال بافر شده با ظرفیت ۱ ایجاد کردیم ولی به این کانال ۲ تا مقدار ارسال کردیم:\n1ch \u0026lt;- 1 2ch \u0026lt;- 2 در ادامه اتفاقی که صورت گرفت کانال ما به خاطر پر شدن ظرفیتش بلاک شده بود و داده دیگه ای را نمی توانست نگه داری کند. در نتیجه با خطای deadlock مواجه شد و برنامه کاملا متوقف شد :\n1fatal error: all goroutines are asleep - deadlock! دریافت مجدد داده از کانال خالی شده # به مثال زیر توجه کنید :\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5) 6 7func main() { 8 ch := make(chan int, 1) 9 ch \u0026lt;- 1 10 fmt.Println(\u0026#34;Sending value to channnel complete\u0026#34;) 11 val := \u0026lt;-ch 12 val = \u0026lt;-ch 13 fmt.Printf(\u0026#34;Receiving Value from channel finished. Value received: %d\\n\u0026#34;, val) 14} 1$ go run main.go 2Sending value to channnel complete 3fatal error: all goroutines are asleep - deadlock! 4 5goroutine 1 [chan receive]: 6main.main() 7\t/tmp/sandbox3239418330/prog.go:12 +0xad در کد فوق ما یک کانال بافر شده با ظرفیت ۱ ایجاد کردیم و یک مقدار را به کانال ارسال کردیم و در نهایت ۲ بار دریافت از کانال را فرخوانی کردیم. اما اتفاقی که افتاده بازم با خطای deadlock مواجه شدیم چون کانال خالی شده است و هیچ داده ای بیشتر از بافر اش ندارد.\n3.6.4 جهت های کانال # شما می توانید کانال را با جهت های مختلفی تعریف کنید که به شرح زیر است :\nدو طرفه : کانال با جهت دوطرفه مانند مثال های قبلی می باشد که شما chan int به این شکل تعریف می کنید. یک طرفه فقط ارسال : شما می توانید یک کانال ایجاد کنید که فقط عملیات ارسال chan\u0026lt;- int را انجام می دهد. یک طرفه فقط دریافت : شما می توانید یک کانال ایجاد کنید که فقط عملیات دریافت \u0026lt;-chan int را انجام می دهد. حالا این سوال پیش می آید چرا باید ما یک کانال ایجاد کنیم که عملیات فقط ارسال یا عملیات فقط دریافت را انجام می دهد. این کار وقتی مفید است که شما بخواهید برای پارامترهای ورودی یا خروجی توابع خود را محدود به یک عملیات در کانال کنید.\nکانال حالت های مختلفی دارد که شما پارامترهای ورودی و خروجی تابع استفاده کنید :\nchan کانال دوطرفه chan \u0026lt;- کانال فقط ارسال \u0026lt;-chan کانال فقط دریافت 3.6.4.1 کانال فقط ارسال # برای ایجاد کانال فقط ارسال شما می توانید به شکل زیر برای ورودی یا خروجی تابع تعریف کنید :\n1func process(ch chan\u0026lt;- int){ doSomething } زمانیکه شما تلاش کنید کانال با جهت های مختلف به پارامتر ورودی تابع فقط ارسال کانالی را پاس دهید با خطای زیر مواجه خواهید شد :\n1invalid operation: \u0026lt;-ch (receive from send-only type chan\u0026lt;- int) به مثال ساده زیر توجه کنید :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tch := make(chan int, 3) 7\tgo process(ch) 8\tfmt.Println(\u0026lt;-ch) 9} 10func process(ch chan\u0026lt;- int) { 11\tch \u0026lt;- 2 12} 1$ go run main.go 22 در کد فوق ما یک تابع به نام process ایجاد کردیم که کانال فقط ارسال به عنوان پارامتر ورودی دارد و در ادامه ما کانال ch را که دو طرفه است به این تابع پاس دادیم و مقدار دریافتی را چاپ کردیم.\n3.6.4.2 کانال فقط دریافت # برای ایجاد کانال فقط دریافت شما می توانید به شکل زیر برای ورودی یا خروجی تابع تعریف کنید :\n1func process(ch \u0026lt;-chan int){ doSomething } زمانیکه شما تلاش کنید کانال با جهت های مختلف به پارامتر ورودی تابع فقط دریافت پاس دهید با خطای زیر مواجه خواهید شد :\n1invalid operation: ch \u0026lt;- 2 (send to receive-only type \u0026lt;-chan int) به مثال ساده زیر توجه کنید :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tch := make(chan int, 3) 7\tch \u0026lt;- 2 8\tprocess(ch) 9} 10func process(ch \u0026lt;-chan int) { 11\ts := \u0026lt;-ch 12\tfmt.Println(s) 13} 1$ go run main.go 22 3.6.5 گرفتن ظرفیت یک کانال # شما می توانید همانند slice یا آرایه ظرفیت یک کانال را با استفاده از تابع ()cap ببینید.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 ch := make(chan int, 3) 7 fmt.Printf(\u0026#34;Capacity: %d\\n\u0026#34;, cap(ch)) 8} 1$ go run main.go 2Capacity: 3 توجه کنید ظرفیت کانال بافر نشده همیشه صفر است. 3.6.6 گرفتن طول یک کانال # شما با استفاده از تابع ()len می توانید طول و اندازه یک کانال را بگیرید و ببینید چه مقدار داده داخل کانال قرار دارد.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tch := make(chan int, 3) 7\tch \u0026lt;- 5 8\tfmt.Printf(\u0026#34;Len: %d\\n\u0026#34;, len(ch)) 9 10\tch \u0026lt;- 6 11\tfmt.Printf(\u0026#34;Len: %d\\n\u0026#34;, len(ch)) 12\tch \u0026lt;- 7 13\tfmt.Printf(\u0026#34;Len: %d\\n\u0026#34;, len(ch)) 14} 1$ go run main.go 2Len: 1 3Len: 2 4Len: 3 3.6.7 عملیات بستن (close) یک کانال # در زبان گو ما یک تابع Built-in به نام close داریم که می توانیم برای بستن یک کانال استفاده کنیم و زمانیکه که یک کانال بسته شود دیگر نمی توانیم داده ای را به آن کانال ارسال کنیم. کانال معمولا زمانی بسته می شود که همه داده ها ارسال شده است و داده دیگری برای ارسال نداریم و باید کانال را ببندیم.\nبه مثال زیر توجه کنید :\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;time\u0026#34; 6) 7 8func main() { 9 ch := make(chan int) 10 go sum(ch, 3) 11 ch \u0026lt;- 2 12 ch \u0026lt;- 2 13 ch \u0026lt;- 2 14 close(ch) 15 time.Sleep(time.Second * 1) 16} 17 18func sum(ch chan int, len int) { 19 sum := 0 20 for i := 0; i \u0026lt; len; i++ { 21 sum += \u0026lt;-ch 22 } 23 fmt.Printf(\u0026#34;Sum: %d\\n\u0026#34;, sum) 24} 1$ go run main.go 2Sum: 6 در کد فوق ما یک کانال بافر شده با ظرفیت ۳ ایجاد کردیم و سپس ۳ تا مقدار را به کانال ارسال کردیم و پس از آن کانال را با تابع close بستیم چون دیگر نمیخواهیم داده دیگری را ارسال کنیم.\nتوجه کنید ارسال داده برروی کانال بسته شده ممکن است برنامه شما با خطای panic مواجه و کاملا متوقف شود.\n1package main 2func main() { 3 ch := make(chan int) 4 close(ch) 5 ch \u0026lt;- 2 6} 1$ go run main.go 2panic: send on closed channel اما برای اینکه بتوانیم جلوی این panic رخ داده را بگیریم می توانیم زمانیکه داریم از کانال مقدار دریافت می کنیم assertion انجام دهیم تا متوجه بسته بودن کانال شویم :\n1package main 2import ( 3 \u0026#34;fmt\u0026#34; 4) 5func main() { 6 ch := make(chan int, 1) 7 ch \u0026lt;- 2 8 val, ok := \u0026lt;-ch 9 fmt.Printf(\u0026#34;Val: %d OK: %t\\n\u0026#34;, val, ok) 10 11 close(ch) 12 val, ok = \u0026lt;-ch 13 fmt.Printf(\u0026#34;Val: %d OK: %t\\n\u0026#34;, val, ok) 14} 1$ go run main.go 2Val: 2 OK: true 3Val: 0 OK: false اگر مقدار ok از کانال دریافتی true باشد یعنی کانال بسته نشده است و اگر مقدار false دریافت کنیم یعنی کانال بسته شده است.\n3.6.8 استفاده از حلقه for-range برروی کانال # یکی از کاربردی ترین حالت های دریافت داده از کانال استفاده از حلقه for-range است که می توانید تا زمان بسته شدن کانال مقدار دریافت کنید.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;time\u0026#34; 6) 7 8func main() { 9\tch := make(chan int, 3) 10\tch \u0026lt;- 2 11\tch \u0026lt;- 2 12\tch \u0026lt;- 2 13\tclose(ch) 14\tgo sum(ch) 15\ttime.Sleep(time.Second * 1) 16} 17 18func sum(ch chan int) { 19\tsum := 0 20\tfor val := range ch { 21\tsum += val 22\t} 23\tfmt.Printf(\u0026#34;Sum: %d\\n\u0026#34;, sum) 24} 1$ go run main.go 2Sum: 6 در کد فوق ما یک کانال بافر شده با ظرفیت ۳ ایجاد کردیم سپس ۳ تا مقدار به کانال ارسال کردیم و داخل تابع sum مقادیر را با استفاده از حلقه for-range دریافت و پس از آن چاپ کردیم.\nحالا یک سوال پیش می آید آیا ما اگر کانال را در تابع main نبندیم چه اتفاقی می افتد؟ اگر شما کانال را نبندید بطور حتمی با خطا deadlock مواجه خواهید شد. حلقه ای که داخل تابع sum قرار دادید برای دریافت داده هیچوقت متوقف نخواهد شد.\nپس سعی کنید همیشه و همه جا در جای درست بستن کانال را انجام دهید تا دچار مشکلات مختلف نشوید.\n3.6.9 کانال nil # همانطور که در اوایل این بخش گفتیم مقدار پیش فرض یک کانال nil است و زمانیکه ما یک کانال بدون تابع make تعریف می کنیم مقدار پیش فرضش nil خوهد بود.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 var a chan int 7 fmt.Print(\u0026#34;Default zero value of channel: \u0026#34;) 8 fmt.Println(a) 9} 1$ go run main.go 2Default zero value of channel: \u0026lt;nil\u0026gt; یکسری نکات در خصوص کانال nil وجود دارد :\nارسال داده به یک کانالی که nil است باعث بلاک شدن همیشگی کد شما در آن خط خواهد شد. دریافت داده به یک کانالی که nil است باعث بلاک شدن همیشگی کد شما در آن خط خواهد شد. بستن یک کانالی که nil باشد باعث panic برنامه شما خواهد شد. "},{"id":38,"href":"/chapter-3/go-select/","title":"3.7 آموزش استفاده از select","section":"فصل سوم: همزمانی (concurrency)","content":"در زبان گو select همانند switch می باشد که دارای case و default هستش اما یک فرق کلی دارد که به عملکردش برمیگردد. case های select برای عملیات ارسال و دریافت از کانال منتظر می ماند. در کل شما با استفاده از select می توانید از کانال های مختلف اطلاعات ارسال و دریافت کنید و پس از آن برروی آن اطلاعات عملیات انجام دهید.\nselect تا زمانی که یکی از case ها آماده شود بلاک می شود. اگر همزمان چندتا case برای انجام عملیات آماده شود select بصورت تصادفی یکی را انتخاب میکند تا عملیات تکمیل شود. 1select { 2case channel_send_or_receive: 3 //Dosomething 4case channel_send_or_receive: 5 //Dosomething 6default: 7 //Dosomething 8} select از بین case ها موردی را انتخاب می کند که در آن عملیات ارسال یا دریافت کانال بلاک نشده باشد و آماده اجرا باشد. اگر چند مورد از case ها آماده باشد یکی از آنها بصورت تصادفی انتخاب می شود تا فرآیند را تکمیل کند.\nبزارید یک مثال ساده بزنیم :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 ch1 := make(chan string) 7 ch2 := make(chan string) 8 9 go goOne(ch1) 10 go goTwo(ch2) 11 12 select { 13 case msg1 := \u0026lt;-ch1: 14 fmt.Println(msg1) 15 case msg2 := \u0026lt;-ch2: 16 fmt.Println(msg2) 17 } 18} 19 20func goOne(ch chan string) { 21 ch \u0026lt;- \u0026#34;From goOne goroutine\u0026#34; 22} 23 24func goTwo(ch chan string) { 25 ch \u0026lt;- \u0026#34;From goTwo goroutine\u0026#34; 26} 1$ go run main.go 2From goOne goroutine در کد فوق ما ۲ تا کانال تعریف کردیم و کانال ها را به توابع goOne و goTwo پاس دادیم سپس داخل تابع به هرکدام از کانال مقداری ارسال شد. حالا در ادامه بدنه main یک select قرار دادیم که هر یک از case ها منتظر دریافت اطلاعات از کانال مشخص شده‌اش است.\nبلافاصله پس از‌اینکه یکی از کانال ها آماده ارسال داده شود، کیس آن اجرا می شود. اگر هر دوی کانال ها همزمان آماده ارسال داده شوند، به‌صورت تصادفی یکی از case ها انتخاب می شود تا عملیات را تکمیل کند.\nکه در خروجی مقداری که از ch1 آمده را نمایش می دهد. اما اگر بخواهیم خروجی هر دو کانال را ببینیم می توانیم از حلقه استفاده کنیم. به مثال زیر توجه کنید :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 ch1 := make(chan string) 7 ch2 := make(chan string) 8 go goOne(ch1) 9 go goTwo(ch2) 10 for i := 0; i \u0026lt; 2; i++ { 11 select { 12 case msg1 := \u0026lt;-ch1: 13 fmt.Println(msg1) 14 case msg2 := \u0026lt;-ch2: 15 fmt.Println(msg2) 16 } 17 } 18} 19 20func goOne(ch chan string) { 21 ch \u0026lt;- \u0026#34;From goOne goroutine\u0026#34; 22} 23 24func goTwo(ch chan string) { 25 ch \u0026lt;- \u0026#34;From goTwo goroutine\u0026#34; 26} 1$ go run main.go 2From goOne goroutine 3From goTwo goroutine در کد فوق ما select را داخل یک حلقه for قرار دادیم و گفتیم اگر مقدار i کوچکتر از ۲ بود ++i شود. که در هر دو تایم مقدار دریافتی از کانال ها را توانستیم به عنوان خروجی چاپ کنیم.\nهمانطور که قبلا گفتیم اگر شما داخل select یک case را بزارید که هیچ اطلاعات از کانال دریافت نکند ممکن است برنامه شما کاملا بلاک شود و با خطای deadlock مواجه شوید.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 ch1 := make(chan string) 7 select { 8 case msg := \u0026lt;-ch1: 9 fmt.Println(msg) 10 } 11} 1$ go run main.go 2fatal error: all goroutines are asleep - deadlock! اتفاقی که در کد فوق رخ داد ما یک کانال ایجاد کردیم و سپس داخل select یک case قرار دادیم که منتظر دریافت داده از کانال می باشد. اما چون هیچ داده‌ای به کانال ارسال نمی شود برنامه بطور کلی در همان تیکه از کد بلاک می شود و در نهایت شما با این خطا مواجه خواهید شد.\n3.7.1 نحوه کنترل عملیات های کانال با select # در بالا در خصوص select توضیح دادیم که چه کاربردی هایی دارد اما بذارید توضیحات را تکمیل کنیم. وقتی شما قصد دارید از گوروتین و کانال استفاده کنید در اینجا select نقش خیلی پررنگی در کنترل عملیات کانال ها دارد. اینجاست که بحث همزمانی در زبان گو خیلی زیبا می شود. select می تواند بطور همزمان داده را از کانال دریافت کند و برای اجرا سایر عملیات آماده کند. بنابراین select همراه با کانال و گوروتین خیلی ابزار قدرتمندی برای کنترل و مدیریت همگام سازی و همزمانی می باشد.\n3.7.1.1 عملیات ارسال با select # در زیر یک مثالی زدیم که با استفاده از select داده ای را به کانال میریزیم و سپس آن داده را از کانال دیگر دریافت می کنیم :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 ch1 := make(chan string) 7 ch2 := make(chan string) 8 go goOne(ch1) 9 go goTwo(ch2) 10 select { 11 12 case msg1 := \u0026lt;-ch1: 13 fmt.Println(msg1) 14 case ch2 \u0026lt;- \u0026#34;To goTwo goroutine\u0026#34;: 15 } 16} 17 18func goOne(ch chan string) { 19 ch \u0026lt;- \u0026#34;From goOne goroutine\u0026#34; 20} 21 22func goTwo(ch chan string) { 23 msg := \u0026lt;-ch 24 fmt.Println(msg) 25} 1$ go run main.go 2To goTwo goroutine در کد فوق ما با استفاده از یکی از case های select داده‌ای را داخل کانال ریختیم و آن داده را داخل گوروتین تابع goTwo دریافت کردیم و پس آن مقدار دریافتی را چاپ کردیم.\n3.7.2 استفاده از default در select # در زبان گو switch و select می توانند یک default داشته باشند. در اینجا default مربوط select رفتارش همانند default داخل switch می باشد. حالا اگر هر یک از case ها عملیات دریافت یا ارسالی برای اجرا نداشته باشند می توانید با استفاده از default از بلاک شدن برای همیشه جلوگیری کنید. و خیلی مهمه که بدانید وقتی دارید داخل select از default استفاده می کنید select از نوع non-blocking می شود. اگر شما داخل select از default استفاده نکنید ممکن است آن بخش کد شما مسدود شود تا زمانیکه یکی از case ها از کانال داده ای را دریافت کند تا ادامه عملیات صورت گیرد.\nبه مثال زیر توجه کنید :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 ch1 := make(chan string) 7 select { 8 case msg := \u0026lt;-ch1: 9 fmt.Println(msg) 10 default: 11 fmt.Println(\u0026#34;Default statement executed\u0026#34;) 12 } 13} 1$ go run main.go 2Default statement executed در کد فوق ما یک کانال ایجاد کردیم و دریافت داده از کانال را داخل یکی از case های select قرار دادیم و پس از آن default را قرار دادیم که از مسدود شدن برنامه جلوگیری کند.\n3.7.3 مسدود سازی select با استفاده از timeout # شما می توانید یک select را با استفاده از timeout بطور موقت تا یک بازه زمانی مسدود کنید. که اینکار توسط تابع After داخل پکیج time صورت میگیرد.\n1func After(d Duration) \u0026lt;-chan Time تابع After یک مدت زمان میگیرد و سپس به عنوان خروجی یک کانال فقط دریافت از نوع Time برمیگرداند.\nبه مثال زیر توجه کنید :\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;time\u0026#34; 6) 7 8func main() { 9\tch1 := make(chan string) 10\tgo goOne(ch1) 11 12\tselect { 13\tcase msg := \u0026lt;-ch1: 14\tfmt.Println(msg) 15\tcase \u0026lt;-time.After(time.Second * 1): 16\tfmt.Println(\u0026#34;Timeout\u0026#34;) 17\t} 18} 19 20func goOne(ch chan string) { 21\ttime.Sleep(time.Second * 2) 22\tch \u0026lt;- \u0026#34;From goOne goroutine\u0026#34; 23} 1$ go run main.go 2Timeout در کد فوق ما در یکی از case های select تابع After را به عنوان کانال دریافت کننده قرار دادیم و سپس مقدار ۱ ثانیه به تابع After پاس دادیم و پس از ۱ ثانیه select از مسدودی خارج شد.\n3.7.4 select خالی # یک select خالی و بدون case می تواند برنامه شما را به‌طور کلی بلاک کند و باعث بروز خطای deadlock شود. اگر select خالی داخل یک گوروتین دیگری قرار گیرد آن گوروتین بطور کلی برای همیشه بلاک خواهد شد اما اگر داخل تابع main قرار دهید باعث بروز deadlock خواهد شد.\n1package main 2 3func main() { 4 select {} 5} 1$ go run main.go 2fatal error: all goroutines are asleep - deadlock! 3.7.5 استفاده از select در حلقه بینهایت # ما می توانیم select را داخل یک حلقه بینهایت قرار دهیم تا برای همیشه از case ها چندتا داده را بواسطه کانال دریافت کنیم و عملیاتی را انجام دهیم. همچنین اگر قصد داریم که آنقدر کیس ها چک شوند تا یکی از کانال ها برای ارسال و یا دریافت داده آماده باشد، می توانیم از این روش استفاده کنیم و در نهایت با return کردن از حلقه بینهایت خارج شویم.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;time\u0026#34; 6) 7 8func main() { 9\tnews := make(chan string) 10\tgo newsFeed(news) 11 12\tprintAllNews(news) 13} 14 15func printAllNews(news chan string) { 16\tfor { 17\tselect { 18\tcase n := \u0026lt;-news: 19\tfmt.Println(n) 20\tcase \u0026lt;-time.After(time.Second * 1): 21\tfmt.Println(\u0026#34;Timeout: News feed finished\u0026#34;) 22\treturn 23\t} 24\t} 25} 26 27func newsFeed(ch chan string) { 28\tfor i := 0; i \u0026lt; 2; i++ { 29\ttime.Sleep(time.Millisecond * 400) 30\tch \u0026lt;- fmt.Sprintf(\u0026#34;News: %d\u0026#34;, i+1) 31\t} 32} 1$ go run main.go 2News: 1 3News: 2 4Timeout: News feed finished در کد فوق ما یک کانال بافر نشده با نام news ایجاد کردیم و این کانال را داخل گوروتین newsFeed و تابع printAllNews قرار داده‌ایم. تابع newsFeed یک مقداری را به کانال ارسال می کند. و ما داخل تابع printAllNews بواسطه حلقه بینهایت و select دریافت می کنیم و یکی از case های select عملیات timeout را دارد که بعد ۱ ثانیه حلقه را کاملا متوقف کند.\n3.7.6 select با یک کانال nil # معمولا اگر یک کانال nil را برای ارسال یا دریافت داخل case قرار دهید برنامه شما همیشه بلاک می شود. اگر شما داخل یکی از case ها بیاید پس از انجام عملیات مقدار یک کانال را nil بزارید case ای که مقدار داخل کانال را دریافت می کند غیرفعال می شود و به هیچ عنوان دیگر قابل استفاده نخواهد بود. و توسط select آن case کاملا نادیده گرفته خواهد شد و select منتظر دریافت و ارسال داده از سایر case ها خواهد بود.\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;time\u0026#34; 6) 7 8func main() { 9 news := make(chan string) 10 go newsFeed(news) 11 printAllNews(news) 12} 13 14func printAllNews(news chan string) { 15 for { 16 select { 17 case n := \u0026lt;-news: 18 fmt.Println(n) 19 news = nil 20 case \u0026lt;-time.After(time.Second * 1): 21 fmt.Println(\u0026#34;Timeout: News feed finished\u0026#34;) 22 return 23 } 24 } 25} 26 27func newsFeed(ch chan string) { 28 for i := 0; i \u0026lt; 2; i++ { 29 time.Sleep(time.Millisecond * 400) 30 ch \u0026lt;- fmt.Sprintf(\u0026#34;News: %d\u0026#34;, i+1) 31 } 32} 1$ go run main.go 2News: 1 3Timeout: News feed finished در کد فوق ما داخل case n := \u0026lt;-news پس از اینکه مقدار دریافتی را چاپ کردیم اومدیم مقدار کانال news را برابر nil قرار دادیم. حالا اگر داده‌ای به اون کانال ارسال شود دیگر نمی توانیم دریافت کنیم و select آن case را بطور کلی نادیده میگیرد.\n1case n := \u0026lt;-news: 2 fmt.Println(n) 3 news = nil 3.7.7 استفاده از break در select # شما می توانید break را داخل هر یک از case های select استفاده کنید.\n1import \u0026#34;fmt\u0026#34; 2 3func main() { 4\tch := make(chan string, 1) 5\tch \u0026lt;- \u0026#34;Before break\u0026#34; 6 7\tselect { 8\tcase msg := \u0026lt;-ch: 9\tfmt.Println(msg) 10\tbreak 11\tfmt.Println(\u0026#34;After break\u0026#34;) 12\tdefault: 13\tfmt.Println(\u0026#34;Default case\u0026#34;) 14\t} 15} 1$ go run main.go 2Before break در کد فوق ما با استفاده از break توانستیم select را کاملا متوقف کنیم و برنامه اتمام شود و اگر دقت کرده باشید بعد از break کلمات After break چاپ نشده.\n1fmt.Println(\u0026#34;After break\u0026#34;) "},{"id":39,"href":"/chapter-3/go-context/","title":"3.8 پکیج context","section":"فصل سوم: همزمانی (concurrency)","content":" پکیج context یک پکیج built-in است که یکی از پرکاربرد ترین پکیج های زبان گو می باشد. کار اصلی این پکیج فراهم کردن بستری است که بتوان به داده های مشترک دسترسی داشت و یا بتوان آنها را به اشتراک گذاشت و مدیریت کرد. حتی اگر شما نخواسته باشید سمت این پکیج بروید به مرور زمان که جلوتر می روید با این پکیج رو به رو خواهید شد و مجبور خواهید بود این پکیج را یاد بگیرید.\nاین پکیج چندان بزرگ نیست و شاید بتوانید توابع و مفاهیم آن را خیلی زود یاد بگیرید اما حتما یک روزی این پکیج تبدیل به یکی از بنیادی ترین قسمت های کدتان خواهد شد.\nدر این بخش از کتاب سعی خواهد شد مفاهیم context به صورت ساده و قابل درک، بیان شود.\n3.8.1 context چیست؟ # در واقع context مانند یک درخت می باشد که کلی شاخه دارد و هر شاخه به شاخه های ریزتری تقسیم شده و در نهایت به برگ ها و میوه های درخت منتهی می شوند. حال شما می توانید در هر ناحیه شاخه والد را قطع کنید تا شاخه های فرزند از بین برود. در زبان گو context یک اینترفیس است که یکسری متد دارد که هریک از متدها می تواند عملیاتی را انجام دهد و این امکان را فراهم می کند هر وقت یک درخواست از سمت کلاینت به سرور می آید این درخواست می تواند در لایه های مختلف منتهی شود و داخل context می تواند یکسری key/value های مهم باشد که شما بتوانید در هر لایه، به آنها دسترسی داشته باشید و همچنین در صورت لزوم می توانید سیگنال cancel بفرستید که درخواستی که تا هرجا رفته است کنسل شود.\nدر ادامه با طرح یک مثال ساده به درک بهتر این موضوع کمک می کنیم :\nفرض کنید یک سرور http راه اندازی کردید (در فصل ۵ آشنا خواهید شد) که یکسری آدرس API دارد که کلاینت می تواند با استفاده از این آدرس ها با سرور شما ارتباط برقرار کند و عملیات مشخصی را انجام دهد. حال وقتی کلاینت درخواست می دهد. درخواست تا زمانیکه کامل شود و خروجی به کاربر نمایش داده شود می توانید این درخواست را بواسطه context در لایه های مختلف پروژه خود منتهی کنید و یکسری عملیات یا اطلاعات را در هر لایه از context بگیرید. اگر به دیاگرام فوق نگاه کنید اگر کلاینت درخواستش را لغو کند و درخواست کاربر به واسط context تا لایه Manager رفته باشد می تواند این درخواست در همان لایه متوقف شود و عملیات تکمیل نشود.\nبرای درک بهتر مثال فوق بهتره فایل صوتی زیر را گوش دهید تا بهتر بتوانید درک کنید :\nدانلود فایل صوت 3.8.1.1 کاربردهای context # لغو یک درخواستی که منتهی شده به لایه های مختلف پروژه بواسطه تابع cancel در پکیج context انتقال داده های حساس به لایه های مختلف بواسطه تابع WithValue در پکیج context گذاشتن timeout برروی context جهت لغو درخواستی که خیلی باعث منتظر ماندن می شود بواسطه تابع WithTimeout در پکیج context 3.8.1.2 معرفی اینترفیس context # بدنه اصلی یک context از اینترفیس تشکیل شده که یکسری متدها برای مدیریت یک درخواست برروی لایه های مختلف را دارد.\n1type Context interface { 2 //It retures a channel when a context is cancelled, timesout (either when deadline is reached or timeout time has finished) 3 Done() \u0026lt;-chan struct{} 4 5 //Err will tell why this context was cancelled. A context is cancelled in three scenarios. 6 // 1. With explicit cancellation signal 7 // 2. Timeout is reached 8 // 3. Deadline is reached 9 Err() error 10 11 //Used for handling deallines and timeouts 12 Deadline() (deadline time.Time, ok bool) 13 14 //Used for passing request scope values 15 Value(key interface{}) interface{} 16} متد Done : بواسطه این متد که یک کانال فقط دریافت است شما می توانید سیگنال توقف درخواست را دریافت کنید و خطا برگردانید. متد Err : داخل این متد اینترفیس خطا وجود دارد که خطاهای مربوط به context را می توانید دریافت و مدیریت کنید. متد Deadline : با استفاده از این متد می توانید context هایی که از نوع Deadline هستند را مدیریت کنید. متد Value : با استفاده از این می توانید مقادیری که بصورت key/value داخل context ذخیره شده را دریافت کنید که بصورت اینترفیس یک key میگیرد و به صورت اینترفیس مقدار داخل key را برمیگرداند. 3.8.2 ایجاد یک context # شما با استفاده از ۲ تابع داخل پکیج context می توانید اولین context خام را ایجاد کنید و در واقع این context ایجاد شده می تواند والد تمامی context هایی که در لایه مختلف ایجاد کردید باشد.\nبرای ایجاد context گفتیم ۲ تابع وجود دارد که به شرح زیر می باشد :\ncontext.Background() : # داخل پکیج context ما یک تابع داریم به نام Background که اولین context خام و والد را میسازد و به شما یک اینترفیس از نوع Context می دهد.\nاین context ایجاد شده هیچ مقداری داخلش ندارد. هیچ وقت نمی تواند کنسل شود. و هیچ deadline ندارد. در هر صورت بدانید ریشه اصلی context شما با این تابع ایجاد می شود و نقطه شروع انتقال یک درخواست بین لایه هایتان با این context والد خواهد بود.\n1func Background() Context context.ToDo() : # داخل پکیج context ما یک تابع داریم به نام ToDo که یک context خالی ایجاد می کند و هدف از این context ایجاد شده با ToDo این است هنوز برایمان مشخص نیست چکار میخوایم انجام بدیم با context می توانیم از این تابع استفاده کنیم. و معمولا برای تست ها و اعتبارسنجی و آنالیز کد خیلی کاربردی هست.\nو دقت کنید در پایه اصلی پروژه اتون بهتره از Background همیشه استفاده کنید.\n1func TODO() Context 3.8.3 درخت Context # در واقع context خام یا ریشه که بواسطه تابع Background یا ToDo ایجاد می شود همانند یک درخت است که قرار است این درخت به شاخه های ریزتری تقسیم شود و هر یک از شاخه ها عملیات مختلفی کنترل شود و به شاخه های دیگر منتقل شود.\n3.8.3.1 ایجاد یک فرزند برای context # شما خیلی ساده مانند کد زیر می توانید یک فرزند برای درخت خود ایجاد کنید :\n1rootCtx := context.Background() 2childCtx := context.WithValue(rootCtx, \u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;) در کد فوق ما یک rootCtx ایجاد کردیم که همان درخت است و سپس اومدیم با استفاده از تابع WithValue یک شاخه ایجاد کردیم که داخل این شاخه یک key/value قرار دارد. که این key/value در لایه های دیگر که منتقل می شود قرار دارد.\n3.8.3.2 ایجاد دو فرزند برای context # 1rootCtx := context.Background() 2childCtx := context.WithValue(rootCtx, \u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;) 3childOfChildCtx, cancelFunc := context.WithCancel(childCtx) در کد فوق :\nrootCtx درخت است childCtx فرزند اول است که با استفاده از WithValue ایجاد شده و یک مقدار key/value را نگه داری می کند. childOfChildCtx برای فرزند اول context ما یک فرزند دیگری ایجاد کردیم با استفاده از تابع WithCancel که این تابع به شما یک context و یک تابع از نوع cancelFunc برمیگرداند. 3.8.3.3 درخت چند سطحی # 1rootCtx := context.Background() 2childCtx1 := context.WithValue(rootCtx, \u0026#34;key1\u0026#34;, \u0026#34;value1\u0026#34;) 3childCtx2, cancelFunc := context.WithCancel(childCtx1) 4childCtx3 := context.WithValue(rootCtx, \u0026#34;user_id\u0026#34;, \u0026#34;some_user_id\u0026#34;) در کد فوق :\nrootCtx درخت است childCtx1 فرزند اول است که با استفاده از WithValue ایجاد شده و یک مقدار key/value را نگه داری می کند. childCtx2 برای فرزند اول context ما یک فرزند دیگری ایجاد کردیم با استفاده از تابع WithCancel که این تابع به شما یک context و یک تابع از نوع cancelFunc برمیگرداند. childCtx3 با استفاده از WithValue از rootCtx که درخت است تشکیل شده حالا اگر ما برای childCtx1 بیایم یک فرزند دیگر با نام childCtx4 اضافه کنیم بصورت زیر خواهد شد :\n1childCtx4 := context.WithValue(childCtx1, \u0026#34;current_time\u0026#34;, \u0026#34;some_time) 3.8.4 تابع context.WithValue # همانطور که گفتیم شما با استفاده از تابع WithValue می توانید مقادیری را بصورت key/value به context اضافه کنید و سپس این مقادیر را با استفاده از context به لایه های مختلف منتقل کنید.\n1withValue(parent Context, key, val interface{}) (ctx Context) دقت کنید شما می توانید بواسطه context.WithValue مقادیر خیلی مهم و حساس نظیر توکن ها و \u0026hellip; را به لایه های مختلف خود منتقل کنید و این مورد خیلی قابل اهمیت است با استفاده از context انجام دهید. 1// Root Context 2ctxRoot := context.Background() 3 4// Below ctxChild has acess to only one pair {\u0026#34;a\u0026#34;:\u0026#34;x\u0026#34;} 5ctxChild := context.WithValue(ctxRoot, \u0026#34;a\u0026#34;, \u0026#34;x\u0026#34;) 6 7// Below ctxChildofChild has access to both pairs {\u0026#34;a\u0026#34;:\u0026#34;x\u0026#34;, \u0026#34;b\u0026#34;:\u0026#34;y\u0026#34;} as it is derived from ctxChild 8ctxChildofChild := context.WithValue(ctxChild, \u0026#34;b\u0026#34;, \u0026#34;y\u0026#34;) در بالا ما یک ctxRoot ایجاد کردیم و سپس یک فرزند با استفاده از تابع WithValue ایجاد کردیم که یک مقدار از نوع key/value با نام a را داخل context فرزند قرار دادیم. حالا برای context فرزند مجدد با استفاده از WithValue یک فرزند دیگری ایجاد کردیم که یک مقدار دیگر از نوع key/value با نام b قرار دادیم حالا اگر دقت کنید ctxChildofChild دارای ۲ مقدار a و b هستش.\nبزارید یک مثال ساده بزنیم :\n1package main 2 3import ( 4\t\u0026#34;context\u0026#34; 5\t\u0026#34;fmt\u0026#34; 6) 7 8func main() { 9\tctx := context.WithValue(context.Background(), \u0026#34;language\u0026#34;, \u0026#34;Go\u0026#34;) 10 11\tfmt.Println(manager(ctx, \u0026#34;language\u0026#34;)) 12} 13 14func manager(ctx context.Context, key string) string { 15\tif v := ctx.Value(key); v != nil { 16\treturn v.(string) 17\t} 18\treturn \u0026#34;not found value\u0026#34; 19} 1$ go run main.go 2Go در کد فوق ما یک context ایجاد کردیم و داخلش با استفاده از WithValue مقدار key/value قرار دادیم و سپس این context را تابع manager پاس دادیم و داخل تابع manager ما با استفاده از متد Value که داخل اینترفیس ctx هست مقدار کلید language را گرفتیم.\nنکته کاربردی و مهم همیشه سعی کنید context را به عنوان اولین پارامتر برای توابع تعریف کنید. و بهتر است برای نام پارامتر ctx یا c بزارید. 3.8.5 تابع context.WithCancel # زمانیکه شما با استفاده از تابع WithCancel یک context فرزند ایجاد می کنید ۲ تا خروجی به شما می دهد اولی context و دومی تابع cancel می باشد. که شما می توانید تابع cancel را برای لغو درخواستی که از سمت کلاینت یا لایه های بالاتر اومده را انجام دهید.\n1type CancelFunc func() 2 3func WithCancel(parent Context) (ctx Context, cancel CancelFunc) حالا با استفاده از مثال زیر میتوانید بحث لغو کردن را بهتر درک کنید :\n1package main 2 3import ( 4 \u0026#34;context\u0026#34; 5 \u0026#34;fmt\u0026#34; 6 \u0026#34;time\u0026#34; 7) 8 9func main() { 10 ctx := context.Background() 11 cancelCtx, cancelFunc := context.WithCancel(ctx) 12 go task(cancelCtx) 13 time.Sleep(time.Second * 3) 14 cancelFunc() 15 time.Sleep(time.Second * 1) 16} 17 18func task(ctx context.Context) { 19 i := 1 20 for { 21 select { 22 case \u0026lt;-ctx.Done(): 23 fmt.Println(\u0026#34;Gracefully exit\u0026#34;) 24 fmt.Println(ctx.Err()) 25 return 26 default: 27 fmt.Println(i) 28 time.Sleep(time.Second * 1) 29 i++ 30 } 31 } 32} 1$ go run main.go 21 32 43 5Gracefully exit 6context canceled در کد فوق ما یک context فرزند با استفاده از WithCancel ایجاد کردیم که به عنوان خروجی cancelCtx و cancelFunc را داد. سپس cancelCtx را به تابع task منتقل کردیم تا عملیاتی را انجام دهد. حال در ادامه کد تابع main ما یک Sleep در حد ۳ ثانیه گذاشتیم و گفتیم تابع cancelFunc اجرا شود. اگر دقت کنید پس ۳ ثانیه سیگنال لغو به تابع task ارسال شده و خطای Gracefully exit را چاپ کردیم و پس از آن خطای context چاپ کردیم.\nنکته کاربردی و مهم همیشه سعی کنید تابع cancelFunc را پس از اینکه context فرزند را با WithCancel ایجاد کردید داخل defer قرار دهید.\n1ctx := context.Background() 2cancelCtx, cancelFunc := context.WithCancel(ctx) 3defer cancelFunc() 3.8.6 تابع context.WithTimeout # تابع WithTimeout یکی از کاربردی ترین context ها را برای ما ایجاد میکند و باعث می شود جلوی طول کشیدن یک درخواست خارجی یا عملیاتی را بگیرد و درخواست را لغو کند. این تابع همانند تابع WithCancel به شما تابع cancelFunc را می دهد و در عوض از شما یک مدت زمان را میگیرد.\n1func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) بزارید یک مثال ساده بزنیم :\n1package main 2 3import ( 4 \u0026#34;context\u0026#34; 5 \u0026#34;fmt\u0026#34; 6 \u0026#34;time\u0026#34; 7) 8 9func main() { 10 ctx := context.Background() 11 cancelCtx, cancel := context.WithTimeout(ctx, time.Second*3) 12 defer cancel() 13 go task1(cancelCtx) 14 time.Sleep(time.Second * 4) 15} 16 17func task1(ctx context.Context) { 18 i := 1 19 for { 20 select { 21 case \u0026lt;-ctx.Done(): 22 fmt.Println(\u0026#34;Gracefully exit\u0026#34;) 23 fmt.Println(ctx.Err()) 24 return 25 default: 26 fmt.Println(i) 27 time.Sleep(time.Second * 1) 28 i++ 29 } 30 } 31} 1$ go run main.go 21 32 43 5Gracefully exit 6context deadline exceeded در کد فوق ما یک context فرزند با استفاده از تابع WithTimeout ایجاد کردیم و مدت زمان ۳ ثانیه به این تابع پاس دادیم و پس از آن context فرزند به همراه تابع cancelFunc دریافت کردیم. حالا تابع cancel را داخل defer قرار دادیم و cancelCtx را به تابع task1 که داخل گوروتین است پاس داده ایم سپس و یک Sleep به مدت ۴ ثانیه گذاشتیم تا، تابع main کارش تمام نشود. حال پس از اینکه ۳ ثانیه گذشت داخل select سیگنال cancel را دریافت کردیم و خطای context deadline exceeded که نشان دهنده اتمام شدن مدت زمان هست را چاپ کرده ایم. همانطور که متوجه شدید درخواست کلی ما لغو شده.\n3.8.7 تابع context.WithDeadline # تابع WithDeadline تا حدی شبیه به WithTimeout است اما با این تفاوت که پارامتر زمانی که میگیرد از نوع time.Time است و مدت زمانی که میگیرد براساس تایم هست مثلا شما میگید ۵ ثانیه بعد از زمان الان درخواست را لغو کند در صورتیکه withTimeout مدت زمان میگیرد که درخواست ۵ ثانیه مهلت دارد کارش را انجام دهد.\n1func WithDeadline(parent Context, d time.Time) (Context, CancelFunc) به مثال زیر توجه کنید :\n1package main 2 3import ( 4 \u0026#34;context\u0026#34; 5 \u0026#34;fmt\u0026#34; 6 \u0026#34;time\u0026#34; 7) 8 9func main() { 10 ctx := context.Background() 11 cancelCtx, cancel := context.WithDeadline(ctx, time.Now().Add(time.Second*5)) 12 defer cancel() 13 go task(cancelCtx) 14 time.Sleep(time.Second * 6) 15} 16 17func task(ctx context.Context) { 18 i := 1 19 for { 20 select { 21 case \u0026lt;-ctx.Done(): 22 fmt.Println(\u0026#34;Gracefully exit\u0026#34;) 23 fmt.Println(ctx.Err()) 24 return 25 default: 26 fmt.Println(i) 27 time.Sleep(time.Second * 1) 28 i++ 29 } 30 } 31} 1$ go run main.go 21 32 43 54 65 7Gracefully exit 8context deadline exceeded در کد فوق یک context فرزند با استفاده از تابع WithDeadline ایجاد کردیم و سپس با توجه به زمان فعلی مدت زمان ۵ ثانیه بعد را درنظر گرفتیم که مثلا اگر الان ساعت است 10:45:30 درخواست را در 10:45:35 لغو کند.\n3.8.8 نکات کاربردی # هیچوقت سعی نکنید اینترفیس context را داخل یک ساختار ذخیره کنید اما می توانید embed کنید. همیشه context باید بین لایه‌های خود منتقل کنید تا بتوانید کنترل بهتری برروی درخواست ها داشته باشید. همیشه سعی کنید context را به عنوان اولین پارامتر توابع قرار دهید. نام context به عنوان پارامتر توابع بهتر است ctx یا c باشد. اگر هنوز مطمئن نیستید که با context چکاری میخواهید انجام دهید بهتر است context را با context.ToDo ایجاد کنید. توجه کنید فقط تابعی که context والد را ایجاد کرده می تواند درخواست را لغو کند پس سعی نکنید تابع cancelFunc را به توابع زیرین پاس دهید. "},{"id":40,"href":"/chapter-3/go-concurrency-teqniques/","title":"3.9 تکنیک های همزمانی","section":"فصل سوم: همزمانی (concurrency)","content":" 3.9.1 ارسال سیگنال انجام شدن با کانال ساختار # شما می توانید با استفاده از کانال struct سیگنالی برای تکمیل شدن انجام یک کار را بفرستید.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;time\u0026#34; 6) 7 8func task1(done chan struct{}) { 9\t// Do some work here 10\tfmt.Println(\u0026#34;doing task 1\u0026#34;) 11 12\ttime.Sleep(2 * time.Second) 13 14\tfmt.Println(\u0026#34;task 1 has been completed\u0026#34;) 15\tdone \u0026lt;- struct{}{} 16} 17 18func task2(done \u0026lt;-chan struct{}) { 19\tselect { 20\tcase \u0026lt;-done: 21\t// Do some work here 22\tfmt.Println(\u0026#34;doing task 2\u0026#34;) 23\ttime.Sleep(2 * time.Second) 24\tfmt.Println(\u0026#34;task 2 has been completed\u0026#34;) 25\t} 26} 27 28func main() { 29\tdone := make(chan struct{}) 30 31\tgo task1(done) 32\tgo task2(done) 33 34\ttime.Sleep(5 * time.Second) 35\tfmt.Println(\u0026#34;all tasks has been completed\u0026#34;) 36} 1$ go run main.go 2doing task 1 3task 1 has been completed 4doing task 2 5task 2 has been completed 6all tasks has been completed در کد فوق ما دو تابع به نام task1 و task2 داریم که داخل گوروتین هستند و به عنوان پارامتر ورودی یک کانال ساختار خالی میگیرد حال کانال ساختار را به هر دو تابع پاس دادیم در ابتدا task1 فرآیند خود را انجام می دهد و سپس سیگنال انجام شدن را می فرستد و در ادامه تابع task2 سیگنال را دریافت می کند و فرآیندهای خود را انجام می دهد.\nدر زبان گو شما وقتی یک struct کاملا خالی و بدون فیلد میسازید هیچ تخصیص حافظه‌ای برایش صورت نمیگیرد. 3.9.2 بررسی یک سرویس یا فرآیند با heartbeat # شما با استفاده از همزمانی می توانید یک heartbeat پیاده سازی کنید تا یک سرویس یا فرآیند را بطور مداوم طی بازه زمانی مشخصی زیر نظر داشته باشد و از وضعیت آن سرویس یا فرآیند به شما اطلاع دهد.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;time\u0026#34; 6) 7 8func heartbeat(interval time.Duration, c chan\u0026lt;- struct{}) { 9 ticker := time.NewTicker(interval) 10\tfor { 11\tselect { 12\tcase \u0026lt;-ticker.C: 13\tc \u0026lt;- struct{}{} 14\t} 15\t} 16} 17 18func task() { 19\t// Do some work here 20\tfmt.Println(\u0026#34;Task running...\u0026#34;) 21} 22 23func main() { 24\tc := make(chan struct{}) 25\tgo heartbeat(1*time.Second, c) 26 27\tfor { 28\tselect { 29\tcase \u0026lt;-c: 30\ttask() 31\t} 32\t} 33} 1$ go run main.go 2Task running... 3Task running... 4Task running... 5Task running... در کد فوق ما یک تابع به نام heartbeat ایجاد کردیم که طی مدت زمانی یک سیگنال می فرستد تا تابع task اجرا شود که وضعیت فرآیند یا سرویس را گزارش دهد. ما مدت زمان را ۱ ثانیه گذاشتیم و یک کانال ساختار ایجاد کردیم و به تابع heartbeat که داخل یک گوروتین هست پاس دادیم سپس هر ۱ ثانیه از طریق کانال c ما سیگنال اجرای task برای بررسی وضعیت سرویس یا فرآیند را دریافت میکنیم.\n3.9.3 ارسال درخواست‌های تکراری به سرور یا سرویسی # فرض کنید شما نیاز دارید به یک سرور یا سرویسی چندین درخواست تکراری را بصورت موازی بفرستید که به اینکار replicated requests می گویند.\nبه مثال زیر توجه کنید :\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;net/http\u0026#34; 6) 7 8func makeRequest(url string, c chan\u0026lt;- *http.Response) { 9 resp, err := http.Get(url) 10 if err != nil { 11 c \u0026lt;- nil 12 } else { 13 c \u0026lt;- resp 14 } 15} 16 17func main() { 18 urls := []string{\u0026#34;http://example.com\u0026#34;, \u0026#34;http://example.org\u0026#34;, \u0026#34;http://example.net\u0026#34;} 19 20 c := make(chan *http.Response) 21 defer close(c) 22 for _, url := range urls { 23 go makeRequest(url, c) 24 } 25 26 for i := 0; i \u0026lt; len(urls); i++ { 27 resp := \u0026lt;-c 28 if resp == nil { 29 fmt.Println(\u0026#34;Error making request\u0026#34;) 30 } else { 31 fmt.Println(resp.Status) 32 } 33 } 34} 1$ go run main.go 2200 OK 3200 OK 4200 OK در کد فوق ما یک تابع makeRequest داریم که ۲ تا پارامتر ورودی دارد اولین پارامتر url میگیرد و دومین پارامتر یک کانال فقط ارسال از نوع http.Response* میگیرد. سپس یک ریکوئست با متد GET ایجاد میکند و خروجی را داخل کانال میفرستد. در تابع main ما یک لیست url داریم که قرار است بصورت موازی به این آدرس ها درخواست بفرستیم و خروجی را دریافت کنیم در اینجا یک کانال از نوع http.Response* ایجاد کردیم و سپس یک حلقه for-range قرار دادیم و به ازای هر یک از url ها تابع makeRequest را فراخوانی کرده‌ایم و سپس داخل گوروتین قرار داده‌ایم، در نهایت یک حلقه for-i داریم که به تعداد url ها شمارش میکند و از طریق کانال ریسپانس را دریافت می کند.\n3.9.4 بازیابی سلامتی یک گوروتین # در برنامه نویسی همزمانی خیلی مهم است شما به سلامتی یک گوروتین رسیدگی کنید که اگر گوروتین قادر به انجام کاری نیست مجدد بتوانید سلامتی گوروتین را بازیابی کنید. در زبان گو شما می توانید با استفاده از پکیج context گوروتین هایی که وضعیت سالمی ندارد را با راه اندازی مجدد سلامتی آنها را بازیابی کنید.\n1package main 2 3import ( 4\t\u0026#34;context\u0026#34; 5\t\u0026#34;fmt\u0026#34; 6\t\u0026#34;time\u0026#34; 7) 8 9func unhealthyGoroutine(ctx context.Context) { 10\tfor { 11\tselect { 12\tcase \u0026lt;-ctx.Done(): 13\tfmt.Println(\u0026#34;Goroutine is unhealthy, exiting\u0026#34;) 14\treturn 15\tdefault: 16\t// Do some work here 17\tfmt.Println(\u0026#34;Goroutine running...\u0026#34;) 18\ttime.Sleep(500 * time.Millisecond) 19\t} 20\t} 21} 22 23func main() { 24\tctx, cancel := context.WithTimeout(context.Background(), 3*time.Second) 25\tdefer cancel() 26 27\tfor { 28\tgo unhealthyGoroutine(ctx) 29\t\u0026lt;-time.After(4 * time.Second) 30\t} 31} 1$ go run main.go 2Goroutine running... 3Goroutine running... 4Goroutine running... 5Goroutine running... 6Goroutine running... 7Goroutine running... 8Goroutine is unhealthy, exiting 9Goroutine is unhealthy, exiting 10Goroutine is unhealthy, exiting 11Goroutine is unhealthy, exiting 12Goroutine is unhealthy, exiting 13Goroutine is unhealthy, exiting در کد فوق ما یک تابع به نام unhealthyGoroutine داریم که بصورت جداگانه در گوروتین های مختلف اجرا می شود و کاری را انجام می دهد. داخل تابع ما یک select داریم که در یکی از case هایش context.Done را بررسی میکنیم آیا فرآیند لغو شده است یا خیر. داخل تابع main ما یک context از نوع Timeout با مدت زمان ۳ ثانیه‌ای ایجاد کردیم و در ادامه داخل یک حلقه بینهایت تابع unhealthyGoroutine داخل گوروتین قرار دادیم و هر ۴ ثانیه یک نمونه از این تابع داخل گوروتین های مختلف اجرا می شود.\nدر اینجا کارهای داخل تابع unhealthyGoroutine انجام شود پس از ۳ ثانیه بواسطه context فرآیندها لغو می شود و از گوروتین خارج می شود. حال ما داخل تابع main اجازه دادیم یک گوروتین جدید و سالم را اجرا کند و جایگزین گوروتین ناسالم شود.\n3.9.5 پیاده سازی الگوریتم فیبوناچی با همزمانی # دنباله فیبوناچی مجموعه‌ای از اعداد است که در آن هر عدد حاصل جمع دو عدد قبلی است که معمولا با 0 و 1 شروع می شود. ، 55، 89، 144 و غیره. دنباله فیبوناچی به نام ریاضیدان ایتالیایی، لئوناردو پیزا، که به فیبوناچی نیز معروف بود، نامگذاری شده است. الگوریتم فیبوناچی روشی برای محاسبه عدد n در دنباله فیبوناچی است. روش‌های مختلفی برای پیاده‌سازی الگوریتم فیبوناچی وجود دارد، اما رایج‌ترین روش استفاده از بازگشت است.\nدر علوم و مهندسی کامپیوتر، از دنباله فیبوناچی برای تحلیل عملکرد الگوریتم هایی مانند برج هانوی و تکنیک جستجوی فیبوناچی استفاده می شود.\nدر زیر ما برای اینکه بتوانید در سریعترین حالت ممکن محاسبات را انجام دهیم خیلی ساده می توانیم از همزمانی و کانال استفاده کنیم و در کسری از ثانیه محاسبه کنیم.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7func fibo(n int) \u0026lt;-chan int { 8\tresult := make(chan int) 9\tgo func() { 10\tdefer close(result) 11 12\tif n \u0026lt;= 2 { 13\tresult \u0026lt;- 1 14\treturn 15\t} 16 17\tresult \u0026lt;- \u0026lt;-fibo(n-1) + \u0026lt;-fibo(n-2) 18 19\t}() 20 21\treturn result 22} 23 24func main() { 25\tfmt.Println(\u0026lt;-fibo(25)) 26} 1$ go run main.go 275025 "},{"id":41,"href":"/chapter-3/go-concurrency-patterns/","title":"3.10 الگو های همزمانی","section":"فصل سوم: همزمانی (concurrency)","content":"الگو های همزمانی را در فصل ۹ در کنار سایر الگوهای طراحی قرار دادیم یک مرجع کامل از الگوهای طراحی برای زبان گو داشته باشیم. در این بخش فقط ما خلاصه توضیحی در خصوص الگوها قرار دادیم و شما را ارجاع می دهیم به صفحه الگو :\nعنوان توضیحات وضعیت Wait For Result با استفاده از الگو Wait For Result می توانید یک عملیاتی را بصورت همزمانی انجام دهید و سپس منتظر نتیجه عملیات صورت گرفته بمانید. برای اینکار از کانال استفاده می شود. ✅ Fan Out/In الگو Fan Out/In یک تکنیک همزمانی در زبان گو می باشد که به شما اجازه می دهد چندین کار را با گوروتین همزمان انجام دهید و در نتیجه خروجی این کارها را با هم ترکیب کنید و به عنوان نتیجه نهایی دریافت کنید. ✅ Wait For Task الگو wait for task یکی از الگوهای رایج در زبان گو می باشد و انتظار برای تکمیل یک تسک یا فرآیند استفاده می شود. یک تسک با استفاده از گوروتین اجرا می شود و پس اتمامش کار تسک از طریق کانال سیگنال انجام می فرستد. ✅ Drop الگو Drop یک الگو مهم برای انجام خدمات سنگین می باشد. خدماتی که مواقعی باعث می شود حجم درخواست هایش بیش از ظرفیت موجود باشد و این درخواست ها بواسطه این الگو می تواند Drop شود. به عنوان مثال سرویس های DNS باید از این الگو استفاده کنند. ✅ Context Cancellation Pattern الگو cancellation که حرکت تکنیکی هست برای ارسال سینگال به گوروتین ها استفاده می شود که باید اجرای کاری را متوقف کند و ایده اصلی این کار با استفاده بستن کانال صورت میگیرد. ✅ Semaphore الگو Semaphore برای مدیریت کنترل دسترسی به منابع مشترک در همزمانی استفاده می شود. فرض کنید بصورت موازی ۱۰۰ درخواست HTTP سمت سرور میاد و I/O شبکه برای پردازش همزمان این ۱۰۰ درخواست درگیر میشود و به مرور عملکرد کاهش می یابد. حال اگر ما بیایم این ۱۰۰ درخواست موازی را تقسیم کنیم به ۵ دسته ۲۰ تایی که بصورت همزمانی انجام شود باعث می شود I/O شبکه کاهش یابد و عملکرد بهتری را خواهیم داشت. ✅ Worker Pool با استفاده از الگو Bounded Work Pooling امکان محدود سازی تعداد گوروتین ها را براساس کار مشخصی دارید و گوروتین ها را محدود به تعداد دفعات کار مشخص شده محدود می شود. این الگو برای وقت مفید است که شما می خواهید منابع را به یک کار خاص محدود کنید. ✅ Retry Timeout شما از الگو Retry Timeout برای تلاش مجدد یکسری عملیات استفاده کنید. برای اینکار شما می توانید از حلقه و تابع After در پکیج time کمک بگیرید و برای هرتلاش یک timeout مشخص کنید. ✅ Channel Cancellation از کانال ها برای ارتباط بین گوروتین ها و هماهنگ کردن اجرا استفاده می شود. حال گاهی اوقات نیاز است که ما یکسری فرآیند را داخل گوروتین لغو کنیم. در اینجا می توانیم با استفاده از کانال سیگنال لغو کردن بفرستید تا عملیات هایی که گوروتین مورد نظر انجام می داد لغو شود. ✅ Producer-Consumer الگو producer-consumer یکی از کاربردی ترین الگوها در زبان گو می باشد که با استفاده از الگو می توانید بطور همزمان یکسری اطلاعات تولید کنید و بفرستید داخل کانال و این اطلاعات توسط مصرف کننده بواسطه کانال دریافت شود. ✅ Monitor الگوی مانیتور به گروتین‌ ها اجازه می‌دهد هنگام ورود به حالت خواب بدون مسدود کردن اجرا یا مصرف منابع، منتظر شرایط خاصی باشند. ✅ Future در زبان گو الگو Future راهی برای نمایش نتیجه یک عملیات ناهمزمان (asynchronous) است که ممکن است آن عملیات هنوز تکمیل نشده باشد اما این الگو به شما این امکان را می دهد کدی بنویسید که طوری رفتار کند که گویی نتیجه یک عملیات فورا در دسترس است. حتی اگر عملیات در پس زمینه در حال اجرا باشد. ✅ Pipeline الگو خط لوله (Pipeline) یکی از پرکاربردی ترین الگوها در همزمانی می باشد شما با استفاده از این الگو می توانید تسک های بزرگ را به تسک های کوچکتر و مستقل تقسیم کنید که می توانند بطور همزمان کار کنند. هر stage داخل یک گوروتین انجام می شود و بواسطه کانال داده ها بین stage های مختلف منتقل می شود. ✅ Subscription الگو Subscription یکی از الگوهای کاربردی برای پیاده سازی consumer می باشد که به یک آدرسی مشترک شوید و در بازده زمانی مختلف درخواست دهید و یکسری اطلاعات دریافت کنید. ✅ Bridge Channel با استفاده از الگو Bridge Channel می توانید بین ۲ کانال داده ای را منتقل کنید فرض کنید یک داده را به کانال input میفرستید و از دریافت داده آن را می توانید به کانال دیگری منتقل کنید و عملا شما یک پل برای انتقال داده ایجاد کردید. ✅ Queuing الگوی \u0026ldquo;صف\u0026rdquo; در زبان گو الگویی است که در آن از یک گوروتین برای بافر کردن و مدیریت ترتیب مقادیر ارسال شده و دریافت شده از یک کانال استفاده می شود. ✅ Rate limit الگوی Rate Limiting برای کنترل تعداد درخواست‌ها یا وظایف همزمان در یک بازه زمانی مشخص استفاده می‌شود. این الگو با استفاده از یک time.Ticker یا روش‌های مشابه، اجرای گوروتین‌ها یا پردازش داده‌ها را محدود می‌کند. ✅ Deadlock Recovery الگوی بازیابی از بن‌بست (Deadlock Recovery) برای شناسایی و بازیابی از وضعیت‌های بن‌بست استفاده می‌شود، جایی که چندین گوروتین به طور نامحدود منتظر منابعی هستند که توسط یکدیگر نگه داشته شده‌اند. بن‌بست می‌تواند به دلیل همگام‌سازی نادرست یا رقابت برای منابع در برنامه‌های همزمان رخ دهد. ✅ Lock-free synchronization همگام‌سازی بدون قفل (lock-free synchronization) به مجموعه‌ای از تکنیک‌ها و الگوهای برنامه‌نویسی گفته می‌شود که به چندین thread یا goroutine اجازه می‌دهد به طور همزمان و ایمن به داده‌های مشترک دسترسی پیدا کنند، بدون اینکه از primitiveهایی مثل Mutex یا قفل‌های سنتی استفاده شود. هدف اصلی این الگوها افزایش بازدهی (throughput)، کاهش زمان انتظار (latency) و جلوگیری از مشکلات رایج قفل‌گذاری (مثل deadlock، priority inversion و contention) است. الگوریتم‌های lock-free تضمین می‌کنند که حتی اگر برخی از threadها متوقف شوند یا دچار کندی شوند، باقی سیستم همچنان قادر به پیشرفت خواهد بود (progress guarantee). ✅ "},{"id":42,"href":"/chapter-4/","title":"فصل چهارم: مباحث پیشرفته","section":"صفحه اصلی","content":"در این بخش به مباحث پیشرفته تری از زبان گو می پردازیم که شامل بخش های زیر می باشد.\n۴.۱ پروژه Build آموزش ‌. ۴.۲ Debuggingآموزش کار با. ۴.۳ go mod آموزش کار با . ۴.۴ workspace آموزش کار با. ۴.۵ Vendor آموزش کار با. ۴.۶ command line آموزش نوشتن برنامه. آموزش کار با فایل ۴.۷. ۴.۸ json آموزش کار با. ۴.۹ toml آموزش کار با. ۴.۱۰ yaml آموزش کار با. ۴.۱۱ CSV آموزش کار با. ۴.۱۲ ini آموزش کار با. ۴.۱۳ enviroment variable آموزش کار با. ۴.۱۴ regexp آموزش کار با. ۴.۱۵ reflection آموزش. ۴.۱۶ generator آموزش. ۴.۱۷ stringerآموزش. تکنیک های کد نویسی زبان گو ۴.۱۸. اصول کامنت نویسی ۴.۱۹. قوانین کد نویسی در زبان گو ۴.۲۰. ۴.۲۱ (garbage collector)زباله جمع کن. ۴.۲۲ Plugin کتابخانه. ۴.۲۳ شی گرایی در زبان گو. ۴.۲۴ tracing آموزش ۴.۲۵ profiling آموزش "},{"id":43,"href":"/chapter-4/build-go-file/","title":"4.1 آموزش Build پروژه","section":"فصل چهارم: مباحث پیشرفته","content":"برای build یک پروژه شما باید از کامند go build استفاده کنید که این کامند دارای یکسری سوییچ می باشد که در زیر ما معرفی خواهیم کرد.\n4.1.1 نحوه build یک فایل گو # معمولا شما باید برای build فایلی که دارای package main هست را برای build استفاده کنید مانند مثال زیر :\n1$ go build main.go پس از build در محل همان فایل یک فایل با نام main ایجاد می شود.\nاگر فایل main شما در روت پروژه باشد نیازی نیست به دستور go build نام فایل را بدهید کافیه مانند دستور زیر پروژه را build کنید.\n1$ go build . خروجی یک فایل با نام پروژه ایجاد می شود.\n4.1.2 استفاده از gcflags برای build # همانطور که گفتیم کامند build دارای یکسری سوییچ می باشد که یکی از سوییچ هایش gcflags می باشد که می توانید هنگام build یکسری اطلاعات مربوط به دیباگ به فایل خروجی اضافه می شود.\n1$ go build -gcflags \u0026#34;-N -l\u0026#34; main.go توجه کنید این نوع build گرفتن برای انجام Remote Debugging که در بخش بعدی آموزش می دهیم خیلی کاربردی می باشد.\n4.1.3 تعیین نام خروجی فایل, معماری و سیستم عامل # اگر یادتان باشد در بخش تاریخچه زبان گو یکی از ویژگی های بارزی که در خصوص زبان گو گفتیم بحث Cross-Platform Build بود که شما می توانید در همان سیستم عاملی که هستید برای سایر پلت فرم ها و سیستم عامل ها خروجی بگیرید.\n1$ GOOS=linux GOARCH=amd64 go build -o myproject main.go کامند فوق در لینوکس و سیستم عامل های یونیکسی کاربردی است که شما می توانید قبل از فرمان اصلی یکسری environment variables تعیین کنید. که در کامند فوق ما ۲ تا environment قرار دادیم اولی برای تعیین سیستم عامل هست و دومی معماری هست که ۳۲ بیت یا ۶۴ بیت و همچنین از نوع arm باشد. سپس فرمان go build را قرار دادیم حال خروجی فایل مناسب برای هر سیستم عامل لینوکس با معماری amd64 (۶۴ بیت) می باشد. و در انتهای کامند یک سوییچ o- قرار دادیم که نام خروجی فایل build شده چی باشد.\n4.1.4 گرفتن build به همراه race detector # در فصل سوم یک بخشی داشتیم به نام data race که در خصوصش توضیح دادیم چطور جلوی این اتفاق را در همزمانی بگیریم. حال یک سوییچ در کامند build داریم به نام race- برای تشخیص data race کمک می کند.\n1$ go build -race 4.1.5 مقدار دهی متغیر هنگام build # اما یکی از سوییچ های خیلی جالب در زبان گو هست که هنگام build پروژه می تواند متغیری را در هرجای پروژه مقدار دهی کند و از کاربردهای آن می توان برای تعیین ورژن پروژه و\u0026hellip; می باشد.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5var ( 6\tVersion string 7\tBuildTime string 8) 9 10func main() { 11\tfmt.Printf(\u0026#34;version %s, build time %s\u0026#34;, Version, BuildTime) 12} 1$ go build -ldflags \u0026#34;-X main.Version=1.0.0 -X main.BuildTime=`date -u +%Y-%m-%dT%H:%M:%SZ`\u0026#34; main.go 1$ ./main 2version 1.0.0, build time 2023-01-27T14:19:23Z در کد فوق ما ۲ متغیر ایجاد کردیم که هنگام build مقدار دهی کنیم و به کامند build ما یک سوییچ ldflags- اضافه کردیم و آدرس متغیرها را جهت مقدار دهی به این کامند داده‌ایم.\nتوجه کنید اگر متغیرهایتان داخل پکیج (پوشه ای) مانند configs بود آدرس متغییر بصورت زیر می شود :\n1$ go build -ldflags \u0026#34;-X configs.Version=1.0.0 -X configs.BuildTime=`date -u +%Y-%m-%dT%H:%M:%SZ`\u0026#34; main.go "},{"id":44,"href":"/chapter-4/debugging-go-code/","title":"4.2 آموزش کار با Debugging","section":"فصل چهارم: مباحث پیشرفته","content":"برای بحث debugging در زبان گو روش های مختلفی وجود دارد که محبوبترین روش ها به شرح زیر می باشد :\nبا استفاده پکیج fmt : شما با استفاده از تابع fmt.Println می توانید مقادیر برخی از متغیرها را چاپ کنید و یکی از روش های ساده برای بحث دیباگ هستش. با استفاده از پکیج log : یکی از کاربردی ترین روش ها بحث لاگ کردن هستش که شما می توانید هر بخش از کدهای خود را لاگ کنید و بصورت زنده در console یا داخل فایل ببینید و از همه مهمتر شما می توانید لاگ های خود را سطح بندی کنید تا بهتر بتوانید دیباگ کنید. استفاده از پکیج pprof : پکیج pprof به شما کمک می کند تا راحتر مشکلات عملکردی برنامه خود را بیابید و همچنین خروجی profile از عملکرد برنامه با CPU و Memory را آنالیز کنید. با استفاده از IDE ها: اکثر IDE هایی (Goland, Vscode) که قبلا معرفی کردیم دارای دیباگر داخلی می باشند که شما می توانید در هر بخش از کد خود breakpoint بزارید و خط به خط کد را دیباگ کنید و مشکلات را برطرف کنید. با استفاده از دیباگر dlv : یکی از محبوبترین دیباگرهایی بصورت متن باز در حال توسعه است delve می باشد که به شما برای دیباگ کردن بصورت تعاملی هنگام اجرا کمک می کند. حال در ادامه ما با مثال هایی نحوه کار با این شیوه هایی که معرفی کردیم آموزش می دهیم.\n4.2.1 نحوه دیباگ با fmt # شما با استفاده از تابع fmt.Println می توانید مقادیر برخی از متغیرها را چاپ کنید و برای اینکار به مثال ساده زیر توجه کنید :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func fibonacci(n uint) uint { 6\tif n \u0026lt; 2 { 7\treturn n 8\t} 9 10\tvar a, b uint 11 12\tb = 1 13 14\tfor n--; n \u0026gt; 0; n-- { 15\ta += b 16\ta, b = b, a 17\tfmt.Println(\u0026#34;this is example debugging value a is \u0026#34;, a, \u0026#34; value b is \u0026#34;, b) 18\t} 19 20\treturn b 21} 22 23func main() { 24\tfmt.Println(fibonacci(100)) 25} 1$ go run main.go 2this is example debugging value a is 1 value b is 1 3this is example debugging value a is 1 value b is 2 4this is example debugging value a is 2 value b is 3 5this is example debugging value a is 3 value b is 5 6this is example debugging value a is 5 value b is 8 7... 8this is example debugging value a is 6174643828739884737 value b is 16008811023750101250 9this is example debugging value a is 16008811023750101250 value b is 3736710778780434371 103736710778780434371 در کد فوق برای اینکه مقدار a, b را ببینیم از تابع Println استفاده کردیم تا مقدار داخل این دو متغیر را ببینیم.\n4.2.2 نحوه دیباگ با استفاده log # یکی از کاربردی ترین روش ها بحث لاگ کردن هستش که شما می توانید هر بخش از کدهای خود را لاگ کنید و بصورت زنده در console یا داخل فایل ببینید و از همه مهمتر شما می توانید لاگ های خود را سطح بندی کنید تا بهتر بتوانید دیباگ کنید. حال برای اینکه با log دیباگ کنید یک پکیج استاندارد به نام log داریم که می توانید بسته به نیازتان تغییرات دهید و هچنین پکیج هایی نظیر zap, logrus و \u0026hellip; هست برای بحث لاگ به شما خیلی کمک می کنند.\n1package main 2 3import ( 4\t\u0026#34;log\u0026#34; 5\t\u0026#34;os\u0026#34; 6) 7 8func main() { 9\t// Set the log level to Info 10\tlog.SetFlags(0) 11\tlog.SetPrefix(\u0026#34;[Info] \u0026#34;) 12\tlog.SetOutput(os.Stdout) 13\tlog.Println(\u0026#34;This is an informational message\u0026#34;) 14 15\t// Set the log level to Warning 16\tlog.SetPrefix(\u0026#34;[Warn] \u0026#34;) 17\tlog.SetOutput(os.Stdout) 18\tlog.Println(\u0026#34;This is a warning message\u0026#34;) 19 20\t// Set the log level to Error 21\tlog.SetPrefix(\u0026#34;[Error] \u0026#34;) 22\tlog.SetOutput(os.Stderr) 23\tlog.Println(\u0026#34;This is an error message\u0026#34;) 24} 1$ go run main.go 2[Info] This is an informational message 3[Warn] This is a warning message 4[Error] This is an error message در کد فوق ما با استفاده از تابع SetPrefix یک پیشوند برای لاگ ها اضافه کردیم تا بتوانیم لاگ با سطح های مختلف ایجاد کنیم. و با استفاده از log.Println لاگ را چاپ کردیم. در ادامه این فصل به بحث آموزش کار به log میپردازیم.\n4.2.3 دیباگ عملکرد با استفاده از pprof # زبان گو یک ابزار داخلی دارد جهت آنالیز و دیباگ عملکرد به نام pprof که با استفاده از آن می توانید یکسری اطلاعات در خصوص عملکرد برنامه تهیه کنید و براساس آنالیز اطلاعات مشکلات عملکردی را می توانید برطرف کنید.\n1package main 2 3import ( 4\t\u0026#34;log\u0026#34; 5\t\u0026#34;net/http\u0026#34; 6\t_ \u0026#34;net/http/pprof\u0026#34; 7) 8 9func main() { 10\tlog.Println(http.ListenAndServe(\u0026#34;localhost:6060\u0026#34;, nil)) 11} 1$ go run main.go در کد فوق ما از پکیج مسیر net/http/pprof استفاده کردیم تا عملکرد برنامه را در وب سرور زبان گو را آنالیز و دیباگ کنیم. حال اگر به آدرس http://localhost:6060/debug/pprof/ بروید می توانید وضعیت عملکرد وب سرور را در لحظه ببینید و آنالیز کنید.\n4.2.3.1 آنالیز وضعیت CPU # برای آنالیز وضعیت CPU کافیه کامند زیر را بزنید :\n1go tool pprof http://localhost:6060/debug/pprof/profile 4.2.3.2 آنالیز وضعیت heap memory # برای آنالیز حافظه heap کافیه کامند زیر را بزنید :\n1go tool pprof http://localhost:6060/debug/pprof/heap 2 3Fetching profile over HTTP from http://localhost:6060/debug/pprof/heap 4Saved profile in /home/javad/pprof/pprof.main.alloc_objects.alloc_space.inuse_objects.inuse_space.001.pb.gz 5File: main 6Type: inuse_space 7Time: Jan 27, 2023 at 6:46pm (+0330) 8Entering interactive mode (type \u0026#34;help\u0026#34; for commands, \u0026#34;o\u0026#34; for options) 9(pprof) pdf زمانیکه کامند فوق را بزنید وارد شل pprof خواهید شد که می توانید با زدن help کامندهای کاربردی را جهت آنالیز ببینید. به عنوان مثال pdf را بزنید یک خروجی pdf بصورت گراف از وضعیت حافظه heap ارائه می دهد که می توانید وضعیت را آنالیز کنید (جهت خواندن گراف این آموزش را مطالعه کنید).\n4.2.4 دیباگ با استفاده از GDB # این قسمت با استفاده از مستندات رسمی GO در مورد 1. Debugging Go Code with GDB نوشته شده است. دستورالعمل های زیر برای استاندارد toolchain (کامپایلر و ابزارهای gc Go) اعمال می شود. Gccgo دارای پشتیبانی از native gdb به صورت پیش فرض است.\nتوجه داشته باشید که هنگام اشکال زدایی برنامه های Go که باstandard toolchain ساخته شده اند، Delve جایگزین بهتری برای GDB است. زیرا Go runtime را بهتر تشخیص می‌دهد و ساختارهای داده و عبارات را بهتر از GDB درک می کند. Delve در حال حاضر از Linux، OSX و Windows در amd64 پشتیبانی می کند. برای به روزترین لیست پلتفرم های پشتیبانی شده، لطفاً به Delve documentation مراجعه کنید.\nGDB برنامه های Go را به خوبی درک نمی کند. مدیریت stack و threading و runtime شامل جنبه هایی هستند که به اندازه کافی با مدل اجرایی متفاوت است که GDB انتظار دارد که می توانند debugger را اشتباه گرفته و نتایج نادرستی را حتی زمانی که برنامه با gccgo کامپایل می شود ایجاد کنند. در نتیجه، اگرچه GDB می‌تواند در برخی موقعیت‌ها مفید باشد (به عنوان مثال، اشکال‌زدایی کد Cgo، یا اشکال‌زدایی خود زمان اجرا)، اما برای برنامه‌های Go، به‌ویژه برنامه‌های به‌شدت همزمان هستند، اشکال‌زدایی با این روش چندان قابل اعتمادی نیست. علاوه بر این، پرداختن به این مسائل که دشوار هستند، برای پروژه Go در اولویت نیست.\nبه طور خلاصه، دستورالعمل‌های زیر باید تنها به‌عنوان راهنمای نحوه استفاده از GDB در هنگام کارکرد آن در نظر گرفته شود، نه به عنوان تضمین موفقیت اجرای درست برنامه. علاوه بر این نمای کلی، ممکن است بخواهید به GDB manual مراجعه کنید.\n4.2.4.1 مقدمه اولیه GDB # وقتی برنامه‌های Go را با toolchain مربوط gc در Linux، macOS، FreeBSD یا NetBSD کامپایل و link می‌دهید، باینری‌های به دست آمده حاوی اطلاعات اشکال‌زدایی DWARFv4 هستند که نسخه‌های اخیر (≥7.5) اشکال‌زدای GDB می‌توانند از آن برای بازرسی یک live process یا یک core dump استفاده کنند. .\nپرچم \u0026lsquo;-w\u0026rsquo; را به linker ارسال کنید تا اطلاعات debug را حذف کنید (به عنوان مثال، go build -ldflags=-w prog.go).\nکد تولید شده توسط کامپایلر gc شامل درون خطی کردن فراخوانی تابع و ثبت متغیرها است. این بهینه سازی ها گاهی اوقات می تواند اشکال زدایی با gdb را سخت تر کند. اگر متوجه شدید که باید این بهینه سازی ها را غیرفعال کنید، برنامه خود را با استفاده از go build -gcflags=all=-N -l بسازید.\nاگر می‌خواهید از gdb برای بررسی یک core dump استفاده کنید، می توانید یک Dump را در یک program crash راه اندازی کنید و برای این کار باید GOTRACEBACK=crash در environment تنظیم کنید (برای اطلاعات بیشتر به runtime package documentation مراجعه کنید).\n4.2.4.2 Common Operations # نمایش فایل و شماره خط برای کد، تعیین breakpoints و disassemble:\n1(gdb) list 2(gdb) list _line_ 3(gdb) list _file.go_:_line_ 4(gdb) break _line_ 5(gdb) break _file.go_:_line_ 6(gdb) disas نمایش backtraces و باز کردن stack frames:\n1(gdb) bt 2(gdb) frame _n_ نمایش نام، type و location در stack frame و local variables، آرگومان ها و مقادیر بازگشتی:\n1(gdb) info locals 2(gdb) info args 3(gdb) p variable 4(gdb) whatis variable نمایش نام، type و location و global variables:\n1(gdb) info variables _regexp_ 4.2.4.3 Go Extensions # اخیرا یک نوع extension به GDB اجازه می دهد تا extension scripts را برای یک باینری معین load کند. این toolchain برای extend GDB با تعداد انگشت شماری از command ها برای بررسی داخلی runtime code (مانند گوروتین ها) و pretty print the built-in map و slice وchannel types استفاده می کند.\n1Pretty printing a string, slice, map, channel or interface:(gdb) p var 2A $len() and $cap() function for strings, slices and maps: (gdb) p $len(var) 3A function to cast interfaces to their dynamic types: 4(gdb) p $dtype(var) 5(gdb) iface var مشکلات شناخته شده: GDB نمی تواند به طور خودکار dynamic type یک interface value را پیدا کند اگر نام طولانی آن با نام کوتاه آن متفاوت باشد (در هنگام printing stacktraces آزاردهنده است، pretty printer به نمایش نام short type و اشاره گر بازمی گردد).\nبررسی گوروتین ها:\n1(gdb) info goroutines 2(gdb) goroutine _n_ _cmd_ 3(gdb) help goroutine به عنوان مثال:\n1(gdb) goroutine 12 bt می توانید همه گوروتین ها را با pass کردن همه به جای goroutine\u0026rsquo;s ID خاص بررسی کنید. مثلا:\n1 (gdb) goroutine all bt اگر می‌خواهید ببینید که این حالت چگونه کار می‌کند یا می‌خواهید آن را گسترش دهید، به src/runtime/runtime-gdb.py در توزیع Go source نگاهی بیندازید. این به برخی از type های جادویی خاص (hash\u0026lt;T,U\u0026gt;) و متغیرهایی (runtime.m و runtime.g) بستگی دارد کهlinker (src/cmd/link/internal/ld/dwarf.go) اطمینان حاصل می کند که در کد DWARF توضیح داده شده اند.\nاگر به debugging information علاقه دارید، objdump -W a.out را اجرا کنید و در بخش های مرتبط با .debug_* مرور کنید.\nمشکلات شناخته شده: # ۱- حالت String pretty printing فقط برای type string فعال می شود، نه برای انواع مشتق شده از آن. ۲-Type information برای قسمت های C که در runtime library هستند، وجود ندارد.\n۳- GDB شرایط Go’s name را نمی‌فهمد و «fmt.Print» را به‌عنوان یک کلمه بدون ساختار با یک «» در نظر می‌گیرد. که باید نقل شود. حتی با شدت بیشتری به method names فرم pkg.(*MyType).Meth. برخورد می کند.\n۴- از Go 1.11، قسمت debug information به طور پیش فرض فشرده شده است. نسخه‌های قدیمی‌تر gdb، مانند نسخه‌ای که به‌طور پیش‌فرض در MacOS موجود است، فشرده‌سازی را درک نمی‌کنند. شما می توانید با استفاده از go build -ldflags=-compressdwarf=false‍ اطلاعات اشکال زدایی فشرده نشده تولید کنید. (برای راحتی می توانید گزینه -ldflags را در GOFLAGS environment variable قرار دهید تا مجبور نباشید هر بار آدرس آن را مشخص کنید.)\n4.2.4.4 مثال های GDB # در این آموزش ما باینری unit tests پکیج regexp را بررسی می کنیم. برای ساخت باینری، به GOROOT/src/regexp$ تغییر دهید و go test -c را اجرا کنید. این باید یک فایل اجرایی به نام regexp.test تولید کند.\nشروع دیباگ # Launch GDB, debugging regexp.test:\n1$ gdb regexp.test 2GNU gdb (GDB) 7.2-gg8 3Copyright (C) 2010 Free Software Foundation, Inc. 4License GPLv 3+: GNU GPL version 3 or later \u0026lt;http://gnu.org/licenses/gpl.html\u0026gt; 5Type \u0026#34;show copying\u0026#34; and \u0026#34;show warranty\u0026#34; for licensing/warranty details. 6This GDB was configured as \u0026#34;x86_64-linux\u0026#34;. 7 8Reading symbols from /home/user/go/src/regexp/regexp.test... 9done. 10Loading Go Runtime support. 11(gdb) پیام \u0026lsquo;Loading Go Runtime Support\u0026rsquo; به این معنی است که GDB برنامه extension را از مسیر GOROOT/src/runtime/runtime-gdb.py$ بارگیری کرده است.\nبرای کمک به GDB در یافتن آدرس Go runtime sources و سایر اسکریپت‌های همراه، $GOROOT را با پرچم \u0026lsquo;-d\u0026rsquo; ارسال کنید:\ngdb regexp.test -d $GOROOT$ اگر به دلایلی هنوز GDB نمی تواند آن دایرکتوری یا آن اسکریپت را پیدا کند، می توانید آن را دستی load کنید (با فرض اینکه go sources در آدرس ~/go/ باشد):\n1(gdb) source ~/go/src/runtime/runtime-gdb.py 2Loading Go Runtime support. بررسی کردن source # از دستور \u0026rsquo;l\u0026rsquo; یا \u0026rsquo;list\u0026rsquo; برای بررسی source code استفاده کنید.\n1(gdb) l بخش خاصی از منبع را که \u0026rsquo;list\u0026rsquo; را پارامتر می کند با نام تابع فهرست کنید (باید با نام بسته آن مرتبط باشد).\n1(gdb) l main.main یک file خاص و line number را فهرست کنید:\n1(gdb) l regexp.go:1 2(gdb) _# Hit enter to repeat last command. Here, this lists next 10 lines._ Naming # نام متغیرها و توابع باید با نام package هایی که به آنها تعلق دارند قابل بازیابی باشند. به عنوان مثال تابع Compile از بسته regexp برای GDB به عنوان \u0026lsquo;regexp.Compile\u0026rsquo; شناخته می شود.\nمتدها باید با نام receiver types خود قابل بازیابی باشند. به عنوان مثال، *Regexp type’s String به عنوان 'regexp.(*Regexp).String' شناخته می شود.\nمتغیرهایی که سایر متغیرها را تحت shadow قرار می دهند، به صورت جادویی با یک عدد در debug info پسوند می شوند. متغیرهایی که توسط بسته‌ها ارجاع می‌شوند به‌عنوان اشاره‌گرهایی با پیشوند جادویی «\u0026amp;» ظاهر می‌شوند.\nقراردادن breakpoints # یک breakpoint در تابع TestFind تنظیم کنید: ‍‍\n1(gdb) b \u0026#39;regexp.TestFind\u0026#39; 2Breakpoint 1 at 0x424908: file /home/user/go/src/regexp/find_test.go, line 148. اجرا کردن برنامه:\n1(gdb) run 2Starting program: /home/user/go/src/regexp/regexp.test 3 4Breakpoint 1, regexp.TestFind (t=0xf8404a89c0) at /home/user/go/src/regexp/find_test.go:148 5148\tfunc TestFind(t *testing.T) { اجرا در breakpoint متوقف شده است. ببینید کدام گوروتین ها در حال اجرا هستند و چه کار می کنند:\n1(gdb) info goroutines 2 1 waiting runtime.gosched 3* 13 running runtime.goexit موردی که با * مشخص شده است، گوروتین فعلی است.\nبررسی کردن stack # به خروجی از stack برای جایی که برنامه را متوقف کرده ایم نگاه کنید:\n1(gdb) bt _# backtrace_ 2#0 regexp.TestFind (t=0xf8404a89c0) at /home/user/go/src/regexp/find_test.go:148 3#1 0x000000000042f60b in testing.tRunner (t=0xf8404a89c0, test=0x573720) at /home/user/go/src/testing/testing.go:156 4#2 0x000000000040df64 in runtime.initdone () at /home/user/go/src/runtime/proc.c:242 5#3 0x000000f8404a89c0 in ?? () 6#4 0x0000000000573720 in ?? () 7#5 0x0000000000000000 in ?? () گوروتین دیگر، شماره 1، در runtime.gosched گیر کرده و در channel receive مسدود شده است:\n1(gdb) goroutine 1 bt 2#0 0x000000000040facb in runtime.gosched () at /home/user/go/src/runtime/proc.c:873 3#1 0x00000000004031c9 in runtime.chanrecv (c=void, ep=void, selected=void, received=void) 4 at /home/user/go/src/runtime/chan.c:342 5#2 0x0000000000403299 in runtime.chanrecv1 (t=void, c=void) at/home/user/go/src/runtime/chan.c:423 6#3 0x000000000043075b in testing.RunTests (matchString={void (struct string, struct string, bool *, error *)} 7 0x7ffff7f9ef60, tests= []testing.InternalTest = {...}) at /home/user/go/src/testing/testing.go:201 8#4 0x00000000004302b1 in testing.Main (matchString={void (struct string, struct string, bool *, error *)} 9 0x7ffff7f9ef80, tests= []testing.InternalTest = {...}, benchmarks= []testing.InternalBenchmark = {...}) 10at /home/user/go/src/testing/testing.go:168 11#5 0x0000000000400dc1 in main.main () at /home/user/go/src/regexp/_testmain.go:98 12#6 0x00000000004022e7 in runtime.mainstart () at /home/user/go/src/runtime/amd64/asm.s:78 13#7 0x000000000040ea6f in runtime.initdone () at /home/user/go/src/runtime/proc.c:243 14#8 0x0000000000000000 in ?? () همانطور که stack frame نشان می دهد، انتظار می رود الان باید در حال اجرای تابع regexp.TestFind باشیم.\n1(gdb) info frame 2Stack level 0, frame at 0x7ffff7f9ff88: 3 rip = 0x425530 in regexp.TestFind (/home/user/go/src/regexp/find_test.go:148); 4 saved rip 0x430233 5 called by frame at 0x7ffff7f9ffa8 6 source language minimal. 7 Arglist at 0x7ffff7f9ff78, args: t=0xf840688b60 8 Locals at 0x7ffff7f9ff78, Previous frame\u0026#39;s sp is 0x7ffff7f9ff88 9 Saved registers: 10 rip at 0x7ffff7f9ff80 دستور info locals همه متغیرهای محلی تابع و مقادیر آنها را فهرست می‌کند، اما استفاده از آن کمی خطرناک است، زیرا سعی می‌کند متغیرهای اولیه را نیز چاپ کند. برش‌های بدون مقدار اولیه ممکن است باعث شوند که gdb سعی کند آرایه‌های بزرگ دلخواه را چاپ کند.\nآرگومان های تابع:\n1(gdb) info args 2t = 0xf840688b60 هنگام چاپ آرگومان، توجه کنید که نشانگر یک مقدار Regexp است. توجه داشته باشید که GDB به اشتباه * را در سمت راست نام تایپ قرار داده و یک کلمه کلیدی \u0026lsquo;struct\u0026rsquo; به سبک سنتی C ساخته است.\n1(gdb) p re 2(gdb) p t 3$1 = (struct testing.T *) 0xf840688b60 4(gdb) p t 5$1 = (struct testing.T *) 0xf840688b60 6(gdb) p *t 7$2 = {errors = \u0026#34;\u0026#34;, failed = false, ch = 0xf8406f5690} 8(gdb) p *t-\u0026gt;ch 9$3 = struct hchan\u0026lt;*testing.T\u0026gt; که ساختار hchan\u0026lt;*testing.T\u0026gt; نمایش runtime-internal یک کانال است و در حال حاضر خالی است، وگرنه gdb محتویات آن را به زیبایی چاپ می کرد.\nحالا به قسمت مهم پیمایش دیباگر میرسیم که با حرف n صورت می‌گیرد.\nپیمایش دیباگر :\n1(gdb) n _# execute next line_ 2149 for _, test := range findTests { 3(gdb) _# enter is repeat_ 4150 re := MustCompile(test.pat) 5(gdb) p test.pat 6$4 = \u0026#34;\u0026#34; 7(gdb) p re 8$5 = (struct regexp.Regexp *) 0xf84068d070 9(gdb) p *re 10$6 = {expr = \u0026#34;\u0026#34;, prog = 0xf840688b80, prefix = \u0026#34;\u0026#34;, prefixBytes = []uint8, prefixComplete = true, 11 prefixRune = 0, cond = 0 \u0026#39;\\000\u0026#39;, numSubexp = 0, longest = false, mu = {state = 0, sema = 0}, 12 machine = []*regexp.machine} 13(gdb) p *re-\u0026gt;prog 14$7 = {Inst = []regexp/syntax.Inst = {{Op = 5 \u0026#39;\\005\u0026#39;, Out = 0, Arg = 0, Rune = []int}, {Op = 15 6 \u0026#39;\\006\u0026#39;, Out = 2, Arg = 0, Rune = []int}, {Op = 4 \u0026#39;\\004\u0026#39;, Out = 0, Arg = 0, Rune = []int}}, 16 Start = 1, NumCap = 2} می توانیم با حرف \u0026rsquo;s\u0026rsquo; وارد فراخوانی Stringfunction شویم:\n1(gdb) s 2regexp.(*Regexp).String (re=0xf84068d070, noname=void) at /home/user/go/src/regexp/regexp.go:97 397 func (re *Regexp) String() string { یک stack trace بگیرید تا ببینید کجا هستیم:\n1(gdb) bt 2#0 regexp.(*Regexp).String (re=0xf84068d070, noname=void) 3 at /home/user/go/src/regexp/regexp.go:97 4#1 0x0000000000425615 in regexp.TestFind (t=0xf840688b60) 5 at /home/user/go/src/regexp/find_test.go:151 6#2 0x0000000000430233 in testing.tRunner (t=0xf840688b60, test=0x5747b8) 7 at /home/user/go/src/testing/testing.go:156 8#3 0x000000000040ea6f in runtime.initdone () at /home/user/go/src/runtime/proc.c:243 9.... به source code نگاه کنید:\n1(gdb) l 292 mu sync.Mutex 393 machine []*machine 494 } 595 696 // String returns the source text used to compile the regular expression. 797 func (re *Regexp) String() string { 898 return re.expr 999 } 10100 11101 // Compile parses a regular expression and returns, if successful, Pretty Printing\nمکانیسم چاپ زیبا GDB توسط regexp matches به صورت زیر می‌باشد:\n1(gdb) p utf 2$22 = []uint8 = {0 \u0026#39;\\000\u0026#39;, 0 \u0026#39;\\000\u0026#39;, 0 \u0026#39;\\000\u0026#39;, 0 \u0026#39;\\000\u0026#39;} از آنجایی که slice ها، آرایه ها و رشته ها اصلا اشاره‌گرهای C نیستند در نتیجه GDB نمی تواند عملیات subscripting را برای شما تفسیر کند، اما می توانید برای انجام این کار به نمایش runtime نگاه کنید (tab completion در اینجا کاربرد دارد):\n1(gdb) p slc 2$11 = []int = {0, 0} 3(gdb) p slc-\u0026gt;* _\u0026lt;TAB\u0026gt;_ 4array slc len 5(gdb) p slc-\u0026gt;array 6$12 = (int *) 0xf84057af00 7(gdb) p slc-\u0026gt;array[1] 8$13 = 0 توابع extension یا افزونه $len و $cap روی strings, arrays , slices کار می‌کنند:\n1(gdb) p $len(utf) 2$23 = 4 3(gdb) p $cap(utf) 4$24 = 4 Channelها و mapها در واقع typeهایی از جنس «reference» هستند که gdb آن‌ها را به‌عنوان اشاره‌گر به C++ like types مانند \u0026lt;hash\u0026lt;int,string\u0026gt;* نشان می‌دهد. Interface ها در runtime به عنوان یک اشاره گر به یک توصیفگر(descriptor) و یک اشاره گر به یک مقدار نشان داده می شوند. پسوند Go GDB در runtime این را رمزگشایی می کند و به طور خودکار pretty printing را برای runtime type ایجاد می کند. تابع افزونه dtype$ درنهایت یک dynamic type را برای شما رمزگشایی می‌کند (مثال‌هایی از یک breakpoint در خط 293 regexp.go گرفته شده‌اند.)\n1(gdb) p i 2$4 = {str = \u0026#34;cbb\u0026#34;} 3(gdb) whatis i 4type = regexp.input 5(gdb) p $dtype(i) 6$26 = (struct regexp.inputBytes *) 0xf8400b4930 7(gdb) iface i 8regexp.input: struct regexp.inputBytes * 4.2.5 معرفی دیباگر DELVE # delve یک debugger برای زبان برنامه نویسی GO است. هدف این پروژه ارائه یک ابزار ساده و کامل debugger برای GO است. DeLve باید به راحتی استفاده می‌شود و استفاده از آن آسان بسیار آسان می‌باشد.\n4.2.5.1 راهنمای نصب DELVE # دستورالعمل های زیر برای کار بر روی Linux، macOS، Windows و FreeBSD مورد استفاده قرار می‌گیرد.\nبرای Clone و build دستورات زیر رو داریم\n1 git clone https://github.com/go-delve/delve 2 cd delve 3 go install github.com/go-delve/delve/cmd/dlv برای Go version 1.16 و بالاتر هم داریم:\n1# Install the latest release: 2$ go install github.com/go-delve/delve/cmd/dlv@latest 3 4# Install at tree head: 5$ go install github.com/go-delve/delve/cmd/dlv@master 6 7# Install at a specific version or pseudo-version: 8$ go install github.com/go-delve/delve/cmd/dlv@v1.7.3 9$ go install github.com/go-delve/delve/cmd/dlv@v1.7.4-0.20211208103735-2f13672765fe برای جزئیات در مورد محل ذخیره فایل اجرایی dlv به راهنمای نصب یا دستور go help install مراجعه کنید.\nاگر در مرحله نصب با خطای مشابه زیر مواجه شدید: 2\n1found packages native (proc.go) and your_operating_system_and_architecture_combination_is_not_supported_by_delve (support_sentinel.go) in /home/pi/go/src/github.com/go-delve/delve/pkg/proc/native یعنی از سیستم عامل یا معماری CPU شما پشتیبانی نمی شود، خروجی go version را بررسی کنید.\nبرای نصب در macOS از لینک macOS استفاده کنید.\n4.2.5.2 شروع استفاده از DELVE # هدف Delve یک ابزار بسیار ساده و قدرتمند است، اما اگر به استفاده از source level debugger در یک زبان کامپایل شده عادت ندارید این ابزار می‌تواند گیج‌کننده باشد. البته این سند تمام اطلاعاتی را که برای شروع اشکال زدایی برنامه های Go خود نیاز دارید را ارائه می دهد.\n4.2.5.3 Debugging \u0026lsquo;main\u0026rsquo; packages # اولین CLI subcommand که بررسی خواهیم کرد کلیدواژه debug است. این subcommand را می توان بدون آرگومان اجرا کرد اگر شما در همان دایرکتوری main package خود هستید، در غیر این صورت به صورت اختیاری یک package path را می پذیرد.\nبه عنوان مثال با توجه به این project layout داریم:\n1github.com/me/foo 2├── cmd 3│ └── foo 4│ └── main.go 5└── pkg 6 └── baz 7 ├── bar.go 8 └── bar_test.go اگر در دایرکتوری github.com/me/foo/cmd/foo هستید، می توانید به سادگی dlv debug را از command line اجرا کنید. از هر جای دیگری، مثلاً project root، می توانید به سادگی package را معرفی کنید، به عنوان مثال: dlv debug github.com/me/foo/cmd/foo . برای ارسال flag‌ها به برنامه خود، آنها را به صورت زیر جدا سازی کنید:\n--: dlv debug github.com/me/foo/cmd/foo -- -arg1 value\nفراخوانی آن دستور باعث می شود که Delve برنامه را به روشی مناسب برای اشکال زدایی کامپایل کند و سپس برنامه اجرا شده و دیباگر به برنامه attach می شود و debug session را شروع می کند. حالا، هنگامی که جلسه debug session برای اولین بار شروع شده است، شما در ابتدای شروع اولیه برنامه هستید. برای رسیدن به جایی که مورد نظر هست باید یک یا دو breakpoint تعیین کنید و اجرا را تا آن نقطه ادامه دهید.\nبه عنوان مثال، برای ادامه اجرا به تابع main برنامه:\n1$ dlv debug github.com/me/foo/cmd/foo 2Type \u0026#39;help\u0026#39; for list of commands. 3(dlv) break main.main 4Breakpoint 1 set at 0x49ecf3 for main.main() ./test.go:5 5(dlv) continue 6\u0026gt; main.main() ./test.go:5 (hits goroutine(1):1 total:1) (PC: 0x49ecf3) 7 1:\tpackage main 8 2:\t9 3:\timport \u0026#34;fmt\u0026#34; 10 4:\t11=\u0026gt; 5:\tfunc main() { 12 6:\tfmt.Println(\u0026#34;delve test\u0026#34;) 13 7:\t} 14(dlv) 4.2.5.4 Debugging tests # با توجه به ساختار دایرکتوری مشابه با بالا، می توانید کد خود را با اجرای مجموعه آزمایشی خود اشکال زدایی کنید. برای این کار می توانید از subcommand یا دستور dlv test استفاده کنید، که همان package path اختیاری را به عنوان dlv debug طی می کند و در صورت عدم ارائه آرگومان، package فعلی را نیز می سازد.\n1$ dlv test github.com/me/foo/pkg/baz 2Type \u0026#39;help\u0026#39; for list of commands. 3(dlv) funcs test.Test* 4/home/me/go/src/github.com/me/foo/pkg/baz/test.TestHi 5(dlv) break TestHi 6Breakpoint 1 set at 0x536513 for /home/me/go/src/github.com/me/foo/pkg/baz/test.TestHi() ./test_test.go:5 7(dlv) continue 8\u0026gt; /home/me/go/src/github.com/me/foo/pkg/baz/test.TestHi() ./bar_test.go:5 (hits goroutine(5):1 total:1) (PC: 0x536513) 9 1:\tpackage baz 10 2:\t11 3:\timport \u0026#34;testing\u0026#34; 12 4:\t13=\u0026gt; 5:\tfunc TestHi(t *testing.T) { 14 6:\tt.Fatal(\u0026#34;implement me!\u0026#34;) 15 7:\t} 16(dlv) همانطور که می بینید، ما شروع به دیباگ کردن یک test binary کردیم، تابع تست خود را از طریق دستور funcs پیدا کردیم که یک regexp برای فیلتر کردن لیست توابع می گیرد، حالا یک breakpoint تعیین می کنیم و سپس اجرا را ادامه می دهیم تا زمانی که به آن breakpoint رسیدیم.\nبرای اطلاعات بیشتر در مورد subcommands که می‌توانید استفاده کنید، dlv help را تایپ کنید، و یک بار در debug session می‌توانید با تایپ help در هر زمانی، تمام دستورات موجود را مشاهده کنید.\n4.2.5.5 Synopsis و گزینه های Command line options # Delve شما را قادر می سازد تا با کنترل اجرای فرآیند، ارزیابی متغیرها و ارائه اطلاعات state thread / goroutine، همینطور CPU register state و موارد دیگر، با برنامه خود تعامل داشته باشید.\nهدف این ابزار ارائه یک رابط ساده و در عین حال قدرتمند برای اشکال زدایی برنامه های Go است. flagبرای استفاده از قابلیت های delve باید flagها را به برنامه‌ای که با استفاده از آن اشکال‌زدایی می‌کنید ارسال کنید، به کمک دستور -- برای مثال:\ndlv exec ./hello -- server --config conf/config.toml\nدر سایر گزینه ها داریم:\n1 2 3 --accept-multiclient Allows a headless server to accept multiple client connections via JSON-RPC or DAP. 4 --allow-non-terminal-interactive Allows interactive sessions of Delve that don\u0026#39;t have a terminal as stdin, stdout and stderr 5 --api-version int Selects JSON-RPC API version when headless. New clients should use v2. Can be reset via RPCServer.SetApiVersion. See Documentation/api/json-rpc/README.md. (default 1) 6 --backend string Backend selection (see \u0026#39;dlv help backend\u0026#39;). (default \u0026#34;default\u0026#34;) 7 --build-flags string Build flags, to be passed to the compiler. For example: --build-flags=\u0026#34;-tags=integration -mod=vendor -cover -v\u0026#34; 8 --check-go-version Exits if the version of Go in use is not compatible (too old or too new) with the version of Delve. (default true) 9 --disable-aslr Disables address space randomization 10 --headless Run debug server only, in headless mode. Server will accept both JSON-RPC or DAP client connections. 11 -h, --help help for dlv 12 --init string Init file, executed by the terminal client. 13 -l, --listen string Debugging server listen address. (default \u0026#34;127.0.0.1:0\u0026#34;) 14 --log Enable debugging server logging. 15 --log-dest string Writes logs to the specified file or file descriptor (see \u0026#39;dlv help log\u0026#39;). 16 --log-output string Comma separated list of components that should produce debug output (see \u0026#39;dlv help log\u0026#39;) 17 --only-same-user Only connections from the same user that started this instance of Delve are allowed to connect. (default true) 18 -r, --redirect stringArray Specifies redirect rules for target process (see \u0026#39;dlv help redirect\u0026#39;) 19 --wd string Working directory for running the program. همینطور دستورات زیر را داریم:\ndlv attach - Attach to running process and begin debugging.\ndlv connect - Connect to a headless debug server with a terminal client.\ndlv core - Examine a core dump.\ndlv dap - Starts a headless TCP server communicating via Debug Adaptor Protocol (DAP).\ndlv debug - Compile and begin debugging main package in current directory, or the package specified.\ndlv exec - Execute a precompiled binary, and begin a debug session.\ndlv replay - Replays a rr trace.\ndlv run - Deprecated command. Use \u0026lsquo;debug\u0026rsquo; instead.\ndlv test - Compile test binary and begin debugging program.\ndlv trace - Compile and begin tracing program.\ndlv version - Prints version.\ndlv log - Help about logging flags\ndlv backend - Help about the --backend flag\n"},{"id":45,"href":"/chapter-4/go-mod/","title":"4.3 آموزش کار با go mod","section":"فصل چهارم: مباحث پیشرفته","content":"از نسخه 1.11 زبان گو مفهوم جدیدی برای مدیریت وابستگی ها آمد و جایگزین GOPATH شد. ماژول های گو این امکان را می دهد خیلی راحت ماژول های مختلف را به پروژه اضافه کنید و نسخه های هر ماژول را مدیریت کنید. با استفاده از ماژول گو برنامه نویسان گو محدود به GOPATH برای توسعه نخواهد بود و در جایی می توانند پروژه خود را ایجاد و ماژول های پروژه را به آسانی مدیریت کند.\nدر زیر یک نمونه از محتوای داخل فایل go.mod را قرار دادیم :\n1module github.com/user/repo 2 3go 1.20 4 5require ( 6 github.com/sirupsen/logrus v1.8.1 7 github.com/spf13/cobra v1.2.1 8) در خط اول نام ماژول می باشد که داخل کد هرجایی که import انجام می دهید نام ماژول اولش قرار می گیرد مانند : 1package cmd 2 3import \u0026#34;github.com/user/repo/internal/app\u0026#34; علت اینکه نام ماژول را آدرس یک مخزن گیت را قرار می دهیم جهت قابل استفاده بودن ماژول می باشد که خیلی ساده بتوانید به پروژه های دیگر ماژولی که نوشتید را اضافه کنید.\nدر خط سوم نسخه زبان گو وجود دارد که شما هر نسخه ای را که تعیین میکنید فقط از ویژگی های همان نسخه به قبل را می توانید استفاده کنید. مثلا شما اگر نسخه 1.17 را گذاشته باشید و قصد داشته باشید از ویژگی جنریک که مربوط به نسخه 1.18 است استفاده کنید, هنگام کامپایل خطا می خورید.\nپس توجه کنید در اینجا سعی کنید از نسخه متناسب با نیاز خود را تعیین کنید هرچند هنگام ایجاد فایل go.mod زبان گو پیش فرض نسخه ای که نصب کرده اید را قرار می دهد.\nدر قسمت require ماژول های خارجی قرار میگیرد که داخل پروژه استفاده کردید. نظیر : github.com/sirupsen/logrus github.com/spf13/cobra به همراه نسخه مشخص اون ماژول.\nاما ماژول گو یک خوبی دارد خیلی راحت می توانید نسخه ماژول ها را به آسانی مدیریت کنید و ارتقا دهید.\nبرای مدیریت ماژول های گو یک کامند داریم به نام mod که یک سری دستورات کمکی برای مدیریت ماژول ها دارد که در ادامه آموزش می دهیم :\n1$ go mod 2Go mod provides access to operations on modules. 3 4Note that support for modules is built into all the go commands, 5not just \u0026#39;go mod\u0026#39;. For example, day-to-day adding, removing, upgrading, 6and downgrading of dependencies should be done using \u0026#39;go get\u0026#39;. 7See \u0026#39;go help modules\u0026#39; for an overview of module functionality. 8 9Usage: 10 11\tgo mod \u0026lt;command\u0026gt; [arguments] 12 13The commands are: 14 15\tdownload download modules to local cache 16\tedit edit go.mod from tools or scripts 17\tgraph print module requirement graph 18\tinit initialize new module in current directory 19\ttidy add missing and remove unused modules 20\tvendor make vendored copy of dependencies 21\tverify verify dependencies have expected content 22\twhy explain why packages or modules are needed 23 24Use \u0026#34;go help mod \u0026lt;command\u0026gt;\u0026#34; for more information about a command. برای اینکه اطلاعات بیشتری در خصوص کامند های go mod کسب کنید کافیه go help mod را قبل از کامند بزارید تا توضیحات بیشتری را ببینید.\n4.3.1 ایجاد go.mod # برای ایجاد فایل go.mod کافیه دستور زیر را در ریشه پروژه بزنید :\n1$ go mod init github.com/user/repo پس از اینکه دستور فوق را زدید یک فایل go.mod ایجاد می شود داخلش محتوای زیر بدون ماژول خارجی می باشد :\n1module github.com/user/repo 2 3go 1.20 4.3.2 افزودن ماژول خارجی به go.mod # برای افزودن یک ماژول خارجی به پروژه کافیه دستور زیر را در محل فایل go.mod بزنید :\n1$ go get github.com/spf13/cobra زمانیکه دستور فوق را می زنید آخرین نسخه ماژول github.com/spf13/cobra را دریافت و به پروژه اضافه می کند.\nدقت کنید وقتی ماژول جدیدی را دریافت می کنید یک فایل go.sum در کنار فایل go.mod ایجاد می شود که داخل این فایل اطلاعات ماژول های خارجی به همراه ساب ماژول ها قرار دارد. که برای اطمینان از یکپارچگی و امنیت وابستگی های مورد استفاده در پروژه Go طراحی شده است. این فایل بصورت خودکار ایجاد و بروز می شود پس بهتر است تغییری در این فایل ندهید. 4.3.3 افزودن ماژول خارجی با تعیین نسخه # با دستور زیر می توانید یک ماژول خارجی با تعیین نسخه به پروژه خود اضافه کنید :\n1$ go get github.com/spf13/cobra@v1.8.1 زمانیکه دستور فوق را می زنید نسخه v1.8.1 ماژول github.com/spf13/cobra را دریافت خواهید کرد.\n4.3.4 آپدیت یک ماژول خارجی به آخرین نسخه # برای آپدیت یک ماژول خارجی به آخرین نسخه کافیه دستور زیر را بزنید :\n1$ go get -u github.com/spf13/cobra در دستور فوق ما سوییچ u- را اضافه کردیم تا آخرین نسخه ماژول github.com/spf13/cobra به پروژه اضافه و جایگزین نسخه های قدیمی شود.\n4.3.5 دستور go mod tidy # یک کامند پر کاربرد به نام tidy داریم که هر زمانی که اجرا می کنید کدهایی که در محل فایل go.mod قرار دارد بررسی می کند و ماژول های ایمپورت شده را به پروژه اضافه می کند و در صورتیکه شما ماژولی را حذف کردید و به هیچ عنوان در پروژه خود استفاده نکردید را از go.mod حذف می کند.\n1$ go mod tidy اگر ماژول خارجی را استفاده کرده باشید در کدهای خود و هنوز به فایل go.mod اضافه نکرده باشید کامند tidy بصورت خودکار آخرین نسخه ماژول خارجی را دریافت و به فایل go.mod اضافه میکند.\n4.3.6 دستور go mod download # با استفاده از این کامند می توانید ماژول های خارجی داخل فایل go.mod را دریافت کرده و در لوکال خود کش کنید. تا بعدا از آن ماژول استفاده کنید.\n1$ go mod download زمانیکه این دستور را بزنید شروع به دانلود ماژول های خارجی می شود و در لوکال شما این ماژول ها ذخیره می شود.\nبرای اینکه بتوانید ببینید وضعیت دانلود تا چه پیشرفته است می توانید سوییچ x- را اضافه کنید تا به شما وضعیت ماژول های در حال دریافت را نمایش دهد :\n1$ go mod download -x 4.3.7 دستور go mod verify # با این دستور شما می توانید وضعیت ماژول ها را بررسی کنید که مورد تایید هست یا نه.\n1$ go mod verify "},{"id":46,"href":"/chapter-4/workspace/","title":"4.4 آموزش کار با workspace","section":"فصل چهارم: مباحث پیشرفته","content":"با استفاده از workspace می توانید همزمان چندین ماژول در یک محل داشته باشید و هر ماژول را به راحتی مدیریت کنید و همچنین همزمان به آسانی این ماژول ها را build و اجرا کنید.\n1$ go help work 2Work provides access to operations on workspaces. 3 4Note that support for workspaces is built into many other commands, not 5just \u0026#39;go work\u0026#39;. 6 7See \u0026#39;go help modules\u0026#39; for information about Go\u0026#39;s module system of which 8workspaces are a part. 9 10See https://go.dev/ref/mod#workspaces for an in-depth reference on 11workspaces. 12 13See https://go.dev/doc/tutorial/workspaces for an introductory 14tutorial on workspaces. 15 16A workspace is specified by a go.work file that specifies a set of 17module directories with the \u0026#34;use\u0026#34; directive. These modules are used as 18root modules by the go command for builds and related operations. A 19workspace that does not specify modules to be used cannot be used to do 20builds from local modules. 21 22go.work files are line-oriented. Each line holds a single directive, 23made up of a keyword followed by arguments. For example: 24 25\tgo 1.18 26 27\tuse ../foo/bar 28\tuse ./baz 29 30\treplace example.com/foo v1.2.3 =\u0026gt; example.com/bar v1.4.5 31 32The leading keyword can be factored out of adjacent lines to create a block, 33like in Go imports. 34 35\tuse ( 36\t../foo/bar 37\t./baz 38\t) 39 40The use directive specifies a module to be included in the workspace\u0026#39;s 41set of main modules. The argument to the use directive is the directory 42containing the module\u0026#39;s go.mod file. 43 44The go directive specifies the version of Go the file was written at. It 45is possible there may be future changes in the semantics of workspaces 46that could be controlled by this version, but for now the version 47specified has no effect. 48 49The replace directive has the same syntax as the replace directive in a 50go.mod file and takes precedence over replaces in go.mod files. It is 51primarily intended to override conflicting replaces in different workspace 52modules. 53 54To determine whether the go command is operating in workspace mode, use 55the \u0026#34;go env GOWORK\u0026#34; command. This will specify the workspace file being 56used. 57 58Usage: 59 60\tgo work \u0026lt;command\u0026gt; [arguments] 61 62The commands are: 63 64\tedit edit go.work from tools or scripts 65\tinit initialize workspace file 66\tsync sync workspace build list to modules 67\tuse add modules to workspace file 68 69Use \u0026#34;go help work \u0026lt;command\u0026gt;\u0026#34; for more information about a command. پیش نیاز ها\nبرای استفاده از workspace حتما باید از نسخه 1.18 گو استفاده کنید. یک ابزار ادیت برای کار باید داشته باشید یک ترمینال مناسب جهت اجرا دستورات 4.4.1 ایجاد workspace # برای ایجاد یک workspace کافیه دستور زیر را بزنید تا در محل پروژه یک فایل go.work ایجاد شود.\n1$ go work init 4.4.2 افزودن ماژول به workspace # در محل workspace یک پوشه ایجاد کنید و دستور go mod init را بزنید تا ماژول ایجاد شود و داخل این محل کدهای ماژول خود را قرار دهید. سپس با دستور go work use می توانید ماژول خود را به workspace اضافه کنید.\n1go work use ./module1 زمانیکه دستور فوق را بزنید پوشه module1 که داخلش ماژول از قبل ایجاد شده به فایل go.work اضافه می شود.\nحال اگر دستور زیر را بزنید می توانید آن ماژول را اگر پکیج main داشته باشد را می تواند اجرا کند :\n1$ go run ./module1 "},{"id":47,"href":"/chapter-4/vendor/","title":"4.5 آموزش کار با Vendor","section":"فصل چهارم: مباحث پیشرفته","content":"در زبان گو یک کامند کاربردی در go mod به نام vendor داریم که ماژول هایی که داخل پروژه استفاده شده و مورد نیاز برای اجرا و بیلد می باشد را در محل پروژه کش می کند و به شما این امکان را می دهد خیلی سریع و راحت بدون نیاز به دانلود مجدد ماژول پروژه را بیلد و اجرا کنید.\n1$ go help mod vendor 2usage: go mod vendor [-e] [-v] [-o outdir] 3 4Vendor resets the main module\u0026#39;s vendor directory to include all packages 5needed to build and test all the main module\u0026#39;s packages. 6It does not include test code for vendored packages. 7 8The -v flag causes vendor to print the names of vendored 9modules and packages to standard error. 10 11The -e flag causes vendor to attempt to proceed despite errors 12encountered while loading packages. 13 14The -o flag causes vendor to create the vendor directory at the given 15path instead of \u0026#34;vendor\u0026#34;. The go command can only use a vendor directory 16named \u0026#34;vendor\u0026#34; within the module root directory, so this flag is 17primarily useful for other tools. 18 19See https://golang.org/ref/mod#go-mod-vendor for more about \u0026#39;go mod vendor\u0026#39;. 4.5.1 ایجاد vendor # با دستور زیر می توانید در محل پروژه خود پوشه vendor ایجاد کنید و ماژول های استفاده شده را داخل این پوشه کش کنید.\n1$ go mod vendor 4.5.2 افزودن ماژول های جدید به vendor # در صورتیکه ماژول جدیدی را به پروژه اضافه کردید حتما باید بصورت دستی vendor را بروز کنید و کافیه دستور زیر را بزنید :\n1$ go mod vendor 4.5.3 اجرا و بیلد پروژه با vendor # شما می توانید پروژه خود را با ماژول های کش شده داخل vendor اجرا و بیلد کنید و دیگر نیازی به دریافت ماژول ها و کش کردن محلی نمی باشد.\nنحوه بیلد\n1$ go build -mod vendor -o main cmd/main.go نحوه اجرا\n1$ go run -mod vendor main.go 4.5.4 نکات کاربردی # یکسری نکات در خصوص استفاده از vendor قرار دادم که به شما می کند تا از vendor به درستی استفاده کنید.\nاز vendor فقط برای پروژه ای استفاده کنید که می خواهد در محیط های مختلف اجرا شود. استفاده از vendor باعث افزایش سریع روند CI/CD هنگام بیلد و تست می شود. زمانیکه vendor ایجاد می کنید فایل بخش های استفاده شده هر ماژول خارجی قرار میگیرد و باعث می شود حجم vendor خیلی کم باشد (پس نگران اینکه vendor مانند npm_module است نباشید) استفاده vendor به IDE گولند کمک می کند در زمان باز کردن پروژه با سرعت بیشتری ماژول ها را index کرده و کدها را سریعتر اسکن کند "},{"id":48,"href":"/chapter-4/command-line-go/","title":"4.6 آموزش نوشتن برنامه command line","section":"فصل چهارم: مباحث پیشرفته","content":" 4.6.1 مقدمه # هنگامی که می‌خواهید نرم‌افزاری بنویسید، ممکن است بخواهید از محیط Command Line یا خط فرمان استفاده کنید. خط فرمان، رابط کاربری ساده‌تری نسبت به محیط گرافیکی دارد و در برخی موارد، سرعت بخش بسیار قابل توجهی است. برای آموزش نوشتن برنامه در خط فرمان، شما به یک زبان برنامه‌نویسی نیاز دارید که از بسیاری از کانسپت‌هایی که در برنامه‌نویسی استفاده می‌شوند، پشتیبانی کند. ما به شما پیشنهاد می‌دهیم که از زبان برنامه‌نویسی Go استفاده کنید زیرا برای کار با Command Line بسیار مناسب است.\nآموزش نوشتن برنامه Command Line به کمک زبان برنامه‌نویسی گو:\nدر اینجا، ما یک مثال ساده از برنامه Hello World با استفاده از Go و Command Line ارائه می‌دهیم. این برنامه، یک پیام ساده را به صفحه نمایش خط فرمان چاپ می‌کند.\nاولین چیزی که شما باید در نظر داشته باشید این است که برنامه‌ی شما باید یک فایل با پسوند .go باشد. برای مثال، می‌توانید یک فایل با نام helloworld.go ایجاد کنید.\nبعد از ایجاد فایل، شما باید کد زیر را به فایل خود اضافه کنید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tfmt.Println(\u0026#34;Hello, World!\u0026#34;) 7} 1$ go run helloworld.go 2Hello, World! اگر کد بالا را به فایل helloworld.go اضافه کردید، می‌توانید با استفاده از Command Line، فایل را اجرا کنید. برای اجرای فایل، ابتدا باید به دایرکتوری فایل برید. سپس می‌توانید دستور برای اجرای فایل را وارد کنید.\nبرای مثال، فرض کنید فایل helloworld.go در دایرکتوری Documents قرار دارد. به عنوان نوشته، این دستورات را در Command Line وارد کنید:\n$ cd Documents\n$ go run helloworld.go\nبا اجرای دستور بالا، برنامه شما اجرا خواهد شد و پیام \u0026ldquo;Hello, World!\u0026rdquo; را در Command Line چاپ می‌کند.\nنتیجه‌گیری:\nاستفاده از خط فرمان برای نوشتن برنامه‌های شما می‌تواند بسیار مفید باشد، اگر یادگیری زبان برنامه‌نویسی Go و چگونگی کار با Command Line را یاد بگیرید. در این مقاله، به شما یک مثال ساده از نوشتن برنامه Command Line با استفاده از Go برای شروع ارائه شد. با ادامه‌ی یادگیری زبان برنامه نویسی Go، شما می‌توانید برنامه‌های پیچیده‌تر را با استفاده از Command Line بسازید.\n4.6.2 نحوه گرفتن arguments به عنوان ورودی از ترمینال # برای گرفتن ورودی از Command Line به عنوان Argument در یک برنامه Go، شما می‌توانید از پایگاه‌داده os در Go استفاده کنید. برای دسترسی به Argumentها، شما می‌توانید متغیرهای os.Args را استفاده کنید. آرایه‌ی os.Args شامل تمامی Argumentهایی است که در Command Line به برنامه شما داده شده است. در زیر، یک مثال ساده از گرفتن دو Argument از Command Line در یک برنامه Go آورده شده است:\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;os\u0026#34; 6) 7 8func main() { 9\targs := os.Args 10\tfmt.Println(\u0026#34;First Argument:\u0026#34;, args[1]) 11\tfmt.Println(\u0026#34;Second Argument:\u0026#34;, args[2]) 12} 1$ go run main.go hello world 2First Argument: hello 3Second Argument: world در کد بالا، ابتدا، ما متغیر os.Args را به متغیر args اختصاص داده‌ایم. سپس، با استفاده از این متغیر، ما مقادیر دو Argument اول را چاپ کرده‌ایم. در اینجا، args[0] نام برنامه Go در Command Line است، بنابراین اولین Argument بعد از آن در args[1] و دومین Argument در args[2] قرار دارد. با تغییر این شماره‌ها، شما می‌توانید به Argument‌های دیگر در Command Line دسترسی داشته باشید.\n4.6.3 کار با flag در زبان گو # در زبان Go، شما می‌توانید از پکیج flag برای ایجاد و مدیریت Flagها در Command Line استفاده کنید. با استفاده از قابلیت Flag، شما می‌توانید به آرگومان های اختیاری و پارامترهای Command Line برنامه خود دسترسی پیدا کنید.\nدر پکیج flag، سه نوع Flag مختلف وجود دارند: string، bool و int. برای ایجاد یک Flag از هر نوع، می‌توانید از توابع flag.String، flag.Bool و flag.Int استفاده کنید.\nدر مثال زیر، ما به کمک Flag یک رشته، یک boolean و یک integer را تعریف و مقداردهی اولیه آن‌ها را انجام می‌دهیم:\n1package main 2 3import ( 4\t\u0026#34;flag\u0026#34; 5\t\u0026#34;fmt\u0026#34; 6) 7 8func main() { 9\t// تعریف یک Flag رشته برای نام کاربری 10\tuserName := flag.String(\u0026#34;username\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;نام کاربری\u0026#34;) 11 12\t// تعریف یک Flag boolean برای پرینت نتیجه 13\tprintResult := flag.Bool(\u0026#34;print\u0026#34;, false, \u0026#34;پرینت نتیجه؟\u0026#34;) 14 15\t// تعریف یک Flag integer برای تعداد تکرار 16\trepeatCount := flag.Int(\u0026#34;count\u0026#34;, 1, \u0026#34;تعداد تکرار\u0026#34;) 17 18\tflag.Parse() 19 20\t// استفاده از Flag ها 21\tfmt.Println(\u0026#34;نام کاربری:\u0026#34;, *userName) 22\tfmt.Println(\u0026#34;پرینت نتیجه؟\u0026#34;, *printResult) 23\tfmt.Println(\u0026#34;تعداد تکرار:\u0026#34;, *repeatCount) 24} 1$ go run main.go -username=John -print=true -count=5 2نام کاربری: john 3پرینت نتیجه؟true 4تعداد تکرار:5 در مثال بالا، ما سه Flag ایجاد کرده‌ایم: username، print و count که به ترتیب متناظر با یک رشته، یک boolean و یک integer هستند. پارامتر اول تابع هر Flag نام آن است، پارامتر دوم مقدار پیش‌فرض و پارامتر سوم توضیحاتی در مورد Flag است.\nدر انتهای برنامه، با استفاده از تابع flag.Parse()، مقدار داده‌شده به Flagها از Command Line دریافت و مقداردهی به متغیرهای var استفاده شده در Flagها انجام می‌گیرد. در مثال بالا، ما با استفاده از اپراتور * به مقدار داده‌شده به هر Flag دریافت شده از Command Line دسترسی پیدا می‌کنیم.\nبا اجرای برنامه و وارد کردن یک Command Line مخصوص مثل زیر، می‌توانید مقدارهای مختلفی به Flagهای برنامه خود اختصاص دهید.\nدر این مثال، مقدار Flag username برابر با \u0026ldquo;John\u0026rdquo;، print برابر با true و count برابر با ۵ می‌باشد.\n"},{"id":49,"href":"/chapter-4/work-with-file-in-go/","title":"4.7 آموزش کار با فایل","section":"فصل چهارم: مباحث پیشرفته","content":" 4.7.1 مقدمه # توسعه دهندگان Go می‌توانند از پکیج‌های built-in مانند \u0026ldquo;os\u0026rdquo; و \u0026ldquo;io\u0026rdquo; برای کار با فایل‌ها استفاده کنند. همچنین، پکیج‌های دیگری نیز برای کار با فایل وجود دارند که می‌توان به عنوان پکیج استاندارد نامید. نمونه ای از این پکیج‌ها، پکیج \u0026ldquo;bufio\u0026rdquo; است که برای کار با بافرهای ورودی/خروجی استفاده شده و به توسعه دهندگان اجازه می‌دهد تا برنامه‌هایی با عملکرد بهتر و با کارایی بالاتر ایجاد کنند.\n4.7.2 باز کردن فایل و خواندن محتوای فایل با پکیج os # برای باز کردن یک فایل متنی و خواندن محتوای آن، می‌توانیم از پکیج \u0026ldquo;os\u0026rdquo; و متد \u0026ldquo;Open\u0026rdquo; استفاده کنیم. در کد زیر، ما یک فایل به نام \u0026ldquo;example.txt\u0026rdquo; باز می‌کنیم و محتوای آن را به صورت خط به خط خوانده و به صفحه کنسول چاپ می‌کنیم:\n1package main 2 3import ( 4\t\u0026#34;bufio\u0026#34; 5\t\u0026#34;fmt\u0026#34; 6\t\u0026#34;log\u0026#34; 7\t\u0026#34;os\u0026#34; 8) 9 10func main() { 11\t// باز کردن فایل برای خواندن 12\tfile, err := os.Open(\u0026#34;example.txt\u0026#34;) 13\tif err != nil { 14\tlog.Fatal(err) 15\t} 16\tdefer file.Close() 17 18\t// خواندن خط به خط از فایل 19\tscanner := bufio.NewScanner(file) 20\tfor scanner.Scan() { 21\tfmt.Println(scanner.Text()) 22\t} 23 24\tif err := scanner.Err(); err != nil { 25\tlog.Fatal(err) 26\t} 27} در کد بالا، با استفاده از متد \u0026ldquo;os.Open\u0026rdquo;، فایل \u0026ldquo;example.txt\u0026rdquo; برای خواندن به صورت فایل شیء باز می‌شود. سپس، با استفاده از متد \u0026ldquo;bufio.NewScanner\u0026rdquo; محتوای فایل به شیء \u0026ldquo;scanner\u0026rdquo; انتقال داده می‌شود و در نهایت با استفاده از حلقه، محتوای فایل خوانده شده خط به خط و به صورت متنی چاپ می‌شود.\nدر نهایت، با استفاده از \u0026ldquo;scanner.Err\u0026rdquo;، خطاهایی که در پروسه خواندن ممکن است بوجود آیند، بررسی شده و مورد احتیاط قرار می‌گیرند.\n4.7.3 نحوه ایجاد فایل و نوشتن محتوا داخل فایل با os # برای ایجاد یک فایل جدید و نوشتن محتوای دلخواه در آن، می‌توانیم از پکیج \u0026ldquo;os\u0026rdquo; و متدهای آن استفاده کنیم. در کد زیر، یک فایل با نام \u0026ldquo;example.txt\u0026rdquo; ساخته شده و پس از باز شدن، متن \u0026ldquo;Hello, World!\u0026rdquo; در داخل آن نوشته می‌شود:\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;os\u0026#34; 6) 7 8func main() { 9\t// ساخت فایل با نام example.txt 10\tfile, err := os.Create(\u0026#34;example.txt\u0026#34;) 11\tif err != nil { 12\tfmt.Println(err) 13\treturn 14\t} 15\tdefer file.Close() 16 17\t// نوشتن محتوا در فایل 18\tfmt.Fprintln(file, \u0026#34;Hello, World!\u0026#34;) 19} در کد بالا، با استفاده از متد \u0026ldquo;os.Create\u0026rdquo;، یک فایل با نام \u0026ldquo;example.txt\u0026rdquo; ایجاد شده و به عنوان یک فایل شیء باز شده است. سپس با استفاده از متد \u0026ldquo;fmt.Fprintln\u0026rdquo;، متن \u0026ldquo;Hello, World!\u0026rdquo; در داخل فایل نوشته می‌شود.\nدر نهایت، با استفاده از \u0026ldquo;file.Close\u0026rdquo;، فایل بسته شده و تمام تغییرات آن ذخیره می‌شود.\n4.7.4 خواندن و نوشتن فایل با استفاده از پکیج io # برای خواندن و نوشتن فایل‌ها می‌توان از پکیج \u0026ldquo;io\u0026rdquo; استفاده کرد. این پکیج امکانات بسیاری را برای کار با بیت‌ها و داده‌های ورودی/خروجی فراهم می‌کند. در کد زیر، یک فایل با نام \u0026ldquo;example.txt\u0026rdquo; باز شده و محتوای آن خوانده شده و به فایل دیگری با نام \u0026ldquo;output.txt\u0026rdquo; کپی می‌شود:\n1package main 2 3import ( 4\t\u0026#34;io\u0026#34; 5\t\u0026#34;log\u0026#34; 6\t\u0026#34;os\u0026#34; 7) 8 9func main() { 10\t// باز کردن فایل برای خواندن 11\tinputFile, err := os.Open(\u0026#34;example.txt\u0026#34;) 12\tif err != nil { 13\tlog.Fatal(err) 14\t} 15\tdefer inputFile.Close() 16 17\t// باز کردن فایل برای نوشتن 18\toutputFile, err := os.Create(\u0026#34;output.txt\u0026#34;) 19\tif err != nil { 20\tlog.Fatal(err) 21\t} 22\tdefer outputFile.Close() 23 24\t// کپی کردن اطلاعات از فایل ورودی به فایل خروجی 25\t_, err = io.Copy(outputFile, inputFile) 26\tif err != nil { 27\tlog.Fatal(err) 28\t} 29} در کد بالا، با استفاده از متدهای \u0026ldquo;os.Open\u0026rdquo; و \u0026ldquo;os.Create\u0026rdquo;، فایل‌های ورودی و خروجی باز شده و به عنوان فایل شیء به برنامه اضافه شده‌اند. سپس با استفاده از متد \u0026ldquo;io.Copy\u0026rdquo;، اطلاعات از فایل ورودی، به فایل خروجی کپی شده‌اند.\nدر نهایت، با استفاده از \u0026ldquo;defer\u0026rdquo; و \u0026ldquo;Close\u0026rdquo;، فایل‌ها بسته شده‌اند و تغییرات آن‌ها ذخیره شده‌اند.\n"},{"id":50,"href":"/chapter-4/work-with-json-file-in-go/","title":"4.8 آموزش کار با json","section":"فصل چهارم: مباحث پیشرفته","content":" 4.8.1 مقدمه # JSON یک فرمت متنی است که برای مبادله و ذخیره داده‌ها استفاده می‌شود. نام JSON مخفف عبارت JavaScript Object Notation است و در ابتدا به عنوان یک زبان مبتنی بر جاوااسکریپت توسعه یافته است. با این حال، در حال حاضر JSON به راحتی با بیشتر زبان‌های برنامه‌نویسی سازگار است.\nJSON یک مجموعه از جفت‌های «key: value» است که با کاما از یکدیگر جدا شده‌اند و بین آنها با «:» ارتباط دارند. JSON در بین برنامه‌نویسان به عنوان یک ساختار داده‌ای محبوب است و به راحتی داده‌ها را به صورت ساختاردهی شده در برنامه‌های کاربردی مختلف به کار می‌رود. این فرمت دیتا استاندارد و مستقل از زبان‌ها و پلتفرم‌های برنامه‌نویسی است و برای برنامه‌های تحت وب، موبایل، دسکتاپ و سرور قابل استفاده است.\nساختار یک فایل JSON شامل تعدادی از آبجکت‌ها و آرایه‌ها می‌باشد. به عبارتی داده‌های JSON می‌توانند در سه نوع اصلی “جسم آرکی”(object) ، “کالکشن آرای”(array) و “مقادیر اولیه”(values) تعریف شوند. آبجکت یک گروه از خصوصیات است که دارای یک کلید منحصر به فرد به عنوان “عنوان شی” می‌باشد. همچنین، آرایه نیز به مشابه یک لیست یا آرایه از خصوصیات است.\nیک مثال ساده JSON:\n1{ 2 \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, 3 \u0026#34;age\u0026#34;: 30, 4 \u0026#34;email\u0026#34;: \u0026#34;johndoe@example.com\u0026#34;, 5 \u0026#34;address\u0026#34;: { 6 \u0026#34;street\u0026#34;: \u0026#34;123 Main St\u0026#34;, 7 \u0026#34;city\u0026#34;: \u0026#34;Anytown\u0026#34;, 8 \u0026#34;state\u0026#34;: \u0026#34;CA\u0026#34;, 9 \u0026#34;zip\u0026#34;: \u0026#34;12345\u0026#34; 10 }, 11 \u0026#34;phone\u0026#34;: [ 12 { 13 \u0026#34;type\u0026#34;: \u0026#34;home\u0026#34;, 14 \u0026#34;number\u0026#34;: \u0026#34;555-555-1234\u0026#34; 15 }, 16 { 17 \u0026#34;type\u0026#34;: \u0026#34;work\u0026#34;, 18 \u0026#34;number\u0026#34;: \u0026#34;555-555-5678\u0026#34; 19 } 20 ] 21} در این مثال، یک شیء با عنوان \u0026ldquo;John Doe\u0026rdquo; تعریف شده است. این شیء دارای خصوصیاتی همچون نام، سن، ایمیل، آدرس و تلفن است. آدرس نیز یک شیء است که شامل خصوصیاتی همچون خیابان، شهر، ایالت و کد پستی است. همچنین، تلفن به عنوان یک آرایه از شیء‌ها تعریف شده است که شامل نوع تلفن و شماره تلفن است.\n4.8.2 کار با marshal و unmarshal پکیج json # در زبان برنامه‌نویسی Go، پکیج \u0026ldquo;encoding/json\u0026rdquo; برای کار با داده‌های JSON بسیار مفید است. این پکیج امکاناتی برای تبدیل داده‌های Go به فرمت JSON (marshal) و برعکس (unmarshal) در اختیار برنامه‌نویسان قرار می‌دهد.\n4.8.2.1 کار با marshal # با استفاده از تابع \u0026ldquo;Marshal\u0026rdquo;، برای مثال، می‌توان یک شیء با فرمت JSON تولید کرد. در کد زیر، یک شیء از نوع \u0026ldquo;person\u0026rdquo; تعریف شده است و با استفاده از تابع \u0026ldquo;Marshal\u0026rdquo; به فرمت JSON تبدیل شده است:\n1package main 2 3import ( 4 \u0026#34;encoding/json\u0026#34; 5 \u0026#34;fmt\u0026#34; 6) 7 8type person struct { 9 Name string `json:\u0026#34;name\u0026#34;` 10 Age int `json:\u0026#34;age\u0026#34;` 11 Email string `json:\u0026#34;email\u0026#34;` 12} 13 14func main() { 15 p := \u0026amp;person{Name: \u0026#34;John Doe\u0026#34;, Age: 30, Email: \u0026#34;john.doe@example.com\u0026#34;} 16 17 b, err := json.Marshal(p) 18 if err != nil { 19 fmt.Println(\u0026#34;error:\u0026#34;, err) 20 } 21 22 fmt.Println(string(b)) 23} 1$ go run main.go 2{\u0026#34;name\u0026#34;:\u0026#34;John Doe\u0026#34;,\u0026#34;age\u0026#34;:30,\u0026#34;email\u0026#34;:\u0026#34;john.doe@example.com\u0026#34;} در کد بالا، ابتدا یک شیء از نوع \u0026ldquo;person\u0026rdquo; با مقادیر مشخص تعریف شده است. سپس از تابع \u0026ldquo;Marshal\u0026rdquo; برای تبدیل این شیء به فرمت JSON استفاده شده است. خروجی تابع \u0026ldquo;Marshal\u0026rdquo; یک بایت‌آرایه است که به عنوان یک رشته و با استفاده از تبدیل به \u0026ldquo;string\u0026rdquo; چاپ شده است.\n4.8.2.2 کار با unmarshal # با استفاده از تابع \u0026ldquo;Unmarshal\u0026rdquo; نیز می‌توان یک رشته JSON را به شیء Go تبدیل کرد. در کد زیر، یک رشته JSON با نام \u0026ldquo;data\u0026rdquo; تعریف شده است و با استفاده از تابع \u0026ldquo;Unmarshal\u0026rdquo; به یک شیء از نوع \u0026ldquo;person\u0026rdquo; تبدیل شده است:\n1package main 2 3import ( 4 \u0026#34;encoding/json\u0026#34; 5 \u0026#34;fmt\u0026#34; 6) 7 8type person struct { 9 Name string `json:\u0026#34;name\u0026#34;` 10 Age int `json:\u0026#34;age\u0026#34;` 11 Email string `json:\u0026#34;email\u0026#34;` 12} 13 14func main() { 15 data := `{\u0026#34;name\u0026#34;:\u0026#34;John Doe\u0026#34;,\u0026#34;age\u0026#34;:30,\u0026#34;email\u0026#34;:\u0026#34;john.doe@example.com\u0026#34;}` 16 17 var p person 18 err := json.Unmarshal([]byte(data), \u0026amp;p) 19 if err != nil { 20 fmt.Println(\u0026#34;error:\u0026#34;, err) 21 } 22 23 fmt.Println(p.Name, p.Age, p.Email) 24} 1$ go run main.go 2John Doe 30 john.doe@example.com در کد بالا، ابتدا یک رشته JSON با نام \u0026ldquo;data\u0026rdquo; تعریف شده است. سپس یک شیء از نوع \u0026ldquo;person\u0026rdquo; با استفاده از تابع \u0026ldquo;Unmarshal\u0026rdquo; و با این رشته JSON به شکل مقداردهی شده است. خروجی تابع \u0026ldquo;Unmarshal\u0026rdquo;، شیء \u0026ldquo;person\u0026rdquo; است که بعداً در کد چاپ شده است. توجه داشته باشید که در اینجا از \u0026ldquo;[]byte\u0026rdquo; برای تبدیل رشته به بایت‌آرایه استفاده شده است.\n4.8.3 تبدیل آرایه و slice به json # در Go، می‌توان آرایه‌ها و slice‌ها را به فرمت JSON تبدیل کرد. برای این کار، از تابع \u0026ldquo;Marshal\u0026rdquo; پکیج \u0026ldquo;encoding/json\u0026rdquo; استفاده می‌شود.\nبرای مثال، فرض کنید یک slice‌ از اعداد صحیح داشته باشیم. برای تبدیل این slice به فرمت JSON، کد زیر نمونه‌ای از چگونگی استفاده از تابع \u0026ldquo;Marshal\u0026rdquo; را نشان می‌دهد:\n1package main 2 3import ( 4 \u0026#34;encoding/json\u0026#34; 5 \u0026#34;fmt\u0026#34; 6) 7 8func main() { 9 numbers := []int{1, 2, 3, 4, 5} 10 11 data, err := json.Marshal(numbers) 12 if err != nil { 13 fmt.Println(\u0026#34;error:\u0026#34;, err) 14 } 15 16 fmt.Println(string(data)) 17} 1$ go run main.go 2[1,2,3,4,5] در این کد، ابتدا یک slice‌ از اعداد صحیح تعریف شده است. سپس با استفاده از تابع \u0026ldquo;Marshal\u0026rdquo; این slice‌ به فرمت JSON تبدیل شده و در متغیر \u0026ldquo;data\u0026rdquo; ذخیره شده است. در نهایت، با استفاده از تبدیل به \u0026ldquo;string\u0026rdquo;، خروجی تابع \u0026ldquo;Marshal\u0026rdquo; به صورت یک رشته چاپ شده است.\nهمچنین، می‌توان آرایه‌های چند بعدی را نیز به فرمت JSON تبدیل کرد. در کد زیر، یک آرایه دوبعدی از اعداد صحیح تعریف شده است و به فرمت JSON تبدیل می‌شود:\n1package main 2 3import ( 4 \u0026#34;encoding/json\u0026#34; 5 \u0026#34;fmt\u0026#34; 6) 7 8func main() { 9 var matrix [2][3]int = [2][3]int{{1, 2, 3}, {4, 5, 6}} 10 11 data, err := json.Marshal(matrix) 12 if err != nil { 13 fmt.Println(\u0026#34;error:\u0026#34;, err) 14 } 15 16 fmt.Println(string(data)) 17} 1$ go run main.go 2[[1,2,3],[4,5,6]] در این کد نیز، بعد از تعریف یک آرایه دوبعدی از اعداد صحیح، با استفاده از تابع \u0026ldquo;Marshal\u0026rdquo; آن را به فرمت JSON تبدیل شده و در متغیر \u0026ldquo;data\u0026rdquo; ذخیره شده است. خروجی تابع \u0026ldquo;Marshal\u0026rdquo; نیز به صورت یک رشته چاپ می‌شود.\n4.8.4 تبدیل map به json # در Go، می‌توان map را به فرمت JSON تبدیل کرد با استفاده از تابع \u0026ldquo;Marshal\u0026rdquo; در پکیج \u0026ldquo;encoding/json\u0026rdquo; میتوان این کار را انجام داد.\nبرای مثال، فرض کنید یک map از داده‌های شخصی داشته باشیم که شامل نام، سن و ایمیل است. برای تبدیل این map به فرمت JSON، کد زیر نمونه‌ای از چگونگی استفاده از تابع \u0026ldquo;Marshal\u0026rdquo; را نشان می‌دهد:\n1package main 2 3import ( 4 \u0026#34;encoding/json\u0026#34; 5 \u0026#34;fmt\u0026#34; 6) 7 8func main() { 9 data := map[string]interface{}{ 10 \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, 11 \u0026#34;age\u0026#34;: 30, 12 \u0026#34;email\u0026#34;: \u0026#34;john.doe@example.com\u0026#34;, 13 } 14 15 output, err := json.Marshal(data) 16 if err != nil { 17 fmt.Println(\u0026#34;error:\u0026#34;, err) 18 } 19 20 fmt.Println(string(output)) 21} 1$ go run main.go 2{\u0026#34;age\u0026#34;:30,\u0026#34;email\u0026#34;:\u0026#34;john.doe@example.com\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;John Doe\u0026#34;} در کد بالا، یک map از داده‌های شخصی با نام \u0026ldquo;data\u0026rdquo; تعریف شده است و سپس با استفاده از تابع \u0026ldquo;Marshal\u0026rdquo; به فرمت JSON تبدیل شده است. خروجی تابع \u0026ldquo;Marshal\u0026rdquo; نیز به صورت یک رشته چاپ شده است.\nتوجه داشته باشید که در این نمونه، نوع داده‌ی مقدارهای مپ از نوع خاصی استفاده نشده است و به جای آن، از نوع \u0026ldquo;interface{}\u0026rdquo; برای مقادیر استفاده شده است. این به این دلیل است که ممکن است مقادیر مختلفی در map وجود داشته باشد ولی نوعشان کاملاً شناخته شده نباشد. با استفاده از \u0026ldquo;interface{}\u0026quot;، مقادیر به صورت پویا تعریف شده و برنامه قادر است به درستی تبدیل را انجام دهد.\n4.8.5 کتابخانه GJSON # استفاده از فرمت json در زبان برنامه نویسی گو به راحتی استفاده از این فرمت در سایر زبان های برنامه نویسی دیگر مثل پایتون نیست و برای اینکه این مورد ساده‌تر شود توصیه میشود از کتابخانه GJSON استفاده شود.\nکتابخانه GJSON یک بسته Go است که راهی سریع و ساده برای دریافت مقادیر از یک سند json ارائه می دهد. دارای ویژگی هاییone line retrieval, dot notation paths, iteration,، و parsing json lines است.\nاین توضیحات یک نمای کلی از نحوه استفاده از GJSON است، برای اطلاعات بیشتر،GJSON Syntax را بررسی کنید.\n4.8.5.1 راه اندازی و نصب GJSON # برای نصب می توانیم از کد زیر استفاده کنیم.\n1go get -u github.com/tidwall/gjson با این کار کتابخانه نصب می شود.\n4.8.5.2 خواندن مقادیر با GJSON # برای جستجوی مقدار مورد نظر json را برای آدرس یا فایل مشخص شده دریافت کنید. کافیست کلید های تو در تو را تنها توسط یک نقطه، مانند \u0026rsquo;name.last\u0026rsquo; یا \u0026lsquo;age\u0026rsquo; فراخوانی کرده و مقدار درون آن را بدست آورید. به عنوان مثال در کد زیر:\n1package main 2 3import \u0026#34;github.com/tidwall/gjson\u0026#34; 4 5const json = `{\u0026#34;name\u0026#34;:{\u0026#34;first\u0026#34;:\u0026#34;Janet\u0026#34;,\u0026#34;last\u0026#34;:\u0026#34;Prichard\u0026#34;},\u0026#34;age\u0026#34;:47}` 6 7func main() { 8\tvalue := gjson.Get(json, \u0026#34;name.last\u0026#34;) 9\tprintln(value.String()) 10} خروجی به صورت زیر خواهد بود:\n1Prichard همچنین تابع GetMany برای دریافت چندین مقدار در یک زمان و GetBytes برای کار با slices بایت JSON وجود دارد.\n4.8.5.3 Path Syntax # در زیر یک نمای کلی از path syntax ارائه شده است، برای اطلاعات کامل تر لطفاً GJSON Syntax را بررسی کنید.\nیک path مجموعه ای از کلیدها است که با یک نقطه از هم جدا شده اند. یک کلید ممکن است حاوی کاراکترهای ویژه \u0026lsquo;*\u0026rsquo; و \u0026lsquo;؟\u0026rsquo; باشد. برای دسترسی به مقدار آرایه از شاخص به عنوان کلید استفاده کنید. برای به دست آوردن تعداد عناصر در یک آرایه یا دسترسی به یک path فرزند، از کاراکتر \u0026lsquo;#\u0026rsquo; استفاده کنید. کاراکترهای dot و wildcard را می توان با \u0026rsquo;\u0026rsquo; escape کرد.\n‍‍\n1{ 2 \u0026#34;name\u0026#34;: {\u0026#34;first\u0026#34;: \u0026#34;Tom\u0026#34;, \u0026#34;last\u0026#34;: \u0026#34;Anderson\u0026#34;}, 3 \u0026#34;age\u0026#34;:37, 4 \u0026#34;children\u0026#34;: [\u0026#34;Sara\u0026#34;,\u0026#34;Alex\u0026#34;,\u0026#34;Jack\u0026#34;], 5 \u0026#34;fav.movie\u0026#34;: \u0026#34;Deer Hunter\u0026#34;, 6 \u0026#34;friends\u0026#34;: [ 7 {\u0026#34;first\u0026#34;: \u0026#34;Dale\u0026#34;, \u0026#34;last\u0026#34;: \u0026#34;Murphy\u0026#34;, \u0026#34;age\u0026#34;: 44, \u0026#34;nets\u0026#34;: [\u0026#34;ig\u0026#34;, \u0026#34;fb\u0026#34;, \u0026#34;tw\u0026#34;]}, 8 {\u0026#34;first\u0026#34;: \u0026#34;Roger\u0026#34;, \u0026#34;last\u0026#34;: \u0026#34;Craig\u0026#34;, \u0026#34;age\u0026#34;: 68, \u0026#34;nets\u0026#34;: [\u0026#34;fb\u0026#34;, \u0026#34;tw\u0026#34;]}, 9 {\u0026#34;first\u0026#34;: \u0026#34;Jane\u0026#34;, \u0026#34;last\u0026#34;: \u0026#34;Murphy\u0026#34;, \u0026#34;age\u0026#34;: 47, \u0026#34;nets\u0026#34;: [\u0026#34;ig\u0026#34;, \u0026#34;tw\u0026#34;]} 10 ] 11} 1\u0026#34;name.last\u0026#34; \u0026gt;\u0026gt; \u0026#34;Anderson\u0026#34; 2\u0026#34;age\u0026#34; \u0026gt;\u0026gt; 37 3\u0026#34;children\u0026#34; \u0026gt;\u0026gt; [\u0026#34;Sara\u0026#34;,\u0026#34;Alex\u0026#34;,\u0026#34;Jack\u0026#34;] 4\u0026#34;children.#\u0026#34; \u0026gt;\u0026gt; 3 5\u0026#34;children.1\u0026#34; \u0026gt;\u0026gt; \u0026#34;Alex\u0026#34; 6\u0026#34;child*.2\u0026#34; \u0026gt;\u0026gt; \u0026#34;Jack\u0026#34; 7\u0026#34;c?ildren.0\u0026#34; \u0026gt;\u0026gt; \u0026#34;Sara\u0026#34; 8\u0026#34;fav\\.movie\u0026#34; \u0026gt;\u0026gt; \u0026#34;Deer Hunter\u0026#34; 9\u0026#34;friends.#.first\u0026#34; \u0026gt;\u0026gt; [\u0026#34;Dale\u0026#34;,\u0026#34;Roger\u0026#34;,\u0026#34;Jane\u0026#34;] 10\u0026#34;friends.1.last\u0026#34; \u0026gt;\u0026gt; \u0026#34;Craig\u0026#34; همچنین می‌توانید با استفاده از #(...), آرایه‌ای را برای پیدا کردن اولین match یا تطابق مورد نظر بررسی کنید، یا همه موارد مورد نظر را با #(...)# را پیدا کنید. کوئری ها از عملگرهای مقایسه ==, !=, \u0026lt;, \u0026lt;=, \u0026gt;, \u0026gt;= و الگوی ساده تطبیق عملگرهای % (like) و !% (not like) پشتیبانی می کنند.\n‍‍‍‍‍\n1friends.#(last==\u0026#34;Murphy\u0026#34;).first \u0026gt;\u0026gt; \u0026#34;Dale\u0026#34; 2friends.#(last==\u0026#34;Murphy\u0026#34;)#.first \u0026gt;\u0026gt; [\u0026#34;Dale\u0026#34;,\u0026#34;Jane\u0026#34;] 3friends.#(age\u0026gt;45)#.last \u0026gt;\u0026gt; [\u0026#34;Craig\u0026#34;,\u0026#34;Murphy\u0026#34;] 4friends.#(first%\u0026#34;D*\u0026#34;).last \u0026gt;\u0026gt; \u0026#34;Murphy\u0026#34; 5friends.#(first!%\u0026#34;D*\u0026#34;).last \u0026gt;\u0026gt; \u0026#34;Craig\u0026#34; 6friends.#(nets.#(==\u0026#34;fb\u0026#34;))#.first \u0026gt;\u0026gt; [\u0026#34;Dale\u0026#34;,\u0026#34;Roger\u0026#34;] لطفاً توجه داشته باشید که قبل از نسخه 1.3.0، کوئری ها از براکت های #[\u0026hellip;] استفاده می کردند. این در نسخه 1.3.0 تغییر کرد تا از سردرگمی با سینتکس چند مسیری جدید جلوگیری شود. برای backwards compatibility ، #[\u0026hellip;] تا نسخه اصلی بعدی به کار خود ادامه خواهد داد.\n4.8.5.4 Result Type # کتابخانه GJSON از انواع json string، number، bool و null پشتیبانی می کند. آرایه ها و اشیاء به عنوان نوع خام json خود برگردانده می شوند.\nنوع Result یکی از این موارد را دارد:\n‍‍‍\n1bool, for JSON booleans 2float64, for JSON numbers 3string, for JSON string literals 4nil, for JSON null برای دسترسی مستقیم به مقدار مورد نظر:\n1result.Type // can be String, Number, True, False, Null, or JSON 2result.Str // holds the string 3result.Num // holds the float64 number 4result.Raw // holds the raw json 5result.Index // index of raw value in original json, zero means index unknown 6result.Indexes // indexes of all the elements that match on a path containing the \u0026#39;#\u0026#39; query character. انواع مختلفی از توابع مفید وجود دارد که بر روی یک نتیجه کار می کنند:\n1result.Exists() bool 2result.Value() interface{} 3result.Int() int64 4result.Uint() uint64 5result.Float() float64 6result.String() string 7result.Bool() bool 8result.Time() time.Time 9result.Array() []gjson.Result 10result.Map() map[string]gjson.Result 11result.Get(path string) Result 12result.ForEach(iterator func(key, value Result) bool) 13result.Less(token Result, caseSensitive bool) bool تابع result.Value() یک interface{} را برمی‌گرداند که به type assertion نیاز دارد و که یکی از type های Go به صورت زیر است:\n1boolean \u0026gt;\u0026gt; bool 2number \u0026gt;\u0026gt; float64 3string \u0026gt;\u0026gt; string 4null \u0026gt;\u0026gt; nil 5array \u0026gt;\u0026gt; []interface{} 6object \u0026gt;\u0026gt; map[string]interface{} تابع result.Array() آرایه ای از مقادیر را برمی گرداند. اگر نتیجه یک مقدار غیر موجود را نشان دهد، یک آرایه خالی برگردانده می شود. اگر نتیجه یک آرایه JSON نباشد، مقدار بازگشتی یک آرایه حاوی یک نتیجه خواهد بود.\n64-bit integers # فراخوانی های result.Int() و result.Uint() قادر به خواندن تمام 64 بیت هستند و امکان کار با اعداد صحیح JSON را فراهم می کنند.\n1result.Int() int64 // -9223372036854775808 to 9223372036854775807 2result.Uint() uint64 // 0 to 18446744073709551615 4.8.5.5 Modifiers and path chaining # اصلاح کننده یک جزء مسیر است که پردازش custom شده‌ای را روی json انجام می دهد.\nچندین مسیر را می توان با استفاده از pipe character به هم «chained» کرد. این برای دریافت نتایج از یک query اصلاح شده مفید است.\nبه عنوان مثال، با استفاده از اصلاح‌کننده @reverse داخلی در سند json بالا، آرایه فرزندان را دریافت می‌کنیم و ترتیب را برعکس می‌کنیم:\n‍\n1\u0026#34;children|@reverse\u0026#34; \u0026gt;\u0026gt; [\u0026#34;Jack\u0026#34;,\u0026#34;Alex\u0026#34;,\u0026#34;Sara\u0026#34;] 2\u0026#34;children|@reverse|0\u0026#34; \u0026gt;\u0026gt; \u0026#34;Jack\u0026#34; در حال حاضر اصلاح کننده های داخلی زیر وجود دارد:\n@reverse: یک آرایه یا اعضای یک شی را معکوس کنید. @ugly: تمام فضای خالی را از یک سند json حذف کنید. @pretty: سند json را برای انسان قابل خواندن تر کنید. @this: عنصر فعلی را برمی‌گرداند. می توان از آن برای بازیابی عنصر ریشه استفاده کرد. @valid: مطمئن شوید که سند json معتبر است. @flatten: یک آرایه را صاف می کند. @join: چندین شی را به یک شیء متصل می کند. @keys: آرایه ای از کلیدها را برای یک شی برمی گرداند. @values: آرایه ای از مقادیر را برای یک شی برمی گرداند. @tostr: json را به یک رشته تبدیل می کند. یک رشته json را می پیچد. @fromstr: یک رشته را از json تبدیل می کند. یک رشته json را باز می کند. @group: آرایه های اشیاء را گروه بندی می کند. e4fc67c. را ببینید. Modifier arguments\nیک اصلاح کننده ممکن است یک آرگومان اختیاری را بپذیرد. آرگومان می تواند یک سند JSON معتبر یا فقط کاراکتر باشد.\nبه عنوان مثال، اصلاح کننده @pretty یک شی json را به عنوان آرگومان خود می گیرد.\n1@pretty:{\u0026#34;sortKeys\u0026#34;:true} که json را زیبا می کند و تمام کلیدهای آن را سفارش می دهد.\n1{ 2 \u0026#34;age\u0026#34;:37, 3 \u0026#34;children\u0026#34;: [\u0026#34;Sara\u0026#34;,\u0026#34;Alex\u0026#34;,\u0026#34;Jack\u0026#34;], 4 \u0026#34;fav.movie\u0026#34;: \u0026#34;Deer Hunter\u0026#34;, 5 \u0026#34;friends\u0026#34;: [ 6 {\u0026#34;age\u0026#34;: 44, \u0026#34;first\u0026#34;: \u0026#34;Dale\u0026#34;, \u0026#34;last\u0026#34;: \u0026#34;Murphy\u0026#34;}, 7 {\u0026#34;age\u0026#34;: 68, \u0026#34;first\u0026#34;: \u0026#34;Roger\u0026#34;, \u0026#34;last\u0026#34;: \u0026#34;Craig\u0026#34;}, 8 {\u0026#34;age\u0026#34;: 47, \u0026#34;first\u0026#34;: \u0026#34;Jane\u0026#34;, \u0026#34;last\u0026#34;: \u0026#34;Murphy\u0026#34;} 9 ], 10 \u0026#34;name\u0026#34;: {\u0026#34;first\u0026#34;: \u0026#34;Tom\u0026#34;, \u0026#34;last\u0026#34;: \u0026#34;Anderson\u0026#34;} 11} لیست کامل گزینه های @pretty عبارتند از sortKeys, indent, prefix, و width. لطفاً برای اطلاعات بیشتر به _Pretty Options_مراجعه کنید.\nCustom modifiers # همچنین می توانید اصلاح کننده های سفارشی اضافه کنید. به عنوان مثال، در اینجا ما یک اصلاح کننده ایجاد می کنیم که کل سند json را upper case یا lower case می کند.\n1gjson.AddModifier(\u0026#34;case\u0026#34;, func(json, arg string) string { 2 if arg == \u0026#34;upper\u0026#34; { 3 return strings.ToUpper(json) 4 } 5 if arg == \u0026#34;lower\u0026#34; { 6 return strings.ToLower(json) 7 } 8 return json 9}) 1\u0026#34;children|@case:upper\u0026#34; \u0026gt;\u0026gt; [\u0026#34;SARA\u0026#34;,\u0026#34;ALEX\u0026#34;,\u0026#34;JACK\u0026#34;] 2\u0026#34;children|@case:lower|@reverse\u0026#34; \u0026gt;\u0026gt; [\u0026#34;jack\u0026#34;,\u0026#34;alex\u0026#34;,\u0026#34;sara\u0026#34;] 4.8.5.6 JSON Lines # پشتیبانی از JSON Lines با استفاده از پیشوند .. وجود دارد که یک سند چند خطی را به عنوان یک آرایه در نظر می گیرد.\nبه عنوان مثال:\n1{\u0026#34;name\u0026#34;: \u0026#34;Gilbert\u0026#34;, \u0026#34;age\u0026#34;: 61} 2{\u0026#34;name\u0026#34;: \u0026#34;Alexa\u0026#34;, \u0026#34;age\u0026#34;: 34} 3{\u0026#34;name\u0026#34;: \u0026#34;May\u0026#34;, \u0026#34;age\u0026#34;: 57} 4{\u0026#34;name\u0026#34;: \u0026#34;Deloise\u0026#34;, \u0026#34;age\u0026#34;: 44} تابع ForEachLines از طریق خطوط JSON تکرار می شود.\n1gjson.ForEachLine(json, func(line gjson.Result) bool{ 2 println(line.String()) 3 return true 4}) 4.8.5.7 خواندن مقدارهای تو در تو یا nested # فرض کنید همه نام‌های خانوادگی را از json زیر می‌خواهید:\n‍‍\n1{ 2 \u0026#34;programmers\u0026#34;: [ 3 { 4 \u0026#34;firstName\u0026#34;: \u0026#34;Janet\u0026#34;, 5 \u0026#34;lastName\u0026#34;: \u0026#34;McLaughlin\u0026#34;, 6 }, { 7 \u0026#34;firstName\u0026#34;: \u0026#34;Elliotte\u0026#34;, 8 \u0026#34;lastName\u0026#34;: \u0026#34;Hunter\u0026#34;, 9 }, { 10 \u0026#34;firstName\u0026#34;: \u0026#34;Jason\u0026#34;, 11 \u0026#34;lastName\u0026#34;: \u0026#34;Harold\u0026#34;, 12 } 13 ] 14} شما می توانید از مسیر \u0026lsquo;programmers.#.lastName\u0026rsquo; مانند این استفاده کنید:\n‍‍\n1result := gjson.Get(json, \u0026#34;programmers.#.lastName\u0026#34;) 2for _, name := range result.Array() { 3\tprintln(name.String()) 4} همچنین می توانید یک شی در داخل یک آرایه را پرس و جو کنید:\n1name := gjson.Get(json, `programmers.#(lastName=\u0026#34;Hunter\u0026#34;).firstName`) 2println(name.String()) // prints \u0026#34;Elliotte\u0026#34; 4.8.5.8 پیمایش یک شی یا آرایه # تابع ForEach امکان تکرار سریع از طریق یک شی یا آرایه را فراهم می کند. کلید و مقدار برای اشیا به تابع تکرار کننده ارسال می شود. فقط مقدار برای آرایه ها ارسال می شود. برگرداندن false از یک تکرار کننده، تکرار را متوقف می کند.\n1result := gjson.Get(json, \u0026#34;programmers\u0026#34;) 2result.ForEach(func(key, value gjson.Result) bool { 3\tprintln(value.String()) 4\treturn true // keep iterating 5}) 4.8.5.9 Simple Parse and Get # یک تابع Parse(json) وجود دارد که یک تجزیه ساده را انجام می دهد و result.Get(path) که یک نتیجه را جستجو می کند. به عنوان مثال، همه اینها نتیجه یکسانی را نشان می دهند:\n1gjson.Parse(json).Get(\u0026#34;name\u0026#34;).Get(\u0026#34;last\u0026#34;) 2gjson.Get(json, \u0026#34;name\u0026#34;).Get(\u0026#34;last\u0026#34;) 3gjson.Get(json, \u0026#34;name.last\u0026#34;) 4.8.5.10 بررسی جهت وجود یک value خاص # گاهی اوقات فقط می خواهیم بدانیم که آیا یک مقدار وجود دارد یا خیر.\n1value := gjson.Get(json, \u0026#34;name.last\u0026#34;) 2if !value.Exists() { 3\tprintln(\u0026#34;no last name\u0026#34;) 4} else { 5\tprintln(value.String()) 6} 7 8// Or as one step 9if gjson.Get(json, \u0026#34;name.last\u0026#34;).Exists() { 10\tprintln(\u0026#34;has a last name\u0026#34;) 11} 4.8.5.11 اعتبار سنجی JSON # توابع Get* و Parse* انتظار دارند که فایل حاوی json به سالم و استاندارد باشد. خطا در فایل json باعث حالت panic نمی‌شود، اما ممکن است نتایج غیرمنتظره را بازگرداند.\nاگر JSON را از یک منبع غیرقابل نامشخص استفاده کنید، ممکن است بخواهید قبل از استفاده از GJSON اعتبار سنجی کنید.\n‍\n1if !gjson.Valid(json) { 2\treturn errors.New(\u0026#34;invalid json\u0026#34;) 3} 4value := gjson.Get(json, \u0026#34;name.last\u0026#34;) 4.8.5.12 Unmarshal به یک map # برای unmarshal به مپ به صورت map[string]interface{}:\n‍‍\n1m, ok := gjson.Parse(json).Value().(map[string]interface{}) 2if !ok { 3\t// not a map 4} 4.8.5.13 کار با byte ها # اگر درJSON فایل مورد نظر شما []byte slice وجود دارد، تابع GetBytes برای این حالت وجود دارد. این تابع در استفاده از Get(string(data), path) ترجیح داده می شود.\n‍‍\n1var json []byte = ... 2result := gjson.GetBytes(json, path) اگر از تابع gjson.GetBytes(json, path) استفاده می کنید و می خواهید از تبدیل result.Raw به []byte اجتناب کنید، می توانید از این الگو استفاده کنید:\n1var json []byte = ... 2result := gjson.GetBytes(json, path) 3var raw []byte 4if result.Index \u0026gt; 0 { 5 raw = json[result.Index:result.Index+len(result.Raw)] 6} else { 7 raw = []byte(result.Raw) 8} این روش از فیلد result.Index استفاده می‌کند که موقعیت داده‌های خام در json فایل است. ممکن است که مقدار result.Index برابر با صفر باشد، در این صورت result.Raw به یک []byte تبدیل می‌شود.\n4.8.5.14 خواندن چندین value # تابع GetMany می تواند برای دریافت چندین مقدار به طور همزمان استفاده شود.\n‍‍\n1results := gjson.GetMany(json, \u0026#34;name.first\u0026#34;, \u0026#34;name.last\u0026#34;, \u0026#34;age\u0026#34;) مقدار بازگشتی یک []Result است، که همیشه دارای دقیقاً همان تعداد آیتم‌هایی است که مسیرهای ورودی دارند.\n4.8.6 کتابخانه SJSON # در واقع SJSON یک کتابخانه‌ای است که یک راه بسیار سریع و ساده برای تنظیم یک value در یک سند json ارائه می دهد. در بخش قبلی فقط می‌توانستیم مقادیر موجود در یک سند json بازخوانی کنیم ولی به کمک sjson می توانیم مقادیر مورد نظر را در یک سند json وارد کرده یا به روزرسانی و حذف دهیم.\n4.8.6.1 راه اندازی و نصب SJSON # برای شروع استفاده از SJSON باید آن را نصب کنید و go get را اجرا کنید:\n1$ go get -u github.com/tidwall/sjson با این کار کتابخانه نصب می شود.\n4.8.6.2 Set a value # دستور Set مقدار یا value ای را برای path مشخص شده اجرا می کند. یک path در یک dot syntax مشخص می‌شود، مانند \u0026rsquo;name.last\u0026rsquo; یا \u0026lsquo;age\u0026rsquo;. در این عملکرد انتظار می‌رود که ساختار کلی json صحیح و valid باشد. در صورت اشکال در ساختار json فایل و Invalid بودن آن، حالت panic رخ نمی‌دهد، اما ممکن است نتایج غیرمنتظره‌ای را برگرداند. البته pathهای نامعتبر ممکن است ایجاد خطا کند. به عنوان مثال کد زیر:\n1package main 2 3import \u0026#34;github.com/tidwall/sjson\u0026#34; 4 5const json = `{\u0026#34;name\u0026#34;:{\u0026#34;first\u0026#34;:\u0026#34;Janet\u0026#34;,\u0026#34;last\u0026#34;:\u0026#34;Prichard\u0026#34;},\u0026#34;age\u0026#34;:47}` 6 7func main() { 8\tvalue, _ := sjson.Set(json, \u0026#34;name.last\u0026#34;, \u0026#34;Anderson\u0026#34;) 9\tprintln(value) 10} خروجی به شکل زیر خواهد بود:\n1{\u0026#34;name\u0026#34;:{\u0026#34;first\u0026#34;:\u0026#34;Janet\u0026#34;,\u0026#34;last\u0026#34;:\u0026#34;Anderson\u0026#34;},\u0026#34;age\u0026#34;:47} 4.8.6.3 Path syntax # در واقع path یا مسیر مجموعه ای از کلیدها است که با یک نقطه از هم جدا شده اند. کاراکترهای dot و colon را می توان با کاراکتر \\ به راحتی escape کرد.\n1{ 2 \u0026#34;name\u0026#34;: {\u0026#34;first\u0026#34;: \u0026#34;Tom\u0026#34;, \u0026#34;last\u0026#34;: \u0026#34;Anderson\u0026#34;}, 3 \u0026#34;age\u0026#34;:37, 4 \u0026#34;children\u0026#34;: [\u0026#34;Sara\u0026#34;,\u0026#34;Alex\u0026#34;,\u0026#34;Jack\u0026#34;], 5 \u0026#34;fav.movie\u0026#34;: \u0026#34;Deer Hunter\u0026#34;, 6 \u0026#34;friends\u0026#34;: [ 7\t{\u0026#34;first\u0026#34;: \u0026#34;James\u0026#34;, \u0026#34;last\u0026#34;: \u0026#34;Murphy\u0026#34;}, 8\t{\u0026#34;first\u0026#34;: \u0026#34;Roger\u0026#34;, \u0026#34;last\u0026#34;: \u0026#34;Craig\u0026#34;} 9 ] 10} 1\u0026#34;name.last\u0026#34; \u0026gt;\u0026gt; \u0026#34;Anderson\u0026#34; 2\u0026#34;age\u0026#34; \u0026gt;\u0026gt; 37 3\u0026#34;children.1\u0026#34; \u0026gt;\u0026gt; \u0026#34;Alex\u0026#34; 4\u0026#34;friends.1.last\u0026#34; \u0026gt;\u0026gt; \u0026#34;Craig\u0026#34; از کلید -1 می توان برای افزودن یک مقدار به آرایه موجود استفاده کرد:\n1\u0026#34;children.-1\u0026#34; \u0026gt;\u0026gt; appends a new value to the end of the children array معمولاً از کلیدهای عددی برای اصلاح آرایه ها استفاده می شود، اما می توان با استفاده از کاراکتر دو نقطه، یک کلید شی عددی را اجرا کرد:\n1{ 2 \u0026#34;users\u0026#34;:{ 3 \u0026#34;2313\u0026#34;:{\u0026#34;name\u0026#34;:\u0026#34;Sara\u0026#34;}, 4 \u0026#34;7839\u0026#34;:{\u0026#34;name\u0026#34;:\u0026#34;Andy\u0026#34;} 5 } 6} همینطور colon path به صورت زیر است:\n1\u0026#34;users.:2313.name\u0026#34; \u0026gt;\u0026gt; \u0026#34;Sara\u0026#34; 4.8.6.4 Supported types # در کتابخانه SJSON تقریباً هر نوع متغیر یا type ای پشتیبانی می شود:\n1sjson.Set(`{\u0026#34;key\u0026#34;:true}`, \u0026#34;key\u0026#34;, nil) 2sjson.Set(`{\u0026#34;key\u0026#34;:true}`, \u0026#34;key\u0026#34;, false) 3sjson.Set(`{\u0026#34;key\u0026#34;:true}`, \u0026#34;key\u0026#34;, 1) 4sjson.Set(`{\u0026#34;key\u0026#34;:true}`, \u0026#34;key\u0026#34;, 10.5) 5sjson.Set(`{\u0026#34;key\u0026#34;:true}`, \u0026#34;key\u0026#34;, \u0026#34;hello\u0026#34;) 6sjson.Set(`{\u0026#34;key\u0026#34;:true}`, \u0026#34;key\u0026#34;, []string{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}) 7sjson.Set(`{\u0026#34;key\u0026#34;:true}`, \u0026#34;key\u0026#34;, map[string]interface{}{\u0026#34;hello\u0026#34;:\u0026#34;world\u0026#34;}) هنگامی که یک type شناسایی نمی شود، SJSON به رمزگذاری encoding/json باز می گردد.\n4.8.6.5 مثال SJSON # در این بخش به بررسی چند مثال از SJSON می پردازیم:\nوارد کردن یک مقدار در یک json document خالی.\n1value, _ := sjson.Set(\u0026#34;\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;Tom\u0026#34;) 2println(value) 3 4// Output: 5// {\u0026#34;name\u0026#34;:\u0026#34;Tom\u0026#34;} وارد کردن یک مقادیر تو در تو یا nested در یک json document خالی.\n1value, _ := sjson.Set(\u0026#34;\u0026#34;, \u0026#34;name.last\u0026#34;, \u0026#34;Anderson\u0026#34;) 2println(value) 3 4// Output: 5// {\u0026#34;name\u0026#34;:{\u0026#34;last\u0026#34;:\u0026#34;Anderson\u0026#34;}} وارد کردن مقدار جدید در سند:\n1value, _ := sjson.Set(`{\u0026#34;name\u0026#34;:{\u0026#34;last\u0026#34;:\u0026#34;Anderson\u0026#34;}}`, \u0026#34;name.first\u0026#34;, \u0026#34;Sara\u0026#34;) 2println(value) 3 4// Output: 5// {\u0026#34;name\u0026#34;:{\u0026#34;first\u0026#34;:\u0026#34;Sara\u0026#34;,\u0026#34;last\u0026#34;:\u0026#34;Anderson\u0026#34;}} بروزرسانی و آپدیت یک سند:\n1value, _ := sjson.Set(`{\u0026#34;name\u0026#34;:{\u0026#34;last\u0026#34;:\u0026#34;Anderson\u0026#34;}}`, \u0026#34;name.last\u0026#34;, \u0026#34;Smith\u0026#34;) 2println(value) 3 4// Output: 5// {\u0026#34;name\u0026#34;:{\u0026#34;last\u0026#34;:\u0026#34;Smith\u0026#34;}} وارد کردن مقدار آرایه جدید:\n1value, _ := sjson.Set(`{\u0026#34;friends\u0026#34;:[\u0026#34;Andy\u0026#34;,\u0026#34;Carol\u0026#34;]}`, \u0026#34;friends.2\u0026#34;, \u0026#34;Sara\u0026#34;) 2println(value) 3 4// Output: 5// {\u0026#34;friends\u0026#34;:[\u0026#34;Andy\u0026#34;,\u0026#34;Carol\u0026#34;,\u0026#34;Sara\u0026#34;] اضافه کردن مقدار جدید به انتهای آرایه با استفاده از گزینه 1- :\n1value, _ := sjson.Set(`{\u0026#34;friends\u0026#34;:[\u0026#34;Andy\u0026#34;,\u0026#34;Carol\u0026#34;]}`, \u0026#34;friends.-1\u0026#34;, \u0026#34;Sara\u0026#34;) 2println(value) 3 4// Output: 5// {\u0026#34;friends\u0026#34;:[\u0026#34;Andy\u0026#34;,\u0026#34;Carol\u0026#34;,\u0026#34;Sara\u0026#34;] اضافه کردن مقدار جدید به انتهای آرایه و null کردن سایر سلول‌های آرایه که بین انتهای آرایه و آخرین سلولی که دارای مقدار مشخص بوده است :\n1value, _ := sjson.Set(`{\u0026#34;friends\u0026#34;:[\u0026#34;Andy\u0026#34;,\u0026#34;Carol\u0026#34;]}`, \u0026#34;friends.4\u0026#34;, \u0026#34;Sara\u0026#34;) 2println(value) 3 4// Output: 5// {\u0026#34;friends\u0026#34;:[\u0026#34;Andy\u0026#34;,\u0026#34;Carol\u0026#34;,null,null,\u0026#34;Sara\u0026#34;] حذف کردن یک مقدار:\n1value, _ := sjson.Delete(`{\u0026#34;name\u0026#34;:{\u0026#34;first\u0026#34;:\u0026#34;Sara\u0026#34;,\u0026#34;last\u0026#34;:\u0026#34;Anderson\u0026#34;}}`, \u0026#34;name.first\u0026#34;) 2println(value) 3 4// Output: 5// {\u0026#34;name\u0026#34;:{\u0026#34;last\u0026#34;:\u0026#34;Anderson\u0026#34;}} حذف کردن مقادیر آرایه ای:\n1value, _ := sjson.Delete(`{\u0026#34;friends\u0026#34;:[\u0026#34;Andy\u0026#34;,\u0026#34;Carol\u0026#34;]}`, \u0026#34;friends.1\u0026#34;) 2println(value) 3 4// Output: 5// {\u0026#34;friends\u0026#34;:[\u0026#34;Andy\u0026#34;]} حذف کردن انتهای آرایه:\n1value, _ := sjson.Delete(`{\u0026#34;friends\u0026#34;:[\u0026#34;Andy\u0026#34;,\u0026#34;Carol\u0026#34;]}`, \u0026#34;friends.-1\u0026#34;) 2println(value) 3 4// Output: 5// {\u0026#34;friends\u0026#34;:[\u0026#34;Andy\u0026#34;]} "},{"id":51,"href":"/chapter-4/work-with-toml-file-in-go/","title":"4.9 آموزش کار با toml","section":"فصل چهارم: مباحث پیشرفته","content":" 4.9.1 مقدمه # فایل‌های TOML یک نمونه از فایل‌های پیکربندی هستند که در سیستم‌های مدرن مورد استفاده قرار می‌گیرند، این فایل‌ها به صورت متنی و قابل خواندن برای انسان و در عین حال قابل پردازش برای ماشین طراحی شده‌اند.\nTOML مخفف کلمات (Tom\u0026rsquo;s Obvious, Minimal Language) می‌باشد. جمعیت بزرگتری از افراد آن را مفسرند به این شکل که TOML ابزاری ساده برای پیکربندی بسیار درون‌فرمانی است. این فرمت فایل متنی دارای مقادیر شبیه به دیکشنری بوده و در بسیاری از نرم‌افزارها، به‌طور خاص در نرم‌افزارهای ساخته شده با golang بسیار به‌کار می‌رود.\nمثال زیر یک فایل TOML معتبر را نمایش می‌دهد:\n1[database] 2server = \u0026#34;localhost\u0026#34; 3port = 3306 4user = \u0026#34;username\u0026#34; 5password = \u0026#34;password\u0026#34; 6database = \u0026#34;myDB\u0026#34; در این مثال، تمام اطلاعات پیکربندی مربوط به یک پایگاه‌داده وجود دارد (server، port، user و غیره)، و به صورت مشخصی تعریف شده‌اند، به طوری که برای برنامه‌نویسی با استفاده از این پیکربندی بسیار سرعت‌بخش خواهد بود. از آنجا که فایل TOML قابل‌خواندی و ویرایش توسط انسان است، برنامه‌نویسی با این نوع فایل‌ها آسان و قابل فهم خواهد بود.\n4.9.2 کار با marshal و unmarshal پکیج toml # پکیج toml در زبان Go، حاوی توابع Marshal و Unmarshal برای تبدیل داده‌های Go به فرمت TOML و برعکس می‌باشد.\n4.9.2.1 Marshal # تابع Marshal برای تبدیل یک متغیر ساخته شده در Go به فرمت TOML مورد استفاده قرار می‌گیرد. برای استفاده از این تابع، باید داده‌های خود را به یک متغیر با نوع interface{} تبدیل کنید و سپس این متغیر را به تابع Marshal بدهید.\nبه عنوان مثال، برای تبدیل داده‌های map[string]interface{} به فرمت TOML، می‌توانید این کد را به کار ببرید:\n1package main 2 3import ( 4 \u0026#34;github.com/BurntSushi/toml\u0026#34; 5 \u0026#34;fmt\u0026#34; 6) 7 8func main() { 9 data := map[string]interface{}{ 10 \u0026#34;name\u0026#34;: \u0026#34;John\u0026#34;, 11 \u0026#34;email\u0026#34;: \u0026#34;john@example.com\u0026#34;, 12 \u0026#34;age\u0026#34;: 22, 13 } 14 tomlData, err := toml.Marshal(data) 15 if err != nil { 16 panic(err) 17 } 18 fmt.Println(string(tomlData)) 19} این کد یک دیکشنری ساده را تعریف می‌کند و سپس آن را به فرمت TOML تبدیل می‌کند. خروجی به صورت زیر خواهد بود:\n1$ go run main.go 2age = 22 3email = \u0026#34;john@example.com\u0026#34; 4name = \u0026#34;John\u0026#34; 4.9.2.2 Unmarshal # تابع Unmarshal، برای تبدیل یک رشته فرمت TOML به داده‌های Go استفاده می‌شود. برای استفاده از این تابع، باید با استفاده از تابع ioutil.ReadFile، فایل TOML مورد نظر را بخوانید و سپس رشته خوانده‌شده را به تابع Unmarshal بدهید.\nبه عنوان مثال، برای خواندن یک فایل TOML و تبدیل آن به یک دیکشنری در Go، می‌توانید این کد را به کار ببرید:\n1package main 2 3import ( 4 \u0026#34;github.com/BurntSushi/toml\u0026#34; 5 \u0026#34;fmt\u0026#34; 6 \u0026#34;io/ioutil\u0026#34; 7) 8 9type Person struct { 10 Name string 11 Email string 12 Age int 13} 14 15func main() { 16 data, err := ioutil.ReadFile(\u0026#34;file.toml\u0026#34;) 17 if err != nil { 18 panic(err) 19 } 20 21 var person Person 22 if _, err := toml.Decode(string(data), \u0026amp;person); err != nil { 23 panic(err) 24 } 25 26 fmt.Printf(\u0026#34;%#v\\n\u0026#34;, person) 27} این کد یک فایل TOML با فرمت زیر را می‌خواند و مقادیر موجود در آن را به داده‌های Go مناسب تبدیل می‌کند:\n1name = \u0026#34;John\u0026#34; 2email = \u0026#34;john@example.com\u0026#34; 3age = 22 خروجی به صورت زیر خواهد بود:\n1$ go run main.go 2main.Person{Name:\u0026#34;John\u0026#34;, Email:\u0026#34;john@example.com\u0026#34;, Age:22} 4.9.3 تبدیل struct به toml و بلعکس # برای تبدیل یک struct به فرمت TOML و بلعکس، می‌توان از تابع‌های Marshal و Unmarshal پکیج toml استفاده کرد. در این روش، فیلدهای struct بر اساس نام آن‌ها و به صورت حروف کوچک در فایل TOML با نام فیلد متناظر ذخیره می‌شوند.\nهمچنین می‌توان از تگ‌ها در داخل struct برای تعیین نام فیلد در فایل TOML استفاده کرد. با استفاده از تگ toml:\u0026quot;name\u0026quot; می‌توان نامی دلخواه برای فیلد در فایل TOML مشخص کرد. همچنین می‌توان از تگ‌های دیگری مانند toml:\u0026quot;omitempty\u0026quot; برای اجباری نبودن یک فیلد در فایل TOML استفاده کرد.\nبه عنوان مثال، فرض کنید یک struct به نام Person با فیلدهای Name، Emailو Age داریم. با استفاده از تگ‌ها، نام فیلدها در فایل TOML و پیش‌فرض برای آن‌ها مشخص می‌شود.\n1package main 2 3import ( 4 \u0026#34;github.com/BurntSushi/toml\u0026#34; 5 \u0026#34;fmt\u0026#34; 6) 7 8type Person struct { 9 Name string `toml:\u0026#34;name\u0026#34;` 10 Email string `toml:\u0026#34;email,omitempty\u0026#34;` 11 Age int `toml:\u0026#34;age\u0026#34;` 12} 13 14func main() { 15 // Marshaling from struct to TOML 16 person := Person{Name: \u0026#34;John\u0026#34;, Age: 30} 17 tomlData, err := toml.Marshal(person) 18 if err != nil { 19 panic(err) 20 } 21 fmt.Println(string(tomlData)) 22 23 // Unmarshaling from TOML to struct 24 var p Person 25 if _, err := toml.Decode(string(tomlData), \u0026amp;p); err != nil { 26 panic(err) 27 } 28 fmt.Printf(\u0026#34;%#v\\n\u0026#34;, p) 29} در این مثال، struct با نام Person تعریف شده و از تگ برای نام‌گذاری فیلدها استفاده شده است. در تابع main، ابتدا از متد Marshal پکیج toml برای تبدیل یک شیء Person به فرمت TOML استفاده شده است. سپس با استفاده از متد Decode از پکیج toml، فایل TOML به داخل شیء Person تبدیل می‌شود.\nخروجی کد بالا به صورت زیر است:\n1$ go run main.go 2name = \u0026#34;John\u0026#34; 3age = 30 4 5main.Person{Name:\u0026#34;John\u0026#34;, Email:\u0026#34;\u0026#34;, Age:30} همان‌طور که مشاهده می‌کنید، نام فیلدها در فایل TOML با تگ‏های تعیین‌شده در struct مطابقت می‌کند. همچنین با توجه به تگ omitempty که در فیلد Email وجود دارد، این فیلد در فایل TOML نمایش داده نشده است، چرا که در شی person مقداری برای آن تعریف نشده بود.\n"},{"id":52,"href":"/chapter-4/work-with-yaml-file-in-go/","title":"4.10 آموزش کار با yaml","section":"فصل چهارم: مباحث پیشرفته","content":" 4.10.1 مقدمه # YAML یک زبان فراهم کننده ساختار پذیر برای نمایش اطلاعات است که در قالب متن موجود می‌باشد. این زبان ابتدا برای نوشتن سند‌های XML توسعه یافت که با پیشرفت کاربردهای آن به محل جایگزینی برای فرمت‌های رایجی همچون JSON و اقلیتاً TOML تبدیل شده است.\nاین فرمت در صنعت‌های مختلف مورد استفاده و ستوده شده ‌است، مانند ذخیره سازی تنظیمات سیستمی، فایل‌های کانفیگ مختلف، فایل‌های داده و \u0026hellip; . همچنین به خاطر قابل خواندن بودن برای انسان، استفاده از YAML در فایل‌هایی که باید توسط بشر خوانده شوند مانند فایل‌های خودرو، پروژه و\u0026hellip; صورت گرفته است.\nیکی از نمونه‌های کاربردی YAML، استفاده از آن در فایل‌های کانفیگ ‌Docker است. در فایل docker-compose.yaml، بخش‌های مختلفی از یک سرویس در قالب Block mapping و با کلید‌های خاصی مانند version، services، ports و غیره تعریف شده است. این فرمت به طور کل شرکت‌های بزرگی مانند مایکروسافت، ای‌بی‌ای و گوگل، در محصولات خود به صورت فایل‌های YAML استفاده می‌کنند.\nبنابراین، می‌توان گفت YAML یک فرمت متنی ساده و پذیرفتنی است که در بسیاری از پروژه‌های نرم‌افزاری استفاده می‌شود، به خاطر پشتیبانی از انواع داده‌ها و ساختارهای مختلف، قابلیت خواندن و نوشتن آسان برای انسان و قابل استفاده در زبان‌های مختلفی استفاده از YAML در صنایع مختلفی از جمله فناوری‌های اطلاعات، اینترنت اشیا و\u0026hellip; رایج است.\n4.10.2 کار با marshal و unmarshal پکیج yaml # پکیج YAML در زبان Go شامل توابع Marshal و Unmarshal برای تبدیل داده‌های Go به فرمت YAML و بالعکس می‌شود. استفاده از این توابع بسیار ساده است و می‌توان به سرعت با استفاده از ویژگی‌های زبان Go به داده‌ها دسترسی پیدا کرد.\nبرای مثال، فرض کنید یک پرونده YAML با محتوای زیر داریم:\n1name: John 2age: 25 3isStudent: true 4.10.2.1 Marshal # همچنین، می‌توان از تابع Marshal برای تبدیل ساختار داده‌ای Go به فرمت YAML استفاده کرد. به عنوان مثال، برای تبدیل ساختار Person به فرمت YAML می‌توان از کد زیر استفاده کرد:\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;gopkg.in/yaml.v2\u0026#34; 6\t\u0026#34;log\u0026#34; 7) 8 9func main() { 10\tperson := Person{ 11\tName: \u0026#34;John\u0026#34;, 12\tAge: 25, 13\tIsStudent: true, 14\t} 15 16\tyamlData, err := yaml.Marshal(\u0026amp;person) 17\tif err != nil { 18\tlog.Fatalf(\u0026#34;error: %v\u0026#34;, err) 19\t} 20 21\tfmt.Printf(\u0026#34;%s\u0026#34;, string(yamlData)) 22} در این کد، یک شیء از ساختار Person را ایجاد می کنیم و سپس از تابع Marshal برای تبدیل آن به فرمت YAML استفاده می کنیم. سپس محتوای YAML را به کمک تابع Printf چاپ می کنیم.\nبه این ترتیب پکیج YAML از امکانات و قابلیت بالایی برای کد نویسی و کار با فرمت YAML در زبان Go برخوردار می‌باشد.\n4.10.2.2 Unmarshal # می‌توانیم این پرونده را به کمک تابع Unmarshal به یک ساختار Go تبدیل کنیم. برای این کار، ابتدا نیاز است که یک ساختار داده‌ای برای ذخیره اطلاعات YAML تعریف کنیم. در این حالت، می‌توانیم از ساختار زیر استفاده کنیم:\n1type Person struct { 2\tName string `yaml:\u0026#34;name\u0026#34;` 3\tAge int `yaml:\u0026#34;age\u0026#34;` 4\tIsStudent bool `yaml:\u0026#34;isStudent\u0026#34;` 5} حالا می توانیم از تابع Unmarshal برای تبدیل داده‌ی YAML به ساختار Go استفاده کنیم:\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;gopkg.in/yaml.v2\u0026#34; 6\t\u0026#34;log\u0026#34; 7) 8 9type Person struct { 10\tName string `yaml:\u0026#34;name\u0026#34;` 11\tAge int `yaml:\u0026#34;age\u0026#34;` 12\tIsStudent bool `yaml:\u0026#34;isStudent\u0026#34;` 13} 14 15func main() { 16\tyamlData := ` 17name: John 18age: 25 19isStudent: true 20` 21 22\tvar person Person 23 24\terr := yaml.Unmarshal([]byte(yamlData), \u0026amp;person) 25\tif err != nil { 26\tlog.Fatalf(\u0026#34;error: %v\u0026#34;, err) 27\t} 28 29\tfmt.Printf(\u0026#34;Name: %s\\nAge: %d\\nIsStudent: %v\u0026#34;, person.Name, person.Age, person.IsStudent) 30} این کد پرونده YAML را به متغیر yamlData منتسب کرده، از تابع Unmarshal برای تجزیه و تحلیل داده‌های YAML استفاده و ساختار Person را با مقادیر معادل پر کرده‌است. سپس جزئیات این ساختار را چاپ می‌کنیم.\n"},{"id":53,"href":"/chapter-4/work-with-csv-file-in-go/","title":"4.11 آموزش کار با csv","section":"فصل چهارم: مباحث پیشرفته","content":" 4.11.1 مقدمه # CSV یکی از فرمت‌های متداول برای ذخیره داده‌های جدولی است. خروجی اکثر برنامه‌های قابلیت دستکاری داده، همراه با نرم‌افزار‌های آفیس، به فرمت CSV تولید می‌شود. فرمت CSV چندین ستون در یک ردیف را با استفاده از کاما (,) جدا کرده و هر ردیف را با استفاده از عبارت جدید (newline) جدا می‌کند.\nدر زبان برنامه‌نویسی Go نیز پکیج encoding/csv وجود دارد که در آن، توابع مربوط به خواندن و نوشتن داده‌های CSV به صورت دستی یا از طریق پرونده‌ها فراهم شده است. با استفاده از این پکیج، می‌توان داده‌های CSV را به داده‌های جدولی تبدیل کرد و برعکس.\nبه عنوان مثال، در ادامه یک فایل CSV به نام \u0026ldquo;data.csv\u0026rdquo; حاوی اطلاعات چند شخص را در نظر بگیرید:\n1Name,Age,City 2John,25,New York 3Jane,30,San Francisco 4Bob,40,Los Angeles 4.11.2 نحوه خواندن فایل csv # برای خواندن فایل csv می‌توان با استفاده از پکیج encoding/csv پرونده CSV را باز کرد:\n1package main 2 3import ( 4 \u0026#34;encoding/csv\u0026#34; 5 \u0026#34;fmt\u0026#34; 6 \u0026#34;os\u0026#34; 7) 8 9func main() { 10 f, err := os.Open(\u0026#34;data.csv\u0026#34;) 11 if err != nil { 12 panic(err) 13 } 14 15 r := csv.NewReader(f) 16 records, err := r.ReadAll() 17 if err != nil { 18 panic(err) 19 } 20 21 for _, row := range records { 22 for _, col := range row { 23 fmt.Print(col, \u0026#34;\\t\u0026#34;) 24 } 25 fmt.Println() 26 } 27} در این کد، تابع os.Open برای باز کردن پرونده CSV استفاده می‌شود. یک رابط csv.Reader ایجاد شده و یک رشته ساختارمند، پرونده CSV را می‌خواند. سپس با استفاده از یک حلقه، داده‌های جدولی چاپ می‌شود.\nفراداده‌های CSV بسیار گسترده هستند و می‌توانند شامل شماره دسته، توضیحات، یادداشت‌های شخصی و غیره باشند. برای کار با این نوع داده‌ها، پکیج encoding/csv امکاناتی مانند تنظیمات csv.Reader را فراهم می‌کند، که در آن، می‌توانیم تنظیماتی مانند علامت‌گذاری مناسب فایل CSV و دیگر علامت‌گذاری‌ها را بهبود ببخشیم.\n4.11.3 ReadAll فایل csv # تابع ReadAll تمام رکوردهای باقی مانده را از reader می خواند. هر رکورد یک قسمتی از fieldها است.\n1first_name,last_name,occupation 2John,Doe,gardener 3Lucy,Smith,teacher 4Brian,Bethamy,programmer نام این فایل users.csv است. خط اول نام ستون ها هستند.\n1package main 2 3import ( 4 \u0026#34;encoding/csv\u0026#34; 5 \u0026#34;fmt\u0026#34; 6 \u0026#34;log\u0026#34; 7 \u0026#34;os\u0026#34; 8) 9 10type User struct { 11 firstName string 12 lastName string 13 occupation string 14} 15 16func main() { 17 18 records, err := readData(\u0026#34;users.csv\u0026#34;) 19 20 if err != nil { 21 log.Fatal(err) 22 } 23 24 for _, record := range records { 25 26 user := User{ 27 firstName: record[0], 28 lastName: record[1], 29 occupation: record[2], 30 } 31 32 fmt.Printf(\u0026#34;%s %s is a %s\\n\u0026#34;, user.firstName, user.lastName, 33 user.occupation) 34 } 35} 36 37func readData(fileName string) ([][]string, error) { 38 39 f, err := os.Open(fileName) 40 41 if err != nil { 42 return [][]string{}, err 43 } 44 45 defer f.Close() 46 47 r := csv.NewReader(f) 48 49 // skip first line 50 if _, err := r.Read(); err != nil { 51 return [][]string{}, err 52 } 53 54 records, err := r.ReadAll() 55 56 if err != nil { 57 return [][]string{}, err 58 } 59 60 return records, nil 61} اسم فایل بالا read_all.go می‌باشد و این مثال فایل users.csv را می خواند. هر line به یک User type را بر می‌گرداند.\n1// skip first line 2if _, err := r.Read(); err != nil { 3 return [][]string{}, err 4} در اینجا از خط اول که شامل نام ستون هاست می گذریم.\n1records, err := r.ReadAll() در نهایت همه رکوردها را یک جا با ReadAll دریافت می کنیم.\n1$ go run read_all.go 2John Doe is a gardener 3Lucy Smith is a teacher 4Brian Bethamy is a programmer 4.11.4 delimiter CSV دلخواه # علیرغم نام CSV ، CSV ممکن است دارای جداکننده های دیگری غیر از کاما باشد. این به دلیل استاندارد نبودن قالب CSV است.\n1# user.csv 2# this is users.csv file 3 4John;Doe;gardener 5Lucy;Smith;teacher 6Brian;Bethamy;programmer در فایل users.csv فیلدها با نقطه ویرگول از هم جدا شده اند. این فایل حاوی یک comment نیز می‌باشد.\n1//different_delimiter.go// 2 3package main 4 5import ( 6 \u0026#34;encoding/csv\u0026#34; 7 \u0026#34;fmt\u0026#34; 8 \u0026#34;log\u0026#34; 9 \u0026#34;os\u0026#34; 10) 11 12func main() { 13 14 f, err := os.Open(\u0026#34;users.csv\u0026#34;) 15 16 if err != nil { 17 18 log.Fatal(err) 19 } 20 21 r := csv.NewReader(f) 22 r.Comma = \u0026#39;;\u0026#39; 23 r.Comment = \u0026#39;#\u0026#39; 24 25 records, err := r.ReadAll() 26 27 if err != nil { 28 log.Fatal(err) 29 } 30 31 fmt.Print(records) 32} این مثال تمام داده های این فایل را می خواند.\n1r := csv.NewReader(f) 2r.Comma = \u0026#39;;\u0026#39; 3r.Comment = \u0026#39;#\u0026#39; در اینجا separator و کاراکتر comment را تنظیم می کنیم تا package بداند چگونه فایل را parse یا تجریه تحلیل کند.\n4.11.5 نوشتن CSV # تابع Write یک رکورد CSV را برای writer می نویسد. رکورد برشی از strings است که هر string یک فیلد است. write ها buffer شده هستند، بنابراین باید Flush فراخوانی شود تا اطمینان حاصل شود که رکورد برای writer اصلی نوشته شده است.\n1//write_fun.go// 2package main 3 4import ( 5 \u0026#34;encoding/csv\u0026#34; 6 \u0026#34;log\u0026#34; 7 \u0026#34;os\u0026#34; 8) 9 10func main() { 11 12 records := [][]string{ 13 {\u0026#34;first_name\u0026#34;, \u0026#34;last_name\u0026#34;, \u0026#34;occupation\u0026#34;}, 14 {\u0026#34;John\u0026#34;, \u0026#34;Doe\u0026#34;, \u0026#34;gardener\u0026#34;}, 15 {\u0026#34;Lucy\u0026#34;, \u0026#34;Smith\u0026#34;, \u0026#34;teacher\u0026#34;}, 16 {\u0026#34;Brian\u0026#34;, \u0026#34;Bethamy\u0026#34;, \u0026#34;programmer\u0026#34;}, 17 } 18 19 f, err := os.Create(\u0026#34;users.csv\u0026#34;) 20 defer f.Close() 21 22 if err != nil { 23 24 log.Fatalln(\u0026#34;failed to open file\u0026#34;, err) 25 } 26 27 w := csv.NewWriter(f) 28 defer w.Flush() 29 30 for _, record := range records { 31 if err := w.Write(record); err != nil { 32 log.Fatalln(\u0026#34;error writing record to file\u0026#34;, err) 33 } 34 } 35} در مثال بالا، چند رکورد را با تابع Write در فایل users.csv نوشتیم.\n4.11.6 نوشتن WriteAll CSV # تابع WriteAll چندین رکورد CSV را با استفاده از Write برای writer می‌نویسد و سپس Flush را فراخوانی می‌کند.\n1 2//write_all.go// 3 4package main 5 6import ( 7 \u0026#34;encoding/csv\u0026#34; 8 \u0026#34;log\u0026#34; 9 \u0026#34;os\u0026#34; 10) 11 12func main() { 13 14 records := [][]string{ 15 {\u0026#34;first_name\u0026#34;, \u0026#34;last_name\u0026#34;, \u0026#34;occupation\u0026#34;}, 16 {\u0026#34;John\u0026#34;, \u0026#34;Doe\u0026#34;, \u0026#34;gardener\u0026#34;}, 17 {\u0026#34;Lucy\u0026#34;, \u0026#34;Smith\u0026#34;, \u0026#34;teacher\u0026#34;}, 18 {\u0026#34;Brian\u0026#34;, \u0026#34;Bethamy\u0026#34;, \u0026#34;programmer\u0026#34;}, 19 } 20 21 f, err := os.Create(\u0026#34;users.csv\u0026#34;) 22 defer f.Close() 23 24 if err != nil { 25 26 log.Fatalln(\u0026#34;failed to open file\u0026#34;, err) 27 } 28 29 w := csv.NewWriter(f) 30 err = w.WriteAll(records) // calls Flush internally 31 32 if err != nil { 33 log.Fatal(err) 34 } 35} در نهایت ما چند رکورد را در یک لحظه با WriteAll می نویسیم.\n"},{"id":54,"href":"/chapter-4/work-with-ini-file-in-go/","title":"4.12 آموزش کار با ini","section":"فصل چهارم: مباحث پیشرفته","content":"بطور خلاصه فایل های ini.* جهت ذخیره تنظیمات مختلف استفاده می شود تنظیماتی مثل: آدرس خاص در شبکه، اطلاعات ورود به سیستم های مختلف و موارد از این قبیل.\nبرای شروع ساختار پروژه ما به این شکل است\n1$ mkdir -p /tmp/ini 2$ cd /tmp/ini 3$ touch my.ini main.go 4$ tree . . 5├── main.go 6└── my.ini در پروژه دو فایل ایجاد کردیم یکی فایل اصلی برنامه main.go و دیگری my.ini که می خواهیم تنظیمات برنامه را در آن نگهداری کنیم. محتوای داخل فایل ini را بصورت ذیل تعریف کرده ایم\n1# possible values : production, development 2app_mode = development 3 4[paths] 5# Path to where grafana can store temp files, sessions, and the sqlite3 db (if that is used) 6data = /home/git/grafana 7 8[server] 9# Protocol (http or https) 10protocol = http 11 12# The http port to use 13http_port = 9999 14# Redirect to correct domain if host header does not match domain # Prevents DNS rebinding attacks 15enforce_domain = true همانطور که در توصیف کد آمده است 5 مقدار مختلف داخل فایل آمده است برخی را توضیح می دهیم\nمقدار app_mode که در واقع میخواهیم جهت تشخیص مود توسعه استفاده کنیم برای مثال به کمک این مقدار میخواهیم لاگ های برنامه در پروداکشن نمایش داده نشود ولی در زمان توسعه دهنده بتوانیم لاگ هایم مختلف را مشاهده کنیم. قسمت بعد protocol است که کاملا مشخص می باشد و در واقع میخواهیم پروتکل استفاده شده را مشخص کنیم حط بعد شماره پورت مورد استفاده برنامه است که مقدار 9999 می باشد مقادیر وارد شده صرفا برای مثال می باشد و می توان هر مقداری را که در برنامه نیاز دارید ایجاد کنید.\n1package main 2import ( 3\u0026#34;fmt\u0026#34; 4\u0026#34;os\u0026#34; 5\u0026#34;gopkg.in/ini.v1\u0026#34; 6) 7 8func main() { 9cfg, err := ini.Load(\u0026#34;my.ini\u0026#34;) 10 11if err != nil { 12fmt.Printf(\u0026#34;Fail to read file: %v\u0026#34;, err) 13os.Exit(1) 14} 15 16// Classic read of values, default section can be represented as empty string 17fmt.Println(\u0026#34;App Mode:\u0026#34;, cfg.Section(\u0026#34;\u0026#34;).Key(\u0026#34;app_mode\u0026#34;).String()) 18fmt.Println(\u0026#34;Data Path:\u0026#34;, cfg.Section(\u0026#34;paths\u0026#34;).Key(\u0026#34;data\u0026#34;).String()) 19 20// Let\u0026#39;s do some candidate value limitation 21fmt.Println(\u0026#34;Server Protocol:\u0026#34;, 22cfg.Section(\u0026#34;server\u0026#34;).Key(\u0026#34;protocol\u0026#34;).In(\u0026#34;http\u0026#34;, []string{\u0026#34;http\u0026#34;, \u0026#34;https\u0026#34;})) 23 24// Value read that is not in candidates will be discarded and fall back to given default value 25fmt.Println(\u0026#34;Email Protocol:\u0026#34;, cfg.Section(\u0026#34;server\u0026#34;).Key(\u0026#34;protocol\u0026#34;).In(\u0026#34;smtp\u0026#34;, []string{\u0026#34;imap\u0026#34;, \u0026#34;smtp\u0026#34;})) 26 27// Try out auto-type conversion 28fmt.Printf(\u0026#34;Port Number: (%[1]T) %[1]d\\n\u0026#34;, cfg.Section(\u0026#34;server\u0026#34;).Key(\u0026#34;http_port\u0026#34;).MustInt(9999)) 29 30fmt.Printf(\u0026#34;Enforce Domain: (%[1]T) %[1]v\\n\u0026#34;, cfg.Section(\u0026#34;server\u0026#34;).Key(\u0026#34;enforce_domain\u0026#34;).MustBool(false)) 31 32// Now, make some changes and save it 33cfg.Section(\u0026#34;\u0026#34;).Key(\u0026#34;app_mode\u0026#34;).SetValue(\u0026#34;production\u0026#34;) cfg.SaveTo(\u0026#34;my.ini.local\u0026#34;) 34 35} خروجی اجرای کد بالا به این شکل است\n1$ go run main.go 2App Mode: development 3Data Path: /home/git/grafana 4Server Protocol: http 5Email Protocol: smtp Port Number: (int) 9999 6Enforce Domain: (bool) true 7 8$ cat my.ini.local 9# possible values : production, development 10app_mode = production [paths] 11# Path to where grafana can store temp files, sessions, and the sqlite3 db (if that is used) data = /home/git/grafana 12... کد بالا به اندازه کافی شفاف و ساده است که نیازی به توضیح بیشتر ندارد در ابتدا نیاز است تا بسته \u0026ldquo;gopkg.in/ini.v1\u0026rdquo; را به برنامه اضافه کنیم سپس با متد load فایل کانفیگ موجود را به حافظه بارگذاری می کنیم تا محتوای آن را بخوانیم و خط های بعد مقادیر آن را میخوانیم در خط پایانی نیز مقدار app_mode را به production تغییر دادیم و در فایل جدیدی به نام my.ini.local ذخیره کردیم .\nمی توانیم به شکل های مختلف یک فایل را بارگذاری یا ایجاد کنیم به مثال ذیل توجه کنید:\n1cfg, err := ini.Load( []byte(\u0026#34;raw data\u0026#34;), // Raw data 2\t\u0026#34;filename\u0026#34;, // File 3\tioutil.NopCloser(bytes.NewReader([]byte(\u0026#34;some other data\u0026#34;))), 4) در این قطعه کد ما تنظیمات خود را به 3 شکل می توانیم فراخوانی کنیم رشته، فایل و io.ReadCloser البته در صورت نیاز می توانیم یک فایل خالی در فضای حافظه بشکل ذیل نیز ایجاد کنیم.\n1cfg := ini.Empty() در ابتدا می توانید هر تعداد فایل ini را بارگذاری و یا فرخوانی کنید ولیکن مواقعی نیاز دارید که یک منبع دیگر به آنها اضافه کنید که برای این منظور می توانید از دستور Append استفاده نمائید\n1err := cfg.Append(\u0026#34;other file\u0026#34;, []byte(\u0026#34;other raw data\u0026#34;)) و یا مواقعی از چند منبع اقدام به بارگذاری می نمائید که احتمال دارد برخی از آن منابع خطا در بارگذاری دهد در این شرایط بهتر از تابع ()LooseLoadd استفاده کنید\n1cfg, err := ini.LooseLoad(\u0026#34;filename\u0026#34;, \u0026#34;filename_404\u0026#34;) و در نهایت می توانید پس از تغییرات دلخواه فایل را بصورت ذیل ذخیره نمائید\n1// ... 2err = cfg.SaveTo(\u0026#34;my.ini\u0026#34;) 3err = cfg.SaveToIndent(\u0026#34;my.ini\u0026#34;, \u0026#34;\\t\u0026#34;) همانطور که در بالا دید برای دسترسی به یک قسمت از فایل ما از تابع Section بصورت ذیل استفاده می کنیم\n1sec, err := cfg.GetSection(\u0026#34;section name\u0026#34;) که در اینجا \u0026ldquo;section name\u0026rdquo; نام قطعه کد ما در فایل تنظیمات است. برخی از توابع مهم این بسته عبارت اند از : 1.\n1err := cfg.NewSection(\u0026#34;new section\u0026#34;) جهت ایجاد قطعه جدید 2.\n1secs := cfg.Sections() 2names := cfg.SectionStrings() برای بدست آوردن تمامی قطعات داخل فایل 3.\n1key, err := cfg.Section(\u0026#34;\u0026#34;).GetKey(\u0026#34;app_mode\u0026#34;) برای بدست آوردن key یک section بطور مثال \u0026ldquo;app_mode\u0026rdquo; 4. ```go key, err := cfg.Section(\u0026quot;\u0026quot;).HasKey(\u0026ldquo;app_mode\u0026rdquo;)\n1برای بررسی وجود یک key 25. 3```go 4key, err := cfg.Section(\u0026#34;\u0026#34;).NewKey(\u0026#34;name\u0026#34;, \u0026#34;value\u0026#34;) برای ایجاد یک key جدید\n"},{"id":55,"href":"/chapter-4/work-with-environment-variable/","title":"4.13 آموزش کار با environment variable","section":"فصل چهارم: مباحث پیشرفته","content":"Environment Variables یا متغیرهای محیطی، متغیرهایی هستند که در فضای محیطی سیستم عامل مشخص شده‌اند. این متغیرها، شامل اطلاعاتی مانند مسیر فایل‌ها، تنظیمات سیستم، ترجیحات و تعیینات ساده و دیگر اطلاعات مورد استفاده توسط برنامه‌ها هستند.\nبه عنوان مثال، در سیستم عامل لینوکس، PATH یک متغیر محیطی است که شامل یک فهرست از دایرکتوری‌هایی است که سیستم به دنبال فایل‌ها و برنامه‌ها می‌گردد. برای دسترسی به این متغیر، می‌توان از دستور زیر در خط فرمان استفاده کرد:\n1echo $PATH همچنین، در زبان برنامه‌نویسی Go نیز استفاده از Environment Variables بسیار رایج است. برای نمونه، تنظیمات پایگاه داده را می‌توان با استفاده از Environment Variables در برنامه اصلی تنظیم کرد. در این مثال بسیار کوتاه، متصل شدن به پایگاه داده با استفاده از متغیرهای محیطی بیان شده است:\n1package main 2 3import ( 4 \u0026#34;database/sql\u0026#34; 5 \u0026#34;os\u0026#34; 6) 7 8func main() { 9 db, err := sql.Open(\u0026#34;postgres\u0026#34;, os.Getenv(\u0026#34;DATABASE_URL\u0026#34;)) 10 if err != nil { 11 panic(err) 12 } 13 defer db.Close() 14 15 // Do something with the database 16} در این مثال، پایگاه داده PostgreSQL از طریق پارامتر DATABASE_URL قابل تنظیم است. با استفاده از os.Getenv مقدار متغیر محیطی با همین نام به دست می‌آید و سپس به عنوان آرگومان به sql.Open ارائه می‌شود.\nاستفاده از Environment Variables یک روش مدیریتی عالی برای محیط برنامه است. این روش، به برنامه‌ها امکان می‌دهد که بدون اینکه برای هر برنامه یک سری تنظیمات خاص وجود داشته باشد، با یک سری تنظیمات کلی کار کنند و به صورت پویا و گسترده پاسخگو باشند.\n4.13.1 نحوه set کردن # در زبان برنامه‌نویسی Go، برای set کردن Environment Variables می‌توان از پکیج os استفاده کرد. برای مثال، برای تعیین متغیر محیطی با نام \u0026ldquo;DATABASE_URL\u0026rdquo; به مقدار \u0026ldquo;postgresql://localhost/mydb\u0026rdquo; می‌توانید از تابع os.Setenv استفاده کنید:\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;os\u0026#34; 6) 7 8func main() { 9 err := os.Setenv(\u0026#34;DATABASE_URL\u0026#34;, \u0026#34;postgresql://localhost/mydb\u0026#34;) 10 if err != nil { 11 panic(err) 12 } 13 fmt.Println(\u0026#34;Environment variable set successfully\u0026#34;) 14} در این مثال، با استفاده از تابع os.Setenv، متغیر محیطی با نام DATABASE_URL و مقدار postgresql://localhost/mydb تنظیم شده است. اگر خطا رخ دهد، با استفاده از تابع panic خطا ثبت می‌شود. سپس یک پیام تاییدی برای نشان دادن موفقیت set کردن متغیر محیطی نمایش داده می‌شود.\nاگر بخواهید یک Environment Variable را به یک مقدار خالی تنظیم کنید، می‌توانید از تابع os.Unsetenv استفاده کنید. برای مثال، برای حذف متغیر محیطی DATABASE_URL، کد زیر را می‌توانید استفاده کنید:\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;os\u0026#34; 6) 7 8func main() { 9 err := os.Unsetenv(\u0026#34;DATABASE_URL\u0026#34;) 10 if err != nil { 11 panic(err) 12 } 13 fmt.Println(\u0026#34;Environment variable unset successfully\u0026#34;) 14} در این مثال، با استفاده از تابع os.Unsetenv، متغیر محیطی با نام DATABASE_URL حذف شده است. اگر خطا رخ دهد، با استفاده از تابع panic خطا ثبت می‌شود. سپس یک پیام تاییدی برای نشان دادن موفقیت unset کردن متغیر محیطی نمایش داده می‌شود.\n4.13.2 نحوه get کردن # در زبان برنامه‌نویسی Go، برای get کردن Environment Variables می‌توان از پکیج os استفاده کرد. برای مثال، برای به دست آوردن مقدار متغیر محیطی با نام \u0026ldquo;DATABASE_URL\u0026rdquo; می‌توانید از تابع os.Getenv استفاده کنید:\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;os\u0026#34; 6) 7 8func main() { 9 dbUrl := os.Getenv(\u0026#34;DATABASE_URL\u0026#34;) 10 fmt.Printf(\u0026#34;Database URL: %s\\n\u0026#34;, dbUrl) 11} در این مثال، با استفاده از تابع os.Getenv، متغیر محیطی با نام DATABASE_URL به عنوان پارامتر به تابع ارسال شده و مقدار آن در یک متغیر به نام dbUrl ذخیره شده است. سپس با استفاده از تابع fmt.Printf، مقدار dbUrl به همراه یک پیام مشابه \u0026ldquo;Database URL: postgresql://localhost/mydb\u0026rdquo; نمایش داده می‌شود.\nاگر مقدار متغیر محیطی مورد نظر وجود نداشته باشد، تابع os.Getenv مقدار خالی برمی‌گرداند. لذا برای اطمینان از وجود مقدار متغیر محیطی، می‌توانید از تابع os.LookupEnv استفاده کنید. برای مثال، کد زیر چک می‌کند که آیا متغیر محیطی EMAIL تنظیم شده است یا خیر:\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;os\u0026#34; 6) 7 8func main() { 9 email, ok := os.LookupEnv(\u0026#34;EMAIL\u0026#34;) 10 if ok { 11 fmt.Printf(\u0026#34;Email address: %s\\n\u0026#34;, email) 12 } else { 13 fmt.Println(\u0026#34;Email address is not set\u0026#34;) 14 } 15} در این مثال، با استفاده از تابع os.LookupEnv، متغیر محیطی با نام EMAIL برای وجود مقدار بررسی شده است. اگر مقدار موجود بود، با استفاده از تابع fmt.Printf، مقدار این متغیر به همراه یک پیام مشابه \u0026ldquo;Email address: user@example.com\u0026rdquo; نمایش داده می‌شود. در صورتی که مقداری برای این متغیر وجود نداشته باشد، با استفاده از تابع fmt.Println، یک پیام مشابه \u0026ldquo;Email address is not set\u0026rdquo; نمایش داده می‌شود.\n4.13.3 کار با فایل env. # فایل .env یک فایل متنی است که حاوی متغیرهای محیطی برای برنامه شما است. در Go، می‌توانیم از پکیج godotenv استفاده کنیم تا مقادیر متغیرهای محیطی را از فایل .env بخوانیم و در متغیرهای خود بارگذاری کنیم.\nبرای استفاده از پکیج godotenv، ابتدا باید آن را با استفاده از دستور زیر نصب کنید:\n1go get github.com/joho/godotenv سپس می‌توانید از تابع godotenv.Load() استفاده کنید تا متغیرهای محیطی از فایل .env خوانده شود. در زیر یک مثال برای استفاده از پکیج godotenv به همراه فایل .env نشان داده شده است:\nفرض کنید فایل .env شما به شکل زیر باشد:\n1DATABASE_URL=postgresql://localhost/mydb 2API_KEY=AbCdEfGhIjKlMnOp حال در کد Go خود، پکیج godotenv را import کرده و با استفاده از تابع godotenv.Load()، متغیرهای محیطی از فایل .env خوانده شده و در متغیرهای خود بارگذاری کنید:\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;github.com/joho/godotenv\u0026#34; 6 \u0026#34;os\u0026#34; 7) 8 9func main() { 10 // Load environment variables from .env file 11 err := godotenv.Load() 12 if err != nil { 13 fmt.Println(\u0026#34;Error loading .env file\u0026#34;) 14 os.Exit(1) 15 } 16 17 // Get values of environment variables 18 dbUrl := os.Getenv(\u0026#34;DATABASE_URL\u0026#34;) 19 apiKey := os.Getenv(\u0026#34;API_KEY\u0026#34;) 20 21 // Print the values 22 fmt.Printf(\u0026#34;Database URL: %s\\n\u0026#34;, dbUrl) 23 fmt.Printf(\u0026#34;API Key: %s\\n\u0026#34;, apiKey) 24} در این مثال، با استفاده از تابع godotenv.Load()، متغیرهای محیطی از فایل .env خوانده شده و در متغیرهای خود بارگذاری شده‌اند. سپس با استفاده از تابع os.Getenv()، مقادیر این متغیرها به دست آمده و با استفاده از تابع fmt.Printf نمایش داده شده‌اند.\nبا استفاده از این روش، مقادیری که در فایل .env تعریف شده‌اند، در زمان اجرای برنامه به راحتی قابل دسترس خواهند بود و این اجازه را به شما می‌دهد که مقادیر مورد نیاز را به راحتی تغییر دهید و حتی بدون تغییر کد، برنامه خود را در محیط‌های مختلف اجرا کنید.\n"},{"id":56,"href":"/chapter-4/go-regular-expressions/","title":"4.14 آموزش کار با regexp","section":"فصل چهارم: مباحث پیشرفته","content":"مواقعی در کد نویسی دارید که نیاز هست تا یک عبارتی مثل شماره تلفن،کد پستی و یا شماره پاسپورت وارد شده را بصورت قاعده مند بررسی کنید به عبارتی کاربر نتواند برای فیلد شماره تلفن، کاراکتر غیر عددی وارد کند. در این مواقع بهتر است داده وارد شده بصورت قاعده مند بررسی شود. برای درک بهتر موضوع به رشته وارد شده توسط کاربر که می تواند سهوا باشد دقت کنید\n1+989121234#566 در این رشته کاربر مرتکب دو اشتباه شده است.\nشماره موبایل یک رقم بیشتر وارد شده است کاربر بجای رقم از علامت # استفاده کرده است در چنین شرایطی روش های بررسی مرسوم داده پاسخگو نیست و بهتر است از عبارات با قاعده استفاده کنیم.\nدر زبان برنامه نویسی Go بسته از پیش تعریف شده regexp برای اینکار وجود دارد.\n1import ( 2 \u0026#34;regexp\u0026#34; 3) برای شروع و درک بهتر مطلب اجازه دهید از یک مثال ساده شروع کنیم. میخواهیم بررسی کنیم آیا کاربر کارکتر نقطه [.] را وارد کرده است یا خیر .\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;regexp\u0026#34; 6) 7 8func main() { 9 sampleRegex := regexp.MustCompile(\u0026#34;[.]\u0026#34;) 10 match := sampleRegex.Match([]byte(\u0026#34;.\u0026#34;)) 11 fmt.Println(match) 12} در کد فوق به کمک تابع MustCompile عبارت قاعده مند را دریافت می کنیم در صورتیکه عبارت وارد شده قابل قبول یا معتبر نباشد panic اتفاق خواهد افتاد . دقت داشته باشید که خود عبارت قاعده مند دارای استاندارد و چارچوب های مشخص است که بهتر است درصورت عدم اطلاع از ابتدا آن را بیاموزید.\nدقت کنید که در کد فوق عبارت مد نظر خود را داخل [] قرار داده ایم و در خط بعد با تابع Match که مقدار مورد نظر را بصورت رشته ای از بایت ها به آن معرفی کرده ایم بررسی می کنیم که \u0026ldquo;.\u0026rdquo; در رشته وجود دارد یا خیر که خروجی این بررسی یک مقدار بولین بصورت ذیل است.\n1true در واقع می توانید رشته های ساده را نیز با این روش مقایسه کنید بطور مثال :\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;regexp\u0026#34; 6) 7func main() { 8 first := \u0026#34;abc\u0026#34; 9 second := \u0026#34;xyz\u0026#34; 10 third := \u0026#34;123\u0026#34; 11 sampleRegex := regexp.MustCompile(first + second + third) 12 13 match := sampleRegex.Match([]byte(\u0026#34;abcxyz123\u0026#34;)) 14 fmt.Println(match) 15} خروجی بررسی بالا\n1$go run main.go 2true اگر به کد فوق دقت کنید متوجه خواهید شد که مقادیر بررسی شده بصورت کامل بوده و چنانچه بررسی شما شامل بخشی از عبارت وارد شده باشد باز نتیجه بررسی اشتباه خواهد بود برای مثال ما قسمتی از کد را تغییر می دهیم\n1package main 2... 3func main() { 4 5\t... 6 match := sampleRegex.Match([]byte(\u0026#34;abcxyz\u0026#34;)) 7 8 fmt.Println(match) 9 10} در اینجا نتیجه بررسی برای عبارت \u0026ldquo;abcxyz\u0026rdquo; که در عبارت اصلی یعنی \u0026ldquo;abcxyz123\u0026rdquo; قرار دارد مقدار false نمایش داده خواهد شد که این به معنای بررسی کل عبارت است. برای رفع این اشتباه می بایست از ساختار عبارات قاعده مند بهر بگیریم و به این شکل به برنامه اطلاع دهیم که عبارت مد نظر ما می تواند بخشی از عبارت وارد شده باشد.\n1package main 2import ( 3 \u0026#34;fmt\u0026#34; 4 \u0026#34;regexp\u0026#34; 5) 6func main() { 7 sampleRegex := regexp.MustCompile(\u0026#34;[abc]\u0026#34;) 8 match := sampleRegex.Match([]byte(\u0026#34;abcd\u0026#34;)) 9 10 fmt.Printf(\u0026#34;For abcd: %t\\n\u0026#34;, match) 11 match = sampleRegex.Match([]byte(\u0026#34;1abc23\u0026#34;)) 12 fmt.Printf(\u0026#34;For 1abc23: %t\\n\u0026#34;, match) 13 14 match = sampleRegex.Match([]byte(\u0026#34;abc\u0026#34;)) 15 fmt.Printf(\u0026#34;For abc: %t\\n\u0026#34;, match) 16} خروجی کد\n1$go run main.go 2For abcd: true 3For 1abc23: true 4For abc: true در کد فوق کارکترهای [] به این معنا است که عبارت مورد نظر می تواند شامل عبارت مورد مقایسه نیز باشد. به چند تا از علائم و معانی پرکاربرد در عبارات قاعده مند توجه کنید.\n\\w فقط شامل حروف باشد \\W شامل حروف نباشد \\d شامل اعداد باشد \\Dشامل اعداد نباشد \\s شامل فضای خالی باشد \\S شامل فضای خالی نباشد \\+ شامل حداقل یک یا بیشتر باشد \\* شامل صفر یا بیشتر باشد \\| شامل عبارت مورد نظر و یا مورد دیگر باشد لیست کامل این عبارات را می توانید در اینجا مشاهده کنید.\nدر مواقعی مایل هستیم که عبارت مورد نظر در رشته را جستجو و نمایش دهیم بطور مثال:\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;regexp\u0026#34; 6) 7 8func main() { 9\tsampleRegexp := regexp.MustCompile(`(ab){2}`) 10 11\tmatches := sampleRegexp.FindString(\u0026#34;abab\u0026#34;) 12\tfmt.Println(matches) 13 14\tmatches = sampleRegexp.FindString(\u0026#34;ababbc\u0026#34;) 15\tfmt.Println(matches) 16} در اینجا از برنامه خواسته ایم که به دنبال ترکیبی از ab با تکرار دوبار متوالی باشد و در انتها عبارت پیدا شده توسط تابع FindString را نمایش دهد که علامت () تاکید روی عبارت مورد نظر است و {2} به معنی تکرار حداقل دوبار متوالی است.\nخروجی کد بالا\n1$go run main.go 2abab 3abab در پایان می خواهیم یک مثال سختر را که در ابتدا به آن اشاره کردیم بنویسیم و آن بررسی شماره تلفن است.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;regexp\u0026#34; 6) 7 8func main() { 9\tsampleRegexp := regexp.MustCompile(`^\\+989(1[0-9]|3[1-9]|2[1-9])?[0-9]{7}$`) 10 11\tmatches := sampleRegexp.Match([]byte(\u0026#34;+989121234#566\u0026#34;)) 12\tfmt.Println(matches) 13 14\tmatches = sampleRegexp.Match([]byte(\u0026#34;+989121234567\u0026#34;)) 15\tfmt.Println(matches) 16} خروجی کد بالا\n1$ go run main.go 2false 3true در کد فوق علامت ^ در عبارات با قاعده به معنی شروع ساختار عبارت است و علامت $ به معنای پایان عبارت. درواقع تمامی رشته های که قرار است عتبار سنجی شوند باید در ساختار بین این تو کاراکتر تطبیق شوند. در ادامه نیاز است تا با کمک کاراکتر \\ اثر کارکتر + را خنثی کنیم به این معنی که تمامی شماره های وارد شده باید علامت + در ابتدا داشته باشند سپس قید شده است که 989 که پیش شمار ایران و موبایل است را قید کرده ایم . از آنجا که شماره موبایلهای ایران 911|912|913 شروع می شود با این عبارت \u0026ldquo;(1[0-9]|3[1-9]|2[1-9])\u0026rdquo; مشخص کرده ایم. علامت ؟ به معنی حداقل یکبار تکرار شده عبارت قبل خودش است و در انتها کاربر می بایست هفت رقم وارد که به این صورت مشخص شده است \u0026ldquo;[0-9]{7}\u0026rdquo;. همانطور مشاهده می کنید رشته اول معتبر نبوده ولی رشته دوم صحیح است.\n"},{"id":57,"href":"/chapter-4/go-reflection/","title":"4.15 آموزش reflection","section":"فصل چهارم: مباحث پیشرفته","content":"پکیج reflect در زبان Go، امکانات reflection زمان اجرا را فراهم می‌کند که به یک برنامه اجازه می‌دهد تا با اشیاءی با انواع دلخواه کار کند. استفاده اصلی این پکیج، گرفتن اطلاعات نوع پویای یک مقدار با نوع استاتیک interface{} با فراخوانی تابع TypeOf است که یک مقدار Type را برمی‌گرداند.\nبا فراخوانی تابع ValueOf، یک شیء Value که حاوی دادهٔ زمان اجراست، برمی‌گرداند. تابع Zero یک مقدار Type دریافت کرده و یک شیء Value را که مقدار صفر برای آن نوع است، برمی‌گرداند.\n4.15.1 تعریف reflection و metaprogramming # قبل از شروع آموزش، باید مفاهیم metaprogramming و reflection زمان اجرا را بفهمیم. می‌توانیم کدهای منبع خود را به دو شکل کد و داده در نظر بگیریم.\nاگر کدهای منبع را به عنوان کد در نظر بگیریم، می‌توانیم آن‌ها را روی CPU اجرا کنیم.\nاز طرف دیگر، اگر کدهای منبع را به عنوان داده در نظر بگیریم، می‌توانیم مانند داده‌های معمولی فرآیند برنامه را برای آن‌ها بررسی و به‌روزرسانی کنیم. به عنوان مثال، می‌توانید تمام خصوصیات یک ساختار را بدون داشتن همه خصوصیات آن بدانید.\nmetaprogramming به تکنیکی از برنامه نویسی گفته می‌شود که برنامه را به عنوان داده مورد بررسی قرار می‌دهد. تکنیک‌های metaprogramming می‌توانند برنامه‌های دیگر را بررسی و پردازش کنند، یا حتی در حین اجرای برنامه به خود برنامه دسترسی داشته باشند.\nreflection زمان اجرا زیر مجموعه‌ای از الگوی metaprogramming است. تقریباً تمام زبان‌های محبوب، API داخلی را برای مدیریت metaprogramming برای زبان برنامه‌نویسی خود ارائه می‌دهند. این API ها به عنوان امکانات reflection زمان اجرا شناخته می‌شوند و به عنوان قابلیت زبان برنامه‌نویسی خاصی برای بررسی، تغییر و اجرای ساختار کد عمل می‌کنند.\nبنابراین، ما می‌توانیم کارهایی مانند:\nبررسی خصوصیات یک ساختار بررسی وجود یک تابع در یک نمونه ساختار بررسی نوع اتمی یک متغیر ناشناخته با API های reflection زمان اجرا را انجام دهیم. حال به بررسی بیشتر اینکه این چگونه در زبان برنامه نویسی Go کار می‌کند، می‌پردازیم.\n4.15.2 کاربردهای reflection # مفهوم reflection به طور معمول یک API اصلی را برای بررسی یا تغییر برنامه فعلی ارائه می‌دهد. ممکن است فکر کنید که در مورد کد منبع برنامه خود آگاه هستید، پس چرا نیاز به بررسی کد نوشته شده خود با استفاده از reflection دارید؟ اما reflection دارای موارد کاربرد مفید زیادی است، که در زیر ذکر شده است:\nبرنامه‌نویسان می‌توانند از reflection استفاده کنند تا با کمترین کد، مشکلات برنامه‌نویسی را حل کنند. به عنوان مثال، اگر از یک نمونه ساختاری برای ساخت یک پرس و جوی SQL استفاده می‌کنید، می‌توانید با استفاده از reflection، فیلدهای ساختار را بدون هاردکد کردن نام هر فیلد ساختاری استخراج کنید. با توجه به اینکه reflection یک روش برای بررسی ساختار برنامه ارائه می‌دهد، ممکن است با استفاده از آن، تحلیلگرهای کد استاتیکی ساخته شود. با استفاده از API reflection، ما می‌توانیم کد را به صورت پویا اجرا کنیم. به عنوان مثال، شما می‌توانید متدهای موجود یک ساختار را پیدا کرده و با نام آن‌ها تماس بگیرید. بخش آموزشی زیر همه اصول مورد نیاز برای پیاده‌سازی موارد کاربرد فوق را پوشش خواهد داد. همچنین، به شما نشان خواهم داد که چگونه می‌توانید یک برنامه shell ساده با API reflection بسازید.\nاکنون که مفهوم reflection را پوشش دادیم، با مثال‌های عملی شروع کنیم.\nپکیج reflection Go به ما reflect در زمان اجرا را ارائه می‌دهد، لذا این مثال‌ها ساختار برنامه را در طول زمان اجرا بررسی یا تغییر می‌دهند. با توجه به اینکه Go یک زبان کامپایل شده با نوع استاتیک است، API reflection آن بر اساس دو عنصر کلیدی، نوع reflection و مقدار reflection، ساخته شده است.\n5.15.3 بررسی تایپ های متغیرها # در ابتدا، می‌توانیم با پکیج reflect، از بررسی نوع متغیرها برای شروع استفاده کنیم. کد زیر را ببینید که نوع چندین متغیر را چاپ می‌کند.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;reflect\u0026#34; 6) 7 8func main() { 9\tx := 10 10\tname := \u0026#34;Go Lang\u0026#34; 11\ttype Book struct { 12\tname string 13\tauthor string 14\t} 15\tsampleBook := Book{\u0026#34;Reflection in Go\u0026#34;, \u0026#34;John\u0026#34;} 16\tfmt.Println(reflect.TypeOf(x)) // int 17\tfmt.Println(reflect.TypeOf(name)) // string 18\tfmt.Println(reflect.TypeOf(sampleBook)) // main.Book 19} 1$ go run main.go 2int 3string 4main.Book کد بالا نوع داده‌های متغیرها را با استفاده از تابع reflect.TypeOf چاپ می‌کند. تابع TypeOf یک نمونه reflection Type بازگردانده می‌کند که توابعی برای دسترسی به اطلاعات بیشتر درباره نوع فعلی فراهم می‌کند. برای مثال، می‌توانیم از تابع Kind برای بدست آوردن نوع ابتدایی یک متغیر استفاده کنیم. به خاطر داشته باشید که کد بالا نوع داده ساختار اختصاصی main.Book برای متغیر sampleBook را نشان می‌دهد - نه نوع ساختار ابتدایی.\nبرای بدست آوردن نوع ابتدایی، کد بالا را به صورت زیر تغییر دهید:\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;reflect\u0026#34; 6) 7 8func main() { 9\tvar ( 10\tstr = \u0026#34;Hello, world!\u0026#34; 11\tnum = 42 12\tflt = 3.14 13\tboo = true 14\tslice = []int{1, 2, 3} 15\tmymap = map[string]int{\u0026#34;foo\u0026#34;: 1, \u0026#34;bar\u0026#34;: 2} 16\tstructure = struct{ Name string }{Name: \u0026#34;John Doe\u0026#34;} 17\tinterface1 interface{} = \u0026#34;hello\u0026#34; 18\tinterface2 interface{} = \u0026amp;structure 19\t) 20 21\tfmt.Println(reflect.TypeOf(str).Kind()) 22\tfmt.Println(reflect.TypeOf(num).Kind()) 23\tfmt.Println(reflect.TypeOf(flt).Kind()) 24\tfmt.Println(reflect.TypeOf(boo).Kind()) 25\tfmt.Println(reflect.TypeOf(slice).Kind()) 26\tfmt.Println(reflect.TypeOf(mymap).Kind()) 27\tfmt.Println(reflect.TypeOf(structure).Kind()) 28\tfmt.Println(reflect.TypeOf(interface1).Kind()) 29\tfmt.Println(reflect.TypeOf(interface2).Kind()) 30} 1$ go run main.go 2string 3int 4float64 5bool 6slice 7map 8struct 9string 10ptr دلیلی که در کد بالا برای سومین دستور چاپ، struct چاپ می‌شود، این است که تابع Kind reflection Type یک reflection Kind بازگردانده که اطلاعات نوع اولیه را نگه می‌دارد. در این حالت، reflection Kind نوع اولیه ساختار است.\n5.15.3.1 اندازه تایپ های مقداردهی شده # همچنین می‌توانیم از تابع Size reflection Type استفاده کنیم تا تعداد بایت‌های مورد نیاز برای ذخیره نوع فعلی را بدست آوریم. کد زیر را ببینید:\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;reflect\u0026#34; 6) 7 8func main() { 9\tvar ( 10\tstr = \u0026#34;Hello, world!\u0026#34; 11\tnum = 42 12\tflt = 3.14 13\tboo = true 14\tslice = []int{1, 2, 3} 15\tmymap = map[string]int{\u0026#34;foo\u0026#34;: 1, \u0026#34;bar\u0026#34;: 2} 16\tstructure = struct{ Name string }{Name: \u0026#34;John Doe\u0026#34;} 17\t) 18 19\tfmt.Printf(\u0026#34;Size of str: %d\\n\u0026#34;, reflect.TypeOf(str).Size()) 20\tfmt.Printf(\u0026#34;Size of num: %d\\n\u0026#34;, reflect.TypeOf(num).Size()) 21\tfmt.Printf(\u0026#34;Size of flt: %d\\n\u0026#34;, reflect.TypeOf(flt).Size()) 22\tfmt.Printf(\u0026#34;Size of boo: %d\\n\u0026#34;, reflect.TypeOf(boo).Size()) 23\tfmt.Printf(\u0026#34;Size of slice: %d\\n\u0026#34;, reflect.TypeOf(slice).Size()) 24\tfmt.Printf(\u0026#34;Size of mymap: %d\\n\u0026#34;, reflect.TypeOf(mymap).Size()) 25\tfmt.Printf(\u0026#34;Size of structure: %d\\n\u0026#34;, reflect.TypeOf(structure).Size()) 26} این کد، با استفاده از تابع Size reflection Type، تعداد بایت‌های مورد نیاز برای ذخیره هر نوع را چاپ می‌کند. با اجرای این کد، خروجی زیر را خواهید داشت:\n1$ go run main.go 2Size of str: 16 3Size of num: 8 4Size of flt: 8 5Size of boo: 1 6Size of slice: 24 7Size of mymap: 8 8Size of structure: 0 در این کد، تعداد بایت‌های مورد نیاز برای نوع string 16 بایت، برای نوع int 8 بایت، برای نوع float64 8 بایت، برای نوع bool 1 بایت، برای نوع slice 24 بایت و برای نوع map 8 بایت است. برای نوع ساختاری structure بایتی نیاز نیست و برابر با صفر است.\n5.15.4 بررسی مقدار یک متغیر # قبلاً، اطلاعات نوع داده‌ها را بررسی کردیم. همچنین با استفاده از پکیج reflect، می‌توانیم مقادیر متغیرها را استخراج کنیم. کد زیر، مقادیر متغیرها را با استفاده از تابع reflect.ValueOf چاپ می‌کند:\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;reflect\u0026#34; 6) 7 8func main() { 9\tvar ( 10\tstr = \u0026#34;Hello, world!\u0026#34; 11\tnum = 42 12\tflt = 3.14 13\tboo = true 14\tslice = []int{1, 2, 3} 15\tmymap = map[string]int{\u0026#34;foo\u0026#34;: 1, \u0026#34;bar\u0026#34;: 2} 16\tstructure = struct{ Name string }{Name: \u0026#34;John Doe\u0026#34;} 17\t) 18 19\tfmt.Printf(\u0026#34;Value of str: %v\\n\u0026#34;, reflect.ValueOf(str)) 20\tfmt.Printf(\u0026#34;Value of num: %v\\n\u0026#34;, reflect.ValueOf(num)) 21\tfmt.Printf(\u0026#34;Value of flt: %v\\n\u0026#34;, reflect.ValueOf(flt)) 22\tfmt.Printf(\u0026#34;Value of boo: %v\\n\u0026#34;, reflect.ValueOf(boo)) 23\tfmt.Printf(\u0026#34;Value of slice: %v\\n\u0026#34;, reflect.ValueOf(slice)) 24\tfmt.Printf(\u0026#34;Value of mymap: %v\\n\u0026#34;, reflect.ValueOf(mymap)) 25\tfmt.Printf(\u0026#34;Value of structure: %v\\n\u0026#34;, reflect.ValueOf(structure)) 26} این کد، با استفاده از تابع reflect.ValueOf، مقادیر متغیرها را چاپ می‌کند. با اجرای این کد، خروجی زیر را خواهید داشت:\n1$ go run main.go 2Value of str: Hello, world! 3Value of num: 42 4Value of flt: 3.14 5Value of boo: true 6Value of slice: [1 2 3] 7Value of mymap: map[bar:2 foo:1] 8Value of structure: {John Doe} در این کد، مقادیر متغیرها با استفاده از تابع reflect.ValueOf چاپ می‌شوند. به خاطر داشته باشید که تابع ValueOf یک نمونه reflection Value بازگردانده می‌کند، که اطلاعات مربوط به مقدار و نوع متغیر را نگه‌داری می‌کند. برای چاپ مقدار واقعی، باید از توابع مربوط به reflection Value استفاده کنیم.\n5.15.5 تغییر مقدار یک متغیر # قبلاً، ساختار کد را با استفاده از چندین تابع در پکیج reflect بررسی کردیم. همچنین با استفاده از API بازتاب Go، امکان تغییر کد در حین اجرا وجود دارد. در کد زیر، نحوه به‌روزرسانی یک فیلد رشته‌ای در یک ساختار را مشاهده می‌کنید:\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;reflect\u0026#34; 6) 7 8type Person struct { 9\tName string 10\tAge int 11} 12 13func main() { 14\tp := Person{Name: \u0026#34;John\u0026#34;, Age: 30} 15\tfmt.Println(\u0026#34;Before update:\u0026#34;, p) 16 17\tv := reflect.ValueOf(\u0026amp;p) 18\tif v.Kind() == reflect.Ptr { 19\tv = v.Elem() 20\t} 21 22\tf := v.FieldByName(\u0026#34;Name\u0026#34;) 23\tif f.IsValid() \u0026amp;\u0026amp; f.CanSet() { 24\tf.SetString(\u0026#34;Jane\u0026#34;) 25\t} 26 27\tfmt.Println(\u0026#34;After update:\u0026#34;, p) 28} در این کد، یک ساختار به نام Person تعریف شده است که دو فیلد Name و Age دارد. در تابع main، یک نمونه از ساختار Person با مقدار پیش‌فرض Name: \u0026ldquo;John\u0026rdquo; و Age: 30 ایجاد شده است. سپس با استفاده از تابع reflect.ValueOf، نمونه ساختار Person به یک reflection Value تبدیل شده و با استفاده از تابع Kind، نوع آن بررسی می‌شود. اگر نوع نمونه یک اشاره‌گر باشد، با استفاده از تابع Elem، به مقدار اشاره شده تبدیل می‌شود.\nدر ادامه، با استفاده از تابع FieldByName، فیلد Name در نمونه ساختار Person بدست آورده می‌شود. سپس با استفاده از تابع IsValid بررسی می‌شود که آیا فیلد موجود است یا خیر. در صورت وجود، با استفاده از تابع CanSet بررسی می‌شود که آیا می‌توان آن را تغییر داد یا خیر. در صورت امکان تغییر، با استفاده از تابع SetString، مقدار فیلد Name به \u0026ldquo;Jane\u0026rdquo; تغییر می‌یابد.\nدر نهایت، با چاپ دوباره مقدار نمونه ساختار Person، تغییر در فیلد Name را مشاهده می‌کنیم. با اجرای این کد، خروجی زیر را خواهید داشت:\n1$ go run main.go 2Before update: {John 30} 3After update: {Jane 30} در این حالت، با استفاده از پکیج reflect، می‌توانیم برنامه را در حین اجرا تغییر داده و به داده‌های موجود در حافظه دسترسی پیدا کنیم.\n5.15.6 بررسی اطلاعات یک struct # بیایید یک کد نمونه برای بررسی همه فیلدهای یک ساختار بنویسیم. در طول بررسی، می‌توانیم نام و مقدار هر فیلد ساختار را نمایش دهیم. کد زیر این کار را انجام می‌دهد:\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;reflect\u0026#34; 6) 7 8type Person struct { 9\tName string 10\tAge int 11\tAddress string 12} 13 14func main() { 15\tp := Person{Name: \u0026#34;John\u0026#34;, Age: 30, Address: \u0026#34;123 Main St.\u0026#34;} 16 17\tv := reflect.ValueOf(p) 18\tif v.Kind() == reflect.Ptr { 19\tv = v.Elem() 20\t} 21 22\tfor i := 0; i \u0026lt; v.NumField(); i++ { 23\tfield := v.Field(i) 24\tfmt.Printf(\u0026#34;Field %d: %s = %v\\n\u0026#34;, i, v.Type().Field(i).Name, field.Interface()) 25\t} 26} در این کد، یک ساختار به نام Person تعریف شده است که دارای سه فیلد Name، Age و Address است. در تابع main، یک نمونه از ساختار Person با مقدار پیش‌فرض Name: \u0026ldquo;John\u0026rdquo;، Age: 30 و Address: \u0026ldquo;123 Main St.\u0026rdquo; ایجاد شده است.\nسپس با استفاده از تابع reflect.ValueOf، نمونه ساختار Person به یک reflection Value تبدیل شده و با استفاده از تابع Kind، نوع آن بررسی می‌شود. اگر نوع نمونه یک اشاره‌گر باشد، با استفاده از تابع Elem، به مقدار اشاره شده تبدیل می‌شود.\nدر ادامه، با استفاده از تابع NumField، تعداد فیلدهای موجود در نمونه ساختار Person بدست آورده می‌شود. سپس در یک حلقه، با استفاده از تابع Field، مقدار هر فیلد به همراه نام آن چاپ می‌شود. با استفاده از تابع Type، نوع نمونه ساختار Person به دست می‌آید، و با استفاده از تابع Field(i).Name، نام فیلد در ایندکس i بدست می‌آید. در نهایت، با استفاده از تابع Interface، مقدار فیلد به صورت یک interface{} برگردانده می‌شود و چاپ می‌شود.\nبا اجرای این کد، خروجی زیر را خواهید داشت:\n1$ go run main.go 2Field 0: Name = John 3Field 1: Age = 30 4Field 2: Address = 123 Main St. در این حالت، با استفاده از پکیج reflect، می‌توانیم برای هر ساختار، همه فیلدها را بررسی کرده و نام و مقدار هر فیلد را چاپ کنیم.\n5.15.7 بررسی متدها (Methods) # فرض کنید شما یک موتور دستور سفارشی برای یک برنامه شل پیاده‌سازی می‌کنید و برای اجرای توابع Go بر اساس دستورات ورودی کاربر، نیاز دارید دستورات را به توابع مرتبط تخصیص دهید. اگر تعداد توابع کم باشد، می‌توانید از یک switch-case statement استفاده کنید. اما اگر تعداد توابع صد‌ها نفر باشد؟ در این صورت، ما می‌توانیم توابع Go را براساس نام آن‌ها به صورت پویا فراخوانی کنیم. برنامه شل پایه‌ای زیر با استفاده از بازتاب این کار را انجام می‌دهد:\n1package main 2import ( 3 \u0026#34;fmt\u0026#34; 4 \u0026#34;reflect\u0026#34; 5 \u0026#34;bufio\u0026#34; 6 \u0026#34;os\u0026#34; 7) 8type NativeCommandEngine struct{} 9func (nse NativeCommandEngine) Method1() { 10 fmt.Println(\u0026#34;INFO: Method1 executed!\u0026#34;) 11} 12func (nse NativeCommandEngine) Method2() { 13 fmt.Println(\u0026#34;INFO: Method2 executed!\u0026#34;) 14} 15func (nse NativeCommandEngine) callMethodByName(methodName string) { 16 method := reflect.ValueOf(nse).MethodByName(methodName) 17 if !method.IsValid() { 18 fmt.Println(\u0026#34;ERROR: \\\u0026#34;\u0026#34; + methodName + \u0026#34;\\\u0026#34; is not implemented\u0026#34;) 19 return 20 } 21 method.Call(nil) 22} 23func (nse NativeCommandEngine) ShowCommands() { 24 val := reflect.TypeOf(nse) 25 for i := 0; i \u0026lt; val.NumMethod(); i++ { 26 fmt.Println(val.Method(i).Name) 27 } 28} 29func main() { 30 nse := NativeCommandEngine{} 31 fmt.Println(\u0026#34;A simple Shell v1.0.0\u0026#34;) 32 fmt.Println(\u0026#34;Supported commands:\u0026#34;) 33 nse.ShowCommands() 34 scanner := bufio.NewScanner(os.Stdin) 35 fmt.Print(\u0026#34;$ \u0026#34;) 36 for scanner.Scan() { 37 nse.callMethodByName(scanner.Text()) 38 fmt.Print(\u0026#34;$ \u0026#34;) 39 } 40} 1$ go run main.go 2A simple Shell v1.0.0 3Supported commands: 4Method1 5Method2 6ShowCommands 7$ برنامه شلی که پیشتر نوشتیم، ابتدا تمام دستورات پشتیبانی شده را نشان می‌دهد. سپس کاربر می‌تواند دستورات را به دلخواه خود وارد کند. هر دستور شل یک متد متناظر دارد، و اگر یک متد خاص وجود نداشته باشد، شل پیام خطا چاپ می‌کند.\n5.15.8 نوشتن custom tag برای فیلد های ساختار # تگ سفارشی مانند json:\u0026quot;name\u0026quot; در گو، برای اتصال متاداده به فیلدهای یک ساختار استفاده می‌شود. بسته reflect در گو، یک راه برای دسترسی به این تگ‌ها در زمان اجرا فراهم می‌کند. برای ایجاد یک تگ سفارشی در گو، می‌توان از بسته reflect برای دسترسی به تگ‌ها بر روی یک فیلد ساختار استفاده کرد.\nدر ادامه مثالی از چگونگی ایجاد یک تگ سفارشی با بسته reflect در گو آورده شده است:\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;reflect\u0026#34; 6) 7 8type Person struct { 9\tName string `customtag:\u0026#34;myname\u0026#34;` 10\tAge int `customtag:\u0026#34;myage\u0026#34;` 11} 12 13func main() { 14\tp := Person{\u0026#34;John\u0026#34;, 30} 15 16\tt := reflect.TypeOf(p) 17\tv := reflect.ValueOf(p) 18 19\tfor i := 0; i \u0026lt; t.NumField(); i++ { 20\tfield := t.Field(i) 21\tvalue := v.Field(i) 22 23\ttag := field.Tag.Get(\u0026#34;customtag\u0026#34;) 24 25\tfmt.Printf(\u0026#34;Field: %s, Value: %v, Tag: %s\\n\u0026#34;, field.Name, value.Interface(), tag) 26\t} 27} در این مثال، یک ساختار Person با دو فیلد Name و Age تعریف شده است. هر یک از این فیلدها با استفاده از کلید customtag یک تگ سفارشی دارند.\nبرای دسترسی به تگ‌ها در زمان اجرا، از بسته reflect استفاده می‌شود. با استفاده از reflect.TypeOf و reflect.ValueOf نوع و مقدار ساختار Person بدست می‌آیند. سپس با استفاده از حلقه for و توابع t.NumField() و t.Field(i) بر روی فیلدهای ساختار حرکت می‌کنیم. برای هر فیلد، با استفاده از v.Field(i) مقدار آن را و با استفاده از field.Tag.Get(\u0026quot;customtag\u0026quot;) تگ سفارشی آن را بدست می‌آوریم.\nدر نهایت با استفاده از fmt.Printf نام فیلد، مقدار آن و تگ سفارشی آن را چاپ می‌کنیم. خروجی این برنامه به شکل زیر خواهد بود:\n1$ go run main.go 2Field: Name, Value: John, Tag: myname 3Field: Age, Value: 30, Tag: myage این نشان می‌دهد که چگونه می‌توان با استفاده از بسته reflect در گو تگ‌های سفارشی را ایجاد کرد.\n"},{"id":58,"href":"/chapter-4/go-generator/","title":"4.16 آموزش generator","section":"فصل چهارم: مباحث پیشرفته","content":"کد generator در گو، یک ابزار است که برای تولید کد خودکار استفاده می‌شود. برای ایجاد یک کد generator در گو، می‌توان از قابلیت‌هایی که در زبان گو موجود است، مانند بسته‌های go/ast و go/parser استفاده کرد.\nبا استفاده از بسته go/ast می‌توانید ساختار داده‌های AST (Abstract Syntax Tree) را برای کد خود بسازید. AST، ساختار درختی از کدهای گو است که به طور معمول برای بررسی و تحلیل کد استفاده می‌شود.\nبا استفاده از بسته go/parser می‌توانید کد منبع گو را به عنوان ورودی بگیرید و برای آن AST بسازید.\nبا استفاده از این دو بسته، می‌توانید یک کد generator بسازید که برای تولید کد خودکار، کد منبع گو را تحلیل کرده و براساس آن، کد جدیدی را ایجاد کند. برای مثال، می‌توانید یک کد generator بسازید که برای تولید کد تست، کد منبع گو را تحلیل کرده و برای هر تابع یا متد، تست مربوطه را بسازد.\nبا توجه به این که کد generator‌ها برای تولید کد خودکار استفاده می‌شوند، باید دقت شود که کد تولید شده باید قابل خواندن و تصحیح باشد. همچنین، باید از بهبود کیفیت کد تولید شده نیز اطمینان حاصل شود.\nدر کل، با استفاده از بسته‌های go/ast و go/parser می‌توانید یک کد generator قدرتمند در گو بسازید که برای تولید کد خودکار بسیار مفید است.\nاین بخش ادامه دارد\u0026hellip;\n"},{"id":59,"href":"/chapter-4/go-stringer/","title":"4.17 آموزش stringer","section":"فصل چهارم: مباحث پیشرفته","content":"Stringer به طور کلی برای پیاده‌سازی مفهوم شمارشی (enumeration) استفاده می‌شود در حالی که از برنامه‌نویسی ثابت رشته‌های مقدار استفاده نمی‌کند. شمارشی یا enum زمانی استفاده می‌شود که می‌خواهید مجموعه‌ای متناهی و ثابتی از مقادیر یک نوع داده‌ای را تعریف کنید. به عنوان مثال، انواع غذا در منو (پیش غذا، اصلی، دسر)، انواع پوکمون (گیاهی، آبی، آتشی، و غیره).\nبنابراین، زمانی که می‌خواهیم از این مجموعه‌های تعریف شده استفاده کنیم، باید از برنامه‌نویسی ثابت رشته‌های مقدار استفاده کنیم زیرا ممکن است به خطاهای انسانی مانند اشتباهات املایی منجر شود. اگر از Stringer استفاده کنیم، مقادیر را یکبار تولید می‌کنیم و مطمئن می‌شویم که هیچ خطایی ایجاد نمی‌شود. پس از آن، می‌توانیم از آن‌ها بدون نگرانی از خطاهای انسانی استفاده کنیم.\n4.17.1 پیاده سازی متد String برای آبجکت ها # شما می توانید برای هر یک از آبجکت ها متد String را پیاده سازی کنید و یک خروجی استرینگ در خصوص مقادیر آبجکت داشته باشید.\nبه مثال کاربردی زیر توجه کنید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type Age int 6 7const ( 8\tCHILDERN Age = iota 9\tADOLESCENTS 10\tADULTS 11) 12 13func (a Age) String() string { 14\tswitch a { 15\tcase CHILDERN: 16\treturn \u0026#34;childern\u0026#34; 17\tcase ADOLESCENTS: 18\treturn \u0026#34;adolescents\u0026#34; 19\tcase ADULTS: 20\treturn \u0026#34;adults\u0026#34; 21\tdefault: 22\treturn \u0026#34;\u0026#34; 23\t} 24} 25 26func main() { 27\tfmt.Println(CHILDERN.String()) 28} 1$ go run main.go 2childern در مثال فوق ما یک تایپ Age تعریف کردیم و سپس یکسری enum با همان تایپ قرار دادیم پس از آن متد String را پیاده سازی کردیم که بتوانیم رشته هرکدام از enum ها را بگیریم.\n4.17.2 استفاده از ابزار stringer # شما با استفاده از ابزار stringer می توانید به راحتی برای enum های خود رشته را بصورت خودکار ایجاد کنید.\nبرای نصب این ابزار در ابتدا باید دستور زیر را بزنید تا داخل go bin نصب شود:\n1$ go install golang.org/x/tools/cmd/stringer@latest اکنون بخواهیم با استفاده از ابزار stringer متد استرینگ جنریت کنیم کافیه مثال زیر توجه کنید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5//go:generate stringer -type=Age 6 7type Age int 8 9const ( 10\tCHILDERN Age = iota 11\tADOLESCENTS 12\tADULTS 13) 14 15func main() { 16\tfmt.Println(CHILDERN.String()) 17} در کد فوق ما یک directive comment اضافه کردیم حال کافیه با استفاده از دستور go generate متد استرینگ تایپ را جنریت کنیم.\n1go generate ./... "},{"id":60,"href":"/chapter-4/effective-go/","title":"4.18 تکنیک های کدنویسی زبان گو","section":"فصل چهارم: مباحث پیشرفته","content":"در این بخش به موارد زیر می پردازیم.\nکارآمدی (effective) استایل اوبر تکنیک ها نکات فنی بهینه سازی 4.18.1 کارآمدی (Effective) # در زیر به کارآمدی زبان گو می پردازیم.\n4.18.1.1 نام پکیج ها # زمانیکه شما یک پکیج را ایمپورت میکنید نام پکیج در بالای بدنه فایل گو قرار میگیرد مانند :\n1import \u0026#34;bytes\u0026#34; حال وقتی که پکیج ایمپورت می شود و نام اش در بالای بدنه فایل کد شما قرار میگیرد می توانید در ادامه نام پکیج توابع, تایپ ها و یا متغیر و const ها را مانند bytes.Buffer فراخوانی کنید.\nانتخاب یک نام خوب برای پکیج خیلی قابل اهمیت است و شما برای انتخاب یک نام خوب بهتر است موارد زیر را رعایت کنید :\nنام کوتاه باشد. مختصر باشد. نام پکیج طوری باشد که به آسانی بتوان بهش دسترسی داشت نام پکیج باشد تماما حروف کوچک باشد. تک کلمه ای باشد. 4.18.1.2 پیاده سازی Getter/Setter # در زبان گو هیچ Getter یا Setter خودکاری وجود ندارد. به همین منظور شما باید Getter/Setter را در قالب متد یک آبجکت پیاده سازی کنید.\n1owner := obj.GetOwner() 2if owner != user { 3 obj.SetOwner(user) 4} 4.18.1.3 نام اینترفیس # نام اینترفیس یک حالت قراردادی دارد که بهتر است این حالت قرار دادی را رعایت کنید. نام اینترفیس با مشخصه یک رفتار کلی باشد که برپایه متدهای اینترفیس تعیین می شود و در نهایت در انتهای نام اینترفیس دو حرف er اضافه می شود. مانند : Reader , Writer, Formmater\n1type Writer interface { 2\tWrite([]byte) error 3} 4.18.1.4 نوع نام گذاری متغیر, تابع, تایپ و \u0026hellip; # در زبان گو نام گذاری حالت قراردادی دارد که کامپایلر نسبت به نوع نام گذاری شما رفتار نشان می دهد. بطوری که شما می توانید نام ها را بصورت MixedCaps یا mixedCaps بنویسید که این حالت نام گذاری را camleCase و PascalCase می گویند.\nزمانیکه شما نام را بصورت PascalCase می نویسید در واقع حالت شما آن متغیر, تابع, تایپ و \u0026hellip; را بصورت Public در نظر گرفتید. اگر شما نام را بصورت camleCase بنویسید در واقع شما متغیر, تابع, تایپ و \u0026hellip; را بصورت Private در نظر گرفتید وفقط در پکیج لول شما در دسترس می باشد. 4.18.1.5 نقطه ویرگول (Semicolons) # مانند C، گرامر رسمی Go از نقطه ویرگول برای پایان دادن به عبارات استفاده می کند، اما برخلاف C، این نقطه ویرگول ها در منبع ظاهر نمی شوند. در عوض، lexer از یک قانون ساده برای درج خودکار نقطه ویرگول ها در حین اسکن استفاده می کند، بنابراین متن ورودی عمدتاً فاقد آنها است.\n4.18.1.6 ساختارهای کنترلی if, for, switch # در زبان گو همانند سایر زبان ها ساختارهای کنترلی نظیر if, for, switch داریم که در زیر می توانید با حالت های کارآمد استفاده از این کنترل ها آن ها آشنا شوید.\nif\nدر زبان گو حالت ساده شرط به شکل زیر است :\n1if x \u0026gt; 0 { 2 return y 3} حال اگر شما یک تابعی داشته باشید که یک مقدار مانند خطا برگرداند می توانید داخل عبارت شرط یک متغییر راه اندازی کنید و تابع را داخلش قرار دهید سپس با قرار دادن نقطه ویرگول شرط را بررسی کرده.\n1if err := file.Chmod(0664); err != nil { 2 log.Print(err) 3 return err 4} اما اگر تابع شما ۲ تا خروجی داشته باشد بهتر است داخل دو متغییر خروجی را بگیرید و در خط بعدی شرط را جهت بررسی هریک از متغیرها قرار دهید:\n1f, err := os.Open(name) 2if err != nil { 3 return err 4} 5codeUsing(f) 4.18.2 استایل اوبر (Uber) # در زیر استایل کدنویسی که تیم مهندسی شرکت اوبر تهیه کردند می پردازیم.\n4.18.3 تکنیک ها # در زیر به تکنیک های زبان گو می پردازیم.\n4.18.4 نکات فنی # در زیر چندین نکات فنی قرار دادم که کاربردی می باشد.\n4.18.4.1 مقدار صفر تایپ ها و مقادیر # همانطور در فصل های قبل اشاره کردیم تایپ ساختار (struct) بدون فیلد مقدارش در حافظه کاملا صفر است. اندازه تایپ آرایه بدون هیچ المنتی صفر است. حال در زیر یک مثال میزنیم تا ببینید:\n1package main 2 3import \u0026#34;unsafe\u0026#34; 4 5type A [0][256]int 6type S struct { 7\tx A 8\ty [1 \u0026lt;\u0026lt; 30]A 9\tz [1 \u0026lt;\u0026lt; 30]struct{} 10} 11type T [1 \u0026lt;\u0026lt; 30]S 12 13func main() { 14\tvar a A 15\tvar s S 16\tvar t T 17\tprintln(unsafe.Sizeof(a)) // 0 18\tprintln(unsafe.Sizeof(s)) // 0 19\tprintln(unsafe.Sizeof(t)) // 0 20} 1$ go run main.go 20 30 40 در Go، اندازه ها اغلب به عنوان مقادیر int نشان داده می شوند. این به این معنی است که بزرگترین طول ممکن یک آرایه MaxInt است که مقدار آن در سیستم عامل های 64 بیتی 2^63-1 است. با این حال، طول آرایه با اندازه عناصر غیر صفر به سختی توسط کامپایلر استاندارد رسمی Go و زمان اجرا محدود می شود.\n1var x [1\u0026lt;\u0026lt;63 - 1]struct{} // okay 2var y [2000000000 + 1]byte // compilation error 3var z = make([]byte, 1\u0026lt;\u0026lt;49) // panic: runtime error: makeslice: len out of range 4.18.4.2 نحوه تخصیص مقادیر اندازه صفر به کامپایلر بستگی دارد # در اجرای استاندارد رسمی فعلی کامپایلر Go (نسخه 1.20)، همه مقادیر محلی صفر تخصیص داده شده روی heap و آدرس یکسانی دارند. به عنوان مثال، موارد زیر دو بار false را چاپ می کنند، سپس دو بار true را چاپ می کنند.\n1package main 2 3var g *[0]int 4var a, b [0]int 5 6//go:noinline 7func f() *[0]int { 8\treturn new([0]int) 9} 10func main() { 11\t// x and y are allocated on stack. 12\tvar x, y, z, w [0]int 13\t// Make z and w escape to heap. 14\tg = \u0026amp;z 15\tg = \u0026amp;w 16\tprintln(\u0026amp;b == \u0026amp;a) // false 17\tprintln(\u0026amp;x == \u0026amp;y) // false 18\tprintln(\u0026amp;z == \u0026amp;w) // true 19\tprintln(\u0026amp;z == f()) // true 20} 1$ go run main.go 2false 3false 4true 5true لطفا توجه داشته باشید که خروجی های برنامه فوق به کامپایلرهای خاصی بستگی دارد. خروجی ها ممکن است برای نسخه های کامپایلر استاندارد رسمی Go در آینده متفاوت باشند. 4.18.4.3 فیلد با اندازه صفر را به عنوان فیلد نهایی یک نوع ساختار قرار ندهید # در کد زیر اندازه تایپ Tz از تایپ Ty بزرگتر است.\n1package main 2 3import \u0026#34;unsafe\u0026#34; 4 5type Ty struct { 6\t_ [0]func() 7\ty int64 8} 9type Tz struct { 10\tz int64 11\t_ [0]func() 12} 13 14func main() { 15\tvar y Ty 16\tvar z Tz 17\tprintln(unsafe.Sizeof(y)) // 8 18\tprintln(unsafe.Sizeof(z)) // 16 19} 1$ go run main.go 28 316 چرا اندازه نوع Tz بیشتر است؟\nدر پیاده‌سازی runtime Go استاندارد کنونی، تا زمانی که یک بلوک حافظه توسط حداقل یک اشاره‌گر زنده مشارکت شود، آن بلوک حافظه به عنوان زباله در نظر گرفته نمی‌شود و جمع‌آوری نمی‌شود. همه فیلدهای یک مقدار ساختار قابل دسترسی می‌توانند آدرس‌گرفته شوند. اگر اندازه فیلد نهایی در یک مقدار ساختار با اندازه غیر صفر صفر باشد، آنگاه گرفتن آدرس فیلد نهایی در مقدار ساختاری، آدرسی را که خارج از بلوک حافظه اختصاص داده شده برای مقدار ساختاری است باز خواهد گرداند. آدرس بازگردانده شده ممکن است به بلوک حافظه دیگری که به طور نزدیکی پس از بلوک حافظه اختصاص داده شده برای مقدار ساختاری با اندازه غیر صفر قرار دارد، اشاره کند. تا زمانی که آدرس بازگردانده شده در یک مقدار اشاره‌گر زنده ذخیره شود، بلوک حافظه دیگری که به جمع‌آوری زباله می‌روید جمع‌آوری نخواهد شد که ممکن است باعث نشت حافظه شود. برای جلوگیری از این نوع مشکلات نشت حافظه، کامپایلر Go استاندارد تضمین می‌کند که دریافت آدرس فیلد نهایی در یک ساختار با اندازه غیر صفر هرگز آدرسی را که خارج از بلوک حافظه اختصاص داده شده برای ساختار نیست را بازنخواهد گرداند. کامپایلر Go استاندارد این کار را با وارد کردن برخی بایت‌ها پس از فیلد صفر آخرین انجام می‌دهد. بنابراین، حداقل یک بایت پس از فیلد نهایی (صفر) نوع Tz وجود دارد. به همین دلیل اندازه نوع Tz بزرگتر از Ty است. در واقع، در سیستم عامل‌های ۶۴ بیتی، ۸ بایت پس از فیلد نهایی (صفر) Tz وجود دارد. برای توضیح این موضوع، باید دو حقیقت را در پیاده‌سازی کامپایلر استاندارد رسمی بدانیم:\nتضمین ترازبندی یک نوع ساختاری، بزرگترین تضمین ترازبندی فیلدهای آن است. اندازه یک نوع همیشه یک ضریبی از تضمین ترازبندی آن است. حقیقت اول، علت برابری تضمین ترازبندی نوع Tz با ۸ (که تضمین ترازبندی نوع int64 است) را توضیح می‌دهد. حقیقت دوم، علت برابری اندازه نوع Tz با ۱۶ را توضیح می‌دهد. منبع : https://github.com/golang/go/issues/9401\n4.18.5 بهینه سازی # در زیر به بهینه سازی در زبان گو می پردازیم.\n"},{"id":61,"href":"/chapter-4/go-commentry/","title":"4.19 اصول کامنت نویسی","section":"فصل چهارم: مباحث پیشرفته","content":"اصول کامنت‌نویسی در زبان گو\n4.19.1 تعریف # «کامنت» به توضیحات‌ی گفته می‌شود که داخل کد، به‌قصد «یادآوری»، «جلب‌توجه مخاطب به موضوع‌(ها)ی خاص»، کمک به onboard شدن اعضاء جدید تیم و مانند اون نگارش می‌شود. در زبان گو، به شیوه‌های زیر کامنت می‌گذاریم:\nقرار دادن // در ابتدای سطر.\n1// defined to store multi string (see below why this is not a good comment) 2var sliceVar []string قراردادن متن کامنت داخل یک بلوک که با */ شروع می‌شود و /* تمام می‌شود.\n1for index, row := range sliceVar { 2 row /* for loop lifetime */ = \u0026#34;new_val\u0026#34; 3 sliceVar[index] /* apply to sliceVar out of loop */ = \u0026#34;new_val\u0026#34; 4 fmt.Println(row) // hint to sliceVar large len 5} دستور ‍gofmt کامنت‌ها را مانند سایر فرمت‌ها، مرتب می‌نماید. اما روش بهتر درصورت امکان، نظم آنها توسط خود توسعه‌دهنده جهت رعایت الگوها و ساختار خاص هر پروژه است.\n1gofmt -w main.go 4.19.2 دیدگاه‌ها درباره «کامنت» # با توجه به این موضوع که در جوامع‌تخصصی توسعه نرم‌افزار، درارتباط با اصل وجود کامنت، مزایا/معایب و چگونگی استفاده از آن، مطالب گوناگون و بعضاً متضادی، حتی از جانب متخصصین، وجود دارد، در این قسمت سعی خواهیم کرد، تاجای‌ممکن پاسخ حساب‌شده‌ای به نیازمندی‌های مختلف در ارتباط با «کامنت‌گذاری» بدهیم.\n4.19.3 کامنت؛ خوب، بد، زشت # در کدهایی که بارها نسخه‌های متفاوتی از آن ایجاد شده و در طول زمان، نیازمندی‌ها عوض شده، کیفیت، کارایی و سرعت اجرا بهبود پیدا کرده، «کامنت» گزارش «چرایی» کد هست برای این: نیاز/کیفیت/کارایی/سرعت اجرا، برای اینکه همه این‌ها رو دوباره تجربه نکنند ... یک کد خوب، هیچ نیازی به کامنت ندارد، به‌زبان‌دیگر، اگر نیاز می‌بینید که برای کدی «کامنت» بنویسید، احتمالاً، کد خوبی ننوشتید ... یک ساختار جدید، ناشناخته و احتمالاً حجیم، به‌قدر‌کافی ماهیتاً اینقدر پیچیدگی دارد که اضافه شدن، یک توضیح به زبان کاملاً انسانی (داخل زبان کامپایلر/مفسری برای زبان ماشین)، نه‌تنها باعث روشن‌تر شدن آن نمی‌شود بلکه مسئله‌ی فهم منظور نگارنده «کامنت» به مجموعه مسائل قبلی اضافه می‌گردد. هیچ‌چیز بیشتر از یک کد پیچیده با کلی «کامنت‌های» پیچیده برای مخاطبی که انتظار روشن بودن چرایی و چگونگی کد را دارد، عذاب‌آور نیست ... همه این‌ها پاسخ‌های متفاوت‌ی است که توسعه‌دهندگان به موضوع «کامنت» می‌دهند. اما «اصولاً» کامنت پرفایده است یا بی‌فایده؟\n4.19.4 آنالیز محصول و محیط توسعه # وقتی در ارتباط با کامنت صحبت می‌کنیم این خیلی مهم است که ما به‌تنهایی مشغول توسعه یک محصول هستیم یا در یک دپارتمان کوچک یا در یک ابَرپروژه \u0026hellip; آیا ما مجبور به تبعیت از یک‌سری دستورالعمل‌های کدنویسی هستیم یا می‌توانیم سلیقه‌شخصی خود را داشته باشیم؟ \u0026hellip;\nشرایط تیم توسعه. نحوه مدیریت(افراد/روش‌ها) پروژه در فرآیند توسعه کد. تعداد زیرمجموعه‌ها و تعداد توسعه‌دهندگان در بخش‌های مختلف. میزان ارتباط و حساسیت کدها بین واحدها و توسعه‌دهندگان. سرعت تغییرات جابجایی توسعه‌دهندگان در پروژه. و موارد مشابه دیگر. تحلیل نیازمندی‌های محصول. مقیاس پروژه. زمان توسعه پروژه. زمان تغییرات همزمان با نسخه‌های ریلیز شده. پیچیدگی و ماهیت نیازهای محصول. و موارد مانند این‌ها. نتیجه اینکه: ابتدا نیازمندی، توانایی و شرایط تیم/محصول را مشخص کنیم، و بعد تصمیم به چرایی و چگونگی کامنت‌نویسی اصولی بگیریم. 4.19.5 انواع کامنت # کامنت فایل/پکیج (Doc Comment) این‌نوع کامنت‌ها درباره «چیستی» کل فایل یا پکیج توضیح دارد.\n1// Copyright 2011 The Go Authors. All rights reserved. 2// Use of this source code is governed by a BSD-style 3// license that can be found in the LICENSE file. 4 5/* 6Package builtin provides documentation for Go\u0026#39;s predeclared identifiers. 7The items documented here are not actually in package builtin 8but their descriptions here allow godoc to present documentation 9for the language\u0026#39;s special identifiers. 10*/ 11package builtin مثال بالا از پکیج builtin درباره حق‌چاپ / تعریف اولیه پکیج و اینکه مستندات در godoc ارائه می‌شود، توضیح داده است.\nکامنت داخلی فانکشن/متد/بلوک/تایپ/متغیر/دستور و مانند آن (Ordinary Comments) این‌نوع کامنت درباره «چرایی» آن قسمتِ خاص اشاره دارد. 1// The delete built-in function deletes the element with the specified key 2// (m[key]) from the map. If m is nil or there is no such element, delete 3// is a no-op. 4func delete(m map[Type]Type1, key Type) در مثال بالا، توسط کامنت توضیح داده شده که وظیفه فانکشن-داخلی delete حذف المنت با کلید مشخص هست، و توضیح دقیق‌تر اینکه اگر المنت مربوط به کلید nil باشد یا وجود نداشته باشد، فانکشن delete هیچ عملیاتی انجام نمی‌دهد. (مثلاً خطا باز نمی‌گرداند − گزارش نمی‌کند و \u0026hellip;)\n4.19.6 اصول کامنت‌نویسی # یک کامنت خوب:\nتوضیح واضحات را نمی‌دهد. در حداقل مقدار «لازم» و «کافی» نگارش می‌شود. بیشتر درباره «چیستی/چرایی» اشاره دارد و نه «چگونگی». دارای یک الگو و دستورالعمل نگارشی واحد برای نظم و سرعت ارتباط مخاطب است. وجودش آگاه‌کننده موضوع بااهمیت بالاست. مربوط به موضوعی است که اکنون وجود دارد (بروزرسانی کامنت‌ها-حذف کامنت‌های اضافی) ادبیات کامنت، بسته به تیم و دستورالعمل‌ها، بهتر است رسمی نگارش شود تا عمومی بماند. البته گاهی کمی شوخ‌طبعی هم اگر کنترل‌شده باشد، باعث انتقال‌مطلب بهتر می‌شود. درصورت لازم بودن یک یا چند منبع مرتبط با کد، حاوی لینک url خواهد بود. 1 // flip the buffer for this connection if we need to drain it. 2 // note that for a successful query (i.e. one where rows.next() 3 // has been called until it returns false), `rows.mc` will be nil 4 // by the time the user calls `(*Rows).Close`, so we won\u0026#39;t reach this 5 // see: https://github.com/golang/go/commit/651ddbdb5056ded455f47f9c494c67b389622a47 6 mc.buf.flip() 4.19.7 به پرتگاه نزدیک می‌شوید! # زامبی کد: به کدی می‌گویند که به دلیل عدم کارایی، اصلاح با کد جدید، و یا مشابه این موارد، بجای «حذف»، «کامنت» می‌شوند. کامنت اسپاگتی کد: به کامنت‌های دنباله‌داری گفته می‌شود که برای توضیح یک کدی که ساختار منظم و مشخصی ندارد، نگارش می‌شود. یکی دیگر از استفاده‌های کامنت، وظیفه‌ی برنامه‌ریزی‌شده می‌باشد که اگر کنترل نشود، یکی دیگر از عذاب‌های عظیم خواهد بود. جای کلمات عبور و مقادیر امنیتی در کامنت نیست. اگر دائماً نیاز می‌بینید که در مراحل مختلف به همکاران بصورت کامنت «هشدار» بنویسید، شاید باید به‌فکر اصلاح معماری نرم‌افزار باشید. کامنت‌های شما، نباید تبدیل به «نویز» درکدنویسی دیگران شود. تعدد کامنت‌ها کد را تبدیل به کد کثیف می‌کند که خوانایی ضعیفی خواهد داشت. کامنت، جای دردل کردن، شکایت از مدیرپروژه، تعریف از خود و گفتگو نیست. 4.19.8 انواع directive comment # //go:generate: این کامنت برای مشخص کردن یک دستور است که باید توسط ابزار go generate اجرا شود. این کامنت معمولاً قبل از یک دستور تولید کد قرار داده می‌شود که به شما اجازه می‌دهد کد Go را به صورت خودکار تولید کنید.\n//go:binary-only-package: این کامنت برای اعلام این استفاده می‌شود که یک بسته باید به عنوان یک بسته فقط دودویی در کامنت گرفته شود، به معنای این است که کد منبع بسته در دسترس نیست. این برای بسته‌هایی استفاده می‌شود که شامل کد‌های محصولی یا بسته‌های مشخص سیستم‌عامل هستند.\n//go:build: این کامنت برایمحدودیت‌های ساخت استفاده می‌شود. این به شما امکان می‌دهد که کنترل کنید که یک فایل باید بر اساس شرایط خاصی مانند سیستم عامل، معماری یا برچسب ساخت، در ساخت شامل شود یا خیر.\n//go:cgo_\u0026hellip;: چندین کامنت دستوری وجود دارد که با cgo_ شروع می‌شوند، مانند //go:cgo_import_dynamic و //go:cgo_export_dynamic. این کامنتات همراه با cgo استفاده می‌شوند، ابزاری که به کد Go اجازه می‌دهد تا به کد C و بالعکس برای فراخوانی دستورات استفاده شود. آن‌ها دستوراتی را به ابزار cgo ارائه می‌دهند که نحوه برخورد کد C را مشخص می‌کنند.\n//go:noinline: این کامنت برای مشخص کردن این استفاده می‌شود که یک تابع توسط کامپایلر به صورت inline نباید درج شود. Inline کردن یک تابع یک تکنیک بهینه‌سازی است که کد یک تابع به طور مستقیم در کد فراخواننده آن قرار می‌گیرد و هزینه فراخوانی تابع را حذف می‌کند. استفاده از این کامنت از کامپایلر جلوگیری می‌کند تا برای تابع مشخص شده inline کردن انجام دهد.\n//go:nosplit: این کامنت برای مشخص کردن این استفاده می‌شود که یک تابع باید توسط برنامه‌ریز Go runtime اجرا شده (split) نشود. این معمولاً برای توابع سطح پایین استفاده می‌شود که نیاز به کنترل دقیق بر روی اجرای آن‌ها دارند و نباید وقفه داده شوند.\n//go:linkname: این کامنت برای برقراری ارتباط بین کد Go و نمادهای خارجی یا کد غیر Go استفاده می‌شود. این به شما اجازه می‌دهد تا به یک نماد با نام متفاوت یا از بسته‌ای دیگر ارجاع دهید.\n//go:noescape: این کامنت برای مشخص کردن این استفاده می‌شود که آرگومان‌های اشاره گر تابع escape نمی‌کنند، به معنایی که در طول عمر تابع ذخیره یاستفاده نمی‌شوند یا استفاده نمی‌شوند. این اطلاعات به کامپایلر اجازه می‌دهند که بهینه‌سازی‌های حافظه تابع را انجام دهد.\n//go:embed: این کامنت برای اضافه کردن فایل‌های استاتیک یا دایرکتوری‌ها به طور مستقیم به باینری Go در زمان کامپایل استفاده می‌شود. این فرآیند از جمله فرآیند بسته‌بندی و توزیع منابع با برنامه‌های Go خود است.\n//go:generate go run: این کامنت یک نوع دیگر از کامنت //go:generate است. این کامنت مشخص می‌کند که دستور زیر کامنت باید توسط اجرای برنامه Go با استفاده از دستور go run اجرا شود.\n//go:build \u0026hellip;: این کامنت یک فرم گسترده‌تر از کامنت build است. این به شما امکان می‌دهد شرایط ساخت را با استفاده از اپراتورهای منطقی بولی، پرانتز و نفی مشخص کنید. این امکانات بیشتری در کنترل کردن فایل‌هایی که در ساخت شامل می‌شوند، فراهم می‌کند.\n//go:protofile: این کامنت برای مشخص کردن پروتوباف فایل مرتبط با یک فایل منبع Go استفاده می‌شود. این معمولاً در کد Go استفاده می‌شود که شامل کد پروتوباف تولید شده است، اجازه می‌دهد که کامپایلر فایل‌های Go و پروتوباف رابه درستی به هم پیوند دهد.\n//go:nowritebarrier: این کامنت برای مشخص کردن این استفاده می‌شود که یک تابع بدون write barrier باید اجرا شود. Write barrier برای تعقیب و به‌روزرسانی اشاره‌گرها در زمان تخصیص و آزادسازی حافظه توسط garbage collector استفاده می‌شود. استفاده از این کامنت ممکن است خطرناک باشد و تنها در موارد خاصی که مدیریت دستی حافظه لازم است، باید استفاده شود.\n//go:norace: این کامنت دستوری برای غیرفعال کردن ردیابی race برای یک تابع خاص است. ردیاب race یک ابزار در Go است که به شناسایی دسترسی همزمان به متغیرهای مشترک که ممکن است منجر به دور زدن داده‌ها (race condition) بشود، کمک می‌کند. این دستور می‌تواند هنگامی استفاده شود که از عدم وجود شرایط race برای یک تابع خاص اطمینان دارید.\n//go:buildignore: این کامنت دستوری برای حذف یک فایل از فرآیند ساخت استفاده می‌شود. این به سیستم ساخت Go می‌گوید که این فایل را نادیده بگیرد و در هنگام کامپایل بسته، شامل نشود.\n//go:generate goimports: این کامنت دستوری برای استفاده در ارتباط با دستور //go:generate استفاده می‌شود تا به صورت خودکار ابزار goimports اجرا شود. goimports به طور خودکار import statements را به روزرسانی و فرمت دهی می‌کند، اطمینان حاصل می‌کند که import های بسته درست هستند و import های بی‌استفاده را حذف می‌کند.\n//go:embed pattern: این کامنت دستوری یک فرم گسترده‌تر از //go:embed است و به شما اجازه می‌دهد الگویی را برای تطبیق با فایل‌ها یا دایرکتوری‌ها برای جاسازی در حالت تعبیه شده مشخص کنید. این امکانات، در انتخاب فایل‌ها یا دایرکتوری‌های خاص بیشتری ارائه می‌دهد.\n//go:nolint: این کامنت دستوری برای سرکوب خطاها و هشدارهای خاص لینتر برای یک خط کد خاص استفاده می‌شود. این اغلب هنگامی استفاده می‌شود که یک قانون لینتر یک false positive را سیگنال می‌دهد یا وقتی دلیل معتبری برای نادیده گرفتن یک مسئله لینتینگ موقتا وجود دارد.\n//go:generate go test: این کامنت دستوری برای استفاده در ارتباط با دستور //go:generate استفاده می‌شود تا به صورت خودکار دستور go test اجرا شود. این دستور معمولاً برای تولید و اجرای کد آزمایشی برای یک بسته استفاده می‌شود.\n//go:uintptrescapes: این کامنت دستوری برای نشان دادن این است که یک مقدار uintptr ممکن است به حافظه heap فرار کند. به طور پیش فرض، کامپایلر فرض می‌کند که مقدارهای uintptr فرار نمی‌کنند، اما استفاده از این دستور اجازه تجزیه و تحلیل فرار دقیق‌تر را می‌دهد.\n//go:build !constraint: این کامنت دستوری برای حذف یک فایل از فرآیند ساخت بر اساس شرط ساخت خاص استفاده می‌شود. این به شما اجازه می‌دهد یک شرط را مشخص کنید که برای شامل شدن فایل در فرآیند ساخت باید برآورده نشود.\n//go:checkptr: این کامنت دستوری برای فعال کردن بررسی‌های ایمنی اضافی برای اشاره‌گرها در کد استفاده می‌شود. این دستور به کامپایلر دستور می‌دهد تا بررسی‌های رانتایم اضافی را برای شناسایی عملیات اشاره‌گر ناموفق و مسائل امنیتی حافظه انجام دهد.\n//go:nosplitcheck: این کامنت دستوری برای غیرفعال کردن بررسی nosplit برای یک تابع استفاده می‌شود. بررسی nosplit بررسی می‌کند که یک تابع بدون پیش‌بینی از برنامه‌ای که در آینده اجرا می‌شود، بدون توقف توسط برنامه اجرا شود.استفاده از این دستور ممکن است خطرناک باشد و فقط در صورت ضرورت باید استفاده شود.\n//go:noruntime: این کامنت دستوری برای نشان دادن این است که یک بسته به Go runtime وابسته نیست. این به کامپایلر اطلاع می‌دهد که بسته می‌تواند در یک محیط استفاده شود که Go runtime در دسترس نیست یا نیاز نیست.\nمثال استفاده از directive comment:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5//go:generate stringer -type=Age 6 7type Age int 8 9const ( 10\tCHILDERN Age = iota 11\tADOLESCENTS 12\tADULTS 13) 14 15func main() { 16\tfmt.Println(CHILDERN.String()) 17} در کد فوق ما یک directive comment اضافه کردیم حال کافیه با استفاده از دستور go generate متد استرینگ تایپ را جنریت کنیم.\n1$ go generate ./... "},{"id":62,"href":"/chapter-4/go-code-rules/","title":"4.20 قوانین کدنویسی در گو","section":"فصل چهارم: مباحث پیشرفته","content":"قوانین در زبان گو همانند دیگر زبان های برنامه نویسی به دو دسته تقسیم می شود. بخشی از قوانین در سطح سینتکس زبان مطرح می شوند، لذا رعایت آنها مهم هست، در غیر اینصورت کامپایلر قادر به کامپایل درست کدهای شما نخواهد بود و در بعضی شرایط ممکن است به صورت خاموش خطا به محیط اجرا (runtime) نیز برده شود. بخشی از قوانین به عنوان پیشنهاد و ترجیح مطرح هستند که عموما توسط لینتر بررسی می شوند و تاثیر اصلی بر خوانایی منطق کدها دارند. یعنی رعایت آنها الزام قطعی ندارد. به طور مثال استفاده از _ در نام گذاری ها در گو توصیه نمی شود ولی در کتابخانه استاندارد (الحاقی به زبان گو) به وفور عدم رعایت این موضوع دیده می شود.\nلازم به ذکر است که سازمان ها می توانند قوانین پیشنهادی خود را توسعه دهند و با توسعه لینتر اختصاصی در فرآیند توسعه نرم افزار خود با روش هایی مانند CI/CD از رعایت قوانین خود توسط توسعه دهندگان پروژه های نرم‌افزاری خود اطمینان حاصل نمایند.\n4.20.1 قوانین نام گذاری # در زبان برنامه‌نویسی Go برای نامگذاری توابع، همان گونه که در بالا نیز توضیح داده شد دو مدل قوانین (اجباری و اختیاری) وجود دارد. قوانین اجباری باید رعایت شوند و قوانین اختیاری بهتر است رعایت شوند تا کد هم خوانایی بیشتری داشته باشد و هم از نظر تعاریف و نام‌گذاری مطابق رویه های (پروتکل های) معرفی شده توسط تیم توسعه زبان، به صورت استاندارد باشند.\n4.20.1.1 نام توابع # نام توابع باید با حروف بزرگ یا کوچک شروع شود. توابعی که با حروف بزرگ شروع می‌شوند، به عنوان public تلقی می‌شوند و از سمت بیرون پکیج برای دیگران قابل دسترس هستند. توابعی که با حروف کوچک شروع می‌شوند، به عنوان private تلقی می‌شوند و فقط در داخل پکیج موجود هستند.\nنام توابع public بصورت Pascal Case هستند مانند: ()CalculateInterestRate نام توابع private بصورت camel Case هستند مانند: ()calculateInterestRate برای اطلاعات بیشتر درخصوص public یا private میتوانید به بخش Encapsulation مراجعه کنید.\n4.20.1.2 نام فایل های پسوند go. # نام فایل باید با حرف کوچک شروع شود. نام فایل باید از حروف بزرگ و خط تیره (-) استفاده نکند. نام فایل باید با نام پکیج مطابقت داشته باشد. نام فایل باید از جمله معانی آن و بخشی از توضیح فایل باشد. برای مثال: database_connection.go، calculator_test.go 4.20.1.3 نام interface # نام اینترفیس باید با I شروع نشود. نام اینترفیس باید با camelCase باشد. نام اینترفیس باید صفت یا اسم باشد و معمولاً با حرف I شروع نمی‌شود. برای مثال: Reader، Writer در انتهای نام حتما er داشته باشد. 4.20.1.4 نام پارامترهای توابع # نام پارامترها باید با حروف کوچک شروع شود. نام پارامترها باید با camelCase باشد. برای مثال، تابع زیر درست نام‌گذاری شده است:\n1func CalculateInterestRate(principal float64, interestRate float64, termInYears int) float64 { 2 // function code here 3} در این مثال، تمامی پارامترهای تابع با حروف کوچک، با CamelCase نام‌گذاری شده‌اند.\nبه طور کلی، هدف از این قوانین نام‌گذاری، رعایت استانداردهایی برای نام‌گذاری است تا کد خواناتر و قابل فهم باشد و همچنین قابلیت نگهداری و توسعه را بهتری داشته باشد.\n4.20.1.5 نام پکیج # نام پکیج در Go باید با حرف کوچک شروع شود و نام پکیج باید شامل تنها حروف کوچک انگلیسی، اعداد و خط فاصله (-) باشد. همچنین در نام پکیج از حروف بزرگ استفاده نشود، همچنین اسم پکیج باید توصیفی از محتوای آن باشد. برای نام‌گذاری پکیج، معمولاً از نام اصلی محصول یا سرویسی که پیاده‌سازی می‌شود، یا نام ماژول یا قسمتی از نرم‌افزار استفاده می‌شود.\nمثلاً اگر یک پروژه برای پردازش تصویر داریم، نام پکیج می‌تواند \u0026ldquo;imageprocessing\u0026rdquo; باشد. همچنین اگر می‌خواهیم یک کتابخانه بخشی از پروژه خود را به اشتراک بگذاریم، می‌توانیم از نام پروژه یا نام ماژول استفاده کنیم.\nتوجه داشته باشید که نام پکیج باید با نام پوشه‌ای که فایل‌های پروژه در آن هستند همخوانی داشته باشد. برای مثال، اگر فایل‌های پروژه در پوشه imageprocessing قرار دارند، نام پکیج باید imageprocessing باشد.\n4.20.1.6 نام متغیر و const # برای متغیرها و ثابت‌ها در زبان برنامه‌نویسی Go نیز نام‌های خاصی وجود دارد که برای آن‌ها پیشنهاد می‌شود. در ادامه به برخی از قوانین نام‌گذاری برای متغیرها و ثابت‌ها در Go اشاره می‌شود:\nمتغیر\nنام متغیر باید با حرف کوچک شروع شود. نام متغیر باید جهت نمایش نوع متغیر در نام آن و حاوی توضیح مختصر در مورد نام متغیر باشد. نام متغیر باید با camelCase باشد. نام متغیر باید کاملاً توصیفی باشد و نیازی به توضیحات اضافی در مورد آن نباشد. برای مثال، به جای تعریف متغیر x برای نگهداری مقدار سن، می‌توان از نام age استفاده کرد:\n1var age int // تعریف متغیر برای سن شخص const\nنام ثابت باید با حروف بزرگ شروع شود. نام ثابت باید جهت نمایش نوع ثابت در نام آن و حاوی توضیح مختصر در مورد مقدار ثابت باشد. نام ثابت باید با Snake_case باشد. نام ثابت باید کاملاً توصیفی باشد و نیازی به توضیحات اضافی در مورد آن نباشد. برای مثال، برای تعریف ثابت مقدار پاییز در فصل های سال، می‌توانیم از نام SEASON_AUTUMN استفاده کنیم:\n1const SEASON_AUTUMN = \u0026#34;پاییز\u0026#34; توجه داشته باشید که برای نام‌گذاری متغیرها و ثابت‌ها در Go، پیشنهاد می‌شود از نام‌هایی استفاده کنید که بهره بیشتری از خوانایی و قابلیت نگهداری کد برداشته شود. و نام‌هایی که توصیف کننده‌تر و صحیح‌تر هستند برای این منظور بهتر استفاده می‌شوند.\n"},{"id":63,"href":"/chapter-4/go-garbage-collector/","title":"4.21 زباله جمع کن (garbage collector)","section":"فصل چهارم: مباحث پیشرفته","content":"یکی از جذابیت های زبان های برنامه نویسی جدید قابلیت زباله جمع کن (garbage collector) ایجاد شده در آنها است. بطور خلاصه مدیریت و آزاد سازی منابع اختصاص داده شده از حافظه را که بصورت خودکار در زبان های برنامه نویسی مدرن انجام می شود را garbage collector می شناسیم.\nمدیریت منابع حافظه که بسیار حساس و در مواقعی زمان بر است توسط برخی زبان ها بصورت توکار پشتیبانی می شود و این کار به افزایش سرعت و همچنین کاهش خطا در زمان و پروسه تولید نرم افزار می شود. با تمام این تفاسیر مواقعی است که برنامه نویس می باید خودش مدیریت حافظه را در دست گرفته و پیش از بروز شرایط بحرانی اقدام به آزاد سازی حافظه و یا منابع اختصاص یافته نماید. خبر خوب اینکه در زبان Go مدیریت منابع حافظه نسبت به زبان های دیگر ساده تر و راحتر است ولی در این نوشته سعی می کنیم تا درک خوبی از مدیریت منابع و نحوه عملکرد آن داشته باشید بنابر این در ادامه با یک مثال که نیاز به بررسی کد در سطوح پایین دارد می پردازیم.\nاستفاده از uprobes # برای بررسی وضعیت حافظه ما از uprobes استفاده می کنیم این بسته امکان بسیاری در اختیارمان قرار می دهد برای مثال نیازی به تغییر کد برنامه نمی باشد و برای برنامه های درحال اجرا نیز می توان استفاده نمود.\nمراحل garbage collection # مکانیزم garbage collection در زبان go بصورت هم رونده یا concurrent در کنار برنامه ما اجرا می شود که همین قابلیت دلیل عدم توقف یا مکث برنامه در زمان پاکسازی حافظه است و دو مرحله کلی را برای پاکسازی حافظه اجرا می کند.\n1- مرحله Mark phase در این مرحله GC اشیاء و متغیرهای مرده دربرنامه که بخشی از حافظه را اشغال کرده‌اند را جستجو و شناسایی می کند.\n2- مرحله Sweep phase در این مرحله اشیائی که در فاز قبل نشانه گذاری شده‌اند بصورت فیزیکی از حافظه دور ریخته می شود.\nتصویر بالا مراحل مختلف شناسایی و پاکسازی را نشان می دهد\nدر ادامه قطعه کد ذیل را داریم که در واقع یک عمل ساده درخواست و پاسخ به یک آدرس وب است\n1http.HandleFunc(\u0026#34;/allocate-memory-and-run-gc\u0026#34;, func(w http.ResponseWriter, r *http.Request) { 2 3 arrayLength, bytesPerElement := parseArrayArgs(r) 4 5 arr := generateRandomStringArray(arrayLength, bytesPerElement) 6 7 fmt.Fprintf(w, fmt.Sprintf(\u0026#34;Generated string array with %d bytes of data\\n\u0026#34;, len(arr) * len(arr[0]))) 8 9 runtime.GC() 10 11 fmt.Fprintf(w, \u0026#34;Ran garbage collector\\n\u0026#34;) 12 13 }) در این قطعه کد یک متغیر که محتوای آن آرایه‌ای از رشته ها است تولید می شود و در پایان با صدا زدن تابع runtime.GC از GC درخواست می کنیم که حافظه را پاکسازی کند دقت کنید که در این قسمت از کد شی arr دیگر مورد استفاده قرار نمی گیرد و از نظر طول عمر مرده به حساب می آید و GC اقدام به پاکسازی فظای اشغال شده توسط این متغیر را می کند.\nاما داستان به این سادگی هم نیست برای مثال مهمترین ویژگی GC این است که بصورت خودکار در زمان های مناسب وارد عمل می شود و اقدام به رها سازی حافظه می نماید باید توجه داشته باشیم که خود عملیات GC بدون سربار به سیستم نیست و شامل موارد ذیل است\nGC Pause Time: عملیات پاکسازی بصورت همزمان با اجرای برنامه انجام می شود ولیکن در برنامه های سنگین بصورت لحظه ای می شود متوجه سربار زمان توقف برنامه برای عملیات پاکسازی شد. هرچند که برای کاربران عادی مشهود نباشد.\nMemory Allocation: جهت نشانه گذاری اشیاء مرده نیز نیاز به تخصیص حافظه است.\nCPU usage: تمامی فعالیت های انجام شده نیاز به پردازش دارد که قاعدتا به پردازنده سربار اضافی تحمیل خواهد کرد.\nGC trigger threshold این قابلیت در زبان go قابل تنظیم است و اجازه می دهد تا یک آستانه برای عملیات پاکسازی در نظر بگیریم که به بصورت درصد مشخص می شود. چنانچه درصد استفاده از حافظه از مقدار تعیین شده در متغیر آستانه بیشتر شود عملیات پاکسازی اجرا خواهد شد که این به نوبه خود چالش برانگیز است برای مثال اگر مقدار آستانه را زیاد تعریف کنیم ممکن است برنامه با کمبود منابع روبرو شود و یا درصورت تعیین مقدار پایین منابعی مانند پردازنده بیش از حد درگیر خواهند شد. Memory Pressure: مواقعی که برنامه به لحاظ منابع حافظه تحت فشار و محدودیت است در این زمان GC بطور متوالی اجرا خواهد شد که می تواند دلیل توقف برنامه اصلی شود\nمانیتور نحوه کار GC # در ادامه میخواهیم توابع ذیل که در runtime موجود است را به کمک uprobes زیر نظر بگیریم تا علاوه بر مقادیر تولید شده در آنها، فرآیند آنها نیز برایمان قابل درک باشد.\nGC تابع اجرای عملیات پاکسازی gcWaitOnMark تابع تشخیص اشیا جهت رها سازی gcSweep تابع رها سازی منابع دقت داشته باشید که تنظیم و اجرا uprobes نیاز به اطلاع بیشتر دارد که در حوصله این نوشتار نیست و متوانید با جستجو در اینترنت به منابع مورد نیاز دسترسی داشته باشید\n1$ curl \u0026#39;127.0.0.1/allocate-memory-and-run-gc?arrayLength=10\u0026amp;bytesPerElement=20\u0026#39; 2 3Generated string array with 200 bytes of data 4 5Ran garbage collector پس از اجرای کوئری بالا بر روی آدرس برنامه خود نتایج ذیل حاصل می شود نکته قابل توجه اینجاست که تابع gcWaitOnMark دو بار در طول عملیات پاکسازی اجار می شود که بار اول جهت اعتبار سنجی منابع نشانه گذاری شده قسمت قبل است.\nبا این توضیحات حال می خواهیم به بررسی چند مثال ساده بپردازیم تا ببینیم در چه مواقعی بهتر است برنامه نویس در بخش های مناسب خود اقدام به پاکسازی حافظه نماید\n1 2package main 3 4import ( 5\t\u0026#34;fmt\u0026#34; 6\t\u0026#34;runtime\u0026#34; 7) 8 9func main() { 10\t// Allocate some memory for the program to use 11\ts := make([]string, 0, 100000) 12\tfor i := 0; i \u0026lt; 100000; i++ { 13\ts = append(s, \u0026#34;hello, world\u0026#34;) 14\t} 15 16\t// Print the initial memory usage 17\tvar m runtime.MemStats 18\truntime.ReadMemStats(\u0026amp;m) 19\tfmt.Println(\u0026#34;Initial HeapAlloc: \u0026#34;, m.HeapAlloc) 20 21\t// Trigger the garbage collector 22\truntime.GC() 23 24\t// Print the memory usage after the garbage collector has run 25\truntime.ReadMemStats(\u0026amp;m) 26\tfmt.Println(\u0026#34;After GC HeapAlloc: \u0026#34;, m.HeapAlloc) 27 28\t// Release the memory 29\ts = nil 30\t// Trigger the garbage collector 31\truntime.GC() 32\t// Print the memory usage after the garbage collector has run 33\truntime.ReadMemStats(\u0026amp;m) 34\tfmt.Println(\u0026#34;After release HeapAlloc: \u0026#34;, m.HeapAlloc) 35} خروجی برنامه :\n1# go run main.go 2Initial HeapAlloc: 1654512 3After GC HeapAlloc: 37872 4After release HeapAlloc: 37872 در کد بالا به کمک یک حلقه در هربار اجرای آن مقداری را به رشته قبلی خود اضافه نموده ایم و بعد از آن مقدار فضای اشغال شده توسط رشته ما در حافظه را نمایش می دهیم در ادامه به کمک runtime.GC حافظه را تخلیه می کنیم و در انتها بررسی می کنیم که آیا مقدار متغیر ما بصورت واقعی تخلیه شده است که نتایج خروجی موارد فوق را تائید می نماید. به یاد داشته باشید که منابع سیستم همواره محدود می باشد و در شرایط این چنینی می بایست خود برنامه نویس با تشخیص درست اقدام به تخلیه حافظه نماید.\nاستفاده از GODEBUG # در مواقعی نیاز است تا GC را بدونه کتابخانه و ابزار اضافی و فقط با قابلیت‌های داخلی خود زبان go بررسی نمائیم که در چنین شرایطی بهتر است از GODEBUG استفاده کنیم.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;runtime\u0026#34; 6\t\u0026#34;time\u0026#34; 7) 8 9func printStats(mem runtime.MemStats) { 10\truntime.ReadMemStats(\u0026amp;mem) 11\tfmt.Println(\u0026#34;mem.Alloc:\u0026#34;, mem.Alloc) 12\tfmt.Println(\u0026#34;mem.TotalAlloc:\u0026#34;, mem.TotalAlloc) 13\tfmt.Println(\u0026#34;mem.HeapAlloc:\u0026#34;, mem.HeapAlloc) 14\tfmt.Println(\u0026#34;mem.NumGC:\u0026#34;, mem.NumGC) 15\tfmt.Println(\u0026#34;-----\u0026#34;) 16} 17 18func main() { 19\tvar mem runtime.MemStats 20\tprintStats(mem) 21 22\tfor i := 0; i \u0026lt; 10; i++ { 23\ts := make([]byte, 100000000) 24\tif s == nil { 25\tfmt.Println(\u0026#34;Operation failed!\u0026#34;) 26\t} 27\t} 28\tprintStats(mem) 29 30\tfor i := 0; i \u0026lt; 10; i++ { 31\ts := make([]byte, 100000000) 32\tif s == nil { 33\tfmt.Println(\u0026#34;Operation failed!\u0026#34;) 34\t} 35\ttime.Sleep(5 * time.Second) 36\t} 37\tprintStats(mem) 38 39} خروجی کد:\n1# go run main.go 2mem.Alloc: 48256 3mem.TotalAlloc: 48256 4mem.HeapAlloc: 48256 5mem.NumGC: 0 6----- 7mem.Alloc: 100045200 8mem.TotalAlloc: 1000128496 9mem.HeapAlloc: 100045200 10mem.NumGC: 9 11----- 12^Csignal: interrupt در کد فوق برنامه بدون دیباگ خروجی فوق را تولید نموده است که مقدار منابع مصرف شده در هر چرخه را نمایش می دهد اما اگر بخواهیم برنامه را با دستور GODEBUG اجرا کنیم خروجی متفاوت خواهد بود به یاد داشته باشید ما در اینجا میخواهیم مقادیر تولید شده که بصورت key-value است و با علامت کاما از هم جدا شده اند و فقط برای GC را بررسی کنیم درحالی که می توان بخش های دیگر برنامه را نیز با سوئیچ های مختلف دیباگ کرد بنابراین اینبار برنامه را با دستور ذیل اجرا می کنیم\n1# GODEBUG=gctrace=1 go run main.go a 2gc 1 @0.019s 1%: 0.014+2.4+0.001 ms clock, 0.014+0.33/0/0+0.001 ms cpu, 4-\u0026gt;4-\u0026gt;0 MB, 5 MB goal, 1 P 3gc 2 @0.050s 3%: 0.027+5.1+0.002 ms clock, 0.027+0.37/1.0/0+0.002 ms cpu, 4-\u0026gt;4-\u0026gt;1 MB, 5 MB goal, 1 P 4gc 3 @0.089s 2%: 0.067+3.3+0.002 ms clock, 0.067+0.66/0/0+0.002 ms cpu, 4-\u0026gt;4-\u0026gt;1 MB, 5 MB goal, 1 P 5gc 4 @0.128s 2%: 0.032+2.6+0.003 ms clock, 0.032+0.82/0/0+0.003 ms cpu, 4-\u0026gt;4-\u0026gt;1 MB, 5 MB goal, 1 P 6gc 5 @0.153s 2%: 0.046+5.1+0.002 ms clock, 0.046+0.81/0/0+0.002 ms cpu, 4-\u0026gt;5-\u0026gt;1 MB, 5 MB goal, 1 P 7gc 6 @0.175s 3%: 0.030+11+0.002 ms clock, 0.030+1.4/0.16/0+0.002 ms cpu, 4-\u0026gt;5-\u0026gt;1 MB, 5 MB goal, 1 P 8gc 7 @0.224s 2%: 0.027+2.4+0.003 ms clock, 0.027+0.63/0/0+0.003 ms cpu, 4-\u0026gt;5-\u0026gt;2 MB, 5 MB goal, 1 P 9# command-line-arguments 10gc 1 @0.004s 17%: 0.009+2.4+0.002 ms clock, 0.009+1.3/0/0+0.002 ms cpu, 4-\u0026gt;6-\u0026gt;5 MB, 5 MB goal, 1 P 11gc 2 @0.036s 16%: 0.014+8.7+0.004 ms clock, 0.014+4.0/2.2/0+0.004 ms cpu, 9-\u0026gt;9-\u0026gt;8 MB, 11 MB goal, 1 P 12mem.Alloc: 48128 13mem.TotalAlloc: 48128 14mem.HeapAlloc: 48128 15mem.NumGC: 0 16----- 17gc 1 @0.007s 1%: 0.011+0.11+0.002 ms clock, 0.011+0.10/0/0+0.002 ms cpu, 95-\u0026gt;95-\u0026gt;0 MB, 96 MB goal, 1 P 18gc 2 @0.054s 0%: 0.030+0.13+0.002 ms clock, 0.030+0.12/0/0+0.002 ms cpu, 95-\u0026gt;95-\u0026gt;0 MB, 96 MB goal, 1 P 19gc 3 @0.106s 0%: 0.023+0.12+0.002 ms clock, 0.023+0.12/0/0+0.002 ms cpu, 95-\u0026gt;95-\u0026gt;0 MB, 96 MB goal, 1 P 20gc 4 @0.141s 0%: 0.023+0.15+0.004 ms clock, 0.023+0.15/0/0+0.004 ms cpu, 95-\u0026gt;95-\u0026gt;0 MB, 96 MB goal, 1 P 21gc 5 @0.185s 0%: 0.021+0.12+0.001 ms clock, 0.021+0.11/0/0+0.001 ms cpu, 95-\u0026gt;95-\u0026gt;0 MB, 96 MB goal, 1 P 22gc 6 @0.221s 0%: 0.023+0.22+0.002 ms clock, 0.023+0.22/0/0+0.002 ms cpu, 95-\u0026gt;95-\u0026gt;0 MB, 96 MB goal, 1 P 23gc 7 @0.269s 0%: 0.025+0.12+0.001 ms clock, 0.025+0.12/0/0+0.001 ms cpu, 95-\u0026gt;95-\u0026gt;0 MB, 96 MB goal, 1 P 24gc 8 @0.311s 0%: 0.032+0.33+0.002 ms clock, 0.032+0.32/0/0+0.002 ms cpu, 95-\u0026gt;95-\u0026gt;0 MB, 96 MB goal, 1 P 25gc 9 @0.350s 0%: 0.022+0.10+0.006 ms clock, 0.022+0.097/0/0+0.006 ms cpu, 95-\u0026gt;95-\u0026gt;0 MB, 96 MB goal, 1 P 26gc 10 @0.390s 0%: 0.021+0.11+0.005 ms clock, 0.021+0.10/0/0+0.005 ms cpu, 95-\u0026gt;95-\u0026gt;0 MB, 96 MB goal, 1 P 27mem.Alloc: 100045256 28mem.TotalAlloc: 1000128368 29mem.HeapAlloc: 100045256 30mem.NumGC: 9 31----- در نگاه اول خروجی کد بالا کمی گند به نظر می رسد که سعی می کنیم در ذیل آنها را توضیح دهیم\nخروجی توضیح gc 1 شماره پاکسازی که در هربار اجرای عملیات پاکسازی بصورت خودکار به آن اضافه می شود @0.007s زمان اجرای پاکسازی بعد از شروع به کار برنامه 0% درصد منابع پردازشی استفاده شده بعد از اجرای برنامه 0.011+0.11+0.002 ms clock مقدار این متغیر متشکل از چند مقدار است که بصورت ذیل محاسبه می شود Tgc = Tseq + Tmark + Tsweep 95-\u0026gt;95-\u0026gt;0 MB این متغیر نیز چند مقداری است و مقادیر اول نشانگر عملکرد حافظه قبل از اجرای پاکسازی ، دوم بعد از اجرای پاکسازی و سوم مقدار پشته است 96 MB goal اندازه پشته برنامه مورد نظر 1 P تعداد پردازنده مورد استفاده شده Tseq: زمان توقف گوروتین های کاربر\nTmark: زمان مورد استفاده جهت فاز mark\nTsweep: زمان مورد استفاده جهت فاز sweep\n"},{"id":64,"href":"/chapter-4/go-plugin/","title":"4.22 کتابخانه Plugin","section":"فصل چهارم: مباحث پیشرفته","content":"در میان ویژگی‌های قابل توجه Go نسخه 1.8، سیستم جدید پلاگین‌های Go قرار دارد. این ویژگی به برنامه‌نویسان اجازه می‌دهد تا برنامه‌های ماژولار بدون ارتباط زنجیره‌ای با هم، با استفاده از بسته‌هایی که به صورت کتابخانه‌های اشیا شیء‌گرا کامپایل شده‌اند، ساخته شوند و به‌صورت پویا در زمان اجرا بارگذاری و به‌صورت پیوسته به آن‌ها پیوند داده شوند.\nاین تغییر بزرگی است! چرا که توسعه‌دهندگان نرم‌افزارهای سیستمی بزرگ در Go، بدون شک، نیاز به ماژولارسازی کد خود دارند. ما برای دستیابی به ماژولارسازی کد، از طراحی‌های متعدد out-of-process، مانند OS exec calls، سوکت و RPC/gRPC (و غیره) استفاده کرده‌ایم. این روش‌ها ممکن است به خوبی کار کنند، اما در بسیاری از زمینه‌ها به‌عنوان پایانه‌ای برای پردازش با قبل نبود یک سیستم پلاگین‌ای ناتیو در Go بکار رفته‌اند.\nدر این بخش از کتاب، من بررسی می‌کنم که ایجاد نرم‌افزار ماژولار با استفاده از سیستم پلاگین‌های Go (plugin) چه تبعاتی دارد.\nاز نسخه 1.8، plugin فقط در لینوکس کار می‌کند. با توجه به سطح علاقمندی به این ویژگی، این احتمالا در نسخه‌های آینده تغییر خواهد کرد. 4.22.1 طراحی ماژولار با Go # ایجاد برنامه‌های ماژولار با پلاگین﻿‌های Go، نیاز به همان شیوه کار قابل اعتماد نرم‌افزاری دارد که به بسته‌های Go رایج اعمال می‌شود. با این‌حال، پلاگین‌ها نگرانی‌های طراحی جدید را با توجه به اتصالشان به دیگر اجزای برنامه، بیشتر کرده‌اند.\nدر هنگام ساخت سیستم نرم‌افزاری قابل پلاگین‌گذاری، بسیار مهم است که قابلیت‌های واضحی برای اجزای سیستم تعریف شوند. سیستم باید رابط‌های ساده و شفافی برای یکپارچه‌سازی پلاگین فراهم کند. از سوی دیگر، توسعه‌دهندگان پلاگین باید به عنوان یک جعبه سیاه برای سیستم در نظر گرفته شوند و علاوه بر قراردادهای ارائه‌شده، هیچ فرضیاتی را انجام ندهند. پلاگین باید به عنوان یک اجزای مستقل در نظر گرفته شود که از دیگر اجزا جدا شده است. این باعث می‌شود که پلاگین‌ها بتوانند دوره‌ی life cycle توسعه و استقرار خود را بدون وابستگی به مصرف‌کنندگانشان دنبال کنند. کد پلاگین باید طراحی شود تا تمرکز خود را فقط بر روی یکی از مسائل عملکردی داشته باشد و نه بیشتر از آن. از آنجایی که پلاگین‌ها اجزای مستقل‌ای هستند که در زمان اجرا بارگیری می‌شوند، مهم این است که از مستندات خوبی برخوردار باشند. به عنوان مثال، نام توابع و متغیرهای پیاده سازی باید به طور واضح مشخص شوند تا خطاهای جستجوی symbol ها را جلوگیری کنند. پلاگین‌های Go می‌توانند تابع‌های بسته و متغیرهایی از هر نوع را به‌صورت خروجی دهند. می‌توانید پلاگین‌تان را طراحی کنید تا قابلیت‌های خود را به‌صورت یک مجموعه‌ی تابع‌های آزاد گروه‌بندی کند. سردرگمی، این است که شما باید به‌صورت جداگانه هر symbol تابع را جستجو و به آن متصل شوید. راهکار بهتر این است که از انواع interface استفاده کنید. ایجاد یک interface برای صادرکردن قابلیت‌ها، یک سطح تعاملی یکنواخت و مختصر با نشانگرهای عملیاتی واضح فراهم می‌کند. جستجو و متصل کردن به‌نمادی که به یک رابط حل می‌شود، دسترسی به کل مجموعه شیوه های تابعی برای قابلیت‌ها را فراهم می‌کند، نه فقط یکی از آن‌ها. 4.22.2 کتابخانه plugin # کتابخانه plugin، یک کتابخانه خیلی ساده و آسان است و فقط یک تابع Open و یک متد Lookup دارد که به شما برای بازکردن فایل so. و استفاده ازinterface های پیاده سازی شده کمک می کند.\n1type Plugin 2\tfunc Open(path string) (*Plugin, error) 3\tfunc (p *Plugin) Lookup(symName string) (Symbol, error) 4\t5type Symbol کتابخانه plugin، یک پکیج اصلی Go با توابع و متغیرهای صادرشده است که با استفاده از دستور زیر برای کامپایل ساخته شده است:\n1$ go build -buildmode=plugin وقتی که یک plugin برای اولین بار باز می‌شود، تابع init تمام بسته‌هایی که هنوز قسمت برنامه نیستند فراخوانی می‌شوند. تابع اصلی اجرا نمی‌شود. یک plugin تنها یکبار مقداردهی اولیه می‌شود و نمی‌تواند بسته شود.\n4.22.3 پیاده سازی قدم به قدم یک برنامه ماژولار با plugin # فرض کنید قصد یک پروژه بنویسیم که hello world را به زبان های مختلف در خروجی terminal چاپ کنیم.\n4.22.3.1 نمونه ساختار پروژه # در ابتدا نیاز داریم یک پروژه با ساختار زیر پیاده سازی کنیم:\n1├── [ 22] go.mod 2├── [ 779] main.go 3└── [ 224] plugin 4 ├── [ 240] en 5 │ └── [ 152] en.go 6 └── [ 240] fa 7 ├── [ 155] fa.go 4.22.3.2 نوشتن پلاگین # در ابتدا یک دایرکتوری plugin ایجاد کنید سپس براساس زبان مورد نظر خود یک یا چند sub directory ایجاد کنید.\nحال برای زبان فارسی و انگلیسی از کد زیر استفاده کنید:\nEnglish\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type hello string 6 7func (h hello) Hello() { 8fmt.Println(\u0026#34;Hello 🌎\u0026#34;) 9} 10 11// Hello exported as symbol named 12var Hello hello Persian\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type hello string 6 7func (h hello) Hello() { 8fmt.Println(\u0026#34;سلام 🌎\u0026#34;) 9} 10 11// Hello exported as symbol named 12var Hello hello در کد فوق ما به ازای هر زبان یک فایل go ایجاد کردیم که با پکیج main شروع می شود و داخلش یک type مشخص قرار دادیم و متد Hello را پیاده سازی کردیم. سپس یک متغییر با نام Hello تعریف کردیم تا به عنوان symbol برای پلاگین در دسترس باشد.\nاگر package شما نام دیگری غیر از main باشد با خطا مواجه خواهید شد به دلیل build شدن ماژول هستش.\n1-buildmode=plugin requires exactly one main package 4.22.3.3 بیلد پلاگین ها # برای بیلد گرفتن پلاگین ها باید از دستورات زیر استفاده کنید:\n1go build -buildmode=plugin -o plugin/en/en.so plugin/en/en.go 2 3 go build -buildmode=plugin -o plugin/fa/fa.so plugin/fa/fa.go زمانیکه بیلد میگیرید فایل پلاگین ها در محل plugin/en یا plugin/fa با پسوند so. قرار میگیرد.\nحال با استفاده از ابزار file در لینوکس می توانید اطلاعات ماژول بیلد شده را ببینید که به عنوان dynamic shared object شناخته می شود:\n1$ file plugin/en/en.so 2plugin/en/en.so: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, BuildID[sha1]=d23f35974563f658267b158466cbb551a97fb049, with debug_info, not stripped ساختار پروژه پس از بیلد پلاگین ها\n1├── [ 22] go.mod 2├── [ 779] main.go 3└── [ 224] plugin 4 ├── [ 240] en 5 │ ├── [ 152] en.go 6 │ └── [ 3.5M] en.so 7 └── [ 240] fa 8 ├── [ 155] fa.go 9 └── [ 3.5M] fa.so 4.22.3.4 استفاده از پلاگین ها # داخل روت پروژه یک فایل main.go ایجاد کنید و کد زیر را قرار دهید.\nتوجه کنید نیاز دارید فایل های پلاگین را در هر محلی هست load کنید.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;os\u0026#34; 6\t\u0026#34;plugin\u0026#34; 7) 8 9type Greeter interface { 10\tHello() 11} 12 13func main() { 14\t// determine plugin to load 15\tlang := \u0026#34;english\u0026#34; 16\tif len(os.Args) == 2 { 17\tlang = os.Args[1] 18\t} 19\tvar mod string 20\tswitch lang { 21\tcase \u0026#34;english\u0026#34;: 22\tmod = \u0026#34;./plugin/en/en.so\u0026#34; 23\tcase \u0026#34;persian\u0026#34;: 24\tmod = \u0026#34;./plugin/fa/fa.so\u0026#34; 25\tdefault: 26\tfmt.Println(\u0026#34;don\u0026#39;t support your language\u0026#34;) 27\tos.Exit(1) 28\t} 29 30\t// load module 31\tplug, err := plugin.Open(mod) 32\tif err != nil { 33\tfmt.Println(err) 34\tos.Exit(1) 35\t} 36 37\t// lookup for symbol 38\tsymbol, err := plug.Lookup(\u0026#34;Hello\u0026#34;) 39\tif err != nil { 40\tfmt.Println(err) 41\tos.Exit(1) 42\t} 43 44\t// assert symbol with interface 45\tp, ok := symbol.(Greeter) 46\tif !ok { 47\tfmt.Println(\u0026#34;unexpected type from module symbol\u0026#34;) 48\tos.Exit(1) 49\t} 50 51\t// call interface method 52\tp.Hello() 53 54} 1$ go run main.go english 2Hello 🌎 در ابتدا یک interface به همراه متد مشابه داخل پلاگین قرار دادیم. سپس داخل main یک زبان پیش فرض را داخل متغیر lang تعیین کردیم سپس از طریق os.Args زبان از طریق os.Stdin گرفتیم و داخل lang قرار دادیم پس از آن با استفاده از switch چک کردیم براساس زبان یک پلاگین یا ماژول مشخص را داخل متغیر mod مسیر دهی کنیم. سپس تابع Open کتابخانه plugin را فراخوانی کردیم و مسیر پلاگین را قرار دادیم. حال پس از باز شدن پلاگین متد Lookup را برای پیدا کردن symbol فراخوانی کردیم که ما نام symbol را Hello گذاشتیم. پس از اینکه symbol بدون خطا load شد ما symbol را با اینترفیس Greeter گرفتیم Assert کردیم تا بتوانیم از متدهای پیاده سازی شده استفاده کنیم. 4.22.4 پروژه هایی که از plugin استفاده کرده اند # در زیر ما لیستی از پروژه های فعالی که از پلاگین استفاده کرده اند را قرار دادیم تا بتوانید برای پیاده سازی پروژه های ماژولار ایده بگیرید:\nhttps://github.com/hashicorp/go-plugin https://github.com/luraproject/lura https://github.com/smartcontractkit/chainlink-starknet https://github.com/ava-labs/blobvm https://github.com/easysoft/zentaoatf 4.22.5 کلام آخر # ماژولارنویسی یکی از مهم ترین عناوین توسعه و طراحی نرم افزار بوده که شما با اینکار می توانید پلاگین های reusable بنویسید و در هر پروژه ای بسته به نیازتان استفاده کنید. شرکت های بزرگی نظیر hashicorp برای اکثر پروژهایش نظیر terraform یا consul از این قابلیت استفاده کرده است.\n"},{"id":65,"href":"/chapter-4/oop/","title":"4.23 شی گرایی در زبان گو","section":"فصل چهارم: مباحث پیشرفته","content":"گو یک زبان statically-typed است و بطور کلی امکانات شی گرایی را به شیوه قدیم و مرسوم پشتیبانی نمی کند. اما در عوض یک شیوه قرار دادی وجود دارد که به شما کمک می کند برخی از مفاهیم شی گرایی را با کمک اینترفیس, composition, متد و type embedding پیاده سازی کنید.\nاین مفاهیم شامل :\nکپسوله سازی ارث بری پلی مورفیسم overriding abstraction تعریف شی گرایی به زبان ساده # بیاید با چند تا مثال ساده، سوا از اینکه با چه زبانی کار می کنیم، با مفهوم شی گرایی آشنا شویم.\nقراره با یه سری مثال از دنیای واقعی شی گرایی رو براتون توضیح بدم. ما موجودی داریم به اسم گربه (class) که این موجود ویژگی (Attribute) و رفتار (Method) هایی رو داره. برای مثال گربه ویژگی هایی مثل رنگ چشم، وزن و \u0026hellip; داره. همچنین رفتار هایی رو داره مثل راه رفتن،‌ میو میو کردن.\nخب تا الان گربه رو به صورت انتزاعی گفتیم که فلان ویژگی ها و رفتار هارو داره. به یک نمونه واقعی از گربه object و یا instance میگیم.\nگربه خودش از یک کلاس والد ارث بری (Inheritance) کرده. مثلا کلاسی داریم به اسم حیوان. کلاس حیوان یه سری ویژگی ها و رفتار هایی رو داره. حالا که گربه از کلاس حیوان ارث بری کرده رفتار ها و ویژگی های والدش رو ارث میگیره.\nخب اینجا یه سوالی پیش میاد! ما کلی موجود داریم که کلاس والدشون حیوان هستش ولی آیا همشون شبیه به همدیگه رفتار می کنن؟ برای مثال همشون یه شکلی راه میرن و صدا در میارن؟ جواب قطعا خیر هستش. اینجاس که چند ریختگی (Polymorphism) اتفاق میوفته. درسته که هم سگ و هم گربه صدا دارن ولی یکیش میو میکنه یکیش هاپ هاپ\nبعضی وقتا نیازه که ما یک سری ویژگی ها و متد هایی رو تعریف کنیم اما از بیرون قابل دسترس نباشه. مثلا attribute به اسم score داریم که امتیاز رو نگه میداریم. بقیه قسمت های کد نباید بصورت مستقیم بتونن مقدار score رو تغییر بدن پس میایم socre رو مخفی می کنیم تا از بیرون دسترسی نداشته باشن و برای تغییر دادن socre یک متد به اسم increase_score می نویسیم که هربار صدا زده بشه به امتیاز کاربر اضافه بشه.\nمثال دوم: فرض کن یه پکیجی رو داری مینویسی که قراره یه سری کارهایی رو انجام بده. نمیخوای برنامه نویسی که قراره از پکیجت استفاده کنه یه سری رفتار و ویژگی هارو ببینه. مثلا متد get_response رو داری که خود این متد چند تا متد دیگه رو صدا میزنه تا بتونه پاسخ مناسب رو نشون بده.\nاین متد هایی که توی get_response استفاده کردیم فقط برای استفاده داخلی نوشته شدن و نمیخوایم برنامه نویس بهشون دسترسی داشته باشه. پس میایم مخفی میکنیمشون و از encapsulation استفاده می کنیم\nهر ساله ماشین ها از نظر فنی کلی تغییر می کنن اما شخصی که با یک ماشین چند سال پیش رانندگی کرده باشه با ماشین الانم میتونه رانندگی کنه. اینجاست که abstraction باعث میشه این اتفاق بیوفته. اومدن بصورت انتزاعی تعریف کردن که ماشین دنده داره، پدال گاز داره و فرمون داره و هر کدومشون به چه صورت عمل می کنن.\nبه همین دلیل با اینکه از نظر فنی و داخلی کلی تغییر میکنن اما طرز استفاده ازش تغییر خاصی نمیکنه.\nبیاید یه مثال دیگه بزنیم: فرض کنید شما یک وب سایت طراحی کردید. یه سری دکمه ها و قابلیت ها قرار دادید تا کاربر بتونه ازش استفاده کنه. با اینکه سبد خرید برای کاربر همونه اما پشت صحنه کلی تغییر دادید و بروزرسانیش کردید.\nهمچنین شما هم برای طراحی وب سایت از یک سری ابزار ها استفاده کردید که این ابزار ها همش در حال بروز رسانی هستند اما نحوه استفاده شما تغییری نمیکنه.\nبه این مفهوم Abstraction میگن.\nدر ادامه این بخش بررسی می کنیم که در زبان گولنگ آیا مفاهیم شی گرایی رو داریم یا نه. اگه داریم به چه صورت قابل پیاده سازی هستند.\n"},{"id":66,"href":"/chapter-4/oop/go-encapsulation/","title":"4.23.1 کپسوله سازی (Encapsulation)","section":"4.23 شی گرایی در زبان گو","content":"کپسوله سازی در زبان گو یا هر زبان دیگری یک مفهوم مشترک می باشد که شما یک داده یک تابع را پشت یک آبجکت یا یک واحد مستقل بپوشانید. با اینکار شما جلوی دسترسی مستقیم برروی داده را میگیرید. این کار در شی گرایی کمک می کند شما کدهای خود را بهتر سازماندهی کنید و جلوی دسترسی مستقیم ناخواسته را بگیرید.\nدر زبان گو برای Public/Private کردن یک آبجکت یا تابع کلمه کلیدی به نام public/private ندارد ولی در عوض شما می توانید داخل هر پکیج با بزرگ یا کوچک کردن حرف اول نام هر آبجکت یا تابع جلو دسترسی مستقیم را بگیرید.\n1var DatabaseName string // public 2var databaseName string // private 3 4func Greeting() {} // public 5func greeting() {} // private زمانی که شما یک آبجکت یا تابع را به شیوه فوق private می کنید در واقع آن آبجکت یا تابع فقط در همان package level خود در دسترس می باشد.\nبه عنوان مثال اگر تابع greeting داخل پکیج message باشد فقط در همان جا در دسترس می باشد.\n1└── message 2 ├── data.go 3 ├── message.go 4 └── resp.go در زیر یک مثال ساده زدیم توجه کنید :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type Person struct { 6\tname string 7\tage int 8} 9 10func (p *Person) GetAge() int { 11\treturn p.age 12} 13 14func (p *Person) getName() string { 15\treturn p.name 16} 17 18func (p *Person) SetAge(age int) { 19\tp.age = age 20} 21 22func main() { 23\tperson := Person{ 24\tname: \u0026#34;Javad\u0026#34;, 25\t} 26 27\tperson.SetAge(29) 28 29\tfmt.Printf(\u0026#34;%s with age %d\u0026#34;, person.getName(), person.GetAge()) 30} 1$ go run main.go 2Javad with age 29 کد فوق ما یک ساختار (آبجکت) Person ایجاد کردیم که داخلش ۲ فیلد name, age بصورت private وجود دارد که سایر پکیج ها نمی توانند دسترسی مستقیم به فیلد های Person دسترسی داشته باشند. حال ۳ متد تعریف کردیم GetAge برای گرفتن سن شخص , SetAge برای تعیین سن شخص , getName گرفتن نام شخص که فقط داخل همان پکیج در دسترس است این متد.\n"},{"id":67,"href":"/chapter-4/oop/go-inheritance/","title":"4.22.2 ارث بری","section":"4.23 شی گرایی در زبان گو","content":"در زبان گو ارث بری در واقع type embedding هست با استفاده type embedding می توانید یک type را داخل type دیگری جاسازی کنید و به واسطه type والد قابل دسترس است.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type Person struct { 6\tName string 7} 8 9func (p *Person) Introduce() { 10\tfmt.Printf(\u0026#34;Hi, my name is %s\\n\u0026#34;, p.Name) 11} 12 13type Student struct { 14\tPerson 15\tSchool string 16} 17 18func main() { 19\ts := \u0026amp;Student{Person{\u0026#34;John Doe\u0026#34;}, \u0026#34;Go University\u0026#34;} 20\ts.Introduce() 21} 1$ go run main.go 2Hi, my name is John Doe "},{"id":68,"href":"/chapter-4/oop/go-polymorphism/","title":"4.23.3 پلی مورفیسم (Polymorphism)","section":"4.23 شی گرایی در زبان گو","content":"پلی مورفیسم یکی از مفاهیم مهم در شی گرایی می باشد و هدف استفاده از پلی مورفیسم این است بین آبجکت ها رفتار مشترکی ایجاد کنیم. در زبان گو شما می توانید یک اینترفیس تعریف کنید و برای ساختارهای مختلف متدهای اینترفیس را پیاده سازی کنید.\nبه مثال زیر توجه کنید :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5// Shape is an interface that defines a method named `Area` 6type Shape interface { 7\tArea() float64 8} 9 10// Rectangle is a struct that represents a rectangle 11type Rectangle struct { 12\twidth float64 13\theight float64 14} 15 16// Area implements the Shape interface for Rectangle 17func (r Rectangle) Area() float64 { 18\treturn r.width * r.height 19} 20 21// Circle is a struct that represents a circle 22type Circle struct { 23\tradius float64 24} 25 26// Area implements the Shape interface for Circle 27func (c Circle) Area() float64 { 28\treturn 3.14 * c.radius * c.radius 29} 30 31func CalcArea(shapes ...Shape) { 32\tfor _, shape := range shapes { 33\tfmt.Println(shape.Area()) 34\t} 35} 36 37func main() { 38\tr := Rectangle{width: 10, height: 5} 39\tc := Circle{radius: 5} 40 41\tCalcArea(r, c) 42} 1$ go run main.go 250 378.5 در کد فوق ما یک اینترفیس Shape داریم که داخلش یک متد به نام Area هست حال این متد را برای ساختارهای Rectangle و Circle پیاده سازی کردیم که مساحت دایره و مستطیل را محاسبه کنیم. حال یک تابع CalcArea داریم به عنوان پارامتر slice از Shape ها میگیرد که ما داخل تابع main ساختار Rectangle و Circle که متد Area اینترفیس Shape را پیاده سازی کرده اند را پاس دادیم و در نهایت محاسبه مساحت را در خروجی چاپ می کند.\n"},{"id":69,"href":"/chapter-4/oop/go-overriding/","title":"4.23.4 overriding","section":"4.23 شی گرایی در زبان گو","content":"در زبان گو مثل سایر زبان های شی گرا امکان overriding مستقیم یک متد وجود ندارد اما در عوض شما می توانید با استفاده از type embedding و پیاده سازی متد یک اینترفیس این تکنیک را انجام دهید و به متدی که override انجام داده Shadow Method می گویند.\nبه مثال زیر توجه کنید :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type User interface { 6\tPrintName() 7} 8 9type Person struct { 10\tName string 11} 12 13func (p Person) PrintName() { 14\tfmt.Println(\u0026#34;My name is\u0026#34;, p.Name) 15} 16 17type Student struct { 18\tPerson 19} 20 21func (s Student) PrintName() { 22\tfmt.Println(\u0026#34;I am a student and my name is\u0026#34;, s.Name) 23} 24 25func main() { 26\tp := Person{Name: \u0026#34;John\u0026#34;} 27\ts := Student{Person{Name: \u0026#34;Jane\u0026#34;}} 28 29\tp.PrintName() 30\ts.PrintName() 31} 1$ go run main.go 2My name is John 3I am a student and my name is Jane در کد فوق ما یک اینترفیس User داریم که داخلش یک متد PrintName وجود دارد که این متد نام شخص یا دانش آموز را به همراه توضیحات چاپ می کند. حال ۲ تا ساختار داریم Person و Student که ساختار student فقط Person را جاسازی کرده است. سپس برای این ۲ ساختار متد PrintName را پیاده سازی کردیم با این تفاوت که داخل متد PrintName ساختار Student متن دیگری قرار دادیم. در تابع main ما متغیر p, s را از نوع Person و Student ایجاد و مقدار دهی کردیم. سپس متد PrintName هر دو را فراخوانی کردیم.\n"},{"id":70,"href":"/chapter-4/oop/go-abstraction/","title":"4.23.5 abstraction","section":"4.23 شی گرایی در زبان گو","content":"Abstraction (به معنای انتزاع)، فرآیند حذف یا از بین بردن برخی ویژگی‌های غیرضروری یک چیز به‌منظور کاهش، خلاصه‌سازی و به کار بردن آن در مجموعه‌ای از ویژگی‌های ضروری است. در برنامه‌نویسی شیءگرا(OOP)، انتزاع یکی از سه مفهوم اصلی (به همراه مفاهیم Encapsulation و Inheritance) است.\nبه نقل از ویکی پدیا : انتزاع،[۱] (به انگلیسی: Abstraction) تجرید یا آهنجش فرایند اختصار، فشرده‌سازی، و تلخیص اطّلاعات از طریق شناسائی، استخراج و سپس، جداسازی و پنهان‌سازی جزئیّات[۲] از کلیّات[۳] است. انتزاع در لغت به معنای جدا کردن، گرفتن، درآوردن جزئی از یک کل[۴] و به معنای بازداشتن و امتناع کردن، برکندن و از جای کشیدن، گرفتن، و دور شدن می‌باشد.[۵]\nانتزاع فرایند یا نتیجهٔ تعمیم بخشیدن با کاهش محتوای اطلاعاتی یک مفهوم یا یک پدیدهٔ قابل مشاهده، جهت حفظ اطلاعات برای منظور خاص می‌باشد.\nدر زبان گو abstraction با استفاده از اینترفیس می توان انجام داد. یک اینترفیس یکسری متد دارد که ما این متدها را برای هریک از تایپ های مختلف پیاده سازی می کنیم.\nبه مثال زیر توجه کنید :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5// Shape is an interface that defines the basic methods for a shape. 6type Shape interface { 7\tArea() float64 8\tPerimeter() float64 9} 10 11// Rectangle is a struct that implements the Shape interface. 12type Rectangle struct { 13\twidth, height float64 14} 15 16// Area returns the area of the rectangle. 17func (r Rectangle) Area() float64 { 18\treturn r.width * r.height 19} 20 21// Perimeter returns the perimeter of the rectangle. 22func (r Rectangle) Perimeter() float64 { 23\treturn 2 * (r.width + r.height) 24} 25 26// Circle is a struct that implements the Shape interface. 27type Circle struct { 28\tradius float64 29} 30 31// Area returns the area of the circle. 32func (c Circle) Area() float64 { 33\treturn 3.14 * c.radius * c.radius 34} 35 36// Perimeter returns the perimeter of the circle. 37func (c Circle) Perimeter() float64 { 38\treturn 2 * 3.14 * c.radius 39} 40 41func main() { 42\t// Create a rectangle and a circle. 43\tr := Rectangle{width: 10, height: 20} 44\tc := Circle{radius: 5} 45 46\t// Declare a slice of Shape interfaces. 47\tshapes := []Shape{r, c} 48 49\t// Iterate over the shapes and print their area and perimeter. 50\tfor _, shape := range shapes { 51\tfmt.Println(\u0026#34;Area:\u0026#34;, shape.Area()) 52\tfmt.Println(\u0026#34;Perimeter:\u0026#34;, shape.Perimeter()) 53\tfmt.Println(\u0026#34;\u0026#34;) 54\t} 55} 1$ go run main.go 2Area: 200 3Perimeter: 60 4 5Area: 78.5 6Perimeter: 31.400000000000002 در کد فوق ما یک اینترفیس Shape داریم که ۲ تا متد Area و Perimeter داریم که مساحت و محیط را محاسبه می کند. در ادامه ۲ ساختار Rectangle و Circle داریم که برای این ساختارها متدهای اینترفیس Shape را پیاده سازی کردیم و در نهایت اندازه مساحت و محیط را محاسبه می کنیم.\n"},{"id":71,"href":"/chapter-4/tracing/","title":"4.24 آموزش tracing","section":"فصل چهارم: مباحث پیشرفته","content":"در این فصل، این مورد را یاد خواهیم گرفت که چگونه یک برنامه در حال اجرا را ردیابی کنیم و آن را با ابزار ردیابی مشاهده کنیم. در این حالت با استفاده از کتابخانه استاندارد، یک ردیابی ایجاد خواهیم کرد.\n4.24.1 مثال از tracing # ما برنامه ای داریم که تعداد دفعات یافتن یک topic را در collection ای ازRSS news feed document را می شمارد. این برنامه از یک threaded algorithm به نام freq استفاده می کند که روی collection تکرار می شود و هر سند را یک به یک پردازش می کند و تعداد دفعاتی که topic پیدا شده است را برمی‌گرداند.\n1func freq(topic string, docs []string) int { 2\tvar found int 3\tfor _, doc := range docs { 4\tfile := fmt.Sprintf(\u0026#34;%s.xml\u0026#34;, doc[:8]) 5\tf, err := os.OpenFile(file, os.O_RDONLY, 0) 6\tif err != nil { 7\tlog.Printf(\u0026#34;Opening Document [%s] : ERROR : %v\u0026#34;, doc, err) 8\treturn 0 9\t} 10\tdata, err := io.ReadAll(f) 11\tf.Close() 12\tif err != nil { 13\tlog.Printf(\u0026#34;Reading Document [%s] : ERROR : %v\u0026#34;, doc, err) 14\treturn 0 15\t} 16\tvar d document 17\tif err := xml.Unmarshal(data, \u0026amp;d); err != nil { 18\tlog.Printf(\u0026#34;Decoding Document [%s] : ERROR : %v\u0026#34;, doc, err) 19\treturn 0 20\t} 21\tfor _, item := range d.Channel.Items { 22\tif strings.Contains(item.Title, topic) { 23\tfound++ 24\tcontinue 25\t} 26\tif strings.Contains(item.Description, topic) { 27\tfound++ 28\t} 29\t} 30\t} 31\treturn found 32} تابع Freq کار را به چهار مرحله تقسیم می کند: باز کردن، خواندن، باز کردن و جستجو. برای تست تابع freq، تابع main مجموعه ای از فایل های 4k را می سازد و freq را فراخوانی می کند.\n1type ( 2 3item struct { 4 5XMLName xml.Name `xml:\u0026#34;item\u0026#34;` 6 7Title string `xml:\u0026#34;title\u0026#34;` 8 9Description string `xml:\u0026#34;description\u0026#34;` 10 11} 12 13 14 15channel struct { 16 17XMLName xml.Name `xml:\u0026#34;channel\u0026#34;` 18 19Items []item `xml:\u0026#34;item\u0026#34;` 20 21} 22 23 24 25document struct { 26 27XMLName xml.Name `xml:\u0026#34;rss\u0026#34;` 28 29Channel channel `xml:\u0026#34;channel\u0026#34;` 30 31} 32 33) 34 35 36 37func main() { 38 39docs := make([]string, 4000) 40 41for i := range docs { 42 43docs[i] = fmt.Sprintf(\u0026#34;newsfeed-%.4d.xml\u0026#34;, i) 44 45} 46 47topic := \u0026#34;president\u0026#34; 48 49n := freq(topic, docs) 50 51log.Printf(\u0026#34;Searching %d files, found %s %d times.\u0026#34;, len(docs), topic, n) 52 53} کدی که تکه‌ای از اسناد 4k را می‌سازد، مجموعه‌ای از فایل‌های منحصربه‌فرد را براساس یک فایل واقعی که ما newfeed.xml نامیده‌ایم ایجاد می‌کند.\n1newsfeed.xml 2 3\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; 4 5\u0026lt;?xml-stylesheet title=\u0026#34;XSL_formatting\u0026#34; type=\u0026#34;text/xsl\u0026#34;?\u0026gt; 6 7\u0026lt;rss\u0026gt; 8 9\u0026lt;channel\u0026gt; 10 11\u0026lt;title\u0026gt;\u0026lt;![CDATA[BBC News - US \u0026amp; Canada]]\u0026gt;\u0026lt;/title\u0026gt; 12 13\u0026lt;description\u0026gt;\u0026lt;![CDATA[BBC News - US \u0026amp; Canada]]\u0026gt;\u0026lt;/description\u0026gt; 14 15\u0026lt;item\u0026gt; 16 17\u0026lt;title\u0026gt;\u0026lt;![CDATA[President China visit: US leader strik]]\u0026gt;\u0026lt;/title\u0026gt; 18 19\u0026lt;description\u0026gt;\u0026lt;![CDATA[The US president praises]]\u0026gt;\u0026lt;/description\u0026gt; 20 21\u0026lt;/item\u0026gt; 22 23\u0026lt;/channel\u0026gt; 24 25\u0026lt;/rss\u0026gt; این یک نمونه بسیار کوچک از فایل newsfeed.xml است. به جای اینکه فایل های واقعی 4k را نگه داریم، فقط یک فایل را نگه می داریم و تلاش می کنیم که 4k یکی از آنها را نشان دهد. الگوریتم freq کاراکترهای اضافی را از نام فایل، قبل از باز کردن فایل حذف می کند. خوب است که یک ایده اولیه از مدت زمان لازم برای پردازش این 4000 فایل با نسخه تک رشته ای Freq داشته باشید. پس می توانیم این کار را با استفاده از time command در ارتباط با اجرای برنامه انجام دهیم.\n1$ go build 2$ time ./trace 32021/05/12 09:30:52 Searching 4000 files, found president 28000 times. 4./trace 2.63s user 0.18s system 101% cpu 2.763 total می بینیم که زمان اجرای برنامه حدود 2.7 ثانیه طول کشید تا فایل های 4k را پردازش کند. اگر قرار بود فقط فایل‌های 4k یا شاید حتی چند هزار فایل دیگر را پردازش کنیم، این برنامه تکمیل شده و تمام بود. با این حال، در نظر داریم که توانایی پردازش یک میلیون فایل را داشته باشیم و تجزیه و تحلیل آن ساعت‌ها طول نکشد. پس باید راهی برای افزایش سرعت این برنامه پیدا کنیم. در واقع می‌توانیم از یک memory profile استفاده کنیم، هر چند که این برنامه از memory گذرا زیادی استفاده می‌کند و کار زیادی نمی‌توانیم در مورد آن انجام دهیم. پس می‌توانیم از یک cpu profile استفاده کنیم. این روش به در واقع بیان می‌کند که به لطف فراخوانی با os.OpenFile، بیشتر زمان را در فراخوانی و رخدادهای سیستمی مصرف می‌کنیم. مشکل استفاده از profiler در اینجا این است که یک profiler فقط می تواند بگوید که چه اتفاقی می افتد ولی باید بدانیم چه چیزی اتفاقی می افتد و چه چیزی اتفاق نمی افتد تا راهی برای سرعت بخشیدن به این برنامه پیدا کنیم. وقتی باید ببینیم چه اتفاقی نیافتاده، ابزار ردیابی گزینه خوبی است.\n4.24.2 Generating Traces # از آنجایی که این برنامه در عرض چند ثانیه شروع و متوقف می شود، می توانیم از کتابخانه استاندارد برای ایجاد ردی از این برنامه استفاده کنم. به طور کلی، ایجاد ردیابی برای بیش از چند ثانیه از زمان اجرا می‌تواند برای بررسی سخت باشد، زیرا یک ردیابی مقدار زیادی داده تولید می‌کند. ما می خواهیم بر روی ردپاهای کوچک و هدفمند تمرکز کنیم.\n1import ( 2 3\u0026#34;runtime/trace\u0026#34; //\u0026lt;-- ADDED 4 5) 6 7 8 9func main() { 10 11trace.Start(os.Stdout) // \u0026lt;-- ADDED 12 13defer trace.Stop() // \u0026lt;-- ADDED 14 15 16 17docs := make([]string, 4000) 18 19for i := range docs { 20 21docs[i] = fmt.Sprintf(\u0026#34;newsfeed-%.4d.xml\u0026#34;, i) 22 23} 24 25 26 27topic := \u0026#34;president\u0026#34; 28 29n := freq(topic, docs) 30 31log.Printf(\u0026#34;Search %d files, found %s %d times.\u0026#34;, len(docs), topic, n) 32 33} پس از افزودن بسته trace به importها، می توانیم از توابع trace.Start و Stop استفاده کنیم. نوشتن ردیابی در stdout گرفتن و تغییر مسیر داده های ردیابی به یک فایل را ساده می کند. حالا می توانم دوباره برنامه را اجرا کنیم.\n1$ go build 2 3 4 5$ time ./trace \u0026gt; t.out 6 72021/05/12 11:57:06 Search 4000 files, found president 28000 times. 8 9./trace \u0026gt; t.out 2.71s user 0.19s system 102% cpu 2.827 total 10 11 12 13$ time ./trace \u0026gt; t.out 14 152021/05/12 11:57:11 Search 4000 files, found president 28000 times. 16 17./trace \u0026gt; t.out 2.73s user 0.18s system 108% cpu 2.683 total 18 19 20 21$ ls -l 22 23total 9136 24 25-rw-r--r-- 1 bill staff 2108 Jan 4 08:16 README.md 26 27-rw-r--r-- 1 bill staff 25544 Jan 4 08:16 newsfeed.xml 28 29-rw-r--r-- 1 bill staff 1501618 May 12 11:57 t.out 30 31-rwxr-xr-x 1 bill staff 2470208 May 12 11:57 trace 32 33-rw-r--r-- 1 bill staff 8135 May 12 11:56 trace.go ما همیشه برنامه را دو بار اجرا می کنیم تا مطمئن شوم دستگاه گرم شده است. اجرای دوم معمولا بهتر از اولین اجرا می شود و من می توانم 144 میلی ثانیه تفاوت بین این دو اجرا ببینم. همچنین می‌توانم ببینم که فایل t.out در فهرست، 1.5 مگ داده در طول 2.6 ثانیه زمان اجرا گرفته است.\n4.24.3 Generating Traces # برای بررسی ردیابی، باید از ابزار ردیابی استفاده کنم.\n1$ go tool trace t.out 2 3 4 52021/05/12 12:00:19 Parsing trace... 6 72021/05/12 12:00:19 Splitting trace... 8 92021/05/12 12:00:19 Opening browser. Trace viewer is listening on 10 11http://127.0.0.1:64321 پس از تجزیه و تقسیم فایل، یک برگه مرورگر با مجموعه ای از linkها باز می شود.\nحالا می‌خواهیم اولین link را انتخاب کنیم که یک رابط کاربری مبتنی بر Chrome را باز می‌کند که می‌تواند داده‌های ردیابی را ارائه دهد. این ابزار فقط در کروم کار می کند.\nتمام اطلاعاتی که ارائه می شود تا میکروثانیه زمان وقوع آن ثبت می شود. در سمت چپ، می توانیم دسته های مختلف اطلاعات نموداری را ببینم.\nدر هر زمان معین در ردیابی موارد زیر را داریم:\n● Goroutines: The number of Goroutines.\n● Heap: The amount of memory in-use on the heap.\n● Threads: The number of operating system threads.\n● GC: The start/end of each GC with details.\n● Syscalls: The start/end of any system call with details.\n● Procs: The activity on each logical processor.\nاولین کاری که باید انجام دهیم اندازه گیری مدت زمان اجرای برنامه بر اساس داده های ردیابی است. می‌توانیم این کار را با ابزار زمان بندی، که آخرین ابزار در toolbar است، انجام دهیم.\nاگرtimeline کل ردیابی را انتخاب کنیم، برابر 2.67 ثانیه خواهد بود که تقریباً به آنچه time command ارائه شده است نزدیک است. نکته بعدی که می‌خواهم بدانم این است که اندازه heap چقدر ثابت مانده است یا چقدر بزرگ‌تر شده است. برای این کار باید نمای نمودار را گسترش می دهیم و سپس از ابزار انتخاب (اولین ابزار در نوار ابزار) برای انتخاب قسمت بالای نمودار heap استفاده می کنبم.\nدو رنگ (یا سایه) وجود دارد که در نمودار heap نشان داده شده است. نارنجی (سایه تیره تر) میزان حافظه در حال استفاده روی heap را در هر میکروثانیه نشان می دهد. سبز (سایه روشن‌تر) نشان‌دهنده زمانی است که GC بعدی بر اساس زمانی که آن مقدار حافظه دوباره در heap مورد استفاده قرار می‌گیرد، راه‌اندازی می‌شود.\nبه همین دلیل است که وقتی ناحیه نارنجی به بالای منطقه سبز می رسد، یک خط در قسمت GC وجود دارد. هر خط نشان دهنده یک GC است که اتفاق افتاده است.\nاز آنجایی که ناحیه سبز در یک خط مستقیم ثابت برای کل اجرای برنامه است، می توانم هر نقطه نارنجی را برای دیدن حداکثر اندازه heap انتخاب کنیم. در این صورت اگر بخواهم در مورد این عدد وضوح بیشتری داشته باشم، می توانیم از GODEBUG استفاده کنیم و دوباره برنامه را اجرا کنیم.\n1$ time GODEBUG=gctrace=1 ./trace \u0026gt; t.out 2 3gc 1 @0.016s 0%: 0.020+0.29+0.024 ms clock, 0.32+0.18/0.12/0.12+0.39 ms cpu, 4 54-\u0026gt;4-\u0026gt;0 MB, 5 MB goal, 16 P 6 7gc 2 @0.029s 0%: 0.030+0.23+0.002 ms clock, 0.49+0.15/0.17/0.001+0.037 ms 8 9cpu, 4-\u0026gt;4-\u0026gt;0 MB, 5 MB goal, 16 P 10 11gc 3 @0.040s 0%: 0.033+0.26+0.019 ms clock, 0.52+0.15/0.15/0.059+0.31 ms 12 13cpu, 4-\u0026gt;4-\u0026gt;0 MB, 5 MB goal, 16 P 14 15. . . 16 17gc 273 @2.793s 0%: 0.043+0.46+0.040 ms clock, 0.70+0.24/0.18/0.25+0.65 ms 18 19cpu, 4-\u0026gt;4-\u0026gt;0 MB, 5 MB goal, 16 P 20 21gc 274 @2.804s 0%: 0.043+0.35+0.002 ms clock, 0.69+0.28/0.37/0.16+0.042 ms 22 23cpu, 4-\u0026gt;4-\u0026gt;0 MB, 5 MB goal, 16 P 24 25gc 275 @2.814s 0%: 0.032+0.28+0.017 ms clock, 0.52+0.20/0.26/0.026+0.28 ms 26 27cpu, 4-\u0026gt;4-\u0026gt;0 MB, 5 MB goal, 16 P 28 292021/05/12 15:17:24 Searching 4000 files, found president 28000 times. اینطور به نظر می‌رسد که ، heap در meg 4 نگهداری می شد و تمام memory گذرا بوده است زیرا هر GC منجر به صفر بودن تعداد مقادیر زنده می شد. دقیقاً همان چیزی است که در ردیابی می بینیم. چیزی که واقعاً به آن نیاز داریم اطلاعات بیشتری در مورد GC است. این در مورد 1 GC نیست، بلکه در مورد همه GCهایی است که باید انجام شوند. پس می توانیم این اطلاعات را با استفاده از ابزار انتخاب و دوبار کلیک کردن روی هر خط آبی GC بدست بیاورم.\nاین اعداد در تعیین میزان کار GC در اجرای برنامه مفید هستند. با این اعداد ما یک پایه برای عملکرد برنامه داریم. با اعداد پایه، هنوز پاسخی در مورد اینکه چگونه می توانم برنامه را سرعت بخشم، نداریم. شاید نگاه کردن به بخش بزرگتری از نمودار کمک کند؟\n![[Pasted image 20230619032144.png]]\nاگر به این بخش از ردیابی دقیق تر نگاه کنیم، می توانیم مشکل را ببینیم. این برنامه فقط از یک پردازنده منطقی در هر زمان معین برای اجرای کار برنامه استفاده می کند. با این حال GC بیشتر منابع استفاده می کند. اگر الگوریتم را به صورت همزمان و friendly برای استفاده از تمام هسته‌های موجود در دستگاه خود تغییر دهیم، شاید این باید به بهبود performance کمک کند.\n4.24.4 الگوی Fan-Out # یکی از الگوهای concurrency که می‌توانم استفاده کنیم، الگوی fan-out است. این الگو به ما اجازه می دهد تا یک الگوریتم همزمان با کمترین مقدار تغییر کد داشته باشم. ایده این الگو این است که برای هر فایلی که نیاز به پردازش دارد، یک گوروتین ایجاد می‌کند و به scheduler اجازه می‌دهد تمام Goroutine را مدیریت کند و آنها را در تمام پردازنده‌های منطقی زمان‌بندی کند. ما می توانیم همه این گوروتین ها را fan-out کنیم زیرا ترتیب کار مهم نیست. مهم این است که همه چیز درست انجام شود.\n1func freqConcurrent(topic string, docs []string) int { 2 3 4 5var found int 6 7g := len(docs) // \u0026lt;-- ADDED 8 9var wg sync.WaitGroup // \u0026lt;-- ADDED 10 11wg.Add(g) // \u0026lt;-- ADDED 12 13 14 15for _, doc := range docs { 16 17. . . 18 19} 20 21 22 23wg.Wait() //\u0026lt;-- ADDED 24 25return int 26 27} برای شروع، باید کدی اضافه کنیم که مطمئن شویم تا زمانی که کار کامل نشده است، تابع freq برنگردد. این به بهترین وجه با استفاده از WaitGroup پیاده سازی می شود. ما با شناسایی تعداد گوروتین هایی که باید ایجاد شوند شروع می کنیم، که با طول docs collection نشان داده می شود. سپس آن عدد را به WaitGroup اضافه می کنم و در پایان تابع منتظر می مانم تا WaitGroup دوباره به صفر برسد.\n1func freqConcurrent(topic string, docs []string) int { 2 3 4 5var found int 6 7 8 9g := len(docs) 10 11var wg sync.WaitGroup 12 13wg.Add(g) 14 15for _, doc := range docs { 16 17go func(doc string) { // \u0026lt;-- ADDED 18 19defer wg.Done() // \u0026lt;-- ADDED 20 21. . . 22 23}(doc) // \u0026lt;-- ADDED 24 25} 26 27 28 29 30wg.Wait() 31 32return int 33 34} برای شروع، باید کدی اضافه کنیم که مطمئن شود تا زمانی که کار کامل نشده است، تابع freq برنگردد. این به بهترین وجه با استفاده از WaitGroup پیاده سازی می شود. من با شناسایی تعداد گوروتین هایی که باید ایجاد شوند شروع می کنیم، که با طول مجموعه اسناد نشان داده می شود. سپس آن عدد را به WaitGroup اضافه می کنیم و در پایان تابع منتظر می مانم تا WaitGroup دوباره به صفر برسد.\nدر مرحله بعد، کد موجود را در داخل حلقه for range حول یک Goroutine می پیچیم، جایی که هر document تکرار شده به Goroutine جدید منتقل می شود تا از هرگونه اشکال بسته شدن جلوگیری شود. با وجود Goroutine، می‌توانیم کد WaitGroup را با اطمینان از اینکه هر Goroutine ()wg.Done را قبل از پایان آن فراخوانی می‌کند، نهایی کنیم. آخرین کاری که باید انجام دهیم این است که هنگام پردازش یک فایل، مقدار بازگشتی 0 را از تمام شرایط خطای داخل حلقه حذف کنیم. ممکن است فکر کنیم این کد آماده است زیرا تمام هماهنگی ها با WaitGroup در جای خود است، اما اگر این کد را با race detector اجرا کنیم چه اتفاقی می افتد؟\n1 2$ go build -race 3 4$ ./trace \u0026gt; t.out 5 6================== 7 8WARNING: DATA RACE 9 10Read at 0x00c000157548 by goroutine 21: 11 12main.freq.func1() 13 14/Users/bill/code/go/src/github.com/ardanlabs/gotraining/topics/go/ 15 16profiling/trace/trace.go:103 +0x644 17 18Previous write at 0x00c000157548 by goroutine 66: 19 20main.freq.func1() 21 22/Users/bill/code/go/src/github.com/ardanlabs/gotraining/topics/go/ 23 24profiling/trace/trace.go:103 +0x65d 25 26. . . 27 28================== دو خط اول در خروجی می گوید که یک خواندن و یک نوشتن قبلی در همان محل حافظه در همان خط کد در داخل تابع تحت اللفظی وجود دارد. با این وجود در خط 103 چه کدی وجود دارد؟\n196 for _, item := range d.Channel.Items { 2 397 if strings.Contains(item.Title, topic) { 4 598 found++ 6 799 continue 8 9100 } 10 11101 12 13102 if strings.Contains(item.Description, topic) { 14 15103 found++ 16 17104 } 18 19105 } اگر شماره خطوط را به کد اضافه کنیم، می توانیم ببیینم که مورد مربوط به افزایش متغیر پیدا شده است. این کد در واقع دوباره در خط 98 استفاده می شود، بنابراین هر دو خط کد (98، 103) حاوی یک data race است. برای رفع این data race، باید افزایش متغیر پیدا شده را برای استفاده از یک atomic instruction. تغییر دهیم. برای این کار می توانم از atomic package استفاده کنم.\n196 for _, item := range d.Channel.Items { 2 397 if strings.Contains(item.Title, topic) { 4 598 atomic.AddInt32(\u0026amp;found, 1) // \u0026lt;-- CHANGED 6 799 continue 8 9100 } 10 11101 12 13102 if strings.Contains(item.Description, topic) { 14 15103 atomic.AddInt32(\u0026amp;found, 1) // \u0026lt;-- CHANGED 16 17104 } 18 19105 } ما خطوط 98 و 103 را برای استفاده از تابع atomic.AddInt32 جایگزین کردم. مشکل این است که این تابع به int32 نیاز دارد نه int، بنابراین باید دو تغییر دیگر انجام دهم.\n1func freq(topic string, docs []string) int { 2 3var found int32 // \u0026lt;-- CHANGED 4 5. . . 6 7wg.Wait() 8 9return int(found) // \u0026lt;-- CHANGED 10 11} این تغییرات برای استفاده از تابع atomic.AddInt32 و بازگرداندن یک عدد صحیح ضروری است. با این تغییرات، data race از بین خواهد رفت. با این حال، هنوز مشکل دیگری در مورد کد وجود دارد. اینکه آنقدرها هم که می‌توانست با حافظه پنهان سازگار نباشد.\n4.24.5 Cache Friendly # در حال تکمیل \u0026hellip;\n"},{"id":72,"href":"/chapter-4/profiling/","title":"4.25 آموزش profiling","section":"فصل چهارم: مباحث پیشرفته","content":"پروفایلینگ یک تکنیک مفید برای شناسایی گلوگاه‌های عملکرد ، بررسی مصرف حافظه و به دست آوردن بینش درباره سربار جمع‌آوری زباله (Garbage Collection) و موارد دیگر است. اکوسیستم Go ابزارهای فوق‌العاده‌ای برای این منظور ارائه می‌دهد. امکان فعال و غیرفعال کردن پروفایلینگ به ویژه هنگام رفع اشکال در یک برنامه CLI نوشته شده با Go بسیار مفید است.\nنقل و قول نویسنده:\nشاید profiling برای حال حاضر قابل اهمیت نباشد اما روزی خواهد رسید که در بخش هایی از پروژه دچار مصرف بیش از حد memory, CPU خواهید شد و اینجاس که profiling به شما کمک خواهد کرد سریز منابع را پیدا کنید.\nسعی کنید این مطلب را یاد بگیرید قطعا یک روزی با این موضوع مواجه خواهید شد.\nچه زمانی پروفایل کنیم؟\nموارد استفاده رایج پروفایلینگ عبارتند از:\nکشف گلوگاه‌های عملکرد و رفع آن‌ها برای بهبود عملکرد کلی یافتن تخصیص‌های اضافی حافظه و کاهش آن‌ها به منظور کاهش تاثیر منفی Garbage Collection بر عملکرد. سرریز یا نشت حافظه یا CPU در بلند مدت (نشت منابع وقتی مشخص می شود که سرویس شما برای مدت طولانی چند روز در حال اجرا باشد.) 4.25.1 مدل ذهنی (mental) برای Go # ممکن است بتوانید در نوشتن کد Go به مهارت بالایی برسید بدون اینکه درک دقیقی از نحوه عملکرد این زبان در پشت صحنه داشته باشید. اما وقتی به عملکرد و اشکال‌زدایی می‌رسیم، داشتن یک مدل ذهنی از جزئیات داخلی زبان به شدت به نفع شما خواهد بود. بنابراین، ابتدا یک مدل ابتدایی از Go را شرح می‌دهیم. این مدل به اندازه کافی خوب است که به شما کمک کند از اشتباهات رایج اجتناب کنید، اما تمامی مدل‌ها محدودیت دارند، بنابراین توصیه می‌شود که برای حل مشکلات پیچیده‌تر در آینده، به منابع تخصصی‌تر مراجعه کنید.\nوظیفه اصلی Go، مشابه یک سیستم‌عامل، این است که منابع سخت‌افزاری را چندوظیفه‌ای و انتزاعی کند. این کار عمدتاً با استفاده از دو انتزاع اصلی انجام می‌شود:\nزمان‌بند Goroutine: مدیریت نحوه اجرای کد شما بر روی پردازنده‌های سیستم. جمع‌آوری زباله (Garbage Collector): حافظه مجازی را فراهم می‌کند که به طور خودکار در صورت نیاز آزاد می‌شود. 4.25.1.1 زمان‌بند (scheduler) گوروتین # ابتدا با استفاده از مثال زیر در مورد زمان‌بند صحبت کنیم:\n1func main() { 2 res, err := http.Get(\u0026#34;https://example.org/\u0026#34;) 3 if err != nil { 4 panic(err) 5 } 6 fmt.Printf(\u0026#34;%d\\n\u0026#34;, res.StatusCode) 7} در اینجا یک goroutine واحد داریم که آن را G1 می‌نامیم و این goroutine تابع main را اجرا می‌کند. تصویر زیر یک خط زمانی ساده‌شده از نحوه اجرای این goroutine روی یک پردازنده را نشان می‌دهد. ابتدا G1 بر روی پردازنده اجرا می‌شود تا درخواست HTTP را آماده کند. سپس پردازنده بیکار می‌شود زیرا goroutine باید منتظر شبکه بماند. در نهایت، goroutine دوباره روی پردازنده زمان‌بندی می‌شود تا کد وضعیت را چاپ کند.\nاز دیدگاه زمان‌بند، برنامه بالا به این صورت اجرا می‌شود. ابتدا G1 در حال اجرا روی پردازنده 1 است. سپس goroutine از پردازنده خارج می‌شود و در حال انتظار برای شبکه قرار می‌گیرد. زمانی که زمان‌بند متوجه می‌شود شبکه پاسخ داده است (با استفاده از ورودی/خروجی غیرمسدودکننده، مشابه Node.js) گوروتین را به عنوان \u0026quot; آماده اجرا \u0026quot; علامت‌گذاری می‌کند. و به محض اینکه یک هسته پردازنده آزاد شود، goroutine دوباره شروع به اجرا می‌کند. در مثال ما تمام هسته‌ها در دسترس هستند، بنابراین G1 بلافاصله بدون صرف زمانی در حالت \u0026ldquo;آماده اجرا\u0026rdquo; می‌تواند به اجرای تابع fmt.Printf() بر روی یکی از پردازنده‌ها برگردد.\nدر اکثر مواقع، برنامه‌های Go چندین goroutine را به طور همزمان اجرا می‌کنند، بنابراین تعدادی از goroutineها در حال اجرای روی برخی از هسته‌های پردازنده هستند، تعداد زیادی از goroutineها به دلایل مختلف در حالت \u0026ldquo;انتظار\u0026rdquo; قرار دارند، و ایده‌آل این است که هیچ goroutineی در حالت \u0026ldquo;آماده اجرا\u0026rdquo; نباشد، مگر اینکه برنامه شما بار پردازشی بسیار بالایی بر روی پردازنده ایجاد کند. یک مثال از این حالت را می‌توان در زیر مشاهده کرد.\nالبته مدل بالا بسیاری از جزئیات را نادیده می‌گیرد. در واقعیت، زمان‌بند Go بر روی نخ‌هایی (threads) که توسط سیستم‌عامل مدیریت می‌شوند، کار می‌کند و حتی خود پردازنده‌ها نیز قادر به استفاده از هایپرتردینگ (hyper-threading) هستند که می‌توان آن را نوعی زمان‌بندی در نظر گرفت.\nبا این حال، مدل فوق باید برای درک بخش‌های باقی‌مانده از این راهنما کافی باشد. به طور خاص، باید روشن شود که زمان اندازه‌گیری‌شده توسط پروفایلرهای مختلف Go در اصل زمانی است که goroutineهای شما در حالت \u0026ldquo;اجرا\u0026rdquo; (Executing) و \u0026ldquo;انتظار\u0026rdquo; (Waiting) صرف می‌کنند، همان‌طور که در نمودار زیر نشان داده شده است.\n4.25.1.2 زباله جمع کن (Garbage Collector) # دیگر انتزاع مهم در Go، جمع‌آوری زباله (Garbage Collector) است. در زبان‌هایی مانند C، برنامه‌نویس باید به صورت دستی تخصیص و آزادسازی حافظه را با استفاده از malloc() و free() مدیریت کند. این رویکرد کنترل خوبی ارائه می‌دهد، اما در عمل بسیار مستعد خطا است. یک جمع‌آوری‌کننده زباله (GC) می‌تواند این بار را کاهش دهد، اما مدیریت خودکار حافظه ممکن است به راحتی به یک گلوگاه عملکرد تبدیل شود. این بخش از راهنما یک مدل ساده برای GC در Go ارائه می‌دهد که برای شناسایی و بهینه‌سازی مشکلات مربوط به مدیریت حافظه مفید خواهد بود.\nبرای یک راهنمای جامع‌تر درباره GC در Go، به مستندات رسمی مراجعه کنید.\n4.25.1.2.1 پشته (Stack) # با اصول اولیه شروع کنیم. Go می‌تواند حافظه را در یکی از دو مکان تخصیص دهد: پشته یا هیپ. هر goroutine پشته خاص خود را دارد که یک ناحیه پیوسته از حافظه است. علاوه بر این، یک ناحیه بزرگ از حافظه وجود دارد که بین goroutineها به اشتراک گذاشته می‌شود و به آن هیپ می‌گویند. این حالت را می‌توان در تصویر زیر مشاهده کرد.\nوقتی یک تابع تابع دیگری را فراخوانی می‌کند، یک بخش مخصوص روی پشته به آن اختصاص داده می‌شود که به آن «فریم پشته» (stack frame) می‌گویند و می‌تواند برای قرار دادن متغیرهای محلی از آن استفاده کند. یک اشاره‌گر پشته (stack pointer) برای شناسایی محل آزاد بعدی در فریم استفاده می‌شود. زمانی که یک تابع به پایان می‌رسد، داده‌های فریم قبلی به سادگی با بازگرداندن اشاره‌گر پشته به انتهای فریم قبلی حذف می‌شوند. داده‌های فریم همچنان می‌توانند در پشته باقی بمانند و با فراخوانی بعدی تابع بازنویسی شوند. این فرآیند بسیار ساده و کارآمد است زیرا Go نیازی به پیگیری هر متغیر ندارد.\n1func main() { 2\tsum := 0 3\tsum = add(23, 42) 4\tfmt.Println(sum) 5} 6 7func add(a, b int) int { 8\treturn a + b 9} برای درک بهتر این موضوع، به مثال زیر توجه کنید:\nدر اینجا یک تابع main() داریم که با رزرو مقداری فضا روی پشته برای متغیر sum شروع می‌شود. وقتی تابع add() فراخوانی می‌شود، یک فریم مخصوص برای نگه داشتن پارامترهای محلی a و b به آن اختصاص داده می‌شود. پس از اتمام اجرای add()، داده‌های آن با بازگرداندن اشاره‌گر پشته به انتهای فریم تابع main() حذف می‌شوند و متغیر sum با نتیجه به‌روز می‌شود. در همین حال، مقادیر قدیمی تابع add() فراتر از اشاره‌گر پشته باقی می‌مانند تا با فراخوانی بعدی تابع بازنویسی شوند. در زیر یک تصویرسازی از این فرآیند آمده است:\nمثال بالا به شدت ساده شده است و بسیاری از جزئیات مانند مقادیر بازگشتی، اشاره‌گرهای فریم، آدرس‌های بازگشت و درون‌خطی‌سازی (inlining) توابع را حذف کرده است. در واقع، از نسخه Go 1.17 به بعد، ممکن است برنامه بالا نیازی به فضای پشته نداشته باشد، زیرا مقدار کم داده می‌تواند توسط کامپایلر با استفاده از ثبات‌های پردازنده (CPU registers) مدیریت شود. اما این مسئله مشکلی ایجاد نمی‌کند. این مدل همچنان به شما یک شهود معقول از نحوه تخصیص و حذف متغیرهای محلی در برنامه‌های پیچیده‌تر Go روی پشته می‌دهد.\nشاید در این مرحله این سوال برای شما پیش بیاید که چه اتفاقی می‌افتد اگر فضای پشته تمام شود. در زبان‌هایی مانند C، این موضوع باعث خطای سرریز پشته (stack overflow) می‌شود. اما در Go، این مشکل به صورت خودکار با ایجاد یک نسخه کپی از پشته که دو برابر بزرگتر است، مدیریت می‌شود. این قابلیت به goroutineها اجازه می‌دهد که با پشته‌های بسیار کوچک، معمولاً 2 کیلوبایت، شروع کنند و یکی از عوامل اصلی مقیاس‌پذیری بیشتر goroutineها نسبت به نخ‌های سیستم‌عامل همین موضوع است.\n4.25.1.2.2 هیپ (Heap) # تخصیص‌های پشته عالی هستند، اما در بسیاری از موارد Go نمی‌تواند از آن‌ها استفاده کند. رایج‌ترین حالت زمانی است که باید اشاره‌گری به یک متغیر محلی از یک تابع بازگردانده شود. این موضوع را می‌توان در نسخه اصلاح‌شده مثال تابع add() که در بالا آمد، مشاهده کرد:\n1func main() { 2\tfmt.Println(*add(23, 42)) 3} 4 5func add(a, b int) *int { 6\tsum := a + b 7\treturn \u0026amp;sum 8} در حالت عادی، Go می‌تواند متغیر sum را داخل تابع add() روی پشته تخصیص دهد. اما همانطور که یاد گرفتیم، این داده‌ها هنگام بازگشت تابع add() از بین می‌روند. بنابراین، برای بازگرداندن ایمن یک اشاره‌گر به \u0026amp;sum، Go باید حافظه را از خارج از پشته تخصیص دهد. اینجا است که هیپ وارد عمل می‌شود.\nهیپ برای ذخیره‌سازی داده‌هایی استفاده می‌شود که ممکن است پس از پایان اجرای تابع سازنده، همچنان مورد نیاز باشند، همچنین برای هر داده‌ای که بین goroutineها با استفاده از اشاره‌گرها به اشتراک گذاشته می‌شود. اما این سوال پیش می‌آید که چگونه این حافظه آزاد می‌شود؟ چون برخلاف تخصیص‌های پشته، تخصیص‌های هیپ را نمی‌توان به محض اتمام تابعی که آن‌ها را ایجاد کرده، حذف کرد.\nGo این مشکل را با استفاده از جمع‌آوری زباله داخلی (GC) خود حل می‌کند. جزئیات پیاده‌سازی آن بسیار پیچیده است، اما از یک دید کلی، GC حافظه شما را به این شکل مدیریت می‌کند. در تصویر زیر می‌بینید که سه goroutine دارای اشاره‌گرهایی به تخصیص‌های سبز رنگ روی هیپ هستند. برخی از این تخصیص‌ها همچنین به تخصیص‌های سبز دیگری اشاره می‌کنند. علاوه بر این، تخصیص‌های خاکستری وجود دارند که ممکن است به تخصیص‌های سبز یا یکدیگر اشاره کنند، اما خودشان توسط تخصیص‌های سبز مرجع نشده‌اند. این تخصیص‌ها زمانی قابل دسترس بودند، اما اکنون به عنوان زباله در نظر گرفته می‌شوند. این اتفاق ممکن است زمانی رخ دهد که تابعی که اشاره‌گرهای آن‌ها را روی پشته ایجاد کرده بود بازگردد، یا مقدارشان بازنویسی شده باشد. وظیفه GC این است که به صورت خودکار این تخصیص‌ها را شناسایی و آزاد کند.\nاجرای جمع‌آوری زباله (GC) شامل پیمایش گراف‌های پرهزینه و تخلیه کش (cache thrashing) است. این فرایند حتی نیاز به فازهای متوقف‌کننده کل جهان (stop-the-world) دارد که اجرای کل برنامه شما را متوقف می‌کند. خوشبختانه نسخه‌های اخیر Go این زمان را به کسری از یک میلی‌ثانیه کاهش داده‌اند، اما بسیاری از هزینه‌های باقی‌مانده ذاتاً به هر GC مربوط می‌شود. در واقع، معمولاً ۲۰ تا ۳۰ درصد از اجرای یک برنامه Go صرف مدیریت حافظه می‌شود.\nبه‌طور کلی، هزینه GC متناسب با مقدار تخصیص‌های هیپ (heap allocations) است که برنامه شما انجام می‌دهد. بنابراین وقتی صحبت از بهینه‌سازی هزینه‌های مرتبط با حافظه می‌شود، شعار این است:\nکاهش (Reduce): سعی کنید تخصیص‌های هیپ را به تخصیص‌های پشته تبدیل کنید یا از آن‌ها به‌طور کلی اجتناب کنید. کاهش تعداد اشاره‌گرها در هیپ نیز کمک می‌کند. بازاستفاده (Reuse): تخصیص‌های هیپ را دوباره استفاده کنید به جای اینکه آن‌ها را با تخصیص‌های جدید جایگزین کنید. بازیافت (Recycle): برخی از تخصیص‌های هیپ غیرقابل اجتناب هستند. بگذارید GC آن‌ها را بازیافت کند و بر روی مسائل دیگر تمرکز کنید. همانند مدل ذهنی قبلی در این راهنما، همه موارد بالا نمایی به شدت ساده شده از واقعیت است. اما امیدوارم که این مدل به اندازه کافی مفید باشد تا باقی‌مانده این راهنما را درک کنید و شما را به مطالعه مقالات بیشتری در این زمینه ترغیب کند.\n4.25.2 درک عمیق پروفایلرهای (Profilers) گو # در اینجا مروری بر پروفایلرهای ساخته‌شده در زمان اجرای Go (Go runtime) ارائه می‌شود. برای جزئیات بیشتر، به لینک‌ها مراجعه کنید.\nدر زیر جدول مربوط به پروفایلرهای مختلف موجود در Go ارائه شده است:\nویژگی CPU Memory Block Mutex Goroutine ThreadCreate Production Safety ✅ ✅ ⚠ (1.) ✅ ⚠️ (2.) 🐞 (3.) نرخ ایمنی default default ❌ (1.) 100 1000 goroutines - دقت ⭐️⭐️ ⭐⭐⭐ ⭐⭐⭐ ⭐⭐⭐ ⭐⭐⭐ - عمق حداکثر پشته 64 32 32 32 32 - 100 (4.) - برچسب‌های پروفایلر ✅ ❌ ❌ ❌ ✅ - پروفایلر بلوک (block profiler): اگر به درستی پیکربندی نشده باشد، پروفایلر بلوک می‌تواند منبع قابل توجهی از بار CPU باشد. توقف‌های جهانی (stop-the-world): یک توقف جهانیO(N) وجود دارد که N تعداد goroutineها است. انتظار می‌رود هر goroutine بین ~1-10 میکروثانیه توقف داشته باشد. پروفایلر ThreadCreate: این پروفایلر به طور کامل معیوب است و بهتر است از آن استفاده نکنید. عمق حداکثر پشته: این مورد به API وابسته است. 4.25.2.1 پروفایلر CPU # پروفایلر CPU در Go می‌تواند به شما کمک کند تا قسمت‌هایی از کد خود را که زمان CPU زیادی مصرف می‌کنند، شناسایی کنید.\n⚠️ توجه داشته باشید که زمان CPU معمولاً با زمان واقعی که کاربران شما تجربه می‌کنند (که به آن تاخیر می‌گویند) متفاوت است. به عنوان مثال، یک درخواست HTTP معمولاً ممکن است ۱۰۰ میلی‌ثانیه طول بکشد، اما تنها ۵ میلی‌ثانیه از زمان CPU را مصرف کند و ۹۵ میلی‌ثانیه را در انتظار پاسخ از پایگاه داده بگذراند. همچنین ممکن است یک درخواست ۱۰۰ میلی‌ثانیه طول بکشد، اما ۲۰۰ میلی‌ثانیه از زمان CPU را صرف کند اگر دو goroutine به طور همزمان کارهای پردازشی سنگین انجام دهند. اگر این موضوع برای شما گیج‌کننده است.\nشما می‌توانید پروفایلر CPU را از طریق APIهای مختلف کنترل کنید:\ngo test -cpuprofile cpu.pprof: این دستور تست‌های شما را اجرا کرده و پروفایل CPU را در فایلی به نام cpu.pprof می‌نویسد.\npprof.StartCPUProfile(w): این دستور پروفایل CPU را به w ضبط می‌کند و زمان را تا زمانی که pprof.StopCPUProfile() فراخوانی شود، پوشش می‌دهد.\nimport _ \u0026quot;net/http/pprof\u0026quot;: این کد به شما اجازه می‌دهد با درخواست GET به آدرس /debug/pprof/profile?seconds=30 از سرور HTTP پیش‌فرض که می‌توانید با استفاده از http.ListenAndServe(\u0026quot;localhost:6060\u0026quot;, nil) راه‌اندازی کنید، یک پروفایل CPU به مدت ۳۰ ثانیه درخواست کنید.\nruntime.SetCPUProfileRate(): این تابع به شما اجازه می‌دهد نرخ نمونه‌گیری پروفایلر CPU را کنترل کنید. برای محدودیت‌های فعلی به محدودیت‌های پروفایلر CPU مراجعه کنید.\nruntime.SetCgoTraceback(): این تابع می‌تواند برای دریافت ردیابی‌های پشته به کد cgo استفاده شود. benesch/cgosymbolizer یک پیاده‌سازی برای Linux و macOS دارد.\nاگر به یک قطعه کد سریع نیاز دارید که بتوانید در تابع main() خود قرار دهید، می‌توانید از کد زیر استفاده کنید:\n1file, _ := os.Create(\u0026#34;./cpu.pprof\u0026#34;) 2pprof.StartCPUProfile(file) 3defer pprof.StopCPUProfile() صرف نظر از اینکه چگونه پروفایلر CPU را فعال می‌کنید، پروفایل به‌دست‌آمده در اصل یک جدول از ردیابی‌های پشته است که به فرمت باینری pprof قالب‌بندی شده است. در زیر نسخه‌ای ساده‌شده از چنین جدولی نشان داده شده است:\nstack trace samples/count cpu/nanoseconds main;foo 5 50000000 main;foo;bar 3 30000000 main;foobar 4 40000000 پروفایلر CPU این داده‌ها را با درخواست از سیستم‌عامل برای نظارت بر استفاده از CPU برنامه جمع‌آوری می‌کند و هر ۱۰ میلی‌ثانیه که CPU زمانی را مصرف می‌کند، سیگنال SIGPROF را به آن ارسال می‌کند. همچنین سیستم‌عامل زمان صرف‌شده توسط کرنل به نمایندگی از برنامه را در این نظارت شامل می‌کند. از آنجا که نرخ تحویل سیگنال به مصرف CPU وابسته است، این نرخ دینامیک بوده و می‌تواند به حداکثر N * 100Hz برسد که در آن N تعداد هسته‌های منطقی CPU در سیستم است.\nهنگامی که سیگنال SIGPROF دریافت می‌شود، هندلر سیگنال Go یک ردیابی پشته از goroutine فعالی که در حال حاضر در حال اجرا است، جمع‌آوری می‌کند و مقادیر مربوطه در پروفایل را افزایش می‌دهد. مقدار cpu/nanoseconds در حال حاضر مستقیماً از تعداد نمونه‌ها مشتق می‌شود، بنابراین این مقدار تکراری است، اما راحت است.\n4.25.2.1.1 برچسب‌های پروفایلر (Profiler Labels) CPU # یکی از ویژگی‌های جالب پروفایلر CPU در Go این است که می‌توانید جفت‌های کلید و مقدار دلخواهی را به یک goroutine متصل کنید. این برچسب‌ها توسط هر goroutine‌ای که از آن goroutine متولد می‌شود، به ارث برده می‌شوند و در پروفایل نهایی نمایش داده می‌شوند.\nبیایید مثالی را در نظر بگیریم که برخی از کارهای CPU را به نمایندگی از یک کاربر انجام می‌دهد. با استفاده از API های pprof.Labels() و pprof.Do()، می‌توانیم کاربر را با goroutine که در حال اجرای تابع work() است، مرتبط کنیم. علاوه بر این، برچسب‌ها به‌طور خودکار توسط هر goroutine‌ای که در همان بلوک کد متولد می‌شود، به ارث برده می‌شوند، برای مثال goroutine backgroundWork().\n1func work(ctx context.Context, user string) { 2\tlabels := pprof.Labels(\u0026#34;user\u0026#34;, user) 3\tpprof.Do(ctx, labels, func(_ context.Context) { 4\tgo backgroundWork() 5\tdirectWork() 6\t}) 7} پروفایل نهایی شامل یک ستون برچسب جدید خواهد بود و ممکن است به شکل زیر باشد:\nstack trace label samples/count cpu/nanoseconds main.backgroundWork user:bob 5 50000000 main.backgroundWork user:alice 2 20000000 main.work;main.directWork user:bob 4 40000000 main.work;main.directWork user:alice 3 30000000 مشاهده همان پروفایل با نمای گراف pprof نیز شامل برچسب‌ها خواهد بود:\nچگونگی استفاده از این برچسب‌ها به شما بستگی دارد. می‌توانید مواردی مانند شناسه‌های کاربری، شناسه‌های درخواست، نقاط پایانی HTTP، برنامه‌های اشتراک یا داده‌های دیگر را شامل کنید که به شما کمک می‌کند درک بهتری از اینکه کدام نوع درخواست‌ها باعث مصرف بالای CPU می‌شوند، حتی زمانی که توسط همان مسیرهای کد پردازش می‌شوند، به دست آورید. با این حال، استفاده از برچسب‌ها اندازه فایل‌های pprof شما را افزایش می‌دهد. بنابراین بهتر است با برچسب‌های با کاردینالیته پایین مانند نقاط پایانی شروع کنید و سپس به برچسب‌های با کاردینالیته بالا بروید، زمانی که احساس می‌کنید بر عملکرد برنامه شما تأثیر نمی‌گذارد.\n⚠️ نسخه‌های Go 1.17 و پایین‌تر حاوی چندین اشکال بودند که می‌توانستند منجر به عدم وجود برخی برچسب‌های پروفایلر در پروفایل‌های CPU شوند، برای اطلاعات بیشتر به محدودیت‌های پروفایلر CPU مراجعه کنید.\n4.25.2.1.2 مصرف CPU # از آنجایی که نرخ نمونه‌گیری پروفایلر CPU با توجه به مقدار CPU که برنامه شما مصرف می‌کند، تنظیم می‌شود، می‌توانید مصرف CPU را از پروفایل‌های CPU استخراج کنید. در واقع، pprof این کار را به طور خودکار برای شما انجام می‌دهد. به عنوان مثال، پروفایل زیر از برنامه‌ای استخراج شده است که دارای میانگین مصرف CPU برابر با 147.77% بود:\n1$ go tool pprof guide/cpu-utilization.pprof 2Type: cpu 3Time: Sep 9, 2021 at 11:34pm (CEST) 4Duration: 1.12s, Total samples = 1.65s (147.77%) 5Entering interactive mode (type \u0026#34;help\u0026#34; for commands, \u0026#34;o\u0026#34; for options) 6(pprof) روش دیگری که برای بیان مصرف CPU محبوب است، استفاده از هسته‌های CPU است. در مثال بالا، برنامه به‌طور میانگین از 1.47 هسته CPU در طول دوره پروفایل‌سازی استفاده می‌کرد.\n⚠️ در نسخه‌های Go 1.17 و پایین‌تر، نباید به این عدد به خصوص اگر نزدیک یا بیشتر از 250% باشد، اعتماد زیادی داشته باشید. با این حال، اگر عدد بسیار پایینی مانند 10% مشاهده کردید، معمولاً نشان‌دهنده این است که مصرف CPU برای برنامه شما مشکلی نیست. یک اشتباه رایج این است که به این عدد توجه نکرده و نگران یک تابع خاص باشید که زمان زیادی نسبت به بقیه پروفایل صرف می‌کند. این معمولاً وقت تلف کردن است، زمانی که مصرف کلی CPU پایین است، زیرا از بهینه‌سازی این تابع چندان سودی نخواهید برد.\n4.25.2.1.3 فراخوانی‌های سیستم در پروفایل‌های CPU # اگر در پروفایل‌های CPU خود فراخوانی‌های سیستمی مانند syscall.Read() یا syscall.Write() را مشاهده کردید که زمان زیادی را صرف می‌کنند، لطفاً توجه داشته باشید که این فقط زمان CPU صرف شده در داخل این توابع در هسته است. زمان I/O خود به‌طور جداگانه پیگیری نمی‌شود. صرف زمان زیادی در فراخوانی‌های سیستمی معمولاً نشانه‌ای از انجام بیش از حد آن‌ها است، بنابراین شاید افزایش اندازه بافرها بتواند کمک کند. برای موقعیت‌های پیچیده‌تر مانند این، باید استفاده از Linux perf را در نظر بگیرید، زیرا می‌تواند stack trace های هسته را نیز به شما نشان دهد که ممکن است سرنخ‌های اضافی برای شما فراهم کند.\n4.25.2.1.4 محدودیت‌های پروفایلر CPU # چندین مشکل و محدودیت شناخته‌شده برای پروفایلر CPU وجود دارد که ممکن است بخواهید از آن‌ها آگاه باشید:\n🐞 GH #35057: پروفایل‌های CPU که با نسخه‌های Go \u0026lt;= 1.17 گرفته شده‌اند، به‌طور نسبی برای برنامه‌هایی که از بیش از 2.5 هسته CPU استفاده می‌کنند، دقت کمتری دارند. به‌طور کلی، استفاده کلی از CPU به‌طور نادرست گزارش می‌شود و پیک‌های بارکاری ممکن است به‌درستی در پروفایل حاصل نمایان نشوند. این مشکل در Go 1.18 برطرف شده است. در عین حال، می‌توانید از Linux perf به‌عنوان یک راه‌حل موقت استفاده کنید.\n🐞 برچسب‌های پروفایلر در Go \u0026lt;= 1.17 از چندین باگ رنج می‌بردند.\nGH #48577 و CL 367200: برچسب‌ها برای goroutineهایی که بر روی استک سیستم، کد C را اجرا می‌کنند یا فراخوانی‌های سیستمی را انجام می‌دهند، گم شده بودند. CL 369741: اولین دسته از نمونه‌ها در یک پروفایل CPU دارای خطای off-by-one بودند که باعث نسبت‌گذاری نادرست برچسب‌ها می‌شد. CL 369983: سیستم goroutineهایی که به نمایندگی از goroutineهای کاربر ایجاد شده‌اند (مثلاً برای جمع‌آوری زباله) به‌طور نادرست برچسب‌های والدین خود را به ارث بردند. ⚠️️ می‌توانید از runtime.SetCPUProfileRate() برای تنظیم نرخ پروفایلر CPU قبل از فراخوانی runtime.StartCPUProfile() استفاده کنید. این عمل یک هشدار را چاپ می‌کند که می‌گوید runtime: cannot set cpu profile rate until previous profile has finished. با این حال، این عمل هنوز در چارچوب محدودیت‌های باگ ذکر شده عمل می‌کند. این مسئله ابتدا در اینجا مطرح شد و یک پیشنهاد پذیرفته شده برای بهبود API وجود دارد.\n⚠️ حداکثر تعداد فراخوانی‌های تو در توی تابعی که می‌تواند در stack trace ها توسط پروفایلر CPU ضبط شود، در حال حاضر 64 است. اگر برنامه شما از الگوهایی مانند بازگشت عمیق یا دیگر الگوهایی استفاده کند که به عمق استک بالایی منجر می‌شود، پروفایل CPU شما شامل stack trace هایی خواهد بود که برش داده شده‌اند. این به این معناست که شما بخشی از زنجیرهٔ فراخوانی که به تابعی که در زمان نمونه‌برداری فعال بود، منجر شده، را از دست خواهید داد.\n4.25.2.2 پروفایلر حافظه (Memory) # پروفایلر حافظه در Go می‌تواند به شما کمک کند تا شناسایی کنید کدام بخش‌های کد شما دارای تعداد زیادی تخصیصات حافظه در هیپ (heap) هستند و همچنین چند تا از این تخصیصات در آخرین جمع‌آوری زباله (garbage collection) هنوز در دسترس بودند. به همین دلیل، پروفایل تولید شده توسط پروفایلر حافظه معمولاً به‌عنوان پروفایل هیپ نیز شناخته می‌شود.\nمدیریت حافظه هیپ معمولاً مسئول حدود 20-30% از زمان CPU مصرفی توسط فرآیندهای Go است. علاوه بر این، حذف تخصیصات هیپ می‌تواند تأثیرات ثانویه‌ای داشته باشد که بخش‌های دیگر کد شما را به‌دلیل کاهش مقدار هدر رفت کش (cache thrashing) که در هنگام اسکن هیپ توسط جمع‌آورنده زباله (garbage collector) رخ می‌دهد، سریع‌تر می‌کند. به این معنی که بهینه‌سازی تخصیص‌های حافظه می‌تواند معمولاً بازگشت بهتری نسبت به بهینه‌سازی مسیرهای کد وابسته به CPU در برنامه شما داشته باشد.\n⚠️ پروفایلر حافظه تخصیصات استک را نشان نمی‌دهد زیرا این‌ها به‌طور کلی بسیار ارزان‌تر از تخصیصات هیپ هستند. برای اطلاعات بیشتر به بخش جمع‌آورنده زباله مراجعه کنید.\nشما می‌توانید پروفایلر حافظه را از طریق API های مختلف کنترل کنید:\ngo test -memprofile mem.pprof تست‌های شما را اجرا می‌کند و پروفایل حافظه را در فایلی به نام mem.pprof می‌نویسد. pprof.Lookup(\u0026quot;allocs\u0026quot;).WriteTo(w, 0) پروفایل حافظه‌ای که شامل رویدادهای تخصیص از زمان شروع فرآیند است را به w می‌نویسد. import _ \u0026quot;net/http/pprof\u0026quot; به شما امکان می‌دهد که یک پروفایل حافظه 30 ثانیه‌ای با فراخوانی GET /debug/pprof/allocs?seconds=30 از سرور HTTP پیش‌فرض که می‌توانید با http.ListenAndServe(\u0026quot;localhost:6060\u0026quot;, nil) راه‌اندازی کنید، درخواست کنید. این پروفایل به‌طور داخلی به عنوان پروفایل دلتا (delta profile) شناخته می‌شود. runtime.MemProfileRate به شما اجازه می‌دهد تا نرخ نمونه‌برداری پروفایلر حافظه را کنترل کنید. برای محدودیت‌های کنونی به محدودیت‌های پروفایلر حافظه مراجعه کنید. اگر به یک قطعه کد سریع نیاز دارید که بتوانید آن را به تابع main() خود اضافه کنید، می‌توانید از کد زیر استفاده کنید:\n1file, _ := os.Create(\u0026#34;./mem.pprof\u0026#34;) 2defer pprof.Lookup(\u0026#34;allocs\u0026#34;).WriteTo(file, 0) 3defer runtime.GC() صرف نظر از اینکه چگونه پروفایلر حافظه را فعال کنید، پروفایل حاصل اساساً یک جدول از ردیابی‌های پشته است که به فرمت باینری pprof فرمت‌بندی شده است. نسخه‌ای ساده‌شده از چنین جدولی در زیر نشان داده شده است:\nstack trace alloc_objects/count alloc_space/bytes inuse_objects/count inuse_space/bytes main;foo 5 120 2 48 main;foo;bar 3 768 0 0 main;foobar 4 512 1 128 یک پروفایل حافظه شامل دو بخش اصلی اطلاعات است:\nalloc_*: مقدار تخصیص‌هایی که برنامه شما از زمان شروع فرایند (یا دوره پروفایل‌گیری برای پروفایل‌های دلتا) انجام داده است. inuse_*: مقدار تخصیص‌هایی که برنامه شما انجام داده و در آخرین جمع‌آوری زباله (GC) همچنان قابل دسترسی بودند. شما می‌توانید از این اطلاعات برای مقاصد مختلف استفاده کنید. به عنوان مثال، می‌توانید از داده‌های alloc_* برای تعیین اینکه کدام مسیرهای کد ممکن است زباله زیادی تولید کنند که GC باید با آن برخورد کند، استفاده کنید. همچنین بررسی داده‌های inuse_* در طول زمان می‌تواند به شما در بررسی نشت حافظه یا استفاده بالای حافظه توسط برنامه‌تان کمک کند.\n4.25.2.2.1 تفاوت پروفایل‌های Allocations و Heap # تابع pprof.Lookup() و همچنین بسته [net/http/pprof](https://pkg.go.dev/net/http/pprof) پروفایل حافظه را تحت دو نام مختلف عرضه می‌کنند: allocs و heap. هر دو پروفایل شامل داده‌های یکسانی هستند، تنها تفاوت این است که پروفایل allocs به عنوان نوع نمونه پیش‌فرض alloc_space/bytes را دارد، در حالی که پروفایل heap به طور پیش‌فرض inuse_space/bytes را انتخاب می‌کند. این موضوع توسط ابزار pprof برای تصمیم‌گیری درباره نوع نمونه‌ای که باید به طور پیش‌فرض نشان داده شود، استفاده می‌شود.\n4.25.2.2.2 نمونه‌برداری (Sampling) پروفایل حافظه # برای حفظ بار کم، پروفایل حافظه از نمونه‌برداری پواسون استفاده می‌کند تا به طور متوسط فقط یک تخصیص از هر 512KiB باعث شود که یک ردیابی پشته گرفته شده و به پروفایل اضافه شود. با این حال، قبل از اینکه پروفایل به فایل نهایی pprof نوشته شود، زمان‌اجرا مقادیر نمونه جمع‌آوری شده را با تقسیم بر احتمال نمونه‌برداری مقیاس می‌دهد. این بدان معناست که مقدار تخصیص‌های گزارش شده باید تخمینی خوب از مقدار واقعی تخصیص‌ها باشد، صرف‌نظر از نرخ runtime.MemProfileRate که استفاده می‌کنید.\nبرای پروفایل‌گیری در محیط تولید، معمولاً نیازی به تغییر نرخ نمونه‌برداری نیست. تنها دلیلی که برای این کار وجود دارد، نگرانی درباره این است که در شرایطی که تخصیص‌های بسیار کمی انجام می‌شود، ممکن است تعداد کافی نمونه‌ها جمع‌آوری نشود.\n4.25.2.2.3 Memory Inuse در مقابل RSS # یک اشتباه رایج این است که مقدار کل حافظه گزارش‌شده توسط نوع نمونه inuse_space/bytes را با مقدار استفاده از حافظه RSS که توسط سیستم‌عامل گزارش می‌شود مقایسه کنید و متوجه شوید که این دو با هم مطابقت ندارند. دلایل مختلفی برای این عدم تطابق وجود دارد:\nبه‌طور تعریف شده، RSS شامل مواردی بیشتر از فقط استفاده از حافظه پشته Go است، مانند حافظه استفاده شده توسط پشته‌های گوروتین‌ها، فایل اجرایی برنامه، کتابخانه‌های مشترک و همچنین حافظه تخصیص یافته توسط توابع C. GC (جمع‌کننده زباله) ممکن است تصمیم بگیرد که حافظه آزاد را فوراً به سیستم‌عامل بازنگرداند، اما بعد از تغییرات زمان‌اجرا در Go 1.16 این موضوع کمتر مشکل‌ساز شده است. Go از GC غیرمتحرک استفاده می‌کند، بنابراین در برخی موارد، حافظه آزاد پشته ممکن است به گونه‌ای تکه‌تکه شود که مانع از بازگشت آن به سیستم‌عامل شود. 4.25.2.2.4 پیاده‌سازی پروفایلر حافظه # کد زیر باید جنبه‌های اساسی پیاده‌سازی پروفایلر حافظه را پوشش دهد تا شما درک بهتری از آن داشته باشید. همانطور که مشاهده می‌کنید، تابع malloc() در داخل زمان‌اجرای Go از تابع poisson_sample(size) برای تعیین این که آیا باید یک تخصیص نمونه‌گیری شود یا خیر استفاده می‌کند. اگر جواب مثبت باشد، یک دنباله پشته (stack trace) به نام s گرفته می‌شود و به عنوان کلید در mem_profile (یک نقشه هش) استفاده می‌شود تا شمارنده‌های allocs و alloc_bytes افزایش یابند. علاوه بر این، فراخوانی track_profiled(object, s)، شیء تخصیص یافته را به عنوان یک تخصیص نمونه‌گیری شده در پشته علامت‌گذاری می‌کند و دنباله پشته s را با آن مرتبط می‌سازد.\n1func malloc(size): 2 object = ... // allocation magic 3 4 if poisson_sample(size): 5 s = stacktrace() 6 mem_profile[s].allocs++ 7 mem_profile[s].alloc_bytes += size 8 track_profiled(object, s) 9 10 return object هنگامی که GC (جمع‌آوری زباله‌ها) تعیین می‌کند که زمان آزادسازی یک شیء تخصیص یافته فرا رسیده است، تابع sweep() را فراخوانی می‌کند که از is_profiled(object) استفاده می‌کند تا بررسی کند آیا شیء به عنوان یک شیء نمونه‌گیری شده علامت‌گذاری شده است یا خیر. اگر جواب مثبت باشد، دنباله پشته s که منجر به تخصیص شده بود بازیابی می‌شود و شمارنده‌های frees و free_bytes برای آن داخل mem_profile افزایش می‌یابد.\n1func sweep(object): 2 if is_profiled(object) 3 s = alloc_stacktrace(object) 4 mem_profile[s].frees++ 5 mem_profile[s].free_bytes += sizeof(object) 6 7\t// deallocation magic شمارنده‌های free_* به‌طور مستقیم در پروفایل نهایی حافظه گنجانده نمی‌شوند. در عوض، از آن‌ها برای محاسبه شمارنده‌های inuse_* در پروفایل از طریق کم کردن ساده‌ی frees از allocs استفاده می‌شود. همچنین، مقادیر خروجی نهایی با تقسیم آن‌ها بر احتمال نمونه‌گیری مقیاس‌بندی می‌شوند.\n4.25.2.2.5 محدودیت‌های پروفایلر حافظه # چندین مشکل و محدودیت شناخته‌شده برای پروفایلر حافظه وجود دارد که باید از آن‌ها آگاه باشید:\n🐞 GH #49171: پروفایل‌های دلتا (که با مثلاً GET /debug/pprof/allocs?seconds=60 گرفته می‌شوند) ممکن است به دلیل یک باگ در هم‌نمادسازی مرتبط با closures داخلی در Go 1.17 شمارش تخصیص منفی را گزارش کنند. این مشکل در Go 1.18 رفع شده است. ⚠️ runtime.MemProfileRate باید فقط یک بار و در اسرع وقت در ابتدای اجرای برنامه تغییر داده شود؛ برای مثال در ابتدای تابع main(). تغییر این مقدار به‌صورت چندباره در طول اجرای برنامه باعث تولید پروفایل‌های نادرست خواهد شد. ⚠ هنگام عیب‌یابی نشتی‌های حافظه احتمالی، پروفایلر حافظه می‌تواند نشان دهد که این تخصیص‌ها کجا ایجاد شده‌اند، اما نمی‌تواند نشان دهد که کدام مراجع باعث زنده نگه‌داشتن آن‌ها هستند. چندین تلاش برای حل این مشکل انجام شده است، اما هیچ‌کدام با نسخه‌های اخیر Go کار نمی‌کنند. ⚠ برچسب‌های پروفایلر CPU یا مشابه آن توسط پروفایلر حافظه پشتیبانی نمی‌شوند. اضافه کردن این ویژگی به پیاده‌سازی فعلی سخت است زیرا می‌تواند منجر به نشتی حافظه در جدول هش داخلی داده‌های پروفایل حافظه شود. ⚠ تخصیص‌های انجام شده توسط کد C (cgo) در پروفایل حافظه نمایش داده نمی‌شوند. ⚠ داده‌های پروفایل حافظه ممکن است تا دو چرخه‌ی جمع‌آوری زباله قدیمی باشند. اگر نیاز به یک عکس فوری مداوم دارید، می‌توانید قبل از درخواست پروفایل حافظه، runtime.GC() را فراخوانی کنید. net/http/pprof از آرگومان ?gc=1 برای این منظور پشتیبانی می‌کند. ⚠ حداکثر تعداد توابع تو در تو که توسط پروفایلر حافظه در اثر فراخوانی ثبت می‌شوند، در حال حاضر 32 است. برای اطلاعات بیشتر در مورد این محدودیت، به محدودیت‌های پروفایلر CPU مراجعه کنید. ⚠ هیچ محدودیتی برای اندازه‌ی جدول هش داخلی که پروفایل حافظه را نگه‌ می‌دارد وجود ندارد. این جدول تا زمانی که تمام مسیرهای تخصیص کد شما را پوشش دهد، بزرگ می‌شود. این مسئله در عمل مشکل‌ساز نیست اما ممکن است به‌نظر برسد که مانند یک نشتی حافظه کوچک است اگر از میزان استفاده حافظه فرآیند خود نظارت کنید. 4.25.2.3 پروفایلر بلاک # پروفایلر بلاک در Go اندازه‌گیری می‌کند که چقدر زمان گوروتین‌های شما در حالت Off-CPU صرف می‌شود، در حالی که منتظر عملیات کانال و mutexهای ارائه‌شده توسط پکیج sync هستند. عملیات‌های Go زیر توسط پروفایلر بلاک کنترل می‌شوند:\nselect chan send chan receive semacquire (مثل Mutex.Lock، RWMutex.RLock، RWMutex.Lock، WaitGroup.Wait) notifyListWait (مثل Cond.Wait) ⚠️ پروفایل‌های بلاک شامل زمان انتظار روی I/O، خواب (Sleep)، GC و سایر حالات انتظار نیستند. همچنین رویدادهای مسدود کننده تا زمانی که کامل نشوند ثبت نمی‌شوند، بنابراین پروفایل بلاک نمی‌تواند برای اشکال‌زدایی از اینکه چرا یک برنامه Go در حال حاضر قفل کرده استفاده شود. برای این منظور، از پروفایلر گوروتین می‌توان استفاده کرد.\n4.25.2.3.1 کنترل پروفایلر بلاک با API‌های مختلف: # دستور go test -blockprofile block.pprof تست‌ها را اجرا کرده و پروفایلی از هر رویداد مسدودکننده در فایلی به نام block.pprof ذخیره می‌کند. تابع runtime.SetBlockProfileRate(rate) به شما اجازه می‌دهد نرخ نمونه‌گیری پروفایلر بلاک را کنترل کنید. دستور pprof.Lookup(\u0026quot;block\u0026quot;).WriteTo(w, 0) پروفایلی از رویدادهای مسدودکننده از ابتدای فرآیند تا کنون ایجاد می‌کند و در خروجی w می‌نویسد. دستور import _ \u0026quot;net/http/pprof\u0026quot; اجازه می‌دهد تا با استفاده از درخواست GET /debug/pprof/block?seconds=30 یک پروفایل بلاک 30 ثانیه‌ای درخواست کنید. 4.25.2.3.2 کد نمونه برای استفاده از پروفایلر بلاک در برنامه: # 1runtime.SetBlockProfileRate(100_000_000) // هشدار: می‌تواند باعث افزایش استفاده از CPU شود 2file, _ := os.Create(\u0026#34;./block.pprof\u0026#34;) 3defer pprof.Lookup(\u0026#34;block\u0026#34;).WriteTo(file, 0) صرف‌نظر از نحوه فعال کردن پروفایلر بلاک، پروفایل نهایی یک جدول از ردپاهای پشته خواهد بود که در فرمت باینری pprof فرمت شده است.\nstack trace contentions/count delay/nanoseconds main;foo;runtime.selectgo 5 867549417 main;foo;bar;sync.(*Mutex).Lock 3 453510869 main;foobar;runtime.chanrecv1 4 5351086 4.25.2.3.3 پیاده‌سازی پروفایلر بلاک # کد شبه زیر جنبه‌های اساسی از پیاده‌سازی پروفایلر بلاک را نشان می‌دهد تا درک بهتری از آن به شما بدهد. هنگام ارسال پیام به یک کانال، یعنی ch \u0026lt;- msg، Go تابع chansend() را در runtime فراخوانی می‌کند. اگر کانال برای دریافت پیام آماده باشد (ready())، عملیات send() بلافاصله انجام می‌شود. در غیر این صورت، پروفایلر بلاک زمان شروع رویداد مسدودکننده را ثبت می‌کند و از تابع wait_until_ready() استفاده می‌کند تا گوروتین از CPU خارج شود تا زمانی که کانال آماده شود. هنگامی که کانال آماده شد، مدت زمان مسدود شدن تعیین می‌شود و با استفاده از تابع random_sample() و نرخ نمونه‌گیری، بررسی می‌شود که آیا باید این رویداد مسدودکننده ثبت شود یا خیر. در صورت مثبت بودن پاسخ، ردپای پشته فعلی (stack trace) گرفته شده و به عنوان کلید درون نقشه هش block_profile استفاده می‌شود تا شمارنده‌های count و delay افزایش یابند. پس از آن، عملیات send() ادامه می‌یابد.\n1func chansend(channel, msg): 2 if ready(channel): 3 send(channel, msg) 4 return 5 6 start = now() 7 wait_until_ready(channel) // Off-CPU Wait 8 duration = now() - start 9 10 if random_sample(duration, rate): 11 s = stacktrace() 12 // note: actual implementation is a bit trickier to correct for bias 13 block_profile[s].contentions += 1 14 block_profile[s].delay += duration 15 16 send(channel, msg) تابع random_sample به این صورت عمل می‌کند. اگر پروفایلر بلاک فعال باشد، همه رویدادهایی که duration \u0026gt;= rate باشند ثبت می‌شوند و رویدادهای کوتاه‌تر با احتمال duration/rate ثبت می‌شوند.\n1func random_sample(duration, rate): 2 if rate \u0026lt;= 0 || (duration \u0026lt; rate \u0026amp;\u0026amp; duration/rate \u0026gt; rand(0, 1)): 3 return false 4 return true به عبارت دیگر، اگر نرخ (rate) را برابر 10,000 تنظیم کنید (واحد در اینجا نانوثانیه است)، همه رویدادهای مسدودکننده‌ای که 10 µsec یا بیشتر طول می‌کشند ثبت می‌شوند. علاوه بر این، 10% از رویدادهای با طول 1 µsec و 1% از رویدادهای با طول 100 نانوثانیه و\u0026hellip; نیز ثبت می‌شوند.\n4.25.2.3.4 تفاوت پروفایلر بلاک و پروفایلر Mutex # هر دو پروفایلر بلاک و mutex زمان انتظار روی mutexها را گزارش می‌دهند. تفاوت این است که پروفایلر بلاک زمان انتظار برای به دست آوردن Lock() را ثبت می‌کند، در حالی که پروفایلر mutex زمانی که گوروتین دیگری منتظر Unlock() است تا اجرا شود را ثبت می‌کند.\n4.25.2.3.5 محدودیت‌های پروفایلر بلاک # 🚨 پروفایلر بلاک می‌تواند باعث افزایش قابل توجه مصرف CPU در محیط تولید شود. توصیه می‌شود که تنها برای توسعه و تست استفاده شود. اگر نیاز به استفاده از آن در محیط تولید دارید، با نرخ بسیار بالا شروع کنید، مثلاً 100 میلیون، و تنها در صورت نیاز آن را کاهش دهید. ⚠ پروفایل‌های بلاک تنها شامل زیر مجموعه کوچکی از حالات انتظار Off-CPU هستند که یک گوروتین می‌تواند وارد آن‌ها شود. ⚠ حداکثر تعداد توابع تو در تو که می‌توانند در ردپاهای پشته توسط پروفایلر بلاک ثبت شوند، فعلاً برابر 32 است. ⚠ نقشه هش داخلی که پروفایل بلاک را نگه می‌دارد هیچ محدودیتی در اندازه ندارد. 4.25.2.4 پروفایلر Mutex # پروفایلر mutex زمانی را اندازه‌گیری می‌کند که گوروتین‌ها صرف مسدود کردن سایر گوروتین‌ها می‌کنند. به عبارتی، این پروفایلر منابع رقابت برای قفل‌ها را ثبت می‌کند. پروفایلر mutex می‌تواند رقابت ناشی از sync.Mutex و sync.RWMutex را ثبت کند.\n⚠️ پروفایل‌های mutex شامل سایر منابع رقابت مثل sync.WaitGroup، sync.Cond یا دسترسی به توصیف‌کننده‌های فایل نمی‌شوند. همچنین، رقابت mutex تا زمانی که mutex آزاد نشود، ثبت نمی‌شود. بنابراین، پروفایل mutex برای اشکال‌زدایی از دلیل معلق بودن برنامه Go قابل استفاده نیست؛ برای این کار می‌توانید از پروفایلر گوروتین استفاده کنید.\n4.25.2.4.1 کنترل پروفایلر Mutex # چندین API برای کنترل پروفایلر mutex در دسترس است:\ngo test -mutexprofile mutex.pprof تست‌ها را اجرا می‌کند و پروفایل mutex را در یک فایل با نام mutex.pprof می‌نویسد. runtime.SetMutexProfileRate(rate) به شما امکان می‌دهد نرخ نمونه‌گیری پروفایلر mutex را فعال و کنترل کنید. اگر نرخ نمونه‌گیری برابر با R تنظیم شود، به طور متوسط 1/R از رویدادهای رقابت mutex ثبت می‌شوند. اگر نرخ برابر 0 یا کمتر باشد، هیچ رویدادی ثبت نمی‌شود. pprof.Lookup(\u0026quot;mutex\u0026quot;).WriteTo(w, 0) پروفایل mutex را از شروع پردازش تا زمان نوشتن به w ثبت می‌کند. import _ \u0026quot;net/http/pprof\u0026quot; به شما امکان می‌دهد با ارسال درخواست به مسیر GET /debug/pprof/mutex?seconds=30 یک پروفایل 30 ثانیه‌ای از mutex‌ها دریافت کنید. 4.25.2.4.2 نمونه سریع استفاده از پروفایلر Mutex # اگر نیاز به کد سریع برای قرار دادن در تابع main() دارید، می‌توانید از کد زیر استفاده کنید:\n1runtime.SetMutexProfileFraction(100) 2file, _ := os.Create(\u0026#34;./mutex.pprof\u0026#34;) 3defer pprof.Lookup(\u0026#34;mutex\u0026#34;).WriteTo(file, 0) پروفایل mutex به دست آمده در اصل جدولی از ردپای پشته‌ها (stack traces) خواهد بود که به صورت فرمت دودویی pprof ذخیره می‌شود.\nstack trace contentions/count delay/nanoseconds main;foo;sync.(*Mutex).Unlock 5 867549417 main;bar;baz;sync.(*Mutex).Unlock 3 453510869 main;foobar;sync.(*RWMutex).RUnlock 4 5351086 4.25.2.4.3 تفاوت پروفایل‌های Block و Mutex # پروفایل‌های block و mutex هر دو زمان انتظار روی mutex‌ها را ثبت می‌کنند، اما تفاوت در این است که پروفایل block زمانی که گوروتین در حال انتظار برای قفل شدن است را ثبت می‌کند، در حالی که پروفایل mutex زمانی که یک گوروتین قفل را در اختیار دارد و باعث جلوگیری از ادامه کار سایر گوروتین‌ها می‌شود، را ثبت می‌کند.\n4.25.2.4.4 پیاده‌سازی پروفایلر Mutex # پروفایلر mutex با ثبت زمانی که یک گوروتین تلاش می‌کند قفلی را بگیرد (مثلاً mu.Lock())، تا زمانی که گوروتین صاحب قفل آن را آزاد کند (مثلاً mu.Unlock())، کار می‌کند. ابتدا یک گوروتین semacquire() را برای گرفتن قفل فراخوانی می‌کند و اگر قفل در حال حاضر توسط گوروتین دیگری گرفته شده باشد، زمان شروع انتظار ثبت می‌شود. وقتی گوروتین صاحب قفل آن را با فراخوانی semrelease() آزاد می‌کند، گوروتین منتظر بررسی می‌شود و زمان انتظار آن محاسبه می‌گردد. در نهایت، اگر رویداد به صورت تصادفی برای ثبت انتخاب شود، زمان مسدودی به یک نقشه هش (hash map) اضافه می‌شود که کلید آن پشته فراخوانی گوروتین آزادکننده قفل است.\n4.25.2.4.5 محدودیت‌های پروفایلر Mutex # ⚠️ حداکثر تعداد فراخوانی‌های تو در تو که می‌توان در پشته فراخوانی‌های پروفایل mutex ثبت کرد، در حال حاضر 32 است. برای اطلاعات بیشتر درباره محدودیت‌های پروفایلر CPU، به مستندات مرتبط مراجعه کنید. ⚠️ هیچ محدودیتی برای اندازه نقشه هش داخلی که داده‌های پروفایل mutex را نگه می‌دارد وجود ندارد. این بدان معناست که اندازه آن تا زمانی که تمام مسیرهای مسدودکننده در کد شما پوشش داده شوند، رشد خواهد کرد. در عمل، این مشکل چندانی ایجاد نمی‌کند، اما ممکن است به عنوان یک نشت حافظه کوچک به نظر برسد. ⚠️ برچسب‌های پروفایلر CPU در پروفایل mutex پشتیبانی نمی‌شوند. اضافه کردن این ویژگی به پیاده‌سازی فعلی ممکن است باعث ایجاد نشت حافظه در نقشه هش داخلی که داده‌های پروفایل حافظه را نگه می‌دارد، شود. ⚠️ تعداد رقابت‌ها و زمان‌های تأخیر در یک پروفایل mutex بر اساس آخرین نرخ نمونه‌برداری تنظیم شده، تنظیم می‌شوند، نه در زمان نمونه‌برداری. در نتیجه، برنامه‌هایی که نرخ نمونه‌برداری پروفایل mutex را در میانه اجرای خود تغییر می‌دهند، ممکن است نتایج نادقیقی را مشاهده کنند. 4.25.2.5 پروفایلر Goroutine # در زمان اجرای Go، تمام گوروتین‌ها در یک آرایه ساده به نام allgs نگهداری می‌شوند. این آرایه شامل گوروتین‌های فعال و غیرفعال (مرده) است. گوروتین‌های مرده برای استفاده مجدد زمانی که گوروتین‌های جدید ایجاد می‌شوند، نگه داشته می‌شوند.\nGo دارای API‌های مختلفی برای بررسی گوروتین‌های فعال در allgs است که به همراه استک ترِیس و برخی دیگر از ویژگی‌های آنها اطلاعاتی ارائه می‌دهند. برخی از این API‌ها اطلاعات آماری ارائه می‌دهند، در حالی که برخی دیگر اطلاعات مربوط به هر گوروتین را به صورت جداگانه فراهم می‌کنند.\nعلیرغم تفاوت‌های بین این API‌ها، تعریف مشترک از گوروتین \u0026ldquo;فعال\u0026rdquo; به نظر می‌رسد که شامل موارد زیر باشد:\nگوروتین از بین رفته نباشد. گوروتین سیستمی یا گوروتین نهایی‌کننده نباشد. به عبارت دیگر، گوروتین‌هایی که در حال اجرا هستند و همچنین آنهایی که منتظر ورودی/خروجی (I/O)، قفل‌ها، کانال‌ها، برنامه‌ریزی و غیره هستند، همه به عنوان \u0026ldquo;فعال\u0026rdquo; در نظر گرفته می‌شوند، حتی اگر به نظر برسد که برخی از این حالت‌ها غیرفعال هستند.\n4.25.2.5.1 سربار (Overhead) # همه پروفایل‌گیری‌های گوروتین در Go نیاز به یک فاز متوقف‌سازی جهان (stop-the-world) به اندازه O(N) دارند، که در آن N تعداد گوروتین‌های تخصیص داده شده است. یک بنچمارک ساده نشان می‌دهد که جهان به طور تقریبی به ازای هر گوروتین حدود ~1µs متوقف می‌شود، وقتی از API runtime.GoroutineProfile() استفاده می‌شود. اما این مقدار ممکن است بسته به عواملی مانند عمق استک برنامه، تعداد گوروتین‌های مرده و غیره تغییر کند.\nبه طور کلی، برنامه‌هایی که بسیار حساس به تأخیر هستند و از هزاران گوروتین فعال استفاده می‌کنند، ممکن است بخواهند در پروفایل‌گیری گوروتین در محیط تولید با دقت بیشتری عمل کنند. با این حال، تعداد زیاد گوروتین‌ها و حتی شاید خود زبان Go ممکن است برای چنین برنامه‌هایی ایده‌ی مناسبی نباشد.\nبیشتر برنامه‌هایی که تعداد زیادی گوروتین ایجاد نمی‌کنند و می‌توانند چند میلی‌ثانیه تأخیر اضافی را تحمل کنند، نباید مشکلی با پروفایل‌گیری مستمر گوروتین در محیط تولید داشته باشند.\n4.25.2.5.2 ویژگی‌های گوروتین # گوروتین‌ها دارای بسیاری از ویژگی‌ها هستند که می‌توانند به اشکال‌زدایی برنامه‌های Go کمک کنند. موارد زیر جالب توجه هستند و به طرق مختلف از طریق API‌هایی که در ادامه این سند توضیح داده شده‌اند، در دسترس قرار دارند:\ngoid: شناسه‌ی یکتای گوروتین؛ گوروتین اصلی دارای شناسه 1 است. atomicstatus: وضعیت گوروتین، یکی از موارد زیر: idle: تازه تخصیص داده شده است. runnable: در صف اجرا، منتظر زمان‌بندی. running: در حال اجرا روی یک نخ (thread) سیستم‌عامل. syscall: مسدود شده در یک فراخوان سیستمی. waiting: توسط زمان‌بندی‌کننده متوقف شده، نگاه کنید به g.waitreason. dead: تازه خارج شده یا در حال دوباره‌سازی. copystack: استک در حال انتقال است. preempted: تازه از اجرا خودداری کرده است. waitreason: دلیلی که گوروتین در وضعیت waiting قرار دارد، مانند خواب، عملیات کانال، I/O، جمع‌آوری زباله (GC) و غیره. waitsince: زمان تقریبی که گوروتین وارد وضعیت waiting یا syscall شده است که توسط اولین GC بعد از شروع انتظار تعیین می‌شود. labels: مجموعه‌ای از کلید/مقدار برچسب‌های پروفایل‌گیر که می‌توانند به گوروتین‌ها متصل شوند. stack trace: تابعی که در حال اجراست و همچنین توابع فراخواننده آن. این به صورت خروجی متنی شامل نام فایل‌ها، نام توابع و شماره خطوط یا به صورت یک آرایه از آدرس‌های شمارنده برنامه (PCs) نمایش داده می‌شود. 🚧تحقیق بیشتر درباره این موضوع: آیا می‌توان متن تابع/فایل/خط را به PCs تبدیل کرد؟ gopc: آدرس شمارنده برنامه (PC) مربوط به فراخوانی go ... که باعث ایجاد این گوروتین شده است. این می‌تواند به فایل، نام تابع و شماره خط تبدیل شود. lockedm: نخی که این گوروتین به آن قفل شده است، در صورتی که وجود داشته باشد. 4.25.2.5.3 ماتریس ویژگی‌ها (Feature Matrix) # جدول ماتریس ویژگی‌های زیر به شما یک ایده کلی از دسترسی کنونی این ویژگی‌ها از طریق APIهای مختلف ارائه می‌دهد.\n4.25.2.5.4 APIها # runtime.Stack() / pprof.Lookup(debug=2)\nاین تابع خروجی متنی بدون ساختار بازمی‌گرداند که شامل استک (Stack) تمام گوروتین‌های فعال و ویژگی‌هایی که در ماتریس ویژگی‌ها ذکر شده است، می‌باشد.\nویژگی waitsince به عنوان nanotime() - gp.waitsince() بر حسب دقیقه نمایش داده می‌شود، اما تنها زمانی که مدت زمان بیش از 1 دقیقه باشد.\npprof.Lookup(debug=2) یک نام مستعار ساده‌شده برای استفاده از این پروفایل است. فراخوانی واقعی به این شکل است:\n1profile := pprof.Lookup(\u0026#34;goroutine\u0026#34;) 2profile.WriteTo(os.Stdout, 2) پیاده‌سازی پروفایل به سادگی runtime.Stack() را فراخوانی می‌کند.\nدر زیر مثالی کوتاه از خروجی بازگردانده شده آمده است.\n1goroutine 1 [running]: 2main.glob..func1(0x14e5940, 0xc0000aa7b0, 0xc000064eb0, 0x2) 3\t/Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:29 +0x6f 4main.writeProfiles(0x2, 0xc0000c4008, 0x1466424) 5\t/Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:106 +0x187 6main.main() 7\t/Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:152 +0x3d2 8 9goroutine 22 [sleep, 1 minutes]: 10time.Sleep(0x3b9aca00) 11\t/usr/local/Cellar/go/1.15.6/libexec/src/runtime/time.go:188 +0xbf 12main.shortSleepLoop() 13\t/Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:165 +0x2a 14created by main.indirectShortSleepLoop2 15\t/Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:185 +0x35 16 17goroutine 3 [IO wait, 1 minutes]: 18internal/poll.runtime_pollWait(0x1e91e88, 0x72, 0x0) 19\t/usr/local/Cellar/go/1.15.6/libexec/src/runtime/netpoll.go:222 +0x55 20internal/poll.(*pollDesc).wait(0xc00019e018, 0x72, 0x0, 0x0, 0x1465786) 21\t/usr/local/Cellar/go/1.15.6/libexec/src/internal/poll/fd_poll_runtime.go:87 +0x45 22internal/poll.(*pollDesc).waitRead(...) 23\t/usr/local/Cellar/go/1.15.6/libexec/src/internal/poll/fd_poll_runtime.go:92 24internal/poll.(*FD).Accept(0xc00019e000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0) 25\t/usr/local/Cellar/go/1.15.6/libexec/src/internal/poll/fd_unix.go:394 +0x1fc 26net.(*netFD).accept(0xc00019e000, 0x7d667d63cbbded3e, 0x1789ccbbded3e, 0x100000001) 27\t/usr/local/Cellar/go/1.15.6/libexec/src/net/fd_unix.go:172 +0x45 28net.(*TCPListener).accept(0xc000188060, 0x60006709, 0xc000196da8, 0x109abe6) 29\t/usr/local/Cellar/go/1.15.6/libexec/src/net/tcpsock_posix.go:139 +0x32 30net.(*TCPListener).Accept(0xc000188060, 0xc000196df8, 0x18, 0xc000001200, 0x12e9eec) 31\t/usr/local/Cellar/go/1.15.6/libexec/src/net/tcpsock.go:261 +0x65 32net/http.(*Server).Serve(0xc00019c000, 0x14ec6e0, 0xc000188060, 0x0, 0x0) 33\t/usr/local/Cellar/go/1.15.6/libexec/src/net/http/server.go:2937 +0x266 34net/http.(*Server).ListenAndServe(0xc00019c000, 0xc00019c000, 0x1475536) 35\t/usr/local/Cellar/go/1.15.6/libexec/src/net/http/server.go:2866 +0xb7 36net/http.ListenAndServe(...) 37\t/usr/local/Cellar/go/1.15.6/libexec/src/net/http/server.go:3120 38main.main.func1(0xc000032120) 39\t/Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:123 +0x126 40created by main.main 41\t/Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:121 +0xc5 42 43goroutine 4 [sleep, 1 minutes]: 44time.Sleep(0x3b9aca00) 45\t/usr/local/Cellar/go/1.15.6/libexec/src/runtime/time.go:188 +0xbf 46main.shortSleepLoop() 47\t/Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:165 +0x2a 48created by main.main 49\t/Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:130 +0x195 50 51goroutine 5 [sleep, 1 minutes]: 52time.Sleep(0x34630b8a000) 53\t/usr/local/Cellar/go/1.15.6/libexec/src/runtime/time.go:188 +0xbf 54main.sleepLoop(0x34630b8a000) 55\t/Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:171 +0x2b 56created by main.main 57\t/Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:131 +0x1bc 58 59goroutine 6 [chan receive, 1 minutes]: 60main.chanReceiveForever() 61\t/Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:177 +0x4d 62created by main.main 63\t/Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:132 +0x1d4 64 65goroutine 24 [select, 1 minutes]: 66net/http.(*persistConn).writeLoop(0xc0000cea20) 67\t/usr/local/Cellar/go/1.15.6/libexec/src/net/http/transport.go:2340 +0x11c 68created by net/http.(*Transport).dialConn 69\t/usr/local/Cellar/go/1.15.6/libexec/src/net/http/transport.go:1709 +0xcdc 70 71goroutine 23 [IO wait, 1 minutes]: 72internal/poll.runtime_pollWait(0x1e91da0, 0x72, 0x14e6ca0) 73\t/usr/local/Cellar/go/1.15.6/libexec/src/runtime/netpoll.go:222 +0x55 74internal/poll.(*pollDesc).wait(0xc00010e198, 0x72, 0x14e6c00, 0x16db878, 0x0) 75\t/usr/local/Cellar/go/1.15.6/libexec/src/internal/poll/fd_poll_runtime.go:87 +0x45 76internal/poll.(*pollDesc).waitRead(...) 77\t/usr/local/Cellar/go/1.15.6/libexec/src/internal/poll/fd_poll_runtime.go:92 78internal/poll.(*FD).Read(0xc00010e180, 0xc000256000, 0x1000, 0x1000, 0x0, 0x0, 0x0) 79\t/usr/local/Cellar/go/1.15.6/libexec/src/internal/poll/fd_unix.go:159 +0x1a5 80net.(*netFD).Read(0xc00010e180, 0xc000256000, 0x1000, 0x1000, 0x103b1dc, 0xc000199b58, 0x10680e0) 81\t/usr/local/Cellar/go/1.15.6/libexec/src/net/fd_posix.go:55 +0x4f 82net.(*conn).Read(0xc000010008, 0xc000256000, 0x1000, 0x1000, 0x0, 0x0, 0x0) 83\t/usr/local/Cellar/go/1.15.6/libexec/src/net/net.go:182 +0x8e 84net/http.(*persistConn).Read(0xc0000cea20, 0xc000256000, 0x1000, 0x1000, 0xc00009e300, 0xc000199c58, 0x10074b5) 85\t/usr/local/Cellar/go/1.15.6/libexec/src/net/http/transport.go:1887 +0x77 86bufio.(*Reader).fill(0xc0001801e0) 87\t/usr/local/Cellar/go/1.15.6/libexec/src/bufio/bufio.go:101 +0x105 88bufio.(*Reader).Peek(0xc0001801e0, 0x1, 0x0, 0x0, 0x1, 0x0, 0xc0001d0060) 89\t/usr/local/Cellar/go/1.15.6/libexec/src/bufio/bufio.go:139 +0x4f 90net/http.(*persistConn).readLoop(0xc0000cea20) 91\t/usr/local/Cellar/go/1.15.6/libexec/src/net/http/transport.go:2040 +0x1a8 92created by net/http.(*Transport).dialConn 93\t/usr/local/Cellar/go/1.15.6/libexec/src/net/http/transport.go:1708 +0xcb7 94 95goroutine 41 [IO wait, 1 minutes]: 96internal/poll.runtime_pollWait(0x1e91cb8, 0x72, 0x14e6ca0) 97\t/usr/local/Cellar/go/1.15.6/libexec/src/runtime/netpoll.go:222 +0x55 98internal/poll.(*pollDesc).wait(0xc00019e098, 0x72, 0x14e6c00, 0x16db878, 0x0) 99\t/usr/local/Cellar/go/1.15.6/libexec/src/internal/poll/fd_poll_runtime.go:87 +0x45 100internal/poll.(*pollDesc).waitRead(...) 101\t/usr/local/Cellar/go/1.15.6/libexec/src/internal/poll/fd_poll_runtime.go:92 102internal/poll.(*FD).Read(0xc00019e080, 0xc000326000, 0x1000, 0x1000, 0x0, 0x0, 0x0) 103\t/usr/local/Cellar/go/1.15.6/libexec/src/internal/poll/fd_unix.go:159 +0x1a5 104net.(*netFD).Read(0xc00019e080, 0xc000326000, 0x1000, 0x1000, 0x203000, 0x203000, 0x203000) 105\t/usr/local/Cellar/go/1.15.6/libexec/src/net/fd_posix.go:55 +0x4f 106net.(*conn).Read(0xc000186028, 0xc000326000, 0x1000, 0x1000, 0x0, 0x0, 0x0) 107\t/usr/local/Cellar/go/1.15.6/libexec/src/net/net.go:182 +0x8e 108net/http.(*connReader).Read(0xc00007c300, 0xc000326000, 0x1000, 0x1000, 0x100000006, 0x10, 0x1819408) 109\t/usr/local/Cellar/go/1.15.6/libexec/src/net/http/server.go:798 +0x1ad 110bufio.(*Reader).fill(0xc000290060) 111\t/usr/local/Cellar/go/1.15.6/libexec/src/bufio/bufio.go:101 +0x105 112bufio.(*Reader).ReadSlice(0xc000290060, 0xa, 0x1819408, 0xc000337988, 0x100f6d0, 0xc000110000, 0x100) 113\t/usr/local/Cellar/go/1.15.6/libexec/src/bufio/bufio.go:360 +0x3d 114bufio.(*Reader).ReadLine(0xc000290060, 0xc000110000, 0x1079694, 0xc0001a4000, 0x0, 0x1010038, 0x30) 115\t/usr/local/Cellar/go/1.15.6/libexec/src/bufio/bufio.go:389 +0x34 116net/textproto.(*Reader).readLineSlice(0xc000182300, 0xc000110000, 0x10d7c4d, 0xc00019e080, 0x1068000, 0xc000282900) 117\t/usr/local/Cellar/go/1.15.6/libexec/src/net/textproto/reader.go:58 +0x6c 118net/textproto.(*Reader).ReadLine(...) 119\t/usr/local/Cellar/go/1.15.6/libexec/src/net/textproto/reader.go:39 120net/http.readRequest(0xc000290060, 0x0, 0xc000110000, 0x0, 0x0) 121\t/usr/local/Cellar/go/1.15.6/libexec/src/net/http/request.go:1012 +0xaa 122net/http.(*conn).readRequest(0xc0000c6320, 0x14ed4a0, 0xc000322000, 0x0, 0x0, 0x0) 123\t/usr/local/Cellar/go/1.15.6/libexec/src/net/http/server.go:984 +0x19a 124net/http.(*conn).serve(0xc0000c6320, 0x14ed4a0, 0xc000322000) 125\t/usr/local/Cellar/go/1.15.6/libexec/src/net/http/server.go:1851 +0x705 126created by net/http.(*Server).Serve 127\t/usr/local/Cellar/go/1.15.6/libexec/src/net/http/server.go:2969 +0x36c pprof.Lookup(debug=1)\nاین روش پروفایل‌گیری مشابه pprof.Lookup(debug=2) فراخوانی می‌شود، اما داده‌های کاملاً متفاوتی تولید می‌کند:\nبه جای لیست کردن هر گوروتین به صورت جداگانه، گوروتین‌هایی با استک و برچسب‌های یکسان فقط یک بار همراه با تعداد آنها لیست می‌شوند. برچسب‌های pprof در این حالت گنجانده می‌شوند، در حالی که debug=2 آنها را شامل نمی‌شود. بیشتر ویژگی‌های دیگر گوروتین که در debug=2 وجود دارند، در اینجا وجود ندارند. فرمت خروجی همچنان به صورت متنی است، اما ظاهری بسیار متفاوت نسبت به debug=2 دارد. در زیر یک نمونه کوتاه از خروجی برگردانده شده آورده شده است.\n1goroutine profile: total 9 22 @ 0x103b125 0x106cd1f 0x13ac44a 0x106fd81 3# labels: {\u0026#34;test_label\u0026#34;:\u0026#34;test_value\u0026#34;} 4#\t0x106cd1e\ttime.Sleep+0xbe\t/usr/local/Cellar/go/1.15.6/libexec/src/runtime/time.go:188 5#\t0x13ac449\tmain.shortSleepLoop+0x29\t/Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:165 6 71 @ 0x103b125 0x10083ef 0x100802b 0x13ac4ed 0x106fd81 8# labels: {\u0026#34;test_label\u0026#34;:\u0026#34;test_value\u0026#34;} 9#\t0x13ac4ec\tmain.chanReceiveForever+0x4c\t/Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:177 10 111 @ 0x103b125 0x103425b 0x106a1d5 0x10d8185 0x10d91c5 0x10d91a3 0x11b8a8f 0x11cb72e 0x12df52d 0x11707c5 0x117151d 0x1171754 0x1263c2c 0x12d96ca 0x12d96f9 0x12e09ba 0x12e5085 0x106fd81 12#\t0x106a1d4\tinternal/poll.runtime_pollWait+0x54\t/usr/local/Cellar/go/1.15.6/libexec/src/runtime/netpoll.go:222 13#\t0x10d8184\tinternal/poll.(*pollDesc).wait+0x44\t/usr/local/Cellar/go/1.15.6/libexec/src/internal/poll/fd_poll_runtime.go:87 14#\t0x10d91c4\tinternal/poll.(*pollDesc).waitRead+0x1a4\t/usr/local/Cellar/go/1.15.6/libexec/src/internal/poll/fd_poll_runtime.go:92 15#\t0x10d91a2\tinternal/poll.(*FD).Read+0x182\t/usr/local/Cellar/go/1.15.6/libexec/src/internal/poll/fd_unix.go:159 16#\t0x11b8a8e\tnet.(*netFD).Read+0x4e\t/usr/local/Cellar/go/1.15.6/libexec/src/net/fd_posix.go:55 17#\t0x11cb72d\tnet.(*conn).Read+0x8d\t/usr/local/Cellar/go/1.15.6/libexec/src/net/net.go:182 18#\t0x12df52c\tnet/http.(*connReader).Read+0x1ac\t/usr/local/Cellar/go/1.15.6/libexec/src/net/http/server.go:798 19#\t0x11707c4\tbufio.(*Reader).fill+0x104\t/usr/local/Cellar/go/1.15.6/libexec/src/bufio/bufio.go:101 20#\t0x117151c\tbufio.(*Reader).ReadSlice+0x3c\t/usr/local/Cellar/go/1.15.6/libexec/src/bufio/bufio.go:360 21#\t0x1171753\tbufio.(*Reader).ReadLine+0x33\t/usr/local/Cellar/go/1.15.6/libexec/src/bufio/bufio.go:389 22#\t0x1263c2b\tnet/textproto.(*Reader).readLineSlice+0x6b\t/usr/local/Cellar/go/1.15.6/libexec/src/net/textproto/reader.go:58 23#\t0x12d96c9\tnet/textproto.(*Reader).ReadLine+0xa9\t/usr/local/Cellar/go/1.15.6/libexec/src/net/textproto/reader.go:39 24#\t0x12d96f8\tnet/http.readRequest+0xd8\t/usr/local/Cellar/go/1.15.6/libexec/src/net/http/request.go:1012 25#\t0x12e09b9\tnet/http.(*conn).readRequest+0x199\t/usr/local/Cellar/go/1.15.6/libexec/src/net/http/server.go:984 26#\t0x12e5084\tnet/http.(*conn).serve+0x704\t/usr/local/Cellar/go/1.15.6/libexec/src/net/http/server.go:1851 27 28... pprof.Lookup(debug=0)\nاین روش پروفایل‌گیری دقیقاً مانند pprof.Lookup(debug=1) فراخوانی می‌شود و همان داده‌ها را تولید می‌کند. تنها تفاوت این است که فرمت داده‌ها به صورت پروتکل بافر pprof است.\nدر زیر یک نمونه کوتاه از خروجی برگشتی که توسط go tool pprof -raw گزارش شده است آورده شده است.\n1PeriodType: goroutine count 2Period: 1 3Time: 2021-01-14 16:46:23.697667 +0100 CET 4Samples: 5goroutine/count 6 2: 1 2 3 7 test_label:[test_value] 8 1: 1 4 5 6 9 test_label:[test_value] 10 1: 1 7 8 9 10 11 12 13 14 15 16 17 18 19 20 11 1: 1 7 8 9 10 11 12 21 14 22 23 12 test_label:[test_value] 13 1: 1 7 8 9 24 25 26 27 28 29 30 14 1: 1 31 32 15 test_label:[test_value] 16 1: 1 2 33 17 test_label:[test_value] 18 1: 34 35 36 37 38 39 40 41 19 test_label:[test_value] 20Locations 21 1: 0x103b124 M=1 runtime.gopark /usr/local/Cellar/go/1.15.6/libexec/src/runtime/proc.go:306 s=0 22 2: 0x106cd1e M=1 time.Sleep /usr/local/Cellar/go/1.15.6/libexec/src/runtime/time.go:188 s=0 23 3: 0x13ac449 M=1 main.shortSleepLoop /Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:165 s=0 24 4: 0x10083ee M=1 runtime.chanrecv /usr/local/Cellar/go/1.15.6/libexec/src/runtime/chan.go:577 s=0 25 5: 0x100802a M=1 runtime.chanrecv1 /usr/local/Cellar/go/1.15.6/libexec/src/runtime/chan.go:439 s=0 26 6: 0x13ac4ec M=1 main.chanReceiveForever /Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:177 s=0 27... 28Mappings 291: 0x0/0x0/0x0 [FN] runtime.GoroutineProfile()\nاین تابع در واقع یک slice از تمام گوروتین‌های فعال و trace استک فعلی آنها را برمی‌گرداند. استک ترِیس‌ها به صورت آدرس‌های برنامه ارائه می‌شوند که می‌توان آنها را با استفاده از تابع runtime.CallersFrames() به نام‌های توابع ترجمه کرد.\nاین روش توسط fgprof برای پیاده‌سازی پروفایل‌گیری دیوار ساعت استفاده می‌شود.\nویژگی‌های زیر در حال حاضر در دسترس نیستند، اما ممکن است برای پیشنهاد به پروژه Go در آینده جالب باشند:\nشامل کردن ویژگی‌های گوروتین‌هایی که هنوز در دسترس نیستند، به خصوص برچسب‌ها. فیلتر کردن بر اساس برچسب‌های pprof، این کار می‌تواند stop-the-world را کاهش دهد، اما نیاز به نگهداری اضافی توسط runtime خواهد داشت. محدود کردن تعداد گوروتین‌های بازگشتی به یک زیرمجموعه تصادفی، که می‌تواند stop-the-world را کاهش دهد و ممکن است پیاده‌سازی آن نسبت به فیلتر بر اساس برچسب آسان‌تر باشد. در زیر یک مثال کوتاه از خروجی بازگشتی آورده شده است.\n1[ 2 { 3 \u0026#34;Stack0\u0026#34;: [ 4 20629256, 5 20629212, 6 20627047, 7 20628306, 8 17018153, 9 17235329, 10 ... 11 ] 12 }, 13 { 14 \u0026#34;Stack0\u0026#34;: [ 15 17019173, 16 17222943, 17 20628554, 18 17235329, 19 ... 20 ] 21 }, 22 ... 23] net/http/pprof\nاین پکیج پروفایل‌های توصیف‌شده در بخش pprof.Lookup(\u0026quot;goroutine\u0026quot;) را از طریق endpointهای HTTP فراهم می‌کند. خروجی دقیقاً همان چیزی است که در روش‌های دیگر دیده می‌شود.\n4.25.2.5.5 تاریخچه # پروفایل‌گیری گوروتین توسط Russ Cox پیاده‌سازی شد و برای اولین بار در نسخه weekly.2012-02-22 پیش از انتشار go1 ظاهر شد.\n4.25.2.6 پروفایلر ThreadCreate # 🐞 پروفایل threadcreate برای نمایش استک ترِیس‌هایی طراحی شده که منجر به ایجاد نخ‌های (threads) جدید سیستم‌عامل شده‌اند. با این حال، از سال ۲۰۱۳ خراب شده است، بنابراین بهتر است از آن دوری کنید.\n4.25.3 آموزش کار با ابزار go pprof # پروفایلرهای مختلف داخلی در Go برای کار با ابزار بصری‌سازی pprof طراحی شده‌اند. pprof خود یک پروژه غیررسمی از گوگل است که برای تحلیل داده‌های پروفایل‌گیری از برنامه‌های C++، Java و Go طراحی شده است. این پروژه یک فرمت پروتکل بافر را تعریف می‌کند که توسط تمام پروفایلرهای Go استفاده می‌شود و در این سند توضیح داده شده است.\nپروژه Go خود یک نسخه از pprof را به‌همراه دارد که می‌توان آن را از طریق دستور go tool pprof فراخوانی کرد. این ابزار تا حد زیادی با ابزار اصلی مشابه است، به‌جز چند تغییر جزئی. Go توصیه می‌کند که برای کار با پروفایل‌های Go همیشه از go tool pprof به‌جای ابزار اصلی استفاده شود.\n4.25.3.1 ویژگی‌ها # ابزار pprof دارای یک رابط خط فرمان تعاملی است، اما همچنین یک رابط کاربری وب و گزینه‌های مختلف فرمت خروجی دیگر نیز دارد.\n4.25.3.2 فرمت فایل # فرمت pprof در تعریف پروتکل بافر profile.proto تعریف شده است که شامل نظرات مفیدی است. علاوه بر این، یک README رسمی برای آن وجود دارد. فایل‌های pprof همیشه با فشرده‌سازی gzip در دیسک ذخیره می‌شوند.\nیک تصویر به اندازه هزار کلمه می‌ارزد، بنابراین در زیر یک تجسم خودکار تولید شده از این فرمت قرار داده شده است. لطفاً توجه داشته باشید که فیلدهایی مانند filename اشاره‌گرهایی به string_table هستند که در تجسم نشان داده نمی‌شوند و بهبودهای این حوزه خوش‌آمد است!\n4.25.3.3 فرمت داده‌های pprof # فرمت داده‌های pprof به نظر می‌رسد که برای کارایی، زبان‌های مختلف و انواع پروفایل‌های مختلف (CPU، Heap و غیره) طراحی شده است، اما به دلیل این موضوع، بسیار انتزاعی و پر از اشاره‌گری است. اگر می‌خواهید جزئیات کامل را مشاهده کنید، به لینک‌های بالا مراجعه کنید. اگر به دنبال خلاصه‌ای مختصر هستید، ادامه دهید:\nیک فایل pprof شامل فهرستی از پشته‌های تراشه است که به آن‌ها نمونه‌ها گفته می‌شود و یک یا چند مقدار عددی با آن‌ها مرتبط است. برای یک پروفایل CPU، مقدار ممکن است مدت زمان CPU در نانوثانیه باشد که پشته تراشه در طول پروفایل‌سازی مشاهده شده است. برای یک پروفایل Heap، ممکن است تعداد بایت‌های تخصیص‌یافته باشد. نوع‌های مقداری خود در ابتدای فایل توصیف شده و برای پر کردن فهرست \u0026ldquo;نمونه\u0026rdquo; در رابط کاربری pprof استفاده می‌شوند. علاوه بر مقادیر، هر پشته تراشه می‌تواند شامل مجموعه‌ای از برچسب‌ها نیز باشد. برچسب‌ها زوج‌های کلید-مقدار هستند و حتی می‌توانند شامل واحد نیز باشند. در Go، این برچسب‌ها برای برچسب‌های پروفایلر استفاده می‌شوند.\nاین پروفایل همچنین شامل زمان (در UTC) است که پروفایل ثبت شده و مدت زمان ضبط را نشان می‌دهد.\nعلاوه بر این، فرمت امکان استفاده از عبارات منظم drop/keep برای حذف یا شامل کردن برخی از پشته‌های تراشه را فراهم می‌کند، اما آن‌ها توسط Go استفاده نمی‌شوند. همچنین فضایی برای فهرستی از نظرات (توسط Go نیز استفاده نمی‌شود) و توصیف فاصله دوره‌ای که در آن نمونه‌ها گرفته شده‌اند وجود دارد.\nکد تولید خروجی pprof در Go در runtime/pprof/proto.go موجود است.\n4.25.3.4 رمزگشایی (Decoding) # در زیر تعدادی ابزار برای رمزگشایی فایل‌های pprof به خروجی متنی قابل خواندن انسان آورده شده است. آن‌ها بر اساس پیچیدگی فرمت خروجی خود مرتب شده‌اند، به طوری که ابزارهایی که خروجی ساده‌تری ارائه می‌دهند ابتدا فهرست شده‌اند:\n4.25.3.5 استفاده از pprofutils # pprofutils ابزاری کوچک برای تبدیل بین فایل‌های pprof و فرمت متنی جمع شده Brendan Gregg است (folded text). می‌توانید از آن به صورت زیر استفاده کنید:\n1$ pprof2text \u0026lt; examples/cpu/pprof.samples.cpu.001.pb.gz 2 3golang.org/x/sync/errgroup.(*Group).Go.func1;main.run.func2;main.computeSum 19 4golang.org/x/sync/errgroup.(*Group).Go.func1;main.run.func2;main.computeSum;runtime.asyncPreempt 5 5runtime.mcall;runtime.gopreempt_m;runtime.goschedImpl;runtime.schedule;runtime.findrunnable;runtime.stopm;runtime.notesleep;runtime.semasleep;runtime.pthread_cond_wait 1 6runtime.mcall;runtime.park_m;runtime.schedule;runtime.findrunnable;runtime.checkTimers;runtime.nanotime;runtime.nanotime1 1 7runtime.mcall;runtime.park_m;runtime.schedule;runtime.findrunnable;runtime.stopm;runtime.notesleep;runtime.semasleep;runtime.pthread_cond_wait 2 8runtime.mcall;runtime.park_m;runtime.resetForSleep;runtime.resettimer;runtime.modtimer;runtime.wakeNetPoller;runtime.netpollBreak;runtime.write;runtime.write1 7 9runtime.mstart;runtime.mstart1;runtime.sysmon;runtime.usleep 3 4.25.3.6 استفاده از go tool pprof # خود pprof دارای یک حالت خروجی به نام -raw است که محتوای یک فایل pprof را نمایش می‌دهد. با این حال، باید توجه داشت که این حالت آنچنان -raw نیست که می‌توان به آن رسید، به protoc زیر نگاه کنید:\n1$ go tool pprof -raw examples/cpu/pprof.samples.cpu.001.pb.gz 2 3PeriodType: cpu nanoseconds 4Period: 10000000 5Time: 2021-01-08 17:10:32.116825 +0100 CET 6Duration: 3.13 7Samples: 8samples/count cpu/nanoseconds 9 19 190000000: 1 2 3 10 5 50000000: 4 5 2 3 11 1 10000000: 6 7 8 9 10 11 12 13 14 12 1 10000000: 15 16 17 11 18 14 13 2 20000000: 6 7 8 9 10 11 18 14 14 7 70000000: 19 20 21 22 23 24 14 15 3 30000000: 25 26 27 28 16Locations 17 1: 0x1372f7f M=1 main.computeSum /Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/cpu/main.go:39 s=0 18 2: 0x13730f2 M=1 main.run.func2 /Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/cpu/main.go:31 s=0 19 3: 0x1372cf8 M=1 golang.org/x/sync/errgroup.(*Group).Go.func1 /Users/felix.geisendoerfer/go/pkg/mod/golang.org/x/sync@v0.0.0-20201207232520-09787c993a3a/errgroup/errgroup.go:57 s=0 20 ... 21Mappings 221: 0x0/0x0/0x0 [FN] 4.25.3.7 استفاده از protoc # برای کسانی که به دنبال دیدن داده‌ها نزدیک به ذخیره‌سازی باینری خام هستند، ما به کامپایلر پروتکل بافر protoc نیاز داریم. در macOS می‌توانید از brew install protobuf برای نصب آن استفاده کنید، برای سایر پلتفرم‌ها به بخش نصب README مراجعه کنید.\nحالا بیایید به همان پروفایل CPU از بالا نگاهی بیندازیم:\n1$ gzcat examples/cpu/pprof.samples.cpu.001.pb.gz | protoc --decode perftools.profiles.Profile ./profile.proto 2 3sample_type { 4 type: 1 5 unit: 2 6} 7sample_type { 8 type: 3 9 unit: 4 10} 11sample { 12 location_id: 1 13 location_id: 2 14 location_id: 3 15 value: 19 16 value: 190000000 17} 18sample { 19 location_id: 4 20 location_id: 5 21 location_id: 2 22 location_id: 3 23 value: 5 24 value: 50000000 25} 26... 27mapping { 28 id: 1 29 has_functions: true 30} 31location { 32 id: 1 33 mapping_id: 1 34 address: 20393855 35 line { 36 function_id: 1 37 line: 39 38 } 39} 40location { 41 id: 2 42 mapping_id: 1 43 address: 20394226 44 line { 45 function_id: 2 46 line: 31 47 } 48} 49... 50function { 51 id: 1 52 name: 5 53 system_name: 5 54 filename: 6 55} 56function { 57 id: 2 58 name: 7 59 system_name: 7 60 filename: 6 61} 62... 63string_table: \u0026#34;\u0026#34; 64string_table: \u0026#34;samples\u0026#34; 65string_table: \u0026#34;count\u0026#34; 66string_table: \u0026#34;cpu\u0026#34; 67string_table: \u0026#34;nanoseconds\u0026#34; 68string_table: \u0026#34;main.computeSum\u0026#34; 69string_table: \u0026#34;/Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/cpu/main.go\u0026#34; 70... 71time_nanos: 1610122232116825000 72duration_nanos: 3135113726 73period_type { 74 type: 3 75 unit: 4 76} 77period: 78 7910000000 این دستورات به ما این امکان را می‌دهند که ساختارهای ورودی و مقادیر خود را مشاهده کنیم، به ما کمک می‌کنند تا در نهایت فرمت را بهتر درک کنیم.\n4.25.3.8 استفاده از net/http/pprof پروفایلینگ ریموت # امکان دیباگ سرویس با استفاده از pprof برروی http.Server یا سایر وب سرورها. شما می توانید از پکیج net/http/pprof استفاده کنید اما دقت کنید ۲ مسئله وجود دارد باید در نظر بگیرید هنگام استفاده:\nزمانیکه این پکیج را در هر جایی از پروژه خود فراخوانی کنید تابع init() داخل پکیج اجرا می شود و خودکار به http.Handler سرور mux اضافه می شود و نیازی به ریجستر کردن handler نیست اما اگر web framework های دیگر را استفاده میکنید باید بصورت دستی استفاده کنید. امکان اینکه پکیج pprof قابلیت configuration شدن را داشته باشد ندارد و اطلاعات دیباگ خیلی حساس هستند اگر سرویس شما روی پروداکشن هست ممکن است اطلاعات حساسی بیرون درز دهد, به عنوان مثال debug/pprof/cmdline اطلاعات flag, switch هایی که سرویس شما اجرا شده است را نمایش می دهد و در صورتیکه فلگی داشته باشید شامل اطلاعات حساسی نظیر secret key, password و\u0026hellip; باشد دیده می شود. برای مورد دوم راه حلی داریم که می توانید جلو خودکار ریجستر شدن handler های pprof را بگیرید و موارد مورد نیاز را ریجستر کنید.\nبرای مورد دوم راه حلی داریم که می توانید جلو خودکار ریجستر شدن handler های pprof را بگیرید و موارد مورد نیاز را ریجستر کنید.\nبه نمونه کد زیر توجه کنید:\n1package main 2 3import ( 4 \u0026#34;flag\u0026#34; 5 \u0026#34;fmt\u0026#34; \u0026#34;github.com/PacViewer/synker/internal/logger\u0026#34; _ \u0026#34;go.uber.org/automaxprocs\u0026#34; 6 \u0026#34;net/http\u0026#34; \u0026#34;net/http/pprof\u0026#34;) 7 8var ( 9 pprofAddr *string 10) 11 12func init() { 13 pprofAddr = flag.String(\u0026#34;pprof-addr\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;start pprof on server\u0026#34;) 14 flag.Parse() 15 16 // init disables default pprof handlers registered by importing net/http/pprof. 17 // Your pprof is showing (https://mmcloughlin.com/posts/your-pprof-is-showing) 18 http.DefaultServeMux = http.NewServeMux() 19} 20 21func main() { 22 log := logger.DefaultLogger 23 24 if *pprofAddr != \u0026#34;\u0026#34; { 25 mux := http.NewServeMux() 26 mux.HandleFunc(\u0026#34;/debug/pprof/\u0026#34;, pprof.Index) 27 mux.HandleFunc(\u0026#34;/debug/pprof/profile\u0026#34;, pprof.Profile) 28 mux.HandleFunc(\u0026#34;/debug/pprof/symbol\u0026#34;, pprof.Symbol) 29 mux.HandleFunc(\u0026#34;/debug/pprof/trace\u0026#34;, pprof.Trace) 30 31 sv := \u0026amp;http.Server{ 32 Addr: *pprofAddr, 33 Handler: mux, 34 } 35 36 log.Info(\u0026#34;pprof listened\u0026#34;, \u0026#34;addr\u0026#34;, fmt.Sprintf(\u0026#34;http://%s/debug/pprof\u0026#34;, *pprofAddr)) 37 go func() { 38 if err := sv.ListenAndServe(); err != nil { 39 log.Fatal(\u0026#34;failed to listen pprof server\u0026#34;, \u0026#34;err\u0026#34;, err) 40 } 41 }() 42 } 43} پس از اینکه net/http/pprof را ریجستر کردید برروی سرور روی روت /debug/pprof در دسترس است.\n4.25.3.9 دستورات pprof # در زیر ما یکسری دستوارت کاربردی pprof را معرفی میکنیم که میتوانید بصورت visualization اطلاعات پروفایل را در لوکال یا ریموت ببینید.\n4.25.3.9.1 دیدن CPU Profile آنلاین روی لوکال # برای دیدن اطلاعات CPU Profile بصورت آنلاین روی لوکال دستور زیر را بزنید:\n1go tool pprof -http=:8081 http://localhost:8080/debug/pprof/profile 4.25.3.9.2 دیدن Memory Profile آنلاین روی لوکال # برای دیدن اطلاعات Memory Profile بصورت آنلاین روی لوکال دستور زیر را بزنید:\nدیدن allocation ها 1go tool pprof -http=:8081 http://localhost:8080/debug/pprof/allocs دیدن heap ها 1go tool pprof -http=:8081 http://localhost:8080/debug/pprof/heap برای دیدن در قالب flame graph می توانید به آدرس زیر برروید:\n1http://localhost:8082/ui/flamegraph 4.25.3.9.3 گرفتن خروجی pdf, png, svg # برای اینکه بتوانید از اطلاعات profiling خروجی فایل بگیرید دستور زیر را بزنید.\nPDF 1go tool pprof -pdf heap_profile.pprof SVG 1go tool pprof -svg heap_profile.pprof PNG 1go tool pprof -png heap_profile.pprof 4.25.3.9 نتیجه‌گیری # مدیریت کارآمد حافظه در Go، به همراه ابزارهای پروفایل‌سازی‌اش، به توسعه‌دهندگان پلتفرمی قوی برای ساخت برنامه‌های کارآمد ارائه می‌دهد. با درک رفتار حافظه در Go و پروفایل‌سازی منظم برنامه خود، می‌توانید اطمینان حاصل کنید که این برنامه حتی در بارهای سنگین نیز کارآمد و پاسخگو باقی می‌ماند.\n"},{"id":73,"href":"/chapter-5/","title":"فصل پنجم: برنامه نویسی شبکه با گو","section":"صفحه اصلی","content":"در این فصل به مباحث برنامه نویسی شبکه در زبان گو میپردازیم\u0026hellip;\n"},{"id":74,"href":"/chapter-5/network-basic/","title":"5.1 شبکه چیست","section":"فصل پنجم: برنامه نویسی شبکه با گو","content":"به تجهیزات متصل یکدیگر شبکه گفته می‌شود. مکانیزم‌های اتصال ممکن است از طریق سیم مسی، اترنت، فیبر نوری یا بی‌سیم. اندازه ی شبکه می تواند به اندازه ی اینترنت بزرگ یا به اندازه ی یک شبکه خانگی کوچک باشد. یک شبکه محلی (LAN) کامپیوترهایی را که در نزدیکی یکدیگر هستند، معمولاً تعلق به یک خانه، سازمان کوچک یا قسمتی از یک سازمان بزرگ دارند، به هم متصل می‌کند.\nیک شبکه گسترده (WAN) کامپیوترها را در یک منطقه فیزیکی بزرگتر، مانند بین شهرها متصل می‌کند. انواع دیگری هم وجود دارند، مانند MANs (شبکه‌های منطقه شهری)، PANs (شبکه‌های منطقه شخصی) و حتی BANs (شبکه‌های منطقه بدن).\nتفاوت‌های قابل توجهی بین یک اینترنت و یک اینترانت وجود دارد. معمولاً، یک اینترانت تحت کنترل مدیریت واحد قرار خواهد گرفت و یک مجموعه یکپارچه از سیاست‌ها را اعمال خواهد کرد. از طرفی، یک اینترنت تحت کنترل یک بدنه یکپارچه نخواهد بود و کنترل‌های انجام شده بر روی بخش‌های مختلف حتی سازگاری نخواهد داشت.\n5.1.1 چند تعریف و مفهوم کلی در شبکه # 5.1.1.1 پروتکل # پروتکل های شبکه مجموعه قواعد و روش هایی از پیش تعریف شده برای ارتباط دو کامپیوتر در یک شبکه هستند\n5.1.1.2 هسته (node) # هر دستگاه متصل به شبکه یک نود به حساب می آید.\n5.1.1.3 پروتکل اینترنت IP # پروتکل اینترنت یا (internet protocol) یک ادرس منحصر بفرد برای هر دستگاه متصل به اینترنت است هر ایپی (v4) شامل چهار بخش یا octet است که هر بخش را عددی بین ۰ تا ۲۵۵ تشکیل می دهد\n5.1.1.3.1 ایپی ورژن ۶ # زمان شروع و توسعه پروتکل اینترنت هر دستگاه در شبکه نیاز به یک شناسه منحصر به فرد داشت. ایپی ورژن ۴ تنها قابلیت ایجاد 4 بیلیون شناسه یونیک را داشتند (که بنظر برای تمام دستگاه های موجود کافی و مناسب بود) بعد از رشد چشم گیر اینترنت و دستگاه های متصل به اینترنت تعداد IP موجود حدودا کافی نبود ایپی ورژن ۶ جدید ترین نسخه ایپی است که شمال 8 octet است و از hexadecimal استفاده میکند. در نتیجه حدود 340 undecillion ایپی ورژن ۶ منحصر به فرد میتوان تولید کرد که برای عدد قابل توجهی دستگاه متصل به شبکه کافی است. مثال ایپی ورژن ۶: ‍‍2001:0db8:85a3:0000:0000:8a2e:0370:7334\n5.1.1.3.2 تفاوت ها # تفاوت های IPv4 and IPv6\nحافظه:\nورژن ۴: ‍‍32bit ورژن ۶:‍‍ ‍‍128bit نوع ایپی:\nورژن ۴ : ‍‍numeric dot-decimal ورژن ۶ : alphanumeric hexadecimal در نهایت گفتنی است که ورژن ۶ ایپی با استفاده از موارد امنیتی از جمله رمزنگاری و احراز هویت امنیت این پروتوکول را گسترش داده است.\n5.1.2 لایه های پروتکل # سیستم‌های توزیع شده دشوار هستند. چندین کامپیوتر درگیر هستند که باید به یکدیگر متصل شوند. برنامه‌ها برای اجرا بر روی هر کامپیوتر در سیستم باید نوشته شوند و همه باید با همکاری یک وظیفه توزیع شده را انجام دهند. روش رایج برای مقابله با پیچیدگی، تجزیه آن به بخش‌های کوچکتر و ساده‌تر است. این بخش‌ها ساختار خود را دارند، اما همچنین وسایل مشخصی برای ارتباط با بخش‌های مرتبط دیگر دارند. در سیستم‌های توزیع شده، بخش‌ها لایه پروتکل نامیده می‌شوند و وظایف دقیقی دارند. آن‌ها یک پشته را تشکیل می‌دهند، هر لایه با لایه بالایی و پایینی خود ارتباط برقرار می‌کند. ارتباط بین لایه‌ها توسط پروتکل‌ها تعریف می‌شود. ارتباطات شبکه نیازمند پروتکل‌هایی برای پوشش ارتباطات بالارونده بین برنامه‌های کاربردی تا ارتباطات سیم و پیچیدگی‌های پروتکلی در لایه‌های پروتکلی است.\n5.1.2.1 پروتکل ISO OSI # اگرچه هرگز به درستی پیاده‌سازی نشده است، پروتکل‌های OSI (اتصالات باز سیستم‌ها) تأثیر بزرگی در روش‌های گفتگو و طراحی سیستم‌های توزیع شده داشته‌اند. معمولاً آن‌ها به شکلی نشان داده می‌شوند که در شکل زیر نشان داده شده است.\nوظیفه هر لایه از پایین به بالا به شرح زیر است:\nلایه فیزیکی با استفاده از فناوری‌های الکتریکی، نوری یا رادیویی جریان بیت را منتقل می‌کند. لایه اتصال داده‌ها، بسته‌های اطلاعاتی را به فریم‌های شبکه تبدیل کرده و آن‌ها را برای انتقال از طریق لایه فیزیکی و بازگشت به بسته‌های اطلاعاتی آماده می‌کند. لایه شبکه فناوری‌های سوئیچینگ و روتینگ را فراهم می‌کند. لایه حمل و نقل انتقال شفاف داده بین سیستم‌های پایانی را فراهم می‌کند و مسئول بازیابی خطا در سراسر انتها به انتها و کنترل پایین است. لایه جلسه، ارتباطات بین برنامه‌ها را برقرار، مدیریت و پایان می‌دهد. لایه ارائه، استقلال را از تفاوت‌های در نمایش داده‌ها (مانند رمزگذاری) فراهم می‌کند. لایه برنامه، پردازش‌های برنامه و کاربران پایانی را پشتیبانی می‌کند. یک لایه در مدل OSI معمولاً با یک پروتکل مدرن نقش مشابهی دارد؛ به عنوان مثال، پروتکل IP از TCP/IP با لایه شبکه، همچنین شناخته شده به عنوان لایه 3 (لایه فیزیکی لایه 1) مرتبط است. لایه برنامه، یعنی لایه 7، با HTTP مرتبط است. برخی از پروتکل‌ها مانند HTTPS به نظر می‌رسد لایه‌ها را با هم تلفیق می‌کنند، 5 (جلسه) و 6 (ارائه). هیچ مدلی کامل نیست؛ جایگزین‌هایی برای مدل OSI وجود دارد که به واقعیت مشخصی نزدیکتر هستند، مانند مدل پروتکل TCP/IP.\n5.1.2.2 پروتکل TCP/IP # در حالی که مدل OSI در حال بحث و جدل، پیاده‌سازی جزئی، و جنگیدن بود، پروژه تحقیقاتی DARPA در اینترنت مشغول ساخت پروتکل‌های TCP/IP بود. این پروتکل‌ها بسیار موفق بوده و منجر به ایجاد اینترنت (با حروف بزرگ) شده است. این پشته بسیار ساده‌تر است، همانطور که در شکل زیر نشان داده شده است.\n5.1.2.3 پروتکل http # پروتکل http یکی از پرکابردترین و در دسترس ترین پروتکل های دنیا است. تا حدی که شما با یک کلیک و باز کردن مروگر خود به آن درسترسی دارید.\nHttp مخفف عبارت Hyper Text Transfer Protocol است که به معنی پروتکلی برای انتقال ابرمتن‌ها می‌باشد\nاین پروتکل به منظور ایجاد صفحات وب انتقال ابر متن ها توسط تیم برنزلی طراحی و پیاده سازی شد.\nپروتکل Http از Handshaking به منظور ارسال و دریافت اطلاعات استفاده می‌کند. در این روش برای شروع و پایان عملیات تبادل اطلاعات بین سرور و کاربر چندین درخواست و پاسخ جابه جا میشود.\n5.1.3 دروازه (Gateways) # یک دروازه (Gateway) یک عبارت کلی برای یک جسم است که برای اتصال دو یا چند شبکه استفاده می‌شود. یک تکرار کننده (Repeater) در سطح فیزیکی عمل کرده و اطلاعات را از یک زیرشبکه به دیگری کپی می‌کند. یک پل (Bridge) در سطح لایه داده‌ای عمل می‌کند و فریم‌ها را بین شبکه‌ها کپی می‌کند. یک مسیریاب (Router) در سطح شبکه عمل می‌کند و نه تنها اطلاعات را بین شبکه‌ها منتقل می‌کند، بلکه بر روی مسیر تصمیم می‌گیرد.\nدروازه یک نقطه واسط برای ارتباط بین دو شبکه است و معمولاً دروازه‌ها برای ارتباط بین شبکه‌های مختلفی با ساختار‌های مختلف استفاده می‌شوند. تکرار کننده اطلاعات را در سطح فیزیکی از یک شبکه به شبکه دیگر منتقل می‌کند. پل از طریق بررسی آدرس MAC در هر فریم، فریم‌ها را بین شبکه‌های مختلف انتقال می‌دهد. مسیریاب به عنوان یک دروازه هوشمند عمل می‌کند و برای انتقال بسته‌های داده بین شبکه‌های مختلف از پروتکل‌های مسیریابی مانند RIP، OSPF و BGP استفاده می‌کند. همچنین، مسیریاب‌ها مسیر بهینه برای انتقال بسته‌های داده را انتخاب می‌کنند و مسیریابی برای کنترل ترافیک شبکه مورد استفاده قرار می‌گیرد.\n5.1.4 Host-Level Networking # در شبکه مبتنی بر یک میزبان، ما دارای نگرانی‌های اضافی هستیم که در طراحی، اشکال زدایی و پیاده‌سازی نرم‌افزار مبتنی بر شبکه مورد استفاده قرار می‌گیرند. برخی از این موارد عبارتند از:\nDNS (نظام نام دامنه، به عنوان نام‌گذاری سازگار با انسان) Firewalls (مانند مسدود کردن ترافیک ورودی یا خروجی) Routing (به عنوان مثال، فهمیدن کدام شبکه برای قرار دادن یک بسته مناسب است) مدیریت هویت میزبان (به عنوان مثال، آدرس IP) کنترل عملکرد (به عنوان مثال، شکل دهی و یا تلاش مجدد برای ترافیک) مسائل اتصال (به عنوان مثال، عدم وجود آداپتور شبکه، ارتباطات داخلی پردازش درون‌ساختمانی) در کل، طراحی، پیاده‌سازی و مدیریت شبکه در سطح میزبان به دلیل وجود این نگرانی‌های اضافی، بسیار پیچیده تر از طراحی، پیاده‌سازی و مدیریت شبکه در سطح شبکه به شمار می‌آید.\n5.1.5 کپسوله سازی Packet # در هرکدام از مدل OSI یا TCP/IP، ارتباط بین لایه‌ها با ارسال بسته‌های داده از یک لایه به لایه بعدی و در نهایت از طریق شبکه انجام می‌شود. هر لایه اطلاعات مدیریتی دارد که باید درباره لایه خود نگه داشته شود. برای این کار، هر لایه با اضافه کردن اطلاعات هدر به بسته‌ای که از لایه بالایی دریافت می‌کند، همانند یک لایه زیر، بسته را به لایه بعدی منتقل می‌کند. در سمت دریافت کننده، هدرهای این بسته‌ها با حرکت بسته به سمت لایه بالاتر حذف می‌شوند.\nبه عنوان مثال، پروتکل انتقال پرونده‌های ساده (TFTP) فایل‌ها را از یک کامپیوتر به کامپیوتر دیگری منتقل می‌کند. این پروتکل از پروتکل UDP روی پروتکل IP استفاده می‌کند که ممکن است از طریق اترنت ارسال شود. این به صورتی است که در شکل زیر نشان داده شده است.\n5.1.6 مدل های ارتباط # برای دو کامپیوتر برای ارتباط با یکدیگر، آن‌ها باید یک مسیر راه‌اندازی کنند که امکان ارسال حداقل یک پیام در یک جلسه را برای آن‌ها فراهم کند. دو مدل اصلی برای این کار وجود دارد:\n5.1.6.1 مدل مبتنی بر اتصال (Connection Oriented) # در این مدل، ابتدا یک اتصال بین دو کامپیوتر برقرار می‌شود و سپس داده‌ها در قالب یک جلسه انتقال می‌یابند. این مدل برای انتقال داده‌هایی که نیاز به اطمینان بالا و کیفیت خدمات دارند مفید است، به عنوان مثال، ارسال فایل‌های بزرگ، ارتباطات صوتی و تصویری، اتصال به اینترنت و غیره. پروتکل TCP مثالی از یک مدل مبتنی بر اتصال است.\n5.1.6.2 مدل بدون اتصال (Connectionless) # در این مدل، هیچ اتصالی بین دو کامپیوتر برقرار نمی‌شود و هر بسته به صورت مستقل از دیگر بسته‌ها ارسال می‌شود. این مدل برای انتقال داده‌هایی که نیاز به سرعت بالا و حجم کمتری از اطلاعات دارند مفید است، به عنوان مثال، ارسال پیام‌های کوتاه، سرور های بازی، درخواست اطلاعات از یک سرور و غیره. پروتکل UDP مثالی از یک مدل بدون اتصال است.\n5.1.7 مدل های ارتباطات # در یک سیستم توزیع‌شده، بسیاری از اجزا (یعنی فرآیندها) در حال اجرا هستند که باید با یکدیگر ارتباط برقرار کنند. دو مدل اصلی برای این کار وجود دارند: ارسال پیام و فراخوانی رویه‌های از راه دور (Remote Procedure Call).\nدر زمینه شبکه‌ها، این مدل‌ها اجازه ارتباط بین فرآیندها (و/یا رشته‌ها) با هدف فراخوانی رفتار روی فرآیند از راه دور را می‌دهند.\nدر مدل ارسال پیام، فرآیندها با یکدیگر به صورت غیرمستقیم و از طریق ارسال پیام‌هایی که شامل داده‌های خاصی هستند، ارتباط برقرار می‌کنند. این پیام‌ها ممکن است برای انتقال داده‌ها، درخواست خدمات، یا هر نوع ارتباطی بین فرآیندها استفاده شوند. این مدل برای سیستم‌هایی که ارتباطات غیرهمزمان، توزیع شده و یا برای ارتباطاتی که نیاز به پیچیدگی بیشتری دارند، مفید است.\nدر مدل فراخوانی رویه‌های از راه دور، فرآیند فراخواننده یک رویه محلی را فراخوانی می‌کند که در فرآیند دیگری اجرا می‌شود. در این مدل، فرآیند فراخواننده به عنوان مشتری عمل می‌کند و فرآیند دیگر به عنوان سرور. درخواست‌های مشتری به صورت پیام‌هایی به سرور فرستاده می‌شود و سرور درخواست‌ها را پردازش می‌کند و نتیجه را به مشتری می‌فرستد. این مدل برای سیستم‌هایی که نیاز به ارتباطات همزمان و یا درخواست‌هایی که نیاز به پردازش پیچیده دارند، مفید است.\n5.1.7.1 Message Passing # بعضی زبان‌ها بر اساس اصل ارسال پیام ساخته شده‌اند. زبان‌ها و ابزارهای همزمان از این مکانیزم استفاده می‌کنند و مثال شناخته شده‌ترین آن ممکن است خط لوله UNIX باشد. خط لوله UNIX یک خط لوله از بایت‌هاست، اما این یک محدودیت ذاتی نیست: PowerShell شرکت مایکروسافت می‌تواند اشیاء را از طریق خطوط لوله خود ارسال کند و زبان‌های همزمان مانند Parlog می‌توانند ساختارهای داده منطقی دلخواه را در پیام‌های بین فرآیندهای همزمان ارسال کنند. زبان‌های جدید مانند Go دارای مکانیزم‌هایی برای ارسال پیام (بین تردها) هستند.\nارسال پیام یک مکانیزم اولیه برای سیستم‌های توزیع‌شده است. یک اتصال راه‌اندازی کرده و برخی از داده‌ها را از آن پمپ کنید. در سمت دیگر، پیام را تشخیص دهید و به آن پاسخ دهید، با احتمال ارسال پیام‌های بازگشتی. این در شکل زیر نشان داده شده است.\nسیستم‌های مبتنی بر رویداد نیز به همین شکل عمل می‌کنند. در سطح پایین، زبان برنامه‌نویسی Node.js یک حلقه رویداد اجرا می‌کند که منتظر رویدادهای ورود/خروج است، برای این رویدادها شیء‌های اجرایی را فراخوانی کرده و به آن‌ها پاسخ می‌دهد. در سطح بالاتر، اکثر سیستم‌های رابط کاربری از یک حلقه رویداد برای انتظار ورودی کاربر استفاده می‌کنند، در حالی که در دنیای شبکه، Ajax از XMLHttpRequest برای ارسال و دریافت درخواست‌ها استفاده می‌کند.\n5.1.7.2 Remote Procedure Call # در هر سیستمی، انتقال اطلاعات و کنترل کم از یک بخش از سیستم به بخش دیگری اتفاق می‌افتد. در زبان‌های رویه‌ای، این ممکن است شامل فراخوانی رویه باشد، که در آن اطلاعات بر روی یک پشته فراخوانی قرار داده می‌شود و سپس کنترل به بخش دیگری از برنامه منتقل می‌شود. حتی با فراخوانی رویه، تفاوت‌هایی وجود دارد. کد ممکن است به طور استاتیک متصل شود تا کنترل از قسمتی از کد اجرایی برنامه به بخش دیگری از آن منتقل شود. به دلیل استفاده روزافزون از روتین‌های کتابخانه، معمول شده است کد را در شیء‌های به اشتراک گذاشته شده (.so) یا کتابخانه‌های پیوندی پویای (.dll) داشته باشیم، که کنترل به یک قطعه کد مستقل منتقل می‌شود.\nکتابخانه‌ها در همان ماشینی که کد فراخواننده در آن اجرا می‌شود، اجرا می‌شوند. این یک مرحله ساده (مفهومی) برای انتقال کنترل به یک رویه اجرا شده در ماشین دیگر (یعنی کتابخانه از راه دور) است. اما مکانیک این کار به این سادگی نیست! با این حال، این مدل کنترل باعث بروز فراخوانی رویه از راه دور (RPC) شده است که در یک فصل بعدی به طور جزئیات بیشتری بحث می‌شود. این در شکل زیر نشان داده شده است.\nهمانطور که گفته شد، بسیاری از مثال‌هایی که وجود دارد، بر اساس زبان‌های برنامه‌نویسی خاصی مانند بسته rpc Go یا سیستم‌های RPC پوشش دهی چندین زبان مانند SOAP و gRPC شرکت گوگل است.\nممکن است مبهم باشد که چگونه ارسال پیام و RPC از هم متفاوت هستند. در یک سطح، هردو با فراخوانی رفتار \u0026ldquo;جای دیگری\u0026rdquo; مرتبط هستند. به طور کلی، RPC در مقایسه با ارسال پیام کمتر انتزاعی است (یعنی به نظر می‌رسد و به احساس فراخوانی روتین‌های معمولی شبیه است)، در حالی که در ارسال پیام ممکن است به سیستم صف‌های از راه دور فراخوانی شده باشیم. با این حال، در پشت صحنه، RPC نیز پیام‌ها را ارسال می‌کند.\n5.1.7.3 مدل محاسبات توزیع شده (Distributed Computing) # در سطح بالاتر، می‌توانیم معادل بودن یا عدم معادل بودن اجزای یک سیستم توزیع شده را مورد بررسی قرار دهیم. شاید رایج‌ترین حالت یک حالت نامتقارن باشد: یک مشتری درخواست‌های خود را به یک سرور ارسال می‌کند و سرور پاسخ می‌دهد. این یک سیستم client-server است.\nاگر هر دو اجزای سیستم معادل باشند، قادر به شروع کردن و پاسخ دادن به پیام‌ها باشند، آنگاه یک سیستم همتا به همتا داریم. توجه کنید که این یک طبقه‌بندی منطقی است: یک همتا ممکن است یک ابرکامپیوتر با ۱۶۰۰۰ هسته باشد؛ دیگری ممکن است یک تلفن همراه باشد. اما اگر هر دو می‌توانند به طور مشابه عمل کنند، آنگاه آن‌ها همتای یکدیگر هستند.\nدر مثال سیستم client-server، مرورگری که با یک سرور وب صحبت می‌کند، یک مثال است. مثالی از یک سیستم همتا به همتا، سیستم پایگاه داده است که داده‌ها در آن تکثیر می‌شوند و در هر دو همتا در دسترس هستند.\nترکیب این سیستم‌ها باعث بوجود آمدن معماری‌های چند لایه می‌شود، که یکی از رایج‌ترین آن‌ها سه لایه است (یعنی ارائه -\u0026gt; برنامه -\u0026gt; داده یا مرورگر -\u0026gt; سرور وب -\u0026gt; پایگاه داده).\n5.1.7.3.1 سیستم client-server # به عکس زیر توجه کنید:\nدر سیستم فوق ممکن است توسط یک توسعه‌دهنده که نیاز به شناخت اجزای یک سیستم دارد، داشته باشد. همچنین، کاربری که از یک مرورگر استفاده می‌کند، می‌داند که مرورگر در سیستمش اجرا می‌شود، اما با سرورهای دیگری در جای دیگری ارتباط برقرار می‌کند.\nنمودار قبلی شبیه به مدل OSI است که در ابتدای کتاب بحث شد. لایه‌های موجود در شکل فوق نیز اختیاری هستند؛ به عنوان مثال، می‌توانیم هم مشتری و هم سرور را روی یک پاره‌ای از سخت افزار نصب کنیم. قرار گرفتن روی همان ماشین به این معنی است که ما می‌توانیم برخی از لایه‌های مدل OSI را از جمله لایه ۱ (فیزیکی)، لایه ۲ (پیوند داده) و لایه ۳ (شبکه) را حذف کنیم. ما می‌گوییم \u0026ldquo;احتمالا\u0026rdquo;، زیرا این لایه‌ها هنوز ممکن است برای دلایل مختلفی از جمله همگنی ابزارها یا امنیت، مورد نیاز باشند.\n5.1.7.3.2 اپلیکیشن Client-Server # برخی از برنامه‌ها ممکن است به طور شفاف توزیع شده باشند، به طوری که کاربر نمی‌داند که آن توزیع شده است. کاربران دید خود را از سیستم خود مشاهده می‌کنند، همانطور که در شکل زیر نشان داده شده است.\nبرای عملکرد، هر دو اجزا باید نصب شده باشند. چقدر پیچیدگی برنامه باید شفاف باشد، به برنامه و استفاده آن بستگی دارد.\n5.1.7.3.3 سرور توزیع شده # یک سیستم client-server نیازمند پیچیدگی نیست. مدل ابتدایی، یک سیستم مشتری-سرور تکی است که در شکل زیر نشان داده شده است.\nاما می‌توانید چندین مشتری و یک سرور داشته باشید، همانطور که در شکل زیر نشان داده شده است.\nدر این سیستم، مستر درخواست‌ها را دریافت کرده و به جای اینکه خودش آن‌ها را یکی یکی پردازش کند، آن‌ها را به سرورهای دیگر برای پردازش ارسال می‌کند. این یک مدل رایج است زمانی که مشتریان همزمان ممکن است وجود داشته باشند.\nهمچنین، می‌توانید یک مشتری و چندین سرور داشته باشید، همانطور که در شکل زیر نشان داده شده است.\nاین نوع سیستم بسیار رایج است زمانی که یک سرور باید به عنوان مشتری به سرورهای دیگر عمل کند، مانند یک سرور منطق تجاری که اطلاعات را از سرور پایگاه داده دریافت می‌کند. و البته، می‌تواند چندین مشتری با چندین سرور باشد.\nدوباره، این اجزا ممکن است روی یک سخت‌افزار فیزیکی قرار نگرفته باشند.\n"},{"id":75,"href":"/chapter-5/go-tcp-server-begginer/","title":"5.2 سرور tcp مقدماتی","section":"فصل پنجم: برنامه نویسی شبکه با گو","content":"ما میتوانیم در گو با استفاده از کتابخانه net یک سرور tcp ایجاد کنیم بعد از تکمیل شدن سرور با استفاده از دستور telnet به آن متصل میشویم\nدر قطعه کد زیر با تابع acceptLoop() درخواست های اتصال را مپذیریم و با تابع readLoop() پیام های اتصال را میخوانیم\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;log\u0026#34; 6\t\u0026#34;net\u0026#34; 7) 8 9// ساختار هر پیام در سرور 10type Message struct { 11\t// ادرس ip ارسال کننده پیام 12\tfrom string 13\t// متن و محتوای پیام 14\tpayload []byte 15} 16 17// ساختار سرور 18type Server struct { 19\t// ادرس و یا پورت سرور 20\tlistenAddr string 21\t// listener 22\tln net.Listener 23\t// چنل پیام برای انتقال پیام های دریافتی از اتصال ها بین گوروتین ها 24\tmsgch chan Message 25} 26 27// ایجاد یک سرور جدید 28func newServer(listenAddr string) *Server { 29\treturn \u0026amp;Server{ 30\tlistenAddr: listenAddr, 31\tmsgch: make(chan Message, 10), 32\t} 33} 34 35// شروع سرور و دریافت اتصال های جدید 36func (s *Server) start() error { 37\t// شروع سرور 38\tln, err := net.Listen(\u0026#34;tcp\u0026#34;, s.listenAddr) 39\tif err != nil { 40\treturn err 41\t} 42\t// مقدار دهی listener 43\ts.ln = ln 44\t// با تابع acceptLoop اتصال های جدید به سرور را مدیریت میکنیم 45\t// با استفاده از go هر اتصال را روی یک گوروتین مجزا مدیریت میکنیم 46\tgo s.acceptLoop() 47 48\treturn nil 49} 50 51// اینجا برای استاپ کردن سرور یک متد جدید تعریف میکنیم 52func (s *Server) stop() { 53\tif s.ln != nil { 54\ts.ln.Close() 55\t} 56} 57 58func (s *Server) acceptLoop() { 59\tfor { 60\t// اتصال های موجود را تایید میکنیم متغییر conn را با اتصال مورد نظر مقدار دهی میکنیم 61\tconn, err := s.ln.Accept() 62\tif err != nil { 63\tfmt.Println(\u0026#34;accept error:\u0026#34;, err) 64\tcontinue 65\t} 66\t// با استفاده از این تابع مقادیر ارسال شده توسط اتصال را به چنل message میدهیم 67\tgo s.readLoop(conn) 68\t} 69} 70 71func (s *Server) readLoop(conn net.Conn) { 72\tdefer conn.Close() 73\tbuf := make([]byte, 2048) 74 75\tfor { 76\t// پیام ارسال شده توسط هر اتصال را به متغییر buf میدهیم 77\tn, err := conn.Read(buf) 78\tif err != nil { 79\tfmt.Println(\u0026#34;read error:\u0026#34;, err) 80\tcontinue 81\t} 82 83\ts.msgch \u0026lt;- Message{ 84\t// ادرس ip ارسال کننده پیام از نوع net.IP 85\tfrom: conn.RemoteAddr().String(), 86\t// متن پیام 87\tpayload: buf[:n], 88\t} 89 90\t// بعد از دریافت هر پیام یک پیام به عنوان پاسخ ارسال میکنیم 91\tconn.Write([]byte(\u0026#34;your message recived!\\n\u0026#34;)) 92\t} 93} 94 95func main() { 96\t// ساخت سرور 97\tserver := newServer(\u0026#34;:3000\u0026#34;) 98\t99\t//start the server 100\tif err := server.start(); err != nil { 101\tlog.Fetal(err) 102\t} 103 104\tgo func() { 105\t// در ازای هر پیام مقادیر آن را چاپ میکنیم 106\tfor msg := range server.msgch { 107\tfmt.Printf(\u0026#34;recived new from connection(%s): %s\\n\u0026#34;, msg.from, msg.payload) 108\t} 109\t}() 110 111\t// Run an infinite loop to keep the program running 112\tselect {} 113 114} بعد از پایان پیاده سازی سرور tcp با دستور زیر سرور خود را اجرا میکنیم: go run main.go\nو با دستور زیر در یک ترمینال مجزا به سرور متصل میشویم: telnet localhost 3000\nحال با نوشتن پیام و ارسال آن در ترمینال telnet متن پیام و ادرس اتصال در ترمینال سرور قابل مشاهده است.\nتوجه داشته باشید که دستور ‍telnet در ویندوز نیاز به فعال سازی دارد.\n"},{"id":76,"href":"/chapter-5/go-tcp-server-advanced/","title":"5.3 سرور tcp پیشرفته","section":"فصل پنجم: برنامه نویسی شبکه با گو","content":"در این قسمت به طراحی و ساخت یک سرور tcp بصورت پیشرفته میپردازیم. در قسمت قبل بعد از ایجاد سرور TCP ساده با استفاده از کلاینت telnet به آن متصل شدیم و دیتایی را انتقال دادیم.\nدر این قسمت یک سرور tcp را با هدف انتقال فایل های حجیم بصورت جریان ایجاد میکنم.\nقبل از شروع ایجاد سرور خود به دلیل اینکه چرا فایل های حجیم را استریم میکنیم و یا اصلا استریم چیست میپردازیم. زمانی که شما فایل های کم حجم را مستقیما انتقال میدهید با تاخیر کم و بصورت مطلوب انجام میشود. اما روایت برای فایل های سنگین تر متفاوت است، اگر این عمل بصورت مستقیم و یکجا انجام شود باعث ایجاد تاخیر و مصرف منابع بیش از حد روی سرور میشود. اما ما با استفاده از روش استریم، داده و فایل خود را بصورت قطعه های کم حجم و پشت سر هم ارسال میکنیم.\nدر ادامه به پیاده سازی سرور خود با استفاده از پروتکل tcp میپردازیم:\n1package main 2 3import ( 4\t\u0026#34;bytes\u0026#34; 5\t\u0026#34;crypto/rand\u0026#34; 6\t\u0026#34;encoding/binary\u0026#34; 7\t\u0026#34;fmt\u0026#34; 8\t\u0026#34;io\u0026#34; 9\t\u0026#34;log\u0026#34; 10\t\u0026#34;net\u0026#34; 11\t\u0026#34;time\u0026#34; 12) 13 14 15type FileServer struct { } 16 17 18func (fs *FileServer) start() { 19\tln, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;0.0.0.0:3000\u0026#34;) 20\tif err != nil { 21\tpanic(err) 22\t} 23 24\tfor { 25\tconn, err := ln.Accept() 26 27\tif err != nil { 28\tlog.Fatal(err) 29\tcontinue 30\t} 31 32\tfmt.Printf(\u0026#34;new connection: %s\\n\u0026#34;, conn.RemoteAddr().String()) 33 34\t// read data from accepted connections 35\tgo fs.readLoop(conn) 36\t} 37} 38 39func (fs *FileServer) readLoop(conn net.Conn) { 40 41\t// make a new buffer 42\tbuf := new(bytes.Buffer) 43 44\tfor { 45 46\tvar size int64 47 48\t// get the size from connection 49\tbinary.Read(conn, binary.LittleEndian, \u0026amp;size) 50 51\t// copy from connection until the end of file 52\tn, err := io.CopyN(buf, conn, size) 53\tif err != nil { 54\tlog.Fatal(err) 55\tcontinue 56\t} 57 58\tfmt.Println(buf.Bytes()) 59\tfmt.Printf(\u0026#34;received %d bytes over the network\\n\u0026#34;, n) 60\t} 61} 62 63func main() { 64 65\tgo func () { 66 67\ttime.Sleep(4 * time.Second) 68 69 // set your file szie 70\tsendFile(2000000) 71\t}() 72 73\ts := \u0026amp;FileServer{} 74\ts.start() 75} 76 77// client example that send a large file to server! 78func sendFile(size int) error { 79 80\tfile := make([]byte, size) 81 82\t// make a random file from the size provided 83\t_, err := io.ReadFull(rand.Reader, file) 84\tif err != nil { 85\treturn err 86\t} 87 88\t// dial with the tcp server (you can do this is an other file) 89\tconn, err := net.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;:3000\u0026#34;) 90\tif err != nil { 91\treturn err 92\t} 93 94\t// send the size of file 95\tbinary.Write(conn, binary.LittleEndian, int64(size)) 96 97\t// copy file over the network until the end of file 98\tn, err := io.CopyN(conn, bytes.NewReader(file), int64(size)) 99\tif err != nil { 100\treturn err 101\t} 102 103\tfmt.Printf(\u0026#34;written %d byte over the network\\n\u0026#34;, n) 104\treturn nil 105} بعد از پایان نوشتن کد شما میتوانید با اجرا کردن کد خود (ترجیحا انتخاب یک عدد بزرگ برای حجم فایل یا همان ورودی تابع sendFile) میتوانید استریم شدن بایت هارا بصورت چانک چانک در لاگ های سمت سرور ببینید.\n"},{"id":77,"href":"/chapter-5/go-udp-server-begginer/","title":"5.4 سرور udp مقدماتی","section":"فصل پنجم: برنامه نویسی شبکه با گو","content":"در این قسمت به طراحی و ساخت یک سرور UDP مقدماتی با گولنگ می پردازیم.\n5.4.1 معرفی UDP # پروتکل(User Datagram Protocol) یک پروتکل فاقد اتصال است. به این معنا که بسته های این پروتکل بدون اتصال قبلی و بررسی اینکه ایا همه بسته ها به درستی ارسال شده اند به دستگاه مورد نظر ارسال میشود. به همین دلیل سرعت در این پروتکل از پروتکل tcp پایین تر است اما تظمین ارسال کامل و سالم داده وجود ندارد. از موارد استفاده این پروتکل میتوان سرور بازی های انلاین را مثال زد.\n5.4.2 پیاده سازی # برای پیاده سازی یک سرور udp در گولنگ و اتصال به آن همچنان از کتابخانه net استفاده میکنیم.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;net\u0026#34; 6\t\u0026#34;strings\u0026#34; 7) 8 9 10func main() { 11 // ادرس IP و پورت مورد نظر را برای گوش سپردن به پکت های UDP مشخص میکنیم (مقدار بازگشتی این تابع اتصال ما است که قابلیت نوشتن و خواندن آن را داریم) 12\tconn, err := net.ListenUDP(\u0026#34;udp\u0026#34;, \u0026amp;net.UDPAddr{ 13\tPort: 3000, 14\tIP: net.ParseIP(\u0026#34;0.0.0.0\u0026#34;), 15\t}) 16\tif err != nil { 17\tpanic(err) 18\t} 19 20\tdefer conn.Close() 21\tfmt.Printf(\u0026#34;server listening %s\\n\u0026#34;, conn.LocalAddr().String()) 22 23\tfor { 24\tmessage := make([]byte, 20) 25 // تمام پیام های نوشته شده (ارسال شده) را میخوانیم 26 // متغییر message را با مقدار ارسال شده پر میکنیم (مقدار های بازگشتی این تابع طول پیام و آدرس ریموت ارسال کننده است) 27\treadLen, remote, err := conn.ReadFromUDP(message[:]) 28\tif err != nil { 29\tpanic(err) 30\t} 31 32 // متن پیام را تا قسمت خوانده شده به string تبدیل میکنیم 33\tdata := strings.TrimSpace(string(message[:readLen])) 34 // داده خروجی را چاپ میکنیم 35\tfmt.Printf(\u0026#34;received: %s from %s\\n\u0026#34;, data, remote) 36\t} 37} بعد از انجام مراحل بالا با دستور ‍go run main.go کد خود را اجرا میکنیم.\n5.4.3 کد کلاینت برای اتصال به سرور ساخته شده # اکنون با چند خط کد در زبان گولنگ به سرور خود متصل میشویم پیامی را به آن ارسال میکنیم\n1package main 2 3import \u0026#34;net\u0026#34; 4 5func main() { 6 // یک اتصال به سرور ایجاد میکنیم 7 Conn, _ := net.DialUDP(\u0026#34;udp\u0026#34;, nil, \u0026amp;net.UDPAddr{IP:[]byte{127,0,0,1},Port:3000,Zone:\u0026#34;\u0026#34;}) 8 9 defer Conn.Close() 10 // متن زیر را به سرور ارسال میکنیم 11 Conn.Write([]byte(\u0026#34;hello, gofarsi!\u0026#34;)) 12} اکنون همزمان با اجرا بودن کد سرور این قطعه کد را با دستور ‍‍go run client.go اجرا میکنیم (بسته به اسمی که برای فایل انتخاب کرده اید)\nخروجی در کنسول کد سرور به این صورت خواهد بود: received: hello, gofarsi! from 127.0.0.1:54960\n"},{"id":78,"href":"/chapter-5/go-udp-server-advanced/","title":"5.5 سرور udp پیشرفته","section":"فصل پنجم: برنامه نویسی شبکه با گو","content":"در قسمت قبل به ایجاد یک سرور udp ساده و ارسال پکت به آن پرداختیم. در این قسمت با استفاده از یک سرور و کلاینت udp یک پیام رسان بصورت feed میسازیم. عملکرد سرور و کلاینت: یک سرور udp ایجاد میکنیم که تمام کانکشن های موجود را ذخیره میکند و به محض دریافت پیام از هر یک از کانکشن ها پیام را برای تمام کانکشن های دیگر بجر کانکشن ارسال کننده پیام ارسال میکند.\nدر مرحله اول سروری که کانکشن ها و ارسال پیام را مدیریت میکنید مینویسیم:\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;net\u0026#34; 6) 7 8func main() { 9 // Set up the server 10 addr := net.UDPAddr{ 11 Port: 8000, 12 IP: net.ParseIP(\u0026#34;0.0.0.0\u0026#34;), 13 } 14 15 conn, err := net.ListenUDP(\u0026#34;udp\u0026#34;, \u0026amp;addr) 16 if err != nil { 17 fmt.Println(\u0026#34;Error listening:\u0026#34;, err) 18 return 19 } 20 21 defer conn.Close() 22 fmt.Println(\u0026#34;Server started on port\u0026#34;, addr.Port) 23 24 // Listen for incoming messages 25 buffer := make([]byte, 1024) 26 27 clients := make(map[string]*net.UDPAddr) 28\t29 for { 30 n, clientAddr, err := conn.ReadFromUDP(buffer) 31 if err != nil { 32 fmt.Println(\u0026#34;Error reading:\u0026#34;, err) 33 continue 34 } 35 36 // Add new client 37 if _, ok := clients[clientAddr.String()]; !ok { 38 clients[clientAddr.String()] = clientAddr 39 fmt.Println(\u0026#34;New client joined:\u0026#34;, clientAddr.String()) 40 } 41 42 // Broadcast message to all clients 43 message := buffer[:n] 44 for _, addr := range clients { 45 if addr.String() != clientAddr.String() { 46 _, err = conn.WriteToUDP(message, addr) 47 if err != nil { 48 fmt.Println(\u0026#34;Error broadcasting message:\u0026#34;, err) 49 } 50 } 51 } 52 } 53} در این قسمت یک سرور udp ایجاد کرده ایم و هر کانکشن جدید را به لیست کانکشن های خود اضافه میکنیم. همچنین در ازای هر پیام دریافتی از سمت کانکشن ها آن را برای کانکشن های دیگر ارسال میکنیم.\nدر ادامه یک کلاینت ساده برای سرور خود مینویسیم که پیام هارا نمایش دهد و متن ورودی در ترمینال را به سرور ارسال کند.\n1package main 2 3import ( 4 \u0026#34;bufio\u0026#34; 5 \u0026#34;fmt\u0026#34; 6 \u0026#34;net\u0026#34; 7 \u0026#34;os\u0026#34; 8) 9 10func main() { 11 // Set up connection to the server 12 conn, err := net.Dial(\u0026#34;udp\u0026#34;, \u0026#34;localhost:8000\u0026#34;) 13 if err != nil { 14 fmt.Println(\u0026#34;Error connecting:\u0026#34;, err) 15 return 16 } 17 defer conn.Close() 18 19 20 go func() { 21 for { 22 buf := make([]byte, 1024) // buffer for incoming message 23 n, err := conn.Read(buf) 24 if err != nil { 25 fmt.Println(\u0026#34;Error receiving message:\u0026#34;, err) 26 continue 27 } 28 fmt.Printf(\u0026#34;Received message: %s\\n\u0026#34;, string(buf[:n])) 29 } 30 }() 31 32 // Read input from terminal and send to server 33 scanner := bufio.NewScanner(os.Stdin) 34 for { 35\t// send messages to server 36 fmt.Print(\u0026#34;Enter message: \u0026#34;) 37 if !scanner.Scan() { 38 break 39 } 40 message := scanner.Text() 41 _, err = conn.Write([]byte(message)) 42 if err != nil { 43 fmt.Println(\u0026#34;Error sending message:\u0026#34;, err) 44 continue 45 } 46 } 47} در این کد ما تمام پیام های دریافتی از سرور را چاپ میکنیم و هر پیامی که کاربر در ترمینال وارد کند را به سرور ارسال میکنیم.\nبعد از اتمام کار برای تست کد خود سه ترمینال مجزا بار میکنیم. و در یکی از سرور ها فایل server.go و در دو ترمینال دیگر فایل client.go را اجرا میکنیم.\nهر پیامی که توسط هر کلاینتی ارسال شود برای دیگر کلاینت ها قابل مشاهده است.\nتوجه کنید اسم فایل ها بر اساس اسم انتخابی شما است. همچنین توجه داشته باشید که شما میتوانید هر تعداد دلخواهی کلاینت را اجرا کنید.\n"},{"id":79,"href":"/chapter-5/go-http-server-begginer/","title":"5.6 کتابخانه http سمت سرور مقدماتی","section":"فصل پنجم: برنامه نویسی شبکه با گو","content":"یکی از قابلیت های زبان گو این است که می توان با استفاده از کتابخانه http داخلی گو استفاده کرده و وب سرور پیاده سازی کرد.\nبرای پیاده سازی یک وب سرور حداقل به 3 چیز نیاز داریم: 1) مسیر 2) درگاه وب سرور 3) مقدار برگشتی\nمسیر: عبارت است از URL منحصر به فرد برای ارسال و دریافت اطلاعات ورودی\nدرگاه وب سرور: هر وب سرور نیاز دارد که درگاه (Port) خاصی را در اختیار داشته باشد و همواره به آن درگاه گوش بسپارد.\nمقدار برگشتی: هرگاه کاربر به مسیری وارد میشود یا اطلاعاتی را برای وب سرور ارسال میکند، مقداری از سمت سرور برای کاربر ارسال میشود.\nیک نمونه وب سرور در گو\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;net/http\u0026#34; 6) 7 8func main() { 9\t// مسیر / یا root را برای این تابع انتخاب میکنیم (کد این تابع با صدا شدن مسیر localhost:3000 اجرا می شود) 10\thttp.HandleFunc(\u0026#34;/\u0026#34;, func(writer http.ResponseWriter, request *http.Request) { 11\t// مقدار hello world را در مسیر مشخص شده برمیگردانیم 12\t_, err := fmt.Fprint(writer, \u0026#34;\u0026lt;h1\u0026gt;Hellow World!\u0026lt;/h1\u0026gt;\u0026#34;) 13\tif err != nil { 14\treturn 15\t} 16\t}) 17 18\tfmt.Println(\u0026#34;Starting The Server on :3000...\u0026#34;) 19\t// به درخواست های ارسال شده به پورت 3000 با پروتوکول http گوش میکنیم (سرور در انتظار درخواست از سمت کاربر یا client) می ماند 20\terr := http.ListenAndServe(\u0026#34;:3000\u0026#34;, nil) 21\tif err != nil { 22\treturn 23\t} 24 25} با وارد شدن به آدرس localhost:3000 مقدار برگشته شده در ‍handleFunc را مشاهده خواهید کرد.\n"},{"id":80,"href":"/chapter-5/go-http-server-advanced/","title":"5.7 کتابخانه http سمت سرور پیشرفته","section":"فصل پنجم: برنامه نویسی شبکه با گو","content":"در قسمت قبل با استفاده از کتابخانه net/http یک api ساده ایجاد کردیم.\nدر این قسمت به پیاده سازی یک سرور http برای مدیریت لیست TODO های خود میپردازیم و از چهار متد GET, POST, DELET and PATCH استفاده میکنیم.\nدر این پروژه از دیتابیس استفاده نمیشود. روش ذخیره سازی اطلاعات درون متغییر هاست دلیل استفاده نکردن از یک دیتابیس تمرکز این قسمت روی کتابخانه و پروتکل http است.\nدر ادامه به ایجاد سرور خود میپردازیم.\n1package main 2 3import ( 4\t\u0026#34;encoding/json\u0026#34; 5\t\u0026#34;fmt\u0026#34; 6 \u0026#34;log\u0026#34; 7\t\u0026#34;net/http\u0026#34; 8) 9 10// todo struct with json tags 11type Todo struct { 12\tID int `json:\u0026#34;id\u0026#34;` 13\tTitle string `json:\u0026#34;title\u0026#34;` 14\tStatus bool `json:\u0026#34;status\u0026#34;` 15} 16 17// just work as a DB for us! 18var todos []Todo 19 20// get all the items in the Todo list and write it. GET 21func getTodos(w http.ResponseWriter, r *http.Request) { 22\tw.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) 23\tjson.NewEncoder(w).Encode(todos) 24} 25 26// append a new data in array. POST 27func addTodo(w http.ResponseWriter, r *http.Request) { 28\tw.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) 29 30\tvar todo Todo 31\tjson.NewDecoder(r.Body).Decode(\u0026amp;todo) 32 33 // NOTE: this isn\u0026#39;t a good way to set ids in production! 34\ttodo.ID = len(todos) + 1 35\ttodos = append(todos, todo) 36 37\tjson.NewEncoder(w).Encode(todo) 38} 39 40// change the todo status. PATCH 41func updateTodo(w http.ResponseWriter, r *http.Request) { 42\tw.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) 43 44\tvar todo Todo 45\tjson.NewDecoder(r.Body).Decode(\u0026amp;todo) 46 47\tfor i, t := range todos { 48\tif t.ID == todo.ID { 49\ttodos[i].Status = todo.Status 50\tjson.NewEncoder(w).Encode(todos[i]) 51\treturn 52\t} 53\t} 54 55\tw.WriteHeader(http.StatusNotFound) 56\tjson.NewEncoder(w).Encode(map[string]string{\u0026#34;message\u0026#34;: \u0026#34;TODO not found\u0026#34;}) 57} 58 59// remove the TODO from array. DELETE 60func deleteTodo(w http.ResponseWriter, r *http.Request) { 61\tw.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) 62 63\tvar todo Todo 64\tjson.NewDecoder(r.Body).Decode(\u0026amp;todo) 65 66\tfor i, t := range todos { 67\tif t.ID == todo.ID { 68\ttodos = append(todos[:i], todos[i+1:]...) 69\tjson.NewEncoder(w).Encode(map[string]string{\u0026#34;message\u0026#34;: \u0026#34;TODO deleted\u0026#34;}) 70\treturn 71\t} 72\t} 73 74\tw.WriteHeader(http.StatusNotFound) 75\tjson.NewEncoder(w).Encode(map[string]string{\u0026#34;message\u0026#34;: \u0026#34;TODO not found\u0026#34;}) 76} 77 78 79func main() { 80 // set routes 81\thttp.HandleFunc(\u0026#34;/todos\u0026#34;, getTodos) 82\thttp.HandleFunc(\u0026#34;/todos/add\u0026#34;, addTodo) 83\thttp.HandleFunc(\u0026#34;/todos/update\u0026#34;, updateTodo) 84\thttp.HandleFunc(\u0026#34;/todos/delete\u0026#34;, deleteTodo) 85 86 // start server 87\tfmt.Println(\u0026#34;Server starting at port 8080\u0026#34;) 88\tlog.Fatal(http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil)) 89} بعد از اتمام نوشتن سرور با استفاده از یک کلاینت http مثل postman سرور خود را به روش زیر تست میکنیم:\nنکته: شما می توانید کلاینت خود را خودتان با استفاده از اموزش کلاینت http در قسمت های دیگر بنویسید!\nadd todo # endpoint: localhost:8080/todos/add\nmethod:POST\nrequest:\n1{ 2 \u0026#34;title\u0026#34;:\u0026#34;todo1 test\u0026#34; 3} response:\n1{ 2 \u0026#34;id\u0026#34;: 1, 3 \u0026#34;title\u0026#34;: \u0026#34;todo1 test\u0026#34;, 4 \u0026#34;status\u0026#34;: false 5} get todo\u0026rsquo;s # endpoint: localhost:8080/todos\nmethod:GET\nrequest:\nresponse:\n1[ 2 { 3 \u0026#34;id\u0026#34;: 1, 4 \u0026#34;title\u0026#34;: \u0026#34;todo1 test\u0026#34;, 5 \u0026#34;status\u0026#34;: false 6 }, 7 //... 8] update todo # endpoint: localhost:8080/todos/update\nmethod:PATCH\nrequest:\n1{ 2 \u0026#34;id\u0026#34;:1, 3 \u0026#34;status\u0026#34;:true 4} response:\n1{ 2 \u0026#34;id\u0026#34;: 1, 3 \u0026#34;title\u0026#34;: \u0026#34;todo1 test\u0026#34;, 4 \u0026#34;status\u0026#34;: true 5} delete todo # endpoint: localhost:8080/todos/delete\nmethod:DELETE\nrequest:\n1{ 2 \u0026#34;id\u0026#34;:1 3} response:\n1{ 2 \u0026#34;message\u0026#34;: \u0026#34;TODO deleted\u0026#34; 3} "},{"id":81,"href":"/chapter-5/go-http-client-begginer/","title":"5.8 کتابخانه http سمت کلاینت مقدماتی","section":"فصل پنجم: برنامه نویسی شبکه با گو","content":"برای ایجاد کلاینت http در گولنگ نیاز به کتابخانه net/http داریم. قبل از شروع به نوشتن کلاینت خود چند مفهوم کلی راه بررسی میکنیم.\n5.8.1 سرور # همانطور که میدانیم سرور های http برای تعریف مسیر ها منطق سرور و دریافت درخواست ها طراحی و ساخته میشوند. (در قسمت های قبل ایجاد سرور http بصورت کامل یادگرفتیم)\n5.8.2 کلاینت # کلاینت های در پروتوکول http برای صدا کردن (call) و ارسال درخواست به سرور ها طراحی و ساخته میشوند. در ادامه یک کلاینت مقدماتی و ساده را در زبان گولنگ ایجاد میکنیم.\n‍‍\n1 2package main 3 4import ( 5 \u0026#34;fmt\u0026#34; 6 \u0026#34;io/ioutil\u0026#34; 7 \u0026#34;net/http\u0026#34; 8 \u0026#34;time\u0026#34; 9) 10 11func main() { 12 // کلاینت خود را با استفاده از ماژول http ایجاد میکنیم 13 c := http.Client{Timeout: time.Duration(1) * time.Second} 14 // از طریق کلاینت ایجاد شده یک درخواست با متد GET به آدرس example.com ارسال میکنیم 15 // دقیقا سروری مشابه به سرور هایی که در قسمت های قبل ایجاد کردیم در آدرسی که الان به آن درخوایت ارسال میکنیم درحال گوش سپردن به درخواست ها میباشد. 16 resp, err := c.Get(\u0026#34;https://www.example.com\u0026#34;) 17 if err != nil { 18 fmt.Printf(\u0026#34;Error %s\u0026#34;, err) 19 return 20 } 21 defer resp.Body.Close() 22 // مقادیر دریافت شده از سرور را میخوانیم و چاپ میکنیم 23 body, err := ioutil.ReadAll(resp.Body) 24 fmt.Printf(\u0026#34;Body : %s\u0026#34;, body) 25} در نهایت با اجرای قطعه کد بالا خروجی ما پاسخی است که از سرور دریافت کرده ایم:\n1Body : \u0026lt;!doctype html\u0026gt; 2\u0026lt;html\u0026gt; 3\u0026lt;head\u0026gt; 4 \u0026lt;title\u0026gt;Example Domain\u0026lt;/title\u0026gt; 5 6 \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; 7 \u0026lt;meta http-equiv=\u0026#34;Content-type\u0026#34; content=\u0026#34;text/html; charset=utf-8\u0026#34; /\u0026gt; 8 \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1\u0026#34; /\u0026gt; 9 \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; 10 body { 11 background-color: #f0f0f2; 12 margin: 0; 13 padding: 0; 14 font-family: -apple-system, system-ui, BlinkMacSystemFont, \u0026#34;Segoe UI\u0026#34;, \u0026#34;Open Sans\u0026#34;, \u0026#34;Helvetica Neue\u0026#34;, Helvetica, Arial, sans-serif; 15 16 } 17 div { 18 width: 600px; 19 margin: 5em auto; 20 padding: 2em; 21 background-color: #fdfdff; 22 border-radius: 0.5em; 23 box-shadow: 2px 3px 7px 2px rgba(0,0,0,0.02); 24 } 25 a:link, a:visited { 26 color: #38488f; 27 text-decoration: none; 28 } 29 @media (max-width: 700px) { 30 div { 31 margin: 0 auto; 32 width: auto; 33 } 34 } 35 \u0026lt;/style\u0026gt; 36\u0026lt;/head\u0026gt; 37 38\u0026lt;body\u0026gt; 39\u0026lt;div\u0026gt; 40 \u0026lt;h1\u0026gt;Example Domain\u0026lt;/h1\u0026gt; 41 \u0026lt;p\u0026gt;This domain is for use in illustrative examples in documents. You may use this 42 domain in literature without prior coordination or asking for permission.\u0026lt;/p\u0026gt; 43 \u0026lt;p\u0026gt;\u0026lt;a href=\u0026#34;https://www.iana.org/domains/example\u0026#34;\u0026gt;More information...\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt; 44\u0026lt;/div\u0026gt; 45\u0026lt;/body\u0026gt; 46\u0026lt;/html\u0026gt; "},{"id":82,"href":"/chapter-5/go-http-client-advanced/","title":"5.9 کتابخانه http سمت کلاینت پیشرفته","section":"فصل پنجم: برنامه نویسی شبکه با گو","content":"در قسمت قبل به ایجاد یک کلاینت http ساده و ارسال یک درخواست با متد get پرداختیم.\nدر این قسمت به موارد کامل تر و جزیی تر کلاینت http میپردازیم.\nبرای انجام تمرین های این قسمت از یک api تستی که جهت یادگیری ساخته شده است استفاده میکنیم (شما میتوانید از هر api یا سروری استفاده کنید حتی سرور http که خودتان نوشته باشید.)\nدر این آموزش ما از api زیر استفاده میکنیم: api docs\n5.9.1 نوع درخواست های یک سرور http # یکی از مواردی که حین اتصال به یک سرور http باید مورد توجه قرار بگیرد متد یا نوع درخواست است.\nانواع متد ها: GET : پیام هایی که در این روش ارسال می‌شوند تنها برای دریافت اطلاعات از سرور میباشد.\nPOST : در این نوع پیام ها اطلاعاتی برای ثبت شدن در سرور به سمت سرور http ارسال میشود\nPUT : در این روش برای جایگزاری مقداری در سرور اطلاعاتی ارسال میشود.\nDELETE : از این روش برای حذف مقداری از روی سرور استفاده میشود\nPATCH : این روش برای ویرایش جزیی استفاده میشود.\nاین موارد ۵ تا از پرکابرد ترین نوع درخواست های http هستند.\n5.9.2 نوع پاسخ های یک سرور http # در پاسخ یک سرور http یکی از موارد پر اهمیت کد وضعیت یا status code است. این کد ها اعدادی بین ۱۰۰ تا ۵۹۹ هستند که نشان دهنده وضعیت درخوایت از سمت سرور میباشند.\nانواع کد وضعیت: 1XX: این دسته از کد های وضعیت نمایانگر اطلاعات درخواست هستند\n2XX: این دسته از کد های وضعیت نمایانگر موفقیت درخواست در ارسال ثبت یا ویرایش اطلاعات میباشد\n3xx: این دسته از کد های نشانگر ریدایرکت میباشد\n4xx: این دسته از کد ها نشانگر ارور از سمت کلاینت میباشند\n5xx: این دسته از کد های نشانگر ارور از سمت سرور میباشند\nدر قسمت های بعد به پیاده سازی کلاینت و سرور HTTP خواهیم پرداخت و شاهد این موارد در عمل خواهید بود.\nدر قسمت زیر فهرست تعدادی از کد های وضعیت پرکاربرد را میبینیم:\n200 ok : این کد وضعیت نشانگر موفقیت در پاسخ به متد GET است 404 NotFound : این کد وضعیت نشانگر پیدا نشدن مقدار درخواستی کاربر در سرور است که یکی از معروف ترین کد های وضعیت است 500 InternalServerError: این کد وضعیت نشانگر خطای فنی از سمت سرور است 401 Unauthorized : این کد وضعیت نشانگر این است که درخواست ارسال شده نیاز به احراز هویت دارد 403 Forbidden : این کد وضعیت نشانگر این است که دسترسی به URL مورد نظر نیازمند سطح دسترسی متفاوتی است(این مورد با ۴۰۱ متفاوت است) 5.9.3 GET request # در مرحله اول به ایجاد یک درخواست GET به سرور میپردازیم.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;io/ioutil\u0026#34; 6\t\u0026#34;net/http\u0026#34; 7) 8 9func main() { 10 // به url مورد نظر برای دریافت لیست محصولات موجود یک درخوایت با متد GET ایجاد میکنیم 11 resp, err := http.Get(\u0026#34;https://fakestoreapi.com/products\u0026#34;) 12 if err != nil { 13 fmt.Println(\u0026#34;Error:\u0026#34;, err) 14 return 15 } 16 defer resp.Body.Close() 17 18 // کد وضعیت پاسخ سرور را چاپ میکنیم 19 fmt.Println(resp.StatusCode) 20 21 // خروجی را در یک اسلایس ذخیره میکنیم 22 body, err := ioutil.ReadAll(resp.Body) 23 if err != nil { 24 fmt.Println(\u0026#34;Error:\u0026#34;, err) 25 return 26 } 27 28 // خروجی را چاپ میکنیم 29 fmt.Println(string(body)) 30} خروجی:\n1 2[ 3{ 4\u0026#34;id\u0026#34;:1, 5\u0026#34;title\u0026#34;:\u0026#34;Fjallraven - Foldsack No. 1 Backpack, Fits 15 Laptops\u0026#34;,\u0026#34;price\u0026#34;:109.95,\u0026#34;description\u0026#34;:\u0026#34;Your perfect pack for everyday use and walks in the forest. Stash your laptop (up to 15 inches) in the padded sleeve, your everyday\u0026#34;, 6\u0026#34;category\u0026#34;:\u0026#34;men\u0026#39;s clothing\u0026#34;, 7\u0026#34;image\u0026#34;:\u0026#34;https://fakestoreapi.com/img/81fPKd-2AYL._AC_SL1500_.jpg\u0026#34;, 8\u0026#34;rating\u0026#34;:{\u0026#34;rate\u0026#34;:3.9,\u0026#34;count\u0026#34;:120} 9}, 10// ..... 11] 5.9.4 POST request # در مرحله بعد با استفاده از متد POST یک محصول جدید به سرور اضافه میکنیم.\n1package main 2 3import ( 4 \u0026#34;bytes\u0026#34; 5 \u0026#34;fmt\u0026#34; 6 \u0026#34;net/http\u0026#34; 7) 8 9func main() { 10 url := \u0026#34;https://fakestoreapi.com/products\u0026#34; 11 // جیسان مورد نظر برای ارسال و ثبت در سرور را ایجاد میکنیم (مقادیر مورد نیاز در مستندات api ذکر میشود) 12 jsonStr := []byte(` 13\t{ 14\ttitle: \u0026#39;test product\u0026#39;, 15\tprice: 13.5, 16\tdescription: \u0026#39;lorem ipsum set\u0026#39;, 17\timage: \u0026#39;https://i.pravatar.cc\u0026#39;, 18\tcategory: \u0026#39;electronic\u0026#39; 19\t} 20\t`) 21 22 // یک درخواست یه ادرس سرور میسازیم 23 req, err := http.NewRequest(\u0026#34;POST\u0026#34;, url, bytes.NewBuffer(jsonStr)) 24 if err != nil { 25 fmt.Println(err) 26 } 27 28 29 client := \u0026amp;http.Client{} 30 // درخواست را انجام میدهیم 31 resp, err := client.Do(req) 32 if err != nil { 33 fmt.Println(err) 34 } 35 defer resp.Body.Close() 36 37 // کد وضعیت و پاسخ سرور را چاپ میکنیم 38 fmt.Println(\u0026#34;Status:\u0026#34;, resp.Status) 39 fmt.Println(\u0026#34;Response:\u0026#34;, resp) 40} در صورت برابر بودن کد وضعیت با ۲۰۰ محصول ایجاد شده توسط شما با موفقیت ثبت شده است.\n5.9.5 DELETE request # در مرحله بعد به ایجاد یک درخواست DELETE و پاک کردن یک محصول از سرور میپردازیم:\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;net/http\u0026#34; 6) 7 8func main() { 9 // شماره محصول مورد نظر را در انتهای url اضافه میکنیم (طبق مستندات) 10 url := \u0026#34;https://fakestoreapi.com/products/1\u0026#34; 11 // یک درخواست با متد DELETE ایجاد میکنیم 12 req, err := http.NewRequest(\u0026#34;DELETE\u0026#34;, url, nil) 13 if err != nil { 14 fmt.Println(err) 15 } 16 client := \u0026amp;http.Client{} 17 // درخواست را به سرور ارسال میکنیم 18 resp, err := client.Do(req) 19 if err != nil { 20 fmt.Println(err) 21 } 22 defer resp.Body.Close() 23 // درصورت موفقیت آمیز بودن درخواست خروجی عدد 200 است 24 fmt.Println(\u0026#34;Status:\u0026#34;, resp.Status) 25} 5.9.6 PUT request # در مرحله بعد به ایجاد یک درخواست PUT و اپدیت کردن اطلاعات یک محصول میپردازیم:\n1package main 2 3import ( 4\t\u0026#34;bytes\u0026#34; 5\t\u0026#34;fmt\u0026#34; 6\t\u0026#34;net/http\u0026#34; 7) 8 9func main() { 10 // ایدی محول مورد نظر را به انتهای url اضافه میکنیم 11 url := \u0026#34;https://fakestoreapi.com/products/7\u0026#34; 12 13 // مقدار های جدید را برای اپدیت شدن وارد میکنیم 14 requestBody := []byte(` 15\t{ 16\ttitle: \u0026#39;test product\u0026#39;, 17\tprice: 13.5, 18\tdescription: \u0026#39;lorem ipsum set\u0026#39;, 19\timage: \u0026#39;https://i.pravatar.cc\u0026#39;, 20\tcategory: \u0026#39;electronic\u0026#39; 21\t} 22\t`) 23 ‍‍ // درخواست را ایجاد میکنیم 24 req, err := http.NewRequest(\u0026#34;PUT\u0026#34;, url, bytes.NewBuffer(requestBody)) 25 if err != nil { 26 fmt.Println(err) 27 return 28 } 29 30 31 client := \u0026amp;http.Client{} 32 // درخواست را به سرور ارسال میکنیم 33 resp, err := client.Do(req) 34 if err != nil { 35 fmt.Println(err) 36 return 37 } 38 defer resp.Body.Close() 39 40 // درصورت 200 بودن کد وضعیت اپدیت با موفقیت انجام شده. 41 fmt.Println(resp.StatusCode) 42} "},{"id":83,"href":"/chapter-5/go-quic-prtoocol/","title":"5.10 پروتکل quic","section":"فصل پنجم: برنامه نویسی شبکه با گو","content":"پروتکل quic یک پروتکل توسعه یافته توسط google است. این پروتکل برای امنیت و سرعت بیشتر توسعه داده شده است.\nپروتکل quic از UDP استفاده میکند و در لایه transport قرار میگیرد.\nاین پروتکل اجازه ایجاد چند کانکشن بصورت همزمان را فراهم میکنید و همچنین http/3 بر اساس این پروتکل طراحی و ایجاد شده است.\nچند مورد از ویژگی های کلیدی quic : ۱. ایجاد کانکشن سریع تر به دلیل اسفاده از udp. ۲. نیازی به دست دادن سه مرحله مثل tcp ندارد. ۳. بصورت پیش فرص از رمزنگاری استفاده میکند.\nدر ادامه با استفاده از یک پکیج خارجی به نام quic-go یک سرور ساده با این پروتکل ایجاد میکنیم و یک پیام به آن ارسال میکنیم (عملکرد سرور ما تنها برگرداندن همان متن یا به اصطلاحی echo کردن آن است)\nبرای شروع کار ابتدا نیاز داریم پکیج مورد نظر خود را نصب کنیم\nبا استفاده از دستور زیر: go get github.com/quic-go/quic-go\nبعد از اتمام مرحله نصب شروع به نوشتن کد سرور و کلاینت خود میکنیم.\n1package main 2 3import ( 4\t\u0026#34;context\u0026#34; 5\t\u0026#34;crypto/rand\u0026#34; 6\t\u0026#34;crypto/rsa\u0026#34; 7\t\u0026#34;crypto/tls\u0026#34; 8\t\u0026#34;crypto/x509\u0026#34; 9\t\u0026#34;encoding/pem\u0026#34; 10\t\u0026#34;fmt\u0026#34; 11\t\u0026#34;io\u0026#34; 12\t\u0026#34;log\u0026#34; 13\t\u0026#34;math/big\u0026#34; 14 15\t\u0026#34;github.com/quic-go/quic-go\u0026#34; 16) 17 18const addr = \u0026#34;localhost:4242\u0026#34; 19 20// the message we sent to server you can also change it! 21const message = \u0026#34;hello gifarsi!\u0026#34; 22 23// starting the server and call the client function. 24func main() { 25\tgo func() { log.Fatal(echoServer()) }() 26 27\terr := clientMain() 28\tif err != nil { 29\tpanic(err) 30\t} 31} 32 33// this function start our echo server 34func echoServer() error { 35 // make a new listner with quic 36\tlistener, err := quic.ListenAddr(addr, generateTLSConfig(), nil) 37\tif err != nil { 38\treturn err 39\t} 40 41 // accept incoming connections 42\tconn, err := listener.Accept(context.Background()) 43\tif err != nil { 44\treturn err 45\t} 46 47 // accept incoming streams 48\tstream, err := conn.AcceptStream(context.Background()) 49\tif err != nil { 50\tpanic(err) 51\t} 52 53\t// Echo using the loggingWriter 54\t_, err = io.Copy(loggingWriter{stream}, stream) 55\treturn err 56} 57 58// client function thah send the message to our server 59func clientMain() error { 60 // set up a tls config 61\ttlsConf := \u0026amp;tls.Config{ 62\tInsecureSkipVerify: true, 63\tNextProtos: []string{\u0026#34;quic-echo-example\u0026#34;}, 64\t} 65 // dial with our udp server 66\tconn, err := quic.DialAddr(context.Background(), addr, tlsConf, nil) 67\tif err != nil { 68\treturn err 69\t} 70 71 // opening a new stream from our connection 72\tstream, err := conn.OpenStreamSync(context.Background()) 73\tif err != nil { 74\treturn err 75\t} 76 77 // write the message over the stream 78\tfmt.Printf(\u0026#34;Client: Sending \u0026#39;%s\u0026#39;\\n\u0026#34;, message) 79\t_, err = stream.Write([]byte(message)) 80\tif err != nil { 81\treturn err 82\t} 83 84 // read and print incoming answer from server 85\tbuf := make([]byte, len(message)) 86\t_, err = io.ReadFull(stream, buf) 87\tif err != nil { 88\treturn err 89\t} 90\tfmt.Printf(\u0026#34;Client: Got \u0026#39;%s\u0026#39;\\n\u0026#34;, buf) 91 92\treturn nil 93} 94 95// A wrapper for io.Writer that also logs the message. 96type loggingWriter struct{ io.Writer } 97 98func (w loggingWriter) Write(b []byte) (int, error) { 99\tfmt.Printf(\u0026#34;Server: Got \u0026#39;%s\u0026#39;\\n\u0026#34;, string(b)) 100\treturn w.Writer.Write(b) 101} 102 103// Setup a bare-bones TLS config for the server 104func generateTLSConfig() *tls.Config { 105\tkey, err := rsa.GenerateKey(rand.Reader, 1024) 106\tif err != nil { 107\tpanic(err) 108\t} 109\ttemplate := x509.Certificate{SerialNumber: big.NewInt(1)} 110\tcertDER, err := x509.CreateCertificate(rand.Reader, \u0026amp;template, \u0026amp;template, \u0026amp;key.PublicKey, key) 111\tif err != nil { 112\tpanic(err) 113\t} 114\tkeyPEM := pem.EncodeToMemory(\u0026amp;pem.Block{Type: \u0026#34;RSA PRIVATE KEY\u0026#34;, Bytes: x509.MarshalPKCS1PrivateKey(key)}) 115\tcertPEM := pem.EncodeToMemory(\u0026amp;pem.Block{Type: \u0026#34;CERTIFICATE\u0026#34;, Bytes: certDER}) 116 117\ttlsCert, err := tls.X509KeyPair(certPEM, keyPEM) 118\tif err != nil { 119\tpanic(err) 120\t} 121\treturn \u0026amp;tls.Config{ 122\tCertificates: []tls.Certificate{tlsCert}, 123\tNextProtos: []string{\u0026#34;quic-echo-example\u0026#34;}, 124\t} 125} بعد از اتمام نوشتن کد های سرور میتوانیم کد خود را اجرا و تست کنیم\ngo run main.go\nخروجی لاگ های ما به این صورت خواهد بود :\n1Client: Sending \u0026#39;hello gifarsi!\u0026#39; 2Server: Got \u0026#39;hello gifarsi!\u0026#39; 3Client: Got \u0026#39;hello gifarsi!\u0026#39; در انتها توجه داشته باشید این یک مثال ساده از quic در گولنگ بود شما میتوانید با استفاده از همین پکیج سرور های کامل تر و پیچیده تر را توسعه دهید و همچنین با استفاده از quic-go/http3 یک سرور http3 توسعه دهید.\n"},{"id":84,"href":"/chapter-4/go-project-layout/","title":"4.26 ساختار پروژه","section":"فصل چهارم: مباحث پیشرفته","content":" 4.26.1 نمای کلی project-layout # این متن یک طرح اساسی برای پروژه‌های برنامه‌نویسی به زبان Go است. توجه داشته باشید که این طرح از نظر محتوا ساده است، زیرا فقط روی layout کلی تمرکز دارد و نه آنچه در داخل آن قرار دارد. همچنین ساده است هر چند که از نظر محتوی پیشرفته است ولی به جزئیات زیادی در مورد نحوه ساختاردهی بیشتر پروژه شما نمی‌پردازد. برای مثال، سعی نمی‌کند ساختار پروژه‌ای را با چیزی مانند Clean Architecture پوشش دهد. برای بررسی نمونه کدهای مشابه و مرجع این متن به این لینک مراجعه کنید. این یک استاندارد رسمی تعریف شده توسط تیم توسعه اصلی Go نیست. این مجموعه‌ای از الگوهای layout پروژه‌های رایج با سابقه و نوظهور در اکوسیستم Go است. برخی از این الگوها از بقیه محبوب‌تر هستند. همچنین دارای تعدادی بهبود کوچک همراه با چندین دایرکتوری پشتیبانی مشترک در هر برنامه واقعی به اندازه کافی بزرگ است. توجه داشته باشید که تیم اصلی Go مجموعه خوبی از دستورالعمل‌های عمومی در مورد ساختاردهی پروژه‌های Go و معنای آن برای پروژه شما هنگام وارد شدن و نصب آن ارائه می‌دهد. برای اطلاعات بیشتر، به صفحه Organizing a Go module در اسناد رسمی Go مراجعه کنید. این صفحه شامل الگوهای دایرکتوری داخلی و cmd (که در زیر توضیح داده شده است) و سایر اطلاعات مفید است. اگر در حال یادگیری Go هستید یا یک PoC یا یک پروژه ساده برای خودتان می‌سازید، این طرح پروژه بیش از حد پیچیده است. در عوض، با چیزی بسیار ساده شروع کنید (یک فایل main.go و go.mod بیش از اندازه کافی است). با پیشرفت پروژه، به خاطر داشته باشید که ساختاردهی مناسب کد شما بسیار مهم خواهد بود، در غیر این صورت در نهایت با یک کد نامرتب با وابستگی‌های پنهان (hidden dependencies) و global state زیادی مواجه خواهید شد. وقتی افراد بیشتری روی پروژه کار می‌کنند، به ساختار بیشتری نیاز خواهید داشت. در این زمان است که معرفی یک روش مشترک برای مدیریت بسته‌ها/کتابخانه‌ها اهمیت دارد. وقتی یک پروژه متن‌باز دارید یا می‌دانید که پروژه‌های دیگر کد را از مخزن پروژه شما وارد می‌کنند، آن زمان است که داشتن بسته‌ها و کدهای خصوصی (معادل internal) اهمیت دارد. repository را کپی کنید، آنچه را که نیاز دارید نگه دارید و بقیه را حذف کنید! فقط به این دلیل که وجود دارد، به این معنی نیست که باید از همه آن استفاده کنید. هیچ یک از این الگوها در هر پروژه‌ای استفاده نمی‌شوند. حتی الگوی vendor نیز universal نیست. با آمدن Go 1.14 در نهایت Go Modules برای production آماده شدند. از Go Modules استفاده کنید، مگر اینکه دلیل خاصی برای استفاده نکردن از آن‌ها داشته باشید و اگر اینطور است، نیازی به نگرانی در مورد $GOPATH و جایی که پروژه خود را قرار می‌دهید ندارید. فایل go.mod پایه در مخزن فرض می‌کند که پروژه شما در GitHub میزبانی می‌شود، اما این یک الزام نیست. module path می‌تواند هر چیزی باشد، اگرچه اولین جزء module path باید یک نقطه در نام خود داشته باشد (نسخه فعلی Go دیگر آن را اجباری نمی‌کند، اما اگر از نسخه‌های کمی قدیمی‌تر استفاده می‌کنید، تعجب نکنید اگر ساخت‌های شما بدون آن شکست بخورد). اگر می‌خواهید درباره آن بیشتر بدانید، به Issues 37554 و 32819مراجعه کنید. این طرح پروژه عمداً عمومی است و سعی نمی‌کند یک ساختار پکیج Go خاص را تحمیل کند. این یک تلاش مشترک است. اگر الگوی جدیدی مشاهده کردید یا فکر می‌کنید یکی از الگوهای موجود نیاز به به‌روزرسانی دارد، یک issue را باز کنید. اگر به کمک در مورد نام‌گذاری، قالب‌بندی و style نیاز دارید، ابتدا gofmt و staticcheck را اجرا کنید. linter استاندارد قبلی، golint، اکنون منسوخ شده است و نگهداری نمی‌شود؛ استفاده از یک linter در حال توسعه و نگهداری شده مانند staticcheck توصیه می‌شود. همچنین مطمئن شوید که این دستورالعمل‌ها و توصیه‌های Go code style را بخوانید:\nhttps://talks.golang.org/2014/names.slide https://golang.org/doc/effective_go.html#names https://blog.golang.org/package-names https://go.dev/wiki/CodeReviewComments Style guideline for Go packages (rakyll/JBD) برای اطلاعات بیشتر ، Go Project Layout را ببینید. اطلاعات بیشتر در مورد نامگذاری و سازماندهی بسته‌ها و همچنین سایر توصیه‌های ساختار کد: GopherCon EU 2018: Peter Bourgon-Best Practices for Industrial Programming GopherCon Russia 2018: Ashley McNamara + Brian Ketelsen - Go best practices. GopherCon 2017: Edward Muller-Go Anti-Patterns GopherCon 2018: Kat Zien - How Do You Structure Your Go Apps 4.25.2 دایرکتوری‌ها در Go # /cmd # این دایرکتوری شامل برنامه‌های اصلی پروژه شما است. نام هر دایرکتوری فرعی باید با نام برنامه اجرایی مطابقت داشته باشد (برای مثال، /cmd/myapp). از قرار دادن حجم کد زیاد در دایرکتوری برنامه خودداری کنید. اگر فکر می‌کنید این کد‌ها قابلیت وارد شدن و استفاده در پروژه‌های دیگر را دارد، باید در دایرکتوری /pkg قرار گیرد. اگر کد قابل استفاده مجدد نیست یا نمی‌خواهید دیگران از آن استفاده مجدد کنند، آن کد را در دایرکتوری /internal قرار دهید. تعجب خواهید کرد که دیگران چه کارهایی انجام می‌دهند، بنابراین در مورد اهداف خود صریح باشید! معمولاً یک تابع اصلی کوچک وجود دارد که کد را از دایرکتوری‌های /internal و /pkg وارد کرده و فراخوانی می‌کند و کار دیگری انجام نمی‌دهد. به‌عنوان‌مثال به دایرکتوری /cmd مراجعه کنید.\n/internal # شامل کد Private application و library code است. این کدی است که نمی‌خواهید دیگران آن را در برنامه‌ها یا کتابخانه‌های خود وارد کنند. توجه داشته باشید که این الگوی چیدمان توسط خود کامپایلر Go اعمال می‌شود. برای جزئیات بیشتر، Go 1.4 release notesرا ببینید. توجه داشته باشید که شما به دایرکتوری internal سطح بالا محدود نیستید. شما می‌توانید در هر سطحی از درخت پروژه خود بیش از یک دایرکتوری internal داشته باشید. به‌صورت اختیاری می‌توانید برای جدا کردن کد داخلی مشترک و غیرمشترک خود، کمی ساختار اضافی به بسته‌های داخلی (internal packages) خود اضافه کنید. این کار الزامی نیست (به ویژه برای پروژه‌های کوچک‌تر)، اما داشتن نشانه‌های بصری برای نشان دادن نحوه استفاده موردنظر package بسیار مناسب است. کد application واقعی شما می‌تواند در دایرکتوری /internal/app (مثلاً /internal/app/myapp) و کد مشترک بین آن برنامه‌ها در دایرکتوری /internal/pkg/ (مثلاً , /internal/pkg/myprivlib) قرار گیرد. شما از دایرکتوری‌های internal برای private کردن package‌ها استفاده می‌کنید. اگر یک package را داخل یک internal directory قرار دهید، بسته‌های دیگر نمی‌توانند آن را وارد کنند مگر اینکه یک جد مشترک (common ancestor) داشته باشند. این تنها دایرکتوری‌ای است که در مستندات Go نام برده شده و نحوه برخورد با آن توسط کامپایلر Go خاص و متفاوت است.\n/pkg # کد کتابخانه که امکان استفاده توسط برنامه‌های خارجی را دارد (به‌عنوان مثال، /pkg/mypubliclib). سایر پروژه‌ها این کتابخانه‌ها را import می‌کنند و انتظار کارکرد درست آنها را دارند، بنابراین قبل از قرار دادن چیزی در اینجا خوب فکر کنید :-) و توجه داشته باشید که internal directory، راه بهتری برای اطمینان از وارد نشدن private packages شماست، زیرا توسط Go اجرا می‌شود. دایرکتوری /pkgهمچنان راه خوبی برای بیان صریح این است که کد موجود در آن دایرکتوری برای استفاده توسط دیگران ایمن است. مقاله وبلاگ « I'll take pkg over internal» توسط Travis Jeffery، نمای کلی خوبی از دایرکتوری‌های pkg و internal و زمان‌هایی که استفاده از آنها منطقی است ارائه می‌دهد. همچنین این راهی برای گروه‌بندی کد Go در یک مکان است، زمانی که دایرکتوری اصلی شما حاوی بسیاری از اجزا و دایرکتوری‌های غیر Go باشد، این کار اجرای ابزارهای مختلف Go را آسان‌تر می‌کند (همانطور که در این سخنرانی‌ها ذکر شده است: Best Practices for Industrial Programming از GopherCon EU و GopherCon 2018: Kat Zien - How Do You Structure Your Go Apps و GoLab 2018 - Massimiliano Pippi - Project layout patterns in Go). اگر می‌خواهید ببینید کدام مخازن محبوب Go از این layout pattern پروژه استفاده می‌کنند، به دایرکتوری /pkg مراجعه کنید. این یک الگوی layout رایج است، اما به‌طور جهانی پذیرفته نشده است و برخی از اعضای جامعه Go آن را توصیه نمی‌کنند. اگر پروژه برنامه‌ی شما واقعاً کوچک است و جایی که لایه‌ی اضافی تودرتو بودن ارزش زیادی اضافه نمی‌کند، استفاده نکردن از آن اشکالی ندارد (مگر اینکه واقعاً بخواهید :-)). در مورد آن فکر کنید زمانی که پروژه به اندازه کافی بزرگ می شود و دایرکتوری اصلی شما شلوغ می شود (به خصوص اگر اجزای برنامه غیر Go زیادی دارید). ریشه‌های دایرکتوری pkg: کد منبع قدیمی Go برای بسته‌های خود از pkg استفاده می‌کرد و سپس پروژه‌های مختلف Go در جامعه شروع به کپی کردن این الگو کردند (برای درک بهتر به این توییت Brad Fitzpatrick مراجعه کنید).\n/vendor # وابستگی‌های برنامه (به‌صورت دستی یا توسط ابزار مدیریت وابستگی مورد علاقه شما مانند ویژگی جدید Go Modulesداخلی مدیریت می‌شود). دستور go mod vendor دایرکتوری vendor/ را برای شما ایجاد می‌کند. توجه داشته باشید که اگر از Go 1.14 استفاده نمی‌کنید که به صورت پیش‌فرض فعال است، ممکن است نیاز به اضافه کردن پرچم -mod=vendor به دستور go build خود داشته باشید. اگر در حال ساخت کتابخانه هستید، وابستگی‌های برنامه خود را commit نکنید. توجه داشته باشید که از Go 1.13 ، قابلیت module proxy نیز در Go فعال شد (که به طور پیش‌فرض از https://proxy.golang.org به عنوان سرور پراکسی ماژول خود استفاده می‌کند). برای اینکه ببینید آیا این قابلیت با تمام الزامات و محدودیت‌های شما مطابقت دارد، در اینجا بیشتر در مورد آن بخوانید. اگر اینطور باشد، اصلاً به دایرکتوری vendor نیاز نخواهید داشت.\n4.26.3 دایرکتوری‌های سرویس application # /api # مشخصات OpenAPI/Swagger، فایل‌های JSON schema، فایل‌های تعریف پروتکل. برای مثال به دایرکتوری /api/ مراجعه کنید.\n4.26.4 دایرکتوری‌های سرویس وب # اجزای خاص برنامه وب: static web assets و templateهای سمت سرور و SPAها.\n4.26.5 دایرکتوری‌های مشترک در application # /configs # قالب‌های فایل پیکربندی یا تنظیمات پیش‌فرض. فایل‌های قالب confd یا consul-template خود را اینجا قرار دهید.\n/init # پیکربندی‌های init سیستم (systemd، upstart، sysv) و process manager/supervisor (runit, supervisord).\n/scripts # اسکریپت‌هایی برای انجام عملیات‌های مختلف build, install, analysis و غیره. این اسکریپت‌ها Makefile سطح ریشه را کوچک و ساده نگه می‌دارند (به عنوان مثال،https://github.com/hashicorp/terraform/blob/main/Makefile). برای مثال به دایرکتوری scripts/ مراجعه کنید.\n/build # ‏برای Packaging و Continuous Integration\nپیکربندی‌ها و اسکریپت‌های package‌های ابری (AMI)، کانتینری (Docker)، سیستم‌عامل (deb، rpm، pkg) را در این دایرکتوری قرار دهید. /build # پیکربندی‌ها و اسکریپت‌های CI (travis، circle، drone) را در این دایرکتوری قرار دهید. توجه داشته باشید که برخی از ابزارهای CI (مانند Travis CI) در مورد مکان فایل‌های پیکربندی خود بسیار حساس هستند. سعی کنید فایل‌های پیکربندی را در دایرکتوری /build/ci قرار داده و آن‌ها را به مکانی که ابزارهای CI انتظار دارند (در صورت امکان) لینک کنید. /deployments # پیکربندی‌ها و قالب‌های deployment یا استقرار IaaS، PaaS، سیستم و orchestration کانتینر (dockerCompose, kubernetes/helm, terraform). توجه داشته باشید که در برخی از repoها (به ویژه برنامه‌هایی که با kubernetes استقرار می‌یابند) این دایرکتوری deploy/ نامیده می‌شود. /test # برنامه‌های تست خارجی اضافی و داده‌های تست. می‌توانید دایرکتوری test/ را به هر شکلی که می‌خواهید ساختار دهید. برای پروژه‌های بزرگ‌تر، داشتن یک زیردایرکتوری data منطقی است. برای مثال، می‌توانید test/testdata/ یا test/data/ را داشته باشید اگر نیاز دارید که Go آنچه در آن دایرکتوری است را نادیده بگیرد. توجه داشته باشید که Go همچنین دایرکتوری‌ها یا فایل‌هایی که با \u0026ldquo;.\u0026rdquo; یا \u0026quot;\u0026quot; شروع می‌شوند را نادیده می‌گیرد، بنابراین در نحوه نام‌گذاری دایرکتوری داده‌های تست خود انعطاف بیشتری دارید. برای نمونه‌ها به دایرکتوری test/مراجعه کنید. دایرکتوری‌های دیگر # اسناد طراحی و کاربر (علاوه بر مستندات ایجاد شده توسط godoc شما). برای مثال به دایرکتوری docs/ مراجعه کنید.\n/tools # ابزارهای پشتیبانی این پروژه توجه داشته باشید که این ابزارها می توانند کد را از دایرکتوری های pkg/ و internal/ وارد کنند. برای مثال به دایرکتوری tools/ مراجعه کنید.\n/examples # نمونه‌هایی برای application و یا کتابخانه‌های public شما. برای مثال به دایرکتوری examples/ مراجعه کنید.\n/third_party # ابزارهای کمکی خارجی، کد fork شده و سایر ابزارهای شخص ثالث (مانند Swagger UI).\n/githooks # برای Git hooks.\n/assets # سایر assetها برای همراهی با repository شما (image, logoها و غیره).\n/website # اگر از GitHub pages استفاده نمی‌کنید، اینجا مکانی است که می توانید داده‌های وب‌سایت پروژه خود را قرار دهید. برای مثال به دایرکتوری website/مراجعه کنید.\nدایرکتوری‌هایی که نباید داشته باشید # /src # برخی از پروژه‌های Go دارای یک پوشه src هستند، اما این معمولاً زمانی اتفاق می‌افتد که توسعه‌دهندگان از دنیای جاوا آمده‌اند که در آنجا یک الگوی رایج است. اگر می‌توانید، سعی کنید این الگوی جاوا را نپذیرید. شما واقعاً نمی‌خواهید که کد Go یا پروژه‌های Go شما شبیه جاوا به نظر برسند :-) دایرکتوری /src در سطح پروژه را با دایرکتوری /src که Go برای کارگاه‌های خود استفاده می‌کند، اشتباه نگیرید که در How to Write Go Code توضیح داده شده است. $GOPATH environment variable به (current) workspace فعلی شما اشاره می‌کند (به طور پیش‌فرض به $HOME/go در سیستم‌های غیر ویندوزی اشاره می‌کند). این workspace شامل دایرکتوری‌های سطح بالا /pkg, /bin و /src است. پروژه واقعی شما در نهایت یک زیردایرکتوری زیر /src می‌شود، بنابراین اگر دایرکتوری /src را در پروژه خود دارید، مسیر پروژه به این شکل خواهد بود: /some/path/to/workspace/src/your_project/src/your_code.go. توجه داشته باشید که با Go 1.11 امکان دارد پروژه خود را خارج از GOPATH خود داشته باشید، اما این هنوز به معنای این نیست که استفاده از این الگوی layout pattern ایده خوبی است.\n4.26.6 بررسی Badgeها # ‏ Go Report Card کد شما را با gofmt، go vet، gocyclo، golint، ineffassign، مجوز و غلط املایی اسکن می کند. مرجع پروژه خود را جایگزین github.com/golang-standards/project-layout کنید. ‏ GoDoc این نسخه آنلاین اسناد تولید شده GoDoc شما را ارائه می‌دهد. link را تغییر دهید تا به پروژه شما اشاره کند. ‏ Pkg.go.dev ‏ Pkg.go.dev مقصد جدیدی برای شناسایی و مستندات Go است. می‌توانید با استفاده از badge generation toolآن را ایجاد کنید. در مورد Release - آخرین شماره انتشار پروژه شما را نشان می دهد. لینک github را تغییر دهید تا به پروژه شما اشاره کند.\n4.26.8 نکته‌ها # یک الگوی پروژه با نظر بیشتر با تنظیمات sample/reusable استفاده مجدد، اسکریپت‌ها و کد یک WIP است.\n"},{"id":85,"href":"/chapter-6/","title":"فصل ششم: ژنریک ها (Generics)","section":"صفحه اصلی","content":"در این بخش قصد داریم به بحث ژنریک ها بپردازیم که از نسخه go1.18 اضافه شد که تقریبا یکی از اساسی ترین تغییرات در سینتکس زبان گو بود و در قالب یک پروپوزال ارائه شد و سپس از نسخه ۱.۱۸ منتشر شد و تا الان تغییرات و بهبودهای زیادی داشته است.\nژنریک به زبان برنامه‌نویسی امکانات مهمی اضافه می‌کند:\nپارامترهای نوع برای توابع و انواع داده: با ژنریک، می‌توانید توابع و انواع داده‌ای را با پارامترهای نوع مخصوص بسازید. به این ترتیب می‌توانید یک تابع یا یک نوع داده را برای کار با انواع مختلف داده تعریف کنید.\nتعریف انواع رابط به عنوان مجموعه‌ای از انواع: با ژنریک، می‌توانید انواع اینترفیس را به عنوان مجموعه‌هایی از انواع تعریف کنید، حتی انواعی که متدهای خاصی ندارند. این به شما امکان می‌دهد تا انواع داده‌ای را به عنوان پارامترها در تعریف اینترفیس‌ها استفاده کنید.\nاستفاده از استنباط نوع (Type Inference): ژنریک اجازه می‌دهد که در بسیاری از موارد، پارامترهای نوع را در فراخوانی توابع حذف کنید. به این ترتیب کد شما ساده‌تر و خواناتر می‌شود و نیازی به تعیین دقیق نوع در همه جا ندارید.\nنکات کاربردی\nزمانی از ژنریک ها استفاده کنید که کدهای شما فقط با تغییر تایپ در حال تکرار است آنجا شما می توانید از ژنریک ها برای کاهش کد خود کمک بگیرید. از ژنریک ها می توانید برای کاهش Assertion اینترفیس ها استفاده کنید. با اینکه ژنریک یک ویژگی خوب است اما استفاده زیاد باعث پیچیدگی و سربار حافظه خواهد شد. ژنریک چیست؟ # ژنریک یک ویژگی مهم در Go است که به شما این امکان را می‌دهد تا کدهای کلی و قابل استفاده مجدد بنویسید بدون اینکه به تایپ‌های خاصی محدود شوید. به عبارت ساده‌تر، با ژنریک می‌توانید توابع و ساختارهای داده را بنویسید که با انواع مختلف داده‌ها کار کنند.\nبه عنوان مثال، فرض کنید یک تابع بخواهید بنویسید که دو عدد را با هم جمع کند. بدون استفاده از ژنریک، شما باید تابع‌های مجزایی برای جمع دو عدد از نوع مختلف (مثلاً عدد صحیح و عدد اعشاری) بنویسید. اما با ژنریک، می‌توانید یک تابع جمع کننده عمومی بنویسید که با هر نوع داده‌ای کار کند.\nدر اصطلاحات Go، از انواع نمادگذاری ژنریک می‌کنیم. این انواع می‌توانند به صورت متغیر باشند و از آن‌ها در تابع‌ها و ساختارهای داده استفاده کنید تا کدی ایجاد کنید که قابل استفاده با انواع مختلف داده‌ها باشد.\nاز مزیت‌های ژنریک در Go می‌توان به کاهش تکرار کد، افزایش قابلیت خوانایی کد و افزایش انعطاف‌پذیری برنامه اشاره کرد. با استفاده از این قابلیت، می‌توانید کدهای بهینه‌تری بنویسید و طراحی بهتری داشته باشید.\nبنابراین، ژنریک در Go به شما این امکان را می‌دهد که کدهای کلی‌تر و کاربردی‌تری بنویسید که با انواع مختلف داده‌ها سازگار باشند و به عنوان یک توسعه‌دهنده جوان، این ابزار قدرتمند را در توسعه نرم‌افزار‌های خود بهره‌بری کنید.\n"},{"id":86,"href":"/chapter-6/go-generics-basic/","title":"6.1 مقدمه و اهمیت ژنریک‌ها","section":"فصل ششم: ژنریک ها (Generics)","content":"ایده ژنریک (Generics) به مفهوم برنامه‌نویسی پارامتری (Parametric Polymorphism) برمی‌گردد؛ یعنی نوشتن توابع، کلاس‌ها یا انواعی که با انواع مختلف داده کار کنند بدون اینکه برای هر نوع داده، پیاده‌سازی مجزایی لازم باشد. این مفهوم در علوم کامپیوتر از دهه ۱۹۷۰ مطرح بود و به تدریج به زبان‌های اصلی برنامه‌نویسی راه یافت.\nنقش کلیدی David R. Musser و Alexander A. Stepanov # دو نفر از پیشگامان و پژوهشگران مهم این حوزه، David R. Musser و Alexander A. Stepanov هستند. آن‌ها در دهه ۸۰ و ۹۰ میلادی پژوهش‌هایی درباره طراحی و پیاده‌سازی الگوریتم‌های ژنریک انجام دادند.\nیکی از مهم‌ترین مقالات آن‌ها:\n“Generic Programming” نوشته شده توسط Alexander Stepanov و David Musser منتشر شده در سال 1988، کتابچه International Seminar on Generic Programming لینک مقاله در Springer در این مقاله، آن‌ها ایده \u0026ldquo;برنامه‌نویسی ژنریک\u0026rdquo; را فراتر از الگوهای تابعی (functional patterns) و شی‌گرا معرفی کردند و تأثیر زیادی بر طراحی استانداردهای زبان‌های بعدی داشتند.\nStepanov بعداً به عنوان طراح اصلی STL (Standard Template Library) در ++C شناخته شد که یکی از اولین پیاده‌سازی‌های موفق و پرکاربرد ژنریک در سطح صنعتی بود.\n۶.۱.۱ چرا ژنریک‌ها؟ (مشکلات توسعه بدون ژنریک) # در برنامه‌نویسی، بارها نیاز پیدا می‌کنیم یک الگوریتم یا ساختار داده را برای انواع مختلف داده بنویسیم؛ مثلاً مرتب‌سازی یک لیست از اعداد صحیح، لیست رشته‌ها یا هر نوع دیگری.\nدر زبان‌هایی که ژنریک (Generic) ندارند یا قبل از اضافه شدن ژنریک به Go، این نیاز به چند روش رفع می‌شد که هر کدام معایب و مشکلات جدی داشتند:\nالف) کپی‌برداری و تکرار کد # برای هر نوع داده یک نسخه جداگانه از کد می‌نوشتیم.\nمثلاً یک تابع برای []int، یکی برای []string و\u0026hellip;\nاین کار باعث می‌شد:\nحجم کد زیاد شود (Boilerplate) نگهداری سخت شود (هر تغییری باید در چند جا انجام شود) احتمال بروز باگ بیشتر شود مثال:\n1func MaxInt(a, b int) int { 2 if a \u0026gt; b { 3 return a 4 } 5 return b 6} 7 8func MaxFloat64(a, b float64) float64 { 9 if a \u0026gt; b { 10 return a 11 } 12 return b 13} ب) استفاده از interface{} و بازتاب (Reflect) # راه دوم، استفاده از نوع همه‌کاره‌ی interface{} و بازتاب (reflect) بود:\n1func Max(a, b interface{}) interface{} { 2 // مقایسه به کمک reflect یا type assertion 3 // کد پیچیده و کند می‌شود 4} معایب:\nکاهش خوانایی و ایمنی کد (Type Safety) نبود هشدار کامپایلری برای ناسازگاری انواع کندی اجرا به دلیل استفاده از بازتاب ج) مشکل Type Safety و تولید کد ضعیف # کدهای مبتنی بر interface{} می‌توانند در اجرا دچار panic شوند و خطاهای type را فقط در runtime نشان دهند.\nخلاصه مشکلات بدون ژنریک # تکرار و افزونگی کد سختی نگهداری و توسعه کاهش ایمنی نوعی (type safety) افت کارایی (performance) بالا رفتن احتمال بروز باگ ۶.۱.۲ تاریخچه و سیر تکامل ژنریک‌ها در Go # از ابتدای طراحی زبان Go، توسعه‌دهندگان زیادی خواهان قابلیت ژنریک بودند تا بتوانند الگوریتم‌ها و ساختارهای داده را به صورت type-safe و بدون تکرار بنویسند.\nاما تیم توسعه Go به دلایل مختلف (ساده نگه‌داشتن زبان، اجتناب از پیچیدگی‌های اضافی و دغدغه‌های کارایی) این قابلیت را تا مدت‌ها به تعویق انداخت.\nمراحل مهم در مسیر ژنریک در Go: # قبل از Go 1.18:\nهیچ پشتیبانی رسمی از ژنریک وجود نداشت؛ برنامه‌نویسان ناچار به استفاده از راه‌حل‌های غیراستاندارد بودند (تکرار کد، interface{}، بازتاب و \u0026hellip;). پیشنهادهای اولیه:\nاز سال ۲۰۱۰ تا ۲۰۲۰، چندین طرح پیشنهادی برای اضافه‌کردن ژنریک مطرح شد که برخی به‌خاطر پیچیدگی یا ناسازگاری با فلسفه Go رد شدند. Go 1.18 (مارس ۲۰۲۲):\nانقلاب بزرگ!\nپشتیبانی رسمی از ژنریک اضافه شد: معرفی type parameter تعریف constraint و type set امکان تعریف توابع و انواع ژنریک با سینتکس ساده و خوانا حفظ سرعت کامپایل و کارایی اجرایی Go 1.21 (۲۰۲۳):\nاضافه شدن constraintهای جدید مثل cmp.Ordered Go 1.24 (۲۰۲۵):\nاضافه‌شدن Generic Type Alias (امکان alias برای نوع و constraint ژنریک) Go 1.25 (۲۰۲۵):\nحذف مفهوم core type و ساده‌تر شدن قواعد زبان برای genericها (طبق مستندات جدید و Go Blog). ۶.۱.۳ کاربردهای رایج ژنریک‌ها در برنامه‌نویسی مدرن # ژنریک‌ها در عمل، برای حل مسائلی به کار می‌روند که نیاز به بازاستفاده کد و ایمنی نوعی بالا دارند. مهم‌ترین کاربردها:\nالف) ساختارهای داده‌ی عمومی # مثل Stack, Queue, List, Map و\u0026hellip; که باید با انواع مختلف داده کار کنند:\n1type Stack[T any] struct { 2 data []T 3} 4func (s *Stack[T]) Push(val T) { s.data = append(s.data, val) } 5func (s *Stack[T]) Pop() T { /* ... */ } این ساختار را می‌توانید برای هر نوعی (int, string, struct و \u0026hellip;) به کار ببرید:\n1var intStack Stack[int] 2var strStack Stack[string] ب) الگوریتم‌های عمومی # مانند مرتب‌سازی، جست‌وجو، فیلتر و \u0026hellip;\n1func Filter[T any](list []T, f func(T) bool) []T { 2 var res []T 3 for _, v := range list { 4 if f(v) { res = append(res, v) } 5 } 6 return res 7} ج) کتابخانه‌های عمومی و بازمتن # توسعه کتابخانه‌هایی که کاربران مختلف با داده‌های دلخواه‌شان به سادگی از آن استفاده کنند (مانند slices, maps و \u0026hellip; در استاندارد Go).\nد) ساخت abstraction و معماری ماژولار # امکان پیاده‌سازی اینترفیس‌ها و abstractionهای سطح بالا به صورت type-safe و قابل استفاده برای انواع مختلف.\nه) افزایش خوانایی و نگهداری کد # ژنریک‌ها باعث می‌شوند کد کوتاه‌تر، خواناتر و تغییرپذیرتر شود و توسعه‌دهنده فقط یکبار کد را پیاده‌سازی و همه‌جا استفاده کند.\nنمونه واقعی از کتابخانه استاندارد Go:\nکتابخانه slices (از Go 1.21) دارای توابع ژنریک برای کار با انواع slice:\n1import \u0026#34;slices\u0026#34; 2 3ints := []int{1, 2, 3} 4slices.Reverse(ints) // بدون نیاز به کپی کد ۶.۱.4 مرور تغییرات عملکردی ژنریک‌ها در Go # از نسخه‌ی Go 1.18 تا نسخه‌ی کنونی، چند تغییر کلیدی در عملکرد (Performance) ژنریک‌ها رخ داده که در ادامه بررسی دقیق و مستند آن‌ها را ارائه می‌دهم:\n🔹 Go 1.18 – ورود ژنریک؛ اثر بر سرعت کامپایل و اجرا # کند شدن کامپایل تا 15٪ نسبت به Go 1.17 به دلیل اضافه‌شدن چک‌های نوعی ژنریک و type checker جدید (tip.golang.org, InfoQ). عملکرد اجرا (runtime) بدون تغییر محسوسی باقی ماند، چون کد ژنریک از نوع monomorphization جزئی (dictionary-based) است و روی runtime overhead تاثیری نمی‌گذارد (InfoQ). 🔹 Go 1.19 – بهبود عملکرد ژنریک‌ها # بروزرسانی‌های ابزار کامپایل، runtime و حافظه بهینه‌سازی شده. تا 20٪ بهبود در سرعت برخی برنامه‌های ژنریک گزارش شده است . تیم Go تغییراتی در memory model انجام داد تا کارایی GC نیز بهبود یابد، که به‌ویژه در ترکیب با ژنریک‌ها مفید بود . 🔹 Go 1.20 – بهبود سرعت کامپایل و اجرا # رفع regressions قبلی: سرعت build به سطح Go 1.17 بازگشت (تا 10٪ سریع‌تر نسبت به 1.19) (tip.golang.org). بهبود جزئی در \u0026ldquo;generated code performance\u0026rdquo; نسبت به 1.19 (tip.golang.org). امکان فعال‌سازی Profile-Guided Optimization (PGO) برای بهینه‌سازی‌های inline در call-sites ارائه شد، که می‌تواند به اجرای سریع‌تر ژنریک‌ها منجر شود (tip.golang.org). بررسی جنبه‌های تاثیرگذار بر عملکرد # ۱. قواعد Dictionary-based مونومورفی‌سازی # Go از تکنیک جزئی مونومورفی‌سازی به وسیله ‌GCShape و دیکشنری استفاده می‌کند. این روش مقداری overhead در سربار lookup برای methodها ایجاد می‌کند، به ویژه اگر پارامتر نوع، interface باشد .\n۲. تأخیر در lookup برای methodهای اینترفیسی # مقایسه benchmarking‌ نشان داد:\n1BenchmarkFooIFace: 5.38 ns/op 2BenchmarkFooGeneric: 14.33 ns/op یعنی استفاده از ژنریک ~2.6 برابر کندتر از فراخوانی مستقیم interface است (deepsource.com).\n۳. تأثیر بر توسعه‌دهی و بهبودهای آینده # توسعه کامپایلر Go در نسخه‌های بعدی احتمالاً نرخ مونومورفی‌سازی و inlining را بهبود می‌دهد . به‌روزرسانی‌ها در Go 1.21+ و αισوب esperanza تعریف generic interfaces نیز چنین پیشرفت‌هایی را تسهیل می‌کنند. "},{"id":87,"href":"/chapter-6/go-generics-fundamentals/","title":"6.2 مبانی ژنریک‌ها در Go","section":"فصل ششم: ژنریک ها (Generics)","content":" ۶.۲.۱ تعریف ژنریک (Generic) چیست؟ # ژنریک (Generic) به معنی \u0026ldquo;کلی\u0026rdquo;، \u0026ldquo;عام\u0026rdquo; یا \u0026ldquo;نوع‌پذیر\u0026rdquo; است؛ مفهومی که به شما امکان می‌دهد یک تابع، نوع داده یا ساختار را به گونه‌ای بنویسید که با انواع مختلف داده‌ها کار کند، بدون اینکه برای هر نوع، پیاده‌سازی جداگانه لازم باشد.\nبه بیان دیگر، ژنریک‌ها قابلیتی برای بازاستفاده امن و بهینه از کد در سطح زبان برنامه‌نویسی هستند.\nیه جمله ای از Ian lancer tailor هست:\nزمانی باید از جنریک استفاده کرد که کد شما بواسطه تغییر تایپ تکرار می شود یا اینکه برای کاهش assertion از جنریک استفاده کنیم.\nکاربرد ژنریک: # فرض کنید می‌خواهید یک تابع برای پیدا کردن مقدار بیشینه در یک آرایه بنویسید.\nدر حالت عادی باید برای هر نوع داده (int، float64، string و \u0026hellip;) یک نسخه بنویسید یا از interface{} استفاده کنید که معایب زیادی دارد.\nژنریک‌ها این محدودیت را برطرف می‌کنند و به شما اجازه می‌دهند که فقط یک بار منطق را بنویسید و برای هر نوع داده‌ای از آن استفاده کنید.\nنمونه ساده:\n1// یک تابع ژنریک برای بازگرداندن بیشینه دو مقدار از هر نوع مرتب‌شونده 2func Max[T cmp.Ordered](a, b T) T { 3 if a \u0026gt; b { 4 return a 5 } 6 return b 7} اینجا [T cmp.Ordered] می‌گوید T می‌تواند هر نوعی باشد که قابلیت مقایسه داشته باشد (int، float64، string و \u0026hellip;).\nویژگی اصلی ژنریک: # تعریف توابع و ساختارهای عمومی (generic) که به صورت type-safe با انواع مختلف کار می‌کنند. کاهش چشمگیر تکرار کد (DRY) ارتقاء خوانایی و نگهداری کد بهبود کارایی نسبت به روش‌های مبتنی بر interface{} و بازتاب (reflect) ۶.۲.۲ واژگان کلیدی ژنریک در Go # درک مفاهیم کلیدی ژنریک در Go برای استفاده صحیح و حرفه‌ای ضروری است:\n۱. Type Parameter (پارامتر نوع) # متغیری است که نوع داده را به صورت پارامتریک مشخص می‌کند. در تعریف تابع یا نوع ژنریک درون کروشه قرار می‌گیرد. مثال:\n1func Print[T any](item T) { 2 fmt.Println(item) 3 } ۲. Constraint (قید/محدودیت) # محدودیتی که مشخص می‌کند پارامتر نوع (T) باید چه ویژگی‌هایی داشته باشد. معمولاً یک اینترفیس است که نوع موردنظر باید آن را پیاده‌سازی کند یا عضو مجموعه‌ای از انواع باشد. مثال:\n1 func Sum[T Number](a, b T) T { ... } 2 type Number interface { 3 int | int64 | float64 4 } ۳. Type Set (مجموعه نوع) # مجموعه‌ای از انواع که یک constraint آن‌ها را مجاز می‌داند.\nدر Go، type set معمولاً به صورت union تعریف می‌شود (مثلاً int | float64)\nدر constraintهای مبتنی بر اینترفیس می‌توانید ترکیبی از method و type را تعیین کنید:\n1type Stringer interface { 2 String() string 3} 4type Numeric interface { 5 int | int64 | float64 6} ۴. Type Inference (استنتاج نوع) # فرآیندی که در آن کامپایلر Go می‌تواند پارامتر نوع را به صورت خودکار از روی ورودی‌های تابع یا نوع، حدس بزند. مثال:\n1 Max(10, 20) // T به طور خودکار int فرض می‌شود 2 Max(2.5, 3.8) // T به طور خودکار float64 فرض می‌شود ۵. Constraint Interface (اینترفیس محدودکننده) # اینترفیس‌هایی که هم می‌توانند method داشته باشند هم مجموعه‌ای از انواع را مشخص کنند. مثال:\n1type Constraint interface { 2 ~[]byte | ~string 3 Hash() uint64 4} ۶. any و comparable # any: معادل interface{}، یعنی هر نوعی را مجاز می‌داند. comparable: فقط نوع‌هایی که قابل مقایسه با == و != هستند را می‌پذیرد (برای map key و غیره). ۶.۲.۳ تفاوت ژنریک‌های Go با سایر زبان‌ها (Java، C#، Rust و \u0026hellip;) # ژنریک‌ها مفهومی جهانی هستند، اما نحوه پیاده‌سازی و امکانات آن‌ها در زبان‌های مختلف متفاوت است. در اینجا برخی تفاوت‌های کلیدی آورده شده است:\nالف) سینتکس و سادگی # ژنریک‌های Go به صورت پارامتر نوع در کروشه [] تعریف می‌شوند:\n1func Swap[T any](a, b T) (T, T) در Java و C#: پارامتر نوع با \u0026lt;\u0026gt; تعریف می‌شود:\n1public \u0026lt;T\u0026gt; void swap(T a, T b) ب) Type Constraint # Go امکان تعریف محدودیت (constraint) به شکل بسیار قوی و صریح با اینترفیس یا مجموعه نوع دارد. در Java، فقط می‌توانید یک superclass یا interface به عنوان محدودیت تعریف کنید. در Rust، با trait bounds، و در C# با constraints (مثل where T: struct). ج) Type Erasure vs. Monomorphization # در Java، پیاده‌سازی ژنریک‌ها با Type Erasure است؛ یعنی اطلاعات نوع ژنریک در زمان اجرا حذف می‌شود و فقط در زمان کامپایل کنترل می‌شود. در Go (و Rust و ++C)، ژنریک‌ها با Monomorphization پیاده‌سازی می‌شوند؛ یعنی برای هر نوع داده، کد جداگانه‌ای در زمان کامپایل تولید می‌شود (به معنای ایمنی و کارایی بالاتر). C# هم از رویکرد متفاوتی بهره می‌برد که در برخی موارد closer به monomorphization است. د) پشتیبانی از عملیات # در Go می‌توانید union type تعریف کنید (مثلاً int | float64) در Java این امکان وجود ندارد و باید فقط به یک superclass یا interface محدود کنید. ه) Specialization و Reflection # Go ژنریک‌ها را به صورت type-safe و بدون بازتاب (reflect) اجرا می‌کند، در حالی که در زبان‌هایی مثل Python و حتی Java، بخشی از قدرت ژنریک‌ها وابسته به بازتاب است. Rust و ++C هم مانند Go، اجرا را type-safe و بدون reflect انجام می‌دهند. و) تفاوت در قابلیت‌ها # در Go، ژنریک‌ها روی function, struct و interface قابل اعمال هستند. در Rust و ++C حتی macroها و traitهای پیچیده‌تر و specializationهای سطح پایین‌تر ممکن است. در Java و C#، برخی ویژگی‌ها مانند generic constructor یا wildcard support متفاوت‌اند. "},{"id":88,"href":"/chapter-6/go-generics-syntax-and-structure/","title":"6.3 سینتکس و ساختار ژنریک‌ها در Go","section":"فصل ششم: ژنریک ها (Generics)","content":" ۶.۳.۱ تعریف تابع ژنریک (Generic Functions) # در Go از نسخه ۱.۱۸، می‌توانید توابعی بنویسید که به‌جای نوع خاص، با نوع پارامتری کار می‌کنند. پارامترهای نوعی (type parameters) در کروشه [] بعد از نام تابع قرار می‌گیرند.\nنمونه سینتکس: # 1func Swap[T any](a, b T) (T, T) { 2 return b, a 3} T پارامتر نوعی است که می‌تواند هر نوعی را بپذیرد (در اینجا با constraint any).\nتابع بالا می‌تواند برای هر نوعی (int، string، ساختار دلخواه و \u0026hellip;) فراخوانی شود:\n1a, b := Swap[int](1, 2) // خروجی: 2, 1 2x, y := Swap[string](\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;) // خروجی: \u0026#34;b\u0026#34;, \u0026#34;a\u0026#34; Type Inference: معمولاً Go نوع را به طور خودکار تشخیص می‌دهد و نیازی به ذکر [int] نیست:\n1s, t := Swap(\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;) با constraint (محدودیت نوع): # 1func Max[T cmp.Ordered](a, b T) T { 2 if a \u0026gt; b { 3 return a 4 } 5 return b 6} در اینجا فقط انواع مرتب‌شونده (int, float64, string, \u0026hellip;) مجاز هستند.\n۶.۳.۲ تعریف نوع (Type) ژنریک (Generic Types) # شما می‌توانید struct، slice، map یا هر نوع داده دلخواه را به صورت ژنریک تعریف کنید تا برای انواع مختلف قابل استفاده باشد.\nمثال Struct ژنریک: # 1type Box[T any] struct { 2 Value T 3} اکنون می‌توانید Box را برای هر نوعی استفاده کنید:\n1var intBox Box[int] 2intBox.Value = 42 3 4var strBox Box[string] 5strBox.Value = \u0026#34;Go!\u0026#34; مثال عملی – Stack ژنریک: # 1type Stack[T any] struct { 2 items []T 3} 4 5func (s *Stack[T]) Push(item T) { 6 s.items = append(s.items, item) 7} 8 9func (s *Stack[T]) Pop() (T, bool) { 10 if len(s.items) == 0 { 11 var zero T 12 return zero, false 13 } 14 idx := len(s.items) - 1 15 item := s.items[idx] 16 s.items = s.items[:idx] 17 return item, true 18} این ساختار را می‌توانید برای int، string، struct دلخواه و \u0026hellip; به کار ببرید.\n۶.۳.۳ تعریف اینترفیس ژنریک (Generic Interfaces) # از Go 1.18+، می‌توانید interfaceهایی با پارامتر نوع بنویسید. این امکان بسیار قدرتمند است و اجازه abstraction و تعریف constraintهای پیچیده را می‌دهد.\nنمونه سینتکس: # 1type Equaler[T any] interface { 2 Equal(T) bool 3} هر نوعی که متد Equal(T) bool داشته باشد می‌تواند پیاده‌ساز این اینترفیس باشد. مثال – Set ژنریک: # 1type Set[E any] interface { 2 Insert(E) 3 Delete(E) 4 Has(E) bool 5} اکنون می‌توانید انواع مختلف Set برای انواع داده متفاوت پیاده‌سازی کنید. Constraint ژنریک مبتنی بر متد: # 1type Comparer[T any] interface { 2 Compare(T) int 3} این الگو به شما اجازه می‌دهد فقط با انواعی کار کنید که متد Compare دارند. نکته کاربردی: تعریف constraintها و abstractionهای پیشرفته با استفاده از generic interface در نسخه‌های جدید Go (به ویژه Go 1.21+ و Go 1.24) بسیار ساده و قدرتمند شده است.\n۶.۳.۴ استفاده همزمان از چند پارامتر نوع (Multiple Type Parameters) # گاهی لازم است تابع یا نوعی بنویسید که با چند نوع مختلف سر و کار دارد.\nنمونه سینتکس: # 1func CopyMap[K comparable, V any](m map[K]V) map[K]V { 2 newMap := make(map[K]V) 3 for k, v := range m { 4 newMap[k] = v 5 } 6 return newMap 7} اینجا K کلیدهایی است که باید قابل مقایسه باشند (comparable)، و V می‌تواند هر نوعی باشد. مثال Struct با چند پارامتر نوع: # 1type Pair[A, B any] struct { 2 First A 3 Second B 4} می‌توانید انواع مختلف را جفت کنید:\n1p := Pair[int, string]{First: 1, Second: \u0026#34;Go\u0026#34;} ۶.۳.۵ معرفی و کاربرد Generic Type Alias (جدید در Go 1.24) # در نسخه ۱.۲۴ Go، امکان تعریف type alias برای انواع ژنریک اضافه شد که نقش بسیار مهمی در خوانایی، بازاستفاده و ماژولار کردن کد دارد.\n۶.۳.۵.۱ تفاوت Type Alias معمولی و ژنریک # تا قبل از Go 1.24، فقط می‌توانستید برای انواع غیرژنریک alias تعریف کنید:\n1type MyInt = int از Go 1.24، می‌توانید برای انواع ژنریک هم alias بسازید:\n1type Box[T any] struct{ Value T } 2type IntBox = Box[int] // نوع IntBox معادل Box[int] است ۶.۳.۵.۲ کاربردهای عملی Generic Type Alias # کاهش تکرار کد و ساده‌تر شدن refactoring\nتعریف alias برای توابع ژنریک، constraintها، و حتی mapها و channelهای ژنریک:\n1type StringMap[V any] = map[string]V 2type UserChan = chan User تمیز و خواناتر شدن APIها و لایه abstraction:\n1type ConfigMap = map[string]string ۶.۳.۵.۳ بهترین شیوه‌های نام‌گذاری و ضدالگوها # نام‌های گویا و معنادار انتخاب کنید؛\n❌ بد:\n1 type X = Box[int] ✅ خوب:\n1type UserIDBox = Box[int] از aliasهای تو در تو و بیش از حد بپرهیزید؛ فقط برای کدهایی که واقعاً تکرار می‌شوند و نیاز به abstraction دارند استفاده کنید. ۶.۳.۶ حذف Core Type در Go 1.25 و تأثیر آن بر ژنریک‌ها # در نسخه‌های اولیه ژنریک Go، مفهومی به نام core type وجود داشت که تعیین می‌کرد یک type parameter در زمان compile-time به چه underlying type‌ای ارجاع داده می‌شود. این مفهوم باعث پیچیدگی و محدودیت در برخی عملیات‌ها (مانند index، slice و \u0026hellip;) شده بود.\nاز Go 1.25 به بعد:\ncore type از استاندارد حذف شد و قواعد هر عملیات به صورت واضح‌تر و مستقل بیان شد. خوانایی و سادگی زبان افزایش یافت و پیام‌های خطا شفاف‌تر شدند. حالا فقط کافی است برای عملیات مورد نظر constraint درست تعریف شود (مثلاً اگر با map کار می‌کنید باید comparable باشد). "},{"id":89,"href":"/chapter-6/go-generics-type-sets-and-constraints/","title":"6.4 Constraints و Type Sets","section":"فصل ششم: ژنریک ها (Generics)","content":" ۶.۴.۱ مفهوم constraint و نقش آن در ژنریک‌ها # Constraint (قید یا محدودیت) در ژنریک‌های Go ابزاری است برای کنترل اینکه یک پارامتر نوعی (type parameter) باید چه ویژگی‌هایی داشته باشد.\nبدون constraint، هر نوعی می‌تواند جایگزین شود، اما با تعریف constraint، دایره‌ی مجاز را محدود می‌کنیم تا هم ایمنی نوعی بالا رود و هم امکانات بیشتری برای پیاده‌سازی داشته باشیم.\nنقش constraint: # جلوگیری از استفاده نادرست از ژنریک‌ها (مثلاً استفاده از عملیات غیرمجاز روی نوع پارامتری) افزایش قابلیت تشخیص خطا در زمان کامپایل امکان تعریف abstractionهای قوی‌تر مثال ساده:\n1func Sum[T Number](a, b T) T { return a + b } 2type Number interface { int | float64 } در این مثال، فقط انواعی که در constraint Number تعریف شده‌اند، مجاز هستند.\n۶.۴.۲ interface constraint و مثال‌های کاربردی # در Go، constraint معمولاً به صورت یک interface بیان می‌شود؛ این interface می‌تواند شامل متدها یا ترکیبی از انواع (type sets) باشد.\nمثال: constraint مبتنی بر متد # 1type Stringer interface { 2 String() string 3} 4 5func PrintString[T Stringer](v T) { 6 fmt.Println(v.String()) 7} هر نوعی که متد String() string را داشته باشد (مثلاً time.Time یا type خودتان)، می‌تواند برای این تابع استفاده شود.\nمثال: constraint مبتنی بر type set (union) # 1type Numeric interface { int | int64 | float64 } 2func Max[T Numeric](a, b T) T { 3 if a \u0026gt; b { 4 return a 5 } 6 return b 7} فقط انواع عددی مجاز به استفاده از Max هستند.\nمثال: ترکیبی # 1type ByteString interface { 2 ~[]byte | ~string 3} 4func FirstChar[T ByteString](s T) byte { 5 return s[0] 6} هر نوعی که underlying آن []byte یا string باشد، مجاز است.\n۶.۴.۳ استفاده از کلیدواژه‌های any، comparable و Ordered # Go چندین constraint از پیش تعریف‌شده دارد:\nany # معادل interface{}، یعنی هیچ محدودیتی وجود ندارد:\n1func Identity[T any](v T) T { return v } comparable # فقط نوع‌هایی که می‌توان با == یا != مقایسه کرد (برای map key یا مجموعه‌ها):\n1func Contains[T comparable](slice []T, v T) bool { 2 for _, item := range slice { 3 if item == v { 4 return true 5 } 6 } 7 return false 8} Ordered (از پکیج cmp، Go 1.21+) # برای انواعی که می‌توان از \u0026lt;, \u0026gt;, \u0026lt;=, \u0026gt;= استفاده کرد (int, float, string):\n1 import \u0026#34;cmp\u0026#34; 2 func Min[T cmp.Ordered](a, b T) T { 3 if a \u0026lt; b { 4 return a 5 } 6 return b 7 } ۶.۴.۴ ساخت constraint سفارشی و ترکیبی (union constraints) # شما می‌توانید constraint دلخواه بسازید و انواع مختلف را در یک مجموعه (type set) قرار دهید:\nمثال: # 1type IDType interface { 2 int | int64 | string 3} 4func ParseID[T IDType](v T) string { 5 return fmt.Sprintf(\u0026#34;%v\u0026#34;, v) 6} می‌توانید متد هم به آن اضافه کنید:\n1type ToStringer interface { 2 ~string | ~[]byte 3 ToString() string 4} نکته مهم: # علامت ~ در Go به این معنی است که نوع مورد نظر باید underlying type مشخص‌شده را داشته باشد (مثلاً نوع تعریف‌شده‌ای که underlying آن string باشد).\nدر Go 1.24 به بعد می‌توانید حتی constraint alias تعریف کنید:\n1type Num = interface{ int | float64 } ۶.۴.۵ Generic Interfaces و قابلیت‌های جدید (بر اساس Go 1.21+ و 1.24) # ژنتریک اینترفیس‌ها (Generic Interfaces) از Go 1.18 امکان‌پذیر شد و در نسخه‌های جدید، قابلیت‌های قوی‌تری یافته است.\n۶.۴.۵.۱ پیاده‌سازی الگوهای abstraction با interface ژنریک # می‌توانید abstractionهایی بسازید که به طور کلی روی انواع مختلف اعمال شوند:\n1type Comparer[T any] interface { 2 Compare(T) int 3} 4 5type Sortable[T Comparer[T]] []T 6 7func (s Sortable[T]) Sort() { 8 sort.Slice(s, func(i, j int) bool { 9 return s[i].Compare(s[j]) \u0026lt; 0 10 }) 11} هر نوعی که متد Compare(T) int را داشته باشد، قابل استفاده است. این قابلیت قدرت abstraction و توسعه کتابخانه‌های عمومی را به شدت افزایش داده است. ۶.۴.۵.۲ نکات و چالش‌های پیشرفته (مثلاً مسأله pointer receivers و type inference) # الف) pointer receivers:\nگاهی constraint روی اینترفیس باید به نوع pointer باشد تا متدهای دریافت‌کننده (receiver) به درستی کار کند.\nاگر متدها روی pointer تعریف شده باشند، باید pointer به عنوان نوع پارامتر بدهید:\n1type Setter[T any] interface { 2 Set(T) 3} 4func Update[T any, S Setter[T]](s S, v T) { s.Set(v) } ب) type inference در چند پارامتر:\nدر برخی موارد که چندین type parameter وجود دارد (مثلاً برای abstractionهای پیچیده یا ترکیب چند constraint)، ممکن است inference نوع پیچیده شود و لازم باشد type parameters را به صراحت مشخص کنید.\nج) مقایسه با زبان‌های دیگر:\nدر Go سعی شده تا حد امکان inference ساده و شفاف باشد، اما در abstractionهای خیلی پیچیده (مانند ژنریک تو در تو، pointer receivers یا interface embedding) ممکن است خوانایی امضاها (signature) کمی سخت شود، به خصوص برای توسعه‌دهندگان تازه‌کار.\nد) نکته تولیدی:\nتا حد امکان constraintها را ساده، گویا و خوانا نگه دارید. constraintهای ترکیبی و abstractionهای ژنریک را فقط زمانی به کار ببرید که واقعاً نیاز است و مستندسازی کافی داشته باشید.\n۶.۴.۶ بررسی عمیق constraints در Go # در Go، هرچقدر آزادی در انتخاب نوع پارامتر بیشتر شود، قدرت استفاده از آن کمتر خواهد بود. بنابراین، از محدودیت‌های دقیق برای افزایش قابلیت‌های ژنریک‌ها استفاده می‌کنیم. در واقع، به جای [T any]، باید constraint مناسب انتخاب شود که کامپایلر بداند چه عملیاتی روی T مجاز است.\nقاعده کلی: هرچه interface یا constraint بزرگ‌تر باشد، abstraction ضعیف‌تر است.\n✅ چرا [T any] محدودیت دارد؟ # با تعریف تابع ساده مثل:\n1func Add[T any](a, b T) T { 2 return a + b 3} کامپایلر Go خطا می‌دهد چون از T any نمی‌داند آیا T قابلیت عملگر + را دارد یا خیر. بنابراین نمی‌تواند کدی را که معتبر باشد تولید کند. این نشان می‌دهد که آزادی بیش از حد باعث حذف قابلیت‌های مهم می‌شود.\nانواع constraint در Go # ۱. Basic Interface Constraint (محدودیت بر پایه متد) # این نوع constraint شامل متدهایی است که باید توسط نوع پیاده‌سازی شود.\nمثال:\n1func Stringify[T fmt.Stringer](v T) string { 2 return v.String() 3} اینجا کامپایلر می‌داند که v متدی به نام String() دارد، بنابراین می‌تواند آن را بدون خطا اجرا کند.\n۲. Type Set Constraint (محدودیت لیستی برای عملگرها) # برای استفاده از عملگرهایی مثل +، باید T را محدود کنیم تا مجموعه‌ای از انواع مشخص باشد:\n1type Numeric interface { int | int64 | float64 } 2 3func Add[T Numeric](a, b T) T { 4 return a + b 5} اکنون کامپایلر تضمین می‌دهد که T حتماً یکی از انواع عددی است و عمل + معتبر خواهد بود.\nهمچنین برای اجازه استفاده از ~ برای پذیرش زیرنوع‌ها:\n1type Intish interface { ~int } ۳. ترکیب محدودیت‌ها # می‌توان constraintهایی ساخت که چند محدودیت را همزمان اعمال کنند، مثلاً متد و عملگر:\n1type ReadStringer interface { 2 fmt.Stringer 3 io.Reader 4 ~[]byte | ~string 5} این محدودیت بیان می‌کند که T باید هم String() داشته باشد، هم Read() اجرا کند، و نوع underlying آن []byte یا string باشد.\n🔑 اهمیت و پیامدها # خوانایی و اطمینان بالا:\nبا محدود کردن دقیق T تنها به انواعی که عملیات مورد نظر را دارند، از بروز خطا جلوگیری می‌کنید.\nکارایی بدون overhead:\nچون کامپایلر می‌داند دقیقاً چه عملیاتی مجاز است، نیازی به reflect یا بررسی در runtime نیست.\nارتقاء abstraction:\nتعریف سلسله‌مراتبی از constraintها مانند Numeric, Ordered، یا ReadStringer امکان reuse و خوانایی بالاتر کد را فراهم می‌کند.\n"},{"id":90,"href":"/chapter-6/go-generics-examples-and-practical/","title":"6.5 مثال‌ها و کاربردهای عملی ژنریک‌ها","section":"فصل ششم: ژنریک ها (Generics)","content":" ۶.۵.۱ توابع ژنریک متداول (مانند Min, Max, Map, Filter) # تابع Min و Max # 1import \u0026#34;cmp\u0026#34; // از Go 1.21+ 2 3func Min[T cmp.Ordered](a, b T) T { 4 if a \u0026lt; b { 5 return a 6 } 7 return b 8} 9 10func Max[T cmp.Ordered](a, b T) T { 11 if a \u0026gt; b { 12 return a 13 } 14 return b 15} توضیح:\nاین دو تابع ژنریک به شما اجازه می‌دهند با هر نوع داده‌ای که قابل مقایسه با عملگرهای بزرگ‌تر/کوچک‌تر باشد (مثل int، float64، string و\u0026hellip;) بیشینه یا کمینه دو مقدار را به دست آورید. پارامتر نوعی T باید قید cmp.Ordered را داشته باشد تا عملیات مقایسه مجاز باشد. این ساختار به جای نوشتن نسخه‌های تکراری برای هر نوع داده، یک تابع عمومی و امن ایجاد می‌کند.\nتابع Map (اعمال تابع روی عناصر یک لیست) # 1func Map[T any, R any](input []T, fn func(T) R) []R { 2 result := make([]R, len(input)) 3 for i, v := range input { 4 result[i] = fn(v) 5 } 6 return result 7} توضیح:\nاین تابع یک لیست (input) را می‌گیرد و یک تابع (fn) را روی هر عنصر آن اجرا می‌کند و خروجی‌های تابع را به عنوان لیست جدید بازمی‌گرداند. نوع ورودی (T) و خروجی (R) کاملاً ژنریک هستند و می‌توانید هر تبدیل یا پردازشی را با این الگو روی لیست‌های خود انجام دهید، مثلاً مربع اعداد، تبدیل عدد به رشته و غیره.\nتابع Filter (فیلتر کردن عناصر یک لیست) # 1func Filter[T any](input []T, pred func(T) bool) []T { 2 var result []T 3 for _, v := range input { 4 if pred(v) { 5 result = append(result, v) 6 } 7 } 8 return result 9} توضیح:\nتابع Filter یک لیست و یک تابع شرطی (predicate) می‌گیرد و تنها عناصر لیست را که شرط روی آن‌ها برقرار است، انتخاب و در یک لیست جدید بازمی‌گرداند. این کار باعث می‌شود بدون تکرار کد برای هر نوع داده، فیلترهای قدرتمند و ایمن داشته باشید (مثلاً استخراج فقط اعداد زوج یا رشته‌هایی با طول خاص).\n۶.۵.۲ ساختارهای داده ژنریک (Stack، Queue، List و \u0026hellip;) # Stack ژنریک # 1type Stack[T any] struct { 2 data []T 3} 4 5func (s *Stack[T]) Push(val T) { 6 s.data = append(s.data, val) 7} 8 9func (s *Stack[T]) Pop() (T, bool) { 10 if len(s.data) == 0 { 11 var zero T 12 return zero, false 13 } 14 last := len(s.data) - 1 15 val := s.data[last] 16 s.data = s.data[:last] 17 return val, true 18} توضیح:\nاین کد یک ساختار داده پشته (Stack) را به صورت ژنریک پیاده‌سازی می‌کند؛ یعنی می‌توانید هر نوع داده‌ای را در پشته ذخیره کنید. متد Push یک مقدار جدید به انتهای پشته اضافه می‌کند و Pop مقدار آخر را حذف و بازمی‌گرداند. اگر پشته خالی باشد، مقدار صفر نوع داده (zero value) برگردانده می‌شود. این پیاده‌سازی قابلیت استفاده برای int، string یا حتی structهای پیچیده را دارد.\nQueue ژنریک # 1type Queue[T any] struct { 2 data []T 3} 4 5func (q *Queue[T]) Enqueue(val T) { 6 q.data = append(q.data, val) 7} 8 9func (q *Queue[T]) Dequeue() (T, bool) { 10 if len(q.data) == 0 { 11 var zero T 12 return zero, false 13 } 14 val := q.data[0] 15 q.data = q.data[1:] 16 return val, true 17} توضیح:\nکد بالا یک صف (Queue) ژنریک را پیاده‌سازی می‌کند که برای هر نوع داده‌ای قابل استفاده است. متد Enqueue عنصر جدیدی را به انتهای صف اضافه می‌کند و Dequeue عنصر ابتدای صف را حذف و بازمی‌گرداند. اگر صف خالی باشد، مقدار صفر نوع داده برگردانده می‌شود. این الگو برای مدیریت صف درخواست‌ها یا پیام‌ها با هر نوع داده‌ای بسیار کاربردی است.\nList ژنریک # 1type List[T any] struct { 2 items []T 3} 4 5func (l *List[T]) Add(val T) { 6 l.items = append(l.items, val) 7} 8 9func (l *List[T]) Get(index int) (T, bool) { 10 if index \u0026lt; 0 || index \u0026gt;= len(l.items) { 11 var zero T 12 return zero, false 13 } 14 return l.items[index], true 15} توضیح:\nاین ساختار یک لیست ساده ژنریک است که می‌توانید هر نوع داده‌ای را به آن اضافه یا با اندیس بازیابی کنید. متد Add برای افزودن و Get برای دریافت مقدار در اندیس دلخواه (همراه با بررسی بازه ایمن) استفاده می‌شود. این ساختار می‌تواند پایه ساخت کلکسیون‌ها و آرایه‌های سفارشی در پروژه‌های بزرگ‌تر باشد.\n۶.۵.۳ ترکیب ژنریک با سایر ویژگی‌های Go (کانال‌ها، مپ‌ها و اینترفیس‌ها) # Channel ژنریک # 1type Chan[T any] chan T 2 3func Producer[T any](out Chan[T], vals ...T) { 4 for _, v := range vals { 5 out \u0026lt;- v 6 } 7 close(out) 8} توضیح:\nدر این مثال، نوع کانال (Channel) به صورت ژنریک تعریف شده است، یعنی می‌توانید کانال ارسال/دریافت داده برای هر نوعی بسازید. تابع Producer داده‌های ورودی را به کانال می‌فرستد و در پایان آن را می‌بندد. این الگو برای پردازش موازی و همزمان داده‌ها در معماری‌های concurrent و pipeline بسیار مناسب است.\nMap ژنریک با constraint # 1func Keys[K comparable, V any](m map[K]V) []K { 2 keys := make([]K, 0, len(m)) 3 for k := range m { 4 keys = append(keys, k) 5 } 6 return keys 7} توضیح:\nتابع Keys یک map را می‌گیرد و لیستی از کلیدهای آن را بازمی‌گرداند. نوع کلید باید قابل مقایسه باشد (comparable)، چون mapهای Go فقط با کلیدهای قابل مقایسه کار می‌کنند. این تابع برای استخراج سریع و type-safe کلیدهای هر map بسیار مفید است.\nاینترفیس ژنریک و abstraction # 1type Repository[T any] interface { 2 FindByID(id int) (T, error) 3 Save(entity T) error 4} 5 6type User struct{ Name string } 7 8type UserRepo struct{ data map[int]User } 9 10func (r *UserRepo) FindByID(id int) (User, error) { 11 u, ok := r.data[id] 12 if !ok { 13 return User{}, errors.New(\u0026#34;not found\u0026#34;) 14 } 15 return u, nil 16} 17func (r *UserRepo) Save(entity User) error { 18 r.data[len(r.data)] = entity 19 return nil 20} توضیح:\nدر این مثال، یک اینترفیس ژنریک برای مخزن داده (Repository) تعریف شده است که می‌تواند برای هر نوع داده (مثلاً User) پیاده‌سازی شود. متدهای FindByID و Save عملیات بازیابی و ذخیره را type-safe انجام می‌دهند. این الگو پایه معماری clean و قابل توسعه برای لایه داده در پروژه‌های تولیدی است.\n۶.۵.۴ نمونه‌های تولیدی و پروژه‌ای (از کدهای واقعی و کاربردی) # سرویس کش ژنریک # 1type Cache[K comparable, V any] struct { 2 data map[K]V 3} 4 5func NewCache[K comparable, V any]() *Cache[K, V] { 6 return \u0026amp;Cache[K, V]{data: make(map[K]V)} 7} 8 9func (c *Cache[K, V]) Set(key K, value V) { 10 c.data[key] = value 11} 12 13func (c *Cache[K, V]) Get(key K) (V, bool) { 14 v, ok := c.data[key] 15 return v, ok 16} توضیح:\nدر اینجا یک سرویس کش (Cache) به صورت ژنریک پیاده‌سازی شده که برای هر نوع کلید (comparable) و هر نوع مقدار قابل استفاده است. با استفاده از این ساختار می‌توانید بدون تکرار کد برای انواع مختلف داده، کش‌های بهینه و امن بسازید که در پروژه‌های واقعی (مثلاً کش کاربر، تنظیمات یا داده‌های session) بسیار کاربردی است.\nPipeline ژنریک برای پردازش داده‌ها # 1func Pipeline[T any](data []T, stages ...func([]T) []T) []T { 2 for _, stage := range stages { 3 data = stage(data) 4 } 5 return data 6} توضیح:\nتابع Pipeline به شما امکان می‌دهد زنجیره‌ای از مراحل پردازش (stages) را روی لیست داده اجرا کنید. هر مرحله یک تابع است که لیست را می‌گیرد و خروجی پردازش را بازمی‌گرداند. این الگو برای پردازش داده‌های بزرگ، تحلیل داده یا پیاده‌سازی الگوهای data pipeline در سیستم‌های تولیدی بسیار ارزشمند است.\n"},{"id":91,"href":"/chapter-6/comparing-generics/","title":"6.6 مقایسه ژنریک‌ها با راهکارهای قبل از Go 1.18","section":"فصل ششم: ژنریک ها (Generics)","content":" ۶.۶.۱ استفاده از interface{} و reflect قبل از ژنریک‌ها # پیش از Go 1.18، برای پیاده‌سازی توابع یا ساختارهای داده عمومی، معمولاً از نوع interface{} (نوع همه‌کاره) استفاده می‌شد.\nدر موارد نیاز به عملیات خاص یا تبدیل نوع، ناچار به استفاده از reflect یا type assertion بودیم. این روش‌ها معایب و ریسک‌های خاص خود را داشتند.\nمثال: تابع Max با interface{} و reflect # 1import ( 2 \u0026#34;fmt\u0026#34; 3 \u0026#34;reflect\u0026#34; 4) 5 6func Max(a, b interface{}) interface{} { 7 av := reflect.ValueOf(a) 8 bv := reflect.ValueOf(b) 9 10 if av.Kind() == reflect.Int \u0026amp;\u0026amp; bv.Kind() == reflect.Int { 11 if av.Int() \u0026gt; bv.Int() { 12 return a 13 } 14 return b 15 } 16 // می‌توانید برای انواع دیگر هم کد بنویسید 17 return nil 18} 19 20func main() { 21 fmt.Println(Max(3, 7)) // خروجی: 7 22} توضیح:\nدر این مثال تابع Max با هر نوعی که به آن بدهید کار می‌کند، اما باید به کمک reflect نوع مقدار را بررسی و مقایسه کنید. این کار هم کند است و هم ایمنی نوعی ندارد و در زمان اجرا ممکن است باعث panic یا رفتار ناخواسته شود.\n۶.۶.۲ مزایا و معایب هر روش # interface{} و reflect (روش قدیمی) # مزایا:\nقابلیت انعطاف برای پذیرش هر نوع داده (generic ظاهر) قابل استفاده در زبان‌های قبل از Go 1.18 معایب:\nکاهش ایمنی نوعی (Type Safety): خطاهای نوع فقط در زمان اجرا کشف می‌شوند. پیچیدگی و خوانایی پایین: بررسی نوع با reflect یا type assertion باعث طولانی و پیچیده شدن کد می‌شود. افت کارایی: بازتاب (reflect) کند است و فراخوانی‌های زیاد باعث overhead می‌شود. خطر panic: اگر نوع داده اشتباه ارسال شود، احتمال panic بالا می‌رود. عدم هشدار کامپایلری: هیچ هشدار یا خطایی از سمت کامپایلر دریافت نمی‌کنید. تست و نگهداری دشوار: تست و اشکال‌زدایی کدهایی که مبتنی بر interface{} و reflect هستند به مراتب سخت‌تر است. ژِنریک‌های Go (از 1.18 به بعد) # مزایا:\nایمنی نوعی بالا: همه خطاهای نوع در زمان کامپایل مشخص می‌شوند. کد کوتاه‌تر و خواناتر: نیاز به تکرار تابع برای هر نوع داده نیست و بازتاب حذف می‌شود. کارایی بهتر: هیچ overhead ناشی از reflect یا type assertion وجود ندارد و کد تولیدشده شبیه کد دستی است. نگهداری آسان‌تر: refactoring راحت‌تر و تست‌پذیری بالاتر مستندسازی خودکار و بهتر: امضاهای توابع و structها واضح و قابل فهم برای توسعه‌دهندگان و ابزارهاست. معایب:\nنیاز به نسخه جدید Go: فقط در Go 1.18 به بعد قابل استفاده است. درک اولیه برای توسعه‌دهندگان تازه‌کار ممکن است کمی زمان‌بر باشد. در برخی موارد خاص (مانند ژنریک اینترفیس‌های خیلی پیچیده)، امضاها می‌تواند کمی پیچیده شود. ۶.۶.۳ مقایسه کارایی، خوانایی و نگهداشت # ویژگی interface{} و reflect (قدیمی) ژنریک‌های Go (جدید) ایمنی نوع بسیار پایین (خطر panic بالا) بسیار بالا (compile-time checked) خوانایی پایین و پیچیده (reflect و assert) بالا و شفاف (type-safe) کارایی کند (overhead بازتاب) سریع (مانند کد معمولی) نگهداری دشوار و پرخطا آسان و قابل refactor تست‌پذیری سخت (خطاهای run-time) بسیار آسان (خطاهای compile-time) کد تکراری زیاد (اگر برای هر نوع دستی بنویسید) حداقل (یک بار برای همه انواع) "},{"id":92,"href":"/chapter-6/limitations-errors-and-anti-patterns-in-generics/","title":"6.7 محدودیت‌ها، خطاها و ضدالگوها در ژنریک‌ها","section":"فصل ششم: ژنریک ها (Generics)","content":" ۶.۷.۱ محدودیت‌های فعلی ژنریک‌ها در Go (Compile-time \u0026amp; Runtime) # اگرچه ژنریک‌ها قابلیت فوق‌العاده‌ای به Go افزوده‌اند، اما هنوز با برخی محدودیت‌های فنی و زبانی روبه‌رو هستند که باید حتماً در پروژه‌های جدی مدنظر قرار گیرد:\nمحدودیت‌های زمان کامپایل (Compile-time) # عدم پشتیبانی از عملیات ریاضی یا منطقی روی هر نوع دلخواه:\nفقط انواعی که قید مناسب (مانند cmp.Ordered یا union خاص) دارند می‌توانند با عملگرهای مقایسه یا ریاضی استفاده شوند.\nعدم امکان specialization:\nبرخلاف ++C یا Rust، نمی‌توانید نسخه خاصی از تابع یا struct برای نوعی خاص پیاده‌سازی کنید (Specialization).\nمحدودیت روی method set:\nاگر یک type parameter با interface constraint تعریف شود، فقط به متدهای آن constraint دسترسی دارید، حتی اگر نوع واقعی متدهای بیشتری داشته باشد.\nمحدودیت در تعریف type embedding ژنریک:\nهنوز نمی‌توانید یک struct ژنریک را به عنوان فیلد ناشناس (anonymous field) در struct دیگر embed کنید.\nعدم پشتیبانی از const type parameters:\nمثل ++C و Rust، نمی‌توانید مقدار ثابت را به عنوان پارامتر ژنریک تعیین کنید (مثلاً سایز آرایه).\nمحدودیت‌های زمان اجرا (Runtime) # عدم دسترسی به اطلاعات نوع پارامتر در runtime:\nپارامترهای نوع در زمان اجرا قابل شناسایی نیستند و امکان reflection مستقیم روی آن‌ها وجود ندارد.\nخطاهای مرتبط با nil و zero value:\nبازگرداندن مقدار صفر (zero value) برای نوع پارامتریک ممکن است همیشه با منطق کسب‌وکار شما منطبق نباشد.\n۶.۷.۲ خطاها و پیام‌های رایج در استفاده از ژنریک‌ها # در استفاده از ژنریک‌های Go، با برخی پیام‌های خطا و اشکالات رایج مواجه خواهید شد:\nپیام‌های متداول کامپایلر # \u0026ldquo;type T does not satisfy constraint C\u0026rdquo;\nیعنی نوع مورد استفاده تمام ویژگی‌های constraint را ندارد.\n\u0026ldquo;invalid operation: operator X not defined for T\u0026rdquo;\nعملگری روی نوع پارامتریک استفاده شده که constraint اجازه نمی‌دهد.\n\u0026ldquo;cannot use T as type K in map: T does not implement comparable\u0026rdquo;\nبرای map، کلید باید حتماً comparable باشد.\n\u0026ldquo;cannot infer T\u0026rdquo; یا \u0026ldquo;type parameter T cannot be inferred\u0026rdquo;\nکامپایلر قادر به استنتاج نوع پارامتر نیست و باید صراحتاً نوع را تعیین کنید.\n\u0026ldquo;instantiation cycle\u0026rdquo;\nارجاع بازگشتی نادرست یا پیاده‌سازی ضدالگو در constraintها باعث این خطا می‌شود.\nمثال واقعی خطا: # 1func PrintMapKeys[K comparable, V any](m map[K]V) { 2 for k := range m { 3 fmt.Println(k) 4 } 5} 6 7PrintMapKeys(map[[]int]int{}) // error: []int does not implement comparable ۶.۷.۳ ضدالگوها (Anti-patterns) و اشتباهات متداول # برخی از رفتارها یا کدهای غلط که باید در استفاده از ژنریک‌ها از آن‌ها پرهیز کنید:\n۱. استفاده بیش از حد از any یا constraint بسیار کلی # این کار ایمنی نوعی را کاهش می‌دهد و ژنریک عملاً مانند interface{} عمل می‌کند.\n1func BadFunc[T any](v T) { /* ... */ } // تقریبا مثل استفاده از interface{} ۲. پیاده‌سازی تابع یا struct ژنریک بدون نیاز واقعی # اگر فقط برای یک نوع خاص استفاده می‌کنید، نیاز به ژنریک ندارید و فقط پیچیدگی ایجاد کرده‌اید.\n۳. بازگرداندن zero value به‌جای error handling # اگر pop روی stack ژنریک خالی انجام شود، صرف بازگرداندن zero value ممکن است باعث بروز باگ پنهان شود؛ بهتر است مقدار بولین یا error نیز بازگردانده شود.\n۴. constraintهای بسیار پیچیده یا ناخوانا # استفاده از چندین interface یا unionهای تو در تو، امضای تابع را گیج‌کننده می‌کند و نگهداری را سخت می‌سازد.\n۵. وابستگی زیاد به type assertion یا reflect # اگر در کد ژنریک زیاد مجبور به type assertion شدید، نشانه این است که abstraction شما صحیح یا idiomatic نیست.\n۶. تعریف و استفاده از type alias بی‌معنا یا بی‌هدف # تعریف alias برای انواع ژنریک بدون هدف مشخص، باعث ابهام و پیچیدگی در پروژه می‌شود.\n۶.۷.۴ نکات مربوط به versionهای جدید (مانند مشکلات Migration و backward compatibility) # مشکلات مهاجرت (Migration) # اگر کتابخانه یا کد قدیمی با interface{} نوشته شده باشد، مهاجرت به ژنریک نیازمند refactoring است. تغییر امضاهای توابع و structها ممکن است باعث شکستن سازگاری با کد قدیمی (backward compatibility) شود. برخی ابزارها و کتابخانه‌های شخص ثالث ممکن است از ژنریک به‌درستی پشتیبانی نکنند یا هنوز به نسخه‌های قدیمی Go محدود باشند. مسائل سازگاری نسخه (Backward Compatibility) # کدی که با ژنریک نوشته شده فقط روی Go 1.18+ اجرا می‌شود. در برخی نسخه‌های جدیدتر Go (مثلاً 1.24 یا 1.25)، امکانات بیشتری مثل generic type alias و بهبود constraintها اضافه شده که استفاده از آن‌ها ممکن است برای پروژه‌های multi-version مشکل‌ساز شود. برخی قابلیت‌ها (مانند حذف core type در Go 1.25) باعث ساده‌تر شدن توسعه ولی تغییر در قواعد قدیمی شده‌اند. نکته های بیلد: # برای حفظ سازگاری نسخه و کاهش ریسک migration:\nامضاهای جدید را با مستندسازی مناسب تغییر دهید. در صورت نیاز از build tag یا نسخه‌بندی ماژول استفاده کنید. همیشه تست‌های unit و integration را قبل و بعد از migration اجرا کنید. "},{"id":93,"href":"/chapter-6/generics-best-practice/","title":"6.8 بهترین شیوه‌های استفاده از ژنریک‌ها (Best Practices)","section":"فصل ششم: ژنریک ها (Generics)","content":"در این بخش، به‌صورت حرفه‌ای، کاربردی و تجربی، بهترین شیوه‌های استفاده از ژنریک‌ها در پروژه‌های Go را همراه با نکات تولیدی و فنی ارائه می‌دهم.\n۶.۸.۱ راهنمای تصمیم‌گیری: چه زمانی ژنریک؟ چه زمانی نه؟ # ژنریک‌ها ابزار قدرتمندی هستند، اما استفاده درست و هوشمندانه از آن‌ها حیاتی است.\nبهتر است ژنریک را فقط زمانی به کار ببرید که:\nیک منطق تکراری برای چندین نوع مختلف وجود دارد و پیاده‌سازی جداگانه برای هر نوع باعث تکرار و دشواری نگهداری می‌شود. نیاز به abstraction و توسعه‌پذیری کد برای آینده وجود دارد، مانند ساختار داده‌ها (Stack, Queue, Map)، یا توابع عمومی (Map, Filter, Reduce). ایمنی نوعی (Type Safety) برایتان مهم است و می‌خواهید خطاها را در زمان کامپایل متوجه شوید. چه زمانی ژنریک استفاده نکنیم؟\nزمانی که فقط برای یک یا دو نوع خاص کد می‌نویسید و abstraction عمومی نیاز ندارید. اگر استفاده از ژنریک خوانایی کد را پایین می‌آورد یا امضای تابع/ساختار بسیار پیچیده می‌شود. اگر abstraction شما منجر به over-engineering یا کد غیرضروری می‌شود. زمانی که عملکرد (performance) بسیار بحرانی است و بنچمارک‌ها نشان می‌دهند که نسخه معمولی سریع‌تر است. نکته:\nهمیشه قبل از ژنریک‌سازی، با کد ساده و معمولی شروع کنید و اگر نیاز به تعمیم و بازاستفاده پیش آمد، refactor به ژنریک انجام دهید.\n۶.۸.۲ نکات خوانایی، نگهداشت‌پذیری و توسعه‌پذیری # نام‌گذاری واضح برای پارامتر نوع:\nاز نام‌های معنادار (مثلاً T برای Type، K برای Key، V برای Value) استفاده کنید و در موارد پیچیده‌تر، نام دقیق‌تر (مثلاً User, IDType) انتخاب کنید.\nconstraintها را تا حد امکان ساده نگه دارید:\nاز any یا constraintهای بیش از حد کلی فقط زمانی استفاده کنید که واقعاً نیاز است.\nتوابع و ساختارهای ژنریک را مستند کنید:\nتوضیح دهید که پارامتر نوع چه ویژگی‌هایی باید داشته باشد.\nامضای تابع/ساختار را پیچیده نکنید:\nسعی کنید از چند پارامتر نوعی زیاد، یا constraintهای تو در تو فقط زمانی استفاده کنید که طراحی شما واقعاً به آن نیاز دارد.\nاز aliasهای ژنریک فقط برای ساده‌سازی و افزایش خوانایی استفاده کنید:\nاز aliasهای نامفهوم و زنجیره‌ای بپرهیزید.\n۶.۸.۳ ترفندهای تولیدی و حرفه‌ای برای پروژه‌های بزرگ و ماژولار # ساخت abstractionهای لایه‌ای:\nابتدا یک interface ژنریک تعریف کنید و سپس پیاده‌سازی‌های مختلف با constraintهای متفاوت بسازید (مثلاً یک interface برای ذخیره‌سازی و چند نوع backend مختلف).\nکتابخانه‌های داخلی و عمومی را ژنریک بنویسید:\nهرجا می‌خواهید reusable library یا utility بسازید، ژنریک ابزار ایده‌آل است.\nژِنریک را با تست و بنچمارک پوشش دهید:\nهمیشه انواع مختلف را تست کنید تا از عدم بروز خطاهای نوعی مطمئن شوید.\nدر پروژه‌های بزرگ از constraint alias استفاده کنید:\nconstraintهای تکراری و ترکیبی را alias کنید تا خوانایی و نگهداری بهبود یابد.\nپشتیبانی از backward compatibility:\nهنگام مهاجرت به ژنریک، بخش‌های پرکاربرد را تدریجی refactor کنید تا کاربران پروژه آسیب نبینند.\n۶.۸.۴ عملکرد (Performance)، Compile-Time و تاثیرات بر روی Debugging # بنچمارک قبل و بعد از ژنریک‌سازی:\nدر بخش‌هایی که performance بحرانی است، حتماً قبل و بعد از استفاده از ژنریک بنچمارک بگیرید. در اکثر موارد، کد ژنریک مثل نسخه دستی اجرا می‌شود، اما در برخی حالات خاص (مانند استفاده از اینترفیس یا constraintهای سنگین)، ممکن است کمی کندتر باشد.\nتاثیر بر زمان کامپایل:\nبا ژنریک، زمان کامپایل ممکن است کمی افزایش یابد (به ویژه در پروژه‌های بزرگ یا با constraintهای پیچیده)، اما با بهینه‌سازی نسخه‌های جدید Go این تاثیر حداقلی است.\nDebugging و پیام‌های خطا:\nپیام‌های خطا در ژنریک‌های پیچیده می‌تواند مبهم باشد. توصیه می‌شود با ساده‌سازی constraint و مستندسازی، کار دیباگ را راحت‌تر کنید.\nدر تست‌ها از انواع مختلف استفاده کنید:\nتست ژنریک با داده‌های متنوع به شما کمک می‌کند از ایمنی کد مطمئن شوید و خطاهای پنهان را بیابید.\n"},{"id":94,"href":"/chapter-6/generics-advanced-examples-and-tips/","title":"6.9 مثال‌های پیشرفته و نکات ویژه","section":"فصل ششم: ژنریک ها (Generics)","content":" ۶.۹.۱ ساخت کتابخانه‌های عمومی و abstractionهای حرفه‌ای با ژنریک‌ها # در پروژه‌های مدرن، معمولاً نیاز به abstraction و لایه‌بندی وجود دارد تا بتوانید کدهای reusable و توسعه‌پذیر بسازید. ژنریک‌ها در Go این کار را بسیار ساده و حرفه‌ای می‌کنند.\nمثال: کتابخانه DataStore ژنریک # 1type DataStore[T any] interface { 2 Get(id string) (T, error) 3 Save(id string, data T) error 4} 5 6type MemoryStore[T any] struct { 7 data map[string]T 8} 9 10func NewMemoryStore[T any]() *MemoryStore[T] { 11 return \u0026amp;MemoryStore[T]{data: make(map[string]T)} 12} 13 14func (m *MemoryStore[T]) Get(id string) (T, error) { 15 v, ok := m.data[id] 16 if !ok { 17 var zero T 18 return zero, fmt.Errorf(\u0026#34;not found\u0026#34;) 19 } 20 return v, nil 21} 22 23func (m *MemoryStore[T]) Save(id string, data T) error { 24 m.data[id] = data 25 return nil 26} توضیح:\nدر این مثال یک abstraction برای ذخیره‌سازی داده‌ها پیاده‌سازی شده که می‌تواند برای هر نوع داده‌ای مورد استفاده قرار گیرد (مثلاً User, Order, Product و \u0026hellip;). این ساختار با پیاده‌سازی interface ژنریک، قابلیت توسعه و تست بسیار بالایی دارد و به راحتی می‌توانید MemoryStore را با نسخه DatabaseStore یا CacheStore جایگزین کنید.\n۶.۹.۲ ترکیب ژنریک با error handling و context # ترکیب ژنریک با الگوهای حرفه‌ای مثل مدیریت خطا (error handling) و context در Go باعث ایجاد کدهایی ایمن، تمیز و مقیاس‌پذیر می‌شود.\nمثال: سرویس ژنریک با Context و Error # 1type Service[T any] interface { 2 FindByID(ctx context.Context, id int) (T, error) 3} 4 5type User struct { 6 Name string 7} 8 9type UserService struct { 10 data map[int]User 11} 12 13func (u *UserService) FindByID(ctx context.Context, id int) (User, error) { 14 select { 15 case \u0026lt;-ctx.Done(): 16 return User{}, ctx.Err() 17 default: 18 user, ok := u.data[id] 19 if !ok { 20 return User{}, fmt.Errorf(\u0026#34;not found\u0026#34;) 21 } 22 return user, nil 23 } 24} توضیح:\nدر این الگو، abstraction سرویس به صورت ژنریک تعریف شده و متدها از context و error استفاده می‌کنند. این الگو مناسب سرویس‌های REST, gRPC، کار با پایگاه داده و معماری‌های مدرن است.\n۶.۹.۳ نکات بهینه‌سازی و Performance در کد ژنریک # برای کدهای ژنریک، همواره باید کارایی و بهینه‌سازی را در نظر گرفت، مخصوصاً در ساختارهای داده و توابع پرتکرار.\nنکات مهم: # استفاده از constraintهای حداقلی:\nconstraintها را تا جای ممکن ساده نگه دارید تا کامپایلر بتواند بیشترین بهینه‌سازی را انجام دهد.\nاجتناب از reflect و type assertion:\nهرجا می‌توانید منطق را با constraint و متدهای مستقیم حل کنید و از عملیات runtime اضافه بپرهیزید.\nبنچمارک عملی:\nکدهای ژنریک را مثل سایر کدها با بنچمارک مقایسه کنید، به ویژه اگر در مسیر بحرانی اجرا قرار دارند.\nاستفاده از slices و pre-allocation:\nدر ساختارهای داده، اندازه اولیه slice را تعیین کنید تا از افزایش هزینه reallocation جلوگیری شود.\nپروفایلینگ کد ژنریک:\nبا ابزارهایی مثل pprof، عملکرد توابع ژنریک را بررسی کنید تا نقاط bottleneck را شناسایی و رفع کنید.\nمثال بنچمارک ساده: # 1func BenchmarkMaxInt(b *testing.B) { 2 for i := 0; i \u0026lt; b.N; i++ { 3 _ = Max(123, 456) 4 } 5} 6 7func BenchmarkMaxGeneric(b *testing.B) { 8 for i := 0; i \u0026lt; b.N; i++ { 9 _ = Max[int](123, 456) 10 } 11} توضیح:\nاین بنچمارک‌ها نشان می‌دهند که در عمل، تفاوت سرعت نسخه ژنریک و نسخه معمولی minimal است، اما باید همیشه در پروژه‌های واقعی تست شوند.\n"},{"id":95,"href":"/chapter-7/","title":"فصل هفتم: تست نویسی","section":"صفحه اصلی","content":"در این فصل به صورت عمیق به مباحث تست‌نویسی در زبان Go پرداخته شده است که شامل عناوین زیر می‌باشد.\n۷.۱ مقدمه‌ای بر تست در Go. ۷.۲ تست واحد Unit Test . ۷.۳ تست جدول‌محور Table-Driven Test . ۷.۴ تست یکپارچه Integration Test . ۷.۵ تست انتها به انتها End-to-End Test . ۷.۶ تست عملکرد Benchmark . ۷.۷ تست فازی Fuzz Testing . ۷.۸ ماک و شبیه‌سازی وابستگی‌ها Mocking . ۷.۹ استفاده از کتابخانه testify برای assertions، mock و ساختاردهی تست‌ها. ۷.۱۰ استفاده از فریم‌ورک ginkgo برای تست‌های سبک BDD. ۷.۱۱ تست‌های همزمانی و تحلیل race conditions. ۷.۱۲ سنجش پوشش کد Code Coverage و گزارش‌گیری. ۷.۱۳ مدیریت و گروه‌بندی تست‌ها با Test Suite. ۷.۱۴ تست‌نویسی حرفه‌ای در پروژه‌های واقعی. "},{"id":96,"href":"/chapter-7/go-introduction-testing/","title":"7.1 مقدمه‌ای بر تست در Go","section":"فصل هفتم: تست نویسی","content":"تست‌نویسی یکی از ارکان حیاتی توسعه نرم‌افزارهای قابل‌اعتماد و نگهدارپذیر است. در دنیای امروز که سرعت توسعه و تغییرات کد روزبه‌روز بیشتر می‌شود، وجود تست‌های دقیق و ساختاریافته تضمین می‌کند که عملکرد نرم‌افزار با تغییرات جدید دچار اختلال نشود. از کشف باگ‌ها گرفته تا مستندسازی رفتار مورد انتظار ماژول‌ها، تست‌ها نقشی فراتر از صرفاً اطمینان‌بخشی دارند. آن‌ها به تیم توسعه جرئت ریفکتور می‌دهند و مرزهای طراحی سیستم را شفاف می‌کنند.\nزبان Go با در نظر گرفتن سادگی و مینیمالیسم به عنوان اصل بنیادین، تست‌نویسی را به عنوان بخشی جدانشدنی از چرخه توسعه درون خود جای داده است. بر خلاف بسیاری از زبان‌ها که برای تست‌نویسی نیاز به نصب ابزارهای اضافی دارند، Go یک ابزار تست‌نویسی داخلی، ساده و قدرتمند به نام testing در کنار دستور go test ارائه می‌دهد که فرآیند اجرا و گزارش‌گیری را بسیار روان و سریع می‌کند. این ابزارها با طراحی سطح پایین و بدون پیچیدگی، توسعه‌دهندگان را تشویق می‌کنند که تست را به بخشی از سبک برنامه‌نویسی خود تبدیل کنند.\nدر Go، تست‌ها همان توابع عادی هستند که با قواعد ساده‌ای مانند TestXxx(t *testing.T) نوشته می‌شوند. خبری از assertionهای پیچیده یا DSLهای سنگین نیست. همین سادگی، آزمون‌ها را خواناتر، نگهدار‌پذیرتر و از همه مهم‌تر، قابل‌درک برای همه اعضای تیم می‌کند. ابزارهای جانبی مانند testify یا ginkgo نیز به عنوان افزونه‌هایی قدرتمند برای پروژه‌های بزرگ‌تر و تست‌های ساختاریافته‌تر به کار گرفته می‌شوند، اما اصل فلسفه Go حفظ مینیمالیسم است.\nدر این فصل، با اصول، ابزارها و الگوهای تست‌نویسی در زبان Go آشنا خواهیم شد؛ از تست واحد، جدول‌محور، یکپارچه و انتها به انتها گرفته تا بنچمارک، تست فازی و تست‌های هم‌زمانی. همچنین به ابزارهایی چون testify, gomock, ginkgo, پوشش تست، ساخت Suite تستی و نحوه تست‌نویسی حرفه‌ای در پروژه‌های واقعی می‌پردازیم. هدف این فصل آن است که مهارت تست‌نویسی شما را در Go از سطح ابتدایی به سطحی قابل‌اعتماد و حرفه‌ای ارتقا دهد.\nبه نقل از ویکی پدیا آزمون نرم‌افزار یا تست نرم‌افزار (به انگلیسی: software testing) به فرایند ارزیابی نرم‌افزار به منظور اطمینان از عملکرد صحیح آن در رویدادهایی مختلفی که ممکن است در دوره استفاده از نرم‌افزار با آن مواجه شود می‌باشد و به عبارت دیگر پیدا کردن خطاهایی احتمالی یک نرم‌افزار برای عملکرد درست، صحیح و بهینه آن در طول استفاده از آن است. هر چقدر نرم‌افزار بتواند با رویدادها مختلف به صورت مطلوب تر و قابل پذیرش تری چه از نظر عملکرد و چه از راحتی کاربر داشته باشد می‌توان انتظار داشت نرم‌افزار دارای عملکرد بهتری می‌باشد. 7.1.1 جایگاه تست در چرخه توسعه نرم‌افزار # در توسعه نرم‌افزار، نوشتن تست فقط یک فعالیت جانبی برای اطمینان از صحت عملکرد نیست، بلکه بخش جدایی‌ناپذیری از طراحی، مستندسازی و حفظ کیفیت سیستم محسوب می‌شود. زمانی که نرم‌افزار رشد می‌کند، تغییر می‌کند و افراد جدید به تیم توسعه می‌پیوندند، تست‌ها نقش ستون‌های قابل اعتماد برای حفظ رفتار صحیح سیستم را ایفا می‌کنند. در این میان، زبان برنامه‌نویسی Go با ساده‌سازی ابزارها و یکپارچه‌سازی امکانات تست‌نویسی، فرآیند توسعه را به‌گونه‌ای طراحی کرده که تست بخشی طبیعی از چرخه توسعه باشد.\n7.1.1.1 تست به عنوان بخشی از طراحی سیستم # در بسیاری از روش‌های توسعه نرم‌افزار، نوشتن تست حتی پیش از پیاده‌سازی کد توصیه می‌شود. در روش‌هایی مانند توسعه مبتنی بر تست یا توسعه مبتنی بر رفتار ، تست‌ها بخش اولیه فرآیند طراحی هستند. در زبان Go، نوشتن تست با استفاده از ساختارهای ساده‌ای مانند TestXxx(t *testing.T) یا استفاده از الگوی تست جدول‌محور باعث می‌شود که طراحی APIها و منطق برنامه به‌صورت طبیعی بر پایه رفتار قابل تست شکل بگیرد. این نوع طراحی نه‌تنها کیفیت را افزایش می‌دهد، بلکه کد را تغییرپذیرتر و خواناتر می‌کند.\n7.1.1.2 تست به عنوان مستند رفتاری سیستم # تست‌ها می‌توانند جایگزینی دقیق، همیشگی و زنده برای مستندسازی باشند. هر تست، سناریویی مشخص از تعاملات سیستم با ورودی‌های مختلف است که خروجی یا رفتار خاصی را انتظار دارد. برخلاف مستندات متنی که به‌مرور زمان منسوخ می‌شوند، تست‌ها در صورت مغایرت با پیاده‌سازی، به‌وضوح شکست خواهند خورد. این ویژگی تست‌ها را به مرجع رفتاری سیستم تبدیل می‌کند. توسعه‌دهندگانی که برای هر ماژول تست می‌نویسند، در واقع رفتار آن ماژول را تعریف و مستند می‌کنند؛ به‌نحوی که برای سایر اعضای تیم یا برای توسعه‌دهندگانی که در آینده با پروژه کار می‌کنند نیز قابل درک است.\nتستی که می‌نویسی، قراردادی زنده با عملکرد سیستم است.\n7.1.1.3 تست به عنوان سپر تغییرات # در پروژه‌هایی که توسعه مداوم دارند، تغییر کد امری اجتناب‌ناپذیر است. اما تغییر بدون پشتوانه تست، خطر ایجاد بازگشت خطا را به همراه دارد. تست‌ها در اینجا به‌عنوان یک سپر دفاعی عمل می‌کنند. پیش از اعمال تغییر، می‌توان با اجرای سریع تست‌ها مطمئن شد که تغییرات، سایر بخش‌های سیستم را تحت تأثیر قرار نداده‌اند. سرعت بالای اجرای تست‌ها در Go باعث می‌شود که این فرآیند به‌صورت مستمر در چرخه توسعه انجام شود. با وجود این تست‌ها، می‌توان با اطمینان بالا اقدام به بازسازی ساختار کد یا اضافه‌کردن ویژگی‌های جدید کرد.\nنمی‌توانی چیزی را بهینه کنی که راستی‌آزمایی‌اش نکرده‌ای.\n7.1.1.4 تست در Go: اولویت یا گزینه؟ # در زبان Go، تست‌نویسی نه‌تنها یک امکان در دسترس، بلکه بخشی از ابزار رسمی توسعه است. برخلاف بسیاری از زبان‌ها که نیازمند نصب ابزارها یا کتابخانه‌های شخص ثالث برای نوشتن تست هستند، Go با فراهم کردن ابزارهایی مانند testing، go test، -cover، -bench و -fuzz از ابتدا زیرساخت تست را فراهم کرده است. این ابزارها سبک توسعه‌ای را ترویج می‌دهند که در آن تست‌نویسی نه بعد از پیاده‌سازی، بلکه در حین توسعه و حتی پیش از آن انجام می‌شود. به همین دلیل، در بسیاری از پروژه‌های حرفه‌ای با زبان Go، تست بخش عادی و ضروری توسعه محسوب می‌شود، نه صرفاً یک انتخاب اختیاری.\n7.1.2 مزایای تست‌نویسی در Go # یکی از نقاط قوت زبان Go، سادگی و یکپارچگی ابزارهای تست‌نویسی است. در حالی که در بسیاری از زبان‌ها، برای شروع تست‌نویسی باید چارچوب‌های خارجی نصب و پیکربندی شوند، در Go هر پروژه به‌صورت پیش‌فرض می‌تواند شامل فایل‌های تست باشد و با استفاده از ابزار رسمی go test به‌سادگی تست‌ها را اجرا کند. این طراحی باعث شده تست‌نویسی در Go نه یک کار جانبی یا پیچیده، بلکه بخشی طبیعی از توسعه روزمره باشد.\n7.1.2.1 ساده‌سازی فرآیند تست‌نویسی # تست‌ها در Go صرفاً توابعی هستند که با الگوی TestXxx(t *testing.T) تعریف می‌شوند. نیازی به ارث‌بری، annotation یا ساختارهای پیچیده نیست. تنها چیزی که لازم است یک تابع ساده و چند شرط منطقی برای بررسی نتایج است. همین سادگی باعث می‌شود افراد تازه‌کار نیز بتوانند به‌راحتی نوشتن تست را آغاز کنند و به مرور، تست‌های پیچیده‌تر بنویسند.\n7.1.2.2 سرعت بالا در اجرا # تست‌های Go به دلیل ساختار ساده و اجرای مستقل، بسیار سریع اجرا می‌شوند. این موضوع در پروژه‌های بزرگ که شامل صدها یا هزاران تست هستند، اهمیت ویژه‌ای دارد. با استفاده از امکانات داخلی مانند -short، -run و -parallel می‌توان تست‌ها را به‌صورت انتخابی، سریع و هم‌زمان اجرا کرد. این ویژگی، بازخورد سریع برای توسعه‌دهنده فراهم می‌کند و مانع از کند شدن چرخه توسعه می‌شود.\n7.1.2.3 پوشش طیف متنوعی از تست‌ها # Go به‌صورت پیش‌فرض از انواع مختلف تست پشتیبانی می‌کند:\nتست واحد unit test تست یکپارچه integration test تست انتها به انتها end-to-end test تست عملکرد benchmark تست فازی fuzz testing بدون نیاز به ابزار خارجی، می‌توان تمامی این انواع تست را در دل پروژه نوشت و اجرا کرد. این تنوع به تیم‌ها کمک می‌کند تا از زوایای مختلف، عملکرد و صحت سیستم را ارزیابی کنند.\n7.1.2.4 پشتیبانی از ابزارهای جانبی و شخص ثالث # در کنار ابزارهای داخلی، اکوسیستم Go شامل کتابخانه‌ها و فریم‌ورک‌های محبوبی برای تست‌نویسی پیشرفته است. کتابخانه‌هایی مانند:\ntestify: برای assertions و mock ginkgo: برای تست‌های ساختاریافته به سبک BDD gomock, moq: برای تولید mock خودکار go-cmp: برای مقایسه دقیق ساختارهای پیچیده این ابزارها امکانات اضافی و قدرتمندی به تست‌نویسی اضافه می‌کنند و در عین حال با ساختار زبان سازگار باقی می‌مانند.\n7.1.2.5 ادغام آسان با CI/CD # از آنجا که اجرای تست در Go از طریق یک دستور ساده انجام می‌شود (go test ./...)، ادغام آن در خط تولید خودکار بسیار ساده است. بیشتر پلتفرم‌های CI مثل GitHub Actions، GitLab CI، CircleCI و TravisCI، بدون نیاز به پیکربندی اضافی، می‌توانند تست‌های Go را اجرا و گزارش کنند. این ویژگی باعث می‌شود که فرهنگ تست‌نویسی در تیم به‌راحتی به یک عادت سازنده تبدیل شود.\n7.1.2.6 پایداری و نگهداری آسان تست‌ها # ساختار تست در Go به‌گونه‌ای است که نگهداری آن در طول زمان ساده و کم‌هزینه است. چون تست‌ها از توابع معمولی تشکیل شده‌اند، به‌راحتی می‌توان آن‌ها را بازنویسی، جدا یا ترکیب کرد. همچنین از آنجا که ابزارهای تست بخشی از هسته زبان هستند، احتمال ناسازگاری نسخه‌ای یا شکستن تست‌ها به دلیل تغییر ابزار بسیار پایین است.\nحتماً، در ادامه نگارش کامل بخش ۷.۱.۳ رویکرد زبان Go به تست‌نویسی با رعایت ساختار مورد نظر، استفاده از کلمات تخصصی به‌صورت tooltip، بدون ارجاع مستقیم به کتاب‌ها و با زبان حرفه‌ای فارسی آورده شده است:\n7.1.3 رویکرد زبان Go به تست‌نویسی # زبان Go از ابتدا با این نگرش طراحی شد که توسعه‌دهنده باید بتواند با ساده‌ترین ابزارها، بیشترین کنترل را روی کیفیت کد داشته باشد. در همین راستا، تست‌نویسی نه‌تنها به عنوان یک ابزار جانبی، بلکه به عنوان بخشی ذاتی از فلسفه زبان گنجانده شده است. رویکرد Go به تست‌نویسی بر پایه‌ی اصولی مانند سادگی، سرعت، قابلیت نگهداری و حداقل وابستگی بنا شده است.\n7.1.3.1 استفاده از ابزارهای رسمی و داخلی # در Go، نیازی به نصب هیچ ابزار اضافی برای تست‌نویسی وجود ندارد. با استفاده از پکیج تستینگ و ابزار گو تست می‌توان تست‌ها را نوشت، اجرا کرد و گزارش گرفت. این ابزارها بخشی از هسته زبان هستند و در کنار دستورات اصلی مانند go build یا go run مورد استفاده قرار می‌گیرند. این یکپارچگی باعث می‌شود تست‌نویسی بخشی کاملاً طبیعی از فرآیند توسعه باشد، نه عملی اختیاری یا پیچیده.\n7.1.3.2 سادگی در تعریف تست‌ها # برخلاف زبان‌هایی که برای نوشتن تست نیاز به استفاده از annotation، ارث‌بری از کلاس‌های خاص یا تعریف ساختارهای پیچیده دارند، در Go یک تست تنها یک تابع معمولی با امضای func TestXxx(t *testing.T) است. این توابع می‌توانند هر منطق دلخواهی را پیاده‌سازی کنند و در صورت مشاهده خطا با فراخوانی t.Errorf() یا t.Fatal() گزارش شکست را صادر نمایند. این رویکرد باعث می‌شود تست‌ها خوانا، مینیمال و قابل فهم برای تمام اعضای تیم باشند.\n7.1.3.3 سبک مینیمال و بدون چارچوب # Go از عمد از اضافه کردن چارچوب‌های تست پیچیده و سیستم‌های assertion سنگین اجتناب کرده است. این تصمیم با هدف حفظ سادگی، شفافیت و کنترل بیشتر توسعه‌دهنده اتخاذ شده است. اگرچه کتابخانه‌های شخص ثالث مانند testify یا ginkgo برای پروژه‌های بزرگ یا تست‌های ساختاریافته‌تر وجود دارند، اما فلسفه Go این است که تست ساده باشد و تا جای ممکن از ابزارهای استاندارد استفاده شود.\n7.1.3.4 پشتیبانی طبیعی از انواع تست # رویکرد Go به تست‌نویسی صرفاً محدود به بررسی صحت نیست. ابزار رسمی go test با فلگ‌هایی مانند -bench, -cover و -fuzz از تست‌های متنوعی پشتیبانی می‌کند، از جمله:\nتست عملکرد benchmark سنجش پوشش کد code coverage تست فازی fuzz testing همه این قابلیت‌ها در ابزارهای داخلی Go گنجانده شده‌اند و برای استفاده از آن‌ها نیازی به نصب افزونه یا وابستگی جدید نیست. این ویژگی Go را از بسیاری از زبان‌ها متمایز می‌کند.\n7.1.3.5 طراحی برای توسعه‌دهنده، نه ابزار # فلسفه طراحی Go این است که توسعه‌دهنده باید به‌جای جنگیدن با ابزارها، مستقیماً روی حل مسئله تمرکز کند. این اصل در تست‌نویسی نیز دیده می‌شود. Go توسعه‌دهنده را تشویق می‌کند به‌جای وابستگی به جادوی فریم‌ورک‌ها، با ابزارهای ساده و قابل درک، منطق تست را به‌صورت شفاف پیاده‌سازی کند. این رویکرد در بلندمدت باعث تسهیل نگهداری پروژه، کاهش پیچیدگی و افزایش اطمینان از صحت سیستم می‌شود.\n7.1.4 اصول و قراردادهای تست در Go # در زبان Go، تست‌نویسی نه‌تنها از نظر ابزار ساده است، بلکه از نظر قراردادها، ساختار پوشه‌ها و نام‌گذاری توابع نیز کاملاً روشن و استاندارد تعریف شده است. این ساختار قراردادی به توسعه‌دهندگان کمک می‌کند تا تست‌ها را به‌راحتی بنویسند، بخوانند، اجرا کنند و در ابزارهای خودکار مانند سی‌آی ادغام نمایند.\n7.1.4.1 ساختار فایل‌های تست # تمام تست‌ها در Go باید در فایل‌هایی با پسوند _test.go قرار بگیرند. این قانون توسط ابزار go test شناسایی می‌شود و فقط این فایل‌ها برای اجرای تست در نظر گرفته می‌شوند. این فایل‌ها معمولاً در کنار فایل‌های اصلی قرار می‌گیرند، مثلاً:\n1math.go 2math_test.go این ساختار باعث می‌شود تست‌ها به راحتی با کد اصلی مقایسه و توسعه داده شوند، و وابستگی آن‌ها کاملاً واضح باشد.\n7.1.4.2 امضای تابع تست # هر تابع تست باید به شکل زیر تعریف شود:\n1func TestXxx(t *testing.T) در اینجا Xxx می‌تواند نامی اختیاری و دلخواه باشد، اما باید با حرف بزرگ آغاز شود تا توسط ابزار تست شناسایی شود. آرگومان t از نوع تی تستینگ است و امکاناتی مانند ثبت خطا، توقف تست، یا گزارش وضعیت را فراهم می‌کند.\nبرای مثال:\n1func TestAdd(t *testing.T) { 2 got := Add(2, 3) 3 if got != 5 { 4 t.Errorf(\u0026#34;expected 5, got %d\u0026#34;, got) 5 } 6} 7.1.4.3 گروه‌بندی تست‌ها با Subtest # در Go می‌توان تست‌های مرتبط را با استفاده از متد t.Run به‌صورت زیر تست اجرا کرد. این کار باعث دسته‌بندی منطقی تست‌ها و جداسازی گزارش آن‌ها در خروجی می‌شود:\n1func TestMathOperations(t *testing.T) { 2 t.Run(\u0026#34;Addition\u0026#34;, func(t *testing.T) { 3 // ... 4 }) 5 6 t.Run(\u0026#34;Multiplication\u0026#34;, func(t *testing.T) { 7 // ... 8 }) 9} 7.1.4.4 موازی‌سازی تست‌ها # Go به‌صورت بومی از اجرای هم‌زمان تست‌ها پشتیبانی می‌کند. با استفاده از t.Parallel() می‌توان تست‌ها را به‌صورت مستقل و موازی اجرا کرد، به‌ویژه مفید برای تست‌هایی که داده‌ها یا منابع مشترک ندارند:\n1func TestFastOperation(t *testing.T) { 2 t.Parallel() 3 // اجرای تست 4} در صورتی که تست‌هایی با منابع مشترک دارید، باید از سینک مانند Mutex یا channel برای کنترل استفاده کنید.\n7.1.4.5 قرارداد نام‌گذاری تست‌ها # تمام تست‌ها باید با Test شروع شوند. تست‌های بنچمارک باید با Benchmark شروع شوند و از *testing.B استفاده کنند. تست‌های فازی باید با Fuzz شروع شوند و از *testing.F استفاده کنند. استفاده از اسم‌های معنادار برای تست‌ها باعث خوانایی بهتر کد و گزارش‌ها می‌شود. مثال‌های معتبر:\n1func BenchmarkSort(b *testing.B) { ... } 2func FuzzParseDate(f *testing.F) { ... } 7.1.4.6 تست‌های بدون تست واقعی # گاهی ممکن است نیاز باشد یک تست خالی نوشته شود فقط برای اطمینان از اینکه برنامه کامپایل می‌شود یا فقط هدف خاصی را بررسی کند. در این موارد، می‌توان از t.Skip() استفاده کرد:\n1func TestStub(t *testing.T) { 2 t.Skip(\u0026#34;implementation pending\u0026#34;) 3} 7.1.5 مقایسه با زبان‌های دیگر # زبان Go رویکردی ساده، سریع و بی‌واسطه به تست‌نویسی دارد که آن را از بسیاری از زبان‌های رایج توسعه نرم‌افزار متمایز می‌کند. در حالی که برخی زبان‌ها با استفاده از چارچوب‌های سنگین یا ابزارهای جانبی به سراغ تست می‌روند، Go تست را به‌عنوان بخشی از طراحی زبان در نظر گرفته است. در این بخش، نگاهی تطبیقی به روش تست‌نویسی در Go و چند زبان دیگر می‌اندازیم.\n7.1.5.1 مقایسه با Python # در زبان Python، تست‌نویسی اغلب با استفاده از کتابخانه‌هایی مانند unittest, pytest, یا nose انجام می‌شود. اگرچه این ابزارها قدرتمند هستند و ویژگی‌هایی مانند تشخیص خودکار، fixture injection و assert پیشرفته دارند، اما معمولاً نیاز به نصب و پیکربندی اولیه دارند. در مقابل، Go از ابزار داخلی testing استفاده می‌کند که بدون وابستگی و با دستور go test قابل استفاده است.\nویژگی Go Python + pytest ابزار داخلی بله خیر assert پیشرفته خیر (با if) بله سرعت اجرا بسیار بالا معمولی منحنی یادگیری بسیار ساده نسبتاً متوسط 7.1.5.2 مقایسه با Java # در Java، تست‌نویسی معمولاً با استفاده از چارچوب‌هایی مانند JUnit یا TestNG انجام می‌شود. این چارچوب‌ها مبتنی بر annotation و reflection هستند، که در Go وجود ندارد. تعریف یک تست ساده در Java نیازمند کلاس، annotation و ساختار نسبتاً سنگینی است، در حالی که در Go یک تابع ساده کافی است. از طرفی ابزارهای Java برای پروژه‌های پیچیده‌تر امکانات بیشتری دارند، اما این مزیت همراه با پیچیدگی نیز هست.\nویژگی Go Java + JUnit نیاز به annotation خیر بله نوشتار ساده بله خیر یکپارچگی با زبان کامل از طریق چارچوب جداگانه زمان اجرا سریع کندتر 7.1.5.3 مقایسه با JavaScript / TypeScript # در JavaScript یا TypeScript، ابزارهای متنوعی برای تست وجود دارد مانند Jest, Mocha, Chai, Vitest. اگرچه این ابزارها تجربه تست بسیار مدرنی فراهم می‌کنند (مانند snapshot testing و mocking خودکار)، اما پیکربندی آن‌ها در پروژه‌های بزرگ می‌تواند زمان‌بر باشد. از طرف دیگر، وجود اکوسیستم‌های پیچیده باعث می‌شود گاهی فهمیدن منطق تست دشوار شود. Go از این پیچیدگی اجتناب کرده و تجربه‌ای ساده، قابل پیش‌بینی و سریع ارائه می‌دهد.\nویژگی Go JavaScript + Jest نصب ابزار لازم نیست ضروری snapshot testing ندارد بله mocking داخلی ندارد بله خطایابی آسان تست‌ها بله گاهی دشوار 7.1.5.4 مقایسه با Rust # در Rust، تست‌ها معمولاً درون ماژول‌هایی با annotation #[cfg(test)] و ماکروهای #[test] نوشته می‌شوند. مانند Go، تست بخشی از زبان است و اجرای آن با دستور cargo test انجام می‌شود. از این نظر، رویکرد Rust بسیار به Go نزدیک است. با این حال، تعریف ماژول‌ها و ویژگی‌های زبانی Rust ممکن است منحنی یادگیری بالاتری داشته باشد، در حالی که Go از سادگی بیشتری برخوردار است.\nویژگی Go Rust ابزار تست داخلی بله بله تست داخل ماژول اختیاری بله macro و annotation ندارد دارد پیچیدگی یادگیری پایین متوسط به بالا 7.1.5.5 نتیجه‌گیری مقایسه # رویکرد Go به تست‌نویسی کاملاً عمل‌گرا، ساده و بدون وابستگی به ابزارهای جانبی است. این سادگی باعث می‌شود تیم‌های توسعه بتوانند سریع‌تر شروع به نوشتن تست کنند و فرآیند اجرای تست‌ها نیز سبک، سریع و قابل‌اتکا باقی بماند. در حالی که بسیاری از زبان‌ها بر غنای ابزارهای تست تکیه می‌کنند، Go با ارائه یک راهکار ساده اما کارآمد، توسعه‌دهنده را به نوشتن تست تشویق می‌کند بدون اینکه او را از مسیر تولید منحرف کند.\n7.1.6 آزمونگر ایده‌آل گولنگ‌نویس: چرا باید تست بنویسیم؟ # در اکوسیستم Go، تست‌نویسی نه یک مهارت اضافه بلکه بخشی از هویت یک توسعه‌دهنده حرفه‌ای محسوب می‌شود. اگرچه ابزارها و کتابخانه‌ها نوشتن تست را بسیار آسان کرده‌اند، اما نوشتن تست صرفاً به خاطر وجود ابزار انجام نمی‌شود. در واقع، نوشتن تست در Go به دلایل مهم‌تری ضرورت دارد.\n7.1.6.1 تضمین رفتار سیستم # هر خط تست، تضمینی است برای آنکه یک ویژگی مشخص از سیستم در شرایط خاص به درستی عمل می‌کند. وقتی تستی می‌نویسیم، در واقع داریم تعریف می‌کنیم که چه چیزی قابل قبول است و چه چیزی نیست. بدون تست، تغییر دادن یا توسعه کد به یک فعالیت پرریسک تبدیل می‌شود.\n7.1.6.2 مستندسازی زنده # تست‌های خوب، همانند مستندات زنده هستند. آن‌ها نشان می‌دهند که یک تابع یا ماژول در برابر چه ورودی‌هایی چه رفتاری دارد. این نوع مستندسازی برخلاف توضیحات متنی، خود را با تغییرات کد به‌روزرسانی می‌کند و در صورت عدم هماهنگی، با شکست در اجرا هشدار می‌دهد.\n7.1.6.3 کاهش هزینه‌های نگهداری # کد بدون تست، در بلندمدت هزینه‌بر خواهد شد؛ چرا که کوچک‌ترین تغییر در آن نیازمند تحلیل مجدد و اعتماد به حافظه یا شهود توسعه‌دهنده است. در حالی که وجود تست‌های پوششی، هزینه تغییر، اشکال‌زدایی و توسعه‌ی بیشتر را به‌شدت کاهش می‌دهد.\n7.1.6.4 ایجاد فرهنگ توسعه حرفه‌ای # نوشتن تست فقط مهارت نیست، بلکه نشانه‌ی یک طرز فکر است. توسعه‌دهنده‌ای که تست می‌نویسد، به کیفیت، آینده‌پذیری و قابل‌اعتماد بودن سیستم اهمیت می‌دهد. در دنیای Go، این رویکرد از یک توصیه فراتر رفته و به یک عرف تبدیل شده است.\n7.1.7 ابزار go test و نحوه اجرای تست‌ها از خط فرمان # در زبان Go، اجرای تست‌ها از طریق ابزار رسمی go test انجام می‌شود. این ابزار بخشی از زنجیره ابزارهای CLI زبان است و بدون نیاز به نصب هیچ ابزار اضافه‌ای، امکان نوشتن، اجرا و گزارش‌گیری از تست‌ها را فراهم می‌کند. در این بخش به بررسی کامل نحوه استفاده از go test، همراه با فلگ‌ها، گزینه‌ها و حالت‌های مختلف اجرای آن می‌پردازیم.\n7.1.7.1 اجرای ساده تست‌ها # برای اجرای تست‌های موجود در یک بسته (پوشه فعلی)، تنها کافی‌ست در همان مسیر دستور زیر را وارد کنید:\n1go test این دستور تمام فایل‌های _test.go را کامپایل کرده، به صورت خودکار go vet را اجرا می‌کند و سپس تست‌ها را اجرا می‌کند.\nخروجی به‌صورت خلاصه نمایش داده می‌شود:\n1ok mymodule/mypkg\t0.011s اگر تست‌ها شکست بخورند، خروجی با FAIL نمایش داده می‌شود.\n7.1.7.2 اجرای انتخابی تست‌ها با -run # می‌توان یک یا چند تابع تست خاص را با استفاده از الگوی منظم (regex) و فلگ -run اجرا کرد:\n1go test -run=TestAdd 2go test -run=\u0026#39;Add|Sub\u0026#39; نکته: تابع تست باید دقیقاً با الگوی TestXxx تعریف شده باشد.\n7.1.7.3 تست‌های موازی و مدیریت زمان # برای تنظیم حداکثر تعداد تست‌هایی که می‌توانند هم‌زمان اجرا شوند: 1go test -parallel=4 برای محدود کردن زمان اجرای هر تست یا کل تست‌ها: 1go test -timeout=5s در صورت عبور از این زمان، پروسه تست با خطا قطع می‌شود.\n7.1.7.4 سنجش پوشش کد با -cover # برای مشاهده درصد پوشش کد توسط تست‌ها:\n1go test -cover برای تولید فایل پوشش:\n1go test -coverprofile=coverage.out و برای مشاهده پوشش به صورت HTML:\n1go tool cover -html=coverage.out 7.1.7.5 اجرای بنچمارک‌ها با -bench # برای اجرای بنچمارک‌ها از فلگ -bench استفاده می‌شود. برای اجرای همه بنچمارک‌ها:\n1go test -bench=. برای اجرای بنچمارک خاص:\n1go test -bench=BenchmarkSort با فلگ -benchmem می‌توان اطلاعات حافظه مصرفی را نیز دریافت کرد:\n1go test -bench=. -benchmem 7.1.7.6 تست‌های فازی با -fuzz # برای اجرای تست فازی:\n1go test -fuzz=FuzzParse برای محدود کردن زمان اجرای فاز فازی:\n1go test -fuzz=FuzzParse -fuzztime=20s در صورت یافتن نمونه‌ای که باعث شکست تست شود، داده تولیدشده ذخیره می‌شود و در اجرای بعدی بررسی خواهد شد.\n7.1.7.7 ترکیب‌های رایج در پروژه‌های واقعی # در بسیاری از پروژه‌ها از ترکیب چند فلگ استفاده می‌شود. مثال‌هایی از ترکیب‌های رایج:\n1go test -v ./... # اجرای کامل تست‌ها به‌صورت verbose 2go test -run=TestHandler -cover ./handlers # تست handler خاص با پوشش کد 3go test -bench=BenchmarkEncode -benchmem # اجرای بنچمارک به همراه مصرف حافظه 4go test -fuzz=FuzzMyFunc -fuzztime=1m # اجرای تست فازی به مدت یک دقیقه 5go test -count=1 # غیرفعال‌سازی cache 7.1.7.8 حالت‌های اجرای go test # go test در دو حالت مختلف اجرا می‌شود:\nLocal Directory Mode: بدون آرگومان بسته اجرا می‌شود و فقط پوشه فعلی را تست می‌کند: 1go test Package List Mode: با مشخص‌کردن مسیر یا پکیج اجرا می‌شود: 1go test ./... 2go test mymodule/utils در حالت دوم، سیستم کَش تست فعال می‌شود و تست‌های قبلاً موفق اجرا نشده و نتیجه cache نمایش داده می‌شود (با برچسب (cached)).\n7.1.7.9 بررسی race condition با فلگ -race # در برنامه‌های همزمان، احتمال بروز شرایط مسابقه وجود دارد؛ یعنی دو یا چند goroutine به‌صورت ناهمزمان به یک متغیر مشترک دسترسی پیدا کنند و حداقل یکی از آن‌ها آن را تغییر دهد. این نوع باگ‌ها بسیار خطرناک هستند، زیرا در زمان اجرا قابل پیش‌بینی نیستند و معمولاً فقط در برخی شرایط خاص خود را نشان می‌دهند.\nبرای شناسایی چنین مشکلاتی در Go، می‌توان از فلگ -race هنگام اجرای تست‌ها استفاده کرد. این فلگ باعث می‌شود کامپایلر، برنامه را به‌گونه‌ای کامپایل کند که دسترسی به حافظه در زمان اجرا بررسی شود.\nنحوه استفاده: # 1go test -race یا برای اجرای تست‌های یک پکیج خاص:\n1go test -race ./pkg/concurrent در صورت وجود race، خروجی‌ای مشابه زیر نمایش داده می‌شود:\n1================== 2WARNING: DATA RACE 3Read at 0x00c0000b2000 by goroutine 6: 4 main.main.func1() 5 6Previous write at 0x00c0000b2000 by goroutine 5: 7 main.main.func2() 8================== نکات مهم: # استفاده از -race باعث کند شدن اجرای تست‌ها (معمولاً 2 تا 5 برابر) و مصرف بیشتر حافظه می‌شود. توصیه می‌شود در فرآیند CI، حداقل یک‌بار در روز یا قبل از انتشار نسخه جدید با -race تست کامل انجام شود. تشخیص race توسط این ابزار معمولاً دقیق است، اما به صورت صددرصد تضمینی نیست. "},{"id":97,"href":"/chapter-7/go-unit-testing/","title":"7.2 تست واحد (Unit Test)","section":"فصل هفتم: تست نویسی","content":"تست واحد یکی از مهم‌ترین و بنیادی‌ترین ابزارهایی‌ست که یک توسعه‌دهنده حرفه‌ای در اختیار دارد. این نوع تست، تنها بر یک «واحد» مستقل از منطق برنامه تمرکز می‌کند—معمولاً یک تابع، یک متد، یا یک ساختار کوچک از کد که بدون وابستگی به منابع خارجی قابل بررسی است. هدف اصلی از نوشتن تست واحد، اطمینان از صحت رفتار دقیق و قابل پیش‌بینی کد در مواجهه با ورودی‌های مشخص و شرایط کنترل‌شده است.\nدر زبان Go، فلسفه طراحی بر سادگی، سرعت و ابزارهای داخلی استوار است؛ این رویکرد به‌وضوح در ساختار تست‌نویسی نیز دیده می‌شود. بدون نیاز به هیچ‌گونه چارچوب یا ابزار جانبی، می‌توان تنها با استفاده از فایل‌های _test.go و توابع TestXxx(t *testing.T) تست‌های کاملی برای هر ماژول نوشت. این تست‌ها به‌صورت یکپارچه با ابزار رسمی go test اجرا می‌شوند و خروجی‌ای دقیق، سریع و قابل‌درک ارائه می‌دهند.\nویژگی‌هایی مانند اجرای تست‌های جداگانه با -run، دسته‌بندی تست‌ها با t.Run، پوشش کد با -cover، تست‌های موازی با t.Parallel() و پشتیبانی کامل از ساختارهای ساده Go، باعث شده‌اند که تست واحد نه فقط یک ابزار، بلکه یک عادت طبیعی در سبک توسعه Go محسوب شود. در عمل، یونیت تست‌ها نه‌تنها در کشف باگ‌ها مؤثرند، بلکه مرجعی قابل‌اطمینان برای تعریف رفتار و مستندسازی سیستم نیز به‌شمار می‌آیند.\nدر ادامه این بخش، ابتدا به ساختار پایه تست واحد در Go می‌پردازیم، سپس الگوهای رایج، ضدالگوها، نکات پیشرفته و مثال‌هایی از دنیای واقعی را بررسی خواهیم کرد.\nبه نقل از ویکی پدیا آزمون واحد (به انگلیسی: unit testing) در برنامه‌نویسی رایانه‌ای، نوعی آزمون نرم‌افزار است که در آن «واحدهای منفرد کد منبع» مورد آزمون قرار می‌گیرند تا تعیین شود که آیا برای استفاده سازگار هستند یا نه. در اینجا «واحد منفرد کد منبع» یعنی مجموعه‌ای از یک یا بیشتر پودمان برنامه رایانه‌ای، همراه با داده کنترلی مرتبط، رویه استفاده، و رویه عملیاتی.[۱]\nآزمون‌های واحد معمولاً آزمون‌هایی خودکار هستند که توسط توسعه‌دهنده نرم‌افزار نوشته و اجرا می‌شوند، این آزمون برای آن انجام می‌شود تا اطمینان حاصل شود که بخشی از یک برنامه‌کاربردی (که «واحد» نام دارد) طراحی را برآورده کرده‌است و رفتارش هم براساس انتظار است.[۲]\n7.2.1 اصول نوشتن تست‌های واحد در Go و ساختار آن‌ها # نوشتن تست‌های واحد در زبان Go ساده، شفاف و کاملاً منطبق با فلسفه‌ی طراحی زبان است: حداقل پیچیدگی، حداکثر خوانایی و وابستگی صفر به چارچوب‌های جانبی. در Go، تست‌های واحد در فایل‌هایی با پسوند _test.go تعریف می‌شوند و باید در همان پکیجی باشند که کد اصلی قرار دارد یا در پکیجی مجزا با پسوند _test برای جدا‌سازی وابستگی‌ها.\nهر تست واحد باید با تابعی به فرم زیر آغاز شود:\n1func TestXxx(t *testing.T) که در آن Xxx می‌تواند هر نام معناداری باشد که با حرف بزرگ آغاز شده است (برای شناسایی توسط ابزار go test) و پارامتر t از نوع تی بوده و برای مدیریت وضعیت تست به‌کار می‌رود.\n7.2.1.1 ساختار پایه تست واحد # 1func TestAdd(t *testing.T) { 2 got := Add(2, 3) 3 want := 5 4 if got != want { 5 t.Errorf(\u0026#34;Add(2,3) = %d; want %d\u0026#34;, got, want) 6 } 7} در این مثال ساده:\nتابع Add بررسی می‌شود. نتیجه با مقدار مورد انتظار مقایسه شده. در صورت مغایرت، پیامی با t.Errorf ثبت می‌شود که باعث شکست تست می‌گردد. 7.2.1.2 نقش تابع t.Fail, t.Error, و t.Fatal # در تست‌های Go چندین روش برای ثبت خطا وجود دارد:\nتابع توضیح t.Error ثبت خطا و ادامه اجرای تست t.Errorf مانند t.Error اما با فرمت‌دهی رشته t.Fail فقط ثبت خطا بدون پیام t.Fatal ثبت خطا و توقف فوری اجرای تابع تست t.Fatalf مانند t.Fatal با امکان فرمت‌دهی نمونه:\n1if err != nil { 2 t.Fatalf(\u0026#34;unexpected error: %v\u0026#34;, err) 3} 7.2.1.3 الزامات ابزار go test # برای اینکه go test تست‌ها را شناسایی و اجرا کند:\nتابع تست باید با Test شروع شود. آرگومان آن باید دقیقاً t *testing.T باشد. نباید مقدار برگشتی داشته باشد. فایل باید پسوند _test.go داشته باشد. 7.2.1.4 نحوه سازمان‌دهی فایل‌ها و پوشه‌ها # در Go، تست‌ها معمولاً در کنار کد اصلی قرار می‌گیرند:\n1calculator/ 2├── add.go 3└── add_test.go اما برای تست رفتار خارجی بدون دسترسی به توابع یا متغیرهای داخلی، می‌توان از پکیج mypkg_test استفاده کرد که نسخه‌ای مجزا از پکیج اصلی بدون دسترسی داخلی است:\n1package mypkg_test این روش برای نوشتن تست‌های سطح بالاتر یا رفتار مصرف‌کننده بسیار مناسب است.\n7.2.1.5 اجرای تست # اجرای ساده:\n1go test اجرای یک تابع خاص:\n1go test -run=TestAdd اجرا با جزئیات بیشتر (verbose):\n1go test -v 7.2.1.6 چرا این ساختار موفق است؟ # دلایل موفقیت رویکرد Go در تست‌های واحد:\nخوانایی بالا: هر تست به‌راحتی قابل درک و تحلیل است. حداقل boilerplate: بدون نیاز به setup یا framework. اجرای سریع: تست‌ها بلافاصله اجرا می‌شوند. پشتیبانی بومی ابزارها: بدون وابستگی خارجی. 7.2.2 روش‌های مدیریت خطا در تست‌ها # در تست‌های واحد، بررسی رفتار توابع در مواجهه با خطا یکی از حیاتی‌ترین جنبه‌هاست. بسیاری از توابع در Go به‌جای پرتاب استثنا، مقادیر error بازمی‌گردانند، بنابراین انتظار بروز خطا یا نبود خطا بخشی مهم از منطق تست است. تستی که فقط مقدار بازگشتی موفق را بررسی کند، ناقص است. یک تست کامل باید حالت‌های failure را نیز پوشش دهد.\n7.2.2.1 بررسی خطاهای مورد انتظار # در بسیاری از مواقع، یک تابع در شرایط خاص باید خطا بازگرداند. تست صحیح باید این خطا را بررسی کرده و اطمینان حاصل کند که نوع خطا، پیام و زمان وقوع آن دقیقاً مطابق انتظار است.\nمثال:\n1func Divide(a, b int) (int, error) { 2 if b == 0 { 3 return 0, fmt.Errorf(\u0026#34;cannot divide by zero\u0026#34;) 4 } 5 return a / b, nil 6} تست:\n1func TestDivideByZero(t *testing.T) { 2 _, err := Divide(10, 0) 3 if err == nil { 4 t.Fatal(\u0026#34;expected error, got nil\u0026#34;) 5 } 6 if err.Error() != \u0026#34;cannot divide by zero\u0026#34; { 7 t.Errorf(\u0026#34;unexpected error message: %v\u0026#34;, err) 8 } 9} 7.2.2.2 تست موفقیت در غیاب خطا # در طرف دیگر، باید اطمینان حاصل کنیم که در شرایط صحیح، تابع بدون خطا عمل می‌کند:\n1func TestDivideSuccess(t *testing.T) { 2 res, err := Divide(10, 2) 3 if err != nil { 4 t.Fatalf(\u0026#34;unexpected error: %v\u0026#34;, err) 5 } 6 if res != 5 { 7 t.Errorf(\u0026#34;expected 5, got %d\u0026#34;, res) 8 } 9} 7.2.2.3 استفاده از errors.Is و errors.As # در شرایط حرفه‌ای، به‌جای بررسی پیام خطا، بهتر است از توابع استاندارد کتابخانه errors برای بررسی نوع خطا استفاده شود، خصوصاً زمانی که خطاها wrap می‌شوند.\n1var ErrDivideByZero = errors.New(\u0026#34;cannot divide by zero\u0026#34;) 2 3func Divide(a, b int) (int, error) { 4 if b == 0 { 5 return 0, fmt.Errorf(\u0026#34;wrap: %w\u0026#34;, ErrDivideByZero) 6 } 7 return a / b, nil 8} تست:\n1func TestDivideByZeroTypedError(t *testing.T) { 2 _, err := Divide(1, 0) 3 if !errors.Is(err, ErrDivideByZero) { 4 t.Errorf(\u0026#34;expected ErrDivideByZero, got %v\u0026#34;, err) 5 } 6} 7.2.2.4 پوشش تمامی مسیرهای منطقی # هر تابعی که دارای چند مسیر شرطی است، باید در تست‌های واحد به‌صورت جداگانه در تمامی مسیرها آزمایش شود. عدم پوشش یکی از مسیرها می‌تواند منجر به بروز باگ‌های پنهان در آینده شود.\nبرای مثال، تابع زیر دو مسیر دارد:\n1func Authenticate(token string) error { 2 if token == \u0026#34;\u0026#34; { 3 return errors.New(\u0026#34;token required\u0026#34;) 4 } 5 return nil 6} تست صحیح باید هر دو مسیر را پوشش دهد:\n1func TestAuthenticate(t *testing.T) { 2 tests := []struct { 3 name string 4 input string 5 wantErr bool 6 }{ 7 {\u0026#34;valid token\u0026#34;, \u0026#34;abc123\u0026#34;, false}, 8 {\u0026#34;empty token\u0026#34;, \u0026#34;\u0026#34;, true}, 9 } 10 11 for _, tt := range tests { 12 t.Run(tt.name, func(t *testing.T) { 13 err := Authenticate(tt.input) 14 if (err != nil) != tt.wantErr { 15 t.Errorf(\u0026#34;unexpected error result. got error=%v\u0026#34;, err) 16 } 17 }) 18 } 19} این تکنیک با نام تست جدول‌محور شناخته می‌شود و در بخش بعدی به‌صورت مفصل بررسی خواهد شد.\n7.2.3 تست توابع غیرصادرشده (Unexported) و کاربرد پکیج _test # در Go، توابع یا انواعی که با حرف کوچک آغاز می‌شوند، تنها در محدوده همان پکیج قابل مشاهده هستند. این ویژگی در راستای اصل کپسوله‌سازی طراحی شده است. اما گاهی لازم است این توابع غیرصادرشده را نیز مورد تست قرار دهیم. برای این کار، چند رویکرد رایج وجود دارد که هرکدام بسته به هدف تست قابل انتخاب هستند.\n7.2.3.1 نوشتن تست در همان پکیج # در ساده‌ترین حالت، فایل تست را در همان پکیجی می‌نویسیم که کد اصلی قرار دارد. این روش به تست دسترسی کامل به توابع، متغیرها و انواع داخلی را می‌دهد.\n1// file: internal.go 2package math 3 4func subtract(a, b int) int { 5 return a - b 6} 1// file: internal_test.go 2package math 3 4import \u0026#34;testing\u0026#34; 5 6func TestSubtract(t *testing.T) { 7 if subtract(5, 3) != 2 { 8 t.Errorf(\u0026#34;expected 2, got %d\u0026#34;, subtract(5, 3)) 9 } 10} این روش توصیه‌شده و رسمی‌ترین راه برای تست موارد غیرصادرشده است.\n7.2.3.2 استفاده از پکیج تست جداگانه (_test) # اگر بخواهیم تست‌ها کاملاً از رفتار داخلی جدا باشند و فقط از رابط عمومی (public API) استفاده کنند، می‌توانیم از یک پکیج با پسوند _test استفاده کنیم. این روش برای نوشتن تست‌های سطح بالاتر یا رفتاری مناسب است.\n1// file: api_test.go 2package math_test 3 4import ( 5 \u0026#34;testing\u0026#34; 6 \u0026#34;mymodule/math\u0026#34; 7) 8 9func TestAddPublic(t *testing.T) { 10 got := math.Add(1, 2) 11 if got != 3 { 12 t.Errorf(\u0026#34;expected 3, got %d\u0026#34;, got) 13 } 14} در این حالت:\nتوابع داخلی (مثل subtract) دیگر قابل دسترسی نیستند. تنها توابع صادرشده در دسترس هستند. این یک تست \u0026ldquo;از بیرون\u0026rdquo; یا \u0026ldquo;black-box\u0026rdquo; محسوب می‌شود. 7.2.3.3 تست غیرمستقیم توابع داخلی # اگر تابع غیرصادرشده به‌صورت مستقیم قابل تست نیست ولی از طریق توابع صادرشده فراخوانی می‌شود، بهترین راه تست آن به‌صورت غیرمستقیم و از طریق خروجی تابع صادرشده است. به این ترتیب، تست به ساختار داخلی وابسته نخواهد بود.\nمزیت این روش:\nتست پایدارتر باقی می‌ماند. وابستگی به جزییات پیاده‌سازی کاهش می‌یابد. 7.2.3.4 مزایا و معایب هر رویکرد # روش مزایا معایب پکیج داخلی (package x) دسترسی کامل به کد وابستگی مستقیم به پیاده‌سازی پکیج _test تست رفتاری و بدون وابستگی به داخل عدم امکان تست مستقیم کد داخلی تست غیرمستقیم افزایش انعطاف تست و پایداری طولانی‌مدت پوشش دقیق همه مسیرها ممکن نیست 7.2.3.5 نکات تجربی # تست توابع داخلی اگر رفتار پیچیده‌ای دارند، ضروری است. اگر یک تابع داخلی توسط تابع صادرشده‌ای فراخوانی نمی‌شود، بهتر است به صورت مستقل در همان پکیج تست شود. از پکیج _test در تست‌های انتهایی یا برای نوشتن سناریوهای بلندمدت استفاده کنید. 7.2.4 نکات کاربردی و اشتباهات رایج در تست‌های واحد # یونیت تست‌نویسی در Go به دلیل سادگی و سرعت بالا، بسیار محبوب است؛ اما همین سادگی ممکن است باعث شود برخی نکات ظریف، اما مهم، نادیده گرفته شوند. در این بخش، مجموعه‌ای از توصیه‌های عملی و اشتباهات رایج در یونیت تست‌ها را مرور می‌کنیم که رعایت آن‌ها منجر به تست‌هایی دقیق‌تر، پایدارتر و قابل نگهداری‌تر خواهد شد.\n7.2.4.1 تفاوت بین t.Error و t.Fatal را بشناسید # یکی از اشتباهات رایج، استفاده اشتباه از t.Fatal به‌جای t.Error یا بالعکس است.\nاز t.Error زمانی استفاده کنید که می‌خواهید خطا را ثبت کنید ولی اجازه دهید تست ادامه پیدا کند. از t.Fatal زمانی استفاده کنید که ادامه‌ی تست بی‌معنا است و باید بلافاصله متوقف شود. مثال:\n1if err != nil { 2 t.Fatal(\u0026#34;cannot continue test, error:\u0026#34;, err) 3} 4if result != expected { 5 t.Error(\u0026#34;wrong result, got\u0026#34;, result) 6} اگر با یک خطای بحرانی مثل failure در ورودی مواجه شدید، Fatal مناسب‌تر است.\n7.2.4.2 از time.Sleep در یونیت تست استفاده نکنید # استفاده از time.Sleep برای منتظر ماندن در تست باعث ایجاد تست‌های ناپایدار و کند می‌شود. به‌جای آن، از تکنیک‌های مبتنی بر کانال یا تکرارهای سریع (retry) استفاده کنید.\n❌ بد:\n1time.Sleep(100 * time.Millisecond) ✅ بهتر:\n1for i := 0; i \u0026lt; 100; i++ { 2 if ready() { 3 break 4 } 5 time.Sleep(1 * time.Millisecond) 6} 7.2.4.3 تست‌های وابسته به زمان را کنترل کنید # تست‌هایی که از time.Now() یا time.Since() استفاده می‌کنند باید طوری طراحی شوند که قابل پیش‌بینی باقی بمانند. راهکار:\nتزریق زمان (dependency injection) استفاده از clock mock 7.2.4.4 از t.TempDir() برای ساخت فایل‌ موقت استفاده کنید # اگر تست نیاز به فایل یا پوشه موقتی دارد، به‌جای نوشتن مسیر دستی از t.TempDir() استفاده کنید:\n1func TestWriteFile(t *testing.T) { 2 dir := t.TempDir() 3 path := filepath.Join(dir, \u0026#34;file.txt\u0026#34;) 4 _ = os.WriteFile(path, []byte(\u0026#34;data\u0026#34;), 0644) 5 // فایل بعد از تست به‌صورت خودکار پاک می‌شود 6} 7.2.4.5 مراقب caching ناخواسته باشید # هنگام اجرای مکرر تست‌ها، اگر خروجی تست‌ها در حال تغییر باشد، ممکن است به دلیل کش شدن نتیجه، نتیجه قبلی دوباره نمایش داده شود. برای جلوگیری:\n1go test -count=1 یا پاک‌سازی کامل کش:\n1go clean -testcache 7.2.4.6 تست نباید فقط تابع را صدا بزند # یونیت تست‌هایی که تنها تابع را اجرا می‌کنند ولی هیچ بررسی‌ای انجام نمی‌دهند، بی‌فایده‌اند.\n❌ بد:\n1func TestNoCheck(t *testing.T) { 2 DoSomething() 3} ✅ درست:\n1func TestDoSomething(t *testing.T) { 2 result := DoSomething() 3 if result != expected { 4 t.Errorf(\u0026#34;expected %v, got %v\u0026#34;, expected, result) 5 } 6} 7.2.4.7 گزارش‌دهی دقیق بنویسید # در هنگام ثبت خطا با t.Errorf یا t.Fatalf، حتماً اطلاعات کامل بدهید:\n1t.Errorf(\u0026#34;expected %d, got %d\u0026#34;, want, got) این کار در زمان تحلیل خروجی تست‌ها بسیار مفید است.\n7.2.4.8 نام‌گذاری مناسب تست‌ها # نام تست باید گویای هدف تست باشد:\n1func TestDivideByZeroReturnsError(t *testing.T) { ... } 2func TestAddPositiveNumbers(t *testing.T) { ... } از نام‌هایی مثل Test1, TestA, TestXYZ اجتناب کنید.\n7.2.5 تست واحد برای ساختارها و متدهای گیرنده # در زبان Go، بسیاری از قابلیت‌های سطح بالا از طریق متدهایی روی ساختارها (structs) پیاده‌سازی می‌شوند. این متدها بسته به نوع گیرنده‌شان (value receiver یا pointer receiver) و میزان وابستگی‌شان به وضعیت داخلی ساختار، نیاز به طراحی تست دقیق‌تری دارند.\nدر این بخش، بررسی می‌کنیم که چگونه می‌توان به صورت مؤثر برای متدهای متصل به ساختارها تست واحد نوشت.\n7.2.5.1 تست متدهای گیرنده مقداری (value receiver) # اگر متدی گیرنده مقداری دارد، معمولاً روی یک نسخه‌ی کپی‌شده از ساختار عمل می‌کند و تغییری در وضعیت اصلی ایجاد نمی‌کند. تست چنین متدهایی بسیار ساده است.\nمثال:\n1type Point struct { 2\tX, Y int 3} 4 5func (p Point) IsOrigin() bool { 6\treturn p.X == 0 \u0026amp;\u0026amp; p.Y == 0 7} تست:\n1func TestPoint_IsOrigin(t *testing.T) { 2\tp := Point{X: 0, Y: 0} 3\tif !p.IsOrigin() { 4\tt.Error(\u0026#34;expected true, got false\u0026#34;) 5\t} 6} 7.2.5.2 تست متدهای گیرنده اشاره‌گری (pointer receiver) # اگر متد وضعیت داخلی ساختار را تغییر می‌دهد یا به صورت اشاره‌گری تعریف شده، در تست باید دقت بیشتری کرد.\nمثال:\n1func (p *Point) Move(dx, dy int) { 2\tp.X += dx 3\tp.Y += dy 4} تست:\n1func TestPoint_Move(t *testing.T) { 2\tp := \u0026amp;Point{X: 1, Y: 2} 3\tp.Move(3, 4) 4\tif p.X != 4 || p.Y != 6 { 5\tt.Errorf(\u0026#34;expected (4,6), got (%d,%d)\u0026#34;, p.X, p.Y) 6\t} 7} توجه: حتماً باید از اشاره‌گر (\u0026amp;Point{...}) استفاده شود، چون متد روی pointer تعریف شده است.\n7.2.5.3 تست چند متد روی یک نمونه # اگر چند متد متوالی روی یک نمونه اعمال می‌شود (تغییر وضعیت گام‌به‌گام)، بهتر است تست در قالب subtest یا جدول تست طراحی شود تا خوانایی حفظ شود.\n1func TestPoint_Sequence(t *testing.T) { 2\tp := \u0026amp;Point{} 3\tt.Run(\u0026#34;Move\u0026#34;, func(t *testing.T) { 4\tp.Move(2, 2) 5\t}) 6\tt.Run(\u0026#34;Check\u0026#34;, func(t *testing.T) { 7\tif p.X != 2 || p.Y != 2 { 8\tt.Errorf(\u0026#34;expected (2,2), got (%d,%d)\u0026#34;, p.X, p.Y) 9\t} 10\t}) 11} 7.2.5.4 جداسازی لایه logic از state # در پروژه‌های واقعی، اگر متد ساختار منطق پیچیده دارد، توصیه می‌شود محاسبات را از وضعیت جدا کرده و در توابع مستقل pure قرار دهید تا تست‌پذیرتر شود.\nمثال بهینه‌شده:\n1func calculateNewPosition(x, y, dx, dy int) (int, int) { 2\treturn x + dx, y + dy 3} این تابع را می‌توان به راحتی در یونیت تست مستقل بررسی کرد، بدون نیاز به ساختار.\n7.2.5.5 رفتار پیش‌فرض در مقادیر تهی (zero value) # در Go، مقدار پیش‌فرض (zero value) برای structها معتبر است و معمولاً باید بتوان از آن استفاده کرد. تست این رفتار برای ساختارهایی که متد دارند مهم است.\n1func TestZeroValueBehavior(t *testing.T) { 2\tvar p Point 3\tif !p.IsOrigin() { 4\tt.Error(\u0026#34;expected origin from zero value\u0026#34;) 5\t} 6} 7.2.5.6 ترکیب متد و خطا # در صورتی که متدی روی struct خطا بازمی‌گرداند، حتماً باید شرایط موفق/ناموفق را تست کنید:\n1type User struct { 2\tEmail string 3} 4 5func (u *User) Validate() error { 6\tif u.Email == \u0026#34;\u0026#34; { 7\treturn errors.New(\u0026#34;email required\u0026#34;) 8\t} 9\treturn nil 10} تست:\n1func TestUser_Validate(t *testing.T) { 2\ttests := []struct { 3\temail string 4\twantErr bool 5\t}{ 6\t{\u0026#34;\u0026#34;, true}, 7\t{\u0026#34;hello@example.com\u0026#34;, false}, 8\t} 9 10\tfor _, tt := range tests { 11\tu := \u0026amp;User{Email: tt.email} 12\terr := u.Validate() 13\tif (err != nil) != tt.wantErr { 14\tt.Errorf(\u0026#34;unexpected error state for email %q\u0026#34;, tt.email) 15\t} 16\t} 17} 7.2.6 تفکیک تست‌های سریع و آهسته با -short # در پروژه‌های واقعی، برخی تست‌ها بسیار سریع هستند و بلافاصله اجرا می‌شوند، اما برخی دیگر—به‌دلایل مختلفی مانند تعامل با فایل، شبکه، زمان‌سنجی، یا دیتابیس—کندتر هستند و ممکن است زمان‌بر یا شکننده (flaky) باشند. ابزار go test راهکاری ساده برای تفکیک این دو نوع تست فراهم کرده است: استفاده از فلگ -short.\nهنگامی که دستور زیر اجرا می‌شود:\n1go test -short آرگومان -short به تمامی توابع تست به‌صورت خودکار ارسال می‌شود. سپس داخل کد می‌توان با استفاده از متد testing.Short() بررسی کرد که آیا این تست باید اجرا شود یا رد شود.\n7.2.6.1 مثال کاربردی # 1func TestSlowOperation(t *testing.T) { 2\tif testing.Short() { 3\tt.Skip(\u0026#34;skipping slow test in short mode\u0026#34;) 4\t} 5 6\ttime.Sleep(5 * time.Second) // تست کند 7\tt.Log(\u0026#34;test completed\u0026#34;) 8} در اجرای معمولی:\n1go test تست اجرا می‌شود. اما در حالت short:\n1go test -short خروجی:\n1--- SKIP: TestSlowOperation (0.00s) 2 slow_test.go:4: skipping slow test in short mode 3PASS 7.2.6.2 مزایا # اجرای سریع‌تر تست‌ها در حالت پیش‌فرض مناسب برای CI pipelines سبک یا اجراهای local حذف تست‌هایی که به منابع خارجی یا شرایط خاص نیاز دارند 7.2.6.3 نکته مهم # بهتر است تست‌های کند را با شرط testing.Short() کنترل کنید نه اینکه به‌طور کلی حذف‌شان کنید یا در فایل جداگانه بگذارید. این کار نگهداری و اجرای تست‌ها را انعطاف‌پذیرتر می‌کند.\n7.2.6.4 ترکیب با ابزارهای دیگر # در سیستم‌های CI/CD، می‌توان دو مرحله اجرای تست داشت:\n1go test -short ./... # فقط تست‌های سریع 2go test ./... # همه تست‌ها (مثلاً فقط در زمان انتشار نسخه) "},{"id":98,"href":"/chapter-7/go-table-driven-tests/","title":"7.3 تست جدول‌محور (Table-Driven Test)","section":"فصل هفتم: تست نویسی","content":"در زبان Go، یکی از الگوهای محبوب و بسیار قدرتمند برای نوشتن تست‌های واحد و رفتاری، الگوی «تست جدول‌محور» است. این سبک از تست‌نویسی نه‌تنها منجر به حذف تکرارهای زائد در کد تست می‌شود، بلکه ساختاری منسجم برای تعریف سناریوهای مختلف تست، به همراه ورودی و خروجی‌های مورد انتظار، فراهم می‌سازد.\nدر این الگو، مجموعه‌ای از تست‌ها به‌صورت یک جدول از structها تعریف می‌شود که شامل نام تست، ورودی‌ها، خروجی مورد انتظار، و گاهی انتظار وقوع خطا است. سپس با استفاده از یک حلقه و تابع t.Run، هر ردیف از جدول به‌صورت یک تست مستقل (subtest) اجرا می‌شود. این طراحی باعث می‌شود اضافه‌کردن یک تست جدید، تنها با افزودن یک struct به جدول امکان‌پذیر باشد—بدون نیاز به کپی‌کردن منطق کلی تست.\nاین نوع تست‌نویسی به‌طور ویژه برای پوشش کامل مسیرهای مختلف در توابعی با منطق شرطی یا چند حالت ورودی مناسب است. همچنین، به‌کارگیری آن در کنار subtestها موجب می‌شود گزارش شکست‌ها دقیق‌تر، ساخت‌یافته‌تر و خواناتر باشد. در پروژه‌های مقیاس‌پذیر، این سبک نه‌تنها خوانایی تست‌ها را حفظ می‌کند، بلکه روند توسعه و نگهداری آن‌ها را نیز تسهیل می‌کند.\nدر ادامه‌ی این بخش، ابتدا ساختار استاندارد یک تست جدول‌محور را معرفی می‌کنیم، سپس به بررسی تکنیک‌های پیشرفته، اشتباهات رایج، اجرای موازی تست‌ها، طراحی تست‌های نگهدارنده‌ی خطا، و الگوهای پیشنهادی برای پروژه‌های واقعی می‌پردازیم.\n7.3.1 ساختار پایه تست جدول‌محور و مثال ساده # الگوی تست‌های جدول‌محور در Go یکی از کاربردی‌ترین الگوهای تست‌نویسی است که توسط بسیاری از توسعه‌دهندگان و در پروژه‌های رسمی Go نیز به کار می‌رود. این سبک از تست‌نویسی، بر پایه‌ی تعریف یک جدول از سناریوهای تست و اجرای آن‌ها در یک حلقه‌ی ساده بنا شده است. هدف، کاهش تکرار در کد تست، افزایش خوانایی و ساده‌سازی افزودن موارد تست جدید است.\nدر این الگو، هر ردیف جدول معمولاً یک struct است که شامل فیلدهایی مانند نام تست، ورودی‌ها، خروجی مورد انتظار، و گاهی هم انتظار وقوع خطاست. ساختار کلی آن شبیه به کد زیر است:\n1func TestAdd(t *testing.T) { 2\ttests := []struct { 3\tname string 4\ta, b int 5\texpected int 6\t}{ 7\t{\u0026#34;positive numbers\u0026#34;, 2, 3, 5}, 8\t{\u0026#34;negative numbers\u0026#34;, -1, -2, -3}, 9\t{\u0026#34;mixed signs\u0026#34;, -1, 2, 1}, 10\t} 11 12\tfor _, tt := range tests { 13\tt.Run(tt.name, func(t *testing.T) { 14\tgot := Add(tt.a, tt.b) 15\tif got != tt.expected { 16\tt.Errorf(\u0026#34;expected %d, got %d\u0026#34;, tt.expected, got) 17\t} 18\t}) 19\t} 20} در این مثال:\nبا استفاده از t.Run برای هر تست یک subtest تعریف شده است. پیام‌های شکست تست شامل tt.name هستند که گزارش خطا را واضح‌تر و دقیق‌تر می‌کنند. اضافه‌کردن یک سناریوی تست جدید بسیار ساده است: فقط کافی‌ست یک struct دیگر به tests اضافه کنید. این سبک به‌عنوان راه‌حل رسمی جامعه‌ی Go برای تست‌های با مسیرهای متنوع در توابع معرفی شده است.\n7.3.1.1 مزایای اصلی این الگو # مزایای اصلی این الگو عبارت‌اند از:\nکاهش قابل‌توجه تکرار کد (DRY) ساده‌سازی تحلیل و نگهداری تست‌ها قابلیت اجرای موازی آسان با t.Parallel() مناسب برای پوشش مسیرهای شرطی و edge cases امکان افزودن متغیرهای اضافی مثل wantErr, errorMessage, expectedStatusCode 7.3.1.2 جایگزینی حلقه ساده با map برای بهبود خوانایی # در مثال قبل از یک slice از struct استفاده شد. اما می‌توان از map[string]testCase] هم استفاده کرد تا به‌طور مستقیم نام تست را به‌عنوان کلید بیاوریم و خوانایی را افزایش دهیم:\n1func TestMultiply(t *testing.T) { 2\ttests := map[string]struct { 3\ta, b int 4\texpected int 5\t}{ 6\t\u0026#34;zero\u0026#34;: {0, 5, 0}, 7\t\u0026#34;positive\u0026#34;: {2, 3, 6}, 8\t\u0026#34;negative\u0026#34;: {-2, 4, -8}, 9\t\u0026#34;mixed signs\u0026#34;: {-3, -2, 6}, 10\t} 11 12\tfor name, tt := range tests { 13\ttt := tt 14\tt.Run(name, func(t *testing.T) { 15\tgot := Multiply(tt.a, tt.b) 16\tif got != tt.expected { 17\tt.Errorf(\u0026#34;expected %d, got %d\u0026#34;, tt.expected, got) 18\t} 19\t}) 20\t} 21} نکته مهم در این مثال این است که حتماً باید از کپی tt := tt در ابتدای هر subtest استفاده کنیم، تا از مشکل closure جلوگیری شود.\n7.3.1.3 مقایسه با تست‌های کلاسیک # در تست‌های کلاسیک، ممکن است سه یا چهار تابع تست مختلف برای یک تابع ساده نوشته شود، که هم خوانایی را پایین می‌آورد و هم نگهداری را سخت می‌کند. با Table Test، می‌توان همه این تست‌ها را در یک حلقه با ساختار مشترک نگه داشت.\n7.3.1.4 زمانی که Table Test مناسب نیست # گرچه این الگو بسیار مفید است، اما همیشه انتخاب درست نیست. طبق منابع:\nاگر تست فقط یک حالت دارد، استفاده از جدول ممکن است کد را بی‌جهت پیچیده کند. در برخی تست‌های سطح بالا یا تست‌های تعامل‌محور (مثل تست UI یا سرویس‌های REST)، بهتر است تست‌ها به‌صورت مستقل و سناریو محور نوشته شوند، نه جدول‌محور. 7.3.2 تست خطا و ورودی‌های نادرست در Table Tests # یکی از مهم‌ترین مزایای تست‌های جدول‌محور این است که می‌توان به‌راحتی سناریوهای مثبت و منفی را در کنار هم پوشش داد. به‌ویژه زمانی که توابع شما ممکن است خطا بازگردانند یا در برابر ورودی‌های ناسالم رفتاری خاص نشان دهند، این سبک از تست‌نویسی به شکل چشمگیری ساخت‌یافته و مؤثر خواهد بود.\nدر طراحی جدول تست، معمولاً از فیلدی به‌نام wantErr یا expectErr برای تعیین انتظار بروز خطا استفاده می‌شود. این متغیر به تست‌نویس امکان می‌دهد تا به‌صورت واضح اعلام کند آیا در هر سناریو وقوع خطا انتظار می‌رود یا خیر.\n7.3.2.1 ساختار تست شامل انتظار خطا # 1func Divide(a, b int) (int, error) { 2\tif b == 0 { 3\treturn 0, fmt.Errorf(\u0026#34;division by zero\u0026#34;) 4\t} 5\treturn a / b, nil 6} تست جدول‌محور برای پوشش رفتار صحیح و خطا:\n1func TestDivide(t *testing.T) { 2\ttests := []struct { 3\tname string 4\ta, b int 5\twant int 6\twantErr bool 7\t}{ 8\t{\u0026#34;valid division\u0026#34;, 6, 3, 2, false}, 9\t{\u0026#34;zero divisor\u0026#34;, 5, 0, 0, true}, 10\t} 11 12\tfor _, tt := range tests { 13\ttt := tt 14\tt.Run(tt.name, func(t *testing.T) { 15\tgot, err := Divide(tt.a, tt.b) 16\tif (err != nil) != tt.wantErr { 17\tt.Fatalf(\u0026#34;unexpected error state: %v\u0026#34;, err) 18\t} 19\tif !tt.wantErr \u0026amp;\u0026amp; got != tt.want { 20\tt.Errorf(\u0026#34;expected %d, got %d\u0026#34;, tt.want, got) 21\t} 22\t}) 23\t} 24} در این ساختار:\nتست اول بررسی می‌کند که تقسیم معمولی به درستی انجام شده. تست دوم بررسی می‌کند که در تقسیم بر صفر، خطای مناسب بازگردانده شده. 7.3.2.2 نکاتی در مورد مقایسه خطا # برای تست دقیق‌تر خطا، گاهی لازم است پیام خطا یا نوع خطا بررسی شود. این کار را می‌توان با روش‌های مختلف انجام داد:\nمقایسه پیام خطا # 1if err != nil \u0026amp;\u0026amp; err.Error() != \u0026#34;division by zero\u0026#34; { 2\tt.Errorf(\u0026#34;unexpected error message: %v\u0026#34;, err) 3} استفاده از errors.Is یا errors.As # اگر خطا wrap شده باشد:\n1var ErrDivideByZero = errors.New(\u0026#34;division by zero\u0026#34;) 2 3if !errors.Is(err, ErrDivideByZero) { 4\tt.Errorf(\u0026#34;expected ErrDivideByZero, got %v\u0026#34;, err) 5} 7.3.2.3 ترکیب با subtest برای مدیریت بهتر # حتی در سناریوهای شامل خطا هم می‌توان از t.Parallel() برای اجرای موازی تست‌ها استفاده کرد، به شرطی که مقدار tt را در scope هر subtest کپی کرده باشیم:\n1t.Run(tt.name, func(t *testing.T) { 2\tt.Parallel() 3\t// اجرای تست 4}) 7.3.2.4 طراحی سناریوهای پیچیده‌تر # در بسیاری از پروژه‌ها ممکن است تست شامل چند فیلد دیگر مثل ورودی‌های پیچیده‌تر، اشیای اولیه‌شده، یا توابع callback باشد. در این صورت هم جدول تست می‌تواند گسترش یابد و همچنان خوانا باقی بماند.\nمثال:\n1tests := []struct { 2\tname string 3\tinput Request 4\twant Response 5\twantErr bool 6}{ 7\t{\u0026#34;valid input\u0026#34;, Request{ID: 1}, Response{Success: true}, false}, 8\t{\u0026#34;invalid input\u0026#34;, Request{}, Response{}, true}, 9} 7.3.3 اجرای موازی در تست‌های جدول‌محور با t.Parallel # اجرای تست‌ها به‌صورت موازی، یکی از قابلیت‌های مهم زبان Go است که می‌تواند سرعت اجرای تست‌ها را به شکل قابل‌توجهی افزایش دهد—به‌ویژه زمانی که تعداد زیادی تست داریم و هر تست مستقل از دیگری است. این ویژگی در کنار ساختار جدول‌محور، قدرتی ترکیبی می‌سازد که هم خوانایی بالا دارد و هم بازدهی.\nتابع t.Parallel() به Go اعلام می‌کند که تست جاری می‌تواند به‌صورت همزمان با سایر تست‌ها اجرا شود. اما برای استفاده صحیح از این ویژگی در حلقه‌ی تست‌های جدول‌محور، باید نکته‌ای کلیدی را رعایت کرد: متغیر loop (مانند tt) باید داخل scope هر subtest مجدداً shadow شود. در غیر این صورت، همه goroutineها ممکن است به مقدار یکسانی از tt اشاره کنند و باعث بروز نتایج اشتباه شوند.\n7.3.3.1 مثال صحیح استفاده از t.Parallel # 1func TestMultiply(t *testing.T) { 2\ttests := []struct { 3\tname string 4\ta, b int 5\texpected int 6\t}{ 7\t{\u0026#34;positive\u0026#34;, 2, 3, 6}, 8\t{\u0026#34;zero\u0026#34;, 0, 4, 0}, 9\t{\u0026#34;negative\u0026#34;, -1, 3, -3}, 10\t} 11 12\tfor _, tt := range tests { 13\ttt := tt // کپی کردن متغیر برای جلوگیری از race 14\tt.Run(tt.name, func(t *testing.T) { 15\tt.Parallel() 16\tgot := Multiply(tt.a, tt.b) 17\tif got != tt.expected { 18\tt.Errorf(\u0026#34;expected %d, got %d\u0026#34;, tt.expected, got) 19\t} 20\t}) 21\t} 22} در این مثال:\nt.Parallel() در ابتدای هر subtest فراخوانی شده. متغیر tt := tt باعث شده هر goroutine مقدار اختصاصی خود را داشته باشد. 7.3.3.2 چه زمانی نباید از t.Parallel استفاده کنیم # با وجود مزایای بالا، استفاده از اجرای موازی در همه‌ی تست‌ها توصیه نمی‌شود. در موارد زیر باید با احتیاط یا اصلاً از t.Parallel() استفاده نکنید:\nتست‌هایی که به منابع مشترک دسترسی دارند\nمانند فایل سیستم، دیتابیس، متغیرهای global یا سرویس خارجی. تست‌هایی که به ترتیب اجرا وابسته‌اند تست‌هایی که در زمان اجرا وضعیت را تغییر می‌دهند\nمثلاً حذف یا ایجاد فایل، تغییر در داده‌های اشتراکی. در این موارد، یا تست‌ها را به صورت ترتیبی اجرا کنید، یا منابع را ایزوله کنید (مثلاً از t.TempDir() برای مسیرهای جداگانه استفاده کنید).\n7.3.3.3 ترکیب تست موازی با زیرساخت CI # اجرای موازی تست‌ها در CI/CD، به‌ویژه برای پروژه‌های بزرگ، مزیت مهمی محسوب می‌شود. اما لازم است:\nتست‌ها ایزوله باشند. از حافظه یا دیسک مشترک استفاده نکنند. تست‌ها به‌صورت مستقل از محیط اجرا شوند. 7.3.4 ساخت تست‌های قابل نگهداری و خوانا در جدول‌ها # یکی از دلایل اصلی محبوبیت تست‌های جدول‌محور، سهولت در نگهداری و خوانایی بالای آن‌هاست. اما اگر این الگو به‌درستی اجرا نشود، می‌تواند به کدی پیچیده، گنگ و به‌سختی قابل گسترش تبدیل شود. در این بخش، تکنیک‌هایی برای نوشتن تست‌های جدول‌محور خوانا، قابل گسترش و با حداقل خطا ارائه می‌شود.\n7.3.4.1 استفاده از نام‌های گویا برای هر تست # در جدول تست، فیلد name باید دقیق، گویا و منعکس‌کننده‌ی هدف هر تست باشد. این نام در گزارش‌های خروجی تست نمایش داده می‌شود و کلید تحلیل سریع‌تر خطاهاست.\nمثال خوب:\n1{ 2\tname: \u0026#34;returns error when divisor is zero\u0026#34;, 3\ta: 10, b: 0, wantErr: true, 4} اجتناب شود از نام‌هایی مانند:\n1\u0026#34;name\u0026#34;: \u0026#34;test1\u0026#34; 7.3.4.2 مرتب‌سازی منطقی تست‌ها # در جدول تست، بهتر است تست‌ها را به ترتیب معنایی یا گروه‌بندی شده قرار دهید:\nتست‌های موفق اول، سپس تست‌های خطا یا تست‌هایی با رفتار مشابه در کنار هم\nاین کار، درک و دیباگ تست را ساده‌تر می‌کند. 7.3.4.3 تعریف type مجزا برای تست‌کیس‌ها (در پروژه‌های بزرگ) # برای جلوگیری از تکرار تعریف struct در چندین تابع تست و ارتقای وضوح کد، می‌توان type اختصاصی برای تست‌کیس‌ها تعریف کرد:\n1type divideTestCase struct { 2\tname string 3\ta, b int 4\twant int 5\twantErr bool 6} و سپس در جدول تست:\n1tests := []divideTestCase{ ... } این کار به‌ویژه در تست‌های پیچیده یا تکراری در چند فایل بسیار مفید است.\n7.3.4.4 تعریف توابع کمکی برای assertions و آماده‌سازی # در صورت نیاز به تکرار منطق‌های بررسی نتیجه، یا ایجاد ورودی‌های خاص، بهتر است توابع کمکی بنویسید تا از تکرار و پراکندگی منطق جلوگیری شود.\nمثال:\n1func assertEqual(t *testing.T, got, want int) { 2\tif got != want { 3\tt.Errorf(\u0026#34;expected %d, got %d\u0026#34;, want, got) 4\t} 5} و در تست:\n1t.Run(tc.name, func(t *testing.T) { 2\tresult := Add(tc.a, tc.b) 3\tassertEqual(t, result, tc.expected) 4}) 7.3.4.5 الگوی توصیه‌شده برای تست‌های قابل نگهداری # 1type mathTest struct { 2\tname string 3\ta, b int 4\twant int 5\twantErr bool 6} 7 8func TestDivide(t *testing.T) { 9\tcases := []mathTest{ 10\t{\u0026#34;valid input\u0026#34;, 8, 2, 4, false}, 11\t{\u0026#34;zero divisor\u0026#34;, 10, 0, 0, true}, 12\t} 13 14\tfor _, tc := range cases { 15\ttc := tc 16\tt.Run(tc.name, func(t *testing.T) { 17\tt.Parallel() 18\tgot, err := Divide(tc.a, tc.b) 19\tif (err != nil) != tc.wantErr { 20\tt.Errorf(\u0026#34;unexpected error state: %v\u0026#34;, err) 21\t} 22\tif !tc.wantErr \u0026amp;\u0026amp; got != tc.want { 23\tt.Errorf(\u0026#34;expected %d, got %d\u0026#34;, tc.want, got) 24\t} 25\t}) 26\t} 27} در این الگو:\nt.Parallel() برای سرعت بالا tc := tc برای جلوگیری از closure bug پیام‌های دقیق و واضح struct مشخص و تایپ‌شده برای هر تست 7.3.5 استفاده از تست‌های تو در تو (Subtests) در Table Test # در بسیاری از مواقع، هر سناریوی تست خودش شامل چند حالت بررسی‌شدنی است. به‌جای اینکه این موارد را به تست‌های مجزای بزرگ و تودرتو تبدیل کنیم، می‌توان با استفاده از t.Run برای هر بخش از منطق، تست‌های تو در تو (Subtests) تعریف کرد. این قابلیت که از Go 1.7 به بعد اضافه شده، ابزار قدرتمندی برای سازمان‌دهی بهتر تست‌ها، گزارش‌گیری دقیق‌تر و امکان اجرای هدفمند تست‌ها فراهم می‌کند.\n7.3.5.1 مثال ساده از Subtest در Table Test # فرض کنیم تابعی داریم که عملیات روی کاربر انجام می‌دهد و در هر حالت باید چند ویژگی خروجی را بررسی کنیم. برای هر حالت، چند subtest تعریف می‌کنیم:\n1func TestUserValidation(t *testing.T) { 2\ttests := []struct { 3\tname string 4\tuser User 5\twantErr bool 6\twantRole string 7\t}{ 8\t{\u0026#34;valid user\u0026#34;, User{Email: \u0026#34;a@b.com\u0026#34;}, false, \u0026#34;user\u0026#34;}, 9\t{\u0026#34;missing email\u0026#34;, User{}, true, \u0026#34;\u0026#34;}, 10\t} 11 12\tfor _, tt := range tests { 13\ttt := tt 14\tt.Run(tt.name, func(t *testing.T) { 15\tt.Run(\u0026#34;validate email\u0026#34;, func(t *testing.T) { 16\terr := tt.user.Validate() 17\tif (err != nil) != tt.wantErr { 18\tt.Errorf(\u0026#34;error mismatch: %v\u0026#34;, err) 19\t} 20\t}) 21 22\tt.Run(\u0026#34;check role\u0026#34;, func(t *testing.T) { 23\tif tt.user.Role() != tt.wantRole { 24\tt.Errorf(\u0026#34;expected role %q, got %q\u0026#34;, tt.wantRole, tt.user.Role()) 25\t} 26\t}) 27\t}) 28\t} 29} در این مثال:\nهر tt یک مورد جدول تست است. دو زیرتست برای هر tt اجرا می‌شود: بررسی اعتبار ایمیل بررسی نقش پیش‌فرض خروجی تست‌ها در گزارش نیز به صورت سلسله‌مراتبی نشان داده می‌شود که کمک بزرگی به عیب‌یابی است.\n7.3.5.2 مزایای استفاده از Subtestها در Table Test # دسته‌بندی معنایی تست‌ها: هر مرحله از تست می‌تواند subtest جداگانه داشته باشد. گزارش دقیق‌تر خطا: نام تست‌های تودرتو در گزارش CLI و CI به صورت کامل دیده می‌شود. امکان اجرای selective: می‌توان فقط یک subtest خاص را با flag -run اجرا کرد: 1go test -run=\u0026#34;TestUserValidation/valid_user/check_role\u0026#34; 7.3.5.3 اجرای موازی Subtestها # در صورتی که هر subtest ایزوله باشد، می‌توان از t.Parallel() نیز داخل آن استفاده کرد:\n1t.Run(\u0026#34;parallel section\u0026#34;, func(t *testing.T) { 2\tt.Parallel() 3\t// عملیات تست 4}) 7.3.5.4 نمونه‌ای پیشرفته‌تر: Table + Subtest + Parallel # 1func TestCalculator(t *testing.T) { 2\ttests := []struct { 3\tname string 4\ta, b int 5\t}{ 6\t{\u0026#34;positive\u0026#34;, 1, 2}, 7\t{\u0026#34;negative\u0026#34;, -1, -3}, 8\t} 9 10\tfor _, tt := range tests { 11\ttt := tt 12\tt.Run(tt.name, func(t *testing.T) { 13\tt.Run(\u0026#34;Add\u0026#34;, func(t *testing.T) { 14\tt.Parallel() 15\tif Add(tt.a, tt.b) != tt.a+tt.b { 16\tt.Fail() 17\t} 18\t}) 19\tt.Run(\u0026#34;Multiply\u0026#34;, func(t *testing.T) { 20\tt.Parallel() 21\tif Multiply(tt.a, tt.b) != tt.a*tt.b { 22\tt.Fail() 23\t} 24\t}) 25\t}) 26\t} 27} 7.3.6 خطاهای رایج در پیاده‌سازی Table Tests # اگرچه تست‌های جدول‌محور در Go بسیار توصیه می‌شوند و ساختار مؤثری برای مدیریت سناریوهای متنوع تست فراهم می‌کنند، اما اگر به‌درستی پیاده‌سازی نشوند، می‌توانند منجر به تست‌هایی شکننده، گمراه‌کننده یا حتی ناکارآمد شوند. در این بخش، به بررسی خطاهای رایج در پیاده‌سازی Table Tests و راه‌های جلوگیری از آن‌ها می‌پردازیم.\n7.3.6.1 استفاده اشتباه از متغیر loop (closure bug) # یکی از خطرناک‌ترین و رایج‌ترین اشتباهات، استفاده مستقیم از متغیر loop (tt) درون تابع t.Run است. به دلیل اینکه tt در هر iteration یک متغیر مشترک است، همه goroutineها ممکن است به آخرین مقدار آن دسترسی داشته باشند.\n❌ مثال اشتباه:\n1for _, tt := range tests { 2\tt.Run(tt.name, func(t *testing.T) { 3\tt.Parallel() 4\tdoTest(tt) 5\t}) 6} ✅ راه حل صحیح:\n1for _, tt := range tests { 2\ttt := tt // shadowing → ایجاد نسخه مجزا از tt 3\tt.Run(tt.name, func(t *testing.T) { 4\tt.Parallel() 5\tdoTest(tt) 6\t}) 7} 7.3.6.2 عدم گزارش نام تست در پیام خطا # در گزارش خطاها، اگر از نام تست استفاده نشود، تشخیص خطای رخ‌داده دشوار می‌شود؛ مخصوصاً وقتی چندین تست پشت سر هم fail می‌شوند.\n❌ اشتباه رایج:\n1t.Errorf(\u0026#34;expected %d, got %d\u0026#34;, want, got) ✅ شکل بهتر:\n1t.Errorf(\u0026#34;%s: expected %d, got %d\u0026#34;, tt.name, want, got) یا با subtestها، نیازی به این کار نیست چون t.Run خودش context لازم را دارد.\n7.3.6.3 بررسی نکردن خطا وقتی wantErr مشخص است # در بسیاری از تست‌ها فیلدی به نام wantErr تعریف می‌شود اما بررسی درستی روی آن انجام نمی‌گیرد یا فقط وجود/عدم وجود err بررسی می‌شود، بدون توجه به نوع خطا.\n✅ پیشنهاد بهتر:\n1if (err != nil) != tt.wantErr { 2\tt.Fatalf(\u0026#34;unexpected error state: %v\u0026#34;, err) 3} در صورت نیاز، بررسی نوع خطا با errors.Is یا errors.As نیز می‌تواند اضافه شود.\n7.3.6.4 تست نکردن مقدار خروجی وقتی خطا انتظار نمی‌رود # ❌ اشتباه رایج:\n1if err != nil { 2\tt.Fatalf(\u0026#34;unexpected error: %v\u0026#34;, err) 3} 4// هیچ بررسی‌ای روی خروجی انجام نشده ✅ راه صحیح:\n1if err != nil { 2\tt.Fatalf(\u0026#34;unexpected error: %v\u0026#34;, err) 3} 4if got != tt.want { 5\tt.Errorf(\u0026#34;expected %v, got %v\u0026#34;, tt.want, got) 6} 7.3.6.5 تبدیل جدول تست به پیچیدگی غیرقابل‌خواندن # گاهی‌اوقات، با افزودن منطق اضافی داخل حلقه‌ی تست یا جدول بسیار حجیم، تست‌خوانی به‌شدت افت می‌کند. در چنین شرایطی بهتر است:\nجدول را به فایل جداگانه ببرید. یا توابع assertion و کمکی تعریف کنید. یا حتی آن تست خاص را از Table Test جدا کنید. 7.3.6.6 عدم پوشش شرایط لبه (Edge Cases) # در جدول تست، اغلب فقط شرایط عادی پوشش داده می‌شوند و شرایط خاص یا مرزی نادیده گرفته می‌شوند؛ مثل:\nورودی‌های صفر، نال، یا تهی بزرگ‌ترین یا کوچک‌ترین مقدار مجاز رشته‌های با کاراکترهای خاص پوشش این موارد نه تنها کیفیت تست را بالا می‌برد بلکه از regressionهای خطرناک جلوگیری می‌کند.\n7.3.6.7 وابستگی تست‌ها به یکدیگر # در صورتی که هر iteration تست جدول‌محور، وضعیت مشترکی تغییر دهد (مثل فایل، دیتابیس، متغیر global)، وابستگی بین تست‌ها ایجاد می‌شود و اجرای موازی خطرناک خواهد بود. هر تست باید کاملاً ایزوله باشد.\n7.3.7 جمع‌بندی و توصیه‌های نهایی برای طراحی تست‌های جدول‌محور # تست‌های جدول‌محور یکی از ستون‌های اصلی تست‌نویسی در زبان Go به‌شمار می‌آیند. این الگو، علاوه بر ساده‌سازی نگارش و توسعه تست‌ها، ساختاری منظم، قابل‌گسترش و حرفه‌ای برای پوشش سناریوهای متنوع فراهم می‌کند. اما استفاده درست از این الگو مستلزم رعایت چند اصل کلیدی است.\n7.3.7.1 مزایای کلیدی Table-Driven Tests # کاهش تکرار در کد تست: دیگر نیازی به کپی کردن یک منطق با ورودی‌های مختلف ندارید. خوانایی بالا: تست‌ها در قالب جدول struct به راحتی قابل درک‌اند. افزودن ساده‌ی تست‌های جدید: فقط کافی‌ست یک struct جدید به جدول اضافه شود. قابلیت اجرای موازی و ایزوله: در ترکیب با t.Parallel() امکان تسریع تست‌ها وجود دارد. گزارش‌گیری ساخت‌یافته: با استفاده از t.Run() و نام‌گذاری دقیق هر تست. 7.3.7.2 توصیه‌های نهایی # همیشه از tt := tt در subtest استفاده کن\nحتی اگر در لحظه از t.Parallel() استفاده نمی‌کنی، برای اطمینان از ایزولاسیون متغیرها این دستور را بنویس. نام تست را معنی‌دار بنویس\nنام هر سناریوی تست باید هدف آن را به وضوح منتقل کند؛ این موضوع در CI/CD و گزارش‌های ترمینال بسیار مفید است. ورودی‌ها، خروجی‌ها و انتظار خطا را صریح بیان کن\nحتی اگر ساده به نظر برسد، وجود فیلدهایی مثل wantErr یا expectedCode ساختار تست را واضح‌تر و قابل گسترش می‌کند. برای هر لایه تستی از Subtest استفاده کن\nاگر درون هر سناریوی تست چند شرط باید بررسی شود، از t.Run() برای ساخت زیرتست استفاده کن. Edge Caseها را فراموش نکن\nورودی‌های خاص، تهی، صفر، منفی یا ناصحیح را در جدول لحاظ کن تا تست‌ها فقط “خوش‌بینانه” نباشند. زمانی که الگو پیچیده شد، ساده کن\nاگر جدول بسیار بزرگ، پر از توابع تو در تو یا منطق شرطی شد، شاید وقت آن است که آن تست را جداگانه بنویسی یا تست را refactor کنی. برای پروژه‌های بزرگ، از type مجزا استفاده کن\nتعریف type مشخص برای struct تست‌ها خوانایی را بالا می‌برد، به‌ویژه اگر در چند فایل مشترک باشد. مطمئن شو هر تست ایزوله و بدون side effect است\nجدول تست نباید به یک ترتیب خاص یا shared state وابسته باشد. هر تست باید مستقل و بازتولیدپذیر باشد. 7.3.7.3 نتیجه‌گیری # استفاده صحیح از تست‌های جدول‌محور در Go، نشانه‌ای از بلوغ تست‌نویسی در یک پروژه است. این الگو، در کنار ابزارهایی مانند t.Run, t.Parallel, t.Cleanup, و پکیج‌هایی مثل testify، به شما امکان می‌دهد تست‌هایی با کیفیت تولیدی و قابل اطمینان بنویسید.\n"},{"id":99,"href":"/chapter-8/","title":"فصل هشتم: پکیج های استاندارد","section":"صفحه اصلی","content":"در این فصل به مباحث پکیج های استاندارد در زبان گو میپردازیم\u0026hellip;\n"},{"id":100,"href":"/chapter-9/","title":"فصل نهم: الگوهای طراحی","section":"صفحه اصلی","content":"در این فصل، به مباحث الگوهای طراحی در زبان گو می‌پردازیم و سعی می‌کنیم به طور کلی و با مثال‌های مناسب، هر الگو را به شما آموزش دهیم و همچنین برخی از کاربردهای الگوها را نام ببریم.\nالگوی طراحی چیست؟ # الگوهای طراحی ، به عنوان راه‌حل‌های معمول برای مسائلی که در طراحی نرم‌افزار به طور متداول رخ می‌دهند، استفاده می‌شوند. آنها دستورالعمل‌هایی پیش‌فرض هستند که می‌توانید برای حل یک مسئله تکراری در کد خود استفاده کنید.\nچرا باید الگوهای طراحی را یاد بگیریم؟ # الگوهای طراحی، به شما کدهای برنامه برای حل یک مسئله ارائه نمی‌دهند. بلکه، آنها یک مفهوم کلی را برای حل یک مسئله در اختیار شما قرار می‌دهند و بر عهده شماست که این مفهوم را چگونه در برنامه خود پیاده‌سازی کنید.\nالگوهای طراحی، یک زبان مشترک را تعریف می‌کنند تا شما بتوانید با سایر توسعه‌دهندگان به طور موثرتری ارتباط برقرار کنید. به عنوان مثال، می‌توانید به هم‌تیمی خود بگویید: \u0026ldquo;می‌توانی این مسئله را با استفاده از الگوی سینگلتون حل کنی.\u0026rdquo; و او همه ایده‌های پشت این الگو را درک خواهد کرد، بدون اینکه نیاز به توضیح اضافی داشته باشید.\nبسیار مهم است، از الگوهای طراحی زمانی استفاده کنید که واقعاً نیاز دارید. این امر دقت و درک دقیق از مسئله و نیازهای طراحی شما را می‌طلبد. این موضوع کمک می‌کند تا شما کد قابل نگهداری ، قابل توسعه و خوانا توسعه دهید و همچنین از تجربه و دانش جمعی الگوها بهره‌برداری کنید. در نتیجه، درست استفاده کردن از الگوهای طراحی می‌تواند بهبود قابل توجهی در کیفیت و عملکرد برنامه شما ایجاد کند. طبقه‌بندی الگوهای طراحی # الگوهای طراحی با توجه به پیچیدگی، سطح جزئیات و مقیاس کاربرد در برنامه، متفاوت هستند.\nالگوهای طراحی سازنده مکانیزم‌های ایجاد شیء را ارائه می‌دهند که انعطاف‌پذیری و استفاده مجدد از کد موجود را افزایش می‌دهند. الگوهای طراحی ساختاری چگونگی ترکیب اشیاء و کلاس‌ها را به ساختارهای بزرگتر توضیح می‌دهد، در حالی که این ساختارها انعطاف‌پذیری و کارآمدی خود را حفظ می‌کنند. الگوهای طراحی رفتاری مراقبت از ارتباطات مؤثر و تخصیص مسئولیت‌ها بین اشیاء را بر عهده دارند. "},{"id":101,"href":"/chapter-9/creational-patterns/","title":"9.1 الگوهای طراحی سازنده","section":"فصل نهم: الگوهای طراحی","content":"الگوهای طراحی سازنده\u0026hellip;\n"},{"id":102,"href":"/chapter-9/structural-patterns/","title":"9.2 الگوهای طراحی ساختاری","section":"فصل نهم: الگوهای طراحی","content":"الگوهای طراحی ساختاری\u0026hellip;\n"},{"id":103,"href":"/chapter-9/behavioral-patterns/","title":"9.3 الگوهای طراحی رفتاری","section":"فصل نهم: الگوهای طراحی","content":"الگوهای طراحی رفتاری\u0026hellip;\n"},{"id":104,"href":"/chapter-9/concurrency-patterns/","title":"9.4 الگوهای همزمانی","section":"فصل نهم: الگوهای طراحی","content":" عنوان توضیحات وضعیت Wait For Result با استفاده از الگو Wait For Result می توانید یک عملیاتی را بصورت همزمانی انجام دهید و سپس منتظر نتیجه عملیات صورت گرفته بمانید. برای اینکار از کانال استفاده می شود. ✅ Fan Out/In الگو Fan Out/In یک تکنیک همزمانی در زبان گو می باشد که به شما اجازه می دهد چندین کار را با گوروتین همزمان انجام دهید و در نتیجه خروجی این کارها را با هم ترکیب کنید و به عنوان نتیجه نهایی دریافت کنید. ✅ Wait For Task الگو wait for task یکی از الگوهای رایج در زبان گو می باشد و انتظار برای تکمیل یک تسک یا فرآیند استفاده می شود. یک تسک با استفاده از گوروتین اجرا می شود و پس اتمامش کار تسک از طریق کانال سیگنال انجام می فرستد. ✅ Drop الگو Drop یک الگو مهم برای انجام خدمات سنگین می باشد. خدماتی که مواقعی باعث می شود حجم درخواست هایش بیش از ظرفیت موجود باشد و این درخواست ها بواسطه این الگو می تواند Drop شود. به عنوان مثال سرویس های DNS باید از این الگو استفاده کنند. ✅ Context Cancellation Pattern الگو cancellation که حرکت تکنیکی هست برای ارسال سینگال به گوروتین ها استفاده می شود که باید اجرای کاری را متوقف کند و ایده اصلی این کار با استفاده بستن کانال صورت میگیرد. ✅ Semaphore الگو Semaphore برای مدیریت کنترل دسترسی به منابع مشترک در همزمانی استفاده می شود. فرض کنید بصورت موازی ۱۰۰ درخواست HTTP سمت سرور میاد و I/O شبکه برای پردازش همزمان این ۱۰۰ درخواست درگیر میشود و به مرور عملکرد کاهش می یابد. حال اگر ما بیایم این ۱۰۰ درخواست موازی را تقسیم کنیم به ۵ دسته ۲۰ تایی که بصورت همزمانی انجام شود باعث می شود I/O شبکه کاهش یابد و عملکرد بهتری را خواهیم داشت. ✅ Worker Pool با استفاده از الگو Bounded Work Pooling امکان محدود سازی تعداد گوروتین ها را براساس کار مشخصی دارید و گوروتین ها را محدود به تعداد دفعات کار مشخص شده محدود می شود. این الگو برای وقت مفید است که شما می خواهید منابع را به یک کار خاص محدود کنید. ✅ Retry Timeout شما از الگو Retry Timeout برای تلاش مجدد یکسری عملیات استفاده کنید. برای اینکار شما می توانید از حلقه و تابع After در پکیج time کمک بگیرید و برای هرتلاش یک timeout مشخص کنید. ✅ Channel Cancellation از کانال ها برای ارتباط بین گوروتین ها و هماهنگ کردن اجرا استفاده می شود. حال گاهی اوقات نیاز است که ما یکسری فرآیند را داخل گوروتین لغو کنیم. در اینجا می توانیم با استفاده از کانال سیگنال لغو کردن بفرستید تا عملیات هایی که گوروتین مورد نظر انجام می داد لغو شود. ✅ Producer-Consumer الگو producer-consumer یکی از کاربردی ترین الگوها در زبان گو می باشد که با استفاده از الگو می توانید بطور همزمان یکسری اطلاعات تولید کنید و بفرستید داخل کانال و این اطلاعات توسط مصرف کننده بواسطه کانال دریافت شود. ✅ Monitor الگوی مانیتور به گروتین‌ ها اجازه می‌دهد هنگام ورود به حالت خواب بدون مسدود کردن اجرا یا مصرف منابع، منتظر شرایط خاصی باشند. ✅ Future در زبان گو الگو Future راهی برای نمایش نتیجه یک عملیات ناهمزمان (asynchronous) است که ممکن است آن عملیات هنوز تکمیل نشده باشد اما این الگو به شما این امکان را می دهد کدی بنویسید که طوری رفتار کند که گویی نتیجه یک عملیات فورا در دسترس است. حتی اگر عملیات در پس زمینه در حال اجرا باشد. ✅ Pipeline الگو خط لوله (Pipeline) یکی از پرکاربردی ترین الگوها در همزمانی می باشد شما با استفاده از این الگو می توانید تسک های بزرگ را به تسک های کوچکتر و مستقل تقسیم کنید که می توانند بطور همزمان کار کنند. هر stage داخل یک گوروتین انجام می شود و بواسطه کانال داده ها بین stage های مختلف منتقل می شود. ✅ Subscription الگو Subscription یکی از الگوهای کاربردی برای پیاده سازی consumer می باشد که به یک آدرسی مشترک شوید و در بازده زمانی مختلف درخواست دهید و یکسری اطلاعات دریافت کنید. ✅ Bridge Channel با استفاده از الگو Bridge Channel می توانید بین ۲ کانال داده ای را منتقل کنید فرض کنید یک داده را به کانال input میفرستید و از دریافت داده آن را می توانید به کانال دیگری منتقل کنید و عملا شما یک پل برای انتقال داده ایجاد کردید. ✅ Queuing الگوی \u0026ldquo;صف\u0026rdquo; در زبان گو الگویی است که در آن از یک گوروتین برای بافر کردن و مدیریت ترتیب مقادیر ارسال شده و دریافت شده از یک کانال استفاده می شود. ✅ Rate limit الگوی Rate Limiting برای کنترل تعداد درخواست‌ها یا وظایف همزمان در یک بازه زمانی مشخص استفاده می‌شود. این الگو با استفاده از یک time.Ticker یا روش‌های مشابه، اجرای گوروتین‌ها یا پردازش داده‌ها را محدود می‌کند. ✅ Deadlock Recovery الگوی بازیابی از بن‌بست (Deadlock Recovery) برای شناسایی و بازیابی از وضعیت‌های بن‌بست استفاده می‌شود، جایی که چندین گوروتین به طور نامحدود منتظر منابعی هستند که توسط یکدیگر نگه داشته شده‌اند. بن‌بست می‌تواند به دلیل همگام‌سازی نادرست یا رقابت برای منابع در برنامه‌های همزمان رخ دهد. ✅ Lock-free synchronization همگام‌سازی بدون قفل (lock-free synchronization) به مجموعه‌ای از تکنیک‌ها و الگوهای برنامه‌نویسی گفته می‌شود که به چندین thread یا goroutine اجازه می‌دهد به طور همزمان و ایمن به داده‌های مشترک دسترسی پیدا کنند، بدون اینکه از primitiveهایی مثل Mutex یا قفل‌های سنتی استفاده شود. هدف اصلی این الگوها افزایش بازدهی (throughput)، کاهش زمان انتظار (latency) و جلوگیری از مشکلات رایج قفل‌گذاری (مثل deadlock، priority inversion و contention) است. الگوریتم‌های lock-free تضمین می‌کنند که حتی اگر برخی از threadها متوقف شوند یا دچار کندی شوند، باقی سیستم همچنان قادر به پیشرفت خواهد بود (progress guarantee). ✅ "},{"id":105,"href":"/chapter-9/cloud-native-patterns/","title":"9.5 الگوهای Cloud Native","section":"فصل نهم: الگوهای طراحی","content":"الگوهای cloud native\u0026hellip;\n"},{"id":106,"href":"/chapter-9/anti-pattern/","title":"9.6 ضد الگوها (Anti-Patterns)","section":"فصل نهم: الگوهای طراحی","content":"ضد الگوها\n"},{"id":107,"href":"/chapter-10/","title":"فصل دهم: الگوریتم و ساختار داده","section":"صفحه اصلی","content":"در این فصل به مباحث الگوریتم و ساختار داده در زبان گو میپردازیم\u0026hellip;\n"},{"id":108,"href":"/chapter-11/","title":"فصل یازدهم: معماری های نرم افزار","section":"صفحه اصلی","content":"در این فصل به مباحث معماری های نرم افزار در زبان گو میپردازیم\u0026hellip;\n"},{"id":109,"href":"/chapter-12/blockchain/","title":"12.1 بلاکچین","section":"فصل دوازدهم: شبکه بلاکچین","content":"در این بخش به بحث بلاکچین با زبان گو می پردازیم\u0026hellip;\n"},{"id":110,"href":"/chapter-12/","title":"فصل دوازدهم: شبکه بلاکچین","section":"صفحه اصلی","content":"بلاکچین یک دفتر دیجیتال توزیع‌شده است که در آن تراکنش‌ها در یک ردیف متوالی بلوک‌ها ذخیره می‌شوند. هر بلوک حاوی مجموعه‌ای از تراکنش‌ها است و هر تراکنش پس از تأیید توسط رایانه‌های متعدد در شبکه، به طور دائمی به بلاکچین اضافه می‌شود. این پروسه تأیید، معمولاً از طریق فرایندی به نام استخراج انجام می‌گیرد که در آن معماهای ریاضی پیچیده‌ای حل می‌شوند. خاصیت مهم بلاکچین نامتمرکز بودن آن است که این امکان را فراهم می‌آورد تا هیچ شخص یا سازمانی به تنهایی نتواند داده‌ها را کنترل و یا تغییر دهد، این امر به افزایش امنیت و شفافیت در سیستم‌های مالی و دیگر بخش‌ها کمک می‌کند.\nعلاوه بر کاربردهای مالی مانند ارز دیجیتال (مثلاً بیت کوین)، بلاکچین می‌تواند در زمینه‌های متعددی به اشتراک‌گذاری اطلاعات مورد استفاده قرار گیرد. به عنوان مثال، در زمینه حفظ حقوق مالکیت معنوی، ردیابی زنجیره تامین و حتی رأی‌گیری‌های الکترونیکی. ویژگی‌های منحصر به فرد آن مانند تغییرناپذیری داده‌ها، شفافیت و امنیت بالا، ظرفیت فراوانی برای ایجاد تحول دیجیتالی و اعتماد در تقریباً هر صنعتی را داراست. این فناوری هنوز در ابتدای راه خود قرار دارد و پتانسیل تغییرات عظیمی در نحوه تعاملات ما در دنیای دیجیتال را دارد.\nبه نقل از ویکی پدیا:\nزنجیرهٔ بلوکی[۱] (به انگلیسی: Blockchain)[۲][۳] یک فناوری برای ثبت و ضبط داده‌ها به حساب می‌آید که به آن پایگاه داده نیز گفته میشود. این داده‌ها می‌توانند برای نمونه تراکنش‌های بانکی باشند یا اسناد مالکیت، قرارها، پیام‌های شخصی یا دیگر اطلاعات. یکی از ویژگی های زنجیرهٔ بلوکی این است که کار ذخیرهٔ این داده‌ها بدون وجود یک مدیر و صاحب‌اختیار مرکزی امکان‌پذیر است و نمی‌توان با تخریب یک نقطهٔ مرکزی داده‌های ذخیره‌شده را تحریف یا نابود کرد که نام این ویژگی شبکه عمومی و غیرمتمرکز نام دارد. معروف‌ترین شبکه عمومی و غیرمتمرکزی که از این ویژگی بلاکچین استفاده میکند، رمز ارز بیت‌کوین، اتریوم و تتر است.\nدر این فصل ما بطور کلی بصورت پایه تا پیشرفته به مباحث بلاکچین میپردازیم و هدف از گذارندن این بخش رسیدن به بازار کار و یادگیری کامل بلاکچین خواهد بود.\nبخش ها # در این فصل ما 4 بخش داریم که به شرح زیر می باشد:\nآموزش صفر تا صد عناوین بلاکچین آموزش درخصوص شبکه بیت کوین آموزش درخصوص شبکه اتریوم آموزش درخصوص شبکه پکتوس "},{"id":111,"href":"/chapter-12/blockchain/blockchain/","title":"12.1.1 بلاکچین چیست","section":"12.1 بلاکچین","content":" بلاکچین (زنجیره بلوک) در واقع یک سیستم توزیع شده همتا به همتا (Peer to Peer) 1 می باشد که هیچ سرور مرکزی وجود ندارد و این شبکه با افزایش تعداد بلوک ها, تراکنش ها و کلاینت ها رشد می کند و در این شبکه تمامی اطلاعات بصورت رمزنگاری شده رد و بدل می شود و از انواع رمزنگاری متقارن و نامتقارن برای افزایش امنیت شبکه استفاده می شود.\nهدف اصلی بلاکچین بوجود آمدن یک سیستم شفاف و غیرمرکزی هست که دولت ها یا شرکت ها هیچ دسترسی مستقیمی برروی اطلاعات موجود در شبکه نداشته باشند و تمامی اطلاعات بصورت رمزنگاری شده داخل شبکه رد و بدل شود, منظور از سیستم غیرمرکزی یعنی کلاینت هایی که به شبکه متصل می شوند یکدیگر را به هیچ عنوان نمی شناسند و ممکن است یکی از کلاینت ها سیستم شخصی شما باشد یا اینکه یک سرور مجازی و\u0026hellip; باشد و این کلاینت ها با متصل شدن به یکدیگر و انتشار اطلاعات برای سایر اعضای مجموعه خود باعث بروز شدن اطلاعات شبکه می باشد.\nبلاکچین عموما توسط کامپیوترهای داخل شبکه همتا به همتا مدیریت می شود و جایی که هر گره (یا همان کلاینت) با استفاده از پروتکل الگوریتم اجماع 2 ایجاد و اعتبارسنجی ایجاد تراکنش و بلوک را انجام می دهد.\n12.1.1.1 ساختار و طراحی # یک بلاکچین یک زنجیره غیرمتمرکز, توزیع شده و اغلب عمومی هست و عنوان یک دفتر کل دیجیتالی که شامل کلی رکورد به نام بلوک هست و داخل این بلوک ها تعداد تراکنش با محدوده مشخصی نگه داری می شود, بلوک ها به هیچ عنوان تغییر پذیر نیستند و همواره با ایجاد شدن یک بلوک جدید فرآیند ادامه پیدا میکند بطوری که ممکن است یک بلوک فقط یک تراکنش داشته باشد و ادامه لیست تراکنش های جدید در بلوک بعدی نگه داری شود.\nدر کل این عمل به مشارکت کنندگان (گره ها) اجازه می دهد تا معاملات را بطور مستقل و نسبتا ارزان بررسی و حسابرسی کنند.\nدر شبکه بلاکچین هر گره دارای یک دیتابیس مستقل می باشد که بواسط شبکه همتا به همتا تمامی اطلاعات (بلوک - تراکنش - اکانت ها و\u0026hellip;) بین گره با یک مهر زمانی توزیع می شود و این اطلاعات داخل دیتابیس محلی هر گره نگه داری می شود. هر گره موظف است به محض دریافت اطلاعات جدید این اطلاعات را احراز هویت کند و در صورت معتبر بودن اطلاعات به دیتابیس خود اضافه و نگهداری کند.\nدر شبکه بلاکچین یک دارایی دیجیتالی (به عنوان مثال کوین - توکن) وجود دارد که به هیچ عنوان کپی نمی شود و بلکه این دارایی بین حساب های داخل شبکه منتقل می شود, این تایید می کند که هر واحد ارزش فقط یک بار منتقل شده است و مشکل دیرینه خرج مضاعف را حل می کند.\nیک بلاکچین به عنوان یک پروتکل تبادل ارزش توصیف می شود چون بلاکچین می تواند حقوق مالکیت را حفظ کند و این ارزش یک بار توصیف می شود.\nبلاکچین را می توان به چندین لایه تقسیم می شود:\nزیر ساخت سخت افزار شبکه (کشف گره, انتشار اطلاعات و تایید اطلاعات) پروتکل الگوریتم اجماع داده ها (بلاک ها و تراکنش ها) نرم افزار (قرارداد های هوشمند - برنامه های غیرمتمرکز) 12.1.1.2 غیرمتمرکز # با ذخیره داده ها در سراسر شبکه همتا به همتا بلاکچین برخی از خطرات ناشی از نگه داری داده را بصورت متمرکز حذف می کند.\nدر شبکه های توزیع شده متمرکز احتمالات حملات و آسیب پذیری بسیار بالاس و ممکن است با یک حمله کل شبکه از بین برود اما در شبکه غیرمتمرکز بلاکچین به لطف پروتکل الگوریتم اجماع جلو حملات و کلاینت های مخرب گرفته می شود و پایداری شبکه چند برابر می شود چون زمانیکه که شبکه بلاکچین بزرگتر می شود و رشد می کند امنیت هم رشد پذیر است و شبکه پایدارتر می شود.\nدر شبکه بلاکچین ممکن است گره هایی با دستکاری کردن کلاینت خود قصد آسیب زدن به شبکه را داشته باشند به همین دلیل شبکه با استفاده از استراتژی های مطرح شده در پروتکل الگوریتم اجماع می تواند جلو این اتفاق را بگیرد یکی از این استراتژی های Byzantine fault tolerance می باشد.\n12.1.1.3 بلاکچین Permissionless # بلاکچین مزایایی دارد باز بودن, permissionless یا عمومی بود شبکه می باشد که این مزیت باعث می شود شبکه خود را در برابر گره متخلف از خود محافظت کند و نیازی به کنترل دسترسی نیست. منظور از این مطلب این است که هر برنامه ای می تواند بدون تایید و اعتماد از لایه انتقال شبکه بلاکچین استفاده کند و عمل ناشیانه ای انجام دهد تاثیری برروی آسیب دیدن شبکه نمی گذارد و شبکه مسیر خود را پیش روی میکند.\nبیت کوین و سایر ارزهای دیجیتال در حال حاضر با الزام انجام اثبات Proof of Work 3 شبکه را ایمن می کند و هر کسی که در این شبکه فعالیت می کند با انجام پازل Hashcash می تواند در شبکه بلاک بسازد و به پایداری شبکه کمک کند و در ازا یک جایزه ای دریافت کند.\n12.1.1.4 زمینه های استفاده از بلاکچین # در زیر لیستی از زمینه های که بلاکچین استفاده شده است را قرار دادیم:\nارزهای دیجیتالی قراردادهای هوشمند سرویس های مالی (بانکداری دیجیتال) بازی های آنلاین زنجیره تامین ثبت اطلاعات، اسناد و مستندات با اثبات و تظمین از دست نرفتن بالا تر از ذخیره در منابع متمرکز و شفافیت و \u0026hellip; ارجاعات # شبکه همتا به همتا (Peer to Peer)\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nپروتکل الگوریتم اجماع \u0026#160;\u0026#x21a9;\u0026#xfe0e;\nالگوریتم اثبات کار\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},{"id":112,"href":"/chapter-12/blockchain/blockchain-history/","title":"12.1.2 تاریخچه بلاکچین","section":"12.1 بلاکچین","content":"تاریخچه بلاکچین\n"},{"id":113,"href":"/chapter-12/blockchain/blockchain-architecture/","title":"12.1.3 معماری بلاکچین","section":"12.1 بلاکچین","content":"معماری بلاکچین\n"},{"id":114,"href":"/chapter-12/blockchain/blockchain-type/","title":"12.1.4 انواع بلاکچین","section":"12.1 بلاکچین","content":"انواع بلاکچین\n"},{"id":115,"href":"/chapter-12/blockchain/blockchain-different-with-centerlized/","title":"12.1.5 تفاوت سیستم متمرکز با غیرمتمرکز","section":"12.1 بلاکچین","content":"تفاوت سیستم متمرکز با غیرمتمرکز\n"},{"id":116,"href":"/chapter-12/blockchain/blockchain-scale/","title":"12.1.6 مقیاس پذیری در بلاکچین","section":"12.1 بلاکچین","content":"مقیاس پذیری در بلاکچین\n"},{"id":117,"href":"/chapter-12/blockchain/blockchain-security/","title":"12.1.7 امنیت در بلاکچین","section":"12.1 بلاکچین","content":"امنیت در بلاکچین\n"},{"id":118,"href":"/chapter-12/blockchain/blockchain-cryptography/","title":"12.1.8 مفاهیم رمزنگاری","section":"12.1 بلاکچین","content":"مفاهیم رمزنگاری\n"},{"id":119,"href":"/chapter-12/blockchain/blockchain-consensus-algorithm/","title":"12.1.10 الگوریتم اجماع (Consensus)","section":"12.1 بلاکچین","content":"الگوریتم اجماع (Consensus)\n"},{"id":120,"href":"/chapter-12/blockchain/blockchain-p2p-network/","title":"12.1.11 ساختار و کاربرد شبکه P2P","section":"12.1 بلاکچین","content":" 2.11.1 معماری P2P چیست؟ # معماری P2P یا همتا به همتا، نوعی ساختار شبکه است که در آن دستگاه ها به طور مثال کامپیوتر ها به طور مستقیم و بدون نیاز به سرور مرکزی به یکدیگر متصل می‌شوند. در این نوع شبکه، هر دستگاهی (که به آن گره یا نود هم می‌گویند) می‌تواند هم به عنوان فرستنده و هم به عنوان گیرنده اطلاعات عمل کند.\n12.11.2 انواع شبکه‌های P2P # شبکه‌های P2P بدون ساختار: در این نوع شبکه‌ها، هیچ نظم و ترتیبی در اتصال گره‌ها به یکدیگر وجود ندارد. گره‌ها به طور تصادفی به یکدیگر متصل می‌شوند و به اشتراک‌گذاری فایل‌ها به صورت تصادفی انجام می‌شود شبکه‌های P2P با ساختار: در این نوع شبکه‌ها، گره‌ها به طور منظم به یکدیگر متصل می‌شوند. به اشتراک‌گذاری فایل‌ها بر اساس قوانین و الگوریتم‌های خاصی انجام می‌شود. 12.11.3 کاربرد های معماری P2P # اشتراک‌گذاری فایل: شبکه‌های P2P برای اشتراک‌گذاری فایل‌ها، مانند موسیقی، فیلم و نرم‌افزار، بسیار محبوب هستند.\nبلاکچین: بلاکچین، فناوری زیربنایی ارزهای دیجیتال، از معماری P2P استفاده می‌کند.\nتماس‌های صوتی و تصویری: برخی از برنامه‌های تماس صوتی و تصویری، مانند Skype، از معماری P2P استفاده می‌کنند.\n12.11.3.1 بلاکچین # توزیع و ذخیره‌سازی داده‌ها: بلاکچین به جای ذخیره‌سازی داده‌ها در یک سرور مرکزی، از شبکه‌ای از کامپیوترها (نودها) برای ذخیره‌سازی اطلاعات استفاده می‌کند. این امر باعث می‌شود که بلاکچین در برابر حملات سایبری و خرابی‌ها مقاوم‌تر باشد. تایید تراکنش‌ها: در شبکه‌های بلاکچین، تراکنش‌ها توسط نودها تایید می‌شوند. این کار به صورت غیرمتمرکز انجام می‌شود و نیازی به واسطه (مانند بانک) وجود ندارد. نودها با استفاده از الگوریتم‌های اجماع، مانند اثبات کار (PoW) یا اثبات سهام (PoS)، تراکنش‌ها را تأیید می‌کنند. اجماع: اجماع در بلاکچین به فرآیندی گفته می‌شود که در آن نودها در مورد وضعیت فعلی بلاکچین به توافق می‌رسند. الگوریتم‌های اجماع مختلفی برای بلاکچین وجود دارد. شبکه‌های P2P برای پیاده‌سازی الگوریتم‌های اجماع ضروری هستند. مقیاس‌پذیری: بلاکچین‌های مبتنی بر P2P به طور ذاتی مقیاس‌پذیر هستند. به این معنی که می‌توانند به راحتی با اضافه شدن نودهای جدید به شبکه، ظرفیت خود را افزایش دهند. امنیت: شبکه‌های P2P می‌توانند در برابر حملات سایبری مقاوم باشند. دلیل این امر این است که هیچ نقطه مرکزی برای حمله وجود ندارد. هکرها برای هک کردن بلاکچین، باید تعداد زیادی از نودها را هک کنند. حاکمیت: شبکه‌های P2P به طور غیرمتمرکز اداره می‌شوند. این امر به معنای آن است که هیچ شخص یا گروهی کنترل کاملی بر شبکه ندارد و باعث می‌شود که بلاکچین شفاف‌تر و قابل اعتمادتر باشد. 12.11.3.2 مثال‌هایی از شبکه‌های P2P # BitTorrent: یک شبکه P2P برای اشتراک‌گذاری فایل است.\nBitcoin: یک شبکه P2P برای تبادل ارز دیجیتال بیت کوین است.\nEthereum: یک شبکه P2P برای تبادل ارز دیجیتال اتریوم است.\n12.11.4 مزایای معماری P2P # عدم تمرکز: در شبکه‌های P2P هیچ نقطه مرکزی برای کنترل و مدیریت شبکه وجود ندارد. این امر باعث می‌شود که شبکه در برابر حملات و خرابی‌ها مقاوم‌تر باشد.\nمقیاس‌پذیری: شبکه‌های P2P به طور ذاتی مقیاس‌پذیر هستند. به این معنی که می‌توانند به راحتی با اضافه شدن گره‌های جدید به شبکه، ظرفیت خود را افزایش دهند.\nکارایی: در شبکه‌های P2P، بار ترافیک بین گره‌های مختلف شبکه توزیع می‌شود. این امر باعث می‌شود که شبکه کارآمدتر باشد و از اتلاف منابع جلوگیری شود.\n12.11.5 معایب معماری P2P # امنیت: شبکه‌های P2P می‌توانند در برابر حملات سایبری آسیب‌پذیر باشند.\nکشف محتوا: پیدا کردن محتوا در شبکه‌های P2P می‌تواند دشوار باشد.\nمدیریت: مدیریت شبکه‌های P2P می‌تواند دشوار باشد.\n"},{"id":121,"href":"/chapter-12/blockchain/blockchain-data-management/","title":"12.1.12 مدیریت داده در بلاکچین","section":"12.1 بلاکچین","content":"مدیریت داده در بلاکچین\n"},{"id":122,"href":"/chapter-12/blockchain/blockchain-network-testing/","title":"12.1.13 تست پذیری شبکه","section":"12.1 بلاکچین","content":"تست پذیری شبکه\n"},{"id":123,"href":"/chapter-12/blockchain/blockchain-analyze-and-optimization/","title":"12.1.14 ارزیابی و بهینه سازی شبکه","section":"12.1 بلاکچین","content":"ارزیابی و بهینه سازی شبکه\n"},{"id":124,"href":"/chapter-12/blockchain/blockchain-monitoring/","title":"12.1.15 مانیتورینگ شبکه","section":"12.1 بلاکچین","content":"مانیتورینگ شبکه\n"},{"id":125,"href":"/chapter-12/blockchain/blockchain-forking/","title":"12.1.16 استراتژی فورک ها","section":"12.1 بلاکچین","content":"استراتژی فورک ها\n"},{"id":126,"href":"/chapter-12/blockchain/blockchain-api-and-sdk/","title":"12.1.17 پیاده سازی انواع API ها و SDK ها","section":"12.1 بلاکچین","content":"پیاده سازی انواع API ها و SDK ها\n"},{"id":127,"href":"/chapter-12/blockchain/blockchain-keys-and-addresses/","title":"12.1.18 کلیدها و آدرس ها","section":"12.1 بلاکچین","content":"کلیدها و آدرس ها\n"},{"id":128,"href":"/chapter-12/blockchain/blockchain-accounts/","title":"12.1.19 اکانت ها","section":"12.1 بلاکچین","content":"اکانت ها\n"},{"id":129,"href":"/chapter-12/blockchain/blockchain-transactions-and-messages/","title":"12.1.20 تراکنش ها و پیام ها","section":"12.1 بلاکچین","content":"تراکنش ها و پیام ها\n"},{"id":130,"href":"/chapter-12/blockchain/blockchain-blocks/","title":"12.1.21 بلوک ها (Blocks)","section":"12.1 بلاکچین","content":"بلوک ها\n"},{"id":131,"href":"/chapter-12/blockchain/blockchain-genesis/","title":"12.1.22 جنسیس (Genesis)","section":"12.1 بلاکچین","content":"جنسیس (Genesis)\n"},{"id":132,"href":"/chapter-12/blockchain/blockchain-smart-contracts/","title":"12.1.23 قراردادهای هوشمند","section":"12.1 بلاکچین","content":"قراردادهای هوشمند\n"},{"id":133,"href":"/chapter-12/blockchain/blockchain-privacy/","title":"12.1.24 حریم خصوصی شبکه","section":"12.1 بلاکچین","content":"حریم خصوصی شبکه\n"},{"id":134,"href":"/chapter-12/bitcoin/","title":"12.2 شبکه بیت کوین","section":"فصل دوازدهم: شبکه بلاکچین","content":"در این بخش به بحث شبکه بیت کوین می پردازیم\u0026hellip;\n"},{"id":135,"href":"/chapter-12/bitcoin/bitcoin/","title":"12.2.1 معرفی بیت کوین","section":"12.2 شبکه بیت کوین","content":"معرفی بیت کوین\n"},{"id":136,"href":"/chapter-12/bitcoin/bitcoin-cryptography/","title":"12.2.2 رمزنگاری در بیت کوین","section":"12.2 شبکه بیت کوین","content":"رمزنگاری در بیت کوین\n"},{"id":137,"href":"/chapter-12/bitcoin/bitcoin-addresses/","title":"12.2.3 آدرس ها","section":"12.2 شبکه بیت کوین","content":"آدرس ها\n"},{"id":138,"href":"/chapter-12/bitcoin/bitcoin-transactions/","title":"12.2.4 تراکنش ها","section":"12.2 شبکه بیت کوین","content":"تراکنش ها\n"},{"id":139,"href":"/chapter-12/bitcoin/bitcoin-structure/","title":"12.2.5 ساختار بلاکچین بیت کوین","section":"12.2 شبکه بیت کوین","content":"ساختار بلاکچین بیت کوین\n"},{"id":140,"href":"/chapter-12/bitcoin/bitcoin-consensus/","title":"12.2.6 الگوریتم اجماع","section":"12.2 شبکه بیت کوین","content":"الگوریتم اجماع\n"},{"id":141,"href":"/chapter-12/bitcoin/bitcoin-miners/","title":"12.2.7 ماینرها","section":"12.2 شبکه بیت کوین","content":"ماینرها\n"},{"id":142,"href":"/chapter-12/bitcoin/bitcoin-network/","title":"12.2.8 شبکه","section":"12.2 شبکه بیت کوین","content":"شبکه\n"},{"id":143,"href":"/chapter-12/bitcoin/bitcoin-wallets/","title":"12.2.9 والت ها","section":"12.2 شبکه بیت کوین","content":"والت ها\n"},{"id":144,"href":"/chapter-12/bitcoin/bitcoin-in-real-world/","title":"12.2.10 بیت کوین در دنیای واقعی","section":"12.2 شبکه بیت کوین","content":"بیت کوین در دنیای واقعی\n"},{"id":145,"href":"/chapter-12/bitcoin/bitcoin-innovation/","title":"12.2.11 نوآوری","section":"12.2 شبکه بیت کوین","content":"نوآوری\n"},{"id":146,"href":"/chapter-12/bitcoin/bitcoin-clients/","title":"12.2.12 کلاینت ها","section":"12.2 شبکه بیت کوین","content":"کلاینت ها\n"},{"id":147,"href":"/chapter-12/bitcoin/bitcoin-programming/","title":"12.2.13 برنامه نویسی در بیت کوین","section":"12.2 شبکه بیت کوین","content":"برنامه نویسی در بیت کوین\n"},{"id":148,"href":"/chapter-12/ethereum/","title":"12.3 شبکه اتریوم","section":"فصل دوازدهم: شبکه بلاکچین","content":"در این بخش به شبکه اتریوم، اسمارت کانترکت ها و ماشین مجازی اتریوم میپردازیم\u0026hellip;\n"},{"id":149,"href":"/chapter-12/ethereum/ethereum/","title":"12.3.1 معرفی اتریوم","section":"12.3 شبکه اتریوم","content":" 12.3.1.1 اتریوم # بعد از حل مشکلاتی که برای ایجاد یک ارز یا سکه دیجیتالی یا مجازی وجود داشت توسط بیتکوین، با استفاده از ایجاد یک دفتر کل غیر متمرکز، دیتا مدل بلاکچین و سیستم غیرمتمرکز آن موقعیتی برای ایجاد و حل مشکلات دیگه فراهم کرد.\nویتالیک بوترین ایده اتریوم و وایت پیپر ان را اولین بار در سال ۲۰۱۳ منتشر کرد. او یک فعال در مجله بیتکوین بود و اعتقاد داشت بیتکوین دارای مشکلاتی است که باید برطرف شود. او در سال ۲۰۱۴ با چند توسعه دهنده دیگر در ماه اوت همان سال برای اجرای ایده خود شروع به جذب سرمایه کرد.\nهمانطور که ایده ها حول و محور یک سکه دیجیتالی پیش از بیتکوین زیاد بود، قبل از اتریوم و حتی بیتکوین هم افرادی فکر استفاده از ماشین ها برای اجرا و مدیریت قرارداد ها داشتند. اما مساله تغییر پذیر بودن کد های ماشینی و همیشه در دسترس بودن آنها کار را دشوار تر میکرد.\nهمانطور که در بخش قبل (معرفی بلاکچین)توضیح دادیم، یک بلاکچین یک دیتابیس توزیع شده کاملا غیر قابل تغییر است. و همینطور همیه چیز در آن شفاش و اعتبار سنجی شده است. در کنار تمام این موارد نسبت به تعداد node ها شبکه همیشه دسترسی پذیر است و میتوان به دسترسی پذیر بودن اطلاعات بر بستر آن هم اعتماد کرد.\nاز طرفی مدل های اجماعی قبلی هم مشکلاتی مثل هزینه بر بودن و ایجاد مشکلات در طبعیت را داشتند. در ادامه به حل این مشکلات در اتریوم میپردازیم.\n12.3.1.1.1 ماشین مجازی اتریوم و قرار داد های هوشنمد # این خصوصیات برای ما این فرصت را ایجاد کرد تا قرارداد های هوشمند را اختراع کنیم و پیشتاز این صنعت ویتالیک بوترین با ایده ماشین مجازی اتریوم بود!\nاتریوم، یک بلاکچین نسل دوم است که اولین بار با مدل اجماع اثبات کار PoW و قابلیت پشتیبانی از قرارداد های هوشمند اراعه شد. طبق بژ پیپر اتریوم (بژ پیپر نسخه ای ساده نویسی شده و خلاصه شده از یلو پیپر است.) هدف اصلی اتریوم ارز اتر نیست. (ارز شبکه اتریوم اتر و مرسوم ترین خرده واحد آن وی می باشد) هدف اصلی اتریوم ماشین مجازی آن است. شبکه اتریوم، مجموعه ای از نود ها هستند که نرم افزار اتریوم (یک پیاده سازی از اتریوم) را اجرا میکنند و با دیتا مدل بلاکچین استیت کلی را نگهداری میکنند. زمانی که یک قرارداد هوشمند روی اتریوم مستقر میشود، تمامی نود های شبکه یک بایت کد از ان را نگهداری میککند.\nپس شما میتوانید به راحتی، با استاندارد های اتریوم قرارداد برای مثال مالی خود را بنویسید، و روی شبکه اتریوم مستقر کنید. این امر باعث میشود که شما بدون واسطه، به دسترسی پذیر بودن، شفاف بودن (تمام بایت کد ها روی شبکه اتریوم قابل استعلام و خواندن است. به نحوی هر قرارداد هوشنمند مجبور است متن باز باشد. قابل ذکر است که سورس کدی که کامپایل نشده در شبکه نگهداری نمیشود اما معمولا اکسپلورر ها یک نسخه اعتبارسنجی شده از سورس کد را اراعه میدهند) ان مطمن باشید.\nامامرحله مهم بعدی، اجرای آن قرار داد بصورت مطمن است. هر نود اتریوم یک ماشین مجازی روی خود دارد که از توانایی اجرا بایت کد های اتریوم برخوردار است. یکی از دلایل اجرا نشدن مستقیم کانترکت ها این است که ما در ازای مقدار ورودی ثابت و اجرای توابع کانترکت روی هر نود توقع خروجی ثابت داریم. همانطور که در بخش های قبل اشاره کردیم در بلاکچین بصورت مستقیم به اطلاعات خارج از زنجیره (off-chain) اعتماد نمی کنیم. پس وضعیت نود اجرا کننده نباید در اجرای قرارداد ما اثر گذار باشد.\nپس هر نود سورس کد قرار داد هوشنمد شما به علاوه یک ماشین مجازی برای اجرا آن را دارد. از طرفی ما نمیتوانیم توان پردازشی را بین تمام شبکه تقسیم کنیم و بگوییم که همه نود ها باهم یک تابع را جرا کنند. پس تغییر نهایی قرارداد را روی استیت کلی شبکه اتریوم اعمال میکنیم. که با یک تراکنش که ان را contract call صدا میزنیم انجام میشود. در نتیجه همه برای اعمال تغییر، خروجی را اعتبار سنجی میکنند.\nتمام کانترکت های اتریوم دسترسی به برخی از اطلاعات شبکه، نوشتن و خواندن از ان را دارند و میتوانند مجوز برداشت اتر از صاحب یک حساب بگیرند یا به حساب های مختلف اتر وایز کنند.\nهر کانترکت در شبکه اتریوم (و عمد بلاکچین های موجود) حکم یک شی در پارادایم برنامه نویسی شی گرا را دارد. برای مثال انها استکی مخصوص خود دارند و یا برای صدا زدن یکدگیر باید یک نسخه (instance) از دیگری بسازند. که در این باره در بخش کانترکت و ماشین مجازی اتریوم بصورت مفصل میپردازیم. از طرفی دیگر تمام کانترکت های اتریوم یک فضای ذخیره سازی کلید و مقداری (key/value)هم دارند.\nاما مساله پر اهمیت بعدی این است که چرا یک نود باید کانترکت هارا نگهداری و اجرا کند؟؟؟ برای نگهداری و اعتبار سنجی بلاک ها بصورت صادقانه، ما یک جایزه مشخص کردیم. در اصل در ازای صادق بودن و کمک کردن به شبکه ما یک تشویق و برای تلاش در نابود کردن شبکه تنبیه تعریف کردیم. با روش های مختلف. راه حل قرارداد های هوشنمد هم همین مساله است. زمانی که شما یک کانترکت کال انجام میدهید، اولا نیاز به پرداخت کارمز تراکنش خود هستید، اما بخش اصلی این است که تمام بایت کد های اتریوم یک مبلغ بدون واحد (unit less) به عنوان هزینه اجرا یا gas دارند.\nبرای مثال زمانی که شما یک تابع در یک کانترکت را صدا میزنید، تابعی که شما صدا زده اید از ۵ اوپریشن کد (operation code) تشکیل شده. که هر اوپریشن کد ۳ gas نیاز دارد. (توضیح و جزییات اوپریشن کد ها در بخش ماشین مجازی اتریوم و اسمارت کانترکت انجام میشود) از ان رو که gas واحدی ندارد پس هزینه gas هر کانترکت کال به gas مشخص و ثابت است. اما قیمت هر gas نسبت به بار شبکه و حجم تراکنش ها متفاوت است برای مثال همین الان که این متن نوشته میشود قیمت هر gas حدود ۲۵ gwei است (گیگا وی) حال اگر شما یک کانترکت کال با هزینه مشخص 100 وی انجهام دهید، نیاز به پرداخت ۲۵۰۰ gwei یا 0.068 دلار به عنوان gas دارید.\nپس نودی که کانترکت شما را اجرا میکند دلیلی منطقی برای اجرا و نگهداری از ان دارد. و علت ایجاد ارز اتر همین پاداش و هزینه اجرا کانترکت ها است.\n12.3.1.1.2 مدل اجماع اثبات سهام (Proof of Stake or PoS) # مدل اجماع اولیه شبکه اتریوم، مدل اثبات کار بود. اما بعد ازمدتی اتریوم از مدل جدیدی به اسم اثبات سهام امنیت و یکپارچی خود را تظمین کرد.\nدر مدل اثبات سهام، مسابقه ای وجود ندارد. بجای ماینر ها هر نود نقش یک شخص که وضیفه اعتبار سنجی بلاک هارا دارد را بازی میکند. اما چطور اعتماد به نود ها صورت میگیرد؟\nهر نود برای اینکه در فرایند اجماع شرکت داده بشود، مبلغی از ارز شبکه را استیک میکند. بعد از استیک شدن قابلیت جابه جایی ان وجود ندارد و به نحوی تحت کنترل شبکه است. این استیک حکم اعتبار ان نود را دارد. زمانی که شما دست به تقلب بزنید، استیک های شما در خطر خواهد بود. پس هرچه شما ارزش بیشتری را استیک کنید، مبلغ بیشتری برای از دست دادن دارید. پس احتمالا کمتر به فکر صادق نبودن هستید و در نتیجه معتبر تر هستید.\nزمانی که ۱۰۰ نود برای مثال با استیک های مختلف وجود دارند، یک شخص بصورت تصادفی برای ثبت بلاک جدید انتخاب میشود و نیازی به هیچگونه مسابقه ای نیست. اما شخص انتخاب شده نیاز دارد که بلاک مورد نظر را اراعه کند و بقیه نود ها ان را تایید کنند. احتمال اینکه شما انتخاب شوید بیشتر است، اما اگر استیک بیشتری داشته باشید.\nحداقل استیک در اتریوم در این موقع حدود ۳۲ اتر است. همچین شما قابلیت unstake کردن نود خود را دارید اما فرایند زمان بری است و بعد از ان نود شما در فرایند اجماع شرکت داده نخواهد شد.\nهر نود بعد از انتخاب شدن، بلاک خود را اراعه میکند و دیگر نود ها رای میدهند. اگر بلاک تایید شود همه انرا به دفتر کل خود اضافه میکنند و جایزه بلاک به نود مورد نظر میرسید. اگر بلاک رد شود و به مرور نود مشکوک برسد، همانطور که گفتیم استیک ها در خطرند.\nدر این مدل اجماع، ما بجای مفهوم ماینر یا استخراج کننده از مفهوم و کلمه ولیدیتور و یا اعتبارسنجی کننده استفاده میکنیم. و بجای ماین یا استخراج از کلمه مینت شدن یا ضرب شدن استفاده میکنیم.\nدر این مدل اجماع ما با قفل کردن دارایی های خود هم اعتبار خود را اثبات میکنیم، و هم مشخص میکنیم که از شبکه ای که در حال فعالیت هستیم سهمی سهامی داریم. پس هر حرکت اسیب زننده ای دارایی مارا به دو نحو در خطر میندازد.\nاین مدل اجماع هزینه منابع کمتری دارد و برای طبیعت به نسبت بیت کوین کم ضرر تر است. (نکته مهم این است که شبکه بیتکوین هزاران بار از وضعیت فعلی طلا و ارز های فیات متمرکز کاغذی وضعیت بهتری دارد و بشدت کم ضرر تر است.)\nدر بخش اجماع بصورت جزیی تر به این مدل اجماع میپردازیم.\n12.3.1.1.2 world state # در شبکه اتریم یک استیت جهانی (شبیه به دفتر کل بیتکوین) وجود دارد. اطلاعاتی که تمامی نود ها بصورت یکپارچه از وضعیت ماشین مجازی اتریوم و حساب ها نگهداری میکنند همان ورلد استیت اتریوم است.\nتغییرت و تراکنش های اعمال شده در اطلاعات یک نود با دیگر نود ها در یک شبکه همتا به همتا صورت میگیرد (در ادامه به جزییات این شبکه بیشتر خواهیم پرداخت).\nگفتنی است که این تغییرات نیاز دارند تا در مرحله اجماع به تایید اکثریت نود ها برسند تا در استیت جهانی اعمال شوند. و پیام های رد و بدل شد در فرایند اجماع در همین شبکه همتا به همتا منتقل میشوند.\nراه ارتباطی کابر با نود های شبکه برای خواندن و نوشتن اطلاعات بر ورلد استیت یک API وب ۳ است.\nشما برای هر مدل از عملیات نوشتن نیاز به ایجاد یک تراکنش دارید که بسته به تراکنش و بار شبکه کارمزدی متفاوت دارد. اما برای خواندن اطلاعات از شبکه مثل اطلاعات یک بلاک یا حافظه یک قرارداد هوشمند کارمزدی در نظر گرفته نمیشود و نیازی به ایجاد تراکنش نیست و RPC هایی جهت اینکار اراعه میشود.\nایجاد تراکنش هم با اراعه تراکنش خام امضا شده به همین RPC صورت میگیرد.\n"},{"id":150,"href":"/chapter-12/ethereum/ethereum-cryptography/","title":"12.3.2 رمزنگاری","section":"12.3 شبکه اتریوم","content":"رمزنگاری\n"},{"id":151,"href":"/chapter-12/ethereum/ethereum-keys-and-addresses/","title":"12.3.3 آدرس ها و کلیدها","section":"12.3 شبکه اتریوم","content":"آدرس ها و کلیدها\n"},{"id":152,"href":"/chapter-12/ethereum/ethereum-accounts/","title":"12.3.4 اکانت ها","section":"12.3 شبکه اتریوم","content":"همانطور که میدانید اتریوم از مدل account based بجای UTXO استفاده میکند. اکانت ها در اتریوم، با شبکه بیتکوین تفاوت هایی اساسی دارند. اکانت های اتریوم بصورت کلی به دو دسته EOA و CA تقسیم میشوند. (external owned account) (contract account)\nدر ادامه به خصوصیات و جزییات هر یک از اکانت های کانترکت و اکانت های مالک خارجی (کنترل شده توسط شخص) میپردازیم.\n12.3.4.1 external owned accounts (EOA) # حساب های کنترل شده توسط افراد خارجی یا کنترل شده توسط شخص، حساب هایی معمولی هستند که توانایی نگهداری ارز اتر و انتقال ان با استفاده از ایجاد تراکنش بر روی شبکه را دارند.\nاین اکانت ها با یک کلید خصوصی کنترل میشوند.\nاین اکانت های دارای دو بخش هستند (هر ادرس یا کلید عمومی به یک فیلد دو بخشی از این اطلاعات در ورلد استیت اتریوم اشاره دارد.)\n12.3.4.1.1 nonce # مقدار اول یا عدد نانس یک شمارنده برای حساب مورد نظر است. در ازای هر تراکنش که حساب شما ایجاد میکند یک واحد به مقدار نانس اضافه میشود. برای مثال اگر نانس حساب شما ۱۳ باشد یعنی شما تا به حال ۱۴ تراکنش ایجاد کرده اید. (شمارش از ۰ شروع میشود) اما گفتنی است که خواندن اطلاعات یا تراکنش هایی که به حساب شما به عنوان مقصد صورت میگیرد تاثیری در نانس حساب شما ندارد.\nاما بحث اصلی خاصیت عدد نانس است. زمانی که حساب شما تراکنشی ایجاد میکند تراکنش مورد نظر شامل عدد نانس حساب مبدا هم میشود. در همین حین نود های اتریوم میتوانند بر اساس نانس تراکنش شما را از روی ترتیب این شمارنده اجرا کنند. (در شبکه اتریوم انتخاب تراکنش توسط نود ها پردازش انها بصورت کلی به ترتیب نیست و بستگی به نود ها و بار شبکه و تراکنش دارد. در بخش تراکنش به جزییات این مساله میپردازیم.) یعنی اگر سه تراکنش متوالی از طرف شما ثبت شود. به انها بر اساس نانس ترتیب بندی میشوند و با اینکه اجرای کل تراکنش ها به ترتیب نیست اما تراکنش های هر شخص باید دقیقا زمانی اجرا شوند که یک واحد به نانس فعلی اضافه کنند. و در این حالت ترتیب تراکنش های شما حفظ خواهد شد.\nاما یکی از کاربرد های اصلی نانس جلوگیری از حمله تکرار است. (reply attack) برای مثال اگر الیس به باب ۱ اتر انتقال دهد. و این تراکنش شامل نانس نشود. باب با پیدا کردن تراکنش امضا شده الیس بر بستر شبکه میتواند انرا تکرار کند و از موجودی حساب الیس کم کند. اما زمانی که در تراکنش امضا شده نانس هم قرار بگیرد هر تراکنش حتی با مقصد و مبدا و مبلغ ثابت هم از هم متمایز هستند. و زمانی که تراکنشی تکراری ثبت شود نانس مورد نظر با نانس حساب مبدا همخوانی ندارد. پس نود ها انرا رد میکنند. و باب نیاز دارد تا یک تراکنش جدید با نانس جدید داشته باشد.\n12.3.4.1.2 balance # مقدار دوم یک بالانس یا موجودی است که بطور خلاصه این بالانس مقدار موجودی یک حساب را به وی (wei) نمایش میدهد و نگهداری میکند.\n12.3.4.2 contract accounts (CA) # نوع دوم اکانت های اتریوم اکانت های قرار داد هوشمند است. این حساب ها قابلیت پردازش تراکنش و ایجاد تغییر در ورلد استیت را دارا هستند. این حساب ها بجای یک کلید خصوصی توسط یک کد EVM کنترل میشوند.\n12.3.4.2.1 nonce # نانس در کانترکت ها با عدد صفر شروع میشد که طی EIP-161 این عدد به یک تغییر کرد. بر خلاف حساب های عادی در حساب های کانترکت تنها زمانی نانس افزایش پیدا میکند که کانترکت یک کانترکت جدید بسازد.\nکانترکت ها میتوانند کانترکت های جدیدی بر روی شبکه مستقر کنند.\nهیچ کانترکتی نمیتواند مالک کانترکت دیگری باشد. اما زمانی که کاربری با یک تراکنش تابعی از یک کانترکت ایجاد میکند که کانترکتی دیگر ایجاد شود. نانس کانترکت افزایش پیدا میکند. و مالک کانترکت حساب ایجاد کننده تراکنش خواهد بود.\nهمچنین خوب است نگاهی به این رشته در وبسایت استک اکسچنج اتریوم بیندازید: https://ethereum.stackexchange.com/questions/764/do-contracts-also-have-a-nonce\n12.3.4.2.2 balance # حساب های کانترکت هم مثل حساب های شخصی یا EOA دارای موجودی هستند. که موجودی انها به واحد wei نگهداری میشود.\n12.3.4.2.3 code hash # همانطور که میدانید حساب های کانترکت شامل یک کد که توسط ماشین مجازی اتریوم قابل اجرا هستند را هم شامل میشوند. خود مقدار بایت کد های کانترکت در دیتابیس نود ها بصورت کلید و مقدار نگهداری میشود. در مقدار خود حساب در استیت جهانی یک هش از حساب نگهداری میشود. دلیل نگهداری شدن هش این است که زمانی که با تغییر نانس یا موجودی نیاز به محاسبه دوباره ریشه هش حساب (درخت مرکل) می باشد این محاسبه ارزان تر از محاسبه کل مقدار کد خواهد بود.\nبا این روش ما کد مربوط به حساب را میتوانیم در دیتابیس نود پیدا کنیم. انرا اعبتار سنجی کنیم که یک کد مربوط به ان حساب اجرا خواهد شد. و در نهایت حین محسابیه ریشه هش درخت مرکل حساب هزینه کمی صرف خواهیم کرد.\n12.3.4.2.4 storage root # همانطور که اشاره کردیم هر کانترکت به یک دیتابیس با مدل مقدار و کلید (key/value) دسترسی دارد. این مقادیر در دیتابیس نود ها نگهداری میشوند. ریشه درخت مرکل این دیتا ها (مربوط به همان کانترکت خاص فقط) در این بخش نگهداری میشود. علت نگهداری این هش مشابه نگهداری هش کد کانترکت است.\nبا این روت هش میتوان فضای ذخیره سازی کانترکت را اعتبار سنجی کرد. تغییر ان را تشخیص داد و همچنین از جایی که یک روت هش از ان داریم محسابه روت هش خود حساب را ارزان نگه میدارد.\n12.3.4.3 address # آدرس های حساب های شخصی و کانترکت تفاوت هایی دارند. در بخش کلید ها و ادرس بصورت جزیی انهارا بررسی کرده ایم. اما در این بخش هم توضیحی خلاصه جهت تکمیل مطلب خواهیم داشت.\n12.3.4.3.1 EOA # ادرس در اکانت های شخصی از هش شدن کلید عمومی بدست می آید. که طول ان ۶۴ کاراکتر بر مبنای ۱۶ است.\n12.3.4.3.2 CA # ادرس حساب های کانترکت از هش ادرس حساب مالک (حساب شخصی که تراکنش استقرار کانترکت را ایجاد میکند.) و عدد نانس همان حساب بدست می اید که طول ان ۴۲ کاراکتر بر مبنای ۱۶ است.\n12.3.4.4 ادرس صفر # آدرس صفر در شبکه اتریوم یک ادرس است که همراه با ایجاد اولین بلاک ایجاد میشود. این آدرس یک حساب شخصی یا کانترکت نیست و هیچ کلید خصوصی و مالکی هم ندارد. همچنین هیچ خروجی یا تراکنشی از این آدرس به بیرون وجود ندارد.\n"},{"id":153,"href":"/chapter-12/ethereum/ethereum-transactions-and-messages/","title":"12.3.5 تراکنش ها و پیام ها","section":"12.3 شبکه اتریوم","content":" 12.3.5.1 تراکنش ها در بلاکچین اتریوم # تراکنش ها در شبکه اتریوم دارای خصوصیاتی متفاوت از تراکنش ها در بیتکوین هستند. علل اصلی این تفاوت ها روش متفاوت اتریوم برای جلوگیری از برخی از حملات و همچنین نیاز به مناسب بودن برای اجرا کانترکت ها در ازای تراکنش ها می باشد.\nدر اتریوم تراکنش ها بصورت اتمیک هستند. یعنی ما نمیتوانیم یک تراکنش را به قسمت های دیگری تقسیم و بصورت جدا اجرا و اراعه کنیم. همچنین وضعیت یک تراکنش در اتریوم تنها دو حالت میتوانند داشته باشند. یا انجام شده اند و تغییری برروی ورلد استیت ایجاد کرده اند یا انجام نشده و اثری بر شبکه ندارند.\nدر شبکه اتریوم تراکنش ها بصورت ترتیبی و اجرا شوند و هیچ دو تراکنشی بصورت همزمان اجرا و پردازش نمیشوند. همچنین تراکنش ها در اتریوم قابلیت همپوشانی ندارند.\n12.3.5.1.1 فیلد های یک تراکنش در اتریوم # اولین مقدار در یک تراکنش اتریومی نانس است. که در بخش حساب ها به ان پرداختیم. نانس یک عدد است که نشان میدهد چندمین تراکنشی است که توسط این حساب ایجاد میشود و تراکنش هایی با اطلاعات یکسان را متمایز میسازد که روشی جایگزین برای مقابله با reply attack.\nهمانطور که میدانید بیتکوین از lock-time برای مقابله از این حمله استفاده میکند.\nدومین مقدار هر تراکنش قیمت gas میباشد. در اصل مبلغی است که ایجاد کننده تراکنش حاضر است در ازای هر gas بپردازد.\nسومین بخش محدودیت تعداد مراحل محساباتی است که برای اجرا تراکنش توسط ارسال کننده مشخص میشود. علت استفاده از این فیلد مدل Anti-DOS اتریوم میباشد. برتی مثال جلوگیری از ایجاد حلقه های بینهایت و یا هدر دادن منابع پردازشی.\nفیلد بعدی نشان دهنده آدرس مقصد تراکنش است. و بعد از آن مبلغ اتری که با این تراکنش جابه جا میشود.\nدر نهایت فیلد دیتا که یک فیلد اختیاری است (در استقرار و صدا زدن قرارداد های هوشمند کاربرد دارد) شامل اطلاعاتی میشود که کانترکت مورد نظر میتواند انهارا بخواند. برای مثال اگر شما بخواهید یک رکورد ENS برای ایپی ادرس خود ثبت کنید در این قسمت از تراکنش خود ایپی و نام ENS خود را در صدا زدن کانترکت ENS قرار میدهید.\nهمچنین تراکنش هایی که برای ایجاد یک قرارداد هوشمند جدید اجرا میشوند هم بایت کد های قرارداد هوشمند در این فیلد قرار میگیرد.\nاضافه کردن دیتا در این بخش مقدار gas را افزایش خواهد داد.\n12.3.5.1.2 انواع تراکنش در اتریوم # تراکنش هادر شبکه اتریوم به دو دسته تقسیم می شوند. دسته اول تراکنش هایی هستند که باعث ایجاد و یا همان استقرار یک قرارداد هوشمند جدید بر روی شبکه میشوند. دربخش های قبل به این مدل از تراکنش ها بصورت خلاصه پرداخته ایم.\nاین تراکنش ها در فیلد دیتا یک بایت کد معتبر EVM ای را شامل میشوند. ارسال کننده یا ادرس مقصد این تراکنش ها همیشه یک EOA میباشد که در نهایت مالک ان قرار داد به شمار می اید.\nمقصد این تراکنش ها ادرس صفر است.\nدسته دوم تراکنش ها در اتریوم تراکنش های message call است.\nدر این تراکنش ها معمولا یا یک تابع در یک قرار داد هوشمند صدا زده میشود و یا یک جابه جایی اتر بین دو حساب شخصی صورت میگیرد.\n12.3.5.1 پیام ها در بلاکچین اتریوم # مثال و درک بهتر # در نهایت برای درک بهتر مفهایم تراکنش و پیام ها در شبکه اتریوم (یا هر مفهوم دیگری در هر شبکه دیگیری) بررسی کردن بلاک اکسپلورر آن شبکه و دیدن این موارد در حالت بصری کمک خیلی خوبی به درک این مساعل میکند. همچنین میتوانید با ایجاد یک حساب اتریوم در تست نت های اتریوم این موارد را بصورت عملی تست کنید. (در بخش های اینده به این مورد خواهیم پرداخت)\nEthereum Block explorer\nارجاعات # 1- Messages and Transactions on Ethereum\n"},{"id":154,"href":"/chapter-12/ethereum/ethereum-virtual-machine/","title":"12.3.6 ماشین مجازی اتریوم","section":"12.3 شبکه اتریوم","content":" 12.3.6.1 ماشین مجازی # قبل از شروع بررسی ماشین مجازی اتریوم به مفهوم ماشین مجازی میپردازیم. همانطور که در قسمت های قبل به ورلد استیت اتریوم اشاره کردیم و فهمیدیم که تمام نود های اتریوم یک حافظه وضعیت و یا حالت کلی دارند که همیشه باهم برابر است و در حالت یکسانی قرار دارد و تغییرات بر ورلد استیت با تراکنش ها اعمال میشوند.\nاما تمام شبکه اتریوم به خودی خود یه ورلد کامپیوتر هم میباشد که باید بتواند تمام تراکنش ها را اجرا کند و تغییرات انها را بر روی ورلد استیت اعمال کند. پس اصلی ترین رکن این ورلد کامپیوتر این است که در هر زمان توسط هر کدام از نود ها که اجرا شد خروجی برابری بدهد. (این مساله یکی از دلایلی است که با عدد نانس ترتیب تراکنش ها حفظ میشود و ماشین مجازی اتریوم قابلیت همزمانی را ندارد.)\nیک ماشین مجازی به زبان ساده یک محیط ایزوله درون یک سیستم عامل در حال اجرا بر روی یک کامپیوتر واقعی است که منابع اختصاصی خود را دارد و بدون گرفتن تاثیر از بقیه نرم افزار ها یا شرایط کامپیوتر اجرا میشود.\nبا این شرایط بهترین انتخاب ما برای اجرای کد ها بر بستر بلاکچین ماشین های مجازی هستند. با استفاده از یک ماشین مجازی قرارداد های هوشمند تنها نیاز دارند به بایت کد های قابل درک برای evm کامپایل شوند نه بایت کد های مربوط به هر معماری پردازشگری که در لحظه نود اتریوم را اجرا میکند. همچنین اطمینان داریم که اگر یک تراکنش توسط دو نود مختلف با شرایط مختلف اجرا شد خروجی ورلد استیت انها یکی خواهد بود.\n12.3.6.2 ماشین مجازی اتریوم # اتریوم یک ماشین مجازی مختص خود دارد که وظیفه اجرا و اعمال تغییرات تراکنش هارا دارد. این ماشین مجازی را میتوان به JVM یا ماشین مجازی جاوا هم تشبیه کرد. که بایت کد های مخصوص خود را دارد و هر محیط که ماشین مجازی مورد نظر را داشته باشد میتواند ان کد را بدون نیاز به بایت کد های متفاوت اجرا کند.\nماشین مجازی اتریوم یک ماشین مجازی استک بیس است.\nحافظه های در دسترسی یک ماشین مجازی اتریوم حین اجرا هر کانترکت به سه دسته تقسیم میشوند. مموری. استک و استورج.\nمموری یک حافظه موقت در حین اجرا کانترکت است. استورج یک حافظه داعمی است که نوشتن اطلاعات در استورج هزینه بالاتری دارد.(استورج بصورت کلید و مقدار است)\nو در نهایت استک یک حافظه موقت استیک بیس است که توسط کامپایلر استفاده میشود.\nبیشتر\n12.3.6.2.1 کد های قابل اجرا # ماشین مجازی اتریوم بایت کد های مربوط به خود را دارد. در بخش های اینده به این بایت کد ها در جزییات میپردازیم. اما بصورت کلی این بایت کد ها همان کد هایی هستند که بر بستر شبکه اتریوم دیپلوی و اجرا میشوند.\nاین بایت کد ها در حالت اسمبلی بصورت مجموعه ای از OP code ها یا اوپریشن کد ها نوشته میشوند که هر اوپریشن کد با یک عدد مشخص میشود. بایت کد های اتریوم شماره اوپریشن کد ها و ورودی انها بصورت هگزادسیمال است. که توسط ماشین مجازی اتریوم قابل درک و اجرا میباشد. در بخش مربوط به بایت کد ها به جزییاتشان خواهیم پرداخت.\nنمونه ای از اوپریشن کد ها یک کانترکت ERC-20:\n‍``` PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH2 0x000f JUMPI PUSH0 0x DUP1 REVERT JUMPDEST POP PUSH1 0x04 CALLDATASIZE LT PUSH2 0x00cd JUMPI PUSH0 0x CALLDATALOAD PUSH1 0xe0\n1 2نمونه بایت کد های همان کانترکت: 3 4‍``` 50x608060405234801561000f575f80fd5b50600436106100cd575f3560e01c806370a082311161008a57806395d89b411161006457806395d89b411461022d578063a9059cbb1461024b578063d505accf1461027b578063dd62ed3e14610297576100cd565b806370a08231146101a95780637ecebe00146101d957806384b0196e14610209576100cd565b806306fdde03146100d1578063095ea7b3146100ef57806318160ddd1461011f57806323b872dd1461013d578063313ce5671461016d5780633644e5151461018b575b5f80fd5b6100d96102c7565b6040516100e691906113de565b60405180910390f35b6101096004803603810190610104919061148f565b610357565b60405161011691906114e7565b60405180910390f35b610127610379565b604051610134919061150f565b60405180910390f35b61015760048036038101906101529190611528565b610382565b60405161016491906114e7565b60405180910390f35b6101756103b0565b6040516101829190611593565b60405180910390f35b6101936103b8565b6040516101a091906115c4565b60405180910390f35b6101c360048036038101906101be91906115dd565b6103c6565b6040516101d0919061150f565b60405180910390f35b6101f360048036038101906101ee91906115dd565b61040b565b604051610200919061150f565b60405180910390f35b61021161041c565b6040516102249796959493929190611708565b60405180910390f35b6102356104c1565b60405161024291906113de565b60405180910390f35b6102656004803603810190610260919061148f565b610551565b60405161027291906114e7565b60405180910390f35b610295600480360381019061029091906117de565b610573565b005b6102b160048036038101906102ac919061187b565b6106b8565b6040516102be919061150f565b60405180910390f35b6060600380546102d6906118e6565b80601f0160208091040260200160405190810160405280929190818152602001828054610302906118e6565b801561034d5780601f106103245761010080835404028352916020019161034d565b820191905f5260205f20905b81548152906001019060200180831161033057829003601f168201915b5050505050905090565b5f8061036161073a565b905061036e818585610741565b600191505092915050565b5f600254905090565b5f8061038c61073a565b9050610399858285610753565b6103a48585856107e5565b60019150509392505050565b5f6012905090565b5f6103c16108d5565b905090565b5f805f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f20549050919050565b5f6104158261098b5... 12.3.6.2.2 محیط اجرا # بایت کد های اتریوم توسط ماشین مجازی اتریوم اجرا میشوند که خود بخشی از پیاده سازی نود اتریوم است. نود درحال اجرا هم بصورت مستقیم از منابع یک ماشین غیر مجازی استفاده میکند.\n12.3.6.2.3 پیاده سازی GETH # تمامی عملکرد ماشین مجازی اتریوم در پیاده سازی رسمی اتریوم در این بخش قرار دارد:\nhttps://github.com/ethereum/go-ethereum/blob/master/core/vm\nبرای مثال تعریف اوپریشن کد ها:\nhttps://github.com/ethereum/go-ethereum/blob/master/core/vm/opcodes.go\nساختار ماشین مجازی اتریوم در پیاده سازی گو اتریوم:\n1// EVM is the Ethereum Virtual Machine base object and provides 2// the necessary tools to run a contract on the given state with 3// the provided context. It should be noted that any error 4// generated through any of the calls should be considered a 5// revert-state-and-consume-all-gas operation, no checks on 6// specific errors should ever be performed. The interpreter makes 7// sure that any errors generated are to be considered faulty code. 8// 9// The EVM should never be reused and is not thread safe. 10type EVM struct { 11\t// Context provides auxiliary blockchain related information 12\tContext BlockContext 13\tTxContext 14\t// StateDB gives access to the underlying state 15\tStateDB StateDB 16\t// Depth is the current call stack 17\tdepth int 18 19\t// chainConfig contains information about the current chain 20\tchainConfig *params.ChainConfig 21\t// chain rules contains the chain rules for the current epoch 22\tchainRules params.Rules 23\t// virtual machine configuration options used to initialise the 24\t// evm. 25\tConfig Config 26\t// global (to this context) ethereum virtual machine 27\t// used throughout the execution of the tx. 28\tinterpreter *EVMInterpreter 29\t// abort is used to abort the EVM calling operations 30\tabort atomic.Bool 31\t// callGasTemp holds the gas available for the current call. This is needed because the 32\t// available gas is calculated in gasCall* according to the 63/64 rule and later 33\t// applied in opCall*. 34\tcallGasTemp uint64 35} با بررسی پروژه های دیگر متوجه پیاده سازی های مختلفی از ماشین مجازی اتریوم در زبان های جاوااسکریپت راست و \u0026hellip; خواهید شد.\n"},{"id":155,"href":"/chapter-12/ethereum/ethereum-blocks/","title":"12.3.7 بلاک ها","section":"12.3 شبکه اتریوم","content":"بلاک ها\n"},{"id":156,"href":"/chapter-12/ethereum/ethereum-consensus/","title":"12.3.8 الگوریتم اجماع","section":"12.3 شبکه اتریوم","content":"الگوریتم اجماع\n"},{"id":157,"href":"/chapter-12/ethereum/ethereum-nodes-and-miners/","title":"12.3.9 نودها و ماینرها","section":"12.3 شبکه اتریوم","content":"نودها و ماینرها\n"},{"id":158,"href":"/chapter-12/ethereum/ethereum-network/","title":"12.3.10 شبکه","section":"12.3 شبکه اتریوم","content":"شبکه\n"},{"id":159,"href":"/chapter-12/ethereum/ethereum-smart-contracts/","title":"12.3.11 قراردادهای هوشمند","section":"12.3 شبکه اتریوم","content":"قراردادهای هوشمند\n"},{"id":160,"href":"/chapter-12/ethereum/ethereum-wallets-and-clients/","title":"12.3.12 والت ها و کلاینت ها","section":"12.3 شبکه اتریوم","content":"والت ها و کلاینت ها\n"},{"id":161,"href":"/chapter-12/ethereum/go-ethereum/","title":"12.3.13 معرفی go-ethereum","section":"12.3 شبکه اتریوم","content":"معرفی go-ethereum\n"},{"id":162,"href":"/chapter-12/ethereum/work-with-accounts/","title":"12.3.14 کار با اکانت ها","section":"12.3 شبکه اتریوم","content":"کار با اکانت ها\n"},{"id":163,"href":"/chapter-12/ethereum/transactions-on-ethereum/","title":"12.3.15 تراکنش برروی اتریوم","section":"12.3 شبکه اتریوم","content":"تراکنش برروی اتریوم\n"},{"id":164,"href":"/chapter-12/ethereum/read-write-in-smart-contracts/","title":"12.3.16 نوشتن و ارتباط با قراردادهای هوشمند","section":"12.3 شبکه اتریوم","content":"نوشتن و ارتباط با قراردادهای هوشمند\n"},{"id":165,"href":"/chapter-12/ethereum/abi-and-bin-file/","title":"12.3.17 آشنایی با فایل ABI و bytecode","section":"12.3 شبکه اتریوم","content":"آشنایی با فایل ABI و bytecode\n"},{"id":166,"href":"/chapter-12/ethereum/event-logs/","title":"12.3.18 خواندن و دریافت لحظه ای لاگ های کانترکت ها","section":"12.3 شبکه اتریوم","content":"خواندن و دریافت لحظه ای لاگ های کانترکت ها\n"},{"id":167,"href":"/chapter-12/ethereum/signature/","title":"12.3.19 ایجاد و تایید امضا","section":"12.3 شبکه اتریوم","content":"ایجاد و تایید امضا\n"},{"id":168,"href":"/chapter-12/ethereum/geth/","title":"12.3.20 کار با geth","section":"12.3 شبکه اتریوم","content":"کار با geth\n"},{"id":169,"href":"/chapter-12/ethereum/protocol-swarm-and-whisper/","title":"12.3.21 کار با پروتکل whisper و swarm","section":"12.3 شبکه اتریوم","content":"کار با پروتکل whisper و swarm\n"},{"id":170,"href":"/chapter-12/pactus/","title":"12.4 شبکه پکتوس","section":"فصل دوازدهم: شبکه بلاکچین","content":"در این بخش به بحث شبکه پکتوس می پردازیم\u0026hellip;\n"},{"id":171,"href":"/chapter-12/pactus/pactus/","title":"12.4.1 معرفی پکتوس","section":"12.4 شبکه پکتوس","content":"معرفی پکتوس\n"},{"id":172,"href":"/chapter-12/pactus/pactus-roadmap/","title":"12.4.2 نقشه راه و اهداف","section":"12.4 شبکه پکتوس","content":"نقشه راه و اهداف\n"},{"id":173,"href":"/chapter-12/pactus/pactus-cryptography/","title":"12.4.3 رمزنگاری","section":"12.4 شبکه پکتوس","content":"رمزنگاری\n"},{"id":174,"href":"/chapter-12/pactus/pactus-addresses-and-keys/","title":"12.4.4 آدرس ها و کلیدها","section":"12.4 شبکه پکتوس","content":"آدرس ها و کلیدها\n"},{"id":175,"href":"/chapter-12/pactus/pactus-accounts/","title":"12.4.5 اکانت ها","section":"12.4 شبکه پکتوس","content":"اکانت ها\n"},{"id":176,"href":"/chapter-12/pactus/pactus-transactions-and-messages/","title":"12.4.6 تراکنش ها و پیغام ها","section":"12.4 شبکه پکتوس","content":"تراکنش ها و پیغام ها\n"},{"id":177,"href":"/chapter-12/pactus/pactus-consensus/","title":"12.4.7 الگوریتم اجماع","section":"12.4 شبکه پکتوس","content":"الگوریتم اجماع\n"},{"id":178,"href":"/chapter-12/pactus/pactus-client/","title":"12.4.8 کار با کلاینت","section":"12.4 شبکه پکتوس","content":"کار با کلاینت\n"},{"id":179,"href":"/chapter-12/pactus/pactus-smart-contracts/","title":"12.4.9 قراردادهای هوشمند (بزودی)","section":"12.4 شبکه پکتوس","content":"قراردادهای هوشمند (بزودی)\n"},{"id":180,"href":"/chapter-9/creational-patterns/go-singleton-pattern/","title":"9.1.1 الگو Singleton","section":"9.1 الگوهای طراحی سازنده","content":"سینگلتون یک الگوی طراحی سازنده است که به شما این اجازه را می‌دهد، تنها یک شی از ساختار خود را با دسترسی سراسری ایجاد کنید.\nالگوی طراحی سینگلتون:\nاطمینان می‌دهد که تنها یک شی از یک ساختار ایجاد می‌شود. مشابه یک متغیر سراسری، به شما امکان می‌دهد از هر جای برنامه به آن شی دسترسی داشته باشید و از بازنویسی توسط نقاط دیگر برنامه نیز محافظت می‌کند. از الگوی سینگلتون زمانی استفاده کنید که بخواهید تنها یک شی از یک ساختار در دسترس کل برنامه باشد. به عنوان مثال، می‌توانید از الگوی سینگلتون برای ایجاد یک شی واحد از لاگر استفاده کنید که توسط بخش‌های مختلف برنامه به آن دسترسی دارند. مثال مفهومی از الگوی سینگلتون:\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;sync\u0026#34; 6 \u0026#34;time\u0026#34; 7) 8 9type MyLogger struct { 10} 11 12var ( 13 globalLogger *MyLogger 14 mu = \u0026amp;sync.Mutex{} 15) 16 17func GetMyLoggerInstance(i int) *MyLogger { 18 if globalLogger == nil { 19 mu.Lock() 20 defer mu.Unlock() 21 if globalLogger == nil { 22 fmt.Println(\u0026#34;creating myLogger instance by\u0026#34;, i) 23 globalLogger = \u0026amp;MyLogger{} 24 } 25 } else { 26 fmt.Println(\u0026#34;myLogger instance already created.\u0026#34;) 27 } 28 29 return globalLogger 30} 31 32func main() { 33 for i := 1; i \u0026lt;= 5; i++ { 34 go GetMyLoggerInstance(i) 35 } 36 time.Sleep(time.Second) 37} 1$ go run main.go 2creating myLogger instance by 2 3myLogger instance already created. 4myLogger instance already created. 5myLogger instance already created. 6myLogger instance already created. روش‌ دیگری نیز برای ایجاد یک شی توسط الگوی سینگلتون در زبان گو وجود دارد:\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;sync\u0026#34; 6 \u0026#34;time\u0026#34; 7) 8 9type MyLogger struct { 10} 11 12var ( 13 globalLogger *MyLogger 14 once sync.Once 15) 16 17func GetMyLoggerInstance(i int) *MyLogger { 18 if globalLogger == nil { 19 once.Do( 20 func() { 21 fmt.Println(\u0026#34;creating myLogger instance by\u0026#34;, i) 22 globalLogger = \u0026amp;MyLogger{} 23 }) 24 } else { 25 fmt.Println(\u0026#34;myLogger instance already created.\u0026#34;) 26 } 27 28 return globalLogger 29} 30 31func main() { 32 for i := 1; i \u0026lt;= 5; i++ { 33 go GetMyLoggerInstance(i) 34 } 35 time.Sleep(time.Second) 36} 1$ go run main.go 2creating myLogger instance by 4 مزایا:\n✅ اطمینان می‌دهد که تنها یک شی از ساختار وجود دارد. ✅ دسترسی سراسری به آن شی را فراهم می‌کند.\n✅ شی فقط در صورت نیاز به آن ایجاد و مقداردهی می‌شود.\nمعایب:\n❌ اصل مسئولیت واحد را نقض می‌کند و ممکن است باعث پیچیدگی در کد شود.\n❌ در برنامه‌های ماتی ترد ، پیاده‌سازی الگوی سینگلتون نیاز به رویکردهای خاص دارد و این ممکن است پیچیدگی را افزایش دهد.\n"},{"id":181,"href":"/chapter-9/creational-patterns/go-factory-method-pattern/","title":"9.1.2 الگو Factory Method","section":"9.1 الگوهای طراحی سازنده","content":"الگو Factory Method\u0026hellip;\n"},{"id":182,"href":"/chapter-9/creational-patterns/go-prototype-pattern/","title":"9.1.3 الگو Prototype","section":"9.1 الگوهای طراحی سازنده","content":"الگو Prototype\u0026hellip;\n"},{"id":183,"href":"/chapter-9/creational-patterns/go-abstract-factory-pattern/","title":"9.1.4 الگو Abstract Factory","section":"9.1 الگوهای طراحی سازنده","content":"الگو Abstract Factory\u0026hellip;\n"},{"id":184,"href":"/chapter-9/creational-patterns/go-builder-pattern/","title":"9.1.6 الگو Builder","section":"9.1 الگوهای طراحی سازنده","content":"الگو Builder\u0026hellip;\n"},{"id":185,"href":"/chapter-9/creational-patterns/go-object-pool-pattern/","title":"9.1.7 الگو Object Pool","section":"9.1 الگوهای طراحی سازنده","content":"الگو Object Pool\u0026hellip;\n"},{"id":186,"href":"/chapter-9/structural-patterns/go-adaptor-pattern/","title":"9.2.1 الگو Adaptor","section":"9.2 الگوهای طراحی ساختاری","content":"الگو Adaptor الگوی adapter یک الگوی ساختاری است که برای سازگار کردن موجودیت های مختلف با هم به کار می‌رود.\nداده ها در دنیای دیجیتال به فرمت‌های مختلف ذخیره و پردازش می‌شوند. این تفاوت در لایه‌ها و فرمت‌های مختلف نمایان و آشکار است. نمونه واضح و پرکاربرد آن فرمت‌های مختلفی مانند json و xml و باینری\u0026hellip; است که در پروتکل‌های ارتباطی متفاوت مورد استفاده قرار می‌گیرد و گاها برای ایجاد ارتباط و امکان خوانده شدن این داده‌ها نیازمند یک روش و الگوی قابل گسترش هستیم.\nالگوی adapter در اینجا مورد استفاده قرار می‌گیرد. نحوه پیاده سازی این الگو در زبان گو به اینصورت است که ابتدا یک struct مادر به همراه متد یا متدهای مورد نیاز ما که مابین موجودیت‌های متفاوت مشترک است تعریف می‌شود. همزمان برای هر فرمت داده یک struct جهت سازگار کردن داده‌ها ساخته می شود. متدهای این strcut توسط یک interface فراخوانی شده است. در اینجا کافی است که این interface را به عنوان ورودی متدهای struct مادر درنظر بگیریم. اینکار باعث ایجاد ارتباط میان struct ها و موجودیت های مختلف خواهد شد.\nدر زیر مثالی از پیاده سازی این الگو انجام گرفته است. در این مثال دو دستگاه پرینتر متفاوت وظیفه چاپ بر روی کاغذ با یک ابعاد خاص و مشخص (A4) را دارند در صورتی که هیچکدام بصورت اختصاصی این ابعاد را پشتیبانی نمیکنند بنابراین ما با پیاده سازی الگوی adapter این امکان را ایجاد میکنیم که این تفاوت ابعاد در داخل هر موجودیت مدیریت شود و فقط متد چاپ در ابعاد A4 فراخوانی شود.\n1package main 2 3 4type IPrint interface{ 5PrintA4() 6} 7 8type Printer struct {} 9 10func (p Printer) Print(printer IPrint) { 11printer.PrintA4() 12} 13 14// HP Printer 15type HpPrinter struct {} 16 17func (h HpPrinter) PrintWithHP() { 18println(\u0026#34;print with HP printer\u0026#34;) 19} 20 21type HpAdapter struct { 22printer *HpPrinter 23} 24 25func (ha HpAdapter) PrintA4() { 26println(\u0026#34;adapting to A4 size for HP printer\u0026#34;) 27//some adapting functions 28ha.printer.PrintWithHP() 29} 30 31 32// Canon Printer 33type CanonPrinter struct {} 34 35func (c CanonPrinter) PrintWithCanon() { 36println(\u0026#34;print with Canon printer\u0026#34;) 37} 38 39type CanonAdapter struct{ 40printer *CanonPrinter 41} 42 43func (ca CanonAdapter) PrintA4() { 44println(\u0026#34;adapting to A4 size for Canon printer\u0026#34;) 45//some adapting functions 46ca.printer.PrintWithCanon() 47} 48 49 50func main() { 51 52 53hpPrinter := \u0026amp;HpPrinter{} 54hpAdapter := HpAdapter{ 55printer: hpPrinter, 56} 57 58canonPrinter := \u0026amp;CanonPrinter{} 59canonAdapter := CanonAdapter{ 60printer: canonPrinter, 61} 62 63printer := Printer{} 64printer.Print(hpAdapter) 65printer.Print(canonAdapter) 66} 1 2adapting to A4 size for HP printer 3print with HP printer 4adapting to A4 size for Canon printer 5print with Canon printer ۱− در مثال بالا ما برای هر پرینتر یک struct به عنوان adapter ایجاد کرده ایم (خطوط 21 و 39) ۲− این struct ها متدی به نام PrintA4 را تعریف می‌کنند‌ که وظیفه تغییر داده ها به فرمت مشترک مورد نظر را دارند (خطوط 25 و 43) ۳− این متد در یک اینترفیس به نام IPrint نیز فراخوانی می‌شود (خط 5) ۴− در این مرحله یک struct به نام Printer ایجاد میکنیم (خط 8) ۵− در مرحله آخر متد اصلی که وظیفه Print کردن کاغذ برای هر پیرنتری را دارد تعریف میکنیم. نکته مهم ورودی این متد است که همان interface تعریف شده در مرحله 3 می باشد. ۶− مرحله آخر تغریف هر پرینتر و printerAdapter در خطوط 52 تا 61 است و درنهایت فراخوانی متد تعریف شده در مرحله 5 برای هر پرینتر در خطوط 64 و 65.\n"},{"id":187,"href":"/chapter-9/structural-patterns/go-bridge-pattern/","title":"9.2.2 الگو Bridge","section":"9.2 الگوهای طراحی ساختاری","content":"الگو Bridge\u0026hellip;\n"},{"id":188,"href":"/chapter-9/structural-patterns/go-composite-pattern/","title":"9.2.3 الگو Composite","section":"9.2 الگوهای طراحی ساختاری","content":"الگو Composite\u0026hellip;\n"},{"id":189,"href":"/chapter-9/structural-patterns/go-decorator-pattern/","title":"9.2.1 الگو Decorator","section":"9.2 الگوهای طراحی ساختاری","content":"الگو Decorator\u0026hellip;\n"},{"id":190,"href":"/chapter-9/structural-patterns/go-facade-pattern/","title":"9.2.5 الگو Facade","section":"9.2 الگوهای طراحی ساختاری","content":"الگو Facade\u0026hellip;\n"},{"id":191,"href":"/chapter-9/structural-patterns/go-flyweight-pattern/","title":"9.2.6 الگو Flyweight","section":"9.2 الگوهای طراحی ساختاری","content":"الگو Flyweight\u0026hellip;\n"},{"id":192,"href":"/chapter-9/structural-patterns/go-proxy-pattern/","title":"9.2.7 الگو Proxy","section":"9.2 الگوهای طراحی ساختاری","content":"الگو Proxy\u0026hellip;\n"},{"id":193,"href":"/chapter-9/behavioral-patterns/go-chain-of-responsibility-pattern/","title":"9.3.1 الگو Chain Of Responsibility","section":"9.3 الگوهای طراحی رفتاری","content":" 9.3.1.1 - الگوی زنجیره مسئولیت (Chain of Responsibility) # الگوی زنجیره مسئولیت (Chain of Responsibility) یک الگوی طراحی رفتاری است که به شما امکان می‌دهد درخواست‌ها را در امتداد زنجیره‌ای از هندلرها (handlers) پاس دهید. هر هندلر پس از دریافت یک درخواست، تصمیم می‌گیرد که درخواست را پردازش کند یا آن را به هندلر بعدی در زنجیره منتقل نماید.\n9.3.1.2 - مشکل # فرض کنید روی یک سیستم سفارش آنلاین کار می‌کنید. می‌خواهید دسترسی به سیستم را محدود کنید تا فقط کاربران احراز هویت شده بتوانند سفارش ایجاد کنند. همچنین، کاربرانی که دارای مجوز مدیریت هستند باید دسترسی کامل به تمام سفارشات داشته باشند.\nبعد از کمی برنامه‌ریزی، متوجه می‌شوید که این بررسی‌ها باید به صورت متوالی انجام شوند. برنامه می‌تواند هر زمان درخواستی را که حاوی اعتبارنامه (credentials) کاربر است دریافت می‌کند، تلاش کند کاربر را در سیستم احراز هویت کند. با این حال، اگر این اعتبارنامه‌ها صحیح نباشند و احراز هویت با شکست مواجه شود، دلیلی برای ادامه سایر بررسی‌ها وجود ندارد.\nدر ماه‌های بعد، چندین مورد دیگر از این بررسی‌های متوالی را پیاده‌سازی کردید.\nیکی از همکاران شما پیشنهاد کرده است که انتقال مستقیم داده‌های خام به سیستم سفارش‌دهی ناامن است. بنابراین، یک مرحله اعتبارسنجی اضافی برای تجزیه وتحلیل کردن داده‌ها در یک درخواست اضافه کردید.\nبعداً، کسی متوجه شد که سیستم در برابر کرک رمز عبور با brute force آسیب‌پذیر است. برای جلوگیری از این، به سرعت یک بررسی برای فیلتر کردن درخواست‌های ناموفق مکرر از یک آدرس IP مشابه اضافه کردید.\nفرد دیگری پیشنهاد کرد که با بازگرداندن نتایج کَش (cache) شده در درخواست‌های تکراری حاوی داده‌های یکسان، می‌توانید سرعت سیستم را افزایش دهید. از این رو، یک بررسی دیگر اضافه کردید که به درخواست اجازه می‌دهد تنها در صورتی که پاسخ کَش شده مناسبی وجود نداشته باشد، به سیستم منتقل شود.\nکد مورد بررسی که از قبل هم آشفته‌تر به نظر می‌رسد، با اضافه شدن هر قابلیت جدید، بیشتر و بیشتر آشفته می‌شود. تغییر یک قسمت گاهی اوقات بر سایر قسمت‌ها تأثیر می‌گذاشت. بدترین حالت این بود که وقتی می‌خواستید از این بررسی‌ها برای محافظت از دیگر اجزای سیستم استفاده‌ی مجدد کنید، مجبور بودید بخشی از کد را تکرار کنید، زیرا آن اجزا به برخی از بررسی‌ها نیاز داشتند، اما نه به همه‌ی آن‌ها. درک و نگهداری این سیستم بسیار دشوار و پرهزینه است. پس مدت زمانی با کد درگیر بودید تا اینکه یک روز تصمیم گرفتید کل سیستم را بازنگری (refactor) کنید.\n9.3.1.3 - راه حل # الگوی زنجیره مسئولیت، مانند بسیاری دیگر از الگوهای طراحی رفتاری، بر تبدیل رفتارهای خاص به اشیاء مستقل به نام هندلر (handler) تکیه دارد. در این مورد، هر بررسی باید به کلاس خود با یک روش واحد که بررسی را انجام می دهد استخراج شود. درخواست، همراه با داده‌های آن، به عنوان آرگومان به این متد منتقل می‌شود.\nاین الگو پیشنهاد می‌کند که این هندلرها را به یک زنجیره متصل کنید. هر هندلر متصل دارای فیلدی برای ذخیره مرجع به هندلر بعدی در زنجیره است. هندلرها علاوه بر پردازش یک درخواست، آن را در امتداد زنجیره به جلو منتقل می کنند. درخواست در امتداد زنجیره حرکت می کند تا زمانی که همه هندلرها فرصت پردازش آن را پیدا کنند.\nبهترین بخش اینجاست: یک هندلر می تواند تصمیم بگیرد که درخواست را بیشتر به پایین زنجیره منتقل نکند و عملاً پردازش بیشتر را متوقف کند.\nدر مثال ما با سیستم‌های سفارش، یک هندلر پردازش را انجام می‌دهد و سپس تصمیم می‌گیرد که آیا درخواست را در امتداد زنجیره به پایین منتقل کند یا خیر. با فرض اینکه درخواست حاوی داده‌های صحیح باشد، همه هندلرها می‌توانند رفتار اصلی خود را اجرا کنند، چه این بررسی مربوط به احراز هویت باشد یا ذخیره‌سازی در کَش.\nبا این حال، رویکرد کمی متفاوت دیگری وجود دارد که در آن، یک هندلر پس از دریافت یک درخواست، تصمیم می‌گیرد که آیا می‌تواند آن را پردازش کند. اگر بتواند پردازش را انجام دهد، دیگر آن را به هیچ وجه به جای دیگر منتقل نمی‌کند. پس فقط یک هندلر درخواست را پردازش می‌کند یا اصلاً هیچ کدام را در نظر نمی‌گیرد. این رویکرد هنگام برخورد با رویدادها در پشته‌های عناصر درون یک رابط کاربری گرافیکی (GUI) بسیار رایج است.\nبرای مثال، هنگامی که کاربر روی یک دکمه کلیک می‌کند، رویداد از طریق زنجیره‌ای از عناصر رابط کاربری منتشر می‌شود که از دکمه شروع می‌شود، در امتداد کانتینرهای(containers) آن (مانند فرم‌ها یا پنل‌ها) حرکت می‌کند و به پنجره اصلی برنامه ختم می‌شود. رویداد توسط اولین عنصر در زنجیره که قادر به رسیدگی به آن است، پردازش می‌شود. این مثال همچنین قابل توجه است زیرا نشان می دهد که همیشه می توان یک زنجیره را از یک درخت شیء (object tree) استخراج کرد.\nبسیار مهم است که همه کلاس‌های هندلر یک رابط مشترک را پیاده‌سازی کنند. هر هندلر مشخص (concrete) فقط باید به وجود داشتن متد execute در هندلر بعدی اهمیت دهد. به این ترتیب، می‌توانید زنجیره‌ها را در زمان اجرا با استفاده از هندلرهای مختلف بدون اتصال کد خود به کلاس‌های مشخص آن‌ها بسازید.\n9.3.1.4 - تشبیه دنیای واقعی # به تازگی سخت افزار جدیدی برای کامپیوتر خود خریداری و نصب کرده‌اید. از آنجایی که به اصطلاح یک «گیک» هستید، سیستم عامل های مختلفی روی کامپیوترتان نصب شده است. برای اینکه ببینید آیا سخت افزار جدید پشتیبانی می شود، سعی می کنید همه آنها را بوت کنید. ویندوز به طور خودکار سخت افزار را شناسایی و فعال می کند. با این حال، لینوکس دوست داشتنی شما از کار با سخت افزار جدید امتناع می‌کند. با جرقه‌ای کوچک از امید، تصمیم می‌گیرید با شماره تلفن پشتیبانی فنی که روی جعبه نوشته شده است تماس بگیرید.\nاولین چیزی که می شنوید صدای رباتیک پاسخگوی خودکار است. این پاسخگو 9 راه حل رایج برای مشکلات مختلف را پیشنهاد می کند که هیچ کدام به مورد شما مرتبط نیستند. پس از مدتی، ربات شما را به یک اپراتور زنده متصل می‌کند.\nافسوس، اپراتور هم نمی‌تواند راه حل خاصی را پیشنهاد کند. او همچنان بخش‌های طولانی از دفترچه راهنما را نقل می‌کند و از گوش دادن به نظرات شما امتناع می‌ورزد. بعد از اینکه برای دهمین بار عبارت «آیا کامپیوتر را خاموش و روشن کرده‌اید؟» را می‌شنوید، درخواست می‌کنید که به یک مهندس واقعی وصل شوید.\nدر نهایت، اپراتور تماس شما را به یکی از مهندسان منتقل می کند که احتمالاً ساعت ها در اتاق سرور تاریک زیرزمین یک ساختمان اداری نشسته و مشتاق یک گفتگوی انسانی زنده بوده است. مهندس به شما می گوید که درایورهای مناسب برای سخت افزار جدید خود را از کجا دانلود کنید و چگونه آنها را روی لینوکس نصب کنید. در نهایت، راه حل پیدا شد! تماس را با شادی تمام قطع می کنید.\n9.3.1.5 - مثال # درک الگوی زنجیره مسئولیت(Chain of Responsibility) با یک مثال بهتر انجام می‌شود. بیایید به یک بیمارستان به عنوان مثال توجه کنیم. یک بیمارستان بخش‌های مختلفی دارد مانند:\nپذیرش (Reception) پزشک (Doctor) داروخانه (Medicine Room) صندوق (Cashier) هر زمان که بیماری وارد می‌شود، ابتدا به پذیرش، سپس به پزشک، سپس به داروخانه و سپس به صندوق و غیره می‌رود. به نوعی، بیمار به زنجیره‌ای از بخش‌ها فرستاده می‌شود که پس از انجام کار، بیمار را به سایر بخش‌ها می‌فرستد. اینجاست که الگوی زنجیره مسئولیت وارد عمل می‌شود.\nچه زمانی از این الگو استفاده کنیم؟\nاین الگو در شرایطی کاربرد دارد که چندین گزینه برای پردازش یک درخواست یکسان وجود داشته باشد. همچنین زمانی که نمی‌خواهید کلاینت (فرستنده درخواست)، گیرنده را انتخاب کند، زیرا چندین شیء می‌توانند درخواست را مدیریت کنند. بعلاوه، می‌خواهید کلاینت را از گیرنده‌ها جدا کنید. کلاینت فقط باید عنصر اول زنجیره را بشناسد. همانطور که در مثال بیمارستان مشاهده کردید، بیمار ابتدا به پذیرش مراجعه می‌کند و سپس پذیرش بر اساس وضعیت فعلی بیمار، او را به نفر بعدی در زنجیره (احتمالا پزشک) می‌فرستد.\nUML Diagram: # handler department.go Concrete Handler 1 account.go Concrete Handler 2 doctor.go Concrete Handler 3 medical.go Concrete Handler 4 cashier.go Client main.go مثال عملی # department.go\n1package main 2 3type department interface { 4 execute(*patient) 5 setNext(department) 6} reception.go\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type reception struct { 6 next department 7} 8 9func (r *reception) execute(p *patient) { 10 if p.registrationDone { 11 fmt.Println(\u0026#34;Patient registration already done\u0026#34;) 12 r.next.execute(p) 13 return 14 } 15 fmt.Println(\u0026#34;Reception registering patient\u0026#34;) 16 p.registrationDone = true 17 r.next.execute(p) 18} 19 20func (r *reception) setNext(next department) { 21 r.next = next 22} doctor.go\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type doctor struct { 6 next department 7} 8 9func (d *doctor) execute(p *patient) { 10 if p.doctorCheckUpDone { 11 fmt.Println(\u0026#34;Doctor checkup already done\u0026#34;) 12 d.next.execute(p) 13 return 14 } 15 fmt.Println(\u0026#34;Doctor checking patient\u0026#34;) 16 p.doctorCheckUpDone = true 17 d.next.execute(p) 18} 19 20func (d *doctor) setNext(next department) { 21 d.next = next 22} medical.go\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type medical struct { 6 next department 7} 8 9func (m *medical) execute(p *patient) { 10 if p.medicineDone { 11 fmt.Println(\u0026#34;Medicine already given to patient\u0026#34;) 12 m.next.execute(p) 13 return 14 } 15 fmt.Println(\u0026#34;Medical giving medicine to patient\u0026#34;) 16 p.medicineDone = true 17 m.next.execute(p) 18} 19 20func (m *medical) setNext(next department) { 21 m.next = next 22} cashier.go\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type cashier struct { 6\tnext department 7} 8 9func (c *cashier) execute(p *patient) { 10\tif p.paymentDone { 11\tfmt.Println(\u0026#34;Payment Done\u0026#34;) 12\t} 13\tfmt.Println(\u0026#34;Cashier getting money from patient patient\u0026#34;) 14} 15 16func (c *cashier) setNext(next department) { 17\tc.next = next 18} patient.go\n1package main 2 3type patient struct { 4 name string 5 registrationDone bool 6 doctorCheckUpDone bool 7 medicineDone bool 8 paymentDone bool 9} main.go\n1package main 2 3func main() { 4 cashier := \u0026amp;cashier{} 5 //Set next for medical department 6 medical := \u0026amp;medical{} 7 medical.setNext(cashier) 8 //Set next for doctor department 9 doctor := \u0026amp;doctor{} 10 doctor.setNext(medical) 11 //Set next for reception department 12 reception := \u0026amp;reception{} 13 reception.setNext(doctor) 14 patient := \u0026amp;patient{name: \u0026#34;abc\u0026#34;} 15 //Patient visiting 16 reception.execute(patient) 17} Output:\n1Reception registering patient 2Doctor checking patient 3Medical giving medicine to patient 4Cashier getting money from patient patient Full Working Code: # 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type department interface { 6 execute(*patient) 7 setNext(department) 8} 9 10type reception struct { 11 next department 12} 13 14func (r *reception) execute(p *patient) { 15 if p.registrationDone { 16 fmt.Println(\u0026#34;Patient registration already done\u0026#34;) 17 r.next.execute(p) 18 return 19 } 20 fmt.Println(\u0026#34;Reception registering patient\u0026#34;) 21 p.registrationDone = true 22 r.next.execute(p) 23} 24 25func (r *reception) setNext(next department) { 26 r.next = next 27} 28 29type doctor struct { 30 next department 31} 32 33func (d *doctor) execute(p *patient) { 34 if p.doctorCheckUpDone { 35 fmt.Println(\u0026#34;Doctor checkup already done\u0026#34;) 36 d.next.execute(p) 37 return 38 } 39 fmt.Println(\u0026#34;Doctor checking patient\u0026#34;) 40 p.doctorCheckUpDone = true 41 d.next.execute(p) 42} 43 44func (d *doctor) setNext(next department) { 45 d.next = next 46} 47 48type medical struct { 49 next department 50} 51 52func (m *medical) execute(p *patient) { 53 if p.medicineDone { 54 fmt.Println(\u0026#34;Medicine already given to patient\u0026#34;) 55 m.next.execute(p) 56 return 57 } 58 fmt.Println(\u0026#34;Medical giving medicine to patient\u0026#34;) 59 p.medicineDone = true 60 m.next.execute(p) 61} 62 63func (m *medical) setNext(next department) { 64 m.next = next 65} 66 67type cashier struct { 68 next department 69} 70 71func (c *cashier) execute(p *patient) { 72 if p.paymentDone { 73 fmt.Println(\u0026#34;Payment Done\u0026#34;) 74 } 75 fmt.Println(\u0026#34;Cashier getting money from patient patient\u0026#34;) 76} 77 78func (c *cashier) setNext(next department) { 79 c.next = next 80} 81 82type patient struct { 83 name string 84 registrationDone bool 85 doctorCheckUpDone bool 86 medicineDone bool 87 paymentDone bool 88} 89 90func main() { 91 cashier := \u0026amp;cashier{} 92 93 //Set next for medical department 94 medical := \u0026amp;medical{} 95 medical.setNext(cashier) 96 97 //Set next for doctor department 98 doctor := \u0026amp;doctor{} 99 doctor.setNext(medical) 100 101 //Set next for reception department 102 reception := \u0026amp;reception{} 103 reception.setNext(doctor) 104 105 patient := \u0026amp;patient{name: \u0026#34;abc\u0026#34;} 106 //Patient visiting 107 reception.execute(patient) 108} Output:\n1Reception registering patient 2Doctor checking patient 3Medical giving medicine to patient 4Cashier getting money from patient patient "},{"id":194,"href":"/chapter-9/behavioral-patterns/go-command-pattern/","title":"9.3.2 الگو Command","section":"9.3 الگوهای طراحی رفتاری","content":" 9.3.2.1-الگوی طراحی فرمان (Command) # الگوی طراحی Command یک الگوی رفتاری است که یک درخواست را به یک شیء(object) مستقل تبدیل می کند که حاوی تمام اطلاعات مربوط به درخواست است. این تغییر شکل به شما امکان می دهد درخواست‌ها را به عنوان آرگومان متد ارسال کنید و اجرای یک درخواست را به تعویق بیندازید یا در صف قرار دهید و از عملیات قابل لغو پشتیبانی کنید.\n9.3.2.2-مشکل # فرض کنید روی یک برنامه ویرایشگر متن جدید کار می‌کنید. وظیفه فعلی شما ایجاد نوار ابزار با تعدادی دکمه برای عملیات مختلف ویرایشگر است. شما یک کلاس Button بسیار مرتب ایجاد کرده اید که می‌توان از آن برای دکمه های روی نوار ابزار و همچنین برای دکمه های عمومی در گفتگوهای مختلف استفاده کرد.\n9.3.2.3-راه‌حل نادرست و مشکلات آن # در حالی که همه این دکمه ها شبیه به هم به نظر می رسند، همه آنها قرار است کارهای متفاوتی انجام دهند. کد مربوط به هندلرهای کلیک های مختلف این دکمه ها را کجا قرار می دهید؟ ساده ترین راه حل ایجاد انبوهی از زیرمجموعه‌ها برای هر مکانی است که دکمه در آن استفاده می شود. این زیرمجموعه ها حاوی کدهایی هستند که باید در صورت کلیک روی دکمه اجرا شوند.\nچندان طول نمی کشد که متوجه می شوید این رویکرد عمیقا معیوب است. اول اینکه شما تعداد زیادی از زیرمجموعه‌ها دارید و این خوب است، مگر اینکه هر بار که کلاس Button پایه را تغییر می دهید، خطر شکستن کد در این زیرمجموعه‌ها را نداشته باشید. به بیان ساده، کد رابط کاربری گرافیکی شما به طرز نامناسبی به کد ناپایدار منطق تجاری وابسته شده است.\nو حالا بدترین قسمت مربوط به برخی از عملیات‌ها مثل، کپی/پیست کردن متن، باید از چندین مکان فراخوانی شوند. به عنوان مثال، کاربر می تواند روی دکمه \u0026ldquo;کپی\u0026rdquo; کوچک در نوار ابزار کلیک کند یا چیزی را از طریق منوی زمینه کپی کند یا فقط کلیدهای Ctrl+C را روی صفحه کلید فشار دهد.\nدر ابتدا، زمانی که برنامه ما فقط نوار ابزار را داشت، قرار دادن اجرای عملیات مختلف در زیرمجموعه‌های دکمه اشکالی نداشت. به عبارت دیگر، داشتن کد کپی متن داخل زیرمجموعه CopyButton خوب بود. اما پس از آن، زمانی که منوها، میانبرها و سایر موارد را پیاده سازی می کنید، باید کد عملیات را در بسیاری از کلاس ها تکرار کنید یا منوها را به دکمه‌ها وابسته کنید، که این کار گزینه‌ای بدتر است.\n9.3.2.4-راه‌حل # طراحی خوب نرم‌افزار اغلب بر اساس اصل جداسازی دغدغه‌ها (principle of separation of concerns) بنا شده است، که معمولاً منجر به شکستن یک برنامه به لایه‌های مختلفی می‌شود. رایج ترین مثال: یک لایه برای رابط کاربری گرافیکی و یک لایه دیگر برای منطق تجاری. لایه GUI مسئول ارائه یک تصویر زیبا روی صفحه، گرفتن هر ورودی و نشان دادن نتایج کارهایی است که کاربر و برنامه انجام می دهند. با این حال، زمانی که نوبت به انجام کار مهمی مانند محاسبه مسیر ماه یا نوشتن گزارش سالانه می رسد، لایه GUI کار را به لایه زیرین منطق تجاری واگذار می‌کند.\nدر کد ممکن است به این شکل به نظر برسد: یک شیء GUI متدی از یک شیء منطق تجاری را فراخوانی می‌کند و برخی استدلال‌ها را برای آن ارسال می‌کند. این فرآیند معمولاً به عنوان فرستادن یک درخواست از یک شیء به شیء دیگر توصیف می شود.\nالگوی command پیشنهاد می کند که اشیاء GUI نباید این درخواست ها را مستقیماً ارسال کنند. در عوض، شما باید تمام جزئیات درخواست، مانند شیء فراخوانده شده، نام متد و لیست آرگومان‌ها را به یک کلاس فرمان جداگانه با یک متد واحد که این درخواست را فعال می کند را استخراج کنید.\nاشیاء فرمان به عنوان پیوندهایی بین اشیاء مختلف رابط کاربری و منطق تجاری عمل می کنند. از این به بعد، شیء GUI نیازی به دانستن اینکه کدام شیء منطق تجاری درخواست را دریافت خواهد کرد و چگونه پردازش خواهد شد، ندارد. شیء GUI فقط فرمان را فعال می‌کند، که تمام جزئیات را مدیریت می‌کند.\nگام بعدی این است که دستورات خود را برای پیاده سازی همان رابط کاربری وادار کنید. به طور معمول، فقط یک متد اجرایی دارد که هیچ پارامتری را نمی پذیرد. این رابط به شما امکان می دهد از دستورات مختلف با همان فرستنده درخواست استفاده کنید، بدون اینکه آن را به concrete کلاس‌های مشخص دستورات پیوند دهید. به عنوان یک امتیاز، اکنون می توانید اشیاء فرمان مرتبط با فرستنده را جابجا کنید و به طور موثر رفتار فرستنده را در زمان اجرا تغییر دهید.\nشاید به یک قطعه گمشده از پازل که پارامترهای درخواست است توجه کرده باشید. یک شیء GUI ممکن است برخی از پارامترها را به شیء لایه تجاری ارائه کرده باشد. از آنجایی که متد اجرای دستور هیچ پارامتری ندارد، چگونه جزئیات درخواست را به گیرنده منتقل کنیم؟ به نظر می رسد که دستور باید از قبل با این داده ها پیکربندی شده باشد، یا قادر به دریافت آن به تنهایی باشد.\nحالا که الگوی command را اعمال کرده‌ایم، دیگر به تمام آن زیرمجموعه‌های دکمه برای پیاده‌سازی رفتارهای مختلف کلیک نیاز نداریم. کافی است یک فیلد واحد در کلاس پایه Button قرار دهیم که مرجعی به یک شیء فرمان را ذخیره کند و دکمه را وادار کنیم تا آن فرمان را با یک کلیک اجرا کند.\nشما مجموعه‌ای از کلاس‌های فرمان را برای هر عملیاتی که ممکن است، پیاده‌سازی خواهید کرد و آن‌ها را با دکمه‌های خاص، بسته به رفتار مورد نظر دکمه‌ها، مرتبط می‌کنید.\nسایر عناصر رابط کاربری گرافیکی، مانند منوها، میانبرها یا کل کادرهای محاوره‌ای، می‌توانند به همین روش پیاده‌سازی شوند. آنها به یک فرمان مرتبط می شوند که هنگام تعامل کاربر با عنصر رابط کاربری اجرا می‌شود. همانطور که احتمالاً تا به حال حدس زده اید، عناصر مرتبط با عملیات مشابه به دستورات مشابه مرتبط می‌شوند و از تکرار هر گونه کد جلوگیری می‌کنند.\nدر نتیجه، دستورات به یک لایه میانی مناسب تبدیل می شوند که وابستگی بین لایه های رابط کاربری و منطق تجاری را کاهش می‌دهد. و این تنها بخشی از مزایایی است که الگوی فرمان می تواند ارائه دهد!\n9.3.2.5-مثال از دنیای واقعی # بعد از یک پیاده روی طولانی در شهر، به یک رستوران خوب می‌رسید و پشت میز کنار پنجره می‌نشینید. یک پیشخدمت خوش برخورد به سراغ شما می‌آید و به سرعت سفارش شما را می‌گیرد و آن را روی یک تکه کاغذ یادداشت می‌کند. پیشخدمت به آشپزخانه می رود و سفارش را روی دیوار می‌چسباند. پس از مدتی، سفارش به دست سرآشپز می‌رسد، او آن را می‌خواند و غذا را بر اساس آن طبخ می‌دهد. آشپز غذا را به همراه سفارش روی سینی قرار می‌دهد. پیشخدمت سینی را کشف می‌کند، سفارش را بررسی می‌کند تا مطمئن شود همه چیز مطابق میل شماست و همه چیز را سر میز شما می آورد.\nسفارش کاغذی به عنوان یک فرمان عمل می کند. تا زمانی که سرآشپز آماده سرو آن نباشد، در صف باقی می ماند. سفارش حاوی تمام اطلاعات مرتبط مورد نیاز برای پخت غذا است. این به سرآشپز اجازه می‌دهد بدون اینکه به طور مستقیم برای دریافت جزئیات سفارش از شما بپرسد، بلافاصله شروع به پخت و پز کند.\n9.3.2.6- مثال # ####s اجزای اصلی در الگوی طراحی فرمان\nاجزای اصلی که در الگوی طراحی فرمان استفاده می شوند عبارتند از:\nگیرنده (Receiver) - کلاسی است که حاوی منطق تجاری است. شیء فرمان فقط درخواست های خود را به گیرنده به تعویق می اندازد. فرمان (Command) - گیرنده را جاسازی می‌کند و یک عمل خاص از گیرنده را متصل می کند. اجراکننده (Invoker) - فرمان را جاسازی (embed) می‌کند و با فراخوانی متد اجرای فرمان، فرمان را فراخوانی می کند. کاربر (Client) - فرمان را با گیرنده مناسب ایجاد می‌کند و گیرنده را از سازنده فرمان دور می زند. پس از آن، همچنین فرمان حاصل را با یک اجراکننده مرتبط می‌کند. بیایید وضعیتی را درک کنیم که پس از آن مشخص خواهد شد که چرا الگوی فرمان مفید است. حالت یک تلویزیون را در نظر بگیرید. تلویزیون را می توان با موارد زیر روشن کرد:\nدکمه روشن کنترل از راه دور دکمه روشن روی تلویزیون هر دوی این نقاط شروع کار یکسانی انجام می دهند یعنی روشن کردن تلویزیون. برای روشن کردن تلویزیون، می توانیم شیء فرمان روشن را با گیرنده به عنوان تلویزیون پیاده سازی کنیم. هنگامی که متد execute() روی این شیء فرمان روشن فراخوانده می شود، به نوبه خود تابع TV.on() را فراخوانی می کند. بنابراین در این مورد:\nگیرنده تلویزیون است فرمان مورد نظر برابر با command object روشن است که تلویزیون را جاسازی می‌کند. اجراکننده دکمه روشن کنترل از راه دور یا دکمه روشن تلویزیون است. هر دو شیء فرمان روشن را جاسازی می کنند. در اینجا توجه داشته باشید که ما درخواست روشن کردن تلویزیون را در یک شیء فرمان ( command object) روشن که توسط چندین اجراکننده قابل فراخوانی است، بسته بندی کرده‌ایم. این شیء فرمان روشن گیرنده (در اینجا تلویزیون) را جاسازی می‌کند و می‌تواند به طور مستقل اجرا شود.\nبه عنوان مثال دیگری، مورد یک برنامه ادوبی فتوشاپ را در نظر بگیرید. در فتوشاپ، یک عملیات ذخیره را می توان از 3 مکان راه اندازی کرد:\nاز منو از دکمه روی نوار بالا با استفاده از میانبر Ctrl+S هر سه نقطه شروع کار یکسانی انجام می دهند، یعنی ذخیره تصویر فعلی در برنامه. این ذخیره را می توان در یک شیء فرمان ذخیره با تصویر فعلی باز در برنامه به عنوان گیرنده، قرار داد.\nمزایای ایجاد یک شیء فرمان جداگانه در مثالهای بالا چیست:\nمنطق رابط کاربری را از منطق تجاری زیربنایی جدا می‌کند. نیاز به ایجاد هندلرهای مختلف برای هر یک از اجراکننده ها نیست. شیء فرمان حاوی تمام اطلاعات مورد نیاز برای اجرا است. از این رو می توان از آن برای اجرای به تعویق افتاده نیز استفاده کرد. حالا به نمودار UML نگاه کنیم.\nنمودار UML:\nتوجه کنید که چگونه اجراکننده فرمان را جاسازی می‌کند. درخواست به اجراکننده ارسال می شود و آن درخواست را به شیء فرمان کپسوله شده منتقل می کند. تمام اشیاء فرمان Concrete گیرنده را جاسازی می کنند. نگاشت\nجدول زیر نگاشت بازیگران نمودار UML را به بازیگران پیاده سازی واقعی در \u0026ldquo;مثال عملی\u0026rdquo; در زیر نشان می دهد.\nInvoker button.go Command Interface command.go Concrete Command 1 onCommand.go Concrete Command 2 offCommand.go Receiver Interface device.go Concrete Receiver tv.go Client main.go 9.3.2.7-پیاده سازی # button.go\n1package main 2 3type button struct { 4 command command 5} 6 7func (b *button) press() { 8 b.command.execute() 9} command.go\n1package main 2 3type command interface { 4 execute() 5} onCommand.go\n1package main 2 3type onCommand struct { 4 device device 5} 6 7func (c *onCommand) execute() { 8 c.device.on() 9} offCommand.go\n1package main 2 3type offCommand struct { 4 device device 5} 6 7func (c *offCommand) execute() { 8 c.device.off() 9} device.go\n1package main 2 3type device interface { 4 on() 5 off() 6} tv.go\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type tv struct { 6 isRunning bool 7} 8 9func (t *tv) on() { 10 t.isRunning = true 11 fmt.Println(\u0026#34;Turning tv on\u0026#34;) 12} 13 14func (t *tv) off() { 15 t.isRunning = false 16 fmt.Println(\u0026#34;Turning tv off\u0026#34;) 17} main.go\n1package main 2 3func main() { 4 tv := \u0026amp;tv{} 5 onCommand := \u0026amp;onCommand{ 6 device: tv, 7 } 8 offCommand := \u0026amp;offCommand{ 9 device: tv, 10 } 11 onButton := \u0026amp;button{ 12 command: onCommand, 13 } 14 onButton.press() 15 offButton := \u0026amp;button{ 16 command: offCommand, 17 } 18 offButton.press() 19} Output:\n1Turning tv on 2Turning tv off Full Working Code: # 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type button struct { 6 command command 7} 8 9func (b *button) press() { 10 b.command.execute() 11} 12 13type command interface { 14 execute() 15} 16 17type offCommand struct { 18 device device 19} 20 21func (c *offCommand) execute() { 22 c.device.off() 23} 24 25type onCommand struct { 26 device device 27} 28 29func (c *onCommand) execute() { 30 c.device.on() 31} 32 33type device interface { 34 on() 35 off() 36} 37 38type tv struct { 39 isRunning bool 40} 41 42func (t *tv) on() { 43 t.isRunning = true 44 fmt.Println(\u0026#34;Turning tv on\u0026#34;) 45} 46 47func (t *tv) off() { 48 t.isRunning = false 49 fmt.Println(\u0026#34;Turning tv off\u0026#34;) 50} 51 52func main() { 53 tv := \u0026amp;tv{} 54 onCommand := \u0026amp;onCommand{ 55 device: tv, 56 } 57 offCommand := \u0026amp;offCommand{ 58 device: tv, 59 } 60 onButton := \u0026amp;button{ 61 command: onCommand, 62 } 63 onButton.press() 64 offButton := \u0026amp;button{ 65 command: offCommand, 66 } 67 offButton.press() 68} Output:\n1Turning tv on 2Turning tv off "},{"id":195,"href":"/chapter-9/behavioral-patterns/go-iterator-pattern/","title":"9.3.3 الگو Iterator","section":"9.3 الگوهای طراحی رفتاری","content":" 9.3.3.1-هدف # الگوي طراحی تکرارکننده (Iterator) یک الگوی رفتاری است که به شما امکان می دهد عناصر یک مجموعه را بدون نمایش ساختار درونی آن (فهرست، پشته، درخت و غیره) پیمایش کنید.\n9.3.3.2-مشکل # مجموعه ها (collections) یکی از پرکاربردترین انواع داده در برنامه نویسی هستند. با این وجود، یک مجموعه فقط یک ظرف برای گروهی از اشیاء است.\n(انواع مختلف از collections)\nاکثر مجموعه ها عناصر خود را در لیست های ساده ذخیره می کنند. با این حال، برخی از آنها بر اساس پشته‌ها، درختان، نمودارها و سایر ساختارهای داده پیچیده ساخته شده‌اند.\nاما مهم نیست که یک مجموعه چگونه ساختار یافته باشد، باید روشی برای دسترسی به عناصر آن ارائه دهد تا کدهای دیگر بتوانند از این عناصر استفاده کنند. باید راهی برای مرور هر عنصر از مجموعه بدون دسترسی مکرر به عناصر مشابه وجود داشته باشد.\nاگر مجموعه ای مبتنی بر لیست دارید، این کار ممکن است آسان به نظر برسد. شما فقط روی تمام عناصر حلقه می زنید. اما چگونه عناصر یک ساختار داده پیچیده مانند درخت را به طور متوالی طی کنید؟ به عنوان مثال، ممکن است یک روز فقط با پیمایش عمق اول (depth-first) یک درخت مشکلی نداشته باشید. اما روز بعد ممکن است به پیمایش عرض اول (breadth-first) نیاز داشته باشید. و هفته بعد، ممکن است به چیز دیگری مانند دسترسی تصادفی به عناصر درخت نیاز داشته باشید.\n(از یک مجموعه می‌توان به چند روش مختلف عبور کرد.)\nافزودن الگوریتم های پیمایش بیشتر و بیشتر به مجموعه به تدریج مسئولیت اصلی آن که ذخیره کارآمد داده است را تحت الشعاع قرار می دهد. علاوه بر این، برخی الگوریتم‌ها ممکن است برای یک برنامه خاص طراحی شده باشند، بنابراین گنجاندن آنها در یک کلاس عمومی مجموعه عجیب خواهد بود.\nاز طرف دیگر، کد کلاینت که قرار است با مجموعه‌های مختلفی کار کند، حتی ممکن است اهمیتی ندهد که آنها عناصر خود را چگونه ذخیره می‌کنند. با این حال، از آنجایی که همه مجموعه‌ها روش‌های مختلفی برای دسترسی به عناصر خود ارائه می‌دهند، شما چاره‌ای جز اتصال کد خود به کلاس‌های مجموعه خاص ندارید.\n9.3.3.3-راه‌حل # ایده اصلی الگوی تکرارکننده (Iterator) این است که رفتار پیمایش یک مجموعه را به یک شیء جداگانه به نام «تکرارکننده» (Iterator) استخراج کند.\n(تکرار کننده ها الگوریتم های پیمایش مختلفی را پیاده سازی می کنند. چندین شی تکرارکننده می‌توانند همزمان از یک مجموعه عبور کنند.)\nیک شیء تکرارکننده علاوه بر پیاده سازی الگوریتم پیمایش، تمام جزئیات پیمایش مانند موقعیت فعلی و تعداد عناصر باقی مانده تا انتها را دربرمی گیرد. به همین دلیل، چندین تکرارکننده می توانند به طور همزمان و مستقل از یکدیگر، یک مجموعه را طی کنند.\nمعمولا تکرارکننده‌ها یک روش اصلی برای دریافت عناصر مجموعه ارائه می دهند. کاربر می تواند این روش را تا زمانی که چیزی برنگردد اجرا کند، به این معنی که تکرارکننده تمام عناصر را پیمایش کرده است.\nهمه تکرارکننده‌ها باید یک رابط مشترک را پیاده سازی کنند. این کار باعث می شود کد کلاینت با هر نوع مجموعه یا هر الگوریتم پیمایشی سازگار باشد، به شرطی که یک تکرارکننده مناسب وجود داشته باشد. اگر به روش خاصی برای پیمایش یک مجموعه نیاز دارید، فقط یک کلاس تکرارکننده جدید بدون نیاز به تغییر مجموعه یا مشتری ایجاد کنید.\n9.3.3.4-نمونه واقعی # تصمیم می‌گیرید برای چند روز به شهر رم در ایتالیا سفر کنید و از تمام مناظر و جاذبه های اصلی آن دیدن کنید. اما هنگامی که به آنجا رسیدید، ممکن است زمان زیادی را برای قدم زدن در مسیرهای پر پیچ و خم تلف کنید، بدون اینکه حتی بتوانید نماد باستانی مثل کولوسئوم را پیدا کنید.\nاز طرف دیگر، می توانید یک اپلیکیشن راهنمای مجازی برای گوشی هوشمند خود بخرید و از آن برای مسیریابی استفاده کنید. این کار هوشمند و ارزان است و می توانید تا هر زمان که بخواهید در مکان‌های جالبی توقف و دیدن کنید.\nیک راه حل دیگر این است که بخشی از بودجه سفر را صرف استخدام یک راهنمای محلی کنید که شهر را مثل کف دستش بشناسد. راهنما می‌تواند تور را مطابق با سلیقه شما تنظیم کند، هر جاذبه‌ای را به شما نشان دهد و داستان‌های هیجان‌انگیزی تعریف کند. این حتی سرگرم‌کننده‌تر خواهد بود، اما افسوس، گران‌تر هم خواهد بود.\nهمه این گزینه‌ها - مسیرهای تصادفی که در ذهن شما به وجود می‌آیند، راهنمای هوشمند گوشی هوشمند یا راهنمای انسانی - به عنوان تکرارکننده‌هایی بر روی مجموعه عظیم مناظر و جاذبه‌های واقع در رم عمل می‌کنند.\n9.3.3.5-مثال # الگوی طراحی تکرارکننده (Iterator) # الگوی طراحی تکرارکننده (Iterator) یک الگوی رفتاری است که به شما امکان می دهد عناصر یک مجموعه را بدون نمایش ساختار درونی آن (فهرست، پشته، درخت و غیره) پیمایش کنید.\nاجزای اصلی:\nرابط تکرارکننده (Iterator Interface): این اینترفیس عملیات اصلی برای پیمایش در یک مجموعه را تعریف می کند، به طور معمول شامل متد (Method) هایی مانند hasNext() برای بررسی وجود عناصر بیشتر و getNext() برای بازیابی عنصر بعدی. رابط مجموعه (Collection Interface): این اینترفیس خود مجموعه را نشان می دهد. ممکن است متدی مانند createIterator() را اعلام کند که یک شیء تکرارکننده خاص برای نوع مجموعه را برمی‌گرداند. تکرارکننده خاص (Concrete Iterator): این کلاسی است که رابط Iterator را برای یک نوع مجموعه خاص پیاده سازی می کند. این حالت تکرار (مانند موقعیت فعلی) را حفظ می کند و متد هایی مانند hasNext() و getNext() را ارائه می دهد که خاص ساختار مجموعه است. مجموعه خاص (Concrete Collection): این کلاسی است که اینترفیس یا رابط Collection را برای یک ساختار داده خاص (مانند لیست، درخت) پیاده سازی می کند. این متد createIterator() را ارائه می دهد که یک شیء تکرارکننده خاص را برای پیمایش عناصر آن برمی گرداند. مزایا:\nجداسازی: منطق تکرار را از خود مجموعه جدا می کند و اتصالات ضعیف را ارتقا می دهد و کد را انعطاف پذیرتر و قابل استفاده مجدد می کند. چندین پیمایش: امکان پیمایش همزمان در یک مجموعه با استفاده از تکرارکننده های مختلف، به طور بالقوه با الگوریتم های پیمایش مختلف را فراهم می کند. اصل بسته-باز: پیاده سازی های جدید تکرارکننده را می توان برای نیازهای مختلف پیمایش بدون تغییر در کلاس های مجموعه اضافه کرد. با استفاده از تکرارکننده‌‌ها، می توانید کدی بنویسید که با مجموعه های مختلف بدون وابستگی به ساختارهای خاص آنها کار می کند. این امر به ترویج کدی تمیزتر و قابل نگهداری تر کمک می کند.\n9.3.3.6-Mapping # جدول زیر نگاشت بین بازیگران نمودار UML و بازیگران پیاده‌سازی واقعی را در \u0026ldquo;مثال\u0026rdquo; زیر نشان می‌دهد:\nCollection collection.go Concrete Collection userCollection.go Iterator mac.go Concrete Iterator 1 userIterator.go Client main.go 9.3.3.7-پیاده سازی # collection.go\n1package main 2 3type collection interface { 4 createIterator() iterator 5} userCollection.go\n1package main 2 3type userCollection struct { 4 users []*user 5} 6 7func (u *userCollection) createIterator() iterator { 8 return \u0026amp;userIterator{ 9 users: u.users, 10 } 11} iterator.go\n1package main 2 3type iterator interface { 4 hasNext() bool 5 getNext() *user 6} userIterator.go\n1package main 2 3type userIterator struct { 4 index int 5 users []*user 6} 7 8func (u *userIterator) hasNext() bool { 9 if u.index \u0026lt; len(u.users) { 10 return true 11 } 12 return false 13} 14 15func (u *userIterator) getNext() *user { 16 if u.hasNext() { 17 user := u.users[u.index] 18 u.index++ 19 return user 20 } 21 return nil 22} user.go\n1package main 2 3type user struct { 4 name string 5 age int 6} main.go\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 user1 := \u0026amp;user{ 7 name: \u0026#34;a\u0026#34;, 8 age: 30, 9 } 10 user2 := \u0026amp;user{ 11 name: \u0026#34;b\u0026#34;, 12 age: 20, 13 } 14 userCollection := \u0026amp;userCollection{ 15 users: []*user{user1, user2}, 16 } 17 iterator := userCollection.createIterator() 18 for iterator.hasNext() { 19 user := iterator.getNext() 20 fmt.Printf(\u0026#34;User is %+v\\n\u0026#34;, user) 21 } 22} Output:\n1User is \u0026amp;{name:a age:30} 2User is \u0026amp;{name:b age:20} Full Working Code: # 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type collection interface { 6 createIterator() iterator 7} 8 9type userCollection struct { 10 users []*user 11} 12 13func (u *userCollection) createIterator() iterator { 14 return \u0026amp;userIterator{ 15 users: u.users, 16 } 17} 18 19type iterator interface { 20 hasNext() bool 21 getNext() *user 22} 23 24type userIterator struct { 25 index int 26 users []*user 27} 28 29func (u *userIterator) hasNext() bool { 30 if u.index \u0026lt; len(u.users) { 31 return true 32 } 33 return false 34} 35 36func (u *userIterator) getNext() *user { 37 if u.hasNext() { 38 user := u.users[u.index] 39 u.index++ 40 return user 41 } 42 return nil 43} 44 45type user struct { 46 name string 47 age int 48} 49 50func main() { 51 user1 := \u0026amp;user{ 52 name: \u0026#34;a\u0026#34;, 53 age: 30, 54 } 55 user2 := \u0026amp;user{ 56 name: \u0026#34;b\u0026#34;, 57 age: 20, 58 } 59 userCollection := \u0026amp;userCollection{ 60 users: []*user{user1, user2}, 61 } 62 iterator := userCollection.createIterator() 63 for iterator.hasNext() { 64 user := iterator.getNext() 65 fmt.Printf(\u0026#34;User is %+v\\n\u0026#34;, user) 66 } 67} Output:\n1User is \u0026amp;{name:a age:30} 2User is \u0026amp;{name:b age:20} "},{"id":196,"href":"/chapter-9/behavioral-patterns/go-mediator-pattern/","title":"9.3.4 الگو Mediator","section":"9.3 الگوهای طراحی رفتاری","content":" 9.3.4.1-الگوی طراحی Mediator # الگوی طراحی واسطه (Mediator)، یک الگوی رفتاری است که به شما امکان می‌دهد تا وابستگی‌های درهم‌تنیده بین اشیاء را کاهش دهید. این الگو ارتباط مستقیم بین اشیاء را محدود می‌کند و آن‌ها را مجبور می‌سازد تا تنها از طریق یک شیء واسطه با هم همکاری کنند.\n9.3.4.2-مشکل # فرض کنید یک جعبه dialog برای ایجاد و ویرایش پروفایل کاربران دارید. این جعبه dialog شامل کنترل‌های مختلف فرم مانند فیلدهای متنی، کادرهای انتخابی(checkbox)، دکمه‌ها و غیره می‌شود.\nممکن است برخی از عناصر فرم با سایرین تعامل داشته باشند. برای مثال، انتخاب checkbox \u0026ldquo;من یک سگ دارم\u0026rdquo; ممکن است یک فیلد متنی پنهان برای وارد کردن نام سگ را نمایش دهد. مثال دیگر دکمه “ثبت” است که باید قبل از ذخیره اطلاعات، صحت مقادیر همه فیلدها را تایید کند.\nبا پیاده‌سازی مستقیم این منطق درون کد عناصر فرم، باعث می‌شوید استفاده‌ی مجدد از کلاس‌های این عناصر در فرم‌های دیگر برنامه بسیار دشوار شود. برای نمونه، به دلیل وابستگی به فیلد متن سگ، نمی‌توانید از کلاس کادر انتخاب مذکور در فرم دیگری استفاده کنید. در این حالت، مجبور هستید یا از تمام کلاس‌های درگیر در نمایش فرم پروفایل استفاده کنید، یا هیچ‌کدام را به کار نبرید.\n9.3.4.3- راه‌حل # الگوی طراحی Mediator پیشنهاد می‌کند که تمام ارتباط‌های مستقیم بین اجزایی که می‌خواهید مستقل از یکدیگر باشند را متوقف کنید. در عوض، این اجزا باید به صورت غیرمستقیم با هم همکاری کنند، یعنی با فراخوانی یک شیء واسطه‌ی خاص که تماس‌ها را به اجزای مناسب هدایت می‌کند. در نتیجه، اجزا تنها به یک کلاس واسطه وابسته می‌شوند، نه اینکه به ده‌ها جزء همکار دیگرشان وابسته باشند.\nدر مثال فرم ویرایش پروفایل، خود کلاس باکس گفتگو می‌تواند نقش واسطه را ایفا کند. به احتمال زیاد، کلاس جعبه dialog از قبل از تمام زیرمجموعه‌هایش آگاه است، بنابراین حتی نیازی به معرفی وابستگی‌های جدید به این کلاس نخواهید داشت.\nمهم‌ترین تغییر در عناصر واقعی فرم اتفاق می‌افتد. بیایید دکمه‌ی “ثبت” را در نظر بگیریم. پیش از این، هر بار که کاربر روی دکمه کلیک می‌کرد، این دکمه مجبور بود صحت مقادیر تمام عناصر فرم مجزا را تایید کند. حالا تنها وظیفه‌ی دکمه، اطلاع‌رسانی به جعبه dialog در مورد کلیک است. جعبه dialog پس از دریافت این اطلاع‌رسانی، تایید صحت را خودش انجام می‌دهد یا این وظیفه را به عناصر مجزا واگذار می‌کند. بنابراین، به جای وابستگی به ده‌ها عنصر فرم، دکمه تنها به کلاس باکس گفتگو وابسته است.\nمی‌توانید فراتر بروید و وابستگی را حتی سست‌تر کنید، با این کار که یک واسط مشترک برای تمام انواع جعبه‌های dialog تعریف کنید. این واسط، متد اطلاع‌رسانی را معرفی می‌کند که همه عناصر فرم می‌توانند از آن برای اطلاع‌رسانی به باکس گفتگو در مورد رویدادهای رخ‌داده در آن عناصر استفاده کنند. بنابراین، دکمه‌ی «ثبت» ما حالا باید بتواند با هر جعبه dialog که آن واسط را پیاده‌سازی می‌کند، کار کند.\nبه این ترتیب، الگوی طراحی واسطه به شما امکان می‌دهد تا یک شبکه‌ی پیچیده‌ی روابط بین اشیاء مختلف را درون یک شیء واسطه‌ی واحد کپسوله‌سازی کنید. هرچه وابستگی‌های یک کلاس کمتر باشد، اصلاح، توسعه یا استفاده‌ی مجدد از آن کلاس آسان‌تر می‌شود.\n9.3.4.4- تشبیه در دنیای واقعی # خلبانان هواپیماهایی که به منطقه‌ی کنترل فرودگاه نزدیک می‌شوند یا از آن خارج می‌شوند، به طور مستقیم با یکدیگر ارتباط برقرار نمی‌کنند. در عوض، آن‌ها با یک کنترل‌کننده‌ی ترافیک هوایی صحبت می‌کنند که در یک برج بلند، جایی در نزدیکی باند فرودگاه قرار دارد. بدون وجود کنترل‌کننده ترافیک هوایی، خلبانان باید از هر هواپیمایی در حوالی فرودگاه آگاه باشند و با یک کمیته‌ی متشکل از ده‌ها خلبان دیگر در مورد اولویت‌های فرود بحث کنند. این امر احتمالا آمار سقوط هواپیما را به طرز چشمگیری افزایش می‌داد.\nبرج نیازی به کنترل کل پرواز ندارد. برج فقط برای اعمال محدودیت‌ها در منطقه‌ی فرودگاه وجود دارد.\n9.3.4.5- مثال # همانطور که می‌دانیم؛ الگوی طراحی Mediator یک الگوی طراحی رفتاری است. این الگو پیشنهاد می کند برای جلوگیری از ارتباط مستقیم بین اشیاء، یک شیء میانجی ایجاد شود تا وابستگی های مستقیم بین آنها از بین برود.\nیک مثال بسیار خوب از الگوی Mediator، سکوی سیستم راه آهن است. دو قطار هرگز برای در دسترس بودن سکو با یکدیگر ارتباط برقرار نمی‌کنند. مسئول ایستگاه (stationManager) به عنوان میانجی (Mediator) عمل می کند و سکو را فقط برای یکی از قطارها در دسترس قرار می‌دهد. قطار با مسئول ایستگاه (stationManager) ارتباط برقرار می‌کند و بر اساس دستورات آن عمل می‌کند. این الگو صفی از قطارهای در انتظار را مدیریت می کند. در صورت خروج هر قطاری از سکو، به یکی از قطارها اطلاع می دهد که در ادامه به سکو برسد.\nتوجه کنید که چگونه stationManager در کد زیر به عنوان میانجی بین trains و platform عمل می کند.\npassengerTrain و goodsTrain رابط train را پیاده سازی می‌کنند. stationManager رابط mediator را پیاده سازی می‌کند. 9.3.4.6- مثال کاربردی # train.go\n1package main 2 3type train interface { 4 requestArrival() 5 departure() 6 permitArrival() 7} passengerTrain.go\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type passengerTrain struct { 6 mediator mediator 7} 8 9func (g *passengerTrain) requestArrival() { 10 if g.mediator.canLand(g) { 11 fmt.Println(\u0026#34;PassengerTrain: Landing\u0026#34;) 12 } else { 13 fmt.Println(\u0026#34;PassengerTrain: Waiting\u0026#34;) 14 } 15} 16 17func (g *passengerTrain) departure() { 18 fmt.Println(\u0026#34;PassengerTrain: Leaving\u0026#34;) 19 g.mediator.notifyFree() 20} 21 22func (g *passengerTrain) permitArrival() { 23 fmt.Println(\u0026#34;PassengerTrain: Arrival Permitted. Landing\u0026#34;) 24} goodsTrain.go\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type goodsTrain struct { 6 mediator mediator 7} 8 9func (g *goodsTrain) requestArrival() { 10 if g.mediator.canLand(g) { 11 fmt.Println(\u0026#34;GoodsTrain: Landing\u0026#34;) 12 } else { 13 fmt.Println(\u0026#34;GoodsTrain: Waiting\u0026#34;) 14 } 15} 16 17func (g *goodsTrain) departure() { 18 g.mediator.notifyFree() 19 fmt.Println(\u0026#34;GoodsTrain: Leaving\u0026#34;) 20} 21 22func (g *goodsTrain) permitArrival() { 23 fmt.Println(\u0026#34;GoodsTrain: Arrival Permitted. Landing\u0026#34;) 24} mediator.go\n1package main 2 3type mediator interface { 4 canLand(train) bool 5 notifyFree() 6} stationManager.go\n1package main 2 3import \u0026#34;sync\u0026#34; 4 5type stationManager struct { 6 isPlatformFree bool 7 lock *sync.Mutex 8 trainQueue []train 9} 10 11func newStationManger() *stationManager { 12 return \u0026amp;stationManager{ 13 isPlatformFree: true, 14 lock: \u0026amp;sync.Mutex{}, 15 } 16} 17 18func (s *stationManager) canLand(t train) bool { 19 s.lock.Lock() 20 defer s.lock.Unlock() 21 if s.isPlatformFree { 22 s.isPlatformFree = false 23 return true 24 } 25 s.trainQueue = append(s.trainQueue, t) 26 return false 27} 28 29func (s *stationManager) notifyFree() { 30 s.lock.Lock() 31 defer s.lock.Unlock() 32 if !s.isPlatformFree { 33 s.isPlatformFree = true 34 } 35 if len(s.trainQueue) \u0026gt; 0 { 36 firstTrainInQueue := s.trainQueue[0] 37 s.trainQueue = s.trainQueue[1:] 38 firstTrainInQueue.permitArrival() 39 } 40} main.go\n1package main 2 3func main() { 4 stationManager := newStationManger() 5 passengerTrain := \u0026amp;passengerTrain{ 6 mediator: stationManager, 7 } 8 goodsTrain := \u0026amp;goodsTrain{ 9 mediator: stationManager, 10 } 11 passengerTrain.requestArrival() 12 goodsTrain.requestArrival() 13 passengerTrain.departure() 14} Output:\n1PassengerTrain: Landing 2GoodsTrain: Waiting 3PassengerTrain: Leaving 4GoodsTrain: Arrival Permitted. Landing Full Working Code: # 1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;sync\u0026#34; 6) 7 8type train interface { 9 requestArrival() 10 departure() 11 permitArrival() 12} 13 14type passengerTrain struct { 15 mediator mediator 16} 17 18func (g *passengerTrain) requestArrival() { 19 if g.mediator.canLand(g) { 20 fmt.Println(\u0026#34;PassengerTrain: Landing\u0026#34;) 21 } else { 22 fmt.Println(\u0026#34;PassengerTrain: Waiting\u0026#34;) 23 } 24} 25 26func (g *passengerTrain) departure() { 27 fmt.Println(\u0026#34;PassengerTrain: Leaving\u0026#34;) 28 g.mediator.notifyFree() 29} 30 31func (g *passengerTrain) permitArrival() { 32 fmt.Println(\u0026#34;PassengerTrain: Arrival Permitted. Landing\u0026#34;) 33} 34 35type goodsTrain struct { 36 mediator mediator 37} 38 39func (g *goodsTrain) requestArrival() { 40 if g.mediator.canLand(g) { 41 fmt.Println(\u0026#34;GoodsTrain: Landing\u0026#34;) 42 } else { 43 fmt.Println(\u0026#34;GoodsTrain: Waiting\u0026#34;) 44 } 45} 46 47func (g *goodsTrain) departure() { 48 g.mediator.notifyFree() 49 fmt.Println(\u0026#34;GoodsTrain: Leaving\u0026#34;) 50} 51 52func (g *goodsTrain) permitArrival() { 53 fmt.Println(\u0026#34;GoodsTrain: Arrival Permitted. Landing\u0026#34;) 54} 55 56type mediator interface { 57 canLand(train) bool 58 notifyFree() 59} 60 61type stationManager struct { 62 isPlatformFree bool 63 lock *sync.Mutex 64 trainQueue []train 65} 66 67func newStationManger() *stationManager { 68 return \u0026amp;stationManager{ 69 isPlatformFree: true, 70 lock: \u0026amp;sync.Mutex{}, 71 } 72} 73 74func (s *stationManager) canLand(t train) bool { 75 s.lock.Lock() 76 defer s.lock.Unlock() 77 if s.isPlatformFree { 78 s.isPlatformFree = false 79 return true 80 } 81 s.trainQueue = append(s.trainQueue, t) 82 return false 83} 84 85func (s *stationManager) notifyFree() { 86 s.lock.Lock() 87 defer s.lock.Unlock() 88 if !s.isPlatformFree { 89 s.isPlatformFree = true 90 } 91 if len(s.trainQueue) \u0026gt; 0 { 92 firstTrainInQueue := s.trainQueue[0] 93 s.trainQueue = s.trainQueue[1:] 94 firstTrainInQueue.permitArrival() 95 } 96} 97 98func main() { 99 stationManager := newStationManger() 100 passengerTrain := \u0026amp;passengerTrain{ 101 mediator: stationManager, 102 } 103 goodsTrain := \u0026amp;goodsTrain{ 104 mediator: stationManager, 105 } 106 passengerTrain.requestArrival() 107 goodsTrain.requestArrival() 108 passengerTrain.departure() 109} Output:\n1PassengerTrain: Landing 2GoodsTrain: Waiting 3PassengerTrain: Leaving 4GoodsTrain: Arrival Permitted. Landing "},{"id":197,"href":"/chapter-9/behavioral-patterns/go-memento-pattern/","title":"9.3.5 الگو Memento","section":"9.3 الگوهای طراحی رفتاری","content":"الگو Memento\u0026hellip;\n"},{"id":198,"href":"/chapter-9/behavioral-patterns/go-observer-pattern/","title":"9.3.6 الگو Observer","section":"9.3 الگوهای طراحی رفتاری","content":"الگو Observer\u0026hellip;\n"},{"id":199,"href":"/chapter-9/behavioral-patterns/go-state-pattern/","title":"9.3.7 الگو State","section":"9.3 الگوهای طراحی رفتاری","content":"الگو State\u0026hellip;\n9.3.7.1 مقدمه: # دیزاین پترن State یک دیزاین پترن behavioral است که مبتنی بر Finite State Machine است. ما دیزاین پترن State را در زمینه نمونه ای از Vending Machine توضیح خواهیم داد. برای سادگی، بیایید فرض کنیم که Vending Machine فقط یک نوع کالا یا محصول دارد. همچنین برای سادگی، فرض می کنیم که یک Vending Machine می تواند در 4 حالت(state) مختلف باشد:\nhasItem noItem itemRequested hasMoney یک Vending Machine خودکار نیز عملکردهای متفاوتی خواهد داشت. دوباره برای سادگی فرض می کنیم که فقط چهار عمل وجود دارد:\nSelect the item Add the item Insert Money Dispense Item 9.3.7.2 چه زمانی از این الگو استفاده کنیم: # از الگوی طراحی State زمانی استفاده کنید که object می تواند در بسیاری از حالت های (states) مختلف باشد. بسته به درخواست فعلی، object باید وضعیت فعلی خود را تغییر دهد. در مثال بالا، Vending Machine می تواند در بسیاری از حالت های مختلف باشد. یک Vending Machine از یک state به حالت دیگر تغییر می کند. فرض کنید Vending Machine در مورد itemRequested است، پس از انجام عمل «hasMoney» به حالت «Insert Money» منتقل می‌شود. از این پترن زمانی استفاده کنید که یک شی بسته به وضعیت فعلی پاسخ‌های متفاوتی به درخواست یکسان داشته باشد. استفاده از الگوی طراحی states در اینجا از بسیاری از عبارات شرطی جلوگیری می کند به عنوان مثال در مورد Vending Machine، اگر کاربری بخواهد کالایی را خریداری کند، اگر آن مورد hasItemState باشد دستگاه ادامه خواهد داد یا اگر در noItemState باشد آن را رد می کند. اگر در اینجا متوجه شدید که Vending Machine خودکار به درخواست خرید یک کالا، بسته به اینکه آیا در hasItemState باشد، دو پاسخ متفاوت می دهد. به فایل vendingMachine.go زیر توجه کنید، هیچ نوع دستور شرطی ندارد. تمام منطق توسط پیاده سازی های concrete state اداره می شود. 9.3.7.3 ## UML Diagram: # 9.3.7.4 ## Mapping: # جدول زیر mapping از نمودار UML به نمونه اجرایی پیاده سازی واقعی در کد را نشان می دهد.\nContext vendingMachine.go State Interface state.go Concrete State 1 noItemState.go Concrete State 2 hasItemState.go Concrete State 3 itemRequestedState.go Concrete State 4 hasMoneyState.go 9.3.7.5 ## توضیحات: # ما یک رابط(interface) از نوع \u0026lsquo;State\u0026rsquo; داریم که signature توابع را تعریف می کند که نشان دهنده عملکرد در زمینه Vending Machine است. در زیر signatureهای توابع عملیاتی وجود دارد addItem(int) error requestItem() error insertMoney(money int) error dispenseItem() error هر یک از پیاده‌سازی‌های concrete state، هر 4 تابع بالا را پیاده‌سازی می‌کنند و روی اقدامات مربوط به هر کدام یا به حالت دیگری می‌روند یا پاسخی تولید می‌کنند.\nهر یک از concrete stateها نیز یک اشاره گر را به object مربوط به Vending Machine فعلی تعبیه(embed) می کند تا انتقال حالت (state transition) در آن object اتفاق بیفتد.\n9.3.7.6 ## مثال کاربردی: # vendingMachine.go\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type vendingMachine struct { 6 hasItem state 7 itemRequested state 8 hasMoney state 9 noItem state 10 11 currentState state 12 13 itemCount int 14 itemPrice int 15} 16 17func newVendingMachine(itemCount, itemPrice int) *vendingMachine { 18 v := \u0026amp;vendingMachine{ 19 itemCount: itemCount, 20 itemPrice: itemPrice, 21 } 22 hasItemState := \u0026amp;hasItemState{ 23 vendingMachine: v, 24 } 25 itemRequestedState := \u0026amp;itemRequestedState{ 26 vendingMachine: v, 27 } 28 hasMoneyState := \u0026amp;hasMoneyState{ 29 vendingMachine: v, 30 } 31 noItemState := \u0026amp;noItemState{ 32 vendingMachine: v, 33 } 34 35 v.setState(hasItemState) 36 v.hasItem = hasItemState 37 v.itemRequested = itemRequestedState 38 v.hasMoney = hasMoneyState 39 v.noItem = noItemState 40 return v 41} 42 43func (v *vendingMachine) requestItem() error { 44 return v.currentState.requestItem() 45} 46 47func (v *vendingMachine) addItem(count int) error { 48 return v.currentState.addItem(count) 49} 50 51func (v *vendingMachine) insertMoney(money int) error { 52 return v.currentState.insertMoney(money) 53} 54 55func (v *vendingMachine) dispenseItem() error { 56 return v.currentState.dispenseItem() 57} 58 59func (v *vendingMachine) setState(s state) { 60 v.currentState = s 61} 62 63func (v *vendingMachine) incrementItemCount(count int) { 64 fmt.Printf(\u0026#34;Adding %d items\\n\u0026#34;, count) 65 v.itemCount = v.itemCount + count 66} state.go\n1package main 2 3type state interface { 4 addItem(int) error 5 requestItem() error 6 insertMoney(money int) error 7 dispenseItem() error 8} noItemState.go\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type noItemState struct { 6 vendingMachine *vendingMachine 7} 8 9func (i *noItemState) requestItem() error { 10 return fmt.Errorf(\u0026#34;Item out of stock\u0026#34;) 11} 12 13func (i *noItemState) addItem(count int) error { 14 i.vendingMachine.incrementItemCount(count) 15 i.vendingMachine.setState(i.vendingMachine.hasItem) 16 return nil 17} 18 19func (i *noItemState) insertMoney(money int) error { 20 return fmt.Errorf(\u0026#34;Item out of stock\u0026#34;) 21} 22func (i *noItemState) dispenseItem() error { 23 return fmt.Errorf(\u0026#34;Item out of stock\u0026#34;) 24} hasItemState.go\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type hasItemState struct { 6 vendingMachine *vendingMachine 7} 8 9func (i *hasItemState) requestItem() error { 10 if i.vendingMachine.itemCount == 0 { 11 i.vendingMachine.setState(i.vendingMachine.noItem) 12 return fmt.Errorf(\u0026#34;No item present\u0026#34;) 13 } 14 fmt.Printf(\u0026#34;Item requestd\\n\u0026#34;) 15 i.vendingMachine.setState(i.vendingMachine.itemRequested) 16 return nil 17} 18 19func (i *hasItemState) addItem(count int) error { 20 fmt.Printf(\u0026#34;%d items added\\n\u0026#34;, count) 21 i.vendingMachine.incrementItemCount(count) 22 return nil 23} 24 25func (i *hasItemState) insertMoney(money int) error { 26 return fmt.Errorf(\u0026#34;Please select item first\u0026#34;) 27} 28func (i *hasItemState) dispenseItem() error { 29 return fmt.Errorf(\u0026#34;Please select item first\u0026#34;) 30} itemRequestedState.go\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type itemRequestedState struct { 6 vendingMachine *vendingMachine 7} 8 9func (i *itemRequestedState) requestItem() error { 10 return fmt.Errorf(\u0026#34;Item already requested\u0026#34;) 11} 12 13func (i *itemRequestedState) addItem(count int) error { 14 return fmt.Errorf(\u0026#34;Item Dispense in progress\u0026#34;) 15} 16 17func (i *itemRequestedState) insertMoney(money int) error { 18 if money \u0026lt; i.vendingMachine.itemPrice { 19 fmt.Errorf(\u0026#34;Inserted money is less. Please insert %d\u0026#34;, i.vendingMachine.itemPrice) 20 } 21 fmt.Println(\u0026#34;Money entered is ok\u0026#34;) 22 i.vendingMachine.setState(i.vendingMachine.hasMoney) 23 return nil 24} 25 26func (i *itemRequestedState) dispenseItem() error { 27 return fmt.Errorf(\u0026#34;Please insert money first\u0026#34;) 28} hasMoneyState.go\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type hasMoneyState struct { 6 vendingMachine *vendingMachine 7} 8 9func (i *hasMoneyState) requestItem() error { 10 return fmt.Errorf(\u0026#34;Item dispense in progress\u0026#34;) 11} 12 13func (i *hasMoneyState) addItem(count int) error { 14 return fmt.Errorf(\u0026#34;Item dispense in progress\u0026#34;) 15} 16 17func (i *hasMoneyState) insertMoney(money int) error { 18 return fmt.Errorf(\u0026#34;Item out of stock\u0026#34;) 19} 20 21func (i *hasMoneyState) dispenseItem() error { 22 fmt.Println(\u0026#34;Dispensing Item\u0026#34;) 23 i.vendingMachine.itemCount = i.vendingMachine.itemCount - 1 24 if i.vendingMachine.itemCount == 0 { 25 i.vendingMachine.setState(i.vendingMachine.noItem) 26 } else { 27 i.vendingMachine.setState(i.vendingMachine.hasItem) 28 } 29 return nil 30} main.go\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;log\u0026#34; 6) 7 8func main() { 9 vendingMachine := newVendingMachine(1, 10) 10 err := vendingMachine.requestItem() 11 if err != nil { 12 log.Fatalf(err.Error()) 13 } 14 err = vendingMachine.insertMoney(10) 15 if err != nil { 16 log.Fatalf(err.Error()) 17 } 18 err = vendingMachine.dispenseItem() 19 if err != nil { 20 log.Fatalf(err.Error()) 21 } 22 23 fmt.Println() 24 err = vendingMachine.addItem(2) 25 if err != nil { 26 log.Fatalf(err.Error()) 27 } 28 29 fmt.Println() 30 31 err = vendingMachine.requestItem() 32 if err != nil { 33 log.Fatalf(err.Error()) 34 } 35 36 err = vendingMachine.insertMoney(10) 37 if err != nil { 38 log.Fatalf(err.Error()) 39 } 40 41 err = vendingMachine.dispenseItem() 42 if err != nil { 43 log.Fatalf(err.Error()) 44 } 45} Output:\n1Item requestd 2Money entered is ok 3Dispensing Item 4 5Adding 2 items 6 7Item requestd 8Money entered is ok 9Dispensing Item "},{"id":200,"href":"/chapter-9/behavioral-patterns/go-strategy-pattern/","title":"9.3.8 الگو Strategy","section":"9.3 الگوهای طراحی رفتاری","content":"الگو Strategy\u0026hellip;\n"},{"id":201,"href":"/chapter-9/behavioral-patterns/go-template-method-pattern/","title":"9.3.9 الگو Template Method","section":"9.3 الگوهای طراحی رفتاری","content":"الگو Template Method\u0026hellip;\n9.3.9.1 مقدمه: # الگوی Template Method یک الگوی طراحی behavioral است که به شما امکان می دهد یک الگو یا الگوریتم برای یک عملیات خاص تعریف کنید. بیایید الگوی Template Method را با یک مثال درک کنیم.\nمثال یک مرز یک بار مصرف (One Time Password) یا OTP را در نظر بگیرید. انواع مختلفی از OTP وجود دارد که می تواند برای مثال اجرا شود. OTP می تواند SMS OTP یا EMAIL OTP باشد. اما صرف نظر از اینکه یک پیامک OTP یا EMAIL OTP باشد، کل مراحل فرآیند OTP یکسان است. مراحل مورد نظر به ترتیب زیر هستند.\nیک عدد n رقمی تصادفی ایجاد کنید. این شماره را برای تأیید بعدی در cache ذخیره کنید. محتوا را آماده کنید notification را ارسال کنید metricsها را Publish کنید حتی در آینده فرض کنید یک push notification OTP معرفی شده است، اما همچنان مراحل بالا را طی خواهد کرد.\nدر چنین سناریوهایی زمانی که مراحل یک عملیات خاص یکسان است اما مراحل عملیات می تواند به روشی متفاوت توسط مجریان مختلف اجرا شود. پس از آن بهترین گزینه برای انتخاب دیزاین پترن مناسب گزینه Template Method می شود. ما یک template یا الگوریتم را تعریف می کنیم که از methodهای fixed number تشکیل شده است. نوشتن برنامه برای حالت جدید باید operation override متدهای template را پیاده سازی کند.\nحالا نمونه کد زیر را بررسی کنید.\niOtp نشان دهنده یک interface است که مجموعه متد هایی را که هر نوع otp باید پیاده سازی کند را تعریف می کند.\nاس ام اس و ایمیل پیاده سازی رابط iOtp هستند\notp ساختاری است که متد template () genAndSendOTP را تعریف می کند. otp رابط iOtp را تعبیه می کند.\nمهم: ترکیب رابط iOtp و ساختار otp قابلیت های Abstract Class را در زبان برنامه نویسی go فراهم می کند. برای اطلعات بیشتر در این مورد مرجع مراجعه کنید.\n9.3.9.2 مثال: # otp.go\n1package main 2 3type iOtp interface { 4 genRandomOTP(int) string 5 saveOTPCache(string) 6 getMessage(string) string 7 sendNotification(string) error 8 publishMetric() 9} 10 11type otp struct { 12 iOtp iOtp 13} 14 15func (o *otp) genAndSendOTP(otpLength int) error { 16 otp := o.iOtp.genRandomOTP(otpLength) 17 o.iOtp.saveOTPCache(otp) 18 message := o.iOtp.getMessage(otp) 19 err := o.iOtp.sendNotification(message) 20 if err != nil { 21 return err 22 } 23 o.iOtp.publishMetric() 24 return nil 25} sms.go\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type sms struct { 6 otp 7} 8 9func (s *sms) genRandomOTP(len int) string { 10 randomOTP := \u0026#34;1234\u0026#34; 11 fmt.Printf(\u0026#34;SMS: generating random otp %s\\n\u0026#34;, randomOTP) 12 return randomOTP 13} 14 15func (s *sms) saveOTPCache(otp string) { 16 fmt.Printf(\u0026#34;SMS: saving otp: %s to cache\\n\u0026#34;, otp) 17} 18 19func (s *sms) getMessage(otp string) string { 20 return \u0026#34;SMS OTP for login is \u0026#34; + otp 21} 22 23func (s *sms) sendNotification(message string) error { 24 fmt.Printf(\u0026#34;SMS: sending sms: %s\\n\u0026#34;, message) 25 return nil 26} 27 28func (s *sms) publishMetric() { 29 fmt.Printf(\u0026#34;SMS: publishing metrics\\n\u0026#34;) 30} email.go\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type email struct { 6 otp 7} 8 9func (s *email) genRandomOTP(len int) string { 10 randomOTP := \u0026#34;1234\u0026#34; 11 fmt.Printf(\u0026#34;EMAIL: generating random otp %s\\n\u0026#34;, randomOTP) 12 return randomOTP 13} 14 15func (s *email) saveOTPCache(otp string) { 16 fmt.Printf(\u0026#34;EMAIL: saving otp: %s to cache\\n\u0026#34;, otp) 17} 18 19func (s *email) getMessage(otp string) string { 20 return \u0026#34;EMAIL OTP for login is \u0026#34; + otp 21} 22 23func (s *email) sendNotification(message string) error { 24 fmt.Printf(\u0026#34;EMAIL: sending email: %s\\n\u0026#34;, message) 25 return nil 26} 27 28func (s *email) publishMetric() { 29 fmt.Printf(\u0026#34;EMAIL: publishing metrics\\n\u0026#34;) 30} main.go\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 smsOTP := \u0026amp;sms{} 7 o := otp{ 8 iOtp: smsOTP, 9 } 10 o.genAndSendOTP(4) 11 fmt.Println(\u0026#34;\u0026#34;) 12 emailOTP := \u0026amp;email{} 13 o = otp{ 14 iOtp: emailOTP, 15 } 16 o.genAndSendOTP(4) 17} Output:\n1SMS: generating random otp 1234 2SMS: saving otp: 1234 to cache 3SMS: sending sms: SMS OTP for login is 1234 4SMS: publishing metrics 5 6EMAIL: generating random otp 1234 7EMAIL: saving otp: 1234 to cache 8EMAIL: sending email: EMAIL OTP for login is 1234 9EMAIL: publishing metrics 9.3.9.3 مثال پیاده سازی شده به صورت یکجا: # 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type iOtp interface { 6 genRandomOTP(int) string 7 saveOTPCache(string) 8 getMessage(string) string 9 sendNotification(string) error 10 publishMetric() 11} 12 13type otp struct { 14 iOtp iOtp 15} 16 17func (o *otp) genAndSendOTP(otpLength int) error { 18 otp := o.iOtp.genRandomOTP(otpLength) 19 o.iOtp.saveOTPCache(otp) 20 message := o.iOtp.getMessage(otp) 21 err := o.iOtp.sendNotification(message) 22 if err != nil { 23 return err 24 } 25 o.iOtp.publishMetric() 26 return nil 27} 28 29type sms struct { 30 otp 31} 32 33func (s *sms) genRandomOTP(len int) string { 34 randomOTP := \u0026#34;1234\u0026#34; 35 fmt.Printf(\u0026#34;SMS: generating random otp %s\\n\u0026#34;, randomOTP) 36 return randomOTP 37} 38 39func (s *sms) saveOTPCache(otp string) { 40 fmt.Printf(\u0026#34;SMS: saving otp: %s to cache\\n\u0026#34;, otp) 41} 42 43func (s *sms) getMessage(otp string) string { 44 return \u0026#34;SMS OTP for login is \u0026#34; + otp 45} 46 47func (s *sms) sendNotification(message string) error { 48 fmt.Printf(\u0026#34;SMS: sending sms: %s\\n\u0026#34;, message) 49 return nil 50} 51 52func (s *sms) publishMetric() { 53 fmt.Printf(\u0026#34;SMS: publishing metrics\\n\u0026#34;) 54} 55 56type email struct { 57 otp 58} 59 60func (s *email) genRandomOTP(len int) string { 61 randomOTP := \u0026#34;1234\u0026#34; 62 fmt.Printf(\u0026#34;EMAIL: generating random otp %s\\n\u0026#34;, randomOTP) 63 return randomOTP 64} 65 66func (s *email) saveOTPCache(otp string) { 67 fmt.Printf(\u0026#34;EMAIL: saving otp: %s to cache\\n\u0026#34;, otp) 68} 69 70func (s *email) getMessage(otp string) string { 71 return \u0026#34;EMAIL OTP for login is \u0026#34; + otp 72} 73 74func (s *email) sendNotification(message string) error { 75 fmt.Printf(\u0026#34;EMAIL: sending email: %s\\n\u0026#34;, message) 76 return nil 77} 78 79func (s *email) publishMetric() { 80 fmt.Printf(\u0026#34;EMAIL: publishing metrics\\n\u0026#34;) 81} 82 83func main() { 84 smsOTP := \u0026amp;sms{} 85 o := otp{ 86 iOtp: smsOTP, 87 } 88 o.genAndSendOTP(4) 89 fmt.Println(\u0026#34;\u0026#34;) 90 emailOTP := \u0026amp;email{} 91 o = otp{ 92 iOtp: emailOTP, 93 } 94 o.genAndSendOTP(4) 95} Output:\n1SMS: generating random otp 1234 2SMS: saving otp: 1234 to cache 3SMS: sending sms: SMS OTP for login is 1234 4SMS: publishing metrics 5 6EMAIL: generating random otp 1234 7EMAIL: saving otp: 1234 to cache 8EMAIL: sending email: EMAIL OTP for login is 1234 9EMAIL: publishing metrics "},{"id":202,"href":"/chapter-9/behavioral-patterns/go-visitor-pattern/","title":"9.3.10 الگو Visitor","section":"9.3 الگوهای طراحی رفتاری","content":"الگو Visitor\u0026hellip;\n9.3.10.1 مقدمه: # الگوی طراحی Visitor یک الگوی طراحی Behavioural است که به شما امکان می‌دهد بدون تغییر در ساختار برنامه، رفتاری را به ساختار آن اضافه کنید.\nبیایید الگوی Visitor را با یک مثال درک کنیم. فرض کنید شما نگهدارنده(maintainer) یک lib هستید که ساختارهای با شکل‌های متفاوتی دارد مانند:\nSquare Circle Triangle هر یک از ساختارهای شکل بالا یک شکل رابط مشترک را پیاده سازی می کند. تیم های زیادی در شرکت شما وجود دارند که از lib شما استفاده می کنند. حال فرض کنید یکی از تیم از شما می خواهد که یک رفتار دیگر (getArea()) به ساختارهای Shape اضافه کنید. در نتیجه گزینه های زیادی برای حل این مشکل وجود دارد.\nراه حل اول: # اولین گزینه ای که به ذهن می رسد اضافه کردن متد getArea() در interface مربوط به shape است و سپس هر ساختار shape می تواند متد getArea() را پیاده سازی کند. این به نظر بی اهمیت می رسد اما برخی از مشکلات وجود دارد:\nبه عنوان maintainer کتابخانه، نمی خواهید کد بسیار آزمایش شده کتابخانه خود را با افزودن رفتارهای اضافی تغییر دهید. ممکن است تیم هایی که از کتابخانه شما استفاده می کنند درخواست بیشتری برای رفتارهای بیشتری مانند getNumSides()، getMiddleCoordinates(). سپس، در این مورد، شما نمی خواهید به اصلاح کتابخانه خود ادامه دهید. اما شما می خواهید که تیم های دیگر کتابخانه شما را بدون تغییر واقعی کد گسترش دهند. راه حل دوم: # گزینه دوم این است که تیمی که این ویژگی را درخواست می کند می تواند منطق رفتار را خودش بنویسد. بنابراین بر اساس نوع shape struct آنها کد زیر را در نظر دارند:\n1if shape.type == square { 2 //Calculate area for squre 3} elseif shape.type == circle { 4 //Calculate area of triangle 5} elseif shape.type == \u0026#34;triangle\u0026#34; { 6 //Calculate area of triangle 7} else { 8 //Raise error 9} کد بالا نیز مشکل ساز است زیرا نمی توانید از مزایای کامل interface ها استفاده کنید و به جای آن یک بررسی explicit type که شکننده(fragile) است انجام دهید. دوم، دریافت type در زمان اجرا ممکن است تأثیری بر عملکرد داشته باشد یا حتی در برخی از زبان ها امکان پذیر نباشد.\nراه حل سوم: # گزینه سوم حل مشکل فوق با استفاده از الگوی visitor است. ما یکvisitor interface را مانند زیر تعریف می کنیم.\n1type visitor interface { 2 visitForSquare(square) 3 visitForCircle(circle) 4 visitForTriangle(triangle) 5} توابع visitforSquare(square)، visitForCircle(circle)، visitForTriangle(triangle) به ما اجازه می دهد تا به ترتیب قابلیت های Square، Circle و Triangle را اضافه کنیم.\nحال سوالی که به ذهن می رسد این است که چرا نمی توانیم یک روش visit**(shape)** واحد در visitor interface داشته باشیم. دلیل اینکه ما این ویژگی را نداریم این است که GO و همچنین برخی از زبان های دیگر از method overloading پشتیبانی می کنند. بنابراین یک method متفاوت برای هر یک از ساختارها مورد نیاز است.\nما یک accept method را با signature زیر به shape interface اضافه می کنیم و هر یک از shape struct باید این متد را تعریف کنند.\n1func accept(v visitor) اما یک لحظه صبر کنید، ما فقط اشاره کردیم که نمی خواهیم shape structs موجود خود را تغییر دهیم. اما هنگام استفاده از Visitor Pattern باید shape structs خود را تغییر دهیم اما این اصلاح فقط یک بار انجام می شود. در صورت اضافه کردن هر رفتار اضافی مانند getNumSides()، getMiddleCoordinates() از همان تابع accept(v visitor) فوق بدون تغییر بیشتر در shape structs استفاده می کند. اساساً shape structs فقط باید یک بار اصلاح شوند و تمام درخواست‌های آتی رفتارهای اضافی با استفاده از همان تابع پذیرش بررسی می‌شوند. ببینیم چطور! ساختار مربع (square struct) یک accept method مانند زیر را اجرا می کند:\n1func (obj *squre) accept(v visitor){ 2 v.visitForSquare(obj) 3} و به طور مشابه، دایره و مثلث نیز accept function را مانند بالا تعریف می کنند.\nاکنون تیمی که رفتار getArea() را درخواست می‌کند، می‌تواند به سادگی concrete implementation را برای visitor interface را تعریف کند و منطق محاسبه ناحیه را در آن concrete implementation بنویسد.\nareaCalculator.go\n1type areaCalculator struct{ 2 area int 3} 4 5func (a *areaCalculator) visitForSquare(s *square){ 6 //Calculate are for square 7} 8func (a *areaCalculator) visitForCircle(s *square){ 9 //Calculate are for circle 10} 11func (a *areaCalculator) visitForTriangle(s *square){ 12 //Calculate are for triangle برای محاسبه مساحت یک مربع، ابتدا نمونه ای از مربعی که آنها به سادگی می توانند فراخوانی کنند ایجاد می کنیم.\n1sq := \u0026amp;square{} 2ac := \u0026amp;areaCalculator{} 3sq.accept(ac) به طور مشابه، تیم دیگری که برای رفتار getMiddleCoordinates() درخواست می‌کند، می‌تواند پیاده‌سازی concrete دیگری از visitor interfaceمشابه با بالا تعریف کند.\nmiddleCoordinates.go\n1type middleCoordinates struct { 2 x int 3 y int 4} 5 6func (a *middleCoordinates) visitForSquare(s *square) { 7 //Calculate middle point coordinates for square. After calculating the area assign in to the x and y instance variable. 8} 9 10func (a *middleCoordinates) visitForCircle(c *circle) { 11 //Calculate middle point coordinates for square. After calculating the area assign in to the x and y instance variable. 12} 13 14func (a *middleCoordinates) visitForTriangle(t *triangle) { 15 //Calculate middle point coordinates for square. After calculating the area assign in to the x and y instance variable. 16} در زیر نمودار mapping UML متناظر با مثال عملی shape struct و areaCalculator که در بالا ارائه کردیم آمده است.\n9.3.10.2 # Mapping: # جدول زیر mapping از اجزای مهم نمودار UML به اجزای واقعی implementation را در \u0026lsquo;مثال\u0026rsquo; زیر نشان می دهد.\nelement shape.go Concrete Element A square.go Concrete Element B circle.go Concrete Element C rectangle.go Visitor visitor.go Concrete Visitor 1 areaCalculator.go Concrete Visitor 2 middleCoordinates.go Client main.go 9.3.10.3 # مثال: # shape.go\n1package main 2 3type shape interface { 4 getType() string 5 accept(visitor) 6} square.go\n1package main 2 3type square struct { 4 side int 5} 6 7func (s *square) accept(v visitor) { 8 v.visitForSquare(s) 9} 10 11func (s *square) getType() string { 12 return \u0026#34;Square\u0026#34; 13} circle.go\n1package main 2 3type circle struct { 4 radius int 5} 6 7func (c *circle) accept(v visitor) { 8 v.visitForCircle(c) 9} 10 11func (c *circle) getType() string { 12 return \u0026#34;Circle\u0026#34; 13} rectangle.go\n1package main 2 3type rectangle struct { 4 l int 5 b int 6} 7 8func (t *rectangle) accept(v visitor) { 9 v.visitForrectangle(t) 10} 11 12func (t *rectangle) getType() string { 13 return \u0026#34;rectangle\u0026#34; 14} visitor.go\n1package main 2 3type visitor interface { 4 visitForSquare(*square) 5 visitForCircle(*circle) 6 visitForrectangle(*rectangle) 7} areaCalculator.go\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5) 6 7type areaCalculator struct { 8 area int 9} 10 11func (a *areaCalculator) visitForSquare(s *square) { 12 //Calculate area for square. After calculating the area assign in to the area instance variable 13 fmt.Println(\u0026#34;Calculating area for square\u0026#34;) 14} 15 16func (a *areaCalculator) visitForCircle(s *circle) { 17 //Calculate are for circle. After calculating the area assign in to the area instance variable 18 fmt.Println(\u0026#34;Calculating area for circle\u0026#34;) 19} 20 21func (a *areaCalculator) visitForrectangle(s *rectangle) { 22 //Calculate are for rectangle. After calculating the area assign in to the area instance variable 23 fmt.Println(\u0026#34;Calculating area for rectangle\u0026#34;) 24} middleCoordinates.go\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type middleCoordinates struct { 6 x int 7 y int 8} 9 10func (a *middleCoordinates) visitForSquare(s *square) { 11 //Calculate middle point coordinates for square. After calculating the area assign in to the x and y instance variable. 12 fmt.Println(\u0026#34;Calculating middle point coordinates for square\u0026#34;) 13} 14 15func (a *middleCoordinates) visitForCircle(c *circle) { 16 //Calculate middle point coordinates for square. After calculating the area assign in to the x and y instance variable. 17 fmt.Println(\u0026#34;Calculating middle point coordinates for circle\u0026#34;) 18} 19 20func (a *middleCoordinates) visitForrectangle(t *rectangle) { 21 //Calculate middle point coordinates for square. After calculating the area assign in to the x and y instance variable. 22 fmt.Println(\u0026#34;Calculating middle point coordinates for rectangle\u0026#34;) 23} main.go\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 square := \u0026amp;square{side: 2} 7 circle := \u0026amp;circle{radius: 3} 8 rectangle := \u0026amp;rectangle{l: 2, b: 3} 9 10 areaCalculator := \u0026amp;areaCalculator{} 11 square.accept(areaCalculator) 12 circle.accept(areaCalculator) 13 rectangle.accept(areaCalculator) 14 15 fmt.Println() 16 middleCoordinates := \u0026amp;middleCoordinates{} 17 square.accept(middleCoordinates) 18 circle.accept(middleCoordinates) 19 rectangle.accept(middleCoordinates) 20} Output:\n1Calculating area for square 2Calculating area for circle 3Calculating area for rectangle 4 5Calculating middle point coordinates for square 6Calculating middle point coordinates for circle 7Calculating middle point coordinates for rectangle 9.3.10.3 # پیاده سازی به صورت یک جا: # 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type shape interface { 6 getType() string 7 accept(visitor) 8} 9 10type square struct { 11 side int 12} 13 14func (s *square) accept(v visitor) { 15 v.visitForSquare(s) 16} 17 18func (s *square) getType() string { 19 return \u0026#34;Square\u0026#34; 20} 21 22type circle struct { 23 radius int 24} 25 26func (c *circle) accept(v visitor) { 27 v.visitForCircle(c) 28} 29 30func (c *circle) getType() string { 31 return \u0026#34;Circle\u0026#34; 32} 33 34type rectangle struct { 35 l int 36 b int 37} 38 39func (t *rectangle) accept(v visitor) { 40 v.visitForrectangle(t) 41} 42 43func (t *rectangle) getType() string { 44 return \u0026#34;rectangle\u0026#34; 45} 46 47type visitor interface { 48 visitForSquare(*square) 49 visitForCircle(*circle) 50 visitForrectangle(*rectangle) 51} 52 53type areaCalculator struct { 54 area int 55} 56 57func (a *areaCalculator) visitForSquare(s *square) { 58 //Calculate area for square. After calculating the area assign in to the area instance variable 59 fmt.Println(\u0026#34;Calculating area for square\u0026#34;) 60} 61 62func (a *areaCalculator) visitForCircle(s *circle) { 63 //Calculate are for circle. After calculating the area assign in to the area instance variable 64 fmt.Println(\u0026#34;Calculating area for circle\u0026#34;) 65} 66 67func (a *areaCalculator) visitForrectangle(s *rectangle) { 68 //Calculate are for rectangle. After calculating the area assign in to the area instance variable 69 fmt.Println(\u0026#34;Calculating area for rectangle\u0026#34;) 70} 71 72type middleCoordinates struct { 73 x int 74 y int 75} 76 77func (a *middleCoordinates) visitForSquare(s *square) { 78 //Calculate middle point coordinates for square. After calculating the area assign in to the x and y instance variable. 79 fmt.Println(\u0026#34;Calculating middle point coordinates for square\u0026#34;) 80} 81 82func (a *middleCoordinates) visitForCircle(c *circle) { 83 //Calculate middle point coordinates for square. After calculating the area assign in to the x and y instance variable. 84 fmt.Println(\u0026#34;Calculating middle point coordinates for circle\u0026#34;) 85} 86 87func (a *middleCoordinates) visitForrectangle(t *rectangle) { 88 //Calculate middle point coordinates for square. After calculating the area assign in to the x and y instance variable. 89 fmt.Println(\u0026#34;Calculating middle point coordinates for rectangle\u0026#34;) 90} 91 92func main() { 93 square := \u0026amp;square{side: 2} 94 circle := \u0026amp;circle{radius: 3} 95 rectangle := \u0026amp;rectangle{l: 2, b: 3} 96 areaCalculator := \u0026amp;areaCalculator{} 97 square.accept(areaCalculator) 98 circle.accept(areaCalculator) 99 rectangle.accept(areaCalculator) 100 101 fmt.Println() 102 middleCoordinates := \u0026amp;middleCoordinates{} 103 square.accept(middleCoordinates) 104 circle.accept(middleCoordinates) 105 rectangle.accept(middleCoordinates) 106} Output:\n1Calculating area for square 2Calculating area for circle 3Calculating area for rectangle 4 5Calculating middle point coordinates for square 6Calculating middle point coordinates for circle 7Calculating middle point coordinates for rectangle "},{"id":203,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-wait-for-result/","title":"9.4.1 الگو Wait For Result","section":"9.4 الگوهای همزمانی","content":" 9.4.1.1 توضیحات # الگوی Wait For Result یکی از پرکاربردترین الگوها در برنامه‌نویسی همزمان با Go است که هدفش اجرای عملیات به صورت goroutine و انتظار برای دریافت نتیجه از طریق channel است. در این الگو، معمولاً یک کانال تعریف می‌شود تا داده یا نتیجه (و حتی خطا) از goroutine به کد اصلی منتقل شود. این کار باعث می‌شود عملیات‌های طولانی یا زمان‌بر (مثل خواندن فایل، تماس با API یا انجام محاسبات سنگین) بدون بلاک کردن کل برنامه اجرا شوند و به محض آماده شدن نتیجه، به صورت ایمن و همزمان، دریافت شوند. ساختار معمول این الگو به این صورت است که یک goroutine کار را انجام می‌دهد و در پایان نتیجه را داخل کانال می‌فرستد؛ در این مدت goroutine اصلی (یا هر مصرف‌کننده دیگر) با دریافت روی کانال منتظر نتیجه می‌ماند.\nاین الگو هم از نظر سادگی و هم از نظر ایمنی، مزیت بالایی دارد و پیاده‌سازی آن با استفاده از کانال‌های Go، باعث می‌شود برنامه دچار race condition یا مشکلات همزمانی نشود. همچنین با اضافه کردن ساختارهایی مثل struct حاوی مقدار و خطا، یا استفاده از context برای مدیریت تایم‌اوت و کنسل کردن، می‌توان این الگو را کاملاً production-ready کرد. به طور خلاصه، Wait For Result راهکاری است که به کمک آن، ضمن استفاده بهینه از منابع و افزایش کارایی، کنترل کاملی بر زمان و نتیجه عملیات‌های همزمان خواهید داشت و به راحتی می‌توانید منطق‌های پیچیده‌تر مثل جمع‌آوری نتایج، مدیریت خطاها، یا پیاده‌سازی تایم‌اوت را نیز به آن اضافه کنید.\n9.4.1.2 دیاگرام # sequenceDiagram participant Main as Main Goroutine participant Chan as Channel participant Worker as Worker Goroutine Main-\u003e\u003eChan: ایجاد channel Main-\u003e\u003eWorker: راه‌اندازی goroutine (با ارجاع به channel) Worker-\u003e\u003eWorker: انجام عملیات (مثلاً I/O) Worker-\u003e\u003eChan: ارسال نتیجه به channel Main-\u003e\u003eChan: منتظر دریافت نتیجه از channel Chan--\u003e\u003eMain: دریافت نتیجه 9.4.1.3 نمونه کد # 1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;time\u0026#34; 6) 7 8func longRunningTask(c chan int) { 9\ttime.Sleep(3 * time.Second) 10\tc \u0026lt;- 42 11} 12 13func main() { 14\tc := make(chan int) 15\tgo longRunningTask(c) 16 17\tresult := \u0026lt;-c 18\tfmt.Println(\u0026#34;Result:\u0026#34;, result) 19} 1$ go run main.go 2Result: 42 این کد نمونه، مفهوم الگوی Wait For Result را در Go به شکلی بسیار ساده و شفاف پیاده‌سازی می‌کند. در این برنامه، یک تابع به نام longRunningTask داریم که شبیه‌ساز یک کار زمان‌بر است؛ این تابع پس از سه ثانیه توقف (با استفاده از time.Sleep) عدد ۴۲ را از طریق یک کانال (channel) به بخش اصلی برنامه (main goroutine) ارسال می‌کند. در تابع main، ابتدا یک کانال بدون بافر ساخته شده و سپس با استفاده از goroutine، تابع زمان‌بر به طور موازی اجرا می‌شود. پس از آن، برنامه اصلی منتظر می‌ماند تا مقدار از کانال دریافت شود و به محض دریافت، مقدار دریافت‌شده را چاپ می‌کند.\nکاربرد این الگو در سناریوهایی است که نیاز داریم عملیات زمان‌بر یا همزمان را اجرا کنیم و در عین حال تا زمان آماده شدن نتیجه، سایر بخش‌های برنامه بلاک نشود یا بتوانیم همزمان چندین کار دیگر را انجام دهیم. دریافت مقدار از کانال در اینجا نقش \u0026ldquo;منتظر ماندن برای نتیجه\u0026rdquo; را دارد و هنگامی که goroutine مقدار را ارسال کند، ادامه‌ی برنامه اصلی اجرا می‌شود. این روش به صورت idiomatic و ایمن، همزمانی و انتقال داده بین goroutineها را در Go مدیریت می‌کند و به‌سادگی می‌توان آن را در مسائل واقعی‌تر، مثلاً پردازش موازی درخواست‌ها یا جمع‌آوری نتایج عملیات‌های موازی، استفاده کرد.\n9.4.1.4 کاربردها # Web Scraping: زمانی که عملیات web scraping انجام می‌دهید، معمولاً نیاز است به طور همزمان از چندین آدرس وب داده جمع‌آوری کنید. در این حالت می‌توانید درخواست‌ها را به صورت موازی (با استفاده از goroutine) به چندین سایت ارسال کرده و سپس با استفاده از این الگو منتظر بمانید تا نتایج همه درخواست‌ها دریافت شود؛ این کار باعث افزایش چشمگیر سرعت جمع‌آوری داده می‌شود. API Calls: در معماری میکروسرویس، گاهی لازم است چندین API را به صورت همزمان فراخوانی کنید و پس از دریافت نتایج، نتیجه نهایی را به کلاینت برگردانید. این الگو به شما این امکان را می‌دهد که همزمان درخواست‌ها را ارسال کنید و به صورت منتظر (blocking) روی دریافت پاسخ‌ها بمانید تا همه نتایج آماده شود و در نهایت با کمترین زمان ممکن پاسخ‌دهی انجام دهید. Parallel Computation: در پردازش‌های علمی یا داده‌ای، معمولاً نیاز است محاسبات سنگین را به صورت موازی اجرا کنید. می‌توانید هر بخش از محاسبات را در goroutine جداگانه انجام دهید و با استفاده از این الگو، تا زمانی که تمام نتایج آماده نشده‌اند، منتظر بمانید و پس از دریافت همه پاسخ‌ها، مرحله بعدی پردازش را آغاز کنید. "},{"id":204,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-fan-out-in/","title":"9.4.2 الگو Fan Out/In","section":"9.4 الگوهای همزمانی","content":" 9.4.2.1 توضیحات # الگوی Fan Out/In یکی از مهم‌ترین تکنیک‌های همزمانی در زبان Go است که برای افزایش کارایی و سرعت پردازش در سناریوهایی به‌کار می‌رود که نیاز داریم چندین کار مشابه یا مستقل را به صورت موازی انجام دهیم و در نهایت نتایج همه آن‌ها را جمع‌آوری و تجمیع کنیم. در این الگو، معمولاً یک goroutine اصلی چندین goroutine فرعی را راه‌اندازی می‌کند (Fan Out) تا هر کدام یک وظیفه مستقل را انجام دهند؛ سپس نتایج این goroutineها (که می‌تواند هر نوع داده یا حتی خطا باشد) از طریق کانال‌ها جمع‌آوری شده و پس از اتمام همه کارها، نتیجه نهایی (Fan In) به goroutine اصلی برگردانده می‌شود.\nاین الگو به طور گسترده در جاهایی مانند جمع‌آوری داده از منابع مختلف، پردازش موازی بخش‌های مختلف یک داده بزرگ، یا حتی در معماری‌های میکروسرویس برای جمع‌آوری پاسخ چندین سرویس کاربرد دارد. مزیت اصلی Fan Out/In در Go این است که با استفاده از goroutineها و channelها می‌توان به‌سادگی کارهای موازی را مدیریت کرد، منتظر اتمام تمام کارها ماند و در عین حال، همزمانی ایمن و بدون race condition را حفظ کرد. به عنوان مثال، اگر نیاز باشد صدها درخواست HTTP به طور همزمان ارسال و پاسخ‌ها تجمیع شوند، یا بخش‌های یک فایل بزرگ به صورت موازی پردازش شوند، این الگو بهترین انتخاب است و به سادگی در Go پیاده‌سازی می‌شود.\n9.4.2.2 دیاگرام # graph LR A[InputChannel] --\u003e B1(Add) A --\u003e B2(Add) A --\u003e B3(Add) A --\u003e B4(Add) B1 --\u003e C(Merge) B2 --\u003e C B3 --\u003e C B4 --\u003e C C --\u003e D(Multiply) classDef faded fill:#fff,stroke:#bbb,stroke-width:2px; classDef step fill:#e3ffe3,stroke:#b4eeb4,stroke-width:2px; classDef merge fill:#ffecc7,stroke:#efb64f,stroke-width:2px; class A faded; class B1,B2,B3,B4 step; class C merge; class D step; B1--\u003e|Fan-Out|A C--\u003e|Fan-In|B1 9.4.2.3 نمونه کد # فرض کنید قصد دارید یک برنامه ای بنویسید که چندین فایل بصورت موازی دانلود کنید و در نهایت محتوای این فایل را میخواهید ترکیب کنید و یک خروجی داشته باشید.\nدر زیر یک مثال ساده زدیم :\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;sync\u0026#34; 6) 7 8// ساختار نتیجه دانلود 9type DownloadResult struct { 10\tURL string 11\tData string 12\tErr error 13} 14 15func main() { 16\turls := []string{\u0026#34;url1\u0026#34;, \u0026#34;url2\u0026#34;, \u0026#34;url3\u0026#34;} 17\tvar wg sync.WaitGroup 18 19\tresults := make(chan DownloadResult, len(urls)) // کانال بافر دار به اندازه تعداد urlها 20 21\t// Fan-Out: اجرای موازی دانلودها 22\tfor _, url := range urls { 23\twg.Add(1) 24\tgo func(url string) { 25\tdefer wg.Done() 26\tdata, err := downloadFile(url) 27\tresults \u0026lt;- DownloadResult{ 28\tURL: url, 29\tData: data, 30\tErr: err, 31\t} 32\t}(url) 33\t} 34 35\t// Fan-In: بستن کانال پس از پایان همه goroutineها 36\tgo func() { 37\twg.Wait() 38\tclose(results) 39\t}() 40 41\t// جمع‌آوری و نمایش نتایج 42\tfor result := range results { 43\tif result.Err != nil { 44\tfmt.Printf(\u0026#34;خطا در دانلود %s: %v\\n\u0026#34;, result.URL, result.Err) 45\tcontinue 46\t} 47\tfmt.Printf(\u0026#34;دانلود %s موفقیت‌آمیز: %s\\n\u0026#34;, result.URL, result.Data) 48\t} 49} 50 51// شبیه‌ساز دانلود فایل 52func downloadFile(url string) (string, error) { 53\t// در اینجا می‌توانید کد واقعی دانلود را قرار دهید 54\tif url == \u0026#34;url2\u0026#34; { 55\treturn \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;اتصال برقرار نشد\u0026#34;) 56\t} 57\treturn \u0026#34;file contents of \u0026#34; + url, nil 58} 1$ go run main.go 2دانلود url1 موفقیت‌آمیز: file contents of url1 3دانلود url3 موفقیت‌آمیز: file contents of url3 4خطا در دانلود url2: اتصال برقرار نشد در این مثال از الگوی Fan-Out/Fan-In در Go، عملیات دانلود فایل‌ها از چندین آدرس به صورت کاملاً موازی و ایمن انجام می‌شود و مدیریت خطاها، شناسایی منبع داده و خوانایی کد به شکل قابل توجهی ارتقا یافته است. ساختار جدیدی به نام DownloadResult تعریف شده که اطلاعات هر دانلود شامل آدرس منبع (URL)، داده دریافتی (Data) و هرگونه خطا (Err) را در خود نگه می‌دارد. این کار باعث می‌شود در زمان جمع‌آوری نتایج، به‌راحتی بتوان نتیجه‌ی هر عملیات را با منبع آن تطبیق داد و مدیریت خطا را به صورت مجزا و تمیز انجام داد؛ در حالی که در کد اولیه، فقط داده به صورت یک رشته ساده منتقل می‌شد و اگر خطایی رخ می‌داد، امکان تشخیص منبع آن وجود نداشت.\nدر مرحله Fan-Out، با استفاده از یک حلقه، برای هر URL یک goroutine راه‌اندازی می‌شود که وظیفه دانلود داده از آن آدرس را بر عهده دارد. به‌منظور جلوگیری از بلاک شدن ناخواسته goroutineها (به ویژه اگر دریافت روی کانال با تأخیر انجام شود)، یک کانال بافر دار به اندازه تعداد آدرس‌ها تعریف شده است. هر goroutine پس از اتمام کار، نتیجه (اعم از موفق یا ناموفق) را به صورت یک ساختار DownloadResult داخل کانال قرار می‌دهد و با استفاده از wg.Done() پایان کار خود را به WaitGroup اعلام می‌کند. به‌طور همزمان، یک goroutine دیگر وظیفه دارد پس از اتمام همه عملیات‌ها (یعنی وقتی شمارنده WaitGroup به صفر رسید)، کانال نتایج را ببندد تا مصرف‌کننده (main goroutine) از پایان عملیات‌ها مطلع شود.\nدر مرحله Fan-In، کد اصلی با استفاده از حلقه for result := range results همه نتایج را از کانال دریافت می‌کند. اگر برای هر آدرس خطایی رخ داده باشد، پیام خطا به همراه نام منبع نمایش داده می‌شود و در غیر این صورت، پیام موفقیت و محتوای دانلود شده چاپ می‌گردد. به این ترتیب، امکان مدیریت خطاها، ثبت وضعیت هر دانلود و افزایش شفافیت و قابلیت دیباگ کد به دست می‌آید. از این الگو می‌توان به عنوان هسته اصلی جمع‌آوری موازی داده‌ها، پردازش موازی یا کار با چندین سرویس مختلف استفاده کرد؛ در حالی که همچنان کد خوانا، ایمن و توسعه‌پذیر باقی می‌ماند.\nاین نسخه، به خاطر ساختار‌بندی داده‌ها، مدیریت دقیق goroutineها و رعایت نکات idiomatic زبان Go، کاملاً مناسب پروژه‌های جدی و تولیدی است و به راحتی می‌توان قابلیت‌هایی مثل شمارش زمان پاسخ‌دهی، ذخیره خروجی‌ها یا مدیریت خطاهای خاص را به آن اضافه کرد. این رویکرد بهترین تمرین‌های تولیدی (production-ready best practices) برای کار با همزمانی در Go را به نمایش می‌گذارد و برای سناریوهای واقعی مانند Web Scraping، جمع‌آوری داده از میکروسرویس‌ها یا پردازش موازی فایل‌ها کاملاً قابل اتکا است.\n9.4.2.4 کاربردها # پردازش داده (Data Processing): با استفاده از الگوی Fan-Out/Fan-In می‌توانید حجم زیادی از داده‌ها را به طور موازی پردازش کنید. به عنوان مثال، زمانی که یک داده بزرگ دارید و باید روی آن پردازش انجام دهید، می‌توانید آن را به بخش‌های کوچک‌تر تقسیم کرده و هر بخش را به یک goroutine اختصاص دهید تا پردازش موازی انجام شود. در نهایت، با جمع‌آوری خروجی‌ها از طریق channel، نتیجه نهایی ترکیب و آماده می‌شود. این روش برای سناریوهایی مثل پردازش موازی تصاویر، فایل‌های متنی بزرگ یا داده‌های عددی بسیار مناسب است. Web Scraping: الگوی Fan-Out/Fan-In برای پیاده‌سازی عملیات scraping همزمان روی چندین وب‌سایت یا صفحات وب بسیار کاربردی است. به این صورت که چندین goroutine برای استخراج داده از صفحات مختلف راه‌اندازی می‌شوند و هر کدام نتیجه استخراج‌شده را از طریق یک channel بازمی‌گردانند. سپس این نتایج جمع‌آوری و در صورت نیاز پردازش یا ذخیره می‌شوند. این روش هم سرعت scraping را به شدت افزایش می‌دهد و هم مدیریت منابع را آسان می‌کند. محاسبات توزیع‌شده (Distributed Computing): در سناریوهای محاسبات توزیع‌شده می‌توانید با Fan-Out، چندین goroutine ایجاد کنید که هرکدام وظیفه ارسال یک job به node یا ماشین متفاوتی را دارند و پس از دریافت پاسخ (مثلاً از طریق RPC یا REST)، نتیجه را از طریق channel ارسال می‌کنند. سپس goroutine اصلی تمام نتایج را جمع‌آوری و به صورت ترکیبی یا aggregate پردازش می‌کند. این مدل برای اجرای موازی taskها در خوشه‌های محاسباتی یا توزیع workload در زیرساخت distributed بسیار مناسب است. مدیریت شبکه و اتصالات همزمان: با استفاده از Fan-Out می‌توان برای مدیریت چندین کانکشن ورودی (مثلاً در سرورهای TCP یا HTTP) برای هر کانکشن یک goroutine راه‌اندازی کرد. هر goroutine پردازش مربوط به کانکشن خود را انجام می‌دهد و نتیجه را به channel ارسال می‌کند. سپس در مرحله Fan-In، نتایج تمام کانکشن‌ها جمع‌آوری، ترکیب و بر اساس نیاز پردازش نهایی یا پاسخ به کلاینت انجام می‌شود. این معماری به سادگی مقیاس‌پذیر و مناسب برای سرورهای real-time یا سیستم‌های event-driven است. "},{"id":205,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-wait-for-task/","title":"9.4.3 الگو Wait For Task","section":"9.4 الگوهای همزمانی","content":" 9.4.3.1 توضیحات # الگوی Wait For Task یکی از ساده‌ترین و در عین حال پراستفاده‌ترین الگوهای همزمانی در Go است که برای منتظر ماندن تا اتمام یک فرآیند یا تسک معین کاربرد دارد. در این الگو معمولاً یک goroutine برای انجام کاری خاص راه‌اندازی می‌شود و پس از اتمام، از طریق یک channel به goroutine اصلی سیگنال پایان کار یا حتی داده‌ی تولیدشده را منتقل می‌کند. این روش به شما امکان می‌دهد همزمان چند کار مستقل را اجرا کنید و به صورت مجزا منتظر پایان هرکدام باشید، یا دقیقاً در لحظه‌ای مشخص بدانید یک تسک خاص تمام شده است و می‌توانید ادامه برنامه را اجرا کنید.\nدر رایج‌ترین شکل این الگو، یک کانال (معمولاً از نوع chan struct{} یا یک کانال بافر نشده) ایجاد می‌شود تا فقط نقش ارسال سیگنال (بدون دیتا) را بازی کند. برای مثال، یک goroutine عملیات طولانی یا I/O را انجام می‌دهد و پس از اتمام، با ارسال یک مقدار خالی (مثلاً done \u0026lt;- struct{}{}) به channel، پایان کار را اطلاع می‌دهد؛ main goroutine نیز با دریافت از channel (\u0026lt;-done) منتظر می‌ماند تا کار کامل شود. اگر علاوه بر سیگنال، نیاز به انتقال داده نیز باشد، می‌توان کانال را از نوع داده‌ی مورد انتظار ساخت تا خروجی همزمان با سیگنال ارسال شود.\nکاربرد این الگو بسیار وسیع است؛ مثلاً در انجام یک کار زمان‌بر و اطلاع به UI یا سیستم دیگر، هماهنگی بین تسک‌های موازی، یا مدیریت صحیح پایان عملیات‌های async. همچنین اگر بخواهید چندین تسک موازی را اجرا کنید و منتظر اتمام همه آن‌ها بمانید، می‌توانید برای هر تسک یک channel جدا بسازید یا از sync.WaitGroup استفاده کنید (الگویی ترکیبی از Wait For Task و WaitGroup). این شیوه نه تنها باعث خوانایی و سادگی کنترل جریان برنامه می‌شود، بلکه از مشکلات رایج همزمانی (مانند race condition) نیز جلوگیری می‌کند و در عمل، ابزاری سریع و idiomatic برای سینک کردن تسک‌ها در Go به شمار می‌رود.\nدر نهایت، ترکیب این الگو با ساختارهای دیگر (مانند context یا select) امکان مدیریت پیشرفته‌تر، پیاده‌سازی تایم‌اوت، کنسل کردن عملیات و حتی مدیریت خطا را به سادگی فراهم می‌کند. این ویژگی‌ها سبب شده الگوی Wait For Task تقریباً در تمام پروژه‌های تولیدی Go، از پردازش ساده تا سیستم‌های توزیع‌شده، به شکل گسترده‌ای استفاده شود.\n9.4.3.2 دیاگرام # sequenceDiagram participant Main as Main Goroutine participant Task as Task Goroutine participant Chan as Done Channel Main-\u003e\u003eTask: راه‌اندازی goroutine برای اجرای تسک Task-\u003e\u003eTask: انجام عملیات (مثلاً: I/O یا پردازش) Task-\u003e\u003eChan: ارسال سیگنال پایان (done) Main-\u003e\u003eChan: منتظر دریافت سیگنال پایان Chan--\u003e\u003eMain: دریافت سیگنال و ادامه اجرای برنامه 9.4.3.3 نمونه کد # 1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;time\u0026#34; 6) 7 8// تعریف ساختار نتیجه کار 9type TaskResult struct { 10\tData string 11\tErr error 12} 13 14func main() { 15\tdone := make(chan TaskResult) 16\tgo task(done) 17 18\tresult := \u0026lt;-done 19 20\tif result.Err != nil { 21\tfmt.Println(\u0026#34;Task failed:\u0026#34;, result.Err) 22\treturn 23\t} 24\tfmt.Println(\u0026#34;Task complete!\u0026#34;) 25\tfmt.Println(\u0026#34;Result:\u0026#34;, result.Data) 26} 27 28func task(done chan\u0026lt;- TaskResult) { 29\tfmt.Println(\u0026#34;Task started...\u0026#34;) 30\ttime.Sleep(2 * time.Second) // شبیه‌سازی کار زمان‌بر 31 32\t// شبیه‌سازی موفقیت/خطا 33\tif time.Now().Unix()%2 == 0 { 34\tdone \u0026lt;- TaskResult{ 35\tData: \u0026#34;Some useful data\u0026#34;, 36\tErr: nil, 37\t} 38\t} else { 39\tdone \u0026lt;- TaskResult{ 40\tData: \u0026#34;\u0026#34;, 41\tErr: fmt.Errorf(\u0026#34;خطا در اجرای تسک\u0026#34;), 42\t} 43\t} 44} 1$ go run main.go 2Task started... 3Task complete! 4Result: Some useful data در این مثال بهبود‌یافته، یک پیاده‌سازی حرفه‌ای و واقعی‌تر از الگوی Wait For Task در Go را مشاهده می‌کنید. هدف این است که هم‌زمانی، انتقال نتیجه یا خطا، و مدیریت کامل جریان کار به ساده‌ترین و امن‌ترین شکل انجام شود. ابتدا در تابع main یک کانال از نوع TaskResult ایجاد شده که این ساختار می‌تواند هم داده خروجی (در صورت نیاز) و هم خطا را در خود نگه دارد. سپس با اجرای goroutine تابع task، عملیات به صورت موازی شروع می‌شود و در این مدت، main منتظر می‌ماند تا نتیجه‌ای از کانال دریافت کند.\nدر تابع task ابتدا پیامی برای شروع کار چاپ می‌شود و سپس با دستور time.Sleep(2 * time.Second)، انجام یک کار زمان‌بر شبیه‌سازی می‌گردد. پس از آن، با یک شرط ساده، گاهی نتیجه موفقیت‌آمیز با داده خروجی و گاهی هم یک خطا به کانال ارسال می‌شود. این رویکرد نشان می‌دهد که چطور در سناریوهای واقعی، هم نتیجه و هم خطا را می‌توان به راحتی از طریق کانال به goroutine اصلی منتقل کرد تا کنترل کاملی روی مدیریت جریان و واکنش به خطاها داشت.\nدر بخش جمع‌آوری نتیجه، main با دریافت مقدار از کانال، ابتدا بررسی می‌کند که آیا خطایی رخ داده یا خیر؛ اگر خطا وجود داشته باشد، پیام مناسب چاپ شده و اجرای برنامه خاتمه می‌یابد. در غیر این صورت، پیام موفقیت و داده خروجی نمایش داده می‌شود. این ساختار باعث می‌شود کد همزمان کاملاً idiomatic، قابل گسترش و مناسب استفاده در پروژه‌های جدی باشد، چرا که به سادگی می‌توان مدیریت خطا، پردازش نتیجه و سینک شدن با کارهای async را با امنیت و شفافیت کامل انجام داد. این الگو پایه‌ای برای بسیاری از نیازهای تولیدی، مخصوصاً در هماهنگی و کنترل جریان بین goroutineها محسوب می‌شود.\n9.4.3.4 کاربردها # پردازش موازی حجم بالای داده‌ها: این الگو برای زمانی مناسب است که نیاز دارید حجم زیادی از داده‌ها را به بخش‌های کوچک‌تر تقسیم کرده و هر بخش را با یک goroutine مجزا به صورت موازی پردازش کنید. با استفاده از کانال و مکانیزم انتظار (wait)، می‌توانید تا اتمام کامل همه goroutineها منتظر بمانید و سپس مرحله بعدی برنامه را آغاز کنید. این روش، بهره‌وری پردازش را به شدت افزایش می‌دهد و زمان کل عملیات را کاهش می‌دهد. برقراری چندین درخواست API به صورت همزمان: هنگام کار با سرویس‌های خارجی یا معماری‌های میکروسرویس، ممکن است نیاز باشد چندین تماس API را همزمان برقرار کنید و نتایج آن‌ها را جمع‌آوری نمایید. با الگوی Wait For Task می‌توانید هر درخواست را در یک goroutine ارسال کنید و سپس با جمع‌آوری سیگنال یا داده از کانال‌ها، فقط پس از دریافت همه پاسخ‌ها ادامه دهید؛ این کار latency سیستم را کاهش می‌دهد و تجربه کاربری بهتری فراهم می‌کند. مدیریت ورودی کاربر به صورت غیرمسدودکننده: اگر بخواهید برنامه شما همچنان اجرا شود و در پس‌زمینه منتظر دریافت ورودی از کاربر باشید، می‌توانید یک goroutine مخصوص برای دریافت ورودی کاربر ایجاد کنید و پس از دریافت ورودی، سیگنالی از طریق کانال ارسال کنید. این الگو موجب می‌شود برنامه اصلی بلاک نشود و بتواند همزمان کارهای دیگری انجام دهد تا زمانی که ورودی کاربر فراهم شود. منتظر آماده‌سازی منابع حیاتی: گاهی قبل از اجرای منطق اصلی برنامه نیاز است مطمئن شوید منابعی مثل اتصال پایگاه داده، باز شدن فایل یا ارتباط با سرویس خاصی برقرار شده است. با راه‌اندازی یک goroutine برای آماده‌سازی این منابع و ارسال سیگنال پس از آماده شدن، می‌توانید با اطمینان و همزمانی صحیح، اجرای برنامه را کنترل کنید و فقط در زمان آماده بودن منبع به مرحله بعد بروید. مدیریت انجام کارهای پس‌زمینه: می‌توانید از این الگو برای اجرای یک عملیات در پس‌زمینه (مثلاً جمع‌آوری لاگ، بروزرسانی کش یا هر کار زمان‌بری که مستقیم به کاربر نمایش داده نمی‌شود) استفاده کنید و پیش از شروع مراحل بعدی یا خاموش شدن برنامه، مطمئن شوید این تسک به پایان رسیده است. این کار به شما کنترل کامل بر هماهنگی بخش‌های مختلف سیستم می‌دهد. "},{"id":206,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-worker-pool/","title":"9.4.4 الگوی Worker Pool","section":"9.4 الگوهای همزمانی","content":" 9.4.4.1 توضیحات # الگوی Worker Pool یکی از مهم‌ترین الگوهای همزمانی در Go محسوب می‌شود و زمانی به‌کار می‌رود که بخواهید تعداد مشخصی goroutine (معمولاً با نقش کارگر یا worker) داشته باشید که وظایف مختلف را به صورت صف (queue) دریافت و اجرا کنند. این کار باعث کنترل بهتر منابع، جلوگیری از ایجاد goroutine بیش از حد (که ممکن است باعث مصرف بی‌رویه CPU و memory یا حتی crash برنامه شود) و مدیریت صف کارها در سیستم‌های real-world و پرلود می‌شود. در این الگو، یک یا چند کانال برای ارسال وظایف (task queue) و دریافت نتایج بین goroutineهای تولیدکننده (producer) و goroutineهای worker (مصرف‌کننده) استفاده می‌شود.\nمثلاً در یک سیستم وب یا پردازش موازی داده، می‌توانید یک کانال برای صف کردن درخواست‌ها ایجاد کنید و چند goroutine به عنوان worker راه‌اندازی کنید تا هرکدام از این صف وظیفه برداشته و پردازش کنند. پس از اتمام کار، نتیجه را می‌توانند در یک کانال نتایج (result channel) قرار دهند تا main goroutine یا یک جمع‌کننده (collector) نتایج را جمع‌آوری کند. این معماری، بهترین شیوه برای مدیریت connection pool دیتابیس، پردازش موازی queueها، انجام وظایف تکراری (مثل scraping، پردازش تصاویر یا فایل‌ها) و افزایش مقیاس‌پذیری است.\nدر مجموع، Worker Pool با جلوگیری از ایجاد تعداد زیاد goroutine، افزایش کنترل بر مصرف منابع، افزایش throughput و جلوگیری از bottleneck شدن سیستم، یکی از حرفه‌ای‌ترین الگوهای تولیدی در Go محسوب می‌شود. استفاده هوشمندانه از کانال‌ها برای توزیع و جمع‌آوری وظایف و نتایج، کدنویسی را هم ساده‌تر و هم کاملاً idiomatic می‌کند.\n9.4.4.2 دیاگرام # flowchart LR subgraph Producer A1[Job Queuejob_0, job_1, ..., job_N] end subgraph WorkerPool direction TB W0[Worker 0job_0] W1[Worker 1job_1] WD[...] Wn[Worker Njob_N] end subgraph Collector B1[Result Queueres_0, res_1, ..., res_N] end A1 -- \"job_0\" --\u003e W0 A1 -- \"job_1\" --\u003e W1 A1 -- \"job_i ...\" --\u003e WD A1 -- \"job_N\" --\u003e Wn W0 -- \"res_0\" --\u003e B1 W1 -- \"res_1\" --\u003e B1 WD -- \"...\" --\u003e B1 Wn -- \"res_N\" --\u003e B1 MGR((Manager)) MGR --- WorkerPool classDef worker fill:#e3ffe3,stroke:#6bc76b,stroke-width:2px; classDef queue fill:#f2f6fa,stroke:#4c78a8,stroke-width:2px; classDef mgr fill:#ffe9c6,stroke:#a58954,stroke-width:2px; class W0,W1,WD,Wn worker; class A1,B1 queue; class MGR mgr; 9.4.4.3 نمونه کد # 1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;sync\u0026#34; 6) 7 8// ساختار نتیجه خروجی هر کارگر 9type JobResult struct { 10\tJobID int 11\tInput int 12\tOutput int 13\tWorkerID int 14\tErr error 15} 16 17func main() { 18\tconst ( 19\tnumJobs = 5 20\tnumWorkers = 3 21\t) 22 23\tjobs := make(chan int, numJobs) 24\tresults := make(chan JobResult, numJobs) 25 26\tvar wg sync.WaitGroup 27 28\t// راه‌اندازی worker pool 29\tfor w := 1; w \u0026lt;= numWorkers; w++ { 30\twg.Add(1) 31\tgo worker(w, jobs, results, \u0026amp;wg) 32\t} 33 34\t// ارسال jobها 35\tfor j := 1; j \u0026lt;= numJobs; j++ { 36\tjobs \u0026lt;- j 37\t} 38\tclose(jobs) 39 40\t// انتظار برای اتمام همه workerها و سپس بستن کانال نتایج 41\tgo func() { 42\twg.Wait() 43\tclose(results) 44\t}() 45 46\t// جمع‌آوری و پردازش نتایج 47\tfor result := range results { 48\tif result.Err != nil { 49\tfmt.Printf(\u0026#34;[Job %d] خطا در Worker %d: %v\\n\u0026#34;, result.JobID, result.WorkerID, result.Err) 50\tcontinue 51\t} 52\tfmt.Printf(\u0026#34;[Job %d] Worker %d → input: %d, output: %d\\n\u0026#34;, 53\tresult.JobID, result.WorkerID, result.Input, result.Output) 54\t} 55} 56 57// Worker function 58func worker(id int, jobs \u0026lt;-chan int, results chan\u0026lt;- JobResult, wg *sync.WaitGroup) { 59\tdefer wg.Done() 60\tfor input := range jobs { 61\t// شبیه‌سازی کار و احتمال خطا 62\tvar output int 63\tvar err error 64\tif input == 3 { 65\terr = fmt.Errorf(\u0026#34;مشکل در پردازش داده\u0026#34;) 66\t} else { 67\toutput = input * 2 68\t} 69 70\tresult := JobResult{ 71\tJobID: input, 72\tInput: input, 73\tOutput: output, 74\tWorkerID: id, 75\tErr: err, 76\t} 77\tresults \u0026lt;- result 78\t} 79} 1$ go run main.go 2[Job 1] Worker 3 → input: 1, output: 2 3[Job 2] Worker 3 → input: 2, output: 4 4[Job 4] Worker 2 → input: 4, output: 8 5[Job 5] Worker 2 → input: 5, output: 10 6[Job 3] خطا در Worker 3: مشکل در پردازش داده در این مثال از Worker Pool، سعی شده معماری‌ای تولید شود که هم خوانایی و توسعه‌پذیری بالایی داشته باشد و هم از نظر اطمینان و مدیریت منابع کاملاً production-ready باشد. در ابتدای برنامه، تعداد jobها و workerها به صورت ثابت تعیین شده و دو کانال برای مدیریت ارسال کارها (jobs) و جمع‌آوری نتایج (results) تعریف شده است. با استفاده از یک حلقه، به تعداد workerها goroutine اجرا می‌شود؛ هرکدام با استفاده از یک اشاره‌گر به sync.WaitGroup، اتمام کار خود را اعلام می‌کنند. این باعث می‌شود که بدانیم دقیقاً چه زمانی همه کارگرها کارشان را به اتمام رسانده‌اند.\nبرای هر job که وارد صف می‌شود، اطلاعات آن در کانال jobs قرار می‌گیرد و پس از ارسال تمام jobها، کانال بسته می‌شود تا workerها پس از اتمام کار بتوانند از حلقه خارج شوند. پس از اتمام همه goroutineها (به کمک WaitGroup)، یک goroutine کمکی کانال results را می‌بندد تا حلقه جمع‌آوری نتایج نیز بدون مشکل به پایان برسد. خروجی هر کار به صورت یک ساختار JobResult است که هم شناسه job، هم ورودی و خروجی، هم شماره worker و هم خطای احتمالی را شامل می‌شود. این ساختار هم امکان لاگ‌گیری دقیق، هم مدیریت خطا و هم تحلیل بعدی را به سادگی ممکن می‌کند.\nدر این مثال، برای یکی از jobها به صورت شبیه‌سازی‌شده یک خطا تولید می‌شود تا نشان داده شود چگونه مدیریت خطا باید به صورت ایمن و جداگانه برای هر job انجام گیرد. در حلقه دریافت نتایج، ابتدا خطا بررسی می‌شود و در صورت وجود خطا، پیام مناسب نمایش داده می‌شود؛ در غیر این صورت، ورودی، خروجی و شماره worker برای هر job به صورت فرمت‌بندی‌شده چاپ می‌گردد. این رویکرد علاوه بر رعایت idiomatic بودن کد Go، کنترل کاملی روی منابع و وضعیت اجرایی همه بخش‌ها ایجاد می‌کند و پایه‌ای ایده‌آل برای پروژه‌های واقعی و مقیاس‌پذیر محسوب می‌شود.\nدر نهایت، این معماری به راحتی قابل گسترش برای jobهای پیچیده‌تر، مدیریت صف‌های بزرگ‌تر یا حتی پیاده‌سازی با context و timeout است و از بروز مشکلات رایج مانند goroutine leak یا deadlock جلوگیری می‌کند.\n9.4.4.4 کاربردها # تقسیم کارهای پردازشی (Parallel Data Processing): با استفاده از الگوی Worker Pool می‌توانید حجم زیادی از داده‌ها یا کارهای محاسباتی سنگین را به بخش‌های کوچک‌تر تقسیم کنید و به طور موازی بین چندین goroutine کارگر توزیع نمایید. این رویکرد علاوه بر افزایش سرعت پردازش، باعث استفاده بهینه‌تر از منابع سیستم (CPU و حافظه) می‌شود و از ایجاد goroutineهای بیش از حد یا سربار اضافی جلوگیری می‌کند. در نتیجه، سربار مدیریت همزمانی کاهش یافته و عملکرد نهایی سیستم به طور قابل ملاحظه‌ای بهبود می‌یابد. مدیریت و محدودسازی منابع (Resource Management \u0026amp; Limiting): Worker Pool به شما امکان می‌دهد تعداد ثابتی goroutine برای انجام کارها داشته باشید و از مصرف بیش از حد منابع سیستم، مانند اتصال به دیتابیس یا پردازش همزمان بیش از حد، جلوگیری کنید. این کار برای کنترل بار روی سرویس‌های خارجی (مانند دیتابیس، API یا حتی سخت‌افزار) حیاتی است و جلوی شکست یا کندی سیستم را می‌گیرد. اجرای موازی درخواست‌های خارجی (Parallel External Requests): این الگو برای ارسال همزمان تعداد زیادی درخواست به سرویس‌های خارجی (مانند APIهای وب، ذخیره‌سازی ابری یا دانلود فایل‌ها) بسیار کاربردی است. Worker Pool با محدودسازی تعداد کارگرها، امکان ارسال کنترل‌شده و پایدار درخواست‌ها را فراهم می‌کند. پذیرش و پردازش صف کارها (Job Queue Processing): در معماری‌های صف محور (مانند پردازش پیام یا وظایف پس‌زمینه)، Worker Pool به شما اجازه می‌دهد کارها را از صف بخوانید و توسط کارگرها به شکل کنترل‌شده و موازی اجرا کنید. این الگو پایه بسیاری از سیستم‌های background task، notification و microservice است. پردازش تصاویر، فایل‌ها و داده‌های بزرگ: Worker Pool برای سیستم‌هایی که باید تعداد زیادی تصویر یا فایل را به طور موازی پردازش کنند (مثلاً تغییر سایز عکس، رمزنگاری فایل یا پردازش ویدئو)، ایده‌آل است و بازدهی را به طرز چشمگیری افزایش می‌دهد. مدیریت کانکشن‌های شبکه یا سرور: در سرورهایی که با تعداد زیادی اتصال همزمان مواجه هستند، Worker Pool می‌تواند برای مدیریت همزمان کانکشن‌ها یا درخواست‌های ورودی، و جلوگیری از overload شدن سیستم، استفاده شود. "},{"id":207,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-drop/","title":"9.4.5 الگو Drop","section":"9.4 الگوهای همزمانی","content":" 9.4.5.1 توضیحات # الگوی Drop یا Drop Overflow یکی از الگوهای حیاتی برای سیستم‌هایی است که ممکن است با موجی از درخواست‌ها روبرو شوند که بیش از ظرفیت واقعی سیستم است. در این الگو، زمانی که صف یا ظرفیت پردازش درخواست‌ها (مثلاً یک کانال یا بافر) پر می‌شود، به جای اینکه سیستم را دچار ازدحام، توقف یا crash کند، به سادگی درخواست‌های اضافی (یا جدیدتر یا قدیمی‌تر، بر اساس سیاست) را حذف (Drop) می‌کند. این کار باعث می‌شود سرویس همواره پایدار و قابل اطمینان باقی بماند و منابع اصلی به خاطر یک سناریوی غیرعادی یا حمله دچار مشکل نشود.\nکاربرد این الگو به‌خصوص در سرویس‌های زیرساختی حیاتی مانند DNS، load balancer، یا حتی سیستم‌های realtime که نمی‌خواهند به هیچ قیمتی دچار backlog و تاخیر بالا شوند، بسیار رایج است. به عنوان مثال، در یک سرور DNS وقتی تعداد درخواست‌ها از ظرفیت کانال یا worker pool بیشتر شود، درخواست‌های جدید بلافاصله drop می‌شوند تا latency پایین بماند و سرور همچنان responsive بماند. این الگو به عنوان بخشی از استراتژی کلی Backpressure نیز به کار می‌رود و برای معماری‌هایی که تحمل \u0026ldquo;از دست رفتن بعضی درخواست‌ها\u0026rdquo; بهتر از \u0026ldquo;کُند شدن یا قطع کامل سرویس\u0026rdquo; است، ایده‌آل محسوب می‌شود.\nدر پیاده‌سازی‌های Go معمولاً یک کانال بافر دار تعریف می‌شود و اگر هنگام ارسال داده به کانال، با پر بودن مواجه شویم (مثلاً با select غیر بلوک‌کننده)، درخواست به راحتی Drop می‌شود و کنترل به سرعت به کد اصلی بازمی‌گردد. این تکنیک ساده، موثر و بسیار idiomatic در پروژه‌های تولیدی Go است و به حفظ کیفیت خدمات و جلوگیری از overload شدن سیستم کمک شایانی می‌کند.\n9.4.5.2 دیاگرام # flowchart LR A[درخواست‌های ورودی] --\u003e|درخواست 1| Q((Channel Queue)) A --\u003e|درخواست 2| Q A --\u003e|درخواست 3| Q A --\u003e|درخواست ...| Q Q -- \"در صورت پر بودن\" --\u003e D[Drop Requestرد شدن درخواست] Q -- \"در صورت ظرفیت داشتن\" --\u003e W[Worker] W --\u003e R[نتیجه/پردازش] style Q fill:#ffe9c6,stroke:#efb64f,stroke-width:2px style D fill:#ffeaea,stroke:#ff5b5b,stroke-width:2px style W fill:#e3ffe3,stroke:#6bc76b,stroke-width:2px style R fill:#e0eaff,stroke:#476ebd,stroke-width:2px 9.4.5.3 نمونه کد # 1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;sync\u0026#34; 6\t\u0026#34;time\u0026#34; 7) 8 9func main() { 10\tconst bufferSize = 3 11\tconst numData = 10 12 13\tin := make(chan int, bufferSize) 14\tout := make(chan int, bufferSize) 15\tvar wg sync.WaitGroup 16 17\t// تولیدکننده: تولید داده با Drop در صورت پر بودن کانال 18\twg.Add(1) 19\tgo func() { 20\tdefer wg.Done() 21\tfor i := 1; i \u0026lt;= numData; i++ { 22\tselect { 23\tcase in \u0026lt;- i: 24\tfmt.Printf(\u0026#34;[Producer] Sent: %d\\n\u0026#34;, i) 25\tdefault: 26\tfmt.Printf(\u0026#34;[Producer] Drop: %d (buffer full)\\n\u0026#34;, i) 27\t} 28\ttime.Sleep(100 * time.Millisecond) 29\t} 30\tclose(in) 31\t}() 32 33\t// مصرف‌کننده: مصرف داده با Drop اگر مصرف‌کننده بعدی نتواند داده را بپذیرد 34\twg.Add(1) 35\tgo func() { 36\tdefer wg.Done() 37\tfor data := range in { 38\tselect { 39\tcase out \u0026lt;- data: 40\tfmt.Printf(\u0026#34;[Consumer] Forwarded: %d\\n\u0026#34;, data) 41\tdefault: 42\tfmt.Printf(\u0026#34;[Consumer] Drop: %d (output buffer full)\\n\u0026#34;, data) 43\t} 44\ttime.Sleep(150 * time.Millisecond) 45\t} 46\tclose(out) 47\t}() 48 49\t// جمع‌آوری خروجی 50\tfor result := range out { 51\tfmt.Printf(\u0026#34;[Result] Received: %d\\n\u0026#34;, result) 52\t} 53 54\twg.Wait() 55} 1$ go run main.go 2[Producer] Sent: 1 3[Result] Received: 1 4[Consumer] Forwarded: 1 5[Producer] Sent: 2 6[Consumer] Forwarded: 2 7[Result] Received: 2 8[Producer] Sent: 3 9[Producer] Sent: 4 10[Consumer] Forwarded: 3 11[Result] Received: 3 12[Producer] Sent: 5 13[Consumer] Forwarded: 4 14[Result] Received: 4 15[Producer] Sent: 6 16[Producer] Sent: 7 17[Consumer] Forwarded: 5 18[Result] Received: 5 19[Producer] Sent: 8 20[Consumer] Forwarded: 6 21[Result] Received: 6 22[Producer] Sent: 9 23[Producer] Drop: 10 (buffer full) 24[Consumer] Forwarded: 7 25[Result] Received: 7 26[Consumer] Forwarded: 8 27[Result] Received: 8 28[Consumer] Forwarded: 9 29[Result] Received: 9 در این مثال از الگوی Drop Overflow، یک سناریوی واقعی‌تر برای مدیریت بار بیش از ظرفیت در سیستم‌های concurrent نمایش داده شده است. ابتدا دو کانال بافر‌دار (یکی برای ورودی و دیگری برای خروجی) تعریف شده‌اند تا شبیه‌ساز صف‌هایی با ظرفیت محدود باشند. یک goroutine به عنوان تولیدکننده، داده‌هایی با مقادیر مختلف (از ۱ تا ۱۰) تولید می‌کند و در تلاش است آن‌ها را وارد کانال ورودی کند. اگر ظرفیت کانال ورودی پر باشد، داده جدید بدون معطلی Drop شده و پیام مناسبی در لاگ چاپ می‌شود؛ این رفتار باعث می‌شود که goroutine تولیدکننده هیچگاه بلاک نشود و سیستم دچار اختلال یا توقف نگردد.\nدر طرف مصرف‌کننده، داده‌ها از کانال ورودی خوانده می‌شوند و تلاش می‌شود به کانال خروجی منتقل شوند. اگر خروجی هم در آن لحظه ظرفیت نداشته باشد (یعنی مصرف‌کننده بعدی نتواند داده را دریافت کند)، داده دوباره Drop شده و این اتفاق نیز در لاگ ثبت می‌شود. به این ترتیب، در هر نقطه‌ای از زنجیره پردازش که ظرفیت کافی وجود نداشته باشد، داده بدون انتظار و سربار اضافه حذف خواهد شد. این رفتار بسیار مهم است، چرا که از تجمع داده‌های غیرقابل پردازش جلوگیری می‌کند و جلوی اشغال بیش از حد حافظه یا منابع را می‌گیرد.\nدر انتهای برنامه، خروجی‌ها از کانال خروجی جمع‌آوری و چاپ می‌شوند تا وضعیت مصرف موفق داده‌ها قابل مشاهده باشد. با کمک sync.WaitGroup اطمینان حاصل شده که تمام goroutineها قبل از پایان برنامه به درستی خاتمه پیدا می‌کنند و هیچ goroutine سرگردان یا leak اتفاق نمی‌افتد. با افزودن تأخیرهای زمانی متفاوت در تولید و مصرف داده‌ها، سناریوهای متفاوتی از فشار و ترافیک شبیه‌سازی شده تا نقاط Drop مختلف به خوبی دیده شوند. این مثال نشان‌دهنده کاربرد عملی و idiomatic این الگو در Go است؛ جایی که Drop شدن بخشی از داده‌ها به جای کندی یا Crash سیستم، انتخابی هوشمندانه و تولیدی محسوب می‌شود، به ویژه در سیستم‌های real-time، سرویس‌های زیرساختی یا سناریوهایی با بار متغیر.\n9.4.5.4 کاربردها # محدودسازی نرخ پردازش (Rate Limiting): زمانی که با حجم بالایی از داده‌های ورودی یا درخواست‌ها سروکار دارید، این الگو به شما کمک می‌کند تا تنها تعداد مشخصی داده را در هر لحظه بپذیرید و باقی داده‌های مازاد را Drop کنید؛ به این ترتیب، نرخ پردازش سیستم ثابت و قابل کنترل باقی می‌ماند و از overload یا کندی سیستم جلوگیری می‌شود. ثبت لاگ و مانیتورینگ (Logging/Monitoring): در سیستم‌های لاگ‌گیری یا مانیتورینگ با حجم بالای رویداد، ممکن است توان نوشتن روی دیسک یا ارسال داده به سرور مرکزی محدود باشد. با پیاده‌سازی Drop Pattern می‌توانید پیام‌های اضافی یا کم‌اهمیت را به سادگی حذف کنید تا ضمن حفظ پایداری سرویس، داده‌های کلیدی با کمترین تأخیر ثبت شوند. مدیریت صف و کنترل ازدحام (Queue Management \u0026amp; Congestion Control): هنگام استفاده از صف‌هایی که توسط کانال‌های بافر‌دار مدیریت می‌شوند، به جای مسدود شدن تولیدکننده یا ایجاد backlog زیاد، می‌توانید در صورت پر شدن صف، داده‌های جدید را Drop کنید. این رفتار به ویژه در سناریوهای با بار متغیر، باعث افزایش پایداری سیستم و کاهش سربار مدیریت صف می‌شود. کنترل ترافیک شبکه و ورودی (Traffic Shaping \u0026amp; Throttling): در سرورها یا سرویس‌هایی که با حجم بالای ترافیک یا درخواست همزمان مواجه می‌شوند (مانند API Gateway یا Load Balancer)، Drop Pattern کمک می‌کند که بخشی از ترافیک ورودی در صورت نبود ظرفیت حذف شود و کیفیت خدمات به کاربران باقی‌مانده حفظ شود. این رویکرد، راهکاری مؤثر برای جلوگیری از حملات DoS یا اسپایک‌های ناگهانی است. سیستم‌های بلادرنگ و حساس به تأخیر (Real-time \u0026amp; Low Latency Systems): در سیستم‌های real-time مانند سیستم‌های پردازش صدا، تصویر، یا تحلیل لحظه‌ای داده‌های حسگرها، معمولاً داده‌ها باید در بازه زمانی مشخص پردازش شوند. در صورت پر بودن بافر یا عدم توان مصرف داده، داده‌های جدید Drop می‌شوند تا latency پایین و پاسخ‌دهی سریع سیستم حفظ شود. سرویس‌های زیرساختی حیاتی (مانند DNS و پیام‌رسان‌ها): در زیرساخت‌هایی مثل DNS، صف‌های کاری باید کوتاه و پاسخ‌دهی سریع باشد. اگر صف پر شود، درخواست‌های جدید به سرعت Drop می‌شوند تا سرویس‌دهی پایدار باقی بماند و سیستم دچار اشباع یا توقف نشود. "},{"id":208,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-cancellation/","title":"9.4.6 الگو Context Cancellation Pattern","section":"9.4 الگوهای همزمانی","content":" 9.4.6.1 توضیحات # الگوی Cancellation یا Context Cancellation Pattern یکی از تکنیک‌های کلیدی در Go برای کنترل lifecycle goroutineها و جلوگیری از اجرای ناخواسته یا بی‌پایان آن‌هاست. هدف اصلی این الگو، ارسال سیگنال توقف به goroutineهایی است که به هر دلیلی باید عملیات خود را زودتر از موعد قطع کنند؛ مثلاً کاربر درخواست کنسل می‌دهد، تایم‌اوت رخ می‌دهد یا رویداد خاصی در سیستم اتفاق می‌افتد.\nدر معماری idiomatic Go، برای پیاده‌سازی لغو عملیات، به‌جای بستن کانال‌های اختصاصی، از context.Context استفاده می‌شود که یک سازوکار استاندارد، ساده و thread-safe برای انتشار سیگنال لغو (cancelation) و همچنین مدیریت تایم‌اوت‌ها و مقادیر مرتبط است. معمولاً یک context اصلی با دستور context.WithCancel یا context.WithTimeout ساخته می‌شود و این context به تمامی goroutineها و تابع‌های فرزند پاس داده می‌شود. هر goroutine به طور دوره‌ای وضعیت context را بررسی می‌کند (با \u0026lt;-ctx.Done() یا ctx.Err()) و اگر سیگنال لغو صادر شده باشد، عملیات خود را متوقف می‌کند و منابع را آزاد می‌سازد.\nاستفاده از context علاوه بر خوانایی و سادگی، از مشکلات رایج مانند goroutine leak، deadlock یا بستن اشتباهی کانال‌ها جلوگیری می‌کند و مدیریت همزمانی را ایمن‌تر می‌سازد. در پروژه‌های تولیدی Go، این الگو به عنوان استاندارد طلایی لغو عملیات (چه برای لغو دستی، چه Timeout و چه Propagation سیگنال لغو در عمق کال‌استک) توصیه می‌شود.\n9.4.6.2 دیاگرام # sequenceDiagram participant Main as Main Goroutine participant Ctx as Context (WithCancel/WithTimeout) participant Worker1 as Worker Goroutine 1 participant Worker2 as Worker Goroutine 2 Main-\u003e\u003eCtx: ساخت context با WithCancel یا WithTimeout Main-\u003e\u003eWorker1: ارسال context Main-\u003e\u003eWorker2: ارسال context Note over Worker1, Worker2: انجام عملیات و بررسی\n\u003c-ctx.Done() Main-\u003e\u003eCtx: فراخوانی cancel (یا رخداد timeout) Ctx--\u003e\u003eWorker1: ارسال سیگنال لغو Ctx--\u003e\u003eWorker2: ارسال سیگنال لغو Worker1-\u003e\u003eMain: آزاد کردن منابع و پایان Worker2-\u003e\u003eMain: آزاد کردن منابع و پایان 9.4.6.3 نمونه کد # 1package main 2 3import ( 4\t\u0026#34;context\u0026#34; 5\t\u0026#34;fmt\u0026#34; 6\t\u0026#34;time\u0026#34; 7) 8 9func main() { 10\t// ساخت context قابل لغو 11\tctx, cancel := context.WithCancel(context.Background()) 12 13\t// اجرای goroutine با بررسی لغو 14\tgo func(ctx context.Context) { 15\tfor { 16\tselect { 17\tcase \u0026lt;-ctx.Done(): 18\tfmt.Println(\u0026#34;Cancelled:\u0026#34;, ctx.Err()) 19\treturn 20\tdefault: 21\tfmt.Println(\u0026#34;Running\u0026#34;) 22\ttime.Sleep(time.Second) 23\t} 24\t} 25\t}(ctx) 26 27\t// اجرای goroutine برای ۳ ثانیه 28\ttime.Sleep(3 * time.Second) 29 30\t// فراخوانی لغو 31\tcancel() 32 33\t// انتظار برای خاتمه goroutine 34\ttime.Sleep(time.Second) 35} 1$ go run main.go 2Running 3Running 4Running 5Running 6Cancelled: context canceled در کد فوق ما یک کانال از نوع ساختار ایجاد کردیم با عنوان cancel و این کانال را داخل یکی از case های select بصورت دریافت قرار دادیم که در ادامه ما یک Sleep ۳ گذاشتیم تا فرآیند انجام شود و Running چاپ شود. پس از آن کانال را close کردیم و سیگنال لغو فرآیند ارسال شد و گوروتین کاملا متوقف شد.\n9.4.6.4 کاربردها # لغو یک کار طولانی‌مدت: عملکردی که عملیات زمان‌بر مانند درخواست شبکه یا محاسبات را انجام می‌دهد، اگر دیگر به آن نیاز نباشد یا از مهلت زمانی فراتر رود، می‌توان آن را لغو کرد. پاکسازی منابع: تابعی که منابعی مانند فایل یا اتصال شبکه را تخصیص می دهد، می تواند لغو شود تا این منابع قبل از اینکه دیگر مورد نیاز نباشند آزاد شوند. خاتمه دادن به یک سرور: سروری که چندین درخواست را مدیریت می‌کند، می‌تواند با لغو تمام عملکردهای در حال اجرا که این درخواست‌ها را انجام می‌دهند، به‌خوبی خاموش شود. لغو یک کار پس زمینه: یک کار پس زمینه که همزمان با برنامه اصلی اجرا می شود را می توان لغو کرد تا از اجرای آن جلوگیری شود. "},{"id":209,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-semaphore/","title":"9.4.7 الگو Semaphore","section":"9.4 الگوهای همزمانی","content":" 9.4.7.1 توضیحات # الگوی Semaphore (سمیفور) یکی از مفاهیم کلیدی در دنیای همزمانی (Concurrency) است و نقش آن مدیریت کنترل دسترسی به منابع محدود (مانند فایل، شبکه، دیتابیس و…) در یک زمان است. این الگو مخصوصاً زمانی کاربرد دارد که چندین goroutine یا درخواست به طور همزمان قصد استفاده از یک منبع یا سرویس را دارند، اما تنها تعداد محدودی مجاز به استفاده همزمان از آن هستند. پیاده‌سازی این الگو در Go بسیار ساده و idiomatic است و معمولاً از کانال بافر دار (buffered channel) به عنوان سمیفور استفاده می‌شود.\nفرض کنید سرور شما قرار است همزمان به ۱۰۰ درخواست HTTP پاسخ دهد؛ اگر همه این درخواست‌ها به طور موازی و بدون کنترل وارد مرحله پردازش شوند، مصرف منابع شبکه (یا سایر منابع اشتراکی) افزایش یافته و به سرعت به نقطه بحرانی می‌رسد که عملکرد سیستم به شدت کاهش پیدا می‌کند و حتی ممکن است به خطا یا اختلال بیانجامد. با استفاده از الگوی سمیفور، می‌توانید تعداد goroutineهای فعال و مشغول به پردازش همزمان را به عددی مشخص (مثلاً ۲۰ یا ۵۰) محدود کنید. این کار موجب می‌شود که منابع با ثبات بیشتری مورد استفاده قرار گیرند و بار اضافی و سربار مدیریت سیستم کاهش یابد.\nدر پیاده‌سازی این الگو در Go، یک کانال بافر دار (مثلاً make(chan struct{}, 20)) به عنوان سمیفور تعریف می‌شود. هر goroutine قبل از شروع پردازش، یک مقدار (مثلاً struct{} یا هر مقدار دلخواه) در کانال قرار می‌دهد. اگر کانال پر باشد، goroutine جدید بلاک می‌شود تا زمانی که جای خالی ایجاد شود. پس از پایان کار، goroutine مقدار خود را از کانال خارج می‌کند تا اجازه فعالیت به goroutine دیگری داده شود. این تکنیک همزمانی ایمن و کنترل‌شده را فراهم می‌کند و به راحتی قابل توسعه و مقیاس‌پذیر است.\nسمیفور برای سناریوهای دیگری مانند مدیریت همزمان دسترسی به پایگاه داده، خواندن/نوشتن فایل‌ها، کنترل اجرای Taskهای سنگین و حتی مدیریت connection poolها نیز استفاده می‌شود و یکی از مهم‌ترین ابزارهای جلوگیری از overload شدن سیستم و حفظ پایداری نرم‌افزارهای concurrent است. استفاده از کانال بافر دار به عنوان سمیفور، یک راه حل idiomatic و ساده برای پیاده‌سازی این کنترل در زبان Go محسوب می‌شود و اغلب در کدهای تولیدی مشاهده می‌شود.\nبه نقل از ویکی پدیا :\nدر علم رایانه نشانبر یا سمافور (به انگلیسی: Semaphore) به متغیری گفته می‌شود که در محیط‌های همروند برای کنترل دسترسی فرایندها به منابع مشترک به کار می‌رود. سمافور می‌تواند به دو صورت دودویی (که تنها دو مقدار صحیح و غلط را دارا است) یا شمارنده اعداد صحیح باشد. از سمافور برای جلوگیری از ایجاد وضعیت رقابتی میان فرایندها استفاده می‌گردد. به این ترتیب، اطمینان حاصل می‌شود که در هر لحظه تنها یک فرایند به منبع مشترک دسترسی دارد و می‌تواند از آن بخواند یا بنویسد (انحصار متقابل)\nسمافورها اولین بار به‌وسیلهٔ دانشمند علوم رایانه هلندی، ادسخر دیکسترا معرفی شدند.[۱] و امروزه به‌طور گسترده‌ای در سیستم عاملها مورد استفاده قرار می‌گیرند.\n9.4.7.2 دیاگرام # 9.4.7.3 نمونه کد # 1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;sync\u0026#34; 6\t\u0026#34;time\u0026#34; 7) 8 9// Interface optional, usually direct struct is enough 10type Semaphore struct { 11\tsemCh chan struct{} 12} 13 14func NewSemaphore(maxConcurrency int) *Semaphore { 15\treturn \u0026amp;Semaphore{ 16\tsemCh: make(chan struct{}, maxConcurrency), 17\t} 18} 19 20func (s *Semaphore) Acquire() { 21\ts.semCh \u0026lt;- struct{}{} 22} 23 24func (s *Semaphore) Release() { 25\t\u0026lt;-s.semCh 26} 27 28func main() { 29\tmaxConcurrent := 3 30\ttotProcess := 10 31 32\tsem := NewSemaphore(maxConcurrent) 33\tvar wg sync.WaitGroup 34 35\tfor i := 1; i \u0026lt;= totProcess; i++ { 36\twg.Add(1) 37\tsem.Acquire() 38\tgo func(taskID int) { 39\tdefer wg.Done() 40\tdefer sem.Release() 41\tlongRunningProcess(taskID) 42\t}(i) 43\t} 44 45\twg.Wait() 46\tfmt.Println(\u0026#34;All tasks finished!\u0026#34;) 47} 48 49func longRunningProcess(taskID int) { 50\tfmt.Println(time.Now().Format(\u0026#34;15:04:05\u0026#34;), \u0026#34;Running task\u0026#34;, taskID) 51\ttime.Sleep(2 * time.Second) 52} 1$ go run main.go 223:00:00 Running task 3 323:00:00 Running task 1 423:00:00 Running task 2 523:00:02 Running task 4 623:00:02 Running task 5 723:00:02 Running task 6 823:00:04 Running task 7 923:00:04 Running task 9 1023:00:04 Running task 8 1123:00:06 Running task 10 12All tasks finished! در این نسخه بهبود یافته از الگوی Semaphore، هدف کنترل تعداد goroutineهای همزمان و اطمینان از اجرای کامل تمام وظایف (tasks) بدون هیچ‌گونه race condition یا مشکل همزمانی است. در ابتدا با ساخت یک struct ساده به نام Semaphore و تعریف یک کانال بافر دار به اندازه‌ی تعداد مجاز عملیات همزمان (در اینجا ۳)، یک Semaphore سبک اما مؤثر ساخته می‌شود. هر زمان که یک goroutine می‌خواهد اجرا شود، ابتدا باید یک اسلات در این کانال اشغال کند (Acquire). اگر ظرفیت کانال پر باشد، goroutine تا آزاد شدن یک اسلات جدید منتظر می‌ماند. پس از پایان کار، با دستور Release اسلات آزاد می‌شود تا goroutine بعدی بتواند اجرا شود.\nدر تابع main یک حلقه وظیفه راه‌اندازی ۱۰ goroutine را دارد، ولی با کمک Semaphore فقط ۳ کار همزمان می‌توانند در هر لحظه فعال باشند. برای اطمینان از اینکه تمام goroutineها به‌درستی اجرا و پایان یافته‌اند، از sync.WaitGroup استفاده شده است: قبل از راه‌اندازی هر goroutine مقدار WaitGroup افزایش و پس از اتمام آن کاهش می‌یابد. در انتها با دستور wg.Wait() مطمئن می‌شویم که برنامه فقط پس از اتمام همه کارها به پایان می‌رسد. این مکانیزم از خروج زودهنگام main یا رخ دادن goroutine leak جلوگیری می‌کند.\nهر goroutine یک تابع شبیه‌ساز کار سنگین (longRunningProcess) را با شناسه‌ی خود اجرا می‌کند که خروجی اجرای task و زمان شروع آن را در لاگ چاپ می‌کند و با یک توقف (sleep) دو ثانیه‌ای، بار واقعی‌تری ایجاد می‌نماید. این پیاده‌سازی تضمین می‌کند که همزمانی به‌شکلی کنترل‌شده انجام شود، تعداد goroutineها بیش از حد نشود و سرور یا سیستم هیچ‌گاه overloaded نشود. همین الگو در بسیاری از سناریوهای واقعی مثل دانلود فایل، فراخوانی APIهای موازی، پردازش صف داده و مدیریت connection pool استفاده می‌شود و پایه‌ی معماری بسیاری از سرویس‌های مقیاس‌پذیر است.\nهمچنین این روش idiomatic Go است و برای توسعه در پروژه‌های تولیدی کاملاً توصیه می‌شود.\n9.4.7.4 کاربردها # مدیریت دسترسی به منابع مشترک (Shared Resource Management): سمیفور برای محدود کردن تعداد goroutineهایی که همزمان به یک منبع مشترک (مانند فایل، دیتابیس، یا یک سرویس خارجی) دسترسی دارند، استفاده می‌شود. این کنترل از بروز شرایط رقابتی (race conditions) و مصرف بیش از حد منابع جلوگیری می‌کند و پایداری سیستم را تضمین می‌کند. همگام‌سازی و کنترل دسترسی به ساختار داده‌های اشتراکی (Data Structure Synchronization): زمانی که چندین goroutine نیاز دارند به طور همزمان روی یک ساختار داده مانند map، queue یا cache کار کنند، می‌توان با سمیفور تعداد عملیات همزمان روی آن ساختار را محدود کرد تا همزمانی ایمن و مدیریت‌شده داشته باشیم. مدیریت منابع محدود (Limited Resource Allocation): بسیاری از منابع سیستم مانند connection pool دیتابیس، worker pool، پردازشگرهای شبکه یا حتی ظرفیت نوشتن روی دیسک دارای محدودیت فیزیکی یا منطقی هستند. سمیفور تضمین می‌کند که هرگز بیش از تعداد مشخصی از این منابع همزمان اشغال نشوند. پیاده‌سازی Load Balancer یا Rate Limiter: می‌توانید از سمیفور برای کنترل تعداد درخواست‌های همزمان که از طریق یک load balancer یا API gateway به سرویس اصلی ارسال می‌شوند استفاده کنید. این کار کمک می‌کند سرویس پشت‌صحنه هیچ‌وقت overload نشود و کیفیت پاسخ‌دهی به کاربران حفظ شود. همچنین می‌توان با همین الگو، الگوریتم‌های rate limiting پیاده‌سازی کرد. پیاده‌سازی Worker Pool یا Thread Pool: سمیفور هسته‌ی معماری Worker Pool است؛ یعنی تعداد taskهای فعال (یا thread/goroutine) در هر لحظه را محدود می‌کند و باعث می‌شود که هرگز بیش از ظرفیت واقعی سیستم، کار موازی اجرا نشود. این روش در سیستم‌های پردازش موازی، صف‌بندی background jobها، و بهبود performance به شدت کاربردی است. کنترل ترافیک ورودی یا API Throttling: با استفاده از سمیفور می‌توان تعداد پذیرش درخواست‌های همزمان ورودی (مثلاً به یک endpoint حیاتی یا سرویس خاص) را محدود کرد و در شرایط overload، درخواست‌های اضافی را reject یا queue کرد تا سیستم همیشه پاسخگو و پایدار بماند. "},{"id":210,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-retry-timeout/","title":"9.4.8 الگو Retry Timeout","section":"9.4 الگوهای همزمانی","content":" 9.4.8.1 توضیحات # الگوی Retry Timeout یکی از رایج‌ترین و مهم‌ترین الگوها در توسعه سرویس‌های پایدار (resilient) و سیستم‌های توزیع‌شده است. این الگو زمانی کاربرد دارد که عملیاتی مانند تماس با سرویس خارجی (مثلاً API، پایگاه داده، یا هر نوع ارتباط شبکه‌ای) ممکن است به صورت موقت شکست بخورد و لازم باشد با رعایت یک فاصله زمانی معین (timeout) چند بار به طور خودکار تلاش مجدد (retry) صورت بگیرد تا شانس موفقیت افزایش یابد و تجربه کاربری بهبود پیدا کند.\nدر Go، برای پیاده‌سازی این الگو معمولاً از یک حلقه ساده (for) به همراه تابع time.After یا متدهایی مانند time.Sleep استفاده می‌شود. در هر تلاش، ابتدا عملیات مورد نظر (مثلاً ارسال درخواست) اجرا می‌شود. اگر عملیات موفقیت‌آمیز نبود، برنامه برای مدتی مشخص (مثلاً یک ثانیه یا بیشتر) صبر می‌کند و دوباره تلاش می‌کند. این روند تا زمانی ادامه می‌یابد که یا تعداد تلاش‌ها از حد تعیین‌شده عبور کند، یا عملیات با موفقیت انجام شود، یا یک سیگنال کنسل (مانند context) دریافت شود. با استفاده از time.After، به صورت idiomatic و بدون مسدودسازی غیرضروری، می‌توان در هر تکرار مدت زمان انتظار بین تلاش‌ها را پیاده‌سازی کرد.\nمزیت الگوی Retry Timeout در Go این است که هم پیاده‌سازی آن ساده و خوانا است، هم قابلیت ترکیب با context برای پشتیبانی از لغو یا timeout کل عملیات وجود دارد و هم می‌توانید برای هر retry، لاگ، آمار، و حتی سیاست‌هایی مانند افزایش تدریجی تاخیر (exponential backoff) یا محدودیت کل زمان تلاش‌ها را به راحتی پیاده‌سازی کنید. این الگو یکی از ستون‌های اصلی resiliency در معماری میکروسرویس، ارتباطات شبکه‌ای و سامانه‌های distributed به شمار می‌رود و پیروی از آن، کیفیت و پایداری سرویس‌های شما را به طور چشمگیری افزایش می‌دهد.\n9.4.8.2 دیاگرام # flowchart TD Start([Start]) TryOp[Try Operation] Success{Success?} RetryMore{Retries Left?} Wait[Wait for timeout] DoneSuccess([Done: Success]) DoneFail([Done: Fail]) Start --\u003e TryOp TryOp --\u003e Success Success -- Yes --\u003e DoneSuccess Success -- No --\u003e RetryMore RetryMore -- Yes --\u003e Wait Wait --\u003e TryOp RetryMore -- No --\u003e DoneFail 9.4.8.3 نمونه کد # 1package main 2 3import ( 4\t\u0026#34;context\u0026#34; 5\t\u0026#34;fmt\u0026#34; 6\t\u0026#34;io\u0026#34; 7\t\u0026#34;net/http\u0026#34; 8\t\u0026#34;time\u0026#34; 9) 10 11func main() { 12\tconst ( 13\turl = \u0026#34;http://example.com\u0026#34; 14\tmaxRetries = 3 15\tretryTimeout = 2 * time.Second 16\t) 17\tvar resp *http.Response 18\tvar err error 19 20\t// Timeout کلی روی کل تلاش‌ها (مثلاً 10 ثانیه) 21\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second) 22\tdefer cancel() 23 24\tfor i := 1; i \u0026lt;= maxRetries; i++ { 25\treq, _ := http.NewRequestWithContext(ctx, http.MethodGet, url, nil) 26\tresp, err = http.DefaultClient.Do(req) 27\tif err == nil { 28\tfmt.Printf(\u0026#34;Success on attempt %d\\n\u0026#34;, i) 29\tbreak 30\t} 31\tfmt.Printf(\u0026#34;Attempt %d failed: %v\\n\u0026#34;, i, err) 32\tif i \u0026lt; maxRetries { 33\tselect { 34\tcase \u0026lt;-ctx.Done(): 35\tfmt.Println(\u0026#34;Global timeout reached, aborting retries.\u0026#34;) 36\tbreak 37\tcase \u0026lt;-time.After(retryTimeout): 38\tfmt.Println(\u0026#34;Retrying...\u0026#34;) 39\t} 40\t} 41\t} 42 43\tif err != nil { 44\tfmt.Println(\u0026#34;Final Error:\u0026#34;, err) 45\treturn 46\t} 47\tdefer resp.Body.Close() 48 49\t// خواندن بخشی از بدنه برای اطمینان از آزاد شدن connection 50\tbody, _ := io.ReadAll(io.LimitReader(resp.Body, 200)) 51\tfmt.Println(\u0026#34;Status:\u0026#34;, resp.Status) 52\tfmt.Printf(\u0026#34;Body sample: %q\\n\u0026#34;, body) 53} 1$ go run main.go 2Attempt 1 failed: Get \u0026#34;http://example.com\u0026#34;: dial tcp: lookup example.com on 169.254.169.254:53: dial udp 169.254.169.254:53: connect: no route to host 3Retrying... 4Attempt 2 failed: Get \u0026#34;http://example.com\u0026#34;: dial tcp: lookup example.com on 169.254.169.254:53: dial udp 169.254.169.254:53: connect: no route to host 5Retrying... 6Attempt 3 failed: Get \u0026#34;http://example.com\u0026#34;: dial tcp: lookup example.com on 169.254.169.254:53: dial udp 169.254.169.254:53: connect: no route to host 7Final Error: Get \u0026#34;http://example.com\u0026#34;: dial tcp: lookup example.com on 169.254.169.254:53: dial udp 169.254.169.254:53: connect: no route to host در این مثال از الگوی Retry Timeout، ما یک عملیات HTTP GET به آدرس مورد نظر را با رویکردی حرفه‌ای و ایمن، همراه با تلاش مجدد (Retry) و کنترل Timeout پیاده‌سازی می‌کنیم. ابتدا تعداد تلاش مجدد (maxRetries)، مدت تأخیر بین هر تلاش (retryTimeout) و یک Timeout کلی برای کل عملیات (۱۰ ثانیه) تعریف شده است تا سیستم هم از نظر مدیریت زمان و هم از نظر مصرف منابع، رفتار پیش‌بینی‌پذیری داشته باشد.\nدر ابتدای حلقه، یک context با Timeout کلی ساخته می‌شود. برای هر تلاش (تا سقف مجاز)، یک درخواست HTTP با همین context ساخته می‌شود تا در صورت لغو کلی یا پایان مهلت، همه retryها به صورت امن و هماهنگ متوقف شوند. اگر درخواست موفقیت‌آمیز باشد، شماره تلاش موفق ثبت می‌شود و حلقه خاتمه پیدا می‌کند. اگر شکست بخورد، پیام مربوط به شماره تلاش و علت خطا چاپ می‌شود. پیش از هر retry (به جز آخرین تلاش)، یک وقفه زمانی برقرار می‌شود. این وقفه با select روی ctx.Done() نیز کنترل می‌شود تا اگر قبل از شروع تلاش بعدی، context لغو شده بود، عملیات فوراً متوقف گردد و پیام مناسبی نمایش داده شود.\nپس از پایان حلقه، اگر همچنان خطا وجود داشته باشد، پیام خطا چاپ و برنامه خاتمه پیدا می‌کند. اگر درخواست موفقیت‌آمیز بوده، بدنه‌ی پاسخ حتماً بسته می‌شود تا از leak شدن منابع جلوگیری شود و connection قابل استفاده مجدد بماند. همچنین برای نمونه، بخشی از پاسخ خوانده و در خروجی چاپ می‌شود تا مطمئن شویم اتصال به سرور کامل برقرار شده است.\nاین معماری باعث می‌شود هم مدیریت خطا و retry کاملاً تحت کنترل باشد، هم منابع شبکه‌ای آزاد باقی بمانند و هم بتوان به سادگی رفتارهای حرفه‌ای‌تر مانند backoff تصاعدی، Circuit Breaker، یا لاگ پیشرفته‌تر را به آن اضافه کرد. چنین رویکردی در سامانه‌های توزیع‌شده و میکروسرویس‌ها استاندارد طلایی محسوب می‌شود و در پروژه‌های production-ready بسیار توصیه می‌شود.\n9.4.8.4 کاربردها # مقابله با خطاهای موقت شبکه و سرور: الگوی Retry Timeout اغلب زمانی به کار می‌رود که عملیات‌هایی مانند تماس با سرورهای HTTP، APIهای خارجی، پایگاه داده یا سایر سرویس‌های وابسته ممکن است به دلیل مشکلات موقتی (مانند قطعی لحظه‌ای شبکه، بار زیاد سرور، یا مشکلات DNS) شکست بخورند. با تکرار خودکار عملیات با فاصله زمانی کنترل‌شده، برنامه می‌تواند از گذرا بودن خطاها عبور کند و احتمال موفقیت را بدون دخالت کاربر بالا ببرد. پایداری و تاب‌آوری (Resilience) سرویس‌ها: در معماری‌های میکروسرویس، توزیع‌شده و ابری، Retry Timeout یک ابزار کلیدی برای افزایش resiliency سامانه است. این الگو کمک می‌کند سامانه به طور خودکار در برابر اختلالات کوتاه‌مدت واکنش نشان دهد و از fail شدن کل عملیات به خاطر یک خطای زودگذر جلوگیری کند. کاهش بار بر کاربر و تجربه کاربری بهتر: با استفاده از Retry Timeout، نیاز به تلاش مجدد دستی توسط کاربر حذف می‌شود و کاربران بدون آگاهی از خطاهای موقت، تجربه‌ای پیوسته و روان خواهند داشت. به‌ویژه در اپلیکیشن‌های موبایل یا تحت وب که اتصال شبکه متغیر است، این موضوع اهمیت بیشتری پیدا می‌کند. پیاده‌سازی Backoff و Circuit Breaker: این الگو پایه‌ای برای پیاده‌سازی استراتژی‌های پیچیده‌تری مانند exponential backoff (افزایش تدریجی فاصله بین تلاش‌ها) و circuit breaker (جلوگیری از retry پیوسته هنگام شکست‌های دائم) نیز هست که بهبود پایداری و هوشمندی retry را به ارمغان می‌آورد. اطمینان از اتمام موفق عملیات بحرانی: در کارهایی مانند ارسال تراکنش‌های بانکی، نوشتن در دیتابیس، یا ارسال پیام‌های حیاتی، Retry Timeout شانس اطمینان از موفقیت عملیات را افزایش می‌دهد و احتمال از دست رفتن داده‌ها را تا حد زیادی کاهش می‌دهد. "},{"id":211,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-producer-consumer/","title":"9.4.9 الگو Producer-Consumer","section":"9.4 الگوهای همزمانی","content":" 9.4.9.1 توضیحات # الگوی Producer-Consumer یکی از الگوهای بنیادی و بسیار پرکاربرد در برنامه‌نویسی همزمان (concurrent) با زبان Go است که امکان تولید و مصرف داده به صورت همزمان و ایمن را فراهم می‌کند. در این الگو، معمولاً یک یا چند goroutine به عنوان تولیدکننده (Producer) وظیفه تولید داده، رویداد یا پیام را بر عهده دارند و داده‌های تولیدی را از طریق یک کانال (channel) به goroutineهای دیگر که نقش مصرف‌کننده (Consumer) را دارند، ارسال می‌کنند. مصرف‌کننده‌ها نیز به صورت موازی داده‌های دریافتی را از کانال خوانده و پردازش می‌کنند. این جداسازی نقش تولید و مصرف، باعث می‌شود بخش‌های مختلف برنامه به صورت مستقل و همزمان عمل کرده و در عین حال از race condition و مشکلات همزمانی جلوگیری شود.\nکانال‌ها در Go نقش پل ارتباطی ایمن و همزمان بین goroutineها را بازی می‌کنند. معمولاً برای این الگو از یک کانال یک‌طرفه (unidirectional) بافر‌دار یا بدون بافر استفاده می‌شود تا داده‌ها به شکل صف (queue) از تولیدکننده به مصرف‌کننده منتقل شوند. هر چند، در معماری‌های پیچیده‌تر گاهی ممکن است از دو کانال (یکی برای داده و دیگری برای ارسال acknowledgment یا سیگنال برگشتی) بهره گرفته شود، اما در اکثر سناریوهای استاندارد کانال یک‌طرفه کفایت می‌کند. کانال‌های Go به‌طور خودکار هماهنگی بین goroutineها را برقرار می‌کنند؛ یعنی اگر کانال پر باشد، تولیدکننده منتظر می‌ماند تا مصرف‌کننده داده را مصرف کند، و اگر کانال خالی باشد، مصرف‌کننده منتظر می‌ماند تا داده جدید برسد.\nاین الگو برای حل بسیاری از مسائل دنیای واقعی ایده‌آل است؛ از صف بندی و پردازش موازی jobها گرفته تا انتقال داده بین بخش‌های مختلف یک سامانه، جمع‌آوری لاگ، پردازش همزمان پیام‌ها و حتی مدیریت صف درخواست‌های ورودی به سرویس‌ها. با استفاده از الگوی Producer-Consumer، نه تنها بهره‌وری و سرعت برنامه افزایش می‌یابد، بلکه کنترل جریان داده، پایداری و مقیاس‌پذیری سیستم نیز به طرز چشمگیری بهبود پیدا می‌کند. پیاده‌سازی صحیح این الگو در Go باعث می‌شود برنامه‌نویس بدون نگرانی از مشکلات همزمانی، بخش‌های مختلف سیستم را به صورت مستقل توسعه داده و بهینه کند.\n9.4.9.2 دیاگرام # flowchart TD subgraph Producers direction TB P1[\"Producer 1\"] P2[\"Producer 2\"] Pn[\"...\"] end subgraph Channel Chan[\"Channel (Buffer/Queue)\"] end subgraph Consumers direction TB C1[\"Consumer 1\"] C2[\"Consumer 2\"] Cn[\"...\"] end P1 -- \"Send Data\" --\u003e Chan P2 -- \"Send Data\" --\u003e Chan Pn -- \"Send Data\" --\u003e Chan Chan -- \"Receive Data\" --\u003e C1 Chan -- \"Receive Data\" --\u003e C2 Chan -- \"Receive Data\" --\u003e Cn 9.4.9.3 نمونه کد # 1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;math/rand\u0026#34; 6\t\u0026#34;sync\u0026#34; 7\t\u0026#34;time\u0026#34; 8) 9 10func producer(ch chan\u0026lt;- int, count int, wg *sync.WaitGroup) { 11\tdefer wg.Done() 12\tfor i := 0; i \u0026lt; count; i++ { 13\tn := rand.Intn(100) 14\tch \u0026lt;- n 15\tfmt.Println(\u0026#34;Produced:\u0026#34;, n) 16\ttime.Sleep(100 * time.Millisecond) 17\t} 18\tclose(ch) // سیگنال پایان تولید به مصرف‌کننده‌ها 19} 20 21func consumer(id int, ch \u0026lt;-chan int, wg *sync.WaitGroup) { 22\tdefer wg.Done() 23\tfor n := range ch { 24\tfmt.Printf(\u0026#34;Consumer %d: Consumed %d\\n\u0026#34;, id, n) 25\ttime.Sleep(200 * time.Millisecond) 26\t} 27\tfmt.Printf(\u0026#34;Consumer %d: Finished\\n\u0026#34;, id) 28} 29 30func main() { 31\trand.Seed(time.Now().UnixNano()) 32\tch := make(chan int, 10) // کانال بافر دار 33 34\tvar wg sync.WaitGroup 35\tproduceCount := 20 36 37\twg.Add(1) 38\tgo producer(ch, produceCount, \u0026amp;wg) 39 40\tconsumerCount := 2 41\tfor i := 1; i \u0026lt;= consumerCount; i++ { 42\twg.Add(1) 43\tgo consumer(i, ch, \u0026amp;wg) 44\t} 45 46\twg.Wait() 47\tfmt.Println(\u0026#34;All done.\u0026#34;) 48} 1$ go run main.go 2Produced: 96 3Consumer 2: Consumed 96 4Produced: 55 5Consumer 1: Consumed 55 6Consumer 2: Consumed 36 7Produced: 36 8Produced: 45 9Consumer 1: Consumed 45 10Produced: 61 11Consumer 2: Consumed 61 12Produced: 6 13Consumer 1: Consumed 6 14Produced: 12 15Consumer 2: Consumed 12 16Produced: 45 17Consumer 1: Consumed 45 18Produced: 84 19Consumer 2: Consumed 84 20Produced: 48 21Consumer 1: Consumed 48 22Produced: 78 23Consumer 2: Consumed 78 24Produced: 44 25Consumer 1: Consumed 44 26Produced: 18 27Consumer 2: Consumed 18 28Produced: 92 29Consumer 1: Consumed 92 30Produced: 9 31Consumer 2: Consumed 9 32Produced: 5 33Consumer 1: Consumed 5 34Produced: 32 35Consumer 2: Consumed 32 36Produced: 0 37Consumer 1: Consumed 0 38Produced: 30 39Consumer 2: Consumed 30 40Produced: 86 41Consumer 1: Consumed 86 42Consumer 2: Finished 43Consumer 1: Finished 44All done. در نسخه بهبود یافته‌ی مثال Producer-Consumer، تلاش شده تمام چالش‌های همزمانی و ضعف‌های مدیریت goroutineها به صورت حرفه‌ای و idiomatic در زبان Go برطرف شود. در این ساختار، یک goroutine به عنوان تولیدکننده (Producer) تعریف شده که به تعداد مشخص (مثلاً ۲۰ عدد) داده تصادفی تولید و وارد یک کانال بافر‌دار (مثلاً با ظرفیت ۱۰) می‌کند. استفاده از کانال بافر دار باعث می‌شود تولید و مصرف داده‌ها تا حدی decoupled باشند، یعنی اگر مصرف‌کننده‌ها لحظه‌ای کند شوند، تولیدکننده تا پر شدن بافر بدون توقف می‌تواند تولید کند.\nپس از تولید همه داده‌ها، producer کانال را می‌بندد. این کار بسیار مهم است؛ چون با بسته شدن کانال، حلقه‌ی for در goroutineهای مصرف‌کننده به صورت تمیز و بدون خطا تمام می‌شود و پیام \u0026ldquo;Finished\u0026rdquo; برای هر مصرف‌کننده چاپ می‌گردد. مصرف‌کننده‌ها به صورت worker pool پیاده‌سازی شده‌اند؛ یعنی هر داده‌ای که از کانال خارج شود به طور تصادفی توسط یکی از مصرف‌کننده‌ها پردازش می‌شود (division of labor) و هرکدام بعد از اتمام کارشان (یعنی زمانی که کانال بسته و همه داده‌ها مصرف شده باشد) خارج می‌شوند.\nبرای جلوگیری از goroutine leak و تضمین پایان تمیز همه goroutineها، از sync.WaitGroup استفاده شده است. با اضافه کردن یک مقدار به WaitGroup قبل از هر goroutine و کم کردن آن هنگام اتمام goroutine (defer wg.Done())، می‌توان مطمئن بود که برنامه فقط زمانی پایان می‌یابد که همه تولید و مصرف‌ها به طور کامل انجام شده‌اند.\nاین معماری، همزمانی ایمن، کنترل شده و مقیاس‌پذیر بین بخش تولید و مصرف داده را فراهم می‌کند. در چنین سیستمی، می‌توانید تعداد تولیدکننده یا مصرف‌کننده را به راحتی افزایش دهید یا منطق هر بخش را تغییر دهید (مثلاً پردازش‌های سنگین‌تر، ارسال درخواست‌های شبکه و\u0026hellip;) بدون اینکه نیاز به تغییر بنیادی در ساختار ارتباط بین آن‌ها باشد. استفاده صحیح از کانال‌ها، WaitGroup و مدیریت پایان graceful باعث می‌شود این الگو به راحتی در پروژه‌های تولیدی، سرویس‌های بلادرنگ، صف‌های پیام و هر نوع معماری concurrent مدرن قابل استفاده باشد.\n9.4.9.4 کاربردها # خط لوله پردازش داده (Data Processing Pipeline): با استفاده از این الگو می‌توانید معماری خط لوله یا pipeline ایجاد کنید که هر مرحله از پردازش به‌عنوان یک producer یا consumer عمل می‌کند. به عنوان مثال، ابتدا داده خام توسط یک goroutine تولید و از طریق کانال به مرحله بعد (مثل پاک‌سازی، تحلیل، تبدیل یا ذخیره‌سازی) ارسال می‌شود و هر مرحله می‌تواند نقش producer برای مرحله بعد و consumer برای مرحله قبل را داشته باشد. این مدل توسعه، تست و مقیاس‌پذیری سیستم‌های داده‌محور را بسیار ساده و حرفه‌ای می‌کند. سیستم‌های Logging و Monitoring: در معماری‌های واقعی، ثبت لاگ یا مانیتورینگ سیستم نیازمند جدا بودن تولید و ذخیره‌سازی لاگ است تا بخش اصلی سیستم کند نشود. با این الگو، برنامه اصلی (یا بخش‌های مختلف آن) به‌عنوان producer لاگ‌ها را روی کانال می‌فرستد و یک یا چند consumer این داده‌ها را از کانال می‌خوانند و آن‌ها را در فایل، پایگاه داده یا سرور مانیتورینگ ثبت می‌کنند. این کار از blocking شدن منطق اصلی و تجمع بی‌مورد داده جلوگیری می‌کند و ثبت لاگ را مقیاس‌پذیر و غیرمسدودکننده می‌کند. استریم داده و Real-time Processing: در سناریوهایی مانند پردازش رویدادهای لحظه‌ای (event streaming)، انتقال داده‌های IoT یا سیستم‌های تحلیل آنلاین (online analytics)، این الگو به شما امکان می‌دهد داده‌های تولیدشده را در لحظه به مصرف‌کنندگان منتقل کنید. این مصرف‌کنندگان می‌توانند انواع عملیات مانند فیلتر، آمار، آلارم، ذخیره‌سازی لحظه‌ای یا پردازش پیشرفته روی داده انجام دهند. Producer-Consumer ستون فقرات معماری بسیاری از سرویس‌های real-time و message queue است. واسطه‌گری بین سیستم‌ها (Integration \u0026amp; Decoupling): این الگو به شما اجازه می‌دهد بخش‌های مختلف یک سیستم یا حتی سرویس‌های جدا را از طریق کانال‌های ارتباطی به هم متصل کنید بدون آنکه وابستگی مستقیم یا coupling بالا داشته باشند. هر producer می‌تواند در یک microservice یا process مجزا باشد و داده را به صف ارسال کند و هر consumer در سوی دیگر مسئول مصرف و پردازش باشد. "},{"id":212,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-monitor/","title":"9.4.10 الگو Monitor","section":"9.4 الگوهای همزمانی","content":" 9.4.10.1 توضیحات # الگوی مانیتور (Monitor Pattern) یکی از مفاهیم کلیدی در طراحی سیستم‌های همزمان است که هدف آن فراهم کردن مکانیزمی برای مدیریت ایمن و هماهنگ دسترسی چندین goroutine به یک منبع یا وضعیت مشترک است. این الگو به گونه‌ای طراحی شده که goroutineها بتوانند زمانی که منتظر وقوع یک شرط خاص (مثلاً آماده شدن داده یا تغییر وضعیت یک منبع) هستند، بدون مصرف بیهوده منابع (مانند CPU) یا بلاک شدن کل برنامه، به حالت خواب بروند و به محض برقرار شدن شرط، از خواب بیدار شوند و ادامه اجرا دهند. این رفتار دقیقاً چیزی است که در زبان Go می‌توان با کمک ساختار sync.Cond پیاده‌سازی کرد.\nساختار sync.Cond در پکیج sync زبان Go، ابزاری قدرتمند برای پیاده‌سازی این الگو است. یک شیء Cond روی یک lock (مانند sync.Mutex یا sync.RWMutex) ساخته می‌شود و سه متد کلیدی دارد:\nWait() که goroutine جاری را به حالت خواب می‌برد تا زمانی که از طریق سیگنال بیدار شود؛ Signal() که یکی از goroutineهای منتظر را بیدار می‌کند؛ Broadcast() که همه‌ی goroutineهای منتظر را بیدار می‌کند. هنگامی که goroutine شرط مورد نظرش برقرار نشده، متد Wait را صدا می‌زند و lock را به طور موقت آزاد می‌کند تا دیگران هم بتوانند منبع مشترک را تغییر دهند. پس از دریافت سیگنال و بیدار شدن، دوباره lock را به دست می‌گیرد و شرط را بررسی می‌کند. این روش بسیار ایمن، سریع و idiomatic است و از busy waiting (حلقه‌ی بی‌پایان با مصرف CPU) جلوگیری می‌کند.\nالگوی مانیتور با استفاده از sync.Cond معمولاً در سناریوهایی مانند صف‌های تولید-مصرف (زمانی که صف خالی است، مصرف‌کننده منتظر تولید داده می‌ماند)، پیاده‌سازی سیستم‌های صف انتظار (Waiting Queue)، کنترل منابع اشتراکی، یا هرجایی که نیاز به هماهنگی و همزمانی پیشرفته بین goroutineها وجود دارد، استفاده می‌شود. این الگو باعث افزایش پایداری و کارایی سیستم‌های concurrent می‌شود و پیاده‌سازی آن در Go هم ساده و هم بسیار قدرتمند است.\nبه نقل از ویکی پدیا :\nدر برنامه‌نویسی همروند (یا همان برنامه‌نویسی موازی)، مانیتور یک ساختار همگام سازی است که به ریسمان ها این امکان را می‌دهد که هم، انحصار متقابل داشته باشند و هم، بتوانند برای یک وضعیت خاص منتظر بمانند (مسدود شوند) تا وضعیت غلط شود. مانیتورها همچنین دارای یک مکانیسم هستند که به ریسمان‌های دیگر، از طریق سیگنال می‌فهمانند که شرایط آنها برآورده شده‌است. یک مانیتور، حاوی یک شئ میوتکس (قفل) و متغیرهای وضعیت است. یک متغیر وضعیت اساساً، ظرفی از ریسمان ها است که منتظر یک وضعیت خاص هستند. مانیتورها برای ریسمان‌ها مکانیسمی را فراهم می‌کنند، تا به‌طور موقت، و با هدف منتظر ماندن برای برآورده شدن شرایط خاص، دسترسی انحصاری را رها کنند، و سپس دسترسی انحصاری را مجدداً به دست آورند و کار خود را از سر گیرند.\n9.4.10.2 دیاگرام # flowchart TD A[Goroutine] --\u003e|Check Condition| B{Condition met?} B -- Yes --\u003e C[Process / Continue] B -- No --\u003e D[Wait sync.Cond] D -. Receive Signal .-\u003e E[Wake Up Goroutine] E --\u003e|Acquire lock| B F[Other Goroutines] --\u003e|Signal/Broadcast| D 9.4.10.3 نمونه کد # 1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;sync\u0026#34; 6) 7 8type Item = int 9 10type Queue struct { 11\titems []Item 12\tclosed bool 13\t*sync.Cond 14} 15 16// ایجاد صف جدید 17func NewQueue() *Queue { 18\treturn \u0026amp;Queue{ 19\tCond: sync.NewCond(\u0026amp;sync.Mutex{}), 20\t} 21} 22 23// قرار دادن یک آیتم در صف 24func (q *Queue) Put(item Item) error { 25\tq.L.Lock() 26\tdefer q.L.Unlock() 27\tif q.closed { 28\treturn fmt.Errorf(\u0026#34;queue is closed\u0026#34;) 29\t} 30\tq.items = append(q.items, item) 31\tq.Signal() // فقط یکی از منتظرها را بیدار کن (بهینه‌تر) 32\treturn nil 33} 34 35// گرفتن n آیتم از صف، یا برگشت آیتم‌های موجود در صورت بسته بودن صف 36func (q *Queue) GetMany(n int) ([]Item, error) { 37\tq.L.Lock() 38\tdefer q.L.Unlock() 39\tfor len(q.items) \u0026lt; n \u0026amp;\u0026amp; !q.closed { 40\tq.Wait() 41\t} 42\tif len(q.items) == 0 \u0026amp;\u0026amp; q.closed { 43\treturn nil, fmt.Errorf(\u0026#34;queue closed and empty\u0026#34;) 44\t} 45\t// اگر صف بسته شده و آیتم‌هایی باقی مانده است، همان‌ها را بازگردان 46\tm := n 47\tif len(q.items) \u0026lt; n { 48\tm = len(q.items) 49\t} 50\titems := q.items[:m:m] 51\tq.items = q.items[m:] 52\treturn items, nil 53} 54 55// بستن صف و بیدار کردن همه goroutineهای منتظر 56func (q *Queue) Close() { 57\tq.L.Lock() 58\tdefer q.L.Unlock() 59\tq.closed = true 60\tq.Broadcast() // همه منتظرها را بیدار کن 61} 62 63func main() { 64\tq := NewQueue() 65\tvar wg sync.WaitGroup 66 67\t// مصرف‌کننده‌ها 68\tfor n := 10; n \u0026gt; 0; n-- { 69\twg.Add(1) 70\tgo func(n int) { 71\tdefer wg.Done() 72\tfor { 73\titems, err := q.GetMany(n) 74\tif err != nil { 75\tbreak 76\t} 77\tfmt.Printf(\u0026#34;%2d: %v\\n\u0026#34;, n, items) 78\t} 79\t}(n) 80\t} 81 82\t// تولید داده 83\tfor i := 0; i \u0026lt; 100; i++ { 84\t_ = q.Put(i) 85\t} 86\tq.Close() // صف را پس از تولید داده می‌بندیم 87 88\twg.Wait() 89\tfmt.Println(\u0026#34;All done!\u0026#34;) 90} 1$ go run main.go 2 1: [0] 3 1: [1] 4 1: [2] 5 1: [3] 6 1: [4] 7 1: [5] 8 1: [6] 9 1: [7] 10 1: [8] 11 1: [9] 12 1: [10] 13 1: [11] 14 1: [12] 15 1: [13] 16 7: [14 15 16 17 18 19 20] 17 7: [43 44 45 46 47 48 49] 18 7: [72 73 74 75 76 77 78] 19 7: [79 80 81 82 83 84 85] 20 7: [86 87 88 89 90 91 92] 21 7: [93 94 95 96 97 98 99] 22 5: [50 51 52 53 54] 23 9: [55 56 57 58 59 60 61 62 63] 24 8: [64 65 66 67 68 69 70 71] 25 1: [21] 26 2: [25 26] 27 3: [22 23 24] 28 6: [27 28 29 30 31 32] 2910: [33 34 35 36 37 38 39 40 41 42] 30All done! در این مثال، یک صف thread-safe (ایمن برای همزمانی) با استفاده از الگوی مانیتور (Monitor Pattern) و ابزار قدرتمند sync.Cond پیاده‌سازی شده است. این صف، امکان قرار دادن آیتم (توسط تولیدکننده‌ها) و دریافت چند آیتم به صورت همزمان (توسط مصرف‌کننده‌ها) را به‌صورت هماهنگ و ایمن فراهم می‌کند.\nدر این معماری، متد Put برای افزودن آیتم جدید به صف استفاده می‌شود و با هر بار افزودن، یکی از goroutineهای منتظر (مصرف‌کننده‌ها) را با متد Signal() بیدار می‌کند تا در صورت آماده بودن شرط (یعنی تعداد آیتم کافی)، کار خود را ادامه دهد. در سمت مصرف‌کننده، هر goroutine با متد GetMany(n) منتظر می‌ماند تا حداقل n آیتم در صف موجود شود. اگر این شرط برقرار نباشد و صف همچنان باز باشد، مصرف‌کننده با متد Wait() به حالت خواب می‌رود تا زمانی که داده کافی توسط تولیدکننده وارد صف شود یا صف بسته شود.\nنکته کلیدی اینجاست که بعد از اتمام تولید داده (در این مثال پس از افزودن ۱۰۰ آیتم)، با فراخوانی متد Close() صف بسته می‌شود و همه goroutineهای منتظر با Broadcast() بیدار می‌شوند. این کار تضمین می‌کند هیچ مصرف‌کننده‌ای به صورت بی‌نهایت در حالت انتظار نخواهد ماند و همگی graceful و تمیز به کار خود پایان می‌دهند. اگر صف بسته و خالی باشد، مصرف‌کننده‌ها پیام خطا دریافت و خارج می‌شوند.\nدر نهایت با استفاده از یک sync.WaitGroup اطمینان حاصل می‌شود که تمام goroutineها (مصرف‌کننده‌ها) پس از اتمام واقعی پردازش و بدون هیچ‌گونه goroutine leak یا بن‌بست (deadlock) خاتمه می‌یابند. این معماری، هم مقیاس‌پذیر، هم ایمن، و هم idiomatic در دنیای Go است و می‌تواند در سناریوهای تولید-مصرف، صف‌های پردازش موازی، و حتی سیستم‌های real-time به‌سادگی استفاده شود.\n9.4.10.4 کاربردها # پردازش دسته‌ای داده (Batch Processing): زمانی که نیاز دارید تعداد مشخصی داده (مثلاً ۱۰ آیتم) جمع‌آوری و سپس به صورت یکجا پردازش شوند، می‌توانید با استفاده از sync.Cond منتظر بمانید تا شرط \u0026ldquo;تعداد کافی آیتم در صف\u0026rdquo; برقرار شود. سپس با سیگنال به مصرف‌کننده‌ها اطلاع می‌دهید که اکنون دسته داده آماده پردازش است و می‌توانند ادامه دهند. انتظار برای وقوع رویدادهای خارجی: اگر لازم است goroutineها تا وقوع یک رویداد خاص (مثل تکمیل عملیات در سرویس خارجی، رسیدن پیام از سرور، پایان کار background یا حتی فشار یک دکمه توسط کاربر) متوقف بمانند، با Cond می‌توانید آن‌ها را به خواب بفرستید تا زمانی که سیگنال یا Broadcast داده شود و همه با هم یا یکی یکی بیدار شوند. کنترل جریان و هماهنگی اجرای goroutineها (Flow Control \u0026amp; Synchronization): در مواقعی که لازم است فقط تعداد مشخصی از goroutineها همزمان وارد بخش بحرانی شوند یا اجرای بخشی از کد فقط پس از رخداد شرایط خاص آغاز شود، می‌توانید با کمک sync.Cond و شرط‌های سفارشی، کنترل کامل اجرای concurrent را داشته باشید (مثلاً: شروع تمام همزمان، یا توقف گروهی هنگام رسیدن به نقطه sink). همگام‌سازی و کنترل قفل‌های منابع مشترک: اگر دسترسی به یک منبع (مثلاً یک بافر یا شیء مشترک) باید با شرایط خاصی صورت گیرد (مثلاً تا زمانی که منبع خالی/پر نشده، اجازه دسترسی داده نشود)، می‌توانید با Cond گوروتین‌های منتظر را تا زمان آزاد شدن قفل یا فراهم شدن شرط، به خواب ببرید و سپس با Signal/Broadcast آنها را بیدار کنید. همگام‌سازی پایان و شروع عملیات چندگانه (Barrier Synchronization): زمانی که چندین goroutine باید همگی یک مرحله کار را به اتمام برسانند تا مرحله بعدی آغاز شود (مانند الگوی barrier)، می‌توان با Cond به هر goroutine پس از اتمام کار سیگنال داد و منتظر ماند تا همه به نقطه هماهنگ برسند، سپس اجرای مرحله بعدی را شروع کرد. انتظار پویا برای داده یا منبع: در صف‌های message queue، اگر مصرف‌کننده‌ها به داده نیاز دارند اما صف خالی است، به جای busy waiting، می‌توانند تا زمان ورود داده با Wait منتظر بمانند و تولیدکننده با Signal مصرف‌کننده‌ها را بیدار کند. این کار کارایی و مصرف منابع را بهبود می‌دهد. "},{"id":213,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-future/","title":"9.4.11 الگو Future","section":"9.4 الگوهای همزمانی","content":" 9.4.11.1 توضیحات # الگوی Future (یا Promise) یکی از الگوهای مهم و کاربردی در طراحی سیستم‌های ناهمزمان (asynchronous) است که در زبان Go نیز، اگرچه به صورت مستقیم در کتابخانه استاندارد وجود ندارد، اما می‌توان با استفاده از ابزارهای زبان مانند goroutine و channel، به‌سادگی آن را پیاده‌سازی کرد. هدف این الگو این است که یک \u0026ldquo;آبجکت\u0026rdquo; یا واسط به برنامه‌نویس داده شود که نماینده نتیجه یک عملیات (مانند درخواست شبکه یا محاسبه سنگین) است—حتی اگر آن عملیات هنوز به پایان نرسیده باشد.\nدر عمل، وقتی عملیاتی به صورت asynchronous آغاز می‌شود، به جای اینکه فوراً منتظر نتیجه بمانیم (و اجرای برنامه را بلاک کنیم)، یک مقدار از نوع Future دریافت می‌کنیم. این Future به عنوان placeholder یا وعده‌ای برای تحویل نتیجه نهایی به کار می‌رود. در پس‌زمینه، عملیات اصلی (مثلاً دریافت داده از API یا خواندن از دیسک) با یک goroutine انجام می‌شود و زمانی که به پایان رسید، نتیجه در Future ذخیره و آماده دسترسی می‌شود. هر زمان که برنامه به نتیجه نیاز داشته باشد، می‌تواند روی Future فراخوانی انجام دهد (مثلاً با خواندن از یک channel یا متد Get/Result)؛ اگر نتیجه هنوز آماده نشده باشد، برنامه به طور بلاک تا تکمیل عملیات منتظر می‌ماند و بلافاصله پس از آماده‌شدن داده، ادامه اجرا انجام می‌شود.\nمزیت کلیدی الگوی Future در Go، جداسازی منطق اجرای عملیات ناهمزمان از منطق مصرف‌کننده آن است. این کار خوانایی و مدیریت خطا را ساده‌تر، مدیریت منابع را بهینه‌تر و کد را مقیاس‌پذیرتر می‌کند. با استفاده از این الگو می‌توان معماری‌های مدرن با پردازش موازی و کارآمد ساخت، بدون آنکه درگیر callback hell یا کد پیچیده شوید. همچنین Future پایه بسیاری از فریمورک‌ها و ابزارهای concurrent در زبان‌های دیگر (مانند Java, Rust, JavaScript) نیز هست و در Go، idiomatic ترین پیاده‌سازی معمولاً مبتنی بر channel و goroutine است.\n9.4.11.2 دیاگرام # flowchart TD A[Start async operation] --\u003e B[Return Future object] B -- \"Do other work\" --\u003e C[Need result] C --\u003e D[Wait for result from Future] D --\u003e E[Receive final result and continue] A -- \"Run in background\" --\u003e F[Async task completes] F -- \"Set result in Future\" --\u003e D 9.4.11.3 نمونه کد # 1package main 2 3import ( 4\t\u0026#34;errors\u0026#34; 5\t\u0026#34;fmt\u0026#34; 6\t\u0026#34;sync\u0026#34; 7\t\u0026#34;time\u0026#34; 8) 9 10type FutureInt struct { 11\tonce sync.Once 12\tresult int 13\terr error 14\tdone chan struct{} 15} 16 17// Get با بلاک تا تکمیل شدن عملیات صبر می‌کند و نتیجه و خطا را برمی‌گرداند 18func (f *FutureInt) Get() (int, error) { 19\t\u0026lt;-f.done 20\treturn f.result, f.err 21} 22 23// GetWithTimeout با تایم‌اوت مشخص منتظر نتیجه می‌ماند 24func (f *FutureInt) GetWithTimeout(timeout time.Duration) (int, error) { 25\tselect { 26\tcase \u0026lt;-f.done: 27\treturn f.result, f.err 28\tcase \u0026lt;-time.After(timeout): 29\treturn 0, errors.New(\u0026#34;timeout waiting for future\u0026#34;) 30\t} 31} 32 33func longRunningTask() *FutureInt { 34\tf := \u0026amp;FutureInt{done: make(chan struct{})} 35\tgo func() { 36\tdefer close(f.done) 37\t// شبیه‌سازی کار زمان‌بر و گاهی بروز خطا 38\ttime.Sleep(time.Second) 39\tif time.Now().Unix()%2 == 0 { 40\tf.result = 42 41\tf.err = nil 42\t} else { 43\tf.result = 0 44\tf.err = errors.New(\u0026#34;unexpected error\u0026#34;) 45\t} 46\t}() 47\treturn f 48} 49 50func main() { 51\tf := longRunningTask() 52\tfmt.Println(\u0026#34;Do something else while waiting for result...\u0026#34;) 53\t// دریافت نتیجه با مدیریت خطا 54\tresult, err := f.Get() 55\tif err != nil { 56\tfmt.Println(\u0026#34;Future failed:\u0026#34;, err) 57\treturn 58\t} 59\tfmt.Println(\u0026#34;The answer is:\u0026#34;, result) 60 61\t// نمونه با timeout 62\tf2 := longRunningTask() 63\tresult2, err2 := f2.GetWithTimeout(500 * time.Millisecond) 64\tif err2 != nil { 65\tfmt.Println(\u0026#34;Timeout error:\u0026#34;, err2) 66\t} else { 67\tfmt.Println(\u0026#34;Result with timeout:\u0026#34;, result2) 68\t} 69} 1$ go run main.go 2Do something else while waiting for result... 3Future failed: unexpected error در این مثال از الگوی Future در Go، ما یک ساختار کامل و قابل اطمینان برای مدیریت نتیجه‌ی عملیات ناهمزمان (asynchronous) و دریافت امن و حرفه‌ای نتیجه، همراه با مدیریت خطا و قابلیت timeout پیاده‌سازی کرده‌ایم.\nدر ساختار FutureInt، یک کانال از نوع chan struct{} با نام done وجود دارد که سیگنال اتمام عملیات را ارسال می‌کند. مقدار نتیجه (result) و خطا (err) به صورت فیلدهای struct نگهداری می‌شوند. زمانی که عملیات ناهمزمان (در goroutine مربوط به تابع longRunningTask) به پایان می‌رسد، کانال done بسته می‌شود تا هر goroutine منتظر یا فراخوانی کننده‌ی Get یا GetWithTimeout متوجه آماده‌شدن نتیجه شود.\nمتد Get تا زمانی که عملیات کامل نشده منتظر می‌ماند و پس از اتمام، مقدار نهایی و خطا را بازمی‌گرداند. این کار با خواندن از کانال done انجام می‌شود، که هم thread-safe و هم idiomatic است. متد GetWithTimeout علاوه بر انتظار برای تکمیل، این امکان را می‌دهد که اگر نتیجه طی زمان معینی آماده نشد، با پیغام خطای timeout عملیات را مدیریت کنید—این قابلیت در سناریوهای real-time و حساس به تاخیر اهمیت زیادی دارد.\nدر تابع main، ابتدا یک Future ساخته می‌شود و قبل از فراخوانی نتیجه می‌توان هر کار دیگری انجام داد (این همان مزیت کلیدی Future است). سپس با صدا زدن Get، نتیجه و خطا را دریافت و مدیریت می‌کنیم. همچنین نمونه‌ای از دریافت نتیجه با timeout هم آورده شده است تا نحوه‌ی مدیریت عملیات طولانی یا گیر افتاده نیز مشخص باشد.\nاین معماری علاوه بر ایمنی همزمانی، جداسازی وظایف (تولید و مصرف نتیجه)، پشتیبانی از خطا و timeout، به سادگی قابل توسعه و استفاده در پروژه‌های واقعی و تولیدی است و تجربه برنامه‌نویسی concurrent را بسیار حرفه‌ای‌تر و قابل کنترل‌تر می‌کند.\n9.4.11.4 کاربردها # درخواست‌های شبکه (Asynchronous Network Requests):\nدر زمانی که نیاز به ارسال درخواست به یک سرویس خارجی یا API دارید، الگوی Future کمک می‌کند که بتوانید درخواست را به صورت ناهمزمان ارسال و به محض آماده شدن پاسخ، آن را دریافت کنید. این کار باعث می‌شود بتوانید بدون مسدود کردن برنامه، کارهای دیگری انجام دهید تا زمانی که نتیجه آماده شود. این تکنیک برای توسعه کلاینت‌های HTTP، REST، GraphQL و حتی WebSocket بسیار کاربردی است. کوئری‌های پایگاه داده (Async Database Querying):\nهنگام اجرای کوئری‌های سنگین یا زمان‌بر روی دیتابیس، Future اجازه می‌دهد کوئری را به صورت ناهمزمان آغاز کنید و هر زمان که نتیجه واقعاً لازم بود، آن را دریافت کنید. این رویکرد برای برنامه‌هایی که باید همزمان چند کوئری مختلف را به دیتابیس ارسال کنند (مانند جمع‌آوری داده از چند جدول یا سرور متفاوت) بسیار مفید است و latency کلی برنامه را کاهش می‌دهد. محاسبات سنگین و پردازش موازی:\nاگر در برنامه نیاز به انجام محاسبات CPU-intensive (مانند تجزیه داده، پردازش تصویر، رمزنگاری و \u0026hellip;) دارید، می‌توانید هر task را در یک Future قرار دهید و نتایج را در صورت نیاز، به صورت همزمان و بدون بلاک شدن منتظر بمانید. این کار باعث بهبود performance و پاسخگویی سیستم خواهد شد. ترکیب و همگام‌سازی عملیات مستقل (Composition and Synchronization):\nمی‌توانید چندین Future ایجاد کنید و به طور موازی آن‌ها را اجرا نمایید، سپس به صورت هماهنگ (مثلاً با WaitGroup یا channel) منتظر دریافت همه نتایج باشید (pattern معروف به Fan-In). این رویکرد برای جمع‌آوری نتایج عملیات‌های موازی (مانند دانلود چند فایل یا جمع‌آوری داده از چند سرویس) ایده‌آل است. پردازش رویداد و message queue:\nدر معماری‌هایی مانند صف پیام یا پردازش رویداد (event-driven)، هر message را می‌توان به عنوان یک Future مدیریت کرد و پس از پایان پردازش، نتیجه یا پاسخ را برای ادامه کار استفاده نمود. "},{"id":214,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-pipeline/","title":"9.4.12 الگو Pipeline","section":"9.4 الگوهای همزمانی","content":" 9.4.12.1 توضیحات # الگوی خط لوله (Pipeline) یکی از حرفه‌ای‌ترین و پرکاربردترین الگوهای همزمانی در زبان Go است که نقش بسیار مهمی در طراحی سیستم‌های مقیاس‌پذیر، قابل نگهداری و با کارایی بالا دارد. هدف این الگو این است که یک کار بزرگ یا پردازش پیچیده را به چند مرحله (stage) کاملاً مستقل تقسیم کند، به طوری که هر مرحله بتواند همزمان با مراحل دیگر اجرا شود. در این ساختار، هر stage مسئولیت انجام یک بخش خاص از فرآیند را بر عهده دارد (مثلاً خواندن داده، پاک‌سازی، پردازش، ذخیره‌سازی و\u0026hellip;) و معمولاً هر stage در یک goroutine مجزا اجرا می‌شود.\nانتقال داده بین این مراحل، به صورت ایمن و concurrent از طریق channel انجام می‌گیرد. هر مرحله داده‌های پردازش‌شده خود را به کانال خروجی ارسال می‌کند و مرحله بعدی آن داده‌ها را از کانال ورودی دریافت می‌کند. این ساختار باعث می‌شود که مراحل مختلف pipeline بتوانند بدون وابستگی مستقیم به یکدیگر، به صورت موازی و کاملاً decoupled کار کنند؛ به عبارتی، هر stage می‌تواند با سرعت خود کار کند و کندی یا شتاب یک مرحله، روی کل پردازش اثر غیرخطی نخواهد داشت.\nاین الگو به طور گسترده در پردازش داده‌های حجیم، تحلیل داده‌های real-time، پیاده‌سازی ETL (استخراج، تبدیل و بارگذاری)، پردازش تصویر و صدا، یا هرجا که داده باید مرحله به مرحله و به شکل stream پردازش شود، کاربرد دارد. با استفاده از Pipeline، کد ساده‌تر، توسعه‌پذیرتر و خطایابی آن آسان‌تر می‌شود و همچنین بهره‌وری سیستم به حداکثر می‌رسد، چرا که همزمانی و توزیع بار به بهترین شکل انجام می‌شود.\n9.4.12.2 دیاگرام # flowchart LR A[Input Data] --\u003e S1[Stage 1: Preprocessing] S1 --\u003e S2[Stage 2: Processing] S2 --\u003e S3[Stage 3: Postprocessing] S3 --\u003e B[Output Data] subgraph Goroutine S1 S2 S3 end style S1 fill:#d9f5f9,stroke:#30b5c8,stroke-width:2px style S2 fill:#e2f7e9,stroke:#46c772,stroke-width:2px style S3 fill:#fdf2e8,stroke:#e8922d,stroke-width:2px 9.4.12.3 نمونه کد # 1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7// تولید داده اولیه (stage 1) 8func gen(nums ...int) \u0026lt;-chan int { 9\tout := make(chan int, 2) // کانال بافر دار 10\tgo func() { 11\tdefer close(out) 12\tfor _, n := range nums { 13\tout \u0026lt;- n 14\t} 15\t}() 16\treturn out 17} 18 19// مربع هر عدد (stage 2) 20func sq(in \u0026lt;-chan int) \u0026lt;-chan int { 21\tout := make(chan int, 2) 22\tgo func() { 23\tdefer close(out) 24\tfor n := range in { 25\tout \u0026lt;- n * n 26\t} 27\t}() 28\treturn out 29} 30 31// افزایش عدد به اندازه ۱۰ (stage 3) 32func addTen(in \u0026lt;-chan int) \u0026lt;-chan int { 33\tout := make(chan int, 2) 34\tgo func() { 35\tdefer close(out) 36\tfor n := range in { 37\tout \u0026lt;- n + 10 38\t} 39\t}() 40\treturn out 41} 42 43func main() { 44\t// ساخت خط لوله با چندین مرحله 45\tstage1 := gen(2, 3, 5, 7) 46\tstage2 := sq(stage1) 47\tstage3 := addTen(stage2) 48 49\t// مصرف تمام خروجی pipeline 50\tfor v := range stage3 { 51\tfmt.Println(v) 52\t} 53} 1$ go run main.go 214 319 435 559 در این مثال، یک خط لوله (Pipeline) همزمانی واقعی و کاملاً idiomatic در زبان Go پیاده‌سازی شده است که چندین مرحله (stage) پردازشی را به صورت مستقل و موازی اجرا می‌کند. هر مرحله‌ی این pipeline یک تابع جداگانه است که داده‌های دریافتی از مرحله قبلی را از یک کانال (channel) می‌گیرد، عملیات مورد نظر خود را روی هر داده انجام می‌دهد و نتیجه را به کانال خروجی ارسال می‌کند. این مدل باعث می‌شود هر بخش از پردازش بدون وابستگی به سرعت بخش دیگر و به صورت ایمن و concurrent اجرا شود.\nدر کد، ابتدا با تابع gen داده‌های اولیه (در اینجا ۲، ۳، ۵ و ۷) تولید و وارد یک کانال می‌شوند. سپس این داده‌ها به مرحله دوم (sq) ارسال می‌شوند که کار هر goroutine در این مرحله گرفتن عدد و بازگرداندن مربع آن است. خروجی مرحله دوم وارد مرحله سوم (addTen) می‌شود که به هر عدد، مقدار ۱۰ اضافه می‌کند. هر مرحله در یک goroutine مجزا و روی یک کانال بافر‌دار اجرا می‌شود که باعث افزایش performance و decoupling کامل مراحل می‌شود.\nدر انتها، یک حلقه‌ی ساده روی خروجی مرحله آخر (stage3) قرار می‌گیرد و تمام نتایج به ترتیب مصرف و چاپ می‌شوند. استفاده از حلقه و range روی کانال، مصرف امن، بدون بلاک شدن و بدون نگرانی از goroutine leak را تضمین می‌کند، چون با بسته شدن کانال، حلقه به طور خودکار خارج می‌شود. این ساختار بسیار منعطف و قابل توسعه است؛ می‌توان به راحتی مراحل بیشتری به pipeline افزود یا منطق هر مرحله را تغییر داد، بدون اینکه بخش‌های دیگر برنامه نیاز به تغییر داشته باشند. چنین معماری، مناسب سیستم‌های پردازش داده، real-time، ETL و سناریوهای تحلیل موازی و مقیاس‌پذیر است.\nیک مثال کاربردی دیگر\n9.4.12.4 کاربردها # مدیریت ترافیک و پردازش شبکه (Network Stream Processing):\nالگوی Pipeline به شما اجازه می‌دهد چندین اتصال شبکه (مثلاً درخواست‌های همزمان کاربران یا پیام‌های ورودی) را به صورت مرحله‌ای مدیریت کنید؛ به گونه‌ای که هر بسته یا پیام از مراحل مختلفی مانند خواندن، تجزیه (parse)، فیلتر (filter)، اعتبارسنجی (validation)، مسیریابی (routing)، و حتی رمزنگاری یا فشرده‌سازی عبور کند. این مدل به شدت در سرورهای proxy، load balancer و نرم‌افزارهای firewall کاربرد دارد. محاسبات چند مرحله‌ای و زنجیره‌ای (Multi-stage Computation):\nPipeline راهکاری عالی برای تقسیم محاسبات پیچیده به گام‌های ساده‌تر و مستقل است؛ به طوری که هر مرحله روی بخشی از داده یا نتیجه مرحله قبل کار کند. برای مثال: تولید داده خام → پاک‌سازی → تبدیل فرمت → محاسبات عددی یا آماری → تجمیع نهایی. این ساختار کارایی و خوانایی برنامه را افزایش و توسعه آن را آسان‌تر می‌کند. پردازش و تحلیل گزارش‌ها (Log Processing \u0026amp; ETL):\nدر سامانه‌های جمع‌آوری و تحلیل لاگ یا داده‌های گزارش، می‌توان داده‌ها را به صورت جریان پیوسته از مراحل مختلف عبور داد؛ مثلاً ابتدا فیلترکردن داده‌های نامربوط، سپس تجزیه (parse) رکوردها، enrich کردن با داده‌های خارجی (مانند geoip)، و در نهایت ذخیره‌سازی یا index برای جستجو. این روش پایه معماری‌های ETL، سامانه‌های لاگ توزیع‌شده (ELK، Loki، \u0026hellip;)، و data lakeها است. تجزیه و تحلیل داده‌های بزرگ (Big Data \u0026amp; Real-Time Analytics):\nدر پروژه‌های داده‌محور، Pipeline ابزاری کلیدی برای اجرای زنجیره‌ای عملیات روی داده‌های حجیم است؛ مانند فیلترکردن داده‌ها، map/reduce، تبدیل ویژگی‌ها (feature engineering)، استخراج اطلاعات، و ساخت گزارش‌های لحظه‌ای یا ذخیره در بانک داده. این مدل به پردازش موازی، افزایش throughput و مقیاس‌پذیری سامانه کمک می‌کند. پردازش فایل و تصویر:\nدر بسیاری از سرویس‌های backend، فایل‌ها یا تصاویر آپلودشده می‌توانند به صورت pipeline پردازش شوند: خواندن فایل → decode → resize/crop → تبدیل فرمت → اعمال واترمارک → ذخیره‌سازی یا آپلود به سرویس دیگر. "},{"id":215,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-subscription/","title":"9.4.13 الگو Subscription","section":"9.4 الگوهای همزمانی","content":" 9.4.13.1 توضیحات # الگوی Subscription (یا Pub-Sub / Observer Pattern) یکی از پرکاربردترین الگوها در معماری‌های رویداد-محور و همزمان (event-driven \u0026amp; concurrent) است که امکان ثبت‌نام (subscribe) یک یا چند مصرف‌کننده (consumer) را برای دریافت خودکار داده‌های جدید از یک منبع یا سرویس فراهم می‌کند. در این الگو، یک یا چند مصرف‌کننده به یک \u0026ldquo;آدرس\u0026rdquo; یا منبع اشتراک (مثلاً یک topic، کانال یا event source) متصل می‌شوند و هر زمان که داده یا رویداد جدیدی منتشر شد (publish)، اطلاعات به طور خودکار و بی‌نیاز از polling مکرر به همه‌ی مصرف‌کننده‌های عضو ارسال می‌شود.\nدر زبان Go، پیاده‌سازی Subscription اغلب با استفاده از channelها و goroutineها انجام می‌شود: یک goroutine به عنوان publisher وظیفه تولید و ارسال داده‌ها را دارد، و هر consumer می‌تواند با subscribe کردن (ثبت نام) در یک channel مشترک، داده‌های جدید را دریافت کند. این مدل به شما اجازه می‌دهد تا به سادگی چندین consumer را همزمان به یک منبع داده وصل کنید و مدیریت رویدادهای همزمان، صف‌های پیام (message queue)، بروزرسانی‌های لحظه‌ای، یا حتی سیستم‌های نوتیفیکیشن را به صورت concurrent و بدون بلاک شدن یا پیچیدگی زیاد پیاده‌سازی کنید.\nکاربردهای Subscription در Go بسیار گسترده است: از مدیریت پیام‌های real-time (مثل ارسال اعلان در اپلیکیشن‌ها)، اتصال میکروسرویس‌ها، پیاده‌سازی سیستم‌های event sourcing و message broker گرفته تا جمع‌آوری لاگ‌های زنده یا حتی مانیتورینگ سرویس‌های حیاتی. مزیت اصلی این الگو جداسازی کامل بین تولیدکننده و مصرف‌کننده (decoupling)، مقیاس‌پذیری، و سادگی توسعه و تست در معماری‌های concurrent و reactive است.\n9.4.13.2 دیاگرام # flowchart TD Publisher[Publisher / Source] Sub1[Subscriber 1] Sub2[Subscriber 2] SubN[Subscriber N] Topic[Channel / Topic] Publisher -- \"Publish Data\" --\u003e Topic Topic -- \"Push Update\" --\u003e Sub1 Topic -- \"Push Update\" --\u003e Sub2 Topic -- \"Push Update\" --\u003e SubN Sub1 -- \"Subscribe\" --\u003e Topic Sub2 -- \"Subscribe\" --\u003e Topic SubN -- \"Subscribe\" --\u003e Topic style Topic fill:#e2f0fc,stroke:#377dbf,stroke-width:2px style Publisher fill:#f5e8ff,stroke:#b486e5,stroke-width:2px style Sub1,Sub2,SubN fill:#e9fbe7,stroke:#6dc165,stroke-width:2px 9.4.13.3 نمونه کد # 1package main 2 3import ( 4\t\u0026#34;context\u0026#34; 5\t\u0026#34;encoding/json\u0026#34; 6\t\u0026#34;fmt\u0026#34; 7\t\u0026#34;io/ioutil\u0026#34; 8\t\u0026#34;log\u0026#34; 9\t\u0026#34;net/http\u0026#34; 10\t\u0026#34;os\u0026#34; 11\t\u0026#34;time\u0026#34; 12) 13 14const exampleAPIAddress = \u0026#34;https://random-data-api.com/api/stripe/random_stripe\u0026#34; 15 16type Card struct { 17\tId uint `json:\u0026#34;id\u0026#34;` 18\tUid string `json:\u0026#34;uid\u0026#34;` 19\tValidCard string `json:\u0026#34;valid_card\u0026#34;` 20\tToken string `json:\u0026#34;token\u0026#34;` 21\tInvalidCard string `json:\u0026#34;invalid_card\u0026#34;` 22\tMonth string `json:\u0026#34;month\u0026#34;` 23\tYear string `json:\u0026#34;year\u0026#34;` 24\tCCV string `json:\u0026#34;ccv\u0026#34;` 25\tCCVAmex string `json:\u0026#34;ccv_amex\u0026#34;` 26} 27 28type Subscription interface { 29\tUpdates() \u0026lt;-chan Card 30} 31 32type Fetcher interface { 33\tFetch() (Card, error) 34} 35 36type sub struct { 37\tfetcher Fetcher 38\tupdates chan Card 39} 40 41type fetcher struct { 42\turl string 43} 44 45type fetchResult struct { 46\tfetchedCard Card 47\terr error 48} 49 50// NewSubscription create subscription for fetch data per freq time in second 51func NewSubscription(ctx context.Context, fetcher Fetcher, freq uint) Subscription { 52\ts := \u0026amp;sub{ 53\tfetcher: fetcher, 54\tupdates: make(chan Card), 55\t} 56\tgo s.serve(ctx, freq) 57\treturn s 58} 59 60func NewFetcher(url string) Fetcher { 61\treturn \u0026amp;fetcher{ 62\turl: url, 63\t} 64} 65 66func (f *fetcher) Fetch() (Card, error) { 67\treturn requestAPI(f.url) 68} 69 70func (s *sub) serve(ctx context.Context, freq uint) { 71\tticker := time.NewTicker(time.Duration(freq) * time.Second) 72\tdone := make(chan fetchResult, 1) 73 74\tvar ( 75\tfetchedCard Card 76\tfetchResponseStream chan Card 77\tpending bool 78\t) 79 80\tfor { 81 82\tif pending { 83\tfetchResponseStream = s.updates 84\t} else { 85\tfetchResponseStream = nil 86\t} 87 88\tselect { 89\tcase \u0026lt;-ticker.C: 90\tif pending { 91\tbreak 92\t} 93\tgo func() { 94\tfetched, err := s.fetcher.Fetch() 95\tdone \u0026lt;- fetchResult{fetched, err} 96\t}() 97\tcase result := \u0026lt;-done: 98\tfetchedCard = result.fetchedCard 99\tif result.err != nil { 100\tlog.Printf(\u0026#34;fetch got error %v\u0026#34;, result.err) 101\tbreak 102\t} 103\tpending = true 104\tcase fetchResponseStream \u0026lt;- fetchedCard: 105\tpending = false 106\tcase \u0026lt;-ctx.Done(): 107\treturn 108\t} 109\t} 110} 111 112func (s *sub) Updates() \u0026lt;-chan Card { 113\treturn s.updates 114} 115 116func requestAPI(url string) (Card, error) { 117\tcard := Card{} 118\treq, err := http.NewRequest(http.MethodGet, url, nil) 119\tif err != nil { 120\treturn Card{}, err 121\t} 122\tres, err := http.DefaultClient.Do(req) 123\tif err != nil { 124\treturn Card{}, err 125\t} 126\tbody, err := ioutil.ReadAll(res.Body) 127\tif err != nil { 128\treturn Card{}, err 129\t} 130\tif err := json.Unmarshal(body, \u0026amp;card); err != nil { 131\treturn Card{}, err 132\t} 133\treturn card, nil 134} 135 136func main() { 137\tctx, cancel := context.WithCancel(context.Background()) 138\tsub := NewSubscription(ctx, NewFetcher(exampleAPIAddress), 3) 139 140\ttime.AfterFunc(1*time.Minute, func() { 141\tcancel() 142\tlog.Println(\u0026#34;canceled subscription task\u0026#34;) 143\tos.Exit(0) 144\t}) 145 146\tfor card := range sub.Updates() { 147\tfmt.Println(card) 148\t} 149} 1$ go run main.go 2{4643 add2475a-ed64-4039-831d-0e95469752d9 371449635398431 tok_mastercard_debit 4000000000000101 01 2024 920 7875} 3{6992 a89e3d71-785a-4d37-9639-be3ce7534257 2223003122003222 tok_discover 4000000000000069 11 2024 660 5241} 4{9287 f665526e-1b34-46f5-9d9d-50362631ed0f 5200828282828210 tok_mastercard_debit 4000000000000036 05 2026 993 6272} 5{4956 e8ae8e75-0ff2-42e8-921c-5cc438d64fac 3566002020360505 tok_amex 4000000000000044 10 2024 371 9989} 6{1193 954d1b36-829b-4726-bbb7-0f5f01b3dd40 6011000990139424 tok_mastercard_debit 4000000000000341 12 2026 331 5119} در این مثال، ابتدا یک اینترفیس به نام Subscription تعریف شده است که متدی به نام Updates دارد و کانالی از نوع Card را برمی‌گرداند. این کانال نقش مسیر ارتباطی را بین تولیدکننده و مصرف‌کننده ایفا می‌کند، به طوری که مصرف‌کننده می‌تواند به طور همزمان و غیرمسدود داده‌های جدید را دریافت کند. همچنین اینترفیس Fetcher طراحی شده که وظیفه‌ی فراخوانی API و دریافت داده‌ها را بر عهده دارد و متد Fetch را ارائه می‌دهد. این تفکیک وظایف باعث می‌شود کد قابلیت توسعه و تست بیشتری داشته باشد.\nتابع NewSubscription به عنوان سازنده Subscription عمل می‌کند؛ این تابع یک struct از نوع sub ایجاد می‌کند که حاوی fetcher و یک کانال updates است. سپس متد serve به صورت یک goroutine اجرا می‌شود تا عملیات fetch را در فواصل زمانی مشخص (که با پارامتر freq تعیین می‌شود) تکرار کند. درون این متد از time.Ticker برای زمان‌بندی دقیق استفاده شده است تا به صورت منظم و بدون ایجاد سربار اضافی، داده‌ها را از API فراخوانی کند و در صورت دریافت موفقیت‌آمیز، آن‌ها را در کانال منتشر نماید. همچنین با کمک متغیر pending اطمینان حاصل می‌شود که یک fetch جدید تا قبل از اتمام fetch قبلی آغاز نشود، بنابراین از فشار بیش از حد به سرویس جلوگیری می‌شود.\nمصرف‌کنندگان داده‌ها از طریق متد Updates به کانال updates دسترسی دارند و به محض دریافت داده‌های جدید، می‌توانند پردازش خود را آغاز کنند. استفاده از context.Context در این ساختار اجازه می‌دهد که در هر زمان عملیات fetch به صورت ایمن لغو شود و goroutine مربوطه به سرعت و بدون باقی ماندن در حالت بلاک‌شده خاتمه یابد. این طراحی باعث می‌شود که برنامه همزمانی بهینه‌ای داشته باشد، منابع به خوبی مدیریت شود و کد قابلیت خوانایی، توسعه و تست آسان را حفظ کند.\nدر کل، این الگو ترکیبی از بهترین شیوه‌های Go در مدیریت جریان داده‌های ناهمزمان، کنترل concurrency و ارتباط بین goroutineها است که برای دریافت داده‌های زنده از API یا منابع خارجی بسیار مناسب است. با چنین معماری می‌توان سیستم‌هایی تولید کرد که علاوه بر مقیاس‌پذیری بالا، مقاوم در برابر خطا و قابل کنترل نیز باشند.\n9.4.13.4 کاربردها # دریافت اطلاعات از تولیدکننده‌ها (Publisher) یا سیستم‌های Pub/Sub:\nالگوی Subscription به شما این امکان را می‌دهد که به سادگی به یک یا چند منبع داده (مانند سرویس‌های پیام‌رسان، سیستم‌های صف پیام، یا هر منبعی که به صورت publish/subscribe کار می‌کند) متصل شوید و داده‌های جدید را به صورت همزمان و غیرمسدود دریافت کنید. این کار باعث می‌شود مصرف‌کننده‌ها به صورت real-time یا نزدیک به real-time اطلاعات را دریافت و پردازش نمایند و از پیچیدگی‌های مدیریت اتصال یا polling مکرر بی‌نیاز شوند. همگام‌سازی داده‌ها از APIهای خارجی:\nدر بسیاری از برنامه‌ها نیاز است داده‌ها یا وضعیت از سرویس‌های خارجی (مانند RESTful APIها، سرویس‌های ابری یا سیستم‌های تحلیلی) به صورت دوره‌ای یا بر اساس رویداد به‌روزرسانی شوند. الگوی Subscription این امکان را فراهم می‌کند که بتوانید با تعریف یک سازوکار هوشمند برای دریافت به‌روزرسانی‌ها، مصرف داده‌ها را ساده، پایدار و بهینه کنید. این الگو به خصوص در سناریوهای real-time dashboards، اطلاع‌رسانی لحظه‌ای و هماهنگ‌سازی داده‌های توزیع‌شده کاربرد فراوان دارد. "},{"id":216,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-brdige-channel/","title":"9.4.14 الگو Bridge Channel","section":"9.4 الگوهای همزمانی","content":" 9.4.14.1 توضیحات # الگوی Bridge Channel یکی از الگوهای ساده اما بسیار مفید در زبان Go است که امکان اتصال و انتقال داده بین دو یا چند کانال مستقل را فراهم می‌کند. این الگو زمانی کاربرد دارد که بخواهید داده‌های تولیدشده در یک goroutine یا زیرسیستم را پس از دریافت، به کانال دیگری هدایت کنید؛ به عبارتی، مانند یک پل (bridge) عمل می‌کنید که داده‌ها را از یک کانال ورودی گرفته و به کانال خروجی منتقل می‌نماید.\nدر عمل، یک goroutine بین دو کانال قرار می‌گیرد: یکی برای دریافت (مثلاً in \u0026lt;-chan T) و دیگری برای ارسال (out chan\u0026lt;- T). این goroutine یک حلقه ساده for با range in اجرا می‌کند و هر مقداری که از کانال ورودی دریافت کند را بلافاصله به کانال خروجی می‌فرستد. این تکنیک برای decoupling بین تولیدکننده و مصرف‌کننده عالی است و در سناریوهایی مانند اتصال چند مرحله pipeline، تغییر مسیر داده‌ها، فیلترینگ داده‌ها یا حتی انتقال بین کانال‌هایی با ویژگی‌های متفاوت (مثلاً بافر متفاوت یا ownership مختلف) بسیار کاربرد دارد.\nاز مزایای این الگو می‌توان به سادگی در پیاده‌سازی، انعطاف‌پذیری بالا، و جداسازی مسئولیت‌ها اشاره کرد. این الگو به خصوص در سیستم‌هایی که نیاز به پردازش یا هدایت جریان‌های داده بین چند بخش یا ماژول دارند، بسیار مؤثر است و به افزایش خوانایی و maintainability کد کمک می‌کند. در صورت نیاز می‌توان عملیات اضافی مثل تبدیل داده، اعتبارسنجی یا لاگ‌گیری را نیز داخل goroutine پل انجام داد تا ساختار تمیزتر باقی بماند.\n9.4.14.2 دیاگرام # flowchart LR A[Producer / Input Source] B[Input Channel] C[Bridge Goroutine] D[Output Channel] E[Consumer / Output Sink] A --\u003e B B --\u003e C C --\u003e D D --\u003e E style B fill:#e2f0fc,stroke:#377dbf,stroke-width:2px style D fill:#e2f0fc,stroke:#377dbf,stroke-width:2px style C fill:#fff0cc,stroke:#e69e00,stroke-width:2px style A fill:#e6ffe6,stroke:#42b983,stroke-width:2px style E fill:#fce4ec,stroke:#e91e63,stroke-width:2px 9.4.17.3 نمونه کد # 1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7// bridge بین input و output قرار می‌گیرد و داده‌ها را منتقل می‌کند. 8func bridge(input \u0026lt;-chan int, output chan\u0026lt;- int) { 9\tfor val := range input { 10\toutput \u0026lt;- val 11\t} 12\tclose(output) 13} 14 15func main() { 16\tinput := make(chan int) 17\toutput := make(chan int) 18 19\t// اجرای پل انتقال داده در یک goroutine جدا 20\tgo bridge(input, output) 21 22\t// ارسال چند داده به کانال input 23\tgo func() { 24\tfor i := 1; i \u0026lt;= 3; i++ { 25\tinput \u0026lt;- i 26\t} 27\tclose(input) 28\t}() 29 30\t// دریافت داده‌ها از کانال output 31\tfor val := range output { 32\tfmt.Println(\u0026#34;Received:\u0026#34;, val) 33\t} 34} 1$ go run main.go 2Received: 1 3Received: 2 4Received: 3 در این مثال، ما پیاده‌سازی بهبودیافته‌ای از الگوی Bridge Channel در زبان Go را مشاهده می‌کنیم؛ الگویی که هدف آن اتصال دو کانال (input و output) از طریق یک goroutine واسط (bridge) است. این واسط به صورت شفاف داده‌ها را از یک کانال می‌خواند و به کانال دیگری منتقل می‌کند، به‌گونه‌ای که بخش‌های تولید (Producer) و مصرف (Consumer) بتوانند بدون وابستگی مستقیم به یکدیگر کار کنند.\nدر ابتدای برنامه، دو کانال input و output تعریف می‌شوند. سپس تابعی به نام bridge ایجاد شده که به عنوان واسطه عمل می‌کند. این تابع در یک goroutine اجرا شده و با استفاده از یک حلقه for val := range input، تا زمانی که کانال input باز است، مقادیر را دریافت می‌کند و آن‌ها را بلافاصله در کانال output می‌نویسد. پس از بسته شدن input، تابع bridge نیز با بستن output خاتمه می‌یابد؛ این یک الگوی بسیار ایمن و idiomatic در Go برای جلوگیری از goroutine leak است.\nدر بخش main، یک goroutine دیگر وظیفه ارسال داده به input را بر عهده دارد. در اینجا، مقادیر ۱ تا ۳ به input ارسال شده و سپس کانال بسته می‌شود. در انتها، از یک حلقه for val := range output استفاده شده تا داده‌های منتقل‌شده به output دریافت و چاپ شوند. این ساختار به گونه‌ای طراحی شده که پس از اتمام پردازش، برنامه به صورت تمیز و بدون بلاک شدن به پایان می‌رسد.\nاین مدل نه‌تنها پایه‌ای برای سیستم‌های streaming و pipeline است، بلکه برای ساختاردهی بهتر به معماری‌های همزمان، decoupling اجزا، و افزایش انعطاف‌پذیری و توسعه‌پذیری کد بسیار مناسب است.\n9.4.18.4 کاربردها # انتقال داده بین مراحل مختلف در خط لوله‌های داده اتصال میان دو زیرسیستم که از لحاظ طراحی جدا شده‌اند بافر کردن بین تولیدکننده سریع و مصرف‌کننده کند (یا بالعکس) تغییر مسیر جریان داده‌ها (مثلاً برای logging یا debug) کنترل جریان بین سرویس‌های مختلف در معماری microservice "},{"id":217,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-queuing/","title":"9.4.15 الگو Queuing","section":"9.4 الگوهای همزمانی","content":" 9.4.15.1 توضیحات # الگوی صف (Queue Pattern) در زبان Go، الگویی است که در آن با استفاده از یک goroutine مرکزی و یک یا چند کانال ورودی و خروجی، داده‌ها را به صورت منظم، به ترتیب ورود (FIFO) مدیریت می‌کند. در این الگو، برخلاف استفاده مستقیم از کانال که ممکن است ترتیب یا بافر محدودی داشته باشد، یک گوروتین به عنوان صف درون‌ساخت (in-memory queue) عمل می‌کند و داده‌های دریافتی از کانال ورودی را در یک ساختار صف مانند (مانند slice) نگه می‌دارد، سپس بر اساس منطق زمان‌بندی یا در دسترس بودن مصرف‌کننده، آن‌ها را به کانال خروجی ارسال می‌کند.\nهدف اصلی این الگو، کنترل جریان (flow control) و جداسازی سرعت تولید و مصرف داده‌ها است. برای مثال، اگر producer داده را با سرعت بالایی ارسال کند ولی consumer نتواند به همان سرعت پردازش کند، صف می‌تواند به عنوان بافر موقت بین این دو عمل کند. این کار از بلاک شدن producer جلوگیری کرده و سیستم را پایدار نگه می‌دارد. همچنین، چون داده‌ها در یک ساختار مشخص ذخیره می‌شوند، می‌توان بر ترتیب دریافت، اولویت‌بندی، یا حتی سیاست‌های پردازش (مثل batch processing) نیز کنترل داشت.\nاین الگو در طراحی سیستم‌های message queue، task queue، buffering systems و job dispatcher بسیار رایج است. به‌ویژه زمانی که لازم باشد چندین درخواست به صف وارد شده و بر اساس اولویت یا نوبت پردازش شوند، یا بین سرعت‌های نامتوازن تولید و مصرف تطابق ایجاد شود. الگوی صف در Go، با کمک ترکیب ساده‌ای از goroutine + channel + slice، یک راهکار سبک، قابل‌اتکا و توسعه‌پذیر برای این سناریوها ارائه می‌دهد.\n9.4.15.2 دیاگرام # flowchart LR Producer1[Producer 1] --\u003e IN[Input Channel] Producer2[Producer 2] --\u003e IN IN --\u003e Q[Queue Goroutine Buffered with slice] Q --\u003e OUT[Output Channel] OUT --\u003e Consumer1[Consumer 1] OUT --\u003e Consumer2[Consumer 2] style IN fill:#d0e8ff,stroke:#2980b9,stroke-width:2px style OUT fill:#d0e8ff,stroke:#2980b9,stroke-width:2px style Q fill:#fff0cc,stroke:#e67e00,stroke-width:2px style Producer1,Producer2 fill:#e6ffe6,stroke:#27ae60,stroke-width:2px style Consumer1,Consumer2 fill:#fde2e2,stroke:#c0392b,stroke-width:2px 9.4.15.3 نمونه کد # 1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;time\u0026#34; 6) 7 8func main() { 9\tenqueue := make(chan int) // کانال برای دریافت داده‌های جدید 10\tdequeue := make(chan int) // کانال برای ارسال داده به مصرف‌کننده 11\tdone := make(chan struct{}) // کانال برای پایان اجرای برنامه 12 13\t// Goroutine صف: مسئول بافر و انتقال داده‌ها به ترتیب 14\tgo func() { 15\tvar queue []int 16\tfor { 17\tvar first int 18\tvar out chan int 19 20\tif len(queue) \u0026gt; 0 { 21\tfirst = queue[0] 22\tout = dequeue 23\t} 24 25\tselect { 26\tcase item := \u0026lt;-enqueue: 27\tqueue = append(queue, item) 28\tfmt.Println(\u0026#34;Enqueued:\u0026#34;, item) 29\tcase out \u0026lt;- first: 30\tqueue = queue[1:] 31\tcase \u0026lt;-done: 32\tclose(dequeue) 33\treturn 34\t} 35\t} 36\t}() 37 38\t// Producer: ارسال ۱۰ مقدار به صف 39\tgo func() { 40\tfor i := 0; i \u0026lt; 10; i++ { 41\tenqueue \u0026lt;- i 42\ttime.Sleep(100 * time.Millisecond) 43\t} 44\t// پایان 45\ttime.Sleep(1 * time.Second) 46\tdone \u0026lt;- struct{}{} 47\t}() 48 49\t// Consumer: دریافت مقادیر به ترتیب 50\tfor item := range dequeue { 51\tfmt.Println(\u0026#34;Dequeued:\u0026#34;, item) 52\t} 53} 1$ go run main.go 2Enqueued: 0 3Dequeued: 0 4Enqueued: 1 5Dequeued: 1 6Enqueued: 2 7Dequeued: 2 8Enqueued: 3 9Dequeued: 3 10Enqueued: 4 11Dequeued: 4 12Enqueued: 5 13Dequeued: 5 14Enqueued: 6 15Dequeued: 6 16Enqueued: 7 17Dequeued: 7 18Enqueued: 8 19Dequeued: 8 20Enqueued: 9 21Dequeued: 9 در این مثال ما سه کانال داریم: enqueue برای وارد کردن آیتم‌ها به صف، dequeue برای خارج کردن آیتم‌ها از صف، و done برای پایان دادن به اجرای برنامه. این ساختار به ما اجازه می‌دهد یک صف ساده ولی همزمان و thread-safe را با استفاده از ویژگی‌های زبان Go پیاده‌سازی کنیم.\nیک goroutine اصلی مسئول مدیریت صف است. این goroutine یک queue از نوع []int نگه می‌دارد که همان بافر داخلی صف ماست. درون یک حلقه بی‌نهایت، ابتدا بررسی می‌شود که آیا صف خالی نیست. اگر خالی نبود، مقدار اول صف (first = queue[0]) برای ارسال آماده می‌شود و کانال out برابر dequeue قرار می‌گیرد. در غیر این صورت، مقدار out خالی می‌ماند و بنابراین حالت ارسال انجام نخواهد شد.\nسپس با select سه حالت بررسی می‌شود. اگر آیتم جدیدی از طریق enqueue وارد شود، به انتهای صف اضافه می‌شود. اگر صف خالی نباشد و dequeue آمادگی دریافت داشته باشد (out \u0026lt;- first)، مقدار اول صف به مصرف‌کننده ارسال می‌شود و از صف حذف می‌شود (queue = queue[1:]). اگر سیگنالی از done برسد، یعنی برنامه باید پایان یابد؛ در این صورت کانال dequeue بسته می‌شود و goroutine متوقف می‌شود.\nدر بخش Producer، یک goroutine جدید راه‌اندازی می‌شود که در آن با استفاده از یک حلقه for از ۰ تا ۹ مقدار تولید می‌شود و هر مقدار از طریق enqueue وارد صف می‌شود. بعد از پایان تولید داده‌ها، یک ثانیه صبر می‌کند و سپس سیگنال done ارسال می‌شود تا صف به طور مرتب بسته شود.\nدر نهایت، حلقه for item := range dequeue در تابع اصلی (main) نقش Consumer را بازی می‌کند. این حلقه از روی کانال dequeue آیتم‌ها را دریافت می‌کند و چاپ می‌کند. از آنجا که این حلقه تا زمان بسته شدن کانال ادامه دارد، به‌صورت خودکار پس از رسیدن سیگنال done و بسته شدن dequeue، خاتمه می‌یابد.\nدر مجموع، این کد پیاده‌سازی بسیار مناسبی از صف همزمان (synchronized queue) در زبان Go است که از مزیت‌های goroutineها و channelها برای جداسازی concerns و مدیریت همزمانی بهره برده. طراحی آن بسیار ایمن، ساده و مقیاس‌پذیر است و به‌خوبی نشان می‌دهد چگونه می‌توان سیستم‌هایی با تولیدکننده و مصرف‌کننده را بدون نیاز به lock و mutex ساخت.\n9.4.15.4 کاربردها # زمان‌بندی وظایف (Task Scheduling):\nاز کانال به‌عنوان صف وظایف (task queue) استفاده می‌شود تا وظایف تولیدشده از سوی گوروتین‌های مختلف، به گوروتین‌های worker برای اجرا سپرده شوند. این الگو برای پیاده‌سازی worker pool بسیار رایج است و باعث می‌شود وظایف به ترتیبی که وارد کانال می‌شوند پردازش شوند، بدون نیاز به مدیریت پیچیده‌ی همزمانی با mutex. بافر کردن داده‌ها (Buffering Input Data):\nدر مواقعی که نرخ ورود داده‌ها بیشتر از نرخ پردازش است، یک کانال بافر‌دار می‌تواند به‌عنوان صف موقت برای ذخیره‌ی داده‌ها استفاده شود. این کمک می‌کند فشار از روی گوروتینی که داده را مصرف می‌کند برداشته شود و از data loss یا race conditions جلوگیری شود. محدودسازی نرخ (Throttling/Rate Limiting):\nکانال با ظرفیت مشخص می‌تواند برای کنترل نرخ پردازش به کار رود. اگر گوروتین مصرف‌کننده کند عمل کند و کانال پر شود، گوروتین تولیدکننده تا زمان آزاد شدن بافر مسدود می‌ماند. این یک روش ساده و کارآمد برای جلوگیری از overload شدن سیستم در شرایط پرترافیک است. مدیریت گزارش‌ها (Asynchronous Logging):\nاستفاده از یک کانال به‌عنوان صف برای ثبت گزارش‌ها (logs) باعث می‌شود عملیات نوشتن گزارش (که ممکن است کند باشد) گوروتین‌های دیگر را متوقف نکند. گوروتینی که مسئول نوشتن گزارش است پیام‌ها را به ترتیب از کانال دریافت می‌کند و در فایل یا خروجی شبکه ذخیره می‌کند، بدون اینکه نیاز به قفل یا ساختار همزمانی پیچیده داشته باشد. همزمانی امن بین گوروتین‌ها (Safe Inter-Goroutine Communication):\nکانال‌ها راهی امن و idiomatic برای تبادل داده بین گوروتین‌ها هستند. استفاده از آن‌ها به‌عنوان صف، امکان پیاده‌سازی سیستم‌هایی مانند pipeline processing، fan-in/fan-out یا load balancing را به سادگی فراهم می‌کند، بدون نیاز به primitives سطح پایین‌تر مثل mutex یا condition variable. "},{"id":218,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-ratelimit/","title":"9.4.16 الگو Rate limit","section":"9.4 الگوهای همزمانی","content":" 9.4.16.1 توضیحات # الگوی Rate Limiting یا \u0026ldquo;محدودسازی نرخ درخواست\u0026rdquo; یکی از الگوهای پرکاربرد برای کنترل ترافیک ورودی یا پردازش عملیات در سیستم‌های نرم‌افزاری است. هدف اصلی این الگو، جلوگیری از اجرای بیش از حد عملیات در یک بازه‌ی زمانی مشخص است تا از بارگذاری بیش از حد سیستم، نقض محدودیت‌های منابع خارجی (مثل APIها)، یا سوءاستفاده از سرویس جلوگیری شود. این الگو در سرویس‌هایی که به منابع محدود یا خارجی متصل‌اند—مثل وب‌سرویس‌ها، میکروسرویس‌ها، API گیت‌وی‌ها یا سیستم‌های صف پردازش—به‌شدت حیاتی است.\nدر زبان Go، یکی از ساده‌ترین روش‌های پیاده‌سازی این الگو استفاده از time.Ticker است. این نوعی تایمر است که در فواصل زمانی منظم سیگنالی را از طریق کانال ارسال می‌کند. با قرار دادن منطق پردازش درون حلقه‌ای که روی این کانال می‌چرخد، می‌توان کاری کرد که اجرای هر عملیات فقط هنگام دریافت سیگنال مجاز باشد. مثلاً اگر یک ticker هر ۲۰۰ میلی‌ثانیه سیگنال بفرستد، در نتیجه فقط ۵ بار در ثانیه عملیات اجرا خواهد شد. به این ترتیب نرخ اجرا به شکل دقیق و منظم کنترل می‌شود.\nمزیت این روش در سادگی و کارآمدی آن است، به‌خصوص برای سناریوهای سبک تا متوسط. اما در شرایط پیچیده‌تر، ممکن است نیاز به الگوهای پیشرفته‌تری مانند Token Bucket یا Leaky Bucket باشد که انعطاف‌پذیری بیشتری برای burstهای ناگهانی، اولویت‌بندی یا بازتوزیع ظرفیت فراهم می‌کنند. همچنین در سیستم‌های توزیع‌شده، برای اعمال محدودیت به صورت مرکزی یا سراسری (distributed rate limiting)، باید از ابزارهایی مثل Redis، Nginx، یا سرویس‌های ابری (مثل Cloudflare یا AWS API Gateway) استفاده کرد.\nدر نهایت، الگوی Rate Limiting به عنوان یک تکنیک دفاعی و پایدارسازی سیستم، باید بخشی جدانشدنی از معماری‌ سیستم‌های تولیدی باشد—چه در قالب محدودسازی ساده در سطح goroutineها، و چه به‌صورت سیاست‌های سازمان‌یافته در کل سیستم.\n9.4.16.2 دیاگرام # graph TD subgraph Client A[ارسال درخواست] end subgraph Rate Limiter Ticker B[دریافت تیک از time.Ticker] C{آیا درخواست جدیدی هست؟} end subgraph Worker D[پردازش درخواست] end A --\u003e|درخواست به صف| C B --\u003e C C --\u003e|بله| D C --\u003e|خیر| B D --\u003e B 9.4.16.3 نمونه کد # 1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;time\u0026#34; 6) 7 8func processRequest(id int) { 9\tfmt.Printf(\u0026#34;✅ Processed request %d at %s\\n\u0026#34;, id, time.Now().Format(\u0026#34;15:04:05\u0026#34;)) 10} 11 12func main() { 13\tconst maxRequests = 10 14\tconst rateLimit = time.Second // یک درخواست در هر ثانیه 15 16\tticker := time.NewTicker(rateLimit) 17\tdefer ticker.Stop() 18 19\trequests := make(chan int) 20 21\t// Producer: ارسال درخواست‌ها با فاصله زمانی (مثلاً هر 300ms) 22\tgo func() { 23\tfor i := 1; i \u0026lt;= maxRequests; i++ { 24\trequests \u0026lt;- i 25\ttime.Sleep(300 * time.Millisecond) // simulate incoming traffic 26\t} 27\tclose(requests) 28\t}() 29 30\t// Consumer با Rate Limiting 31\tfor req := range requests { 32\t\u0026lt;-ticker.C // اجازه پردازش فقط هر یک ثانیه یکبار 33\tprocessRequest(req) 34\t} 35} 1$ go run main.go 2✅ Processed request 1 at 23:00:01 3✅ Processed request 2 at 23:00:02 4✅ Processed request 3 at 23:00:03 5✅ Processed request 4 at 23:00:04 6✅ Processed request 5 at 23:00:05 7✅ Processed request 6 at 23:00:06 8✅ Processed request 7 at 23:00:07 9✅ Processed request 8 at 23:00:08 10✅ Processed request 9 at 23:00:09 11✅ Processed request 10 at 23:00:10 در این مثال، پیاده‌سازی ساده‌ای از الگوی Rate Limiting در زبان Go با استفاده از time.Ticker نمایش داده شده است. هدف این کد آن است که اجازه دهد درخواست‌ها (در اینجا اعداد ۱ تا ۱۰) تنها با نرخ یک درخواست در هر ثانیه پردازش شوند. این کار برای جلوگیری از فشار زیاد بر روی سیستم یا رعایت محدودیت‌های خارجی بسیار رایج است.\nابتدا یک ticker با بازه‌ی زمانی یک ثانیه ساخته می‌شود. این ticker در هر ثانیه یک سیگنال روی کانال C خودش ارسال می‌کند. در همین حال، یک goroutine به عنوان تولیدکننده (Producer) تعریف شده که اعداد ۱ تا ۱۰ را بدون تأخیر وارد یک کانال requests می‌کند و سپس آن را می‌بندد. این کانال مانند یک صف عمل می‌کند.\nدر بخش مصرف‌کننده (Consumer)، که در main اجرا می‌شود، یک حلقه از روی requests می‌چرخد. قبل از پردازش هر درخواست، برنامه منتظر سیگنال از ticker.C می‌ماند. به این معنی که هر درخواست دقیقاً با فاصله‌ی زمانی یک ثانیه پردازش می‌شود. این مکانیزم باعث می‌شود اگر درخواست‌ها خیلی سریع وارد صف شوند، باز هم فقط با سرعت مجاز (در این مثال ۱ بر ثانیه) اجرا شوند.\nدر نهایت، تابع processRequest تنها مسئول چاپ شماره‌ی درخواست همراه با زمان اجرای آن است. این پیاده‌سازی اگرچه ساده است، اما پایه‌ای بسیار مناسب برای توسعه‌ی نسخه‌های پیشرفته‌تر مانند کنترل burst، توقف سریع با context، یا پیاده‌سازی توزیع‌شده فراهم می‌کند.\n9.4.16.4 کاربردها # Throttling API Calls: در زمانی که شما نیاز دارید درخواست‌های API را محدود کنید تا از محدودیت‌های تعیین‌شده توسط ارائه‌دهنده API تجاوز نکنید. کنترل بار سیستم: برای جلوگیری از استفاده بیش از حد از منابع سیستم، مانند پردازنده یا پایگاه داده. پردازش داده‌های ورودی: زمانی که داده‌های ورودی بسیار سریع‌تر از ظرفیت پردازش وارد می‌شوند، این الگو می‌تواند سرعت پردازش را مدیریت کند. زمان‌بندی رویدادها: برای انجام عملیات در فواصل زمانی معین مانند ارسال ایمیل‌های گروهی. "},{"id":219,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-deadlock-recovery/","title":"9.4.17 الگو Deadlock Recovery","section":"9.4 الگوهای همزمانی","content":" 9.4.17.1 توضیحات # الگوی بازیابی از بن‌بست (Deadlock Recovery) یکی از الگوهای مهم در طراحی سیستم‌های همزمان (concurrent systems) است که به ما کمک می‌کند از شرایطی خطرناک به نام بن‌بست (deadlock) خارج شویم. در شرایط بن‌بست، دو یا چند گوروتین (یا نخ) در حالتی گیر می‌افتند که هر یک منتظر آزاد شدن منبعی است که توسط دیگری نگه داشته شده؛ در نتیجه هیچ‌کدام نمی‌توانند پیش بروند و کل سیستم در حالت توقف (freeze) باقی می‌ماند.\nدر زبان Go، به دلیل استفاده گسترده از goroutine و channel، احتمال وقوع بن‌بست در اثر طراحی نادرست بالا است. مثلاً اگر گوروتینی منتظر داده روی یک کانال بماند، در حالی که گوروتین ارسال‌کننده هرگز اجرا نشود یا مسدود شده باشد، بن‌بست اتفاق می‌افتد. در سیستم‌های واقعی، تشخیص و بازیابی از این وضعیت حیاتی است تا سیستم به‌صورت پیوسته و قابل اطمینان باقی بماند.\nالگوی Deadlock Recovery معمولاً شامل سه مرحله است:\n۱. نظارت (Monitoring): سیستم باید به‌صورت مداوم وضعیت گوروتین‌ها یا منابع مشترک را بررسی کند. این کار می‌تواند با استفاده از تایم‌اوت، لاگ‌گیری، یا ابزارهای profiler مانند pprof انجام شود.\n۲. تشخیص (Detection): با تجزیه‌وتحلیل رفتار سیستم، مانند گوروتین‌هایی که برای مدت طولانی در حالت مسدود باقی مانده‌اند، می‌توان بن‌بست‌های احتمالی را شناسایی کرد.\n۳. بازیابی (Recovery): پس از تشخیص، می‌توان با یکی از روش‌های زیر اقدام به آزادسازی سیستم کرد:\nتلاش مجدد با backoff (بازگشت نمایی یا تصادفی) بازتنظیم منابع یا صف‌ها خاتمه دادن به گوروتین‌های مسدودشده بازگردانی سیستم به حالت اولیه یا fail-safe این الگو به‌ویژه در برنامه‌های distributed یا دارای state حساس مانند تراکنش‌های مالی، سیستم‌های صف (queue-based systems)، یا پایگاه‌داده‌های درون‌حافظه‌ای اهمیت دارد. اجرای صحیح این الگو باعث حفظ پایداری سیستم در برابر شرایط غیرمنتظره می‌شود، در حالی که غفلت از آن ممکن است به اختلال جدی یا از دست رفتن داده‌ها منجر شود.\n9.4.17.2 دیاگرام # sequenceDiagram participant Main participant G1 as Goroutine 1 participant G2 as Goroutine 2 participant DeadlockChecker as Select with Timeout Main-\u003e\u003eG1: Start Main-\u003e\u003eG2: Start G1-\u003e\u003emu1: Lock(mu1) G2-\u003e\u003emu2: Lock(mu2) G1-\u003e\u003emu2: Try Lock(mu2) ❌ G2-\u003e\u003emu1: Try Lock(mu1) ❌ Note over G1,G2: بن‌بست (Deadlock) ایجاد شد: G1 منتظر mu2، G2 منتظر mu1 DeadlockChecker-\u003e\u003eDeadlockChecker: wait 3s... DeadlockChecker--\u003e\u003eMain: بن‌بست شناسایی شد ✅ 9.4.17.3 نمونه کد # 1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;sync\u0026#34; 6\t\u0026#34;time\u0026#34; 7) 8 9func deadlockRecoveryExample() { 10\tvar mu1, mu2 sync.Mutex 11\tdone := make(chan string, 2) 12 13\t// گوروتین اول: تلاش برای گرفتن mu1 سپس mu2 14\tgo func() { 15\tmu1.Lock() 16\tfmt.Println(\u0026#34;G1: mu1 locked\u0026#34;) 17\ttime.Sleep(1 * time.Second) 18 19\tmu2.Lock() 20\tfmt.Println(\u0026#34;G1: mu2 locked\u0026#34;) 21\ttime.Sleep(500 * time.Millisecond) 22 23\tmu2.Unlock() 24\tmu1.Unlock() 25\tdone \u0026lt;- \u0026#34;G1: done\u0026#34; 26\t}() 27 28\t// گوروتین دوم: تلاش برای گرفتن mu2 سپس mu1 29\tgo func() { 30\tmu2.Lock() 31\tfmt.Println(\u0026#34;G2: mu2 locked\u0026#34;) 32\ttime.Sleep(1 * time.Second) 33 34\tmu1.Lock() 35\tfmt.Println(\u0026#34;G2: mu1 locked\u0026#34;) 36\ttime.Sleep(500 * time.Millisecond) 37 38\tmu1.Unlock() 39\tmu2.Unlock() 40\tdone \u0026lt;- \u0026#34;G2: done\u0026#34; 41\t}() 42 43\t// انتظار برای پیام از گوروتین‌ها یا تشخیص بن‌بست 44\tselect { 45\tcase msg := \u0026lt;-done: 46\tfmt.Println(\u0026#34;✅ موفقیت:\u0026#34;, msg) 47\tcase \u0026lt;-time.After(3 * time.Second): 48\tfmt.Println(\u0026#34;❌ بن‌بست شناسایی شد: یکی از گوروتین‌ها قفل شده است\u0026#34;) 49\t} 50} 51 52func main() { 53\tdeadlockRecoveryExample() 54} 1$ go run main.go 2G1: mu1 locked 3G2: mu2 locked 4❌ بن‌بست شناسایی شد: یکی از گوروتین‌ها قفل شده است در این مثال، یک سناریوی کلاسیک از بن‌بست (Deadlock) در زبان Go شبیه‌سازی شده و با استفاده از مکانیزم select و time.After، وقوع آن تشخیص داده می‌شود. هدف این کد، نشان دادن چگونگی رخ دادن بن‌بست بین دو goroutine است که هر کدام سعی می‌کنند منابع مشترکی را قفل کنند، اما به دلیل ترتیب متفاوت در قفل‌گیری، در حالت انتظار دائمی قرار می‌گیرند.\nدر ابتدا، دو شیء قفل mu1 و mu2 از نوع sync.Mutex تعریف می‌شود. سپس دو goroutine راه‌اندازی می‌شوند. گوروتین اول (G1) ابتدا mu1 را قفل کرده و پس از کمی توقف، سعی می‌کند mu2 را نیز قفل کند. در مقابل، گوروتین دوم (G2) ابتدا mu2 را قفل کرده و پس از کمی توقف، سعی در قفل کردن mu1 دارد. به این ترتیب، هر کدام منتظر آزاد شدن قفلی هستند که در دست دیگری است و هیچ‌کدام نمی‌توانند ادامه دهند، در نتیجه بن‌بست واقعی رخ می‌دهد.\nدر بخش main، یک select برای خواندن پیام از کانال done تعریف شده که انتظار دارد یکی از goroutineها پس از انجام کار، پیامی ارسال کند. اما چون هر دو گوروتین در وضعیت قفل گیر افتاده‌اند و هیچ‌کدام به پایان نمی‌رسند، کانال done خالی می‌ماند. در نتیجه پس از ۳ ثانیه، بخش select وارد مسیر time.After می‌شود و پیام \u0026ldquo;بن‌بست شناسایی شد\u0026rdquo; چاپ می‌گردد.\nاین پیاده‌سازی ساده ولی گویا، نحوه وقوع بن‌بست، اهمیت ترتیب قفل‌گیری منابع، و روش تشخیص آن از طریق time-based watchdog را نشان می‌دهد. چنین مکانیزمی در سیستم‌های حساس به همزمانی بسیار ضروری است، چون بن‌بست می‌تواند کل سیستم را متوقف و ناپایدار کند. برای پیشگیری، طراحی قفل‌گیری منظم، استفاده از تایم‌اوت، context، و حتی الگوریتم‌هایی مانند TryLock یا timeout-based locking توصیه می‌شود.\n9.4.17.4 کاربردها # مدیریت منابع در برنامه‌های همزمان (Concurrent Resource Management):\nدر سیستم‌هایی که گوروتین‌ها یا نخ‌ها به منابع مشترکی مانند فایل‌ها، حافظه، یا کانکشن‌های شبکه دسترسی دارند، استفاده از این الگو برای جلوگیری یا بازیابی از بن‌بست هنگام قفل‌گذاری (locking) منابع حیاتی است. با استفاده از تشخیص زمان‌محور، تلاش مجدد یا اولویت‌بندی دسترسی می‌توان از توقف کامل سیستم جلوگیری کرد. پایگاه‌داده‌های توزیع‌شده و سیستم‌های تراکنشی (Distributed Databases \u0026amp; Transactions):\nدر محیط‌های توزیع‌شده مانند دیتابیس‌های چندگره‌ای یا سیستم‌های ACID، تراکنش‌هایی که منتظر منابع قفل‌شده توسط سایر تراکنش‌ها هستند، ممکن است در حالت بن‌بست باقی بمانند. این الگو با تشخیص بن‌بست‌ها و اعمال سیاست‌هایی مانند abort و retry یا rollback، پایداری و در دسترس بودن سیستم را تضمین می‌کند. سیستم‌های بلادرنگ و حساس به زمان (Real-Time Systems):\nدر سیستم‌های بلادرنگ (مانند سامانه‌های کنترل صنعتی یا رباتیک)، حتی تأخیر جزئی می‌تواند بحرانی باشد. استفاده از الگوی بازیابی از بن‌بست باعث می‌شود سیستم بتواند به‌جای توقف کامل، در زمان محدود وضعیت را تشخیص داده و به روش fail-safe ادامه دهد. اشکال‌زدایی و تحلیل همزمانی (Concurrency Debugging \u0026amp; Analysis):\nاین الگو به توسعه‌دهندگان کمک می‌کند تا طراحی همزمانی برنامه را زیر نظر بگیرند و نقاطی که امکان وقوع بن‌بست دارند را شناسایی کنند. با ابزارهایی مثل pprof, trace و تحلیل کانال‌ها می‌توان مسیرهای اجرای بن‌بست‌زا را شناسایی و بازطراحی کرد. "},{"id":220,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-channel-cancellation/","title":"9.4.18 الگو Channel Cancellation","section":"9.4 الگوهای همزمانی","content":" 9.4.18.1 توضیحات # الگوی Channel Cancellation یا «لغو با کانال» یکی از الگوهای کلیدی در طراحی برنامه‌های همزمان (concurrent) در زبان Go است. این الگو زمانی استفاده می‌شود که نیاز باشد یک یا چند گوروتین را به‌صورت هماهنگ و ایمن متوقف کنیم، به‌ویژه در شرایطی که ادامه اجرای آن‌ها بی‌فایده یا مضر است (مثلاً خطا رخ داده، زمان‌سنج تمام شده یا برنامه در حال خاتمه است). این الگو برخلاف استفاده از context.Context (که در Go برای لغو استاندارد توصیه می‌شود)، از یک channel اختصاصی برای ارسال سیگنال لغو استفاده می‌کند.\nدر این الگو، یک کانال معمولاً از نوع chan struct{} (یا chan bool) تعریف می‌شود که فقط یک بار مقدار می‌گیرد و بعد از آن، تمام گوروتین‌هایی که روی آن منتظر هستند متوجه لغو می‌شوند. گوروتین‌های مصرف‌کننده با استفاده از select بررسی می‌کنند که آیا سیگنال لغو دریافت شده یا نه، و در صورت دریافت آن، بلافاصله متوقف می‌شوند. به این ترتیب، سیستم بدون استفاده از متغیرهای مشترک یا قفل (mutex) می‌تواند گوروتین‌های متعدد را متوقف کند.\nمزیت اصلی Channel Cancellation در سادگی و سازگاری بالا با سایر کانال‌ها و ساختارهای Go است. این الگو به راحتی در ترکیب با select در کنار کانال‌های داده به کار می‌رود، به طوری که هر گوروتین همزمان می‌تواند منتظر داده یا سیگنال لغو باشد. این الگو همچنین مناسب سیستم‌هایی است که به سبک event-driven طراحی شده‌اند یا نیاز دارند از عملیات طولانی یا مسدودکننده (blocking) خارج شوند.\nدر نهایت، گرچه امروزه استفاده از context.Context در اغلب موقعیت‌های لغو توصیه می‌شود، الگوی Channel Cancellation همچنان بسیار مفید، سبک و قابل فهم است—مخصوصاً در کدهایی که ساده‌تر یا فاقد نیاز به توابع context-aware هستند. این الگو پایه‌ای برای پیاده‌سازی shutdown graceful، stop کردن workerها، لغو عملیات IO و کنترل حلقه‌های طولانی‌مدت در برنامه‌های Go محسوب می‌شود.\n9.4.18.2 دیاگرام # sequenceDiagram participant Main participant Worker1 participant Worker2 participant CancelChan as Cancel Channel Main-\u003e\u003eWorker1: start with cancel channel Main-\u003e\u003eWorker2: start with cancel channel Note over Worker1,Worker2: کار ادامه دارد... Main--\u003e\u003eCancelChan: close(cancel) Worker1--\u003e\u003eCancelChan: \u003c- cancel Worker2--\u003e\u003eCancelChan: \u003c- cancel Worker1-\u003e\u003eMain: stopped gracefully Worker2-\u003e\u003eMain: stopped gracefully 9.4.18.3 نمونه کد # 1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;time\u0026#34; 6) 7 8// تابعی که تا زمان دریافت سیگنال لغو کار می‌کند 9func worker(id int, cancel \u0026lt;-chan struct{}) { 10\tfor { 11\tselect { 12\tcase \u0026lt;-cancel: 13\tfmt.Printf(\u0026#34;⛔️ Worker %d متوقف شد\\n\u0026#34;, id) 14\treturn 15\tdefault: 16\tfmt.Printf(\u0026#34;⚙️ Worker %d در حال کار...\\n\u0026#34;, id) 17\ttime.Sleep(500 * time.Millisecond) 18\t} 19\t} 20} 21 22func main() { 23\tcancel := make(chan struct{}) // کانال لغو مشترک 24 25\t// اجرای چند گوروتین worker 26\tfor i := 1; i \u0026lt;= 3; i++ { 27\tgo worker(i, cancel) 28\t} 29 30\t// اجرای اصلی تا ۲ ثانیه صبر می‌کند 31\ttime.Sleep(2 * time.Second) 32 33\t// ارسال سیگنال لغو با بستن کانال 34\tfmt.Println(\u0026#34;📢 ارسال سیگنال لغو به همه گوروتین‌ها...\u0026#34;) 35\tclose(cancel) 36 37\t// صبر برای پایان اجرای گوروتین‌ها 38\ttime.Sleep(1 * time.Second) 39\tfmt.Println(\u0026#34;🏁 پایان برنامه\u0026#34;) 40} 1$ go run main.go 2⚙️ Worker 3 در حال کار... 3⚙️ Worker 1 در حال کار... 4⚙️ Worker 2 در حال کار... 5⚙️ Worker 1 در حال کار... 6⚙️ Worker 3 در حال کار... 7⚙️ Worker 2 در حال کار... 8⚙️ Worker 2 در حال کار... 9⚙️ Worker 3 در حال کار... 10⚙️ Worker 1 در حال کار... 11⚙️ Worker 3 در حال کار... 12⚙️ Worker 2 در حال کار... 13⚙️ Worker 1 در حال کار... 14⚙️ Worker 2 در حال کار... 15📢 ارسال سیگنال لغو به همه گوروتین‌ها... 16⚙️ Worker 3 در حال کار... 17⚙️ Worker 1 در حال کار... 18⛔️ Worker 3 متوقف شد 19⛔️ Worker 2 متوقف شد 20⛔️ Worker 1 متوقف شد 21🏁 پایان برنامه در این مثال، الگوی Channel Cancellation برای متوقف کردن همزمان چند گوروتین به کار گرفته شده است. هدف این الگو آن است که بدون نیاز به متغیرهای اشتراکی یا قفل (mutex)، چند گوروتین را به‌صورت هماهنگ و ایمن متوقف کنیم، آن‌هم با استفاده از یک کانال ساده که نقش سیگنال لغو (cancel signal) را ایفا می‌کند.\nدر ابتدای برنامه، یک کانال از نوع chan struct{} به نام cancel تعریف می‌شود. این کانال هیچ داده‌ای حمل نمی‌کند و فقط نقش «علامت توقف» دارد. سپس با استفاده از یک حلقه، سه گوروتین worker راه‌اندازی می‌شوند که همگی به این کانال دسترسی دارند. هر گوروتین درون یک حلقه بی‌نهایت اجرا می‌شود و درون select بررسی می‌کند که آیا سیگنال لغو از کانال دریافت شده یا نه. اگر سیگنال لغو دریافت شود (\u0026lt;-cancel)، گوروتین با چاپ یک پیام متوقف می‌شود. در غیر این صورت، کار شبیه‌سازی‌شده‌ای انجام می‌دهد و سپس کمی می‌خوابد.\nدر تابع main، برنامه به مدت ۲ ثانیه منتظر می‌ماند تا گوروتین‌ها چند بار پیام «در حال کار» چاپ کنند. سپس کانال cancel را می‌بندد (close(cancel)) که این عمل به عنوان سیگنال توقف برای تمام گوروتین‌ها عمل می‌کند. در نتیجه، هر گوروتینی که در حالت انتظار روی آن کانال بوده، فعال می‌شود و مسیر لغو را طی می‌کند. پس از آن، main کمی صبر می‌کند تا همه گوروتین‌ها فرصت چاپ پیام «⛔️ متوقف شد» را پیدا کنند.\nاین مثال ساده اما مؤثر نشان می‌دهد که چگونه می‌توان با استفاده از یک کانال مشترک، گوروتین‌های متعدد را به‌صورت هماهنگ متوقف کرد، بدون نیاز به اشتراک‌گذاری متغیر یا وضعیت پیچیده. این الگو در سناریوهای واقعی مانند متوقف‌سازی graceful در سرورها، لغو همزمان چند worker، یا واکنش به خطاهای بحرانی بسیار مفید و پراستفاده است.\n9.4.18.4 کاربردها # خاموش‌سازی گوروتین‌ها: برای متوقف کردن چند گوروتین به‌صورت هماهنگ هنگام اتمام کار یا دریافت سیگنال خروج. مدیریت worker pool: برای لغو همه‌ی workerها در صورت خطای بحرانی یا پایان پردازش. جلوگیری از نشت گوروتین (goroutine leak): برای پایان دادن به گوروتین‌هایی که دیگر نیازی به ادامه کار آن‌ها نیست. کنترل زمان اجرا: برای قطع عملیات‌های طولانی یا مسدود شده پس از یک مدت مشخص. پیاده‌سازی graceful shutdown: برای پایان ایمن و منظم سرویس هنگام خاموش شدن یا دریافت سیگنال SIGINT. "},{"id":221,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-lock-free-synchronization/","title":"9.4.19 الگو Lock-free synchronization","section":"9.4 الگوهای همزمانی","content":" 9.4.19.1 توضیحات # همگام‌سازی بدون قفل (lock-free synchronization) به مجموعه‌ای از تکنیک‌ها و الگوهای برنامه‌نویسی گفته می‌شود که به چندین thread یا goroutine اجازه می‌دهد به طور همزمان و ایمن به داده‌های مشترک دسترسی پیدا کنند، بدون اینکه از primitiveهایی مثل Mutex یا قفل‌های سنتی استفاده شود. هدف اصلی این الگوها افزایش بازدهی (throughput)، کاهش زمان انتظار (latency) و جلوگیری از مشکلات رایج قفل‌گذاری (مثل deadlock، priority inversion و contention) است. الگوریتم‌های lock-free تضمین می‌کنند که حتی اگر برخی از threadها متوقف شوند یا دچار کندی شوند، باقی سیستم همچنان قادر به پیشرفت خواهد بود (progress guarantee).\n9.4.19.1.1 مکانیزم پایه: عملیات اتمیک و Compare-And-Swap (CAS) # قلب تمام الگوریتم‌های lock-free، عملیات اتمیک (atomic operations) است، که توسط سخت‌افزار CPU و در Go توسط پکیج sync/atomic فراهم می‌شود. مهم‌ترین عملیات اتمیک، Compare-And-Swap (CAS) است؛ در این متد، برنامه مقدار فعلی متغیر را با مقدار مورد انتظار مقایسه می‌کند و در صورت برابری، مقدار جدید را جایگزین می‌کند—همه این مراحل به صورت اتمیک انجام می‌شوند. اگر مقدار تغییر نکرده باشد، عملیات موفق است وگرنه دوباره تلاش می‌شود (این رفتار اصطلاحاً به optimistic concurrency مشهور است).\nمثال پایه‌ای از CAS در Go:\n1import \u0026#34;sync/atomic\u0026#34; 2 3var counter int64 4atomic.AddInt64(\u0026amp;counter, 1) // جمع اتمیک بدون قفل یا:\n1if atomic.CompareAndSwapInt32(\u0026amp;x, old, new) { 2 // موفقیت در تعویض مقدار، ادامه بده 3} 9.4.19.1.2 الگوهای رایج Lock-Free # Lock-Free Counter:\nپیاده‌سازی شمارنده‌های افزایشی/کاهشی (مثل تعداد درخواست، session فعال و \u0026hellip;) با متدهایی مانند atomic.AddInt64 و atomic.LoadInt64 بدون هیچ قفل یا wait. Lock-Free Stack/Queue:\nساختارهایی مانند stack و queue را می‌توان با ترکیب pointer اتمیک و حلقه‌ی CAS پیاده‌سازی کرد؛ هر عملیاتی که نیاز به افزودن/حذف دارد، تا زمانی که مقدار قبلی با مقدار مورد انتظار برابر باشد، مقدار جدید را جایگزین می‌کند. اگر مقدار تغییر کرده باشد (به دلیل دخالت thread دیگر)، عمل دوباره تکرار می‌شود. Flagها و وضعیت‌های اتمیک:\nاستفاده از فلگ‌ها برای signaling یا مدیریت وضعیت‌های بین چند goroutine (مثلاً active/inactive)، بدون race condition و با سرعت بسیار بالا. Reference Swap (atomic.Value):\nتعویض اتمیک مراجع به object یا ساختار داده کامل (مثلاً عوض کردن reference یک cache در حافظه) با atomic.Value، که خواندن و نوشتن کامل آن اتمیک است. 9.4.19.1.3 مزایا و محدودیت‌ها # مزایا:\nعملکرد بسیار بالا مخصوصاً در سناریوهای multi-core و تعداد بالای thread/goroutine بدون deadlock و starvation: تضمین می‌کند که سیستم به خاطر انتظار برای قفل، هرگز متوقف نمی‌شود مقیاس‌پذیری عالی برای داده‌های ساده و الگوریتم‌های سبک محدودیت‌ها:\nپیچیدگی کدنویسی و تحلیل: الگوریتم‌های lock-free نوشتن و تست سخت‌تری دارند و به دانش عمیق رفتار CPU و حافظه نیاز دارند. مناسب فقط برای داده‌های primitive یا تغییرات ساده: برای داده‌های پیچیده یا ساختارهای بزرگ، مدیریت اتمیک بسیار دشوار و گاهاً غیرممکن است. سازگاری معماری: روی همه CPUها و پلتفرم‌ها باید از لحاظ alignment و atomicity اطمینان حاصل کنید (در Go این موضوع مستند شده اما باید رعایت شود). 9.4.19.2 دیاگرام # flowchart TD subgraph SharedMemory[Shared Variable مثلاً counter] V[Value: X] end G1[Goroutine 1] -- CAS (Compare and Swap) --\u003e V G2[Goroutine 2] -- CAS --\u003e V G3[Goroutine 3] -- CAS --\u003e V V -- \"Success: update committed\" --\u003e Done1[Continue] V -- \"Fail: value changed,\\nretry CAS\" --\u003e G1 V -- \"Fail: value changed,\\nretry CAS\" --\u003e G2 V -- \"Fail: value changed,\\nretry CAS\" --\u003e G3 style SharedMemory fill:#e2f0fc,stroke:#377dbf,stroke-width:2px style G1,G2,G3 fill:#fffbe7,stroke:#eac442,stroke-width:2px style Done1 fill:#d3f5e4,stroke:#11b584,stroke-width:2px 9.4.19.3 نمونه کد # 1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;sync\u0026#34; 6\t\u0026#34;sync/atomic\u0026#34; 7) 8 9func main() { 10\tvar counter int64 11\tvar wg sync.WaitGroup 12 13\tnumGoroutines := 10 14\tincrementsPerGoroutine := 1000 15 16\twg.Add(numGoroutines) 17\tfor i := 0; i \u0026lt; numGoroutines; i++ { 18\tgo func() { 19\tdefer wg.Done() 20\tfor j := 0; j \u0026lt; incrementsPerGoroutine; j++ { 21\tatomic.AddInt64(\u0026amp;counter, 1) // افزایش اتمیک بدون قفل 22\t} 23\t}() 24\t} 25 26\twg.Wait() 27\tfmt.Println(\u0026#34;Final counter value:\u0026#34;, counter) 28} 1$ go run main.go 2Final counter value: 10000 در این مثال یک شمارنده lock-free (بدون قفل) با استفاده از پکیج sync/atomic در زبان Go پیاده‌سازی شده است. هدف این است که چندین goroutine بتوانند همزمان و بدون نیاز به Mutex یا قفل سنتی، یک متغیر مشترک را افزایش دهند و در نهایت مقدار دقیق، بدون race condition و کاملاً صحیح به دست آید.\nدر ابتدای برنامه یک متغیر از نوع int64 به نام counter تعریف می‌شود که قرار است توسط goroutineها به طور مشترک افزایش یابد. یک sync.WaitGroup نیز به کار گرفته شده تا اطمینان حاصل شود همه goroutineها تا پایان اجرای خود منتظر بمانند و برنامه قبل از تکمیل همه عملیات‌ها خاتمه پیدا نکند.\nدر حلقه اصلی، ۱۰ goroutine ایجاد می‌شود که هر کدام ۱۰۰۰ بار مقدار شمارنده را افزایش می‌دهند. برای این کار به جای استفاده از قفل، از تابع atomic.AddInt64 استفاده می‌شود. این تابع تضمین می‌کند که عملیات افزایش مقدار شمارنده کاملاً اتمیک است؛ یعنی در هر لحظه فقط یک goroutine می‌تواند مقدار متغیر را تغییر دهد و هیچ دو goroutineی به طور همزمان مقدار ناسازگار یا نادرست دریافت نمی‌کنند.\nدر پایان برنامه با استفاده از wg.Wait() اطمینان حاصل می‌شود که همه goroutineها کار خود را به پایان رسانده‌اند، سپس مقدار نهایی شمارنده چاپ می‌شود. با توجه به تعداد goroutineها و تعداد دفعات افزایش، انتظار داریم مقدار نهایی برابر با ۱۰,۰۰۰ باشد که نشان‌دهنده عملکرد صحیح و بدون خطا (race) الگوریتم است.\nاین مثال یکی از ساده‌ترین و کاربردی‌ترین نمونه‌های lock-free synchronization است که می‌تواند در شمارنده‌های آماری، جمع‌آوری لاگ، فلگ‌های اشتراکی و سناریوهای نیازمند سرعت بالا و رقابت زیاد به کار رود—بدون نگرانی از deadlock، overhead قفل یا کاهش performance.\n9.4.19.4 کاربردها # شمارنده‌های آماری با بازده بالا:\nثبت تعداد درخواست‌های دریافتی سرور، تعداد پیام‌های ارسال یا دریافت‌شده، تعداد خطاها یا موفقیت‌ها، یا هر نوع شمارش سریع و موازی که نباید موجب گلوگاه (bottleneck) در performance شود. ثبت رخدادهای سریع (event counting):\nبه‌طور مثال، شمارش لحظه‌ای کلیک‌ها یا رویدادهای کاربر در وب‌سرورهای real-time یا برنامه‌های مانیتورینگ. پیاده‌سازی flagهای همگام‌سازی:\nاستفاده از متغیرهای اتمیک برای مدیریت وضعیت بین goroutineها (مثلاً علامت پایان، فعال/غیرفعال شدن یک job، آماده‌بودن یک سرویس، یا لغو شدن یک تسک). ساخت cache یا پیکربندی داینامیک:\nبا استفاده از atomic.Value می‌توانید یک reference به ساختار داده یا تنظیمات (مثل map یا struct تنظیمات) را به صورت لحظه‌ای و اتمیک عوض کنید، بدون نیاز به قفل کردن کل داده برای خواندن و نوشتن. ساخت primitiveهای همگام‌سازی سفارشی:\nپیاده‌سازی الگوریتم‌هایی مانند spinlock، lock-free queue و stack، و semaphoreهای سبک که نیاز به performance بسیار بالا دارند و استفاده از Mutex می‌تواند گلوگاه ایجاد کند. مدیریت ساده state در concurrent logger یا metrics collector:\nدر لایه‌های جمع‌آوری لاگ یا متریک که چندین goroutine همزمان روی یک متغیر می‌نویسند و می‌خوانند. "},{"id":222,"href":"/chapter-9/solid-principle-in-golang/","title":"9.7 اصول SOLID","section":"فصل نهم: الگوهای طراحی","content":" 9.7.1 مقدمه # این مقاله ترجمه ارایه اصول solid در golang توسط Dave Cheneyمی‌‌باشد.\nدر این مبحث به بررسی پیاده سازی solid در زبان Go می‌پردازیم.\nبررسی کد\nچه کسی اینجا بررسی کد را به عنوان بخشی از کار خود انجام می‌دهد؟ تمام اتاق دستشان را بالا بردند که تشویق کننده بود. خوب، چرا بررسی کد انجام می‌دهید؟ کسی فریاد زد «برای جلوگیری از کد بد» اگر code review برای شناسایی کد‌های نامناسب است، پس چگونه می‌دانید کدی که بررسی می‌کنید خوب است یا بد؟ حالا خوب است بگوییم «آن کد نامناسب است» یا «آن کد منبع زیبا است»، درست مانند اینکه بگویید «این نقاشی زیبا است» یا «این اتاق زیبا است» اما اینها اصطلاحات ذهنی هستند و من به دنبال راه‌های عینی برای صحبت در مورد خواص کد خوب یا بد هستم. کد بد # برخی از ویژگی‌های کد بد که ممکن است در بررسی کد به آن پی ببرید کدامند؟ سفت و خشک یا در اصطلاح Rigid. آیا کد Rigid است؟ آیا دارای یک محافظ محدود کننده از انواع و پارامترهای غالب است که اصلاح آن را دشوار می‌کند؟ شکننده یا در اصطلاح Fragile. آیا کد Fragile است؟ آیا کوچکترین تغییر در کد باعث ایجاد ویرانی‌های فراوان می‌شود؟ بی‌حرکتی یا Immobile . آیا تغییر در ساختار کد سخت است؟ آیا اضافه کردن یک حلقه ساده در برنامه کار پیچیده‌ای است؟ پیچیده (Complex). آیا کدها به دلیل اینکه فقط کدی نوشته شده باشد بدون آن که به آن نیاز باشد، وجود دارد، آیا چیزها بیش از حد مهندسی (over-engineered) شده‌اند؟ شرح دادن بیش از حد یا Verbose. آیا استفاده و بررسی از کد خسته‌کننده است؟ وقتی به آن نگاه می‌کنید، می‌توانید بگویید این کد چه کاری می‌خواهد انجام دهد؟ آیا این کلمات مثبت هستند؟ آیا از شنیدن این کلمات در بررسی کد خود خوشحال خواهید شد؟ احتمالا نه. طراحی خوب # اما این یک بهبود دادن در سطح کد است، حالا می‌توانیم چیزهایی مثل «من این را دوست ندارم چون خیلی سخت است تغییرش داد» یا «من این را دوست ندارم چون نمی‌توانم بفهمم کد چه کاری می‌خواهد انجام دهد» بگوییم، اما چه می‌شود اگر با مثبت شروع کنیم؟\nآیا خوب نمی‌شد اگر راه‌هایی برای توصیف ویژگی‌های طراحی خوب وجود داشت، نه فقط طراحی بد و بتوانیم این کار را با اصطلاحات عینی انجام دهیم؟\nبررسی SOLID # در سال 2002 رابرت مارتین کتاب توسعه نرم‌افزار چابک، اصول، الگوها و روش‌ها را منتشر کرد. او پنج اصل طراحی نرم‌افزار قابل استفاده مجدد را توصیف کرد که اصول SOLID نامید، بر اساس حروف اول نام‌های آن‌ها. که شامل موارد زیر است:\nSingle Responsibility Principle Open / Closed Principle Liskov Substitution Principle Interface Segregation Principle Dependency Inversion Principle این کتاب کمی قدیمی است، زبان‌هایی که در مورد آن‌ها صحبت می‌کند، زبان‌هایی هستند که بیش از یک دهه پیش استفاده می‌شدند. اما، شاید جنبه‌هایی از اصول SOLID وجود داشته باشد که بتواند به ما سرنخی در مورد نحوه صحبت در مورد برنامه‌های Go با طراحی خوب بدهد.\nبنابراین می‌خواهم مدتی را صرف بحث در مورد این موضوع با شما کنم.\n9.7.2 اصل Single Responsibility # اولین اصل S در SOLID که اصل مسئولیت واحد است.\nیک کلاس باید یک و تنها یک دلیل برای تغییر داشته باشد.\nخب در زبان Go واضح است که چیزی به نام کلاس وجود ندارد - در عوض ما مفهوم بسیار قدرتمندتر composition را داریم - اما اگر بتوانید از استفاده از کلمه کلاس چشم‌پوشی کنید، فکر می‌کنم ارزش آن را دارد.\nچرا مهم است که یک قطعه کد فقط یک دلیل برای تغییر داشته باشد؟ خب، به اندازه اینکه ایده تغییر کد خودتان آزاردهنده است، کشف اینکه کدی که کد شما به آن وابسته است و مبنای آن تغییر می‌کند بسیار آزاردهنده‌تر است و وقتی کد شما باید تغییر کند، باید در پاسخ به یک محرک مستقیم این کار را انجام دهد، نباید قربانی آسیب‌های جانبی شود.\nبنابراین کدی که مسئولیت واحدی دارد، در نتیجه کمترین دلایل برای تغییر را دارد.\n9.7.2.1 بررسی Coupling و Cohesion # کوپلینگ و Cohesion دو کلمه‌ای که توصیف می‌کنند تغییر یک نرم‌افزار چقدر آسان یا سخت است، Coupling و Cohesion هستند.\nکوپلینگ به سادگی کلمه‌ای است که دو چیز را توصیف می‌کند که با هم تغییر می‌کنند - حرکت در یکی باعث حرکت در دیگری می‌شود.\nیک مفهوم مرتبط اما جداگانه، ایده Cohesion است، نیروی جذب متقابل.\nدر زمینه نرم‌افزار، Cohesion خاصیتی است که توصیف می‌کند قطعات کد به طور طبیعی به یکدیگر جذب می‌شوند.\nبرای توصیف واحدهای کوپلینگ و Cohesion در یک برنامه Go، ممکن است در مورد توابع و متدها صحبت کنیم، همانطور که در هنگام بحث در مورد SRP بسیار رایج است، اما من معتقدم که این کار با مدل packageهای Go شروع می‌شود.\n9.7.2.2 نام Package‌ها # در Go، تمام کدها داخل یک Package قرار دارند و یک Package خوب طراحی شده با نام آن شروع می‌شود. نام یک Package هم توصیفی از هدف آن است و هم پیشوند فضای نام. برخی از مثال‌های Package‌های خوب از کتابخانه‌ی استاندارد Go می‌توانند باشند:\n‏net/http که کلاینت‌ها و سرورهای http را فراهم می‌کند. ‏os/exec که دستورات خارجی را اجرا می‌کند. ‏encoding/json،که کدگذاری و رمزگشایی اسناد JSON را پیاده‌سازی می‌کند. وقتی شما از نمادهای Package دیگری در داخل Package خود استفاده می‌کنید، این کار با اعلامیه‌ی import انجام می‌شود که یک کوپلینگ سطح منبع بین دو Package ایجاد می‌کند. آن‌ها حالا یکدیگر را می‌شناسند.\n9.7.2.3 نام‌های بد Package # این تمرکز بر نام‌ها فقط موشکافی نیست. یک Package بدنام فرصت بررسی هدف خود را از دست می‌دهد، اگر اصلا هدفی داشته باشد.\nبسته‌ی server چه چیزی را فراهم می‌کند؟ \u0026hellip; خب، امیدوارم یک سرور، اما با کدام پروتکل؟\nبسته‌ی private چه چیزی را فراهم می‌کند؟ چیزهایی که نباید ببینم؟ آیا باید نمادهای public داشته باشد؟\nو بسته‌ی common، درست مثل همکارش، بسته‌ی utils، اغلب در نزدیکی این متخلفان دیگر پیدا می‌شود.\nبسته‌های همه کاره‌ی مانند این به یک محل دفن زباله برای چیزهای مختلف تبدیل می‌شوند و چون مسئولیت‌های زیادی دارند، اغلب بدون دلیل تغییر می‌کنند.\n9.7.2.4 فلسفه‌ی یونیکس در Go # به نظر من، هیچ بحثی در مورد طراحی جدا شده بدون ذکر فلسفه‌ی یونیکس Doug McIlroy کامل نمی‌شود؛ ابزارهای کوچک و چابک که برای حل کارهای بزرگ‌تر ترکیب می‌شوند، اغلب کارهایی که توسط نویسندگان اصلی پیش‌بینی نشده بود.\nفکر می‌کنم بسته‌های Go روحیه‌ی فلسفه‌ی یونیکس را تجسم می‌بخشند. در واقع هر بسته‌ی Go خود یک برنامه‌ی کوچک Go است، یک اثرگذاری کوچک با یک مسئولیت واحد.\n9.7.2.5 مثال Single Responsibility # این اصل بیان می‌کند که یک ساختار باید تنها یک دلیل برای تغییر داشته باشد، به این معنی که یک ساختار باید تنها یک مسئولیت داشته باشد. این کمک می کند تا کد را تمیز و قابل نگهداری نگه دارید، زیرا تغییرات در ساختار فقط باید در یک مکان انجام شود.\nفرض کنید من یک کارمند ساختاری دارم که نام، حقوق و آدرس یک کارمند را پیگیری می‌کند:\n1type Employee struct { 2\tName string 3\tSalary float64 4\tAddress string 5} طبق SRP، هر ساختار باید تنها یک مسئولیت داشته باشد، بنابراین در این مورد، بهتر است مسئولیت‌های ساختار Employee به دو ساختار جداگانه تقسیم شود: EmployeeInfo و EmployeeAddress.\n1type EmployeeInfo struct { 2 Name string 3 Salary float64 4} 5 6type EmployeeAddress struct { 7 Address string 8} اکنون می‌توانیم توابع جداگانه‌ای داشته باشیم که مسئولیت‌های مختلف هر ساختار را بر عهده دارد:\n1func (e EmployeeInfo) GetSalary() float64 { 2 return e.Salary 3} 4 5func (e EmployeeAddress) GetAddress() string { 6 return e.Address 7} با پیروی از SRP، من کد را قابل نگهداری تر و درک آن آسان‌تر کرده‌ام، زیرا اکنون هر ساختار مسئولیت مشخص و مشخصی دارد. اگر بخواهم تغییراتی در محاسبه حقوق و دستمزد یا رسیدگی به آدرس ایجاد کنم، دقیقاً می‌دانم به کجا نگاه کنم، بدون اینکه نیازی به کدهای نامرتبط زیادی داشته باشم.\n9.7.3 اصل Open / Closed # اصل دوم، O، اصل بسته باز توسط برتراند مایر است که در سال 1988 نوشت:\nموجودیت‌های نرم‌افزار باید برای توسعه باز باشند، اما برای اصلاح بسته شوند.\n– برتراند مایر، ساخت نرم افزار شی گرا\nاین توصیه چگونه در مورد زبانی که 21 سال بعد نوشته شده است صدق می کند؟\n1package main 2 3type A struct { 4 year int 5} 6 7func (a A) Greet() { fmt.Println(\u0026#34;Hello GolangUK\u0026#34;, a.year) } 8 9type B struct { 10 A 11} 12 13func (b B) Greet() { fmt.Println(\u0026#34;Welcome to GolangUK\u0026#34;, b.year) } 14 15func main() { 16 var a A 17 a.year = 2016 18 var b B 19 b.year = 2016 20 a.Greet() // Hello GolangUK 2016 21 b.Greet() // Welcome to GolangUK 2016 22} ما یک type به نام A داریم با یک field به نام year و یک متد به نام Greet. یک type دوم به نام B داریم که A را در خود جای می‌دهد، بنابراین فراخواننده‌ها متدهای B را روی متدهای A می‌بینند زیرا A به عنوان یک field در داخل B جاسازی شده است و B می‌تواند متد Greet خود را ارائه دهد و آن را از A پنهان کند.\nاما جاسازی فقط برای متدها نیست، بلکه دسترسی به فیلدهای نوع جاسازی شده را نیز فراهم می‌کند. همانطور که می‌بینید، از آنجایی که هر دو A و B در یک package تعریف شده‌اند، B می‌تواند به فیلد خصوصی year در A دسترسی داشته باشد انگار که در داخل B تعریف شده است.\nبنابراین جاسازی (embedding) یک ابزار قدرتمند است که به تایپ‌های Go اجازه می‌دهد برای گسترش باز باشند.\n1package main 2 3type Cat struct { 4 Name string 5} 6 7func (c Cat) Legs() int { return 4 } 8 9func (c Cat) PrintLegs() { 10 fmt.Printf(\u0026#34;I have %d legs\\n\u0026#34;, c.Legs()) 11} 12 13type OctoCat struct { 14 Cat 15} 16 17func (o OctoCat) Legs() int { return 5 } 18 19func main() { 20 var octo OctoCat 21 fmt.Println(octo.Legs()) // 5 22 octo.PrintLegs() // I have 4 legs 23} در این مثال، ما یک type به نام Cat داریم که می‌تواند تعداد پاهای خود را با متد Legs بشمارد. ما این نوع Cat را در یک نوع جدید به نام OctoCat جاسازی می‌کنیم و اعلام می‌کنیم که Octocatها پنج پا دارند. با این حال، اگرچه OctoCat متد Legs خود را تعریف می‌کند که 5 برمی‌گرداند، اما وقتی متد PrintLegs فراخوانی می‌شود، 4 برمی‌گرداند.\nاین به این دلیل است که PrintLegs روی نوع Cat تعریف شده است. این متد یک Cat را به عنوان گیرنده خود می‌گیرد، بنابراین به متد Legs در Cat ارسال می‌شود. Cat هیچ اطلاعی از نوعی که در آن جاسازی شده است ندارد، بنابراین مجموعه متدهای آن نمی‌تواند با جاسازی تغییر کند.\nبنابراین می‌توانیم بگوییم که انواع Go در حالی که برای گسترش باز هستند، برای تغییر بسته هستند.\nدر واقع، متدها در Go چیزی بیشتر از نوعی syntax در اطراف یک تابع با یک پارامتر از پیش تعریف شده، گیرنده‌ی خود نیستند.\n1func (c Cat) PrintLegs() { 2 fmt.Printf(\u0026#34;I have %d legs\\n\u0026#34;, c.Legs()) 3} 4 5func PrintLegs(c Cat) { 6 fmt.Printf(\u0026#34;I have %d legs\\n\u0026#34;, c.Legs()) 7} گیرنده یا receiver دقیقا همان چیزی است که به آن پاس می‌دهید، اولین پارامتر function است و از آنجا که Go از function overloading پشتیبانی نمی‌کند، در نتیجه OctoCatها جایگزین Cats معمولی نمی‌شوند. که من را به اصل بعدی در solid می‌رساند.\n9.7.3.1 مثال Open / Closed # فرض کنید من وظیفه دارم یک سیستم پرداخت بسازم که بتواند پرداخت‌های کارت اعتباری را پردازش کند. همچنین باید به‌اندازه کافی انعطاف‌پذیر باشد تا انواع روش‌های پرداخت را در آینده بپذیرد.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type PaymentMethod interface { 6 Pay() 7} 8 9type Payment struct{} 10 11func (p Payment) Process(pm PaymentMethod) { 12 pm.Pay() 13} 14 15type CreditCard struct { 16 amount float64 17} 18 19func (cc CreditCard) Pay() { 20 fmt.Printf(\u0026#34;Paid %.2f using CreditCard\u0026#34;, cc.amount) 21} 22 23func main() { 24 p := Payment{} 25 cc := CreditCard{12.23} 26 p.Process(cc) 27} طبق OCP، ساختار پرداخت من برای توسعه باز و برای اصلاح بسته است. ازآنجایی‌که من از واسط PaymentMethod استفاده می‌کنم، مجبور نیستم رفتار پرداخت را هنگام افزودن روش‌های پرداخت جدید ویرایش کنم. اضافه‌کردن چیزی مانند PayPal به شکل زیر است:\n1type PayPal struct { 2 amount float64 3} 4 5func (pp PayPal) Pay() { 6 fmt.Printf(\u0026#34;Paid %.2f using PayPal\u0026#34;, pp.amount) 7} 8 9// then in main() 10pp := PayPal{22.33} 11p.Process(pp) 9.7.4 اصل Liskov Substitution # این اصل توسط توسط باربارا لیسکوف معرفی شده است، اصل جایگزینی لیسکوف تقریباً بیان می‌کند که دو نوع قابل جایگزینی هستند اگر رفتارهایی را نشان دهند که فراخواننده نتواند تفاوت را تشخیص دهد.\nدر یک زبان مبتنی بر کلاس‌ها، اصل جایگزینی لیسکوف معمولاً به عنوان یک مشخصات برای یک abstract base class با زیرگونه‌های concrete class مختلف تفسیر می‌شود. اما Go کلاس یا وراثت ندارد، بنابراین جایگزینی نمی‌تواند از نظر سلسله مراتب abstract class پیاده‌سازی شود.\n9.7.4.1 بررسی Interface ها # در عوض، پایده سازی اصل جایگزینی (substitution) در این حوزه‌ بر عهده Interfaceها در Go است. در Go، از تایپ‌ها انتظار نمی‌رود که یک Interface خاصی را که پیاده‌سازی می‌کنند را از قبل معرفی کنند، در عوض هر تایپ یک Interface را پیاده‌سازی می‌کند به شرطی که متدهایی داشته باشد که امضای (signature) آن با اعلامیه اینترفیس (interface declaration) مطابقت داشته باشد.\nما می‌گوییم که در Go، رابط‌ها یا Interfaceها به طور ضمنی (implicitly) برآورده می‌شوند، نه صریح یا explicitly و این تأثیر عمیقی بر نحوه استفاده از آن‌ها در این زبان برنامه نویسی دارد.\nاینترفیس‌های طراحی شده خوب در بیشتر موارد احتمال دارد که اینترفیس‌های کوچکی باشند؛ ضرب‌المثل غالب این است که یک Interface فقط یک متد دارد. منطقی است که اینترفیس‌های کوچک منجر به پیاده‌سازی‌های ساده شوند، زیرا انجام خلاف آن دشوار است. که منجر به بسته‌هایی می‌شود که از پیاده‌سازی‌های ساده تشکیل شده‌اند و توسط رفتار مشترک به هم متصل شده‌اند.\n9.7.4.2 بررسی io.Reader # 1type Reader interface { 2 // Read reads up to len(buf) bytes into buf. 3 Read(buf []byte) (n int, err error) 4} در ادامه مبحث که من را به io.Reader می‌رساند، به راحتی مورد علاقه من در بین اینترفیس‌ها در Go است.\nاینترفیس io.Reader بسیار ساده است؛ Read داده‌ها را به بافر تأمین شده می‌خواند و تعداد بایت‌های خوانده شده و هر خطایی که در حین خواندن رخ داده است را به فراخواننده برمی‌گرداند. به نظر ساده می‌آید اما بسیار قدرتمند است.\nاز آنجایی که io.Reader با هر چیزی که بتوان آن را به عنوان یک stream از بایت‌ها بیان کرد سر و کار دارد، می‌توانیم خواننده‌ها را روی تقریباً هر چیزی ساختیم؛ یک رشته ثابت، یک آرایه بایت، ورودی استاندارد، یک جریان شبکه، یک فایل فشرده gzip، خروجی استاندارد یک فرمان که از طریق ssh به صورت remote اجرا می‌شود.\nو تمام این پیاده‌سازی‌ها برای یکدیگر قابل جایگزینی هستند زیرا قرارداد ساده یکسانی را برآورده می‌کنند.\nبنابراین اصل جایگزینی لیسکوف، اعمال شده بر روی Go، می‌تواند با این ضرب‌المثل زیبا از Jim Weirich خلاصه شود.\nRequire no more, promise no less.\n–Jim Weirich\nو این یک حرکت عالی در چهارمین اصل SOLID است.\n9.7.4.3 مثال Liskov Substitution # بیایید یک struct Animal را در نظر بگیریم:\n1type Animal struct { 2 Name string 3} 4 5func (a Animal) MakeSound() { 6 fmt.Println(\u0026#34;Animal sound\u0026#34;) 7} حال، فرض کنید می‌خواهیم یک ساختار جدید Bird بسازیم که نشان دهنده نوع خاصی از حیوانات است:\n1type Bird struct { 2 Animal 3} 4 5func (b Bird) MakeSound() { 6 fmt.Println(\u0026#34;Chirp chirp\u0026#34;) 7} این اصل بیان می‌کند که اشیاء یک superclass باید با اشیاء یک زیر کلاس بدون تأثیر بر صحت برنامه قابل‌تعویض باشند. این کمک می‌کند تا اطمینان حاصل شود که روابط بین کلاس ها به‌خوبی تعریف شده و قابل حفظ است.\n1type AnimalBehavior interface { 2 MakeSound() 3} 4 5// MakeSound represent a program that works with animals and is expected 6// to work with base class (Animal) or any subclass (Bird in this case) 7func MakeSound(ab AnimalBehavior) { 8 ab.MakeSound() 9} 10 11a := Animal{} 12b := Bird{} 13MakeSound(a) 14MakeSound(b) این وراثت در Go و همچنین اصل جایگزینی Liskov را نشان می‌دهد، زیرا اشیاء یک نوع فرعی Bird را می‌توان در هر جایی که اشیایی از نوع پایه Animal انتظار می‌رود استفاده کرد، بدون اینکه بر صحت برنامه تأثیر بگذارد.\n9.7.5 اصل Interface Segregation # چهارمین اصل، اصل جداسازی اینترفیس است که به شرح زیر است:\nکلاینت نباید مجبور شوند که به متدهایی که استفاده نمی‌کنند وابسته باشند.\n-رابرت سی مارتین\n1// Save writes the contents of doc to the file f. 2func Save(f *os.File, doc *Document) error من می‌توانم این تابع را تعریف کنم، بیایید آن را Save بنامیم، که یک *os.File را به عنوان مقصد برای نوشتن Document می‌گیرد. اما این کار چند مشکل دارد.\nامضای یا signature مخصوص Save گزینه نوشتن داده‌ها به یک مکان شبکه‌ای را از بین می‌برد. با فرض اینکه ذخیره‌سازی شبکه احتمالاً بعداً به یک نیاز تبدیل می‌شود، امضای این تابع باید تغییر کند و روی تمام فراخواننده‌های آن تأثیر بگذارد.\nاز آنجایی که Save مستقیماً با فایل‌ها روی دیسک کار می‌کند، تست کردن آن ناخوشایند است. برای تأیید عملکرد آن، تست باید محتوای فایل را بعد از نوشتن بخواند. علاوه بر این، تست باید اطمینان حاصل کند که f به یک مکان موقت نوشته شده است و همیشه بعد از آن حذف می‌شود.\nهمچنین os.File متدهای زیادی را تعریف می‌کند که با Save مرتبط نیستند، مانند خواندن دایرکتوری‌ها و بررسی اینکه آیا یک مسیر یک symlink است. بسیار مفید خواهد بود اگر امضای تابع Save ما بتواند فقط قسمت‌های مرتبط os.File را توصیف کند.\nپس با این مشکلات چه کنیم؟\n1// Save writes the contents of doc to the supplied Writer. 2func Save(w io.Writer, doc *Document) error یک راه حل بهتر این است که Save را دوباره تعریف کنیم تا فقط یک io.Writer بگیرد و مسئولیت انجام هر کاری غیر از نوشتن داده‌ها به یک جریان را کاملاً از آن بگیرد.\nبا اعمال اصل جداسازی interface بر روی تابع Save، نتیجه همزمان یک function است که از نظر نیازهای خود خاص‌ترین است و فقط به چیزی نیاز دارد که قابل نوشتن باشداکنون می‌توانیم از Save برای ذخیره داده‌های خود به هر چیزی که io.Writer را پیاده‌سازی می‌کند، استفاده کنیم.\nیک قانون بزرگ برای Go پذیرش interfaceها در structهای بازگشتی است. Jack Lindamood\n9.7.5.1 مثال Interface Segregation: # فرض کنید یک interface برای چاپگر اسناد داریم:\n1goCopy codetype Printer interface { 2 Print() 3 Scan() 4 Fax() 5} اگر کلاینت فقط نیاز به چاپ اسناد دارد، نباید آنها را مجبور به پیاده سازی روش های اسکن و فکس کرد. در عوض، می‌توانیم این رابط را به interfaceهای کوچک‌تر و متمرکزتر تقسیم کنیم:\n1type Printer interface { 2 Print() 3} 4 5type Scanner interface { 6 Scan() 7} 8 9type FaxMachine interface { 10 Fax() 11} 9.7.6 اصل Dependency Inversion # اصل SOLID نهایی، اصل وارونگی وابستگی است که بیان می‌کند:\nماژول های سطح بالا نباید به ماژول های سطح پایین وابسته باشند. هر دو باید به انتزاعات بستگی داشته باشند.\nانتزاع ها نباید به جزئیات بستگی داشته باشند. جزئیات باید به انتزاعات بستگی داشته باشد.\n-رابرت سی مارتین\nاما dependency inversion به طور عملی برای برنامه‌نویسان Go چه معنایی دارد؟\nاگر تمام اصول مورد بحث تا این نقطه را اعمال کرده‌اید، کد شما باید از قبل به packageهای مجزا فاکتور شده باشد، هر کدام با یک مسئولیت یا هدف مشخص و خوب تعریف شده است. کد شما باید وابستگی‌های خود را از نظر اینترفیس‌ها توصیف کند و آن اینترفیس‌ها باید برای توصیف تنها رفتار مورد نیاز آن توابع فاکتور شوند. به عبارت دیگر، کار زیادی برای انجام باقی نمی‌ماند.\nبنابراین فکر می‌کنم مارتین در اینجا در مورد ساختار گراف import کردن packageهای شما صحبت می‌کند که مطمئنا در زمینه Go است.\nدر Go باید import graph شما باید غیر دوره‌ای باشد. عدم رعایت این نیاز غیر دوره‌ای زمینه‌ای برای شکست کامپایل است، اما جدی‌تر نشان‌دهنده یک خطای جدی در طراحی است.\nهمه چیز برابر است، import graph یک برنامه‌ی Go به خوبی طراحی شده باید گسترده و نسبتاً مسطح باشد، نه بلند و باریک. اگر packageهای دارید که توابع آن بدون کمک گرفتن از packageهای‌ دیگری نمی‌توانند کار کنند، این احتمالاً نشانه‌ای است که کد به خوبی در امتداد مرزهای بسته فاکتور نشده است.\nاصل وارونگی وابستگی شما را تشویق می‌کند که مسئولیت جزئیات را تا حد امکان به بالای import graph به packageهای‌ اصلی یا هندلر سطح بالا، منتقل کنید و اجازه دهید کد سطح پایین با انتزاعات - اینترفیس‌‌ها (abstractions–interfaces) سروکار داشته باشد.\n9.7.6.1 مثال # فرض کنید یک struct Worker داریم که نماینده یک Worker در یک شرکت است و یک struct Supervisor که نماینده یک سرپرست یا Supervisor است: ‍‍\n1 type Worker struct { 2 ID int 3 Name string 4} 5 6func (w Worker) GetID() int { 7 return w.ID 8} 9 10func (w Worker) GetName() string { 11 return w.Name 12} 13 14type Supervisor struct { 15 ID int 16 Name string 17} 18 19func (s Supervisor) GetID() int { 20 return s.ID 21} 22 23func (s Supervisor) GetName() string { 24 return s.Name 25} اکنون، برای این حالت ضد الگو، فرض کنید یک بخش ماژول سطح بالا داریم که نشان دهنده یک بخش در یک شرکت است و نیاز به ذخیره اطلاعات در مورد workerها و supervisorها دارد که ماژول‌های سطح پایین در نظر گرفته می‌شوند:\n1type Department struct { 2 Workers []Worker 3 Supervisors []Supervisor 4} طبق اصل وارونگی وابستگی، ماژول های سطح بالا نباید به ماژول های سطح پایین وابسته باشند. در عوض، هر دو باید به انتزاعات بستگی داشته باشند. برای اصلاح مثال ضد الگوی خود، می توانم یک Interface Employee ایجاد کنم که نماینده هر دو، workerها و supervisorها باشد:\n1type Employee interface { 2 GetID() int 3 GetName() string 4} اکنون می توانم ساختار Department را به روزرسانی کنم تا دیگر به ماژول‌های سطح پایین وابسته نباشد:\n1type Department struct { 2 Employees []Employee 3} و حالت نهایی:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type Worker struct { 6 ID int 7 Name string 8} 9 10func (w Worker) GetID() int { 11 return w.ID 12} 13 14func (w Worker) GetName() string { 15 return w.Name 16} 17 18type Supervisor struct { 19 ID int 20 Name string 21} 22 23func (s Supervisor) GetID() int { 24 return s.ID 25} 26 27func (s Supervisor) GetName() string { 28 return s.Name 29} 30 31type Employee interface { 32 GetID() int 33 GetName() string 34} 35 36type Department struct { 37 Employees []Employee 38} 39 40func (d *Department) AddEmployee(e Employee) { 41 d.Employees = append(d.Employees, e) 42} 43 44func (d *Department) GetEmployeeNames() (res []string) { 45 for _, e := range d.Employees { 46 res = append(res, e.GetName()) 47 } 48 return 49} 50 51func (d *Department) GetEmployee(id int) Employee { 52 for _, e := range d.Employees { 53 if e.GetID() == id { 54 return e 55 } 56 } 57 return nil 58} 59 60func main() { 61 dep := \u0026amp;Department{} 62 dep.AddEmployee(Worker{ID: 1, Name: \u0026#34;John\u0026#34;}) 63 dep.AddEmployee(Supervisor{ID: 2, Name: \u0026#34;Jane\u0026#34;}) 64 65 fmt.Println(dep.GetEmployeeNames()) 66 67 e := dep.GetEmployee(1) 68 switch v := e.(type) { 69 case Worker: 70 fmt.Printf(\u0026#34;found worker %+v\\n\u0026#34;, v) 71 case Supervisor: 72 fmt.Printf(\u0026#34;found supervisor %+v\\n\u0026#34;, v) 73 default: 74 fmt.Printf(\u0026#34;could not find an employee by id: %d\\n\u0026#34;, 1) 75 } 76} این اصل وابستگی وارونگی را نشان می‌دهد، زیرا ساختار Department به‌جای یک پیاده‌سازی خاص (ساختار Worker یا Supervisor) به یک انتزاع (Employee interface) وابستگی دارد. این امر کد را انعطاف‌پذیرتر می‌کند و نگهداری آن را آسان‌تر می‌کند، زیرا تغییرات در اجرای workers و supervisors بر ساختار Department تأثیر نمی‌گذارد.\n9.7.7 طراحی SOLID در Go # برای جمع‌بندی، وقتی هر یک از اصول SOLID را به Go اعمال می‌کنیم، موارد قدرتمندی در مورد طراحی هستند، اما وقتی با هم به کاربرده می‌شوند، می‌توان گفت که یک ایده مرکزی دارند.\nاصل مسئولیت واحد (Single Responsibility) شما را تشویق می‌کند تا توابع، انواع و متدها را در بسته‌هایی ساختار دهید که انسجام طبیعی دارند؛ تایپ‌ها با هم مرتبط هستند، توابع یک هدف واحد دارند.\nاصل باز/بسته (Open / Closed) شما را تشویق می‌کند تا تایپ‌های ساده را با استفاده از جاسازی به انواع پیچیده‌تر ترکیب کنید.\nاصل جایگزینی لیسکوف (Liskov Substitution) شما را تشویق می‌کند تا وابستگی‌ها بین بسته‌های خود را از نظر اینترفیس‌ها بیان کنید و نه فقط تایپ‌های concrete. با تعریف اینترفیس‌های کوچک، می‌توانیم مطمئن‌تر باشیم که پیاده‌سازی‌ها به طور کامل قرارداد خود را برآورده می‌کنند.\nاصل جداسازی اینترفیس (Interface Substitution) این ایده را بیشتر جلو می‌برد و شما را تشویق می‌کند تا توابع و متدهایی را تعریف کنید که فقط به رفتاری که نیاز دارند وابسته هستند. اگر تابع شما فقط به یک پارامتر از نوع Interface با یک متد نیاز دارد، پس احتمال بیشتری دارد که این تابع فقط یک مسئولیت داشته باشد.\nاصل وارونگی وابستگی (Dependency Inversion) شما را تشویق می‌کند که دانش چیزهایی که package شما به آن‌ها وابسته است را از زمان کامپایل - در Go این را با کاهش تعداد عبارات import استفاده شده توسط یک package خاص می‌بینیم - به زمان اجرا منتقل کنید.\nاگر بخواهید این صحبت را خلاصه کنید، احتمالاً این خواهد بود: Interface‌ها به شما اجازه می‌دهند اصول SOLID را به برنامه‌های Go اعمال کنید.\nزیرا Interface‌ها به برنامه‌نویسان Go اجازه می‌دهند تا توصیف کنند که package آن‌ها چه چیزی را فراهم می‌کند - نه اینکه چگونه این کار را انجام می‌دهد. این همه فقط یک روش دیگر برای گفتن \u0026ldquo;decoupling\u0026rdquo; بوده که در واقع هدف اصلی ما است، زیرا نرم‌افزاری که به صورت پیوستگی ضعیف ( loosely coupled) شده است نرم‌افزاری است که تغییر آن آسان‌تر است.\nهمانطور که Sandi Metz می‌گوید:\nطراحی هنر چیدمان کدی است که باید امروز کار کند و برای همیشه آسان تغییر کند.\nزیرا اگر Go قرار است زبانی باشد که شرکت‌ها برای بلندمدت در آن سرمایه‌گذاری کنند، نگهداری برنامه‌های Go، سهولت تغییر آن‌ها، عامل کلیدی در تصمیم آن‌ها خواهد بود.\n9.7.8 در پایان # بیایید به سؤالی که این صحبت را با آن شروع کردم برگردیم؛ چند برنامه‌نویس Go در دنیا وجود دارد؟ این حدس من است:\nتا سال 2020، 500000 توسعه‌دهنده Go وجود خواهد داشت.\nمن نیم میلیون برنامه‌نویس Go با وقت خود چه خواهند کرد؟ خب، واضح است که آن‌ها مقدار زیادی کد Go خواهند نوشت و اگر صادق باشیم، همه آن خوب نخواهد بود و برخی کاملاً بد خواهند بود.\nلطفا بدانید که من این را برای بی‌رحمی نمی‌گویم، اما هر یک از شما در این اتاق با تجربه توسعه در زبان‌های دیگر - زبان‌هایی که از آن‌ها به Go آمدید - از تجربه خود می‌دانید که این پیش‌بینی تا حدی درست است.\nدرون ++C، یک زبان بسیار کوچکتر و تمیزتر در تلاش برای بیرون آمدن است.\nبیارنه استراوستراپ، طراحی و تکامل ++C فرصت برای همه برنامه‌نویسان Go برای موفقیت زبان ما مستقیماً به توانایی جمعی ما در ایجاد چنین آشفتگی‌ای بستگی دارد که مردم شروع به صحبت کردن درباره Go به همان روشی کنند که امروز درباره ++C شوخی می‌کنند.\nداستانی که زبان‌های دیگر را به دلیل بزرگ، پر حرفی و پیچیده بودن مورد تمسخر قرار می‌دهد، ممکن است روزی به سمت Go برگردد،و من نمی‌خواهم این اتفاق بیفتد، بنابراین درخواستی دارم.\nبرنامه‌نویسان Go باید کمتر در مورد فریمورک‌ها صحبت کنند و بیشتر در مورد طراحی صحبت کنند. باید تمرکز خود را از عملکرد به هر قیمتی متوقف کنیم و در عوض روی استفاده مجدد به هر قیمتی تمرکز کنیم.\nمن می‌خواهم ببینم مردم در مورد نحوه استفاده از زبانی که امروز داریم، صرف نظر از انتخاب‌ها و محدودیت‌های آن، برای طراحی راه‌حل‌ها و حل مشکلات واقعی صحبت می‌کنند.\nمن می‌خواهم بشنوم که مردم در مورد نحوه طراحی برنامه‌های Go به روشی که به خوبی مهندسی شده، جدا شده، قابل استفاده مجدد و از همه مهم‌تر پاسخگو به تغییر است صحبت می‌کنند.\n\u0026hellip; یک چیز دیگر\nحالا، عالی است که بسیاری از شما امروز برای شنیدن از سخنرانان بزرگ اینجا هستید، اما واقعیت این است که صرف نظر از اینکه این کنفرانس چقدر بزرگ می‌شود، در مقایسه با تعداد افرادی که در طول عمر خود از Go استفاده خواهند کرد، ما فقط یک بخش کوچک هستیم.\nبنابراین باید به بقیه دنیا بگوییم که نرم‌افزار خوب چگونه باید نوشته شود. نرم‌افزار خوب، نرم‌افزار قابل ترکیب، نرم‌افزاری که قابل تغییر است و به آن‌ها نشان دهیم که چگونه این کار را با استفاده از Go انجام دهند. و این کار از شما شروع می‌شود.\nمن می‌خواهم شما شروع به صحبت در مورد طراحی کنید، شاید از برخی ایده‌هایی که در اینجا ارائه کردم استفاده کنید، امیدوارم تحقیقات خود را انجام دهید و این ایده‌ها را در پروژه‌های خود اعمال کنید. سپس می‌خواهم شما:\nیک پست وبلاگ در مورد آن بنویسید. یک کارگاه در مورد کاری که انجام دادید تدریس کنید. یک کتاب در مورد آنچه آموخته‌اید بنویسید. و سال آینده به این کنفرانس برگردید و در مورد آنچه به دست آوردید صحبت کنید.\nزیرا با انجام این کارها می‌توانیم فرهنگی از توسعه‌دهندگان Go ایجاد کنیم که به برنامه‌هایی اهمیت می‌دهند که برای ماندگاری طراحی شده‌اند.\nمتشکرم.\n"},{"id":223,"href":"/chapter-9/cloud-native-patterns/go-cloud-native-circuit-breaker-pattern/","title":"9.5.1 الگو Circuit Breaker","section":"9.5 الگوهای Cloud Native","content":"الگو Circuit Breaker\u0026hellip;\n"},{"id":224,"href":"/chapter-9/cloud-native-patterns/go-cloud-native-debounce-pattern/","title":"9.5.2 الگو Debounce","section":"9.5 الگوهای Cloud Native","content":"الگو Debounce\u0026hellip;\n"},{"id":225,"href":"/chapter-9/cloud-native-patterns/go-cloud-native-retry-pattern/","title":"9.5.3 الگو Retry","section":"9.5 الگوهای Cloud Native","content":"الگو Retry\u0026hellip;\n"},{"id":226,"href":"/chapter-9/cloud-native-patterns/go-cloud-native-throttle-pattern/","title":"9.5.4 الگو Throttle","section":"9.5 الگوهای Cloud Native","content":"الگو Throttle\u0026hellip;\n"},{"id":227,"href":"/chapter-9/cloud-native-patterns/go-cloud-native-timeout-pattern/","title":"9.5.5 الگو Timeout","section":"9.5 الگوهای Cloud Native","content":"الگو Timeout\u0026hellip;\n"},{"id":228,"href":"/chapter-9/anti-pattern/go-anti-patterns-in-syntax/","title":"9.6.1 ضد الگو سینتکسی","section":"9.6 ضد الگوها (Anti-Patterns)","content":"ضد الگو سینتکسی\n"},{"id":229,"href":"/chapter-10/10.1--data-structures-queue-stack-lists/","title":"10.1 Data Structures (Queue Stack Lists)","section":"فصل دهم: الگوریتم و ساختار داده","content":"در این قسمت به بررسی مواردی مهم از ساختمان داده در زبان گو می‌پردازیم و این آموزش مناسب افرادی هست که با مباحث ساختمان داده آشنایی داشته باشند.\n10.1.1 Queue in Golang # یک صف (queue) ساده را می توان با استفاده از GO به کمک موارد زیر پیاده سازی کرد:\ncontainer/list package slice یک صف عملیات زیر را انجام می‌دهد:\nEnqueue Dequeue Front Size Empty 10.1.1.1 List Implementation # پیاده سازی صف به کمک لیست‌ها\n1package main 2 3import ( 4 \u0026#34;container/list\u0026#34; 5 \u0026#34;fmt\u0026#34; 6) 7 8type customQueue struct { 9 queue *list.List 10} 11 12func (c *customQueue) Enqueue(value string) { 13 c.queue.PushBack(value) 14} 15 16func (c *customQueue) Dequeue() error { 17 if c.queue.Len() \u0026gt; 0 { 18 ele := c.queue.Front() 19 c.queue.Remove(ele) 20 } 21 return fmt.Errorf(\u0026#34;Pop Error: Queue is empty\u0026#34;) 22} 23 24func (c *customQueue) Front() (string, error) { 25 if c.queue.Len() \u0026gt; 0 { 26 if val, ok := c.queue.Front().Value.(string); ok { 27 return val, nil 28 } 29 return \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;Peep Error: Queue Datatype is incorrect\u0026#34;) 30 } 31 return \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;Peep Error: Queue is empty\u0026#34;) 32} 33 34func (c *customQueue) Size() int { 35 return c.queue.Len() 36} 37 38func (c *customQueue) Empty() bool { 39 return c.queue.Len() == 0 40} 41 42func main() { 43 customQueue := \u0026amp;customQueue{ 44 queue: list.New(), 45 } 46 fmt.Printf(\u0026#34;Enqueue: A\\n\u0026#34;) 47 customQueue.Enqueue(\u0026#34;A\u0026#34;) 48 fmt.Printf(\u0026#34;Enqueue: B\\n\u0026#34;) 49 customQueue.Enqueue(\u0026#34;B\u0026#34;) 50 fmt.Printf(\u0026#34;Size: %d\\n\u0026#34;, customQueue.Size()) 51 for customQueue.Size() \u0026gt; 0 { 52 frontVal, _ := customQueue.Front() 53 fmt.Printf(\u0026#34;Front: %s\\n\u0026#34;, frontVal) 54 fmt.Printf(\u0026#34;Dequeue: %s\\n\u0026#34;, frontVal) 55 customQueue.Dequeue() 56 } 57 fmt.Printf(\u0026#34;Size: %d\\n\u0026#34;, customQueue.Size()) 58} خروجی برنامه بالا:\n1Enqueue: A 2Enqueue: B 3Size: 2 4Front: A 5Dequeue: A 6Front: B 7Dequeue: B 8Size: 0 10.1.1.2 Slice Implementation # پیاده سازی صف به کمک slice\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;sync\u0026#34; 6) 7 8type customQueue struct { 9\tqueue []string 10\tlock sync.RWMutex 11} 12 13func (c *customQueue) Enqueue(name string) { 14\tc.lock.Lock() 15\tdefer c.lock.Unlock() 16\tc.queue = append(c.queue, name) 17} 18 19func (c *customQueue) Dequeue() error { 20\tif len(c.queue) \u0026gt; 0 { 21\tc.lock.Lock() 22\tdefer c.lock.Unlock() 23\tc.queue = c.queue[1:] 24\treturn nil 25\t} 26\treturn fmt.Errorf(\u0026#34;Pop Error: Queue is empty\u0026#34;) 27} 28 29func (c *customQueue) Front() (string, error) { 30\tif len(c.queue) \u0026gt; 0 { 31\tc.lock.Lock() 32\tdefer c.lock.Unlock() 33\treturn c.queue[0], nil 34\t} 35\treturn \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;Peep Error: Queue is empty\u0026#34;) 36} 37 38func (c *customQueue) Size() int { 39\treturn len(c.queue) 40} 41 42func (c *customQueue) Empty() bool { 43\treturn len(c.queue) == 0 44} 45 46func main() { 47\tcustomQueue := \u0026amp;customQueue{ 48\tqueue: make([]string, 0), 49\t} 50 51\tfmt.Printf(\u0026#34;Enqueue: A\\n\u0026#34;) 52\tcustomQueue.Enqueue(\u0026#34;A\u0026#34;) 53\tfmt.Printf(\u0026#34;Enqueue: B\\n\u0026#34;) 54\tcustomQueue.Enqueue(\u0026#34;B\u0026#34;) 55\tfmt.Printf(\u0026#34;Len: %d\\n\u0026#34;, customQueue.Size()) 56 57\tfor customQueue.Size() \u0026gt; 0 { 58\tfrontVal, _ := customQueue.Front() 59\tfmt.Printf(\u0026#34;Front: %s\\n\u0026#34;, frontVal) 60\tfmt.Printf(\u0026#34;Dequeue: %s\\n\u0026#34;, frontVal) 61\tcustomQueue.Dequeue() 62\t} 63\tfmt.Printf(\u0026#34;Len: %d\\n\u0026#34;, customQueue.Size()) 64} خروجی برنامه بالا:\n1Enqueue: A 2Enqueue: B 3Size: 2 4Front: A 5Dequeue: A 6Front: B 7Dequeue: B 8Size: 0 10.1.2 Stack in Golang # یک پشته (Stack) ساده را می توان با استفاده از GO به کمک موارد زیر پیاده سازی کرد:\ncontainer/list package slice یک stack عملیات زیر را انجام می‌دهد:\nPush Pop Front Size Empty 10.1.2.1 List Implementation # پیاده سازی پشته به کمک لیست‌ها\n1package main 2 3import ( 4 \u0026#34;container/list\u0026#34; 5 \u0026#34;fmt\u0026#34; 6) 7 8type customStack struct { 9 stack *list.List 10} 11 12func (c *customStack) Push(value string) { 13 c.stack.PushFront(value) 14} 15 16func (c *customStack) Pop() error { 17 if c.stack.Len() \u0026gt; 0 { 18 ele := c.stack.Front() 19 c.stack.Remove(ele) 20 } 21 return fmt.Errorf(\u0026#34;Pop Error: Stack is empty\u0026#34;) 22} 23 24func (c *customStack) Front() (string, error) { 25 if c.stack.Len() \u0026gt; 0 { 26 if val, ok := c.stack.Front().Value.(string); ok { 27 return val, nil 28 } 29 return \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;Peep Error: Stack Datatype is incorrect\u0026#34;) 30 } 31 return \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;Peep Error: Stack is empty\u0026#34;) 32} 33 34func (c *customStack) Size() int { 35 return c.stack.Len() 36} 37 38func (c *customStack) Empty() bool { 39 return c.stack.Len() == 0 40} 41 42func main() { 43 customStack := \u0026amp;customStack{ 44 stack: list.New(), 45 } 46 fmt.Printf(\u0026#34;Push: A\\n\u0026#34;) 47 customStack.Push(\u0026#34;A\u0026#34;) 48 fmt.Printf(\u0026#34;Push: B\\n\u0026#34;) 49 customStack.Push(\u0026#34;B\u0026#34;) 50 fmt.Printf(\u0026#34;Size: %d\\n\u0026#34;, customStack.Size()) 51 for customStack.Size() \u0026gt; 0 { 52 frontVal, _ := customStack.Front() 53 fmt.Printf(\u0026#34;Front: %s\\n\u0026#34;, frontVal) 54 fmt.Printf(\u0026#34;Pop: %s\\n\u0026#34;, frontVal) 55 customStack.Pop() 56 } 57 fmt.Printf(\u0026#34;Size: %d\\n\u0026#34;, customStack.Size()) 58} خروجی برنامه بالا:\n1Push: A 2Push: B 3Size: 2 4Front: B 5Pop: B 6Front: A 7Pop: A 8Size: 0 10.1.2.2 Slice Implementation # پیاده سازی پشته به کمک slice\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;sync\u0026#34; 6) 7 8type customStack struct { 9 stack []string 10 lock sync.RWMutex 11} 12 13func (c *customStack) Push(name string) { 14 c.lock.Lock() 15 defer c.lock.Unlock() 16 c.stack = append(c.stack, name) 17} 18 19func (c *customStack) Pop() error { 20 len := len(c.stack) 21 if len \u0026gt; 0 { 22 c.lock.Lock() 23 defer c.lock.Unlock() 24 c.stack = c.stack[:len-1] 25 return nil 26 } 27 return fmt.Errorf(\u0026#34;Pop Error: Stack is empty\u0026#34;) 28} 29 30func (c *customStack) Front() (string, error) { 31 len := len(c.stack) 32 if len \u0026gt; 0 { 33 c.lock.Lock() 34 defer c.lock.Unlock() 35 return c.stack[len-1], nil 36 } 37 return \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;Peep Error: Stack is empty\u0026#34;) 38} 39 40func (c *customStack) Size() int { 41 return len(c.stack) 42} 43 44func (c *customStack) Empty() bool { 45 return len(c.stack) == 0 46} 47 48func main() { 49 customStack := \u0026amp;customStack{ 50 stack: make([]string, 0), 51 } 52 fmt.Printf(\u0026#34;Push: A\\n\u0026#34;) 53 customStack.Push(\u0026#34;A\u0026#34;) 54 fmt.Printf(\u0026#34;Push: B\\n\u0026#34;) 55 customStack.Push(\u0026#34;B\u0026#34;) 56 fmt.Printf(\u0026#34;Size: %d\\n\u0026#34;, customStack.Size()) 57 for customStack.Size() \u0026gt; 0 { 58 frontVal, _ := customStack.Front() 59 fmt.Printf(\u0026#34;Front: %s\\n\u0026#34;, frontVal) 60 fmt.Printf(\u0026#34;Pop: %s\\n\u0026#34;, frontVal) 61 customStack.Pop() 62 } 63 fmt.Printf(\u0026#34;Size: %d\\n\u0026#34;, customStack.Size()) 64} خروجی برنامه بالا:\n1Push: A 2Push: B 3Size: 2 4Front: B 5Pop: B 6Front: A 7Pop: A 8Size: 0 10.1.3 Set implementation in Golang # مجموعه (set) یک ساختار داده ای است که عناصر را بدون نظم خاصی در خود نگه می دارد. یک عنصر فقط یک بار در یک مجموعه ظاهر می شود.\nSet را می توان با استفاده از map در GO پیاده سازی کرد. ما از map[string]struct{} برای مجموعه استفاده خواهیم کرد زیرا struct{} هیچ حافظه ای اشغال نمی کند، بنابراین از نظر ذخیره سازی کارآمدتر است.\nدر زیر مثال ساده مجموعه (set) که دارای عملیات زیر است را داریم:\nAdd Remove Exists 1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5) 6 7//MakeSet initialize the set 8func makeSet() *customSet { 9 return \u0026amp;customSet{ 10 container: make(map[string]struct{}), 11 } 12} 13 14type customSet struct { 15 container map[string]struct{} 16} 17 18func (c *customSet) Exists(key string) bool { 19 _, exists := c.container[key] 20 return exists 21} 22 23func (c *customSet) Add(key string) { 24 c.container[key] = struct{}{} 25} 26 27func (c *customSet) Remove(key string) error { 28 _, exists := c.container[key] 29 if !exists { 30 return fmt.Errorf(\u0026#34;Remove Error: Item doesn\u0026#39;t exist in set\u0026#34;) 31 } 32 delete(c.container, key) 33 return nil 34} 35 36func (c *customSet) Size() int { 37 return len(c.container) 38} 39 40func main() { 41 customSet := makeSet() 42 fmt.Printf(\u0026#34;Add: B\\n\u0026#34;) 43 customSet.Add(\u0026#34;A\u0026#34;) 44 fmt.Printf(\u0026#34;Add: B\\n\u0026#34;) 45 customSet.Add(\u0026#34;B\u0026#34;) 46 fmt.Printf(\u0026#34;Size: %d\\n\u0026#34;, customSet.Size()) 47 fmt.Printf(\u0026#34;A Exists?: %t\\n\u0026#34;, customSet.Exists(\u0026#34;A\u0026#34;)) 48 fmt.Printf(\u0026#34;B Exists?: %t\\n\u0026#34;, customSet.Exists(\u0026#34;B\u0026#34;)) 49 fmt.Printf(\u0026#34;C Exists?: %t\\n\u0026#34;, customSet.Exists(\u0026#34;C\u0026#34;)) 50 fmt.Printf(\u0026#34;Remove: B\\n\u0026#34;) 51 customSet.Remove(\u0026#34;B\u0026#34;) 52 fmt.Printf(\u0026#34;B Exists?: %t\\n\u0026#34;, customSet.Exists(\u0026#34;B\u0026#34;)) 53} خروجی برنامه بالا:\n1Add: B 2Add: B 3Size: 2 4A Exists?: true 5B Exists?: true 6C Exists?: false 7Remove: B 8B Exists?: false 10.1.4 Linked List in Golang # لیست منفرد یک نوع ساده از لیست پیوندی است که امکان پیمایش در یک جهت یعنی جلو را فراهم می کند. هر گره در لیست پیوندی شامل بخش داده و اشاره گر به گره بعدی در لیست پیوند شده است.\nلیست پیوندی اجرا شده در مثال زیر از عملیات زیر پشتیبانی می کند.\nAddFront AddBack RemoveFront RemoveBack Traverse Front Size 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type ele struct { 6 name string 7 next *ele 8} 9 10type singleList struct { 11 len int 12 head *ele 13} 14 15func initList() *singleList { 16 return \u0026amp;singleList{} 17} 18 19func (s *singleList) AddFront(name string) { 20 ele := \u0026amp;ele{ 21 name: name, 22 } 23 if s.head == nil { 24 s.head = ele 25 } else { 26 ele.next = s.head 27 s.head = ele 28 } 29 s.len++ 30 return 31} 32 33func (s *singleList) AddBack(name string) { 34 ele := \u0026amp;ele{ 35 name: name, 36 } 37 if s.head == nil { 38 s.head = ele 39 } else { 40 current := s.head 41 for current.next != nil { 42 current = current.next 43 } 44 current.next = ele 45 } 46 s.len++ 47 return 48} 49 50func (s *singleList) RemoveFront() error { 51 if s.head == nil { 52 return fmt.Errorf(\u0026#34;List is empty\u0026#34;) 53 } 54 s.head = s.head.next 55 s.len-- 56 return nil 57} 58 59func (s *singleList) RemoveBack() error { 60 if s.head == nil { 61 return fmt.Errorf(\u0026#34;removeBack: List is empty\u0026#34;) 62 } 63 var prev *ele 64 current := s.head 65 for current.next != nil { 66 prev = current 67 current = current.next 68 } 69 if prev != nil { 70 prev.next = nil 71 } else { 72 s.head = nil 73 } 74 s.len-- 75 return nil 76} 77 78func (s *singleList) Front() (string, error) { 79 if s.head == nil { 80 return \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;Single List is empty\u0026#34;) 81 } 82 return s.head.name, nil 83} 84 85func (s *singleList) Size() int { 86 return s.len 87} 88 89func (s *singleList) Traverse() error { 90 if s.head == nil { 91 return fmt.Errorf(\u0026#34;TranverseError: List is empty\u0026#34;) 92 } 93 current := s.head 94 for current != nil { 95 fmt.Println(current.name) 96 current = current.next 97 } 98 return nil 99} 100 101func main() { 102 singleList := initList() 103 fmt.Printf(\u0026#34;AddFront: A\\n\u0026#34;) 104 singleList.AddFront(\u0026#34;A\u0026#34;) 105 fmt.Printf(\u0026#34;AddFront: B\\n\u0026#34;) 106 singleList.AddFront(\u0026#34;B\u0026#34;) 107 fmt.Printf(\u0026#34;AddBack: C\\n\u0026#34;) 108 singleList.AddBack(\u0026#34;C\u0026#34;) 109 110 fmt.Printf(\u0026#34;Size: %d\\n\u0026#34;, singleList.Size()) 111 112 err := singleList.Traverse() 113 if err != nil { 114 fmt.Println(err.Error()) 115 } 116 117 fmt.Printf(\u0026#34;RemoveFront\\n\u0026#34;) 118 err = singleList.RemoveFront() 119 if err != nil { 120 fmt.Printf(\u0026#34;RemoveFront Error: %s\\n\u0026#34;, err.Error()) 121 } 122 123 fmt.Printf(\u0026#34;RemoveBack\\n\u0026#34;) 124 err = singleList.RemoveBack() 125 if err != nil { 126 fmt.Printf(\u0026#34;RemoveBack Error: %s\\n\u0026#34;, err.Error()) 127 } 128 129 fmt.Printf(\u0026#34;RemoveBack\\n\u0026#34;) 130 err = singleList.RemoveBack() 131 if err != nil { 132 fmt.Printf(\u0026#34;RemoveBack Error: %s\\n\u0026#34;, err.Error()) 133 } 134 135 fmt.Printf(\u0026#34;RemoveBack\\n\u0026#34;) 136 err = singleList.RemoveBack() 137 if err != nil { 138 fmt.Printf(\u0026#34;RemoveBack Error: %s\\n\u0026#34;, err.Error()) 139 } 140 141 err = singleList.Traverse() 142 if err != nil { 143 fmt.Println(err.Error()) 144 } 145 146 fmt.Printf(\u0026#34;Size: %d\\n\u0026#34;, singleList.Size()) 147} خروجی برنامه بالا:\n1AddFront: A 2AddFront: B 3AddBack: C 4Size: 3 5B 6A 7C 8RemoveFront 9RemoveBack 10RemoveBack 11RemoveBack 12RemoveBack Error: removeBack: List is empty 13TranverseError: List is empty 14Size: 0 10.1.5 Doubly Linked List in Go # یک لیست مضاعف (Doubly Linked) شامل سه قسمت در گره خود است.\nفیلد داده. یک اشاره گر بعدی به گره بعدی در لیست اشاره می کند. یک اشاره گر قبلی که به گره قبلی در لیست اشاره می کند. در اینجا فیلدهای «داده‌ها» و «بعدی» مانند لیست‌های پیوندی منفرد هستند. فیلد اشاره گر «قبلی» ویژگی جدیدی است که لیست پیوندی را به لیست پیوندی دوگانه تبدیل می کند.\nدر زیر نمونه ای از یک لیست با پیوند دوگانه آورده شده است. اشاره گر قبلی گره head (start) به Null اشاره می کند. به طور مشابه، اشاره گر Next آخرین گره به Null اشاره می کند.\nبرای پیاده‌سازی یک doubly linked list در زبان Go، یک ساختار گره با داده‌ها، اشاره‌گر قبلی و اشاره‌گر بعدی، روش‌هایی برای افزودن گره‌ها در doubly linked list (از قسمت جلویی یا از انتهای هر دو) و روش‌هایی برای پیمایش به جلو/عقب ایجاد کنید.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type node struct { 6\tdata string 7\tprev *node 8\tnext *node 9} 10 11type doublyLinkedList struct { 12\tlen int 13\ttail *node 14\thead *node 15} 16 17func initDoublyList() *doublyLinkedList { 18\treturn \u0026amp;doublyLinkedList{} 19} 20 21func (d *doublyLinkedList) AddFrontNodeDLL(data string) { 22\tnewNode := \u0026amp;node{ 23\tdata: data, 24\t} 25\tif d.head == nil { 26\td.head = newNode 27\td.tail = newNode 28\t} else { 29\tnewNode.next = d.head 30\td.head.prev = newNode 31\td.head = newNode 32\t} 33\td.len++ 34\treturn 35} 36 37func (d *doublyLinkedList) AddEndNodeDLL(data string) { 38\tnewNode := \u0026amp;node{ 39\tdata: data, 40\t} 41\tif d.head == nil { 42\td.head = newNode 43\td.tail = newNode 44\t} else { 45\tcurrentNode := d.head 46\tfor currentNode.next != nil { 47\tcurrentNode = currentNode.next 48\t} 49\tnewNode.prev = currentNode 50\tcurrentNode.next = newNode 51\td.tail = newNode 52\t} 53\td.len++ 54\treturn 55} 56func (d *doublyLinkedList) TraverseForward() error { 57\tif d.head == nil { 58\treturn fmt.Errorf(\u0026#34;TraverseError: List is empty\u0026#34;) 59\t} 60\ttemp := d.head 61\tfor temp != nil { 62\tfmt.Printf(\u0026#34;value = %v, prev = %v, next = %v\\n\u0026#34;, temp.data, temp.prev, temp.next) 63\ttemp = temp.next 64\t} 65\tfmt.Println() 66\treturn nil 67} 68 69func (d *doublyLinkedList) TraverseReverse() error { 70\tif d.head == nil { 71\treturn fmt.Errorf(\u0026#34;TraverseError: List is empty\u0026#34;) 72\t} 73\ttemp := d.tail 74\tfor temp != nil { 75\tfmt.Printf(\u0026#34;value = %v, prev = %v, next = %v\\n\u0026#34;, temp.data, temp.prev, temp.next) 76\ttemp = temp.prev 77\t} 78\tfmt.Println() 79\treturn nil 80} 81 82func (d *doublyLinkedList) Size() int { 83\treturn d.len 84} 85func main() { 86\tdoublyList := initDoublyList() 87\tfmt.Printf(\u0026#34;Add Front Node: C\\n\u0026#34;) 88\tdoublyList.AddFrontNodeDLL(\u0026#34;C\u0026#34;) 89\tfmt.Printf(\u0026#34;Add Front Node: B\\n\u0026#34;) 90\tdoublyList.AddFrontNodeDLL(\u0026#34;B\u0026#34;) 91\tfmt.Printf(\u0026#34;Add Front Node: A\\n\u0026#34;) 92\tdoublyList.AddFrontNodeDLL(\u0026#34;A\u0026#34;) 93\tfmt.Printf(\u0026#34;Add End Node: D\\n\u0026#34;) 94\tdoublyList.AddEndNodeDLL(\u0026#34;D\u0026#34;) 95\tfmt.Printf(\u0026#34;Add End Node: E\\n\u0026#34;) 96\tdoublyList.AddEndNodeDLL(\u0026#34;E\u0026#34;) 97 98\tfmt.Printf(\u0026#34;Size of doubly linked ist: %d\\n\u0026#34;, doublyList.Size()) 99 100\terr := doublyList.TraverseForward() 101\tif err != nil { 102\tfmt.Println(err.Error()) 103\t} 104 105\terr = doublyList.TraverseReverse() 106\tif err != nil { 107\tfmt.Println(err.Error()) 108\t} 109} خروجی مورد انتظار برابر حالت زیر است:\n1Add Front Node: C 2Add Front Node: B 3Add Front Node: A 4Add End Node: D 5Add End Node: E 6Size of doubly linked ist: 5 7value = A, prev = , next = \u0026amp;{B 0xc000070060 0xc000070020} 8value = B, prev = \u0026amp;{A 0xc000070040}, next = \u0026amp;{C 0xc000070040 0xc000070080} 9value = C, prev = \u0026amp;{B 0xc000070060 0xc000070020}, next = \u0026amp;{D 0xc000070020 0xc0000700a0} 10value = D, prev = \u0026amp;{C 0xc000070040 0xc000070080}, next = \u0026amp;{E 0xc000070080 } 11value = E, prev = \u0026amp;{D 0xc000070020 0xc0000700a0}, next = 12 13value = E, prev = \u0026amp;{D 0xc000070020 0xc0000700a0}, next = 14value = D, prev = \u0026amp;{C 0xc000070040 0xc000070080}, next = \u0026amp;{E 0xc000070080 } 15value = C, prev = \u0026amp;{B 0xc000070060 0xc000070020}, next = \u0026amp;{D 0xc000070020 0xc0000700a0} 16value = B, prev = \u0026amp;{A 0xc000070040}, next = \u0026amp;{C 0xc000070040 0xc000070080} 17value = A, prev = , next = \u0026amp;{B 0xc000070060 0xc000070020} 10.1.6 Tree in Go # درخت به عنوان یک ساختمان داده غیرخطی تعریف می‌شود که از مجموعه‌ای از گره‌ها تشکیل شده است، و این گره‌ها توسط یال‌ها به یکدیگر متصل شده‌اند\nخواص یک درخت:\nدرخت از یک گره ریشه و صفر یا چند درخت فرعی متصل به آن تشکیل شده است گره ریشه بالاترین گره درخت است گره‌های برگ گره‌هایی هستند که هیچ فرزندی ندارند عمق یک گره تعداد یال‌ها بین ریشه و خودش است ارتفاع یک گره تعداد یال‌ها بین خودش و دورترین گره برگ در زیردرخت خود است ‍‍\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5// Tree represents a tree structure. 6type Tree struct { 7\troot *TreeNode 8} 9 10// TreeNode represents a node in the tree. 11type TreeNode struct { 12\tdata int 13\tchildren []*TreeNode 14} 15 16// insertTree adds a new node with the given data as the root node of the tree. 17func (tree *Tree) insertTree(data int) { 18\tif tree.root == nil { 19\ttree.root = \u0026amp;TreeNode{data: data} 20\t} 21} 22 23// InsertNode adds a new node with the given data as a child of the specified node. 24func (node *TreeNode) insertNode(data int) *TreeNode { 25\tnewNode := \u0026amp;TreeNode{data: data} 26\tnode.children = append(node.children, newNode) 27\treturn newNode 28} 29 30// deleteTree removes the specified node, starting from the root of the tree. 31func (tree *Tree) deleteFromRoot(nodeToDelete *TreeNode) { 32\tif tree.root != nil { 33\ttree.root = tree.root.deleteNode(nodeToDelete) 34\t} 35} 36 37// deleteNode recursively removes the specified node and its descendants from the current node\u0026#39;s children. 38func (node *TreeNode) deleteNode(nodeToDelete *TreeNode) *TreeNode { 39\tvar updatedChildren []*TreeNode 40\tfor _, child := range node.children { 41\tif child != nodeToDelete { 42\tupdatedChildren = append(updatedChildren, child.deleteNode(nodeToDelete)) 43\t} 44} 45 46\tnode.children = updatedChildren 47\treturn node 48} 49 50// searchFromRoot searches for a node with the specified data starting from the tree\u0026#39;s root. 51func (tree *Tree) searchFromRoot(data int) *TreeNode { 52\tif tree.root != nil { 53\tnode := tree.root.searchFromNode(data) 54\treturn node 55\t} 56\t57\treturn nil 58} 59 60// searchFromNode searches for a node with the specified data starting from the current node. 61func (node *TreeNode) searchFromNode(data int) *TreeNode { 62\tif node.data == data { 63\treturn node 64\t} 65\tfor _, child := range node.children { 66\tif foundNode := child.searchFromNode(data); foundNode != nil { 67\treturn foundNode 68\t} 69\t} 70 71\treturn nil 72} 73 74// traverseFromRoot initiates a traversal of the tree starting from the root node. 75func (tree *Tree) traverseFromRoot() { 76\tif tree.root != nil { 77\ttree.root.traverse() 78\t} 79} 80 81// traverse performs a recursive traversal starting from the current node. 82func (node *TreeNode) traverse() { 83\tif node == nil { 84\treturn 85\t} 86\t87\tfmt.Printf(\u0026#34;%d \u0026#34;, node.data) 88\tfor _, child := range node.children { 89\tchild.traverse() 90\t} 91} 92 93func main() { 94\t// Creating a Tree instance 95\ttree := Tree{} 96\t97\t// Inserting nodes 98\ttree.insertTree(1) 99\ttree.root.insertNode(2) 100\tnode3 := tree.root.insertNode(3) 101\tnode4 := tree.root.insertNode(4) 102\tnode3.insertNode(5) 103\tnode3.insertNode(6) 104\tnode4.insertNode(7) 105 106\t// Traversing and printing nodes 107\tfmt.Println(\u0026#34;Traverse from root:\u0026#34;) 108\ttree.root.traverse() 109\t110\t// Searching for node 111\tfmt.Println(\u0026#34;\\nSearch for node 3:\u0026#34;) 112\tnode := tree.searchFromRoot(3) 113\tif node != nil { 114\tfmt.Println(\u0026#34;node found\u0026#34;) 115\t} else { 116\tfmt.Println(\u0026#34;node not found\u0026#34;) 117\t} 118\t119\tfmt.Println(\u0026#34;Search for node 8:\u0026#34;) 120\tnode8 := tree.searchFromRoot(8) 121\tif node8 != nil { 122\tfmt.Println(\u0026#34;node found\u0026#34;) 123\t} else { 124\tfmt.Println(\u0026#34;node not found\u0026#34;) 125\t} 126\t127\t// Deleting a node 128\tfmt.Println(\u0026#34;After deleting node 3:\u0026#34;) 129\ttree.deleteFromRoot(node3) 130\ttree.root.traverse() 131} خروجی برنامه بالا:\n1Traverse from root: 21 2 3 5 6 4 7 3Search for node 3 4node found 5Search for node 8 6node not found 7After deleting node 3: 81 2 4 7 10.1.7 Binary Tree in Go # درخت دودویی، نوعی ساختار داده‌ای درخت است که هر گره آن می‌تواند حداکثر دو فرزند (یک فرزند چپ و یک فرزند راست) داشته باشد\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5// BinaryTree represents a binary tree. 6type BinaryTree struct { 7\troot *BinaryNode 8} 9 10// BinaryNode represents a node in the binary tree. 11type BinaryNode struct { 12\tdata int 13\tleft *BinaryNode 14\tright *BinaryNode 15} 16 17// insertFromRoot inserts a new node with the given data into the tree. 18func (tree *BinaryTree) insertFromRoot(data int) *BinaryTree { 19\tif tree.root != nil { 20\ttree.root.insertNode(data) 21\t} else { 22\ttree.root = \u0026amp;BinaryNode{data: data} 23\t} 24\t25\treturn tree 26} 27 28// insertNode inserts a new node with the given data into the subtree rooted at the current node using level-order traversal. 29func (node *BinaryNode) insertNode(data int) *BinaryNode { 30\tvar tempNode *BinaryNode 31\tqueue := []*BinaryNode{node} 32\t33\tfor len(queue) \u0026gt; 0 { 34\ttempNode, queue = queue[0], queue[1:] 35\t36\tif tempNode.left == nil { 37\ttempNode.left = \u0026amp;BinaryNode{data: data} 38\tbreak 39\t} 40\tqueue = append(queue, tempNode.left)\t41\t42\tif tempNode.right == nil { 43\ttempNode.right = \u0026amp;BinaryNode{data: data} 44\tbreak 45\t} 46\tqueue = append(queue, tempNode.right) 47\t} 48 49\treturn node 50} 51 52// deleteFromRoot deletes a specific node from the binary tree starting from the root. 53func (tree *BinaryTree) deleteFromRoot(nodeToDelete *BinaryNode) { 54\tif tree.root != nil { 55\ttree.root.deleteNode(nodeToDelete) 56\t} 57} 58 59// deletetNode attempts to delete a specific node from the subtree rooted at the current node. 60func (node *BinaryNode) deleteNode(nodeToDelete *BinaryNode) *BinaryNode { 61\tvar keyNode, lastNode, tempNode *BinaryNode 62\tqueue := []*BinaryNode{node}\t63\t64\tfor len(queue) \u0026gt; 0 { 65\ttempNode, queue = queue[0], queue[1:] 66\t67\tif tempNode == nodeToDelete {\t68\tkeyNode = tempNode 69\t} 70 71\tif tempNode.left != nil { 72\tlastNode, queue = tempNode, append(queue, tempNode.left) 73\t} 74 75\tif tempNode.right != nil { 76\tlastNode, queue = tempNode, append(queue, tempNode.right) 77\t} 78\t} 79 80 81 82\tif keyNode != nil { 83\tkeyNode.data = tempNode.data 84\t85\tif lastNode.right == tempNode { 86\tlastNode.right = nil 87\t} else { 88\tlastNode.left = nil 89\t} 90\t} 91 92\treturn node 93} 94 95// searchFromRoot searches for a node with the given data in the binary tree starting from the root. 96func (tree *BinaryTree) searchFromRoot(data int) *BinaryNode { 97\tif tree.root != nil { 98\treturn tree.root.searchFromNode(data) 99\t} 100\t101\treturn nil 102} 103 104// searchFromNode performs a level-order traversal to find a node with the given data 105func (node *BinaryNode) searchFromNode(data int) *BinaryNode { 106\tvar tempNode *BinaryNode 107\tqueue := []*BinaryNode{node} 108 109\tfor len(queue) \u0026gt; 0 { 110\ttempNode, queue = queue[0], queue[1:] 111\t112\tif tempNode.data == data { 113\treturn tempNode 114\t} 115 116\tif tempNode.left != nil { 117\tqueue = append(queue, tempNode.left) 118\t} 119 120\tif tempNode.right != nil { 121\tqueue = append(queue, tempNode.right) 122\t} 123\t} 124\t125\treturn nil 126} 127 128// printTreeInOrder prints the values of nodes in the binary tree starting from root using an in-order traversal. 129func (tree *BinaryTree) printTreeInOrder() { 130\tif tree.root != nil { 131\ttree.root.printSubTreeInOrder() 132\t} 133} 134 135// printTreePreOrder prints the values of nodes in the binary tree starting from root using a pre-order traversal. 136func (tree *BinaryTree) printTreePreOrder() { 137\tif tree.root != nil { 138\ttree.root.printSubTreePreOrder() 139\t} 140} 141 142// printTreePostOrder prints the values of nodes in the binary tree starting from root using a post-order traversal. 143func (tree *BinaryTree) printTreePostOrder() { 144\tif tree.root != nil { 145\ttree.root.printSubTreePostOrder() 146\t} 147} 148 149// printSubTreeInOrder prints the values of nodes in the subtree rooted at the given node using an in-order traversal. 150func (node *BinaryNode) printSubTreeInOrder() { 151\tif node != nil { 152\tnode.left.printSubTreeInOrder() 153\tfmt.Printf(\u0026#34;%d \u0026#34;, node.data) 154\tnode.right.printSubTreeInOrder() 155\t} 156} 157 158// printSubTreePreOrder prints the values of nodes in the subtree rooted at the given node using a pre-order traversal. 159func (node *BinaryNode) printSubTreePreOrder() { 160\tif node != nil { 161\tfmt.Printf(\u0026#34;%d \u0026#34;, node.data) 162\tnode.left.printSubTreePreOrder() 163\tnode.right.printSubTreePreOrder() 164\t} 165} 166 167// printSubTreePostOrder prints the values of nodes in the subtree rooted at the given node using a post-order traversal. 168func (node *BinaryNode) printSubTreePostOrder() { 169\tif node != nil { 170\tnode.left.printSubTreePostOrder() 171\tnode.right.printSubTreePostOrder() 172\tfmt.Printf(\u0026#34;%d \u0026#34;, node.data) 173\t} 174} 175 176func main() { 177\t// Create a new binary tree 178\ttree := BinaryTree{} 179\t180\t// Insert nodes 181\ttree.insertFromRoot(1) 182\ttree.insertFromRoot(2) 183\ttree.insertFromRoot(3) 184\ttree.insertFromRoot(4) 185\ttree.insertFromRoot(5) 186\ttree.insertFromRoot(6) 187\ttree.insertFromRoot(7)\t188\t189\tfmt.Println(\u0026#34;In-Order Traversal:\u0026#34;) 190\ttree.printTreeInOrder() 191\t192\tfmt.Println(\u0026#34;\\nPre-Order Traversal:\u0026#34;) 193\ttree.printTreePreOrder() 194\t195\tfmt.Println(\u0026#34;\\nPost-Order Traversal:\u0026#34;) 196\ttree.printTreePostOrder() 197\t198\t// Search for a node 199\tfmt.Println(\u0026#34;\\n\\nSearching for node with data 6:\u0026#34;) 200\tnodeToSearch := tree.searchFromRoot(6) 201\t202\tif nodeToSearch != nil { 203\tfmt.Println(\u0026#34;found node with data 6:\u0026#34;, nodeToSearch.data) 204\t} else { 205\tfmt.Println(\u0026#34;node with data 6 not found.\u0026#34;) 206\t} 207\t208\tfmt.Println(\u0026#34;\\nSearching for node with data 9:\u0026#34;) 209\tnodeToSearch = tree.searchFromRoot(9) 210\t211\tif nodeToSearch != nil { 212\tfmt.Println(\u0026#34;found node with data 9:\u0026#34;, nodeToSearch.data) 213\t} else { 214\tfmt.Println(\u0026#34;node with data 9 not found.\u0026#34;) 215\t} 216\t217\tfmt.Println(\u0026#34;\\nDeleting node with data 4:\u0026#34;) 218\tnodeToDelete := tree.searchFromRoot(4) 219\t220\tif nodeToDelete != nil { 221\tfmt.Println(\u0026#34;deleted node with data 4.\u0026#34;) 222\ttree.deleteFromRoot(nodeToDelete) 223\t} else { 224\tfmt.Println(\u0026#34;node with data 4 not found.\u0026#34;) 225\t} 226\t227\tfmt.Println(\u0026#34;\\nIn-Order Traversal after deletion:\u0026#34;) 228\ttree.printTreeInOrder() 229} خروجی کد بالا:\n1In-Order Traversal: 24 2 5 1 6 3 7 3Pre-Order Traversal: 41 2 4 5 3 6 7 5Post-Order Traversal: 64 5 2 6 7 3 1 7 8Searching for node with data 6: 9found node with data 6: 6 10 11Searching for node with data 9: 12node with data 9 not found. 13 14Deleting node with data 4: 15deleted node with data 4. 16 17In-Order Traversal after deletion: 187 2 5 1 6 3 10.1.8 Binary Search Tree in Go # درخت جستجو دودویی یک نوع از درخت دودویی است که ب هر گره دارای یک مقدار داده و دو زیردرخت (زیردرخت چپ و زیردرخت راست) می‌باشد. در این درخت، داده‌های کوچکتر از مقدار دادهٔ گره مورد نظر در زیردرخت چپ قرار می‌گیرند و داده‌های بزرگتر در زیردرخت راست قرار می‌گیرند . درخت جستجو دودویی به گونه ای طراحی شده است که عملیات جستجو، افزودن و حذف به طور موثر انجام شود\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5// BinarySearchTree represents a binary search tree. 6type BinarySearchTree struct { 7\troot *BinarySearchNode 8} 9 10// BinarySearchNode represents a node in the binary search tree. 11type BinarySearchNode struct { 12\tdata int 13\tleft *BinarySearchNode 14\tright *BinarySearchNode 15} 16 17// insertFromRoot inserts a new node with the given data into the binary search tree, starting from the root of the tree. 18func (tree *BinarySearchTree) insertFromRoot(data int) *BinarySearchTree { 19\tif tree.root != nil { 20\ttree.root.insertNode(data) 21\t} else { 22\ttree.root = \u0026amp;BinarySearchNode{data: data} 23\t} 24\t25\treturn tree 26} 27 28// insertNode inserts a new node with the given data into the binary search tree rooted at the current node. 29func (node *BinarySearchNode) insertNode(data int) *BinarySearchNode { 30\tif node == nil { 31\treturn \u0026amp;BinarySearchNode{data: data} 32\t} else if data == node.data { 33\treturn node 34\t} else if data \u0026gt; node.data { 35\tnode.right = node.right.insertNode(data) 36\t} else { 37\tnode.left = node.left.insertNode(data) 38\t} 39 40\treturn node 41} 42 43// deleteFromRoot deletes a specific node from the binary search tree starting from the root node. 44func (tree *BinarySearchTree) deleteFromRoot(nodeToDelete *BinarySearchNode) *BinarySearchNode { 45\tif tree.root != nil { 46\treturn tree.root.left.deleteNode(nodeToDelete) 47\t} 48\t49\treturn nil 50} 51 52// deleteNode recursively deletes a specific node from the subtree rooted at the current node. 53func (node *BinarySearchNode) deleteNode(nodeToDelete *BinarySearchNode) *BinarySearchNode { 54\tif node == nil { 55\treturn nil 56\t} 57\t58\tif nodeToDelete.data \u0026lt; node.data { 59\tnode.left = node.left.deleteNode(nodeToDelete) 60\t} else if nodeToDelete.data \u0026gt; node.data { 61\tnode.right = node.right.deleteNode(nodeToDelete) 62\t} else { 63\t64\tif node.left == nil { 65\treturn node.right 66\t} else if node.right == nil { 67\treturn node.left 68\t} 69 70\tminNode := node.right.findMin() 71\tnode.data = minNode.data 72\tnode.right = node.right.deleteNode(nodeToDelete) 73\t} 74\t75\treturn node 76 77} 78 79// findMin returns the minimum node value in the subtree rooted at the current node. 80func (node *BinarySearchNode) findMin() *BinarySearchNode { 81\tfor node.left != nil { 82\tnode = node.left 83\t} 84 85\treturn node 86} 87 88// searchFromRoot searches for a node with the specified data in the binary search tree starting from the root node. 89func (tree *BinarySearchTree) searchFromRoot(data int) *BinarySearchNode { 90\tif tree.root != nil { 91\treturn tree.root.searchNode(data) 92\t} 93\t94\treturn nil 95} 96 97 98 99// searchNode recursively searches for a node with the specified data in the subtree rooted at the current node. 100func (node *BinarySearchNode) searchNode(data int) *BinarySearchNode { 101\tif node == nil { 102\treturn nil 103\t} 104 105\tif node.data == data { 106\treturn node 107\t} else if data \u0026gt; node.data { 108\treturn node.right.searchNode(data) 109\t} else if data \u0026lt; node.data { 110\treturn node.left.searchNode(data) 111\t} 112 113\treturn nil 114} 115 116// printTreeInOrder prints the values of nodes in the binary search tree starting from root using an in-order traversal. 117func (tree *BinarySearchTree) printTreeInOrder() { 118\tif tree.root != nil { 119\ttree.root.printSubTreeInOrder() 120\t} 121} 122 123// printTreePreOrder prints the values of nodes in the binary search tree starting from root using a pre-order traversal. 124 125func (tree *BinarySearchTree) printTreePreOrder() { 126\tif tree.root != nil { 127\ttree.root.printSubTreePreOrder() 128\t} 129} 130 131// printTreePostOrder prints the values of nodes in the binary search tree starting from root using a post-order traversal. 132func (tree *BinarySearchTree) printTreePostOrder() { 133\tif tree.root != nil { 134\ttree.root.printSubTreePostOrder() 135\t} 136} 137 138// printSubTreeInOrder prints the values of nodes in the subtree rooted at the given node using an in-order traversal. 139func (node *BinarySearchNode) printSubTreeInOrder() { 140\tif node != nil { 141\tnode.left.printSubTreeInOrder() 142\tfmt.Printf(\u0026#34;%d \u0026#34;, node.data) 143\tnode.right.printSubTreeInOrder() 144\t} 145} 146 147// printSubTreePreOrder prints the values of nodes in the subtree rooted at the given node using a pre-order traversal. 148func (node *BinarySearchNode) printSubTreePreOrder() { 149\tif node != nil { 150\tfmt.Printf(\u0026#34;%d \u0026#34;, node.data) 151\tnode.left.printSubTreePreOrder() 152\tnode.right.printSubTreePreOrder() 153\t} 154} 155 156// printSubTreePostOrder prints the values of nodes in the subtree rooted at the given node using a post-order traversal. 157func (node *BinarySearchNode) printSubTreePostOrder() { 158\tif node != nil { 159\tnode.left.printSubTreePostOrder() 160\tnode.right.printSubTreePostOrder() 161\tfmt.Printf(\u0026#34;%d \u0026#34;, node.data) 162\t} 163} 164 165func main() { 166\t167\t// Create a BinarySearchTree 168\tbst := \u0026amp;BinarySearchTree{} 169\tbst.insertFromRoot(5).insertFromRoot(3).insertFromRoot(7).\t170\tinsertFromRoot(2).insertFromRoot(4) 171\t172\tfmt.Println(\u0026#34;In-order traversal:\u0026#34;) 173\tbst.printTreeInOrder() 174\t175\tfmt.Println(\u0026#34;\\nPre-order traversal:\u0026#34;) 176\tbst.printTreePreOrder() 177 178\tfmt.Println(\u0026#34;\\nPost-order traversal:\u0026#34;) 179\tbst.printTreePostOrder() 180 181\t// Search for a node 182\tfmt.Println(\u0026#34;\\n Searching for node with data 1\u0026#34;) 183\tsearchNode := bst.searchFromRoot(1) 184\tif searchNode != nil { 185\tfmt.Printf(\u0026#34;Node %d found.\\n\u0026#34;, searchNode.data) 186\t} else { 187\tfmt.Println(\u0026#34;Node not found.\u0026#34;) 188\t} 189 190\t// Search for a node 191\tfmt.Println(\u0026#34;Searching for node with data 3\u0026#34;) 192\tsearchNode = bst.searchFromRoot(3) 193\tif searchNode != nil {\t194\tfmt.Printf(\u0026#34;Node %d found.\\n\u0026#34;, searchNode.data) 195\t} else { 196\tfmt.Println(\u0026#34;Node not found.\u0026#34;) 197\t} 198\t199\t// Delete a node 200\tbst.deleteFromRoot(searchNode) 201\tfmt.Println(\u0026#34;In-order traversal after deleting 3:\u0026#34;) 202\tbst.printTreeInOrder() 203} خروجی کد بالا:\n1In-order traversal: 22 3 4 5 7 3Pre-order traversal: 45 3 2 4 7 5Post-order traversal: 62 4 3 7 5 7Searching for node with data 1 8Node not found. 9Searching for node with data 3 10Node 3 found. 11In-order traversal after deleting 3: 122 4 5 7 "}]