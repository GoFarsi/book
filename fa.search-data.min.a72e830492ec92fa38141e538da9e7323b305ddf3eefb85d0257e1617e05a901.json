[{"id":0,"href":"/preface/","title":"پیشگفتار","section":"صفحه اصلی","content":" چرا از گو استفاده می‌کنیم؟\nوقتی در نوامبر سال ۲۰۰۹ رابرت گریسیمر، راب پایک و کن تامپسون برای اولین‌بار گو را بصورت عمومی انتشار دادند، خودشان مطمئن نبودند که به‌صورت گسترده مورد استفاده قرار می‌گیرد یا خیر. تا به تاریخ انتشار این مطلب، مشخص شده،‌گو بسیار فراگیرتر و رشد آن در صنعت وسیع‌تر از چیزی بوده‌است که ایجادکنندگان آن حدس می‌زدند. این‌ها نمونه‌هایی از کاربرد گو در دنیای امروز تکنولوژی هستند:\nGoogle’s Core Data Solutions Team Uses Go تیم راهکار هسته‌ی داده گوگل از گو استفاده می‌کند Chrome Content Optimization Service Runs on Go سرویس بهینه‌سازی محتوا در گوگل‌کروم توسط گو در حال اجراست Chrome’s user experience strategy, operating in the critical path for users is implemented in Go استراتژی حیاتی تجربه کاربری در کروم توسط گو پیاده‌سازی شده است Firebase Hosting Team Scaled With Go ابزار قدرتمند فایربیس توسط گو گسترش یافته است همچنین در صفحه رسمی گو می‌توانید لیستی از شرکت‌ها از Netflix و PayPal تا Uber و Microsoft رو به‌همراه خدماتی که از گو گرفته‌اند رو ملاحظه کنید. https://go.dev/solutions/#case-studies شناخت نیازمندی و ابزارهای پیاده‌سازی وابسته به آن.\nCloud \u0026amp; Network Services Command-line Interfaces Web Development DevOps \u0026amp; Site Reliability انواع منابع موجود جهت کسب اطلاعات و مقایسه‌ی آن‌ها.\nمنابع مکتوب. سایت رسمی زبان گو. https://go.dev در نسخه حال‌حاضر وب‌سایت رسمی گو، مستندات لازم برای شناخت انواع جزئیات وجود دارد. ضمن‌اینکه یک خودآموز مختصر، جهت آشنایی ابتدایی مفاهیم را می‌توانید پیدا کنید. کتاب‌ها. اصولاً استفاده از کتاب‌ها بدلیل اینکه عمدتاً توسط اساتید، متخصصین شناخته‌شده نگارش می‌شود، توصیه می‌گردد. ضمن اینکه کتاب‌ها معمولاً امکان اصلاحات مستمر و انتشار نسخه‌های جدید و به‌روزتر رو دارا هستند و توسط ناشران معتبر منتشر می‌شوند. مقالات. بدلیل راحت‌تر بودن نشر مقالات، طبیعتاً امکان وجود هرنوع مطلبی با هر سطح و کیفیتی از محتوا وجود دارد. بنابراین، در استفاده از این نوع منابع، احتیاط و حساسیت بالاتری مورد نیاز است. منابع صوتی و تصویری. مزیت بزرگ این نوع از منابع، سرعت و امکانات کافی در انتقال مطلب است. اما اشکالی که وجود دارد عدم امکان ساده‌ی اصلاح محتوا و به‌روزرسانی آن است. ضمن‌اینکه این نوع از منابع، مانند مقالات توسط افراد مختلف و با طیفی از انواع کیفیت‌های متفاوت، وجود دارد. بررسی وضعیت منابع فارسی زبان گو در زمان تهیه این کتاب. درحال‌حاضر منابع نگارشی با کیفیت مناسب به‌زبان فارسی بسیار محدود است. این یکی از دلایل «چرایی» نگارش این کتاب به‌زبان فارسی است. ما امیدواریم با مشارکت همه اساتید و متخصصین این حوزه، این کتاب منبع آموزشی باکیفیت، دردسترس عموم متقاضیان، جهت توسعه ابزارهای حرفه‌ای با زبان گو باشد.\nچرا به زبان فارسی می‌نویسیم. دوستان و همکاران بسیاری هستند،‌که این سوال را مطرح می‌کنند که وقتی نیاز به دانش زبان انگلیسی، برای کسب مهارت در این تخصص، یک «باید» محسوب می‌شود، چرا مطلب فارسی؟ جواب این سوال ساده‌تر از پیچیدگی‌هایی هست که بنظر می‌رسد: − ایجاد و رونق جامعه تخصصی فارسی‌زبان توسط موضوع «کتاب» − ایجاد فضایی جهت ایجاد پرسش و پاسخ فارسی‌زبان‌ها − ارائه یک ترجمه فارسی، از منابع اصلی تخصصی، با امکان مقایسه برداشت افراد مختلف از زبان تخصصی − سرعت دادن به یادگیری، حداقل در مفاهیم ابتدایی − برای نوجوانان و افرادی که به‌هر دلیل، درحال‌حاضر تسلط کافی روی زبان انگلیسی ندارند و ارائه راهکار جهت تمرین و شروع یادگیری منابع روی زبان تخصصی\nبرای چگونگی نگارش کتاب می‌توان به موارد زیر اشاره کرد:\nچگونه از جامعه تخصصی، می‌توان در آموزش،بهینه‌سازی و رشد دانش متقاضیان این تخصص استفاده کرد. یکی از وظایف هر استاد، تربیت «شاگرد» و توسعه دانش است. افراد تازه‌کار با دانش و تجربه پیشکسوتان، با سرعت و کیفیت بالاتر، تبدیل به متخصصین جدید خواهند شد. کیفیت جامعه متخصصین، امکان کنترل مصرف منابع و تولید ابزارهای مفید را تعیین خواهد کرد. کار تیمی، به فرهنگ «با هم کار کردن» نیازمند است.\nچرخ را از نو نسازیم، تجربه‌ها را از نو «تجربه» نکنیم، آموزش ببینیم و آموزش بدهیم. با کمی دقت و تجربه، کاملاً بدیهی‌ست در مقام قیاس بین چند جامعه تخصصی همسان، برتری از آن کسانی‌ست که در انتقال دانش-تجربه دست‌و‌دل‌بازتر هستند. جامعه تخصصی با دانش و تجربه عمیق، نیازمند وجود «مبتدیان» با پتانسیل حداکثری است و این میسر نیست مگر با جریان ساده و پایدار آموزش. دانش امروز، در هر رشته و هر سطح برآیند «انتقال» پیشینیان ما است. به جای غرور ناشی از آن می‌توان از انتقال آن به دیگران لذت برد.\n«کلمات» قدرت دارند. به درک و استفاده از کلمات احترام بگذاریم. در جامعه تخصصی حتی چند‌برابر !!! تا جای ممکن، در استفاده از کلمات تخصصی در محل درست خود دقت شده تا مفهوم نادرست منتقل نشود. از شما خواننده عزیز هم تقاضا داریم، هرکجا ایرادی هرچند کوچک ملاحظه فرمودید، به ما اطلاع دهید یا درخواست اصلاح آن را ارسال کنید.\n"},{"id":1,"href":"/history/","title":"تاریخچه","section":"صفحه اصلی","content":"زبان گو (Go) در سال ۲۰۰۷ (به شمسی: ۱۳۸۶) توسط «شرکت گوگل» با هدف افزایش بهره‌وری برنامه‌نویسی در محیط چندهسته‌ای، رایانه‌های شبکه‌ای و کدبیس‌های بزرگ طراحی شد [به نقل از ویکی‌پدیا] و سپس به عنوان یک زبان کامپایلری و تایپ استاتیک در نوامبر سال ۲۰۰۹ به‌صورت عمومی با هدف کامپایل کارآمد ، اجرای کارآمد و سهولت برنامه‌نویسی عرضه شد. بسیاری از اعضای تیم طراحی و توسعه زبان گو [Ken Thompson, Rob Pike, Robert Griesemer] سال‌ها تجربه در زمینه تحقیق و توسعه زبان برنامه‌نویسی دارند.\nتاریخچه زبان گولنگ به سال ۲۰۰۷ میلادی برمیگردد.وقتی که سه برنامه‌نویس تصمیم گرفتند یک زبان برنامه‌نویسی جدید با ترکیبی از ویژگی‌های مختلف را توسعه دهند. هدف آنها این بود که زبانی سریع، ساده، قابل استفاده و مؤثر برای توسعه نرم‌افزارهای همزمان و مقیاس‌پذیر بسازند.\nگولنگ از زبان‌هایی چون pascal، c و oberon الهام گرفته است. هدف توسعه دهندگان گولنگ ساده‌تر کردن فرایند طراحی و ساخت نرم افزارهای مقایس‌پذیر بوده. آن‌ها در طراحی گولنگ تلاش کردند تا عملکرد زبان را بهبود بخشند و یک سینتکس ساده و خوانا ارائه دهند.\nاز آن زمان تا به امروز، گولنگ رشد و پیشرفت چشمگیری کرده است و استفاده از آن در صنعت نرم‌افزار روز به روز بیشتر می‌شود. شرکت‌های بزرگی مانند Google، Dropbox، YouTube و Docker از گولنگ به عنوان یکی از زبان‌های اصلی خود استفاده می‌کنند. همچنین جامعه برنامه‌نویسی گولنگ به طور فزاینده‌ای در حال رشد است و ابزارها و کتابخانه‌های زیادی با استقاده از گولنگ توسعه داده شده است.\nزبان گو دارای یک سری ویژگی‌های منحصر به فرد می‌باشد و برخی از ویژگی‌هایش از سایر زبان‌ها الهام گرفته شده است :\nپشتیبانی از برنامه‌نویسی همزمانی بصورت Built-in گوروتین ‌ها امکان اجرای همزمانی توابع را فراهم می‌کنند و همچنین گوروتین‌ها واقعا خیلی سبک هستند به طوری که شما می‌توانید هزاران گوروتین را همزمان در سخت افزارهای مدرن بدون هیچ مشکل عملکردی اجرا کنید. سایز اولیه یک گروتین بین 2 تا 3 کیلوبایت است، در صورتی که سایز اولیه یک ترد معمولا از 1 تا 2 مگابایت شروع می شود. این حافظه از استک تخصیص داده می شود. کانال ‌ها برپایه مدل CSP می‌باشد که امکان همگام سازی داده‌ها بین گوروتین‌ها را فراهم می‌کند. پشتیبانی از تایپ‌های map و slice امکان پیاده سازی پلی مورفیسم با استفاده از اینترفیس ‌ها پوینترها کلوژر توابع (یک تابع معمولی که داخل یک تابع دیگر به عنوان بازگشت تعریف می‌شود) متدها امکان defer برای تعویق فراخوانی یک تابع قابلیت جاسازی تایپ‌ها ایمنی حافظه در زبان گو قابلیت زباله جمع کن خودکار سازگاری کامل با انواع پلتفرم‌ها نظیر [linux, windows, mac, AIX, android, freeBSD] جهت توسعه و کامپایل امکان Cross-compile با این امکان می‌توانید در هر پلتفرمی برای سایر پلتفرم‌ها کامپایل کنید پشتیبانی از جنریک یا تایپ پارامتر (از نسخه ۱.۱۸) تست نویسی آسان اینترفیس و رفلکشن زبان گو برخلاف زبان‌هایی نظیر c, cpp یا java نیاز به نقطه ویرگول (Semicolons) ندارد و به نسبت زبان‌هایی که معرفی کردیم پرانتز کمتری استفاده می‌کند و همچنین ظاهر سینتکس گو خیلی خواناتر و راحت‌تر می‌باشد. علاوه بر ویژگی‌هایی که در بالا معرفی کردیم یک سری نکات برجسته در خصوص زبان گو وجود دارد که به شرح زیر می‌باشند:\nسینتکس این زبان به گونه‌ای ساده و تمیز طراحی شده که فرآیند یادگیری آن را آسان‌تر می‌کند و از همه مهم‌تر توسعه پروژه‌های مقیاس‌پذیر با زبان گو به دلیل سادگی و آشکار بودن مفاهیم خیلی سریع‌تر صورت می‌گیرد.\nزبان گو دارای تعداد زیادی پکیج‌های استاندارد و کاربردی جهت توسعه می‌باشد که همه این پکیج‌ها در انواع پلتفرم‌ها جهت توسعه قابل استفاده است.\nزبان گو دارای یک جامعه بزرگ از توسعه دهندگان و انجمن‌های فعال می‌باشد که خیلی سریع می‌توانید به پاسخ سوالات خود برسید.\nبرنامه نویس‌های زبان گو را گوفر صدا می‌زنند. گوفر نام یک نوع موش و همچنین نماد گولنگ است. "},{"id":2,"href":"/why-go/","title":"چرا زبان Go؟","section":"صفحه اصلی","content":"زبان Go (یا Golang) با تأکید بر سادگی سینتکسی، سرعت بالا، و پشتیبانی قوی از همزمانی، گزینه‌ای بی‌نظیر برای توسعه‌دهندگان و تیم‌های مهندسی نرم‌افزار به‌شمار می‌آید. Go با بهره‌گیری از کامپایل سریع و استاتیک، اجرای باینری‌های مستقل با سرعتی نزدیک به زبان‌های سطح پایین را ممکن می‌سازد. یکی از برجسته‌ترین قابلیت‌های آن، مدل درون‌ساختاری همزمانی مبتنی بر goroutine و channel است که پردازش موازی با مصرف حافظه بهینه را تسهیل می‌کند. علاوه بر این، وجود جمع‌آوری خودکار حافظه (GC) و مجموعه ابزار استاندارد (از جمله go fmt، go test، go doc و…) روند توسعه را شفاف و قابل‌پیش‌بینی می‌کند. با پشتوانه رسمی گوگل و پذیرش گسترده در پروژه‌های ابری، زیرساخت‌ها و شرکت‌های مطرح (مثل Docker، Kubernetes، Uber)، Go به ابزاری کلیدی در اکوسیستم مدرن توسعه نرم‌افزار تبدیل شده است.\n🎯 ۱. سادگی و خوانایی دقیق در طراحی زبان # Go برای افرادی طراحی شده که به دنبال زبانی با سینتکسی ساده و بدون پیچیدگی‌های مرسوم هستند. نحو آن الهام‌گرفته از خانواده C است اما خبری از ساختارهای پیچیده‌ای مثل «وراثت کلاسیک» نیست.\nاین سادگی کمک می‌کند توسعه‌دهنده بتواند زبان را در عرض یک روز یاد بگیرد و سریع وارد برنامه‌نویسی واقعی شود (Applied Go). ابزار یکپارچه go fmt استانداردسازی کد را تضمین می‌کند و باعث می‌شود تیم‌ها همیشه بر روی قالب یکسانی کد بزنند (Sariasan, Wikipedia).\n⚡ ۲. سرعت در کامپایل و اجرا # Go یک زبان کامپایل‌شده و دارای تایپ استاتیک است—کد مستقیم به باینری اجراشده تبدیل می‌شود، بدون وابستگی به ماشین مجازی. نتیجه: سرعت فوق‌العاده در زمان اجرا. در واقع، گوگل با طراحی Go توانست هزاران خط کد را در کمتر از ۱۰ ثانیه کامپایل کند (WIRED). ♾️ ۳. همزمانی قدرتمند با Goroutines و Channels # Go با goroutine‌ها (ریسمان‌های سبُک‌وزن) و channelهایی برای ارتباط امن بین آنها، همزمانی را در سطح زبان نهادینه کرده (Faradars Blog). این ساختار، اجرای میلیون‌ها goroutine را با استفاده‌ی بسیار کمتر از حافظه امکان‌پذیر می‌سازد — برخلاف thread‌های سنگین جاوا — که مناسب سرویس‌های مقیاس‌پذیر و پرکار است (uptech.team, Sariasan). فلسفه Go در همزمانی این است: «با ارتباط بین حافظه به اشتراک‌گذاری انجام می‌شود، نه با اشتراک‌گذاری حافظه» (Sariasan). 🧠 ۴. مدیریت حافظه خودکار (Garbage Collection) # Go مجهز به سیستم جمع‌آوری زباله (GC) داخلی است که حافظه را به‌صورت خودکار آزاد می‌کند. این موضوع باعث افزایش بهره‌وری و کاهش پیچیدگی برای توسعه‌دهندگان می‌شود، بدون کاهش محسوس کارایی (مبین هاست). 📚 ۵. کتابخانه استاندارد کامل و ابزارهای توسعه # زبان Go همراه با مجموعه استاندارد بزرگی از کتابخانه‌های داخلی برای مواردی مانند تست، قالب‌سازی، همگام‌سازی و مدیریت بسته است (Quera). ابزارهایی مانند go build, go test, go vet, go doc و پروفایل‌سازی/debugging داخلی، محیطی حرفه‌ای برای تمام سطوح توسعه را فراهم می‌کنند (Wikipedia). 🏢 ۶. پشتوانه گوگل و اکوسیستم بالغ # Go در ۲۰۰۷ توسط راب گرایسمر، راب پایک و کن تامپسون در گوگل طراحی شد و در سال ۲۰۱۲ به نسخه ۱.۰ رسید. گوگل هنوز از آن در زیرساخت‌های بزرگ خود بهره می‌برد (JobVision). اکوسیستم متنوعی از شرکت‌های بزرگ مثل Docker، Kubernetes، Uber، Dropbox، Netflix و … از Go استفاده می‌کنند (mytaskpanel.com). 🧩 ۷. مقیاس‌پذیری طبیعی برای زیرساخت‌ها و کلاد نیتیو # طراحی نیتیو Go برای شبکه، موازی‌سازی، پردازش سرویس باعث شده گزینه‌ای بسیار مناسب برای توسعه برنامه‌های میکروسرویس، ابزارهای DevOps و سرویس‌های ابری باشد (مبین هاست, Sariasan, Wikipedia). پروژه‌های بزرگی مانند Docker و Kubernetes کاملًا با Go نوشته شده‌اند، که نشانه پختگی زبان در حوزه زیرساخت است (مبین هاست, Sariasan). 📚 منابع پیشنهادی: # مقاله فارسی «مهم‌ترین مزایای زبان برنامه‌نویسی گولنگ چیست؟» در ویرگول (Sariasan, Wikipedia, نیک آموز, JobVision, Quera) بررسی جامع ابزارها و فلسفه همزمانی در ویکی‌پدیا Go (Wikipedia) مقاله evaluate‌شده در Medium درباره سادگی و مدیریت حافظه (medium.com) پست رسمی گوگل در Wired (2009) درباره معرفی Go و ویژگی‌های کلیدی (WIRED) "},{"id":3,"href":"/installation/","title":"آموزش نصب","section":"صفحه اصلی","content":"جهت نصب زبان گو بر روی سیستم عامل مورد نظر خود در ابتدا باید نسخه مناسب با پلت‌فرم خود را دانلود کنید.\nنکته:\nوب سایت گولنگ ایران را تحریم کرده است و احتمالا برای دانلود کردن گولنگ با مشکل مواجه می شوید. برای اینکه بتوانید تحریم ها را دور بزنید، روش های زیادی وجود دارد. یکی از مرسوم ترین روش ها استفاده از یک سرویس دی ان اس مانند شکن است.\nلینوکس در اینجا نسخه مرتبط با لینوکس خود را دانلود کنید. $ wget -c https://go.dev/dl/go1.xx.x.linux-amd64.tar.gz سپس دستور زیر را بزنید تا اگر نسخه قبلی وجود دارد پاک شود و نسخه جدید در مسیر usr/local/go/ جایگزین شود. $ sudo rm -rf /usr/local/go \u0026amp;\u0026amp; sudo tar -C /usr/local -xzf go1.xx.x.linux-amd64.tar.gz افزودن مسیر usr/local/go/bin/ به متغیرهای محیطی export PATH=$PATH:/usr/local/go/bin بهتر است برای اینکه هر بار ترمینال را باز می‌کنید و فایل go توسط shell شناخته شود دستور فوق را به فایل home/{user}/.profile/ اضافه کنید. جهت اطمینان از اینکه زبان گو به‌درستی بر روی سیستم عامل شما نصب شده است دستور زیر را داخل ترمینال بزنید. $ go version ویندوز روش اول # در اینجا نسخه مرتبط با ویندوز خود را دانلود کنید. سپس فایل go1.xx.x.windows-{arch}.msi را اجرا کنید. مراحل نصب را به‌صورت پیش فرض طی کنید تا زبان گو برروی ویندوز نصب شود. پس از نصب، جهت اطمینان از نصب بودن زبان گو، مراحل زیر را انجام دهید: وارد منو استارت شوید. در منو استارت کلمه cmd را جستجو کنید و سپس آن را اجرا کنید. داخل خط فرمان دستور زیر را بزنید تا از نصب بودن زبان گو اطمینان حاصل فرمایید. go version روش دوم # برای نصب گو می‌توانید از Chocolatey Package Manager استفاده کنید.\nخط فرمان PowerShell را به صورت Administrator باز کنید و دستور زیر را داخل PowerShell بزنید. Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1')) بعد از نصب می‌توانید از دستور choco برای نصب گو استفاده کنید. choco install golang جهت اطمینان از اینکه زبان گو به‌درستی بر روی سیستم عامل شما نصب شده است دستور زیر را داخل ترمینال بزنید. $ go version دقت داشته باشید برای نصب برنامه‌های مختلف مثل git و یا ابزارهای دیگر در محیط Administrator باید از دستور choco استفاده کنید. مکینتاش روش اول # در اینجا نسخه مرتبط با مکینتاش خود را دانلود کنید. سپس فایل go1.xx.x.darwin-{arch}.pkg را اجرا کنید. مراحل نصب را به‌صورت پیش فرض طی کنید تا زبان گو برروی مکینتاش نصب شود. پس از نصب اگر ترمینال باز بود آن را کامل ببندید تا تغییرات صورت گیرد. جهت اطمینان از اینکه زبان گو به‌درستی بر روی سیستم عامل شما نصب شده است دستور زیر را داخل ترمینال بزنید. $ go version روش دوم # برای نصب گو میتوانید از Homebrew Package Manager استفاده کنید.\nبرای نصب brew می‌توانید ترمینال خود را باز کنید و از دستور زیر استفاده کنید. $ /bin/bash -c \u0026quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026quot; بعد از نصب brew از دستور زیر برای نصب گو داخل ترمینال استفاده کنید. $ brew update \u0026amp;\u0026amp; brew install golang جهت اطمینان از اینکه زبان گو به‌درستی بر روی سیستم عامل شما نصب شده است، دستور زیر را داخل ترمینال بزنید. $ go version "},{"id":4,"href":"/toolchain/","title":"ابزارها, دستورات گو و معرفی IDE","section":"صفحه اصلی","content":"پس از اینکه زبان گو را برروی سیستم خود نصب کردید از طریق ترمینال و یا خط فرمان ویندوز قابل دسترس است که می‌توانید با زدن کلمه go یکسری عملیات انجام دهید:\n$ go Go is a tool for managing Go source code. Usage: go \u0026lt;command\u0026gt; [arguments] The commands are: bug start a bug report build compile packages and dependencies clean remove object files and cached files doc show documentation for package or symbol env print Go environment information fix update packages to use new APIs fmt gofmt (reformat) package sources generate generate Go files by processing source get add dependencies to current module and install them install compile and install packages and dependencies list list packages or modules mod module maintenance work workspace maintenance run compile and run Go program test test packages tool run specified go tool version print Go version vet report likely mistakes in packages Use \u0026quot;go help \u0026lt;command\u0026gt;\u0026quot; for more information about a command. Additional help topics: buildconstraint build constraints buildmode build modes c calling between Go and C cache build and test caching environment environment variables filetype file types go.mod the go.mod file gopath GOPATH environment variable gopath-get legacy GOPATH go get goproxy module proxy protocol importpath import path syntax modules modules, module versions, and more module-get module-aware go get module-auth module authentication using go.sum packages package lists and patterns private configuration for downloading non-public code testflag testing flags testfunc testing functions vcs controlling version control with GOVCS Use \u0026quot;go help \u0026lt;topic\u0026gt;\u0026quot; for more information about that topic. جدول دستورات (Commands) # دستور توضیحات build با این دستور (go build main.go) می‌توانید فایل go را کامپایل کنید. clean با این دستور می‌توانید فایل‌های کش‌شده را پاکسازی کنید. doc با این دستور (go doc fmt.Println) می‌توانید داکیومنت هر یک از توابع عمومی را ببینید. env با این دستور می‌توانید متغیرهای محیطی تنظیم شده زبان گو را ببینید و آن‌ها را با دستور go env -w key=value مقداردهی کنید. fmt با این دستور می‌توانید کدهای خود را مرتب go fmt ./... کنید. install با استفاده از این دستور می‌توانید یکسری پکیج‌ها را گرفته و کامپایل کنید. list لیست پکیج‌ها و ماژول‌های دانلود شده. generate با این دستور می‌توانید از قابلیت Generator زبان گو استفاده کنید و فایل generate کنید. mod برای مدیریت و ایجاد فایل mod به ازای هر پروژه. get با این دستور می‌توانید پکیجی را دانلود یا بروزرسانی کنید و همچنین برای استفاده از این دستور نیاز به git دارید که نصب باشد. work با این دستور می‌توانید یک workspace ایجاد کنید و آن را مدیریت کنید. run با این دستور (go run main.go) می‌توانید فایل‌های گو یا پروژه را اجرا کنید. test با این دستور (go test example_test.go) می‌توانید فایل‌های تست را اجرا کنید. version با این دستور می‌توانید نسخه نصب شده زبان گو را ببینید. vet با این دستور می‌توانید اشتباهات کدهای خود را ببینید. اجرای کد ساده در زبان گو # در زیر یک نمونه کد ساده قرار دادیم که به سادگی می‌توانید با دستور go run main.go اجرا کنید و خروجی را ببینید.\npackage main import \u0026quot;fmt\u0026quot; func main() { fmt.Println(\u0026quot;Hello world!!!\u0026quot;) } $ go run main.go Hello world!!! در کد فوق، ما یکسری کلید واژه نظیر package , import , func استفاده کردیم که در بخش 1.2 کلید واژه و شناسه‌ها با آن‌ها آشنا می‌شوید.\nانواع نرم‌افزارهای محیط توسعه (IDE) و ویرایشگر کد (Code Editor) # در زبان برنامه‌نویسی گو نیز مثل سایر زبان‌ها، می‌توان از ابزارهای کدنویسی مانند نرم‌افزارهای محیط توسعه و همچنین از ویرایشگرهای کد استفاده کرد که محبوب‌ترین‌ها معرفی می‌شوند:\nنرم‌افزار Jetbrains Goland اگر با سایر محصولات جت‌برینز آشنا باشید به‌راحتی می‌توانید از این نرم‌افزار محیط توسعه استفاده کنید. نرم‌افزار VsCode تقریباً همه برنامه‌نویس‌ها با آن آشنا هستند. یک ویرایشگر کد متن‌باز می‌باشد که بین برنامه‌نویس‌ها خیلی محبوب است و برای استفاده زبان گو در این نرم‌افزار می‌توان افزونه vscode-go را نصب کنید. نرم‌افزار Vim یک نرم‌افزار متن‌باز و معروف می‌باشد که داخل ترمینال قابل استفاده است و از آن می‌توانید جهت توسعه با زبان گو استفاده کنید و البته نیازمند نصب پلاگین می‌باشد. "},{"id":5,"href":"/roadmap/","title":"نقشه یادگیری زبان گو","section":"صفحه اصلی","content":"نقشه یادگیری زیر roadmap.sh به ترتیب مسیر توصیه شده ی یادگیری ابزارها و مفاهیم اولیه گو، سپس سمت سرور و در نهایت معماری نرم افزار را نشان می‌دهد.\n"},{"id":6,"href":"/interview/","title":"نمونه سوالات مصاحبه","section":"صفحه اصلی","content":"در این بخش ما یکسری سوالات مصاحبه به زبان فارسی ارائه دادیم که برای یافتن ضعف‌ها کاربردی می‌باشد.\n1: چه تایپ‌هایی مقدار zero آن‌ها nil است؟ interfaces slices channels maps pointers functions 2: تایپ‌های نوع Reference؟ Pointers slices maps functions channels 3: تایپ‌های نوع Aggregate؟ Array structs 4: چه وقت باید از پوینتر استفاده کنیم؟ 1- تابعی که یکی از پارامترهای خود را تغییر می‌دهد -وقتی تابعی را فراخوانی می‌کنیم که یک پوینتر را به عنوان پارامتر می‌گیرد، انتظار داریم که متغیر ما تغییر داده شود. اگر شما متغیر را در تابع خود تغییر نمی‌دهید، پس احتمالا نباید از پوینتر استفاده کنید.\n2- عملکرد بهتر -اگر رشته‌ای داشته باشید که شامل یک رمان کامل در حافظه باشد، کپی کردن این متغیر هر بار که به یک تابع جدید ارسال می‌شود، کاری بسیار گران است. ممکن است ارزشمند باشد که به جای این کار یک پوینتر را ارسال کنید، که باعث صرفه‌جویی در پردازنده و حافظه می‌شود. با این حال انجام این کار به قیمت خوانا بودن است، بنابراین فقط در صورت لزوم این بهینه‌سازی را انجام دهید.\n3- به گزینه nil نیاز دارید -گاهی اوقات یک تابع باید بداند که مقدار یک چیزی چیست، همچنین باید وجود یا عدم وجود آن را بداند. معمولا هنگام خواندن JSON از این استفاده می‌کنیم تا بدانیم فیلدی وجود دارد یا خیر.\n5: زبان گولنگ از موارد زیر پشتیبانی نمی‌کند؟ type inheritance operator overloading method overloading pointer arithmetic struct type in consts 6: برای گوروتین ها چه مواقعی از channel و چه مواقعی از mutex استفاده می شود؟ معمولاً در مواقعی که گوروتین ها نیاز به برقراری ارتباط با یکدیگر دارند، از channels استفاده می کنیم. درصورتی که قسمتی از کد ما(برای مثال مقدار متغیری را تغییر می دهیم) که در آن واحد فقط باید یک گوروتین به آن دسترسی داشته باشد، از یک قفل مانند mutext استفاده می کنیم. 7: تفاوت بین goroutine و thread را توضیح دهید. Goroutines سبک وزن هستند و دارای یک استک اولیه کوچک‌تر که به صورت پویا گسترش می‌یابد هستند، این در حالی است که threads استک ثابت دارند. Goroutines هم‌زمانی را در سطح زبان با استفاده از channelها مدیریت می‌کنند، در حالی که threads ممکن است نیاز به lockهای صریح داشته باشند. همچنین، سوئیچینگ بین goroutines کارایی بیشتری نسبت به thread switching دارد. 8: توضیح دهید که interface در Golang چیست و چگونه می‌تواند مورد استفاده قرار گیرد. یک interface در Go یک نوع خاص است که مجموعه‌ای از method signatures را تعریف می‌کند. هر نوع داده‌ای که این متدها را پیاده‌سازی کند، می‌تواند به عنوان آن interface مورد استفاده قرار گیرد. این بدون نیاز به ارث بری صورت می‌گیرد و امکان داکتایپینگ را فراهم می‌کند. 9: چطور می‌توانید memory leak در برنامه‌های نوشته شده به وسیله Golang را شناسایی و مدیریت کنید؟ برای شناسایی memory leaks در Golang، می‌توان از ابزارهایی مانند pprof به همراه نمودارهای ساخته شده بر اساس heap dumps استفاده کرد. برای پیشگیری از memory leaks، باید دقت کرد که از داده‌ها به درستی استفاده شود، حافظه رزرو شده آزاد گردد و منابع بسته شوند هنگامی که دیگر نیازی به آنها نیست. 10: در Golang چگونه می‌توانیم dependency management را انجام دهیم؟ Golang از Go Modules برای مدیریت وابستگی‌ها استفاده می‌کند که به توسعه دهندگان امکان می‌دهد پروژه‌ها را به صورت مستقل از GOPATH راحت‌تر مدیریت کنند. با استفاده از دستوراتی مانند go mod init, go mod tidy, و go mod vendor می‌توان وابستگی‌های لازم برای پروژه را مدیریت کرد. 11: چه زمانی یک channel در Golang باید با buffer مورد استفاده قرار گیرد؟ یک channel با buffer زمانی مورد استفاده قرار گیرد که شما می‌خواهید ارتباطات بین goroutines را بدون ایجاد blocking فوری داشته باشید. این امر می‌تواند بازده کدها را در مواقعی که عملیات‌ها از لحاظ عملکرد اندکی نابرابر هستند، بهبود بخشد. 12: توضیح دهید که defer statement چیست و چرا ممکن است از آن استفاده کنیم. Defer statement برای تضمین اجرای یک تابع مشخص، درست قبل از خارج شدن از تابع فعلی استفاده می‌شود. این برای راحتی در مدیریت منابع مثل بستن فایل‌ها و ارتباطات شبکه استفاده می‌شود که می‌خواهیم اطمینان حاصل کنیم که به‌درستی بسته خواهند شد. 13: در Golang چگونه می‌توانید اطمینان حاصل کنید که یک goroutine نتیجه‌ای تولید می‌کند قبل از اینکه برنامه کار خود را به طور کامل متوقف کند؟ برای اطمینان از اینکه یک goroutine کار خود را به اتمام برساند، معمولا از sync.WaitGroup برای همچین مدیریتی استفاده می‌کنیم. ساختار WaitGroup اجازه می‌دهد تا اصلی‌ترین goroutine صبر کند تا یک یا چند goroutines دیگر کار خود را تمام کنند. 14: توضیح دهید که واحد ایزوله برای کد نویسی در Golang چیست (table-driven tests) و چرا مفید است. Table-driven tests شیوه‌ای برای نوشتن تست‌ها است که از جداول داده برای تعریف چندین case تست بهره می‌برد. این شیوه مفید است زیرا کد تست را می‌توان برای بسیاری از داده‌ها به راحتی توسعه داد و به خوبی سازماندهی می‌شود. 15: چرا Go از ارث بری (inheritance) پشتیبانی نمی‌کند و از composition به عنوان جایگزین استفاده می‌کند؟ Go ارث بری را پیاده‌سازی نمی‌کند زیرا می‌تواند پیچیده شود و معماری نرم‌افزار را سخت‌تر مدیریت کند. در عوض، از composition استفاده می‌کند که می‌تواند code reuse را تشویق کند و طراحی سیستم را ساده‌تر و ماژولارتر می‌کند. 16: آیا در Golang می‌توان از polymorphism استفاده کرد؟ اگر بله، چگونه؟ بله، در Go می‌توان از polymorphism استفاده کرد از طریق استفاده از interfaces. یک interface می‌تواند برای تعریف یک مجموعه از روش‌ها به کار رود و هر نوع که این روش‌ها را پیاده‌سازی کند به عنوان آن نوع interface شناخته شود. 17: چه تفاوتی میان make و new در Golang وجود دارد؟ make در Go برای ایجاد sliceها، maps و channels استفاده می‌شود و یک ابجکت از نوع مورد نظر را با مقدار اولیه مشخصی برمی‌گرداند. از طرفی new یک pointer به یک ابجکت از یک نوع داده‌ای تعریف شده توسط کاربر را برمی‌گرداند که صفر اولیه شده است. 18: متود (method) receivers در Golang چگونه کار می‌کند و تفاوت بین استفاده از pointer receiver و value receiver چیست؟ Method receivers در Go اجازه می‌دهند تا روی نوع معینی از مقادیر عملیات انجام دهیم. استفاده از pointer receiver به ما اجازه می‌دهد تا تغییراتی که در method روی receiver اعمال می‌شوند را بر روی خود آبجکت اصلی اعمال کنیم، در حالیکه استفاده از value receiver یک کپی از مقدار را می‌گیرد و تغییرات او روی کپی صورت می‌گیرد و بر آبجکت اصلی اثر نمی‌گذارد. 19: چگونه می‌توان در Golang یک پکیج اختصاصی ایجاد کرد و چگونه می‌توان آن را در دیگر فایل‌های Go مورد استفاده قرار داد؟ برای ایجاد پکیج اختصاصی در Go، کد مربوطه باید در یک دایرکتوری قرار داده شود و بالای فایل‌های Go باید package mypackage تعریف شود. برای استفاده از پکیج، import \u0026quot;path/to/mypackage\u0026quot; باید در دیگر فایل‌ها قرار داده شود. 20: در Golang، چگونه می‌توانید error handling را اجرا کنید و چه روش‌هایی برای پیاده‌سازی custom error types وجود دارد؟ Error handling در Go اغلب از طریق بازگرداندن ارور از توابع و بررسی آنها انجام می‌شود. برای ایجاد custom error types، می‌توانید از errors.New() برای ایجاد یک ارور ساده استفاده کنید یا یک تایپ که ارور را پیاده‌سازی می‌کند با متدهای اضافی برای داده‌های اضافی مرتبط با ارور ایجاد کرد. 21: کامپایلر گولنگ از نوع AOT است یا JIT؟ تفاوت بین AOT و JIT را بگو. کامپایلر گو یک Ahead Of Time compilation است. تفاوت AOT با JIT در این است که کامپایلر های AOT مستقیم کد ما را تبدیل به machine code می کنند اما در کامپایتر های JIT کد ما تبدیل به یک کد میانی Bytecode می شود و در زمان اجرا توسط runtime engine هر قسمت از برنامه که مورد استفاده قرار می گیرد، تفسیر می شود و تبدیل به machine code می شود. 22: تفاوت بین nil و مقدار صفر در انواع داده چیست؟ در Go مقدار nil مخصوص انواع reference است (مانند slice, map, channel, function, pointer, interface) و به معنای عدم وجود داده یا ارجاع است. مقدار صفر (zero value) برای انواع مقداری مانند int، bool، struct و غیره تعریف می‌شود (مثلاً 0 برای int یا false برای bool) و همیشه یک مقدار معتبر است. 23: تفاوت بین close(channel) و خواندن از یک کانال بسته چیست؟ close(channel) تنها برای ارسال‌کننده استفاده می‌شود تا به دریافت‌کننده‌ها اطلاع دهد داده‌ای دیگر ارسال نخواهد شد. خواندن از یک کانال بسته مقدار صفر نوع داده را برمی‌گرداند بدون این که بلاک شود. ارسال روی کانال بسته panic ایجاد می‌کند. 24: چه زمانی باید از context استفاده کنیم؟ زمانی که نیاز داریم پردازش‌ها یا درخواست‌های طولانی را لغو کنیم یا timeout بگذاریم، از context.Context استفاده می‌کنیم. این ابزار برای همگام‌سازی لغو عملیات بین goroutineها و جلوگیری از resource leak بسیار مهم است. 25: تفاوت sync.Mutex و sync.RWMutex چیست؟ sync.Mutex قفل ساده‌ای است که در یک زمان فقط اجازه دسترسی به یک goroutine را می‌دهد. sync.RWMutex دو حالت دارد: قفل خواندن (می‌تواند همزمان توسط چند goroutine گرفته شود) و قفل نوشتن (انحصاری). این باعث بهبود عملکرد در سناریوهایی با خواندن زیاد و نوشتن کم می‌شود. 26: data race چیست و چگونه می‌توان از آن جلوگیری کرد؟ Data race زمانی رخ می‌دهد که چند goroutine همزمان به یک متغیر مشترک دسترسی پیدا کرده و حداقل یکی از آنها عملیات نوشتن انجام دهد، بدون هماهنگ‌سازی مناسب. جلوگیری: استفاده از sync.Mutex، sync.RWMutex، channelها یا اجتناب از اشتراک داده‌ها. ابزار go run -race می‌تواند این مشکلات را پیدا کند. 27: در چه شرایطی slice باعث memory leak می‌شود؟ زمانی که slice‌ای کوچک ایجاد می‌کنیم ولی همچنان به یک آرایه بزرگ‌تر در حافظه اشاره دارد، GC نمی‌تواند آرایه اصلی را آزاد کند. راه‌حل: ایجاد یک کپی slice جدید با copy یا ساختن slice از ابتدا. 28: تفاوت len و cap در slice چیست؟ len تعداد عناصر موجود در slice را برمی‌گرداند. cap ظرفیت slice را برمی‌گرداند، یعنی تعداد عناصر از اندیس صفر تا انتهای آرایه زیرین که می‌توان بدون تخصیص حافظه جدید استفاده کرد. 29: آیا map در Go thread-safe است؟ خیر. map به صورت پیش‌فرض thread-safe نیست و دسترسی همزمان بدون قفل یا sync.Map باعث panic می‌شود. برای ایمنی، باید از sync.Mutex، sync.RWMutex یا sync.Map استفاده کرد. 30: چگونه می‌توان یک panic را مدیریت کرد بدون اینکه برنامه متوقف شود؟ با استفاده از recover در داخل یک defer می‌توان panic را گرفتن و از توقف کامل برنامه جلوگیری کرد:\ndefer func() { if r := recover(); r != nil { fmt.Println(\u0026quot;Recovered:\u0026quot;, r) } }() 31: تفاوت بین unbuffered و buffered channel چیست؟ Unbuffered channel: ارسال‌کننده تا زمانی که دریافت‌کننده آماده نباشد بلاک می‌شود. Buffered channel: ارسال‌کننده می‌تواند تا ظرفیت کانال داده بفرستد بدون بلاک شدن. دریافت‌کننده فقط زمانی بلاک می‌شود که کانال خالی باشد. 32: چرا نباید از pointer به متغیر loop variable در goroutine استفاده کرد؟ چون همه goroutineها به همان آدرس حافظه اشاره می‌کنند که مقدار آن در هر iteration تغییر می‌کند و باعث نتایج غیرمنتظره می‌شود. باید از یک متغیر محلی کپی‌شده استفاده کرد. 33: تفاوت := و var در تعریف متغیر چیست؟ := فقط در داخل توابع و برای تعریف و مقداردهی اولیه استفاده می‌شود. var در هر جایی (داخل یا بیرون تابع) می‌تواند استفاده شود و امکان تعریف بدون مقدار اولیه (با مقدار صفر) را می‌دهد. 34: چه زمانی باید از sync.Once استفاده کنیم؟ زمانی که می‌خواهیم یک قطعه کد فقط یک‌بار در کل طول عمر برنامه اجرا شود (مثل بارگذاری تنظیمات یا ایجاد اتصال اولیه). 35: تفاوت nil interface و interface حاوی nil چیست؟ nil interface: مقدار و نوع هر دو nil هستند. interface حاوی nil: نوع مشخص شده است ولی مقدار nil است. این تفاوت باعث می‌شود مقایسه مستقیم با nil نتیجه متفاوتی بدهد. 36: آیا گوروتین‌ها به صورت موازی اجرا می‌شوند یا همزمانی (Concurrency) دارند؟ گوروتین‌ها ذاتاً همزمانی دارند و Go scheduler آنها را روی چندین thread اجرا می‌کند. اگر سیستم چند هسته‌ای باشد و GOMAXPROCS متناسب تنظیم شده باشد، گوروتین‌ها می‌توانند موازی اجرا شوند. 37: تفاوت rune و byte چیست؟ byte معادل uint8 است و برای نمایش داده‌های خام یا کاراکترهای ASCII استفاده می‌شود. rune معادل int32 است و برای نمایش یک کاراکتر یونیکد استفاده می‌شود. 38: چرا استفاده بیش از حد از defer می‌تواند بر عملکرد تأثیر بگذارد؟ هر defer یک فراخوانی اضافه ایجاد می‌کند که در خروج از تابع اجرا می‌شود. در مسیرهای پر فراخوانی (hot path)، این می‌تواند باعث افت کارایی شود. در این موارد بهتر است منابع را به صورت دستی آزاد کرد. 39: garbage collector در Go چه زمانی اجرا می‌شود؟ GC در Go به صورت خودکار و همزمان با اجرای برنامه، بر اساس تخصیص حافظه و فشار heap اجرا می‌شود. این فرآیند stop-the-world بسیار کوتاهی دارد تا حافظه غیرقابل دسترسی را آزاد کند. 40: آیا slice به صورت مقادیر (value) پاس داده می‌شود یا ارجاع (reference)؟ Slice خود یک ساختار کوچک است (pointer به آرایه، طول و ظرفیت) که به صورت value پاس داده می‌شود، ولی اشاره‌گر داخل آن باعث می‌شود به آرایه زیرین ارجاع دهد. 41: چه زمانی استفاده از map به جای slice بهینه‌تر است؟ وقتی که نیاز به دسترسی سریع بر اساس کلیدهای غیر ترتیبی داریم یا جستجوی O(1) می‌خواهیم. در مقابل، slice برای داده‌های ترتیبی کوچک و قابل پیمایش سریع‌تر است. 42: چگونه می‌توان ظرفیت اولیه یک map را تعیین کرد و چرا این کار مهم است؟ با استفاده از make(map[KeyType]ValueType, initialCapacity) می‌توان ظرفیت اولیه تعیین کرد. این باعث کاهش عملیات rehash و بهبود عملکرد می‌شود. 43: تفاوت select بدون case و select با default چیست؟ select {} بدون case باعث بلاک شدن دائمی گوروتین می‌شود. select { default: ... } بلافاصله default را اجرا می‌کند اگر هیچ کانالی آماده نباشد. 44: چرا باید منابع مانند فایل یا connection را در defer بلافاصله بعد از ایجاد آن ببندیم؟ این کار تضمین می‌کند که حتی در صورت بروز خطا یا panic، منبع به درستی آزاد شود و از resource leak جلوگیری شود. 45: تفاوت channel جهت‌دار (send-only/receive-only) با channel دوطرفه چیست؟ Send-only: chan\u0026lt;- T فقط اجازه ارسال دارد. Receive-only: \u0026lt;-chan T فقط اجازه دریافت دارد. دوطرفه: chan T می‌تواند هم ارسال و هم دریافت انجام دهد. 46: چگونه می‌توان benchmark در Go نوشت و اجرا کرد؟ با نوشتن تابع‌هایی با امضای func BenchmarkXxx(b *testing.B) و اجرای go test -bench=. می‌توان benchmark گرفت. مقدار b.N مشخص می‌کند چند بار تست اجرا می‌شود. 47: sync.Pool چیست و چه کاربردی دارد؟ sync.Pool یک ساختار برای ذخیره و بازیابی موقت اشیاء قابل استفاده مجدد است که فشار روی GC را کاهش می‌دهد. برای داده‌های موقتی که ایجادشان هزینه‌بر است استفاده می‌شود. 48: تفاوت testing.T و testing.B در پکیج testing چیست؟ testing.T برای تست‌های معمولی و مدیریت خطاها استفاده می‌شود. testing.B برای benchmark استفاده می‌شود و شامل حلقه اجرای تکرارها (b.N) است. 49: آیا Go از tail call optimization پشتیبانی می‌کند؟ خیر، Go به صورت رسمی tail call optimization ندارد. بنابراین توابع بازگشتی عمیق می‌توانند منجر به مصرف زیاد stack شوند. 50: چه تفاوتی بین make و append برای ایجاد slice وجود دارد؟ make یک slice با طول و ظرفیت مشخص ایجاد می‌کند. append برای افزودن عناصر به slice موجود استفاده می‌شود و در صورت پر بودن ظرفیت، یک آرایه جدید ایجاد می‌کند. 51: تفاوت بین زمان‌بندی گوروتین‌ها در Go و threadها در سیستم‌عامل چیست؟ Scheduler گوروتین‌ها در Go به صورت M:N کار می‌کند، یعنی تعداد زیادی گوروتین (M) روی تعداد محدودی thread سیستم‌عامل (N) نگاشت می‌شوند. این مدل سبک‌تر از زمان‌بندی مستقیم threadها توسط سیستم‌عامل است. 52: آیا استفاده از global variable در Go توصیه می‌شود؟ چرا؟ به طور کلی خیر، چون باعث کاهش تست‌پذیری، افزایش coupling و خطر data race می‌شود. در صورت نیاز، باید با قفل یا سایر روش‌های همگام‌سازی محافظت شود. 53: چرا تغییر دادن slice در یک goroutine می‌تواند روی goroutineهای دیگر تأثیر بگذارد؟ چون همه sliceها به یک آرایه زیرین اشاره می‌کنند. تغییر عناصر باعث تغییر در آرایه مشترک و در نتیجه مشاهده تغییرات توسط سایر goroutineها می‌شود. 54: تفاوت string و []byte در Go چیست؟ string غیرقابل تغییر (immutable) است و تغییر مستقیم آن ممکن نیست. []byte قابل تغییر است و برای عملیات پردازشی روی داده‌ها بهینه‌تر است. 55: چرا map در Go iteration order ثابت ندارد؟ برای جلوگیری از وابستگی برنامه‌ها به ترتیب کلیدها و بهبود کارایی، Go عمداً ترتیب پیمایش map را تصادفی می‌کند. 56: چه زمانی باید از atomic operations استفاده کرد؟ زمانی که نیاز به عملیات خواندن/نوشتن thread-safe روی انواع عددی یا آدرس حافظه داریم، بدون استفاده از قفل‌های سنگین مانند Mutex. پکیج sync/atomic برای این منظور استفاده می‌شود. 57: تفاوت nil slice با empty slice چیست؟ Nil slice: nil است، طول و ظرفیت صفر دارد. Empty slice: مقدار غیر nil با طول صفر است، ولی به یک آرایه صفر‌ظرفیت اشاره می‌کند. 58: چرا استفاده از pointer receiver برای struct بزرگ بهینه‌تر است؟ چون از کپی شدن struct بزرگ جلوگیری می‌کند و تغییرات در method روی نمونه اصلی اعمال می‌شود. 59: تفاوت fallthrough در switch چیست؟ در Go، caseها به طور پیش‌فرض break می‌شوند. استفاده از fallthrough باعث می‌شود اجرای case بعدی بدون بررسی شرط ادامه یابد. 60: چرا باید بعد از استفاده از ticker آن را متوقف کنیم؟ عدم توقف (ticker.Stop()) باعث نشت منابع و ادامه کار goroutine داخلی آن می‌شود. 61: تفاوت new و literal برای struct چیست؟ new(T) یک pointer به مقدار صفر نوع T برمی‌گرداند. \u0026amp;T{} نیز یک pointer می‌سازد ولی می‌توان فیلدها را مقداردهی کرد. 62: چرا حلقه for range روی map ممکن است نتیجه متفاوتی در هر اجرا بدهد؟ چون ترتیب پیمایش map در Go عمداً تصادفی است تا از وابستگی برنامه به ترتیب کلیدها جلوگیری شود. 63: تفاوت deep copy و shallow copy در Go چیست؟ Shallow copy فقط مقادیر سطح اول را کپی می‌کند و referenceها همچنان مشترک می‌مانند. Deep copy تمام داده‌ها را بازگشتی کپی می‌کند تا هیچ اشتراک حافظه وجود نداشته باشد. 64: چه زمانی باید از select با context.Done استفاده کنیم؟ وقتی که می‌خواهیم عملیات منتظر روی channel را در صورت لغو context یا timeout متوقف کنیم. 65: تفاوت بین runtime.GOMAXPROCS و تعداد گوروتین‌ها چیست؟ GOMAXPROCS حداکثر تعداد threadهای همزمانی که می‌توانند کد Go اجرا کنند را مشخص می‌کند، ولی تعداد گوروتین‌ها می‌تواند بسیار بیشتر باشد و توسط scheduler مدیریت می‌شود. 66: چرا string در Go غیرقابل تغییر است؟ برای بهینه‌سازی عملکرد و امنیت، string به داده‌های فقط خواندنی اشاره می‌کند. این طراحی اجازه می‌دهد رشته‌ها را به‌طور ایمن بین goroutineها به اشتراک گذاشت بدون نیاز به قفل. 67: تفاوت بین time.Sleep و استفاده از time.After چیست؟ time.Sleep اجرای گوروتین را برای مدت مشخص متوقف می‌کند. time.After یک channel برمی‌گرداند که بعد از گذشت مدت زمان مشخص سیگنال ارسال می‌کند و می‌تواند در select استفاده شود. 68: چرا نباید از panic برای کنترل جریان عادی برنامه استفاده کرد؟ panic برای شرایط غیرمنتظره و خطاهای بحرانی طراحی شده است. استفاده از آن در منطق عادی باعث سختی در خواندن کد، مشکلات تست و مدیریت منابع می‌شود. 69: sync.Cond چیست و چه زمانی استفاده می‌شود؟ sync.Cond ابزاری برای هماهنگ‌سازی پیشرفته است که به goroutineها اجازه می‌دهد تا تا زمان برآورده شدن یک شرط منتظر بمانند و توسط دیگر goroutineها بیدار شوند. 70: تفاوت بین context.Background و context.TODO چیست؟ context.Background برای شروع زنجیره context در برنامه‌های سطح بالا استفاده می‌شود. context.TODO زمانی استفاده می‌شود که هنوز مشخص نیست چه contextی باید استفاده شود یا در حال توسعه هستیم. 71: چرا mapهای بزرگ می‌توانند باعث فشار روی GC شوند؟ چون map ممکن است مقادیر زیادی حافظه تخصیص دهد و GC باید همه کلیدها و مقادیر را بررسی کند. حذف مقادیر غیرضروری یا بازسازی map می‌تواند فشار را کاهش دهد. 72: تفاوت بین کانال بسته و nil channel چیست؟ کانال بسته: خواندن از آن مقدار صفر و وضعیت بسته بودن را برمی‌گرداند. ارسال روی آن panic ایجاد می‌کند. nil channel: هر عملیات ارسال یا دریافت روی آن برای همیشه بلاک می‌شود. 73: چرا استفاده از range روی string با کاراکترهای یونیکد خاص می‌تواند کند باشد؟ زیرا Go هر بار کاراکترها را به صورت rune دیکد می‌کند که شامل تبدیل UTF-8 به int32 است. برای داده‌های ASCII این تبدیل سریع‌تر است. 74: چه زمانی باید از copy برای slice استفاده کنیم؟ وقتی که می‌خواهیم داده‌ها را از یک slice به دیگری منتقل کنیم بدون اینکه به آرایه زیرین مشترک اشاره کنند، مخصوصاً برای جلوگیری از مشکلات memory leak یا تغییرات ناخواسته. 75: تفاوت بین defer با تابع معمولی در مدیریت منابع چیست؟ defer تضمین می‌کند که تابع در پایان محدوده اجرا شود، حتی در صورت panic یا بازگشت زودهنگام، ولی تابع معمولی بلافاصله اجرا می‌شود. 76: چرا نباید روی کانال nil عملیات انجام داد؟ هر ارسال یا دریافت روی کانال nil باعث بلاک شدن بی‌پایان goroutine می‌شود، که معمولاً به صورت ناخواسته deadlock ایجاد می‌کند. 77: تفاوت بین append به slice و append به nil slice چیست؟ هر دو معتبر هستند. append به nil slice باعث ایجاد slice جدید با ظرفیت مورد نیاز می‌شود. 78: چرا حلقه‌های for بدون شرط در Go می‌توانند مشکل‌ساز شوند؟ یک حلقه for {} بدون شرط توقف می‌تواند CPU را ۱۰۰٪ مشغول کند مگر اینکه شامل عملیات بلاک‌کننده یا sleep باشد. 79: sync.Map چه مزیتی نسبت به map با Mutex دارد؟ sync.Map برای سناریوهایی با خواندن زیاد و نوشتن کم بهینه‌سازی شده و نیازی به قفل دستی ندارد، ولی در همه موارد سریع‌تر از map+Mutex نیست. 80: چرا تبدیل بین []byte و string در Go معمولاً باعث کپی می‌شود؟ برای جلوگیری از تغییر داده‌های string (که immutable است)، Go معمولاً داده‌ها را کپی می‌کند. این رفتار هزینه زمانی و حافظه دارد. 81: چرا استفاده از time.Tick بدون توقف می‌تواند memory leak ایجاد کند؟ time.Tick یک channel بازگشتی ایجاد می‌کند که هرگز متوقف نمی‌شود. برای جلوگیری از نشت منابع، بهتر است از time.NewTicker استفاده کرده و در زمان مناسب Stop() را فراخوانی کنید. 82: تفاوت بین interface خالی و interface با متد چیست؟ Interface خالی (interface{}) می‌تواند هر نوعی را نگه دارد. Interface با متدها فقط می‌تواند نوع‌هایی را نگه دارد که تمام متدهای تعریف‌شده را پیاده‌سازی کرده باشند. 83: چرا استفاده از goroutine در حلقه for بدون همگام‌سازی می‌تواند مشکل‌ساز باشد؟ چون متغیرهای حلقه بین goroutineها به اشتراک گذاشته می‌شوند و مقدارشان در زمان اجرا ممکن است تغییر کند. باید متغیر را به صورت محلی کپی یا با آرگومان به goroutine پاس داد. 84: تفاوت بین make برای map و literal map چیست؟ make(map[Key]Value, cap) ظرفیت اولیه را مشخص می‌کند. Literal map (map[Key]Value{...}) بلافاصله داده‌ها را مقداردهی می‌کند. 85: چرا نباید روی کانالی که چند تولیدکننده دارد بدون هماهنگی close انجام داد؟ چون ممکن است چند goroutine همزمان تلاش به بستن کانال کنند که باعث panic می‌شود. معمولاً فقط یک تولیدکننده مسئول close است. 86: تفاوت بین string literal با backtick و با quote چیست؟ با quote (\u0026quot;...\u0026quot;): رشته escape می‌شود و می‌توان از \\n و غیره استفاده کرد. با backtick (`...`): رشته raw است و escape interpretation انجام نمی‌شود. 87: چرا garbage collector نمی‌تواند فایل‌های باز را ببندد؟ GC فقط حافظه را آزاد می‌کند، ولی منابع سیستم‌عاملی مثل فایل‌ها یا socketها را باید به صورت صریح با Close() آزاد کرد. 88: تفاوت بین untyped constant و typed constant چیست؟ Untyped constant می‌تواند با هر نوع سازگار استفاده شود تا زمانی که مقدارش در محدوده باشد. Typed constant نوع مشخص دارد و فقط با همان نوع یا نوع‌های سازگار استفاده می‌شود. 89: چرا استفاده از recover خارج از defer بی‌اثر است؟ چون recover فقط زمانی panic را می‌گیرد که درون یک defer اجرا شود که در همان گوروتین panic اتفاق افتاده باشد. 90: تفاوت بین range روی slice و روی array چیست؟ روی slice: مقدار و اندیس عناصر slice را برمی‌گرداند. روی array: مشابه slice، ولی آرایه به صورت کامل پاس داده می‌شود که می‌تواند هزینه‌بر باشد مگر اینکه با reference پاس شود. 91: چرا capacity slice بعد از append ممکن است چند برابر شود؟ برای بهینه‌سازی تخصیص حافظه، Go هنگام نیاز به افزایش ظرفیت معمولاً آن را به صورت نمایی (دو برابر یا بیشتر) افزایش می‌دهد. 92: تفاوت بین runtime.Gosched و time.Sleep چیست؟ runtime.Gosched به scheduler اجازه می‌دهد گوروتین‌های دیگر را اجرا کند بدون توقف زمان مشخص. time.Sleep گوروتین را برای مدت مشخص متوقف می‌کند. 93: چرا nil pointer در method receiver ممکن است باعث panic نشود؟ اگر متد به فیلد یا داده‌ای از struct دسترسی نداشته باشد، حتی اگر receiver nil باشد، panic ایجاد نمی‌شود. 94: تفاوت بین map[string]struct{} و map[string]bool چیست؟ map[string]struct{} حافظه کمتری مصرف می‌کند چون struct خالی صفر بایت است. map[string]bool نیاز به یک بایت برای مقدار دارد. 95: چرا استفاده از for-select بدون default می‌تواند کارایی را کاهش دهد؟ چون گوروتین بلاک می‌ماند تا یکی از caseها آماده شود، که ممکن است باعث استفاده ناکارآمد از CPU شود. 96: تفاوت بین var x = y و x := y چیست؟ var x = y می‌تواند در سطح package یا تابع استفاده شود. x := y فقط در داخل توابع مجاز است و همیشه تعریف جدید انجام می‌دهد. 97: چرا استفاده از init function باید محدود باشد؟ چون باعث اجرای مخفیانه کد در هنگام بارگذاری پکیج می‌شود و می‌تواند تست و اشکال‌زدایی را سخت کند. بهتر است منطق راه‌اندازی به صراحت در main یا سازنده‌ها باشد. 98: تفاوت بین context.WithCancel و context.WithTimeout چیست؟ WithCancel فقط با فراخوانی تابع cancel لغو می‌شود. WithTimeout به صورت خودکار بعد از زمان مشخص لغو می‌شود. 99: چرا حلقه‌های بازگشتی بدون شرط توقف می‌توانند باعث stack overflow شوند؟ چون Go tail call optimization ندارد و هر فراخوانی بازگشتی stack را افزایش می‌دهد. 100: تفاوت بین log.Fatal و panic چیست؟ log.Fatal پیام را چاپ کرده و برنامه را بلافاصله با os.Exit متوقف می‌کند. panic اجرای عادی را متوقف کرده و chain فراخوانی deferها را اجرا می‌کند قبل از توقف. 101: تفاوت بین unsafe.Pointer و uintptr چیست؟ unsafe.Pointer برای تبدیل بین انواع اشاره‌گر استفاده می‌شود. uintptr یک نوع عددی است که آدرس را به عنوان یک عدد ذخیره می‌کند. تبدیل بین آنها باید با احتیاط انجام شود چون ممکن است GC آدرس را جابجا کند. 102: چرا استفاده از reflect می‌تواند کارایی را کاهش دهد؟ پکیج reflect باعث عملیات‌های زمان اجرا و type checking پویا می‌شود که نسبت به کد معمولی کندتر است. 103: تفاوت بین constant expression و runtime value چیست؟ Constant expression در زمان کامپایل مشخص می‌شود و می‌تواند در تعریف ثابت‌ها استفاده شود. Runtime value فقط در زمان اجرای برنامه مشخص می‌شود. 104: چرا nil channel برای همگام‌سازی گاهی مفید است؟ با nil کردن یک channel می‌توانیم آن را از انتخاب در select حذف کنیم و رفتار برنامه را به صورت پویا کنترل کنیم. 105: تفاوت بین stack و heap allocation در Go چیست؟ Stack سریع‌تر و برای داده‌های کوتاه‌مدت استفاده می‌شود. Heap برای داده‌هایی که طول عمر نامعلوم دارند و بین goroutineها به اشتراک گذاشته می‌شوند. 106: چرا slicing از یک array بزرگ می‌تواند باعث نگه‌داشتن حافظه اضافی شود؟ چون slice به آرایه زیرین اشاره می‌کند و GC نمی‌تواند آرایه بزرگ را آزاد کند تا زمانی که slice زنده باشد. 107: تفاوت بین break و continue در حلقه چیست؟ break حلقه را کامل متوقف می‌کند. continue فقط iteration جاری را رد کرده و iteration بعدی را شروع می‌کند. 108: چرا append ممکن است باعث تغییر آدرس حافظه slice شود؟ وقتی ظرفیت پر شود، append یک آرایه جدید می‌سازد و داده‌ها را کپی می‌کند که آدرس حافظه متفاوت خواهد داشت. 109: تفاوت بین go vet و go fmt چیست؟ go fmt کد را قالب‌بندی می‌کند. go vet مشکلات احتمالی کد را شناسایی می‌کند ولی تغییرات ظاهری ایجاد نمی‌کند. 110: چرا باید از io.Reader و io.Writer در طراحی API استفاده کنیم؟ برای انعطاف‌پذیری بیشتر و امکان استفاده از منابع مختلف (فایل، شبکه، حافظه) بدون تغییر کد. 111: تفاوت بین os.Exit و return در main چیست؟ os.Exit فوراً برنامه را متوقف می‌کند و deferها اجرا نمی‌شوند، ولی return اجازه اجرای deferها را می‌دهد. 112: چرا map نمی‌تواند به عنوان کلید slice داشته باشد؟ چون slice قابل مقایسه نیست و hash آن ثابت نیست. فقط انواع قابل مقایسه (comparable) می‌توانند کلید باشند. 113: تفاوت بین io.Pipe و channel چیست؟ io.Pipe برای اتصال مستقیم بین io.Reader و io.Writer استفاده می‌شود، ولی channel برای ارسال هر نوع داده بین goroutineها استفاده می‌شود. 114: چرا نباید از pointer به local variable بعد از پایان تابع استفاده کنیم؟ چون متغیر ممکن است از بین برود یا آدرسش تغییر کند، که باعث رفتار غیرقابل پیش‌بینی می‌شود. 115: تفاوت بین testing.Short و تست‌های عادی چیست؟ testing.Short() می‌تواند در تست‌ها استفاده شود تا تست‌های طولانی در حالت کوتاه اجرا نشوند. 116: چرا باید برای عملیات‌های سنگین I/O از buffered channel استفاده کرد؟ برای جلوگیری از بلاک شدن تولیدکننده یا مصرف‌کننده و افزایش throughput. 117: تفاوت بین go build و go install چیست؟ go build فایل اجرایی را در دایرکتوری جاری می‌سازد. go install آن را در مسیر bin در $GOPATH یا $GOBIN نصب می‌کند. 118: چرا استفاده از strings.Builder به جای + برای رشته‌ها بهتر است؟ چون از تخصیص‌های متعدد جلوگیری می‌کند و حافظه را بهینه‌تر مدیریت می‌کند. 119: تفاوت بین cap و len در array چیست؟ برای array هر دو برابر طول آرایه هستند، ولی برای slice ممکن است متفاوت باشند. 120: چرا باید بعد از استفاده از bufio.Writer حتماً Flush کرد؟ چون داده‌ها در بافر ذخیره می‌شوند و تا زمانی که Flush نشوند به مقصد نهایی ارسال نمی‌شوند. 121: تفاوت بین import _ و import alias چیست؟ import _ فقط برای اجرای init پکیج است. Import alias برای استفاده از نام متفاوت جهت ارجاع به پکیج. 122: چرا باید از context در عملیات‌های شبکه استفاده کنیم؟ برای امکان لغو یا timeout در صورت طولانی شدن عملیات. 123: تفاوت بین interface value و concrete value چیست؟ Interface value شامل نوع و مقدار واقعی است، concrete value فقط مقدار واقعی است. 124: چرا استفاده از constant برای magic number بهتر است؟ باعث خوانایی بهتر، کاهش خطا و امکان تغییر راحت در آینده می‌شود. 125: تفاوت بین log.Println و fmt.Println چیست؟ log.Println علاوه بر چاپ پیام، timestamp هم اضافه می‌کند. 126: چرا sync.WaitGroup باید با Add قبل از اجرای goroutine استفاده شود؟ برای جلوگیری از شرایطی که goroutine قبل از افزایش شمارنده شروع شود و WaitGroup صفر بماند. 127: تفاوت بین path و filepath در Go چیست؟ path برای مسیرهای URL و forward slash استفاده می‌شود. filepath برای مسیرهای سیستم فایل وابسته به سیستم‌عامل استفاده می‌شود. 128: چرا استفاده از http.Client پیش‌فرض می‌تواند مشکل‌ساز باشد؟ چون connectionها را cache نمی‌کند و ممکن است باعث نشت اتصال شود مگر اینکه timeout یا Transport سفارشی تعریف شود. 129: تفاوت بین sync.Mutex و sync.RWMutex در خواندن زیاد چیست؟ sync.RWMutex اجازه می‌دهد چندین خواننده همزمان کار کنند، ولی Mutex فقط یک قفل کلی می‌دهد. 130: چرا panic در گوروتین جداگانه باید به صورت جداگانه recover شود؟ چون recover فقط panic در همان goroutine را می‌گیرد. 131: تفاوت بین os.Create و os.OpenFile چیست؟ os.Create فایل را با truncate ایجاد یا باز می‌کند. os.OpenFile کنترل کامل روی mode و flagها می‌دهد. 132: چرا context باید به صورت اولین آرگومان به توابع پاس داده شود؟ این یک قرارداد استاندارد Go است که خوانایی و یکپارچگی API را بهبود می‌دهد. 133: تفاوت بین errors.Is و errors.As چیست؟ errors.Is برای بررسی تطابق با یک خطای خاص استفاده می‌شود. errors.As برای استخراج و استفاده از نوع خاص خطا. 134: چرا نباید از defer در حلقه‌های شدیداً پرتکرار استفاده کرد؟ چون هر defer تا پایان تابع ذخیره می‌شود و باعث سربار می‌شود. 135: تفاوت بین nil slice و empty slice در JSON چیست؟ Nil slice به null سریالایز می‌شود، ولی empty slice به []. 136: چرا map در Go به صورت داخلی rehash انجام می‌دهد؟ برای حفظ کارایی O(1) در دسترسی و جلوگیری از افزایش بیش از حد load factor. 137: تفاوت بین encoding/json و jsoniter چیست؟ jsoniter سریع‌تر و انعطاف‌پذیرتر است ولی encoding/json رسمی و پایدار است. 138: چرا باید کانال را فقط توسط ارسال‌کننده ببندیم؟ برای جلوگیری از panic ناشی از ارسال به کانال بسته. 139: تفاوت بین context.WithValue و متغیر global چیست؟ Context برای داده‌های کوتاه‌مدت مرتبط با درخواست استفاده می‌شود، global برای داده‌های بلندمدت. 140: چرا time.AfterFunc می‌تواند به جای time.Sleep مفید باشد؟ چون به صورت asynchronous عمل می‌کند و callback مشخصی را بعد از مدت معین اجرا می‌کند. 141: تفاوت بین select با یک case و استفاده مستقیم از channel چیست؟ select حتی با یک case هم امکان اضافه کردن default یا caseهای دیگر را در آینده می‌دهد و ساختار کد را منعطف‌تر می‌کند، ولی دریافت مستقیم ساده‌تر است. 142: چرا استفاده از buffer بزرگ‌تر در bufio.Reader می‌تواند کارایی را بهبود دهد؟ چون تعداد فراخوانی‌های سیستم‌عاملی (syscall) را کاهش می‌دهد و داده‌ها را یک‌جا می‌خواند. 143: تفاوت بین defer با anonymous function و با نام تابع چیست؟ در defer با anonymous function می‌توان پارامترها را در زمان اجرای defer ارزیابی کرد، ولی در تابع نام‌دار پارامترها در لحظه تعریف defer ارزیابی می‌شوند. 144: چرا از sync/atomic برای شمارنده‌ها استفاده می‌شود؟ چون عملیات‌های اتمیک بدون نیاز به Mutex انجام می‌شوند و سرعت بیشتری دارند. 145: تفاوت بین byte buffer و byte slice چیست؟ Byte buffer (مثل bytes.Buffer) امکانات بیشتری مثل نوشتن و خواندن با رشد خودکار دارد، ولی byte slice ساده‌تر است و امکانات اضافی ندارد. 146: چرا استفاده از fallthrough باید محدود باشد؟ چون می‌تواند باعث اجرای غیرمنتظره caseها شود و خوانایی کد را کاهش دهد. 147: تفاوت بین log.Fatal و os.Exit چیست؟ log.Fatal قبل از توقف پیام خطا را چاپ می‌کند، ولی os.Exit فقط برنامه را متوقف می‌کند. 148: چرا map در Go به‌صورت همزمان توسط چند goroutine قابل استفاده نیست؟ چون پیاده‌سازی داخلی map thread-safe نیست و همزمانی بدون قفل باعث panic می‌شود. 149: تفاوت بین os.Getenv و os.LookupEnv چیست؟ os.Getenv رشته را برمی‌گرداند و اگر وجود نداشته باشد مقدار خالی می‌دهد. os.LookupEnv مقدار و وضعیت وجود داشتن را برمی‌گرداند. 150: چرا range روی channel تا زمان بسته شدن ادامه دارد؟ چون range از channel تا زمانی که همه مقادیر خوانده و کانال بسته نشود، بلاک می‌ماند. "},{"id":7,"href":"/chapter-1/","title":"فصل اول: آشنایی با مفاهیم گو","section":"صفحه اصلی","content":"در فصل اول به مفاهیم پایه زبان برنامه‌نویسی گو بطور عمیق می‌پردازیم. این فصل شامل چندین بخش هست:\n1.1 ساختار کد گو 1.2 کلید واژه و شناسه‌ها 1.3 تایپ های پایه 1.4 عملگرها 1.5 متغیرها و constant 1.6 مقادیر صفر تایپ ها (zero values) 1.7 تابع (function) 1.8 آرایه و slice 1.9 حلقه ها (for) 1.10 نقشه map 1.11 شرط (if, switch) 1.12 اضافه کردن پکیج در کد (package) 1.13 defer, panic, recovery 1.14 لیست تایپ ها و توابع Builtin 1.15آشنایی با رشته و توابع آن "},{"id":8,"href":"/chapter-1/structure-of-go-code/","title":"1.1 ساختار کد گو","section":"فصل اول: آشنایی با مفاهیم گو","content":"همانطور که در تاریخچه زبان گو گفتیم, زبان گو سینتکس خیلی تمیز و ساده‌ای دارد که به راحتی می‌توانید کدهای زبان گو را بخوانید. در ادامه ما سعی می‌کنیم با مثال‌های ساده شما را با ساختار کد زبان گو آشنا کنیم.\nبه نقل از تاریخچه سینتکس زبان گو به گونه‌ای طراحی شده که خیلی ساده و تمیز است و این باعث می‌شود خیلی سریع زبان گو را یاد بگیرید و از همه مهم‌تر توسعه پروژه‌های مقیاس پذیر با زبان گو به دلیل سادگی و آشکار بودن مفاهیم خیلی سریع‌تر صورت‌ گیرد. 1.1.0 زبان برنامه‌نویسی # یک زبان برنامه‌نویسی یک زبان مصنوعی انگلیسی است که برای بیان محاسباتی که توسط یک ماشین (مخصوصاً رایانه) قابل انجام است، طراحی شده‌ است. زبان‌های برنامه‌نویسی برای ایجاد برنامه‌هایی به کار می‌روند که رفتار یک ماشین را مشخص می‌کنند، الگوریتم دقیق را بیان می‌کنند، یا روشی برای تعامل انسان و رایانه هستند. بسیاری از زبان‌های برنامه‌نویسی تعدادی قالب از ویژگی‌های نوشته شده دستوری یا نحو (syntax) و معناشناسی (semantics) دارند، چرا که رایانه‌ها دستورهای دقیقاً مشخص نیاز دارند. برخی توسط سند خصوصیات (specification document) تعیین شده‌اند (برای مثال یک استاندارد ISO)، در حالی که برخی دیگر دارای پیاده‌سازی غالبی هستند. [به نقل از ویکی‌پدیا].\n1.1.1 پکیج # هر برنامه‌ای که با ساختار گو ایجاد شده باشد، از پکیج(ها) ساخته شده است. درواقع زبان گو یک زبان بر پایه پکیج است. برخلاف برخی دیگر که بر پایه فایل هستند. این به‌ این‌ معنی است که به «مجموعه»ای از ابزارها اعم از ثابت‌ها، متغیرها و عملیات مختلف که زیرمجموعه یک نام تعریف می‌شوند، پکیج می‌گوئیم. تفاوتی ندارد در یک «فایل» یا «چند» فایل، بشرطی که ابتدای همگی package name باشند.\n1.1.2 یک نمونه کد ساده زبان گو # قبل از اینکه محتوای بدنه کد زیر را بررسی کنیم؛ بهتر است با نحوه کامنت‌گذاری کد در زبان گو آشنا شوید.\n1.1.2.1 کامنت گذاری # کامنت‌ها در زبان گو همانند زبان سی هستند که با قرار دادن ۲ اسلش در ابتدای خط یا قرار دادن یک یا چند خط ما بین /* و */ ایجاد می‌شود.\n// کامنت عادی یک خطی /* بلاک کامنت برای نوشتن کامنت چند خطی */ 1.1.2.2 نمونه کد # در پایین یک نمونه کد قرار دادیم که با کامنت هر کدام از بخش‌های بدنه کد گو را توضیح دادیم.\npackage main // نام پکیج فایل سورس را مشخص می کند import \"math/rand\" // یک پکیج استاندارد ایمپورت شده const MaxRnd = 16 // یک ثابت تعریف شده است // تابع func StatRandomNumbers(n int) (int, int) { var a, b int for i := 0; i \u003c n; i++ { if rand.Intn(MaxRnd) \u003c MaxRnd/2 { a = a + 1 } else { b++ } } return a, b } // تابع main اولین نقطه شروع اجرای کد شما می باشد که در این تابع سایر موارد تعریف می شود. func main() { var num = 100 x, y := StatRandomNumbers(num) print(\"Result: \", x, \" + \", y, \" = \", num, \"? \") println(x+y == num) } ▶ اجرای کد کپی ✖ بستن خروجی سورس کد بالا را در فایلی با نام basic-code-element-demo.go ذخیره می‌کنیم و سپس با دستور زیر اجرا می‌کنیم تا خروجی کد فوق را ببینیم :\n$ go run basic-code-element-demo.go Result: 46 + 54 = 100? true 1.1.3 تابع main # در زبان گو پکیج main به عنوان یک پکیج منحصر به فرد در نظر گرفته شده است، به شکلی که در هنگام اجرای برنامه مشخص می‌کند شروع کار و خواندن برنامه از کجا باید باشد. در نهایت داخل این پکیج ما تابع ()main را داریم که این تابع نقطه شروع اجرای برنامه ما خواهد بود. این تابع هیچ ارگومانی نمی‌گیرد و هیچ چیزی رو هم بازگشت نخواهد داد. زبان گو به صورت خودکار تابع ()main را فراخوانی می‌کند. برای همین نیازی به فراخوانی این تابع توسط شما وجود ندارد. برای همین باید دقت داشته باشید در هر برنامه‌ای که می‌نویسید حتما از پکیج و تابع main باید استفاده کنید.\n// تعریف پکیج main package main // تعریف تابع main func main() { println(\"Hello GoFarsi!\") } ▶ اجرای کد کپی ✖ بستن خروجی 1.1.4 اجرای کد # برای اجرای کدهای گو می‌توان از پارامتر run استفاده کرد.\n$ go run main.go Result: Hello GoFarsi! دستور بالا ابتدا داخل پوشه temp سیستم شما یک فایل اجرایی را درست می‌کند و سپس آن فایل را اجرا می‌کند و در نهایت خروجی را به ما نشان می‌دهد. اگر شما بخواهید خروجی فایل اجرایی (executable) داشته باشید و سپس آن را اجرا کنید می‌توانید از دستور زیر استفاده کنید:\n$ go build main.go $ ./main Result: Hello GoFarsi! اگر بخواهید برای خروجی فایل اجرایی اسمی در نظر بگیرید می‌توانید از دستور زیر با پارامتر o- استفاده کنید.\n$ go build -o goFarsi main.go $ ./goFarsi Result: Hello GoFarsi! دقت کنید اگر از سیستم‌عامل ویندوز استفاده می‌کنید بعد از وارد کردن اسم، پسوند .exe را نیز اضافه کنید. برای راحتی و سرعت بخشیدن هنگام توسعه ما از دستور go run استفاده می‌کنیم. تابع init # همانطور که گفتیم نقطه شروع برنامه ما تابع main است. اما اگر بخواهیم قبل از اجرای برنامه مقداری را ست کنیم و یا چیزی را لود کنیم، می توانیم در داخل تابع init اینکار را انجام دهیم. تابع init قبل از تابع main اجرا می شود\n// تعریف پکیج main package main // تعریف تابع init func init() { println(\"init\") } // تعریف تابع main func main() { println(\"Hello GoFarsi!\") } ▶ اجرای کد کپی ✖ بستن خروجی پس از اجرای کد. خروجی زیر را مشاهده می کنید.\n$ go run main.go Result: init Hello GoFarsi! 1.1.5 بررسی syntax # برخلاف بیشتر زبان‌های برنامه نویسی در زبان گو شما نمی‌توانید از حالت‌های مختلف برای نوشتن کد خود استفاده کنید. مثلاً کد زیر هنگام کامپایل کردن خطا می‌دهد.\npackage main func main() { println(\"not compiled\") } ▶ اجرای کد کپی ✖ بستن خروجی خروجی کد بالا :\n$ go run main.go Result: # command-line-arguments .\\main.go:4:1: syntax error: unexpected semicolon or newline before { صرفاً با تغییر براکت ما با خطا مواجه شدیم. شاید از دید شما این نوع نوشتن کد نباید خطا ایجاد کند. ولی وقتی شما داخل یک تیم هستید و مجبور هستید کدها را بازخوانی کنید تا بفهمید چه اتفاقی افتاده است، با حالت‌های مختلف سینتکس مواجه نخواهید شد، و همه کدها یک دست و از یک ساختار پیروی می‌کنند، که باعث خواندن سریع‌تر، درک بهتر و امکان توسعه سریع‌تر را برای ما و هم‌تیمی‌های ما ایجاد خواهد کرد.\n1.1.5.1 استفاده از go fmt # برای آن که بتوان از این نوع خطاها جلوگیری کرد و فرمت مناسب و یک نواختی داخل کدهای ما وجود داشته باشد، خود IDEها این خطاها را به ما نشان می‌دهد. خود توسعه‌دهندگان زبان گو پارامتر fmt یا به عبارتی فرمت را در اختیار ما قرار داده‌اند تا هر زمان که کدی می‌نویسم و ذخیره می‌کنیم بتوانیم با استفاده از این دستور ساختار کد خود را مرتب کنیم و اگر خطایی وجود داشته باشد قبل از کامپایل کردن برنامه آن را پیدا و رفع کنیم. مثلاً خروجی استفاده از پارامتر fmt\n$ go fmt main.go Result: .\\main.go:4:1: unexpected semicolon or newline before { حالا فرض کنید کدی را نوشته‌اید و داخل کد شما فضای زیادی وجود دارد و اندازه tab‌ها و space‌ها مشخص نیست. به مثال زیر توجه کنید:\npackage main func main(){ println(\"print line 1\") println(\"print line 2\") } ▶ اجرای کد کپی ✖ بستن خروجی وقتی کدی شبیه کد بالا را دارید و از دستور go fmt استفاده می‌کنیم خروجی کد بالا به شکل زیر تغییر پیدا می‌کند:\npackage main func main() { println(\"print line 1\") println(\"print line 2\") } ▶ اجرای کد کپی ✖ بستن خروجی در برنامه فوق ما یکسری کلمات کلیدی نظیر package, import, const, func, var , for, if, else, return استفاده کردیم و سایر کلماتی که داخل کد فوق دیدید به عنوان شناسه هستند. برای اطلاعات بیشتر در خصوص کلید واژه و شناسه لطفاً بخش کلید واژه و شناسه ها را مطالعه فرمایید. "},{"id":9,"href":"/chapter-1/go-built-in-keywords-identifiers/","title":"1.2 کلید واژه و شناسه‌ها","section":"فصل اول: آشنایی با مفاهیم گو","content":"در این بخش قصد داریم به کلید واژه و شناسه های زبان گو بپردازیم.\n1.2.1 کلید واژه # زبان گو تا نسخه فعلی فقط ۲۵ تا کلید واژه دارد که به شرح زیر ست:\n1 2 3 4 5 1 break default func interface select 2 case defer go map struct 3 chan else goto package switch 4 const fallthrough if range type 5 continue for import return var کلمات کلیدی فوق به ۴ دسته تقسیم می‌شوند که به شرح زیر است:\nکلمات کلیدی که بصورت گلوبال در بدنه قرار می‌گیرند «package, import, type, var, const, func» کلمات کلیدی کامپوزیت «struct, interface, map, chan» کلمات کلیدی که در جریان کنترل کد استفاده می‌شوند «break, case, continue, default, if, else, for, fallthrough, goto, range, return, switch, select» در بخش‌های دیگر کتاب ما بطور مفصل به مفاهیم کلمات کلیدی فوق می‌پردازیم. 1.2.2 شناسه‌ها # شناسه توکنی است که باید از حروف یونیکد, ارقام یونیکد (اعداد دسته‌بندی شده در استاندارد ۸.۰ یونیکد) و خط زیرین ـ تشکیل شده باشد.\nعلامت کاربرد ـ نادیده گرفتن \u0026amp; دسترسی به آدرس حافظه * دسترسی مقدار داخل یک خانه حافظه 1.2.2.1 قوانین شناسه‌ها # نامگذاری باید از حروف a-z یا A-Z و یا 0-9 باشد. نام شناسه‌ها نباید با اعداد شروع شود. نام شناسه‌ها به حروف بزرگ و کوچک حساس است. استفاده از کلید واژه ممنوع است. هیچ محدودیتی در تعداد حروف نام شناسه وجود ندارد و مطلوب‌ترین حالت ۴ الی ۱۵ حرف است. // شناسه‌های معتبر _geeks23 geeks gek23sd Geeks geeKs geeks_geeks // شناسه‌های نامعتبر 212geeks if default در زبان گو یکسری شناسه‌ها از قبل برای برخی از بخش‌های کد تعیین شده است که در زیر می‌توانید ببینید:\n// Constant (ثابت ها) true, false, iota, nil // Types (تایپ ها) int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64, uintptr, float32, float64, complex128, complex64, bool, byte, rune, string, error // Functions (توابع) make, len, cap, new, append, copy, close, delete, complex, real, imag, panic, recover "},{"id":10,"href":"/chapter-1/go-basic-types/","title":"1.3 تایپ‌های پایه","section":"فصل اول: آشنایی با مفاهیم گو","content":" 1.3.1 تایپ چیست؟ # یک تایپ مشخص کننده نوع داده است، که به کامپایلر می‌گوید قرار است چه نوع داده‌ای داخل یک متغیر ذخیره گردد. زبان‌ها انواع تایپ‌های مختلفی به صورت پیش‌فرض دارند که می‌توان از آن‌ها داخل برنامه خود استفاده کرد. ما می‌توانیم تایپ‌ها را به دو دسته کلی تعریف کنیم.\n1.3.1.1 تایپ ایستا (Static Type) # زبانی مثل زبان گو یک زبان تایپ ایستا است، یعنی وقتی ما یک داده‌ای از نوع عددی داخل یک متغیر تعریف می‌کنیم داخل همان متغیر امکان اضافه کردن داده‌ای، غیر داده عددی وجود ندارد.\n1.3.1.2 تایپ پویا (Dynamic Type) # زبان‌هایی مثل PHP، JavaScript و \u0026hellip; جزو زبان‌های تایپ پویا هستند. یعنی وقتی یک متغیری از نوع عددی تعریف می‌کنیم می‌توانیم به همان متغیر مقادیر دیگه‌ای مثل مقادیر رشته‌ای اضافه کنیم.\nتفاوت تایپ ایستا با پویا به نقل از آقای استقامت:\nدر زبان‌هایی مثل گو که جزو زبان‌های نوع ایستا هستند، وقتی بخوایم متغیر یا ثابتی ایجاد کنیم، حتما می بایست نوع متغیر یا ثابت را به صورت مستقیم و صریح اعلان کنیم تا کامپایلر متوجه بشه که درون این متغیر یا ثابت قراره چه نوع داده ای ذخیره بشه.\nبه عنوان مثال در زبان گو باید بنویسیم: ‎var a, b int = 1, 2\nو اگر نوع داده یا در این مثال(int) را مشخص نکنیم با ارور مواجه می‌شویم.\nاکنون که این دو متغیر از نوع int اعلان شدند، فقط و فقط می‌توان مقادیری از نوع اعداد صحیح را درون آن‌ها ذخیره کرد و نمی‌توان به عنوان مثال، یک رشته متنی یا اعداد اعشاری و \u0026hellip; را درون آن‌ها ذخیره نمود.\n▪️ اما در مورد زبان‌های نوع پویا مانند زبان پایتون، ما نیازی به اعلان صریح نوع متغیر نداریم. بلکه کافیست یک شناسه را به عنوان نام متغیر در نظر گرفته و مقداری را به آن انتساب دهیم. در اینجا، کامپایلر یا مفسر زبان به صورت خودکار نوع داده متغیر را بر اساس مقداری که به آن انتساب داده ایم شناسایی می کند: به عنوان مثال در زبان پایتون داریم: ‎n = 300\nدر این جا متغیر n دارای نوع int است که به صورت خودکار توسط زبان شناسایی می‌شود.\nاکنون ما می‌توانیم همین متغیر را در جاهای دیگری از کد استفاده کنیم و مقادیری از انواع داده‌ای دیگر به آن انتساب دهیم بدون اینکه هیچ مشکلی یا اروری پیش بیاید: \u0026quot;‎n = \u0026quot;Hello\nدر حال حاضر متغیر n از نوع string می باشد!\nبرای اطلاعات بیشتر می‌توانید تایپ سیستم را داخل ویکی‌پدیا مطالعه کنید.\n1.3.2 تایپ‌ها در زبان گو # زبان گو مثل سایر زبان‌ها یکسری تایپ‌های پایه دارد که در هر بخش از کد گو می‌توانید استفاده کنید. در ادامه این تایپ‌ها با مقادیر پیش‌فرض‌ معرفی شده است.\nتایپ محدوده مقدار پیش فرض یا مقدار صفر حجم استفاده از حافظه int بستگی به معماری سیستم عامل که ۳۲ بیت یا ۶۴ بیت باشد 0 ۴ یا ۸ بایت int8 128- تا 127 0 ۱ بایت int16 32768- تا 32767 0 ۲ بایت int32 2147483648- تا 2147483647 0 ۴ بایت int64 9223372036854775808- تا 9223372036854775807 0 ۸ بایت uint بستگی به معماری سیستم عامل که ۳۲ بیت یا ۶۴ بیت باشد 0 ۴ یا ۸ بایت uint8 0 تا 255 0 ۱ بایت uint16 0 تا 65535 0 ۲ بایت uint32 0 تا 6294967295 0 ۴ بایت uint64 0 تا 18446744073709551615 0 ۸ بایت uintptr عدد خیلی بزرگ 0 ۸ بایت float32 IEEE-754 0 ۴ بایت float64 IEEE-754 0 ۸ بایت complex64 - 0+0i ۸ بایت complex128 - 0+0i ۱۶ بایت bool - false ۱ بایت string - \u0026quot; \u0026quot; ۱۶ بایت زبان گو به‌طور پیش‌فرض از دو نوع تایپ با نام مستعار پشتیبانی می‌کند :\nتایپ byte این تایپ نام مستعار برای تایپ uint8 است. تایپ rune این تایپ نام مستعار برای تایپ int32 است. تفاوت int و uint در این است که نوع داده int به عنوان Signed Integer شناخته می‌شود و توانایی ذخیره اعداد منفی ، 0 و اعداد مثبت را دارد اما نوع داده uint به معنای Unsigned Integer بوده و فقط توانایی نگهداری اعداد مثبت و 0 را داراست.\nتایپ uintptr به نقل از آقای استقامت:\nدر مورد نوع داده uintptr که در متن بالا در مورد آن گفته شده \u0026ldquo;عدد خیلی بزرگ\u0026quot;، با بیان این مطلب که چنین توضیحی نادرست است، توجه شما رو به ادامه این یادداشت جلب می‌کنم:\nکلمه uintptr همان‌طور که قابل حدس زدن است کوتاه شده Unsigned Integer Pointer است.\nاز این نوع داده برای ذخیره و نگهداری آدرس‌های حافظه(RAM) استفاده می‌شود.\nفضایی که این نوع داده در سیستم اِشغال می‌کند، به نوع معماری سیستم عامل بستگی دارد.\nو در نهایت، به جای عبارت \u0026ldquo;عدد خیلی بزرگ\u0026rdquo; که مفهوم اشتباه و نادرستی می‌رساند، باید اینگونه بگوییم که این نوع داده به اندازه کافی بزرگ است تا بتواند اشاره گرهایی(Pointers) به هر آدرس از حافظه را درون خودش ذخیره کند.(منبع)\npackage main import \"fmt\" func main() { var var1 uintptr = 0xc82000c290 fmt.Println(\u0026ldquo;Value of var1:\u0026rdquo;, var1) fmt.Printf(\u0026ldquo;Type of var1: %T\u0026rdquo;, var1) } ▶ اجرای کد کپی ✖ بستن خروجی\n1.3.3 سفارشی‌سازی تایپ‌(ها) # نام‌گذاری جدید : برای تایپ‌های رشته‌ای، عددی و بول، می‌توان نام سفارشی جدید انتخاب و در پروژه استفاده کرد: /* type alias */ // bul and bool define the same type. type bul = bool // content and string define the same type. type content = string // UI8, uint8 and byte define the same type. type UI8 = uint8 // Word, rune and int32 define the same type. type Word = rune ایجاد تایپ جدید معادل یک تایپ موجود : همچنین می‌توان از تایپ‌های موجود، یک نمونه جدید ایجاد کرد: /* type definition */ // state and bool are two different types. type state bool // str and string are two different types. type str string // ID and uint64 are two different types. type ID uint64 // decimal and float32 are two different types. type decimal float32 1.3.4 مقدار پیش فرض تایپ‌ها # مقدار پیش‌فرض تایپ‌ها در زبان گو به شرح زیر است :\nمقدار پیش‌فرض تایپ بولین false است. مقدار پیش‌فرض تمامی تایپ اعداد (int, uint, float) صفر است. مقدار پیش‌فرض تایپ string برابر با رشته تهی یا empty string است . رشته تهی معادل عبارت \u0026quot;\u0026quot; است (دو علامت نقل قول بدون هیچ کاراکتری در بین آن‌ها) و عبارت \u0026quot; \u0026ldquo; که دارای یک فاصله خالی(Space) در بین دو نقل قول است، یک رشته تهی نیست و بنابراین اشتباه است!\n1.3.5 انواع مقادیر تایپ‌ها # در زبان گو تایپ‌ها یکسری مقادیر مختلفی را دریافت می‌کنند که در زیر به این مقادیر می‌پردازیم.\n1.3.5.1 تایپ بولین # تایپ بولین فقط true و false را به عنوان مقدار دریافت می‌کند.\n1.3.5.2 تایپ Integer # تایپ اعداد ۴ نوع مقدار مختلف دریافت می‌کند که به ترتیب Decimal (پایه ۱۰), Octal (پایه ۸), Hex (پایه ۱۶) و Binrary (پایه ۲ یا دودویی) است.\n0xF // the hex form (starts with a \u0026quot;0x\u0026quot; or \u0026quot;0X\u0026quot;) 0XF 017 // the octal form (starts with a \u0026quot;0\u0026quot;, \u0026quot;0o\u0026quot; or \u0026quot;0O\u0026quot;) 0o17 0O17 0b1111 // the binary form (starts with a \u0026quot;0b\u0026quot; or \u0026quot;0B\u0026quot;) 0B1111 15 // the decimal form (starts without a \u0026quot;0\u0026quot;) package main func main() { println(15 == 017) // true println(15 == 0xF) // true } ▶ اجرای کد کپی ✖ بستن خروجی 1.3.5.3 تایپ Float # تایپ Float چند نوع مقدار را دریافت می‌کند که به ترتیب مقدار ممیز شناور اعشاری ممکن است شامل یک قسمت صحیح اعشاری، یک نقطه اعشاری، یک قسمت کسری اعشاری، و یک قسمت توانی عدد صحیح (مبتنی بر 10) باشد.\n1.23 01.23 // == 1.23 .23 1. // An \u0026quot;e\u0026quot; or \u0026quot;E\u0026quot; starts the exponent part (10-based). 1.23e2 // == 123.0 123E2 // == 12300.0 123.E+2 // == 12300.0 1e-1 // == 0.1 .1e0 // == 0.1 0010e-2 // == 0.1 0e+5 // == 0.0 1.3.5.4 تایپ rune # تایپ rune یک تایپ با نام مستعار int32 است که از تایپ‌های اعداد صحیح خاص هستند. از rune می‌توان برای ذخیره کاراکترهای یونیکد استفاده کرد که در مثال زیر چند نمونه قرار داده شده است:\n'a' // an English character 'π' '众' // a Chinese character // 141 is the octal representation of decimal number 97. '\\141' // 61 is the hex representation of decimal number 97. '\\x61' '\\u0061' '\\U00000061' package main func main() { println('a' == 97) println('a' == '\\141') println('a' == '\\x61') println('a' == '\\u0061') println('a' == '\\U00000061') println(0x61 == '\\x61') println('\\u4f17' == '众') } ▶ اجرای کد کپی ✖ بستن خروجی ◾️استاندارد یونیکد، مجموعه‌ای از تمام کاراکترهای موجود در جهان است (کاراکترهای زبان‌های لاتین، فارسی، عربی، چینی و \u0026hellip;، اموجی‌ها (مانند😊)، کاراکترهای غیرقابل نمایش و \u0026hellip;).\n◾️هر کدام از این کاراکترها در استاندارد یونیکد، توسط یک عدد یکتا و منحصر به فرد مشخص شده است. به این عدد Unicode Code Point می‌گویند.\n◾️به عنوان مثال، کد پوینت کاراکتر «😊» برابر است با U+1F60A یا کد پوینت کاراکتر «ن» در زبان فارسی برابر است با U+0646.\n◾️این کد پوینت‌ها دقیقا همان چیزهایی هستند که در runeها ذخیره می‌شوند.\n◾️از آنجا که زبان گو، از استاندارد UTF-8 (ارائه شده توسط کنسرسیوم یونیکد) برای encoding کاراکترها استفاده می‌کند و در این استاندارد، هر کاراکتر فضایی بین 1 تا 4 بایت(8 بیت تا 32 بیت) را در حافظه اِشغال می‌کند. به همین دلیل نوع داده rune یک نام مستعار برای نوع داده int32 در زبان گو است.\npackage main import \"fmt\" func main() { var r rune = 'k' fmt.Printf(\"%c %T %U\", r, r, r) } ▶ اجرای کد کپی ✖ بستن خروجی 1.3.5.5 byte، string و rune # مقادیر string و rune[] قابل تبدیل به یک دیگر هستند. اما تفاوت این دو در چیست؟ هر string از مجموعه ای از byte ها تشکیل شده که هر یک 8 بیت هستند. هر کاراکتر در UTF-8 از 1 تا 4 بایت تشکیل شده. مثلا حرف \u0026lsquo;a\u0026rsquo; از یک بایت و کاراکتر \u0026lsquo;你\u0026rsquo; از 3 بایت تشکیل میشه. به کد زیر توجه کنید:\npackage main import \"fmt\" func stringAndRuneCompare() { s := \"hello你好\" fmt.Printf(\"%s, type: %T, len: %d\\n\", s, s, len(s)) rs := []rune(s) fmt.Printf(\"%v, type: %T, len: %d\\n\", rs, rs, len(rs)) } func main() { stringAndRuneCompare() } ▶ اجرای کد کپی ✖ بستن خروجی طول رشته در تایپ string یازده و در تایپ rune[] برابر 7 است. علت چیست؟ رشته در تایپ string یازده است، زیرا 5 نویسه اول هر کدام فقط 1 بایت می گیرند، در حالی که 2 نویسه چینی آخر هر کدام 3 بایت می گیرند. بنابراین، کل بایت 3 * 2 + 1 * 5 = 11 است.\nهنگام تبدیل رشته به rune[]، گو 7 کاراکتر 32 بیتی پیدا می کند. از انجایی که هر rune برابر 32 بیت است، کاراکتر های انگلیسی و چینی هر کدام یک rune را اشغال می کنند. در نتیجه مجموعا 7 rune وجود دارد.\n1.3.5.6 تایپ رشته (string) # در زبان گو مقدار تایپ رشته بطور پیش‌فرض از نوع یونیکد UTF-8 است.\n// The interpreted form. \u0026quot;Hello\\nworld!\\n\\\u0026quot;你好世界\\\u0026quot;\u0026quot; // The raw form. `Hello world! \u0026quot;你好世界\u0026quot;` همچنین رشته از کارکترهای خاص یونیکد مانند 0x0D پشتیبانی می‌کند.\n1.3.6 خوانایی بهتر اعداد با _ # در زبان گو می‌توان برای خوانایی بهتر اعداد چند رقمی، از _ برای جداسازی استفاده کرد.\n// Legal ones: 6_9 // == 69 0_33_77_22 // == 0337722 0x_Bad_Face // == 0xBadFace 0X_1F_FFP-16 // == 0X1FFFP-16 0b1011_0111 + 0xA_B.Fp2i // Illegal ones: _69 // _ can't appear as the first character 69_ // _ can't appear as the last character 6__9 // one side of _ is a illegal character 0_xBadFace // \u0026quot;x\u0026quot; is not a legal octal digit 1_.5 // \u0026quot;.\u0026quot; is not a legal octal digit 1._5 // \u0026quot;.\u0026quot; is not a legal octal digit "},{"id":11,"href":"/chapter-1/go-operators/","title":"1.4 عملگرها","section":"فصل اول: آشنایی با مفاهیم گو","content":"زبان گو مثل سایر زبان‌ها دارای یکسری عملگرها مانند: عملگرهای حسابی, عملگرهای مقایسه‌ای, عملگرهای منطقی و عملگرهای بیتی است.\n1.4.1 عملگرهای حسابی # زبان گو دارای ۵ تا عملگر حسابی است که به ترتیب:\nعملگر نام + جمع - تفریق * ضرب / تقسیم % باقی مانده این ۵ تا عملگر اغلب به ترتیب مجموع, تفاوت, حاصل‌ضرب و ضریب نیز نامیده می‌شوند.\na := 1 b := 2 c := a + b // 3 d := a - b // -1 e := a * b // 2 f := a / b // 0 g := a % b // 1 در نمونه کد بالا ما از عملگر := که شیوه تعریف متغیر به روش کوتاه است استفاده کردیم که در بخش 1.5 متغیرها و ثابت ها معرفی خواهیم کرد. 1.4.2 عملگرهای مقایسه‌ای # زبان گو دارای ۶ عملگر مقایسه‌ای است که به ترتیب:\nعملگر نام == مساوی بودن =! مساوی نبودن با \u0026gt; کوچکتر از =\u0026gt; کوچکتر یا مساوی \u0026lt; بزرگتر =\u0026lt; بزرگتر یا مساوی نتیجه استفاده از این عملگرهای مقایسه‌ای, یک نوع untyped بولین است. یعنی حاصل این مقایسه‌ها در واقع true یا false است.\na := 1 b := 2 c := 1 println(a == b) // false println(a == c) // true println(a \u0026lt; b) // true println(b \u0026gt; c) // true println(c \u0026lt;= a) // true println(c \u0026gt;= b) // false println(b != a) // true println(c != a) // false 1.4.3 عملگرهای منطقی # زبان گو دارای ۳ نوع عملگر منطقی است که به ترتیب:\nعملگر نام \u0026amp;\u0026amp; AND || OR ! NOT عملگر \u0026amp;\u0026amp; به انگلیسی AND به فارسی و , اگر هردو عملگر true باشد مقدار بازگشتی true و در غیر اینصورت false خواهد بود. عملگر || به انگلیسی OR به فارسی یا , اگر یکی از عملگرها true باشد مقدار بازگشتی true در غیر این صورت false خواهد بود. عملگر ! به انگلیسی NOT به فارسی ‍‍منفی یا نفی , زمانیکه شما از عملگر ! استفاده می کنید معکوس نتیجه عملوند را نیاز دارید. a := true b := true c := false fmt.Println(a \u0026amp;\u0026amp; b) //true fmt.Println(a || b) //true fmt.Println(!a) //false fmt.Println(!c) //true مثال زیر نتیجه مقادیر متفاوت و عملگرهای منطقی را نشان می‌دهد.\n// x y x \u0026amp;\u0026amp; y x || y !x !y true true true true false false true false false true false true false true false true true false false false false false true true 1.4.4 عملگرهای بیتی # زبان گو داری 5 عملگر بیتی است که به ترتیب:\nعملگر نام \u0026lt;\u0026lt; شیفت بیتی به چپ \u0026gt;\u0026gt; شیفت بیتی به راست \u0026amp; AND | OR ^ XOR ‍‍\nعملگر \u0026lt;\u0026lt; به انگلیسی Zero fill left shift یا به اختصار left shift که به فارسی اسم مناسبی نیافتیم به نقل از ویکی پدیا شیفت بیتی به چپ, مقدار باینری ما را با استفاده از انتقال یا اضافه کردن صفرها به سمت چپ انتقال می‌دهد. عملگر \u0026gt;\u0026gt; به انگلیسی Zero fill right shift یا به اختصار right shift که به فارسی اسم مناسبی نیافتیم به نقل از ویکی پدیا شیفت بیتی به راست, مقدار باینری ما را با به سمت راست انتقال می‌دهد. در زیر دو مثال رو مشاهده می‌کنید که از این دو عملگر استفاده شده:\n//example 1 a := 0b01000101 b := a \u0026lt;\u0026lt; 1 c := a \u0026gt;\u0026gt; 1 fmt.Printf(\u0026quot;binary:%08b,value:%v\u0026quot;, a, a) //binary:01000101,value:69 fmt.Println(\u0026quot;\u0026quot;) fmt.Printf(\u0026quot;binary:%08b,value:%v\u0026quot;, b, b) //binary:10001010,value:138 fmt.Println(\u0026quot;\u0026quot;) fmt.Printf(\u0026quot;binary:%08b,value:%v\u0026quot;, c, c) //binary:00100010,value:34 fmt.Println(\u0026quot;\\n\\n---------------\\n\u0026quot;) //example 2 d := 0b01010101 e := d \u0026lt;\u0026lt; 3 f := d \u0026gt;\u0026gt; 3 fmt.Printf(\u0026quot;binary:%08b,value:%v\u0026quot;, d, d) //binary:01010101,value:85 fmt.Println(\u0026quot;\u0026quot;) fmt.Printf(\u0026quot;binary:%08b,value:%v\u0026quot;, e, e) //binary:1010101000,value:680 fmt.Println(\u0026quot;\u0026quot;) fmt.Printf(\u0026quot;binary:%08b,value:%v\u0026quot;, f, f) //binary:00001010,value:10 fmt.Println(\u0026quot;\u0026quot;) */ در مثال دو همانطور که مشاهده کردید زمانی که از عملگر \u0026gt;\u0026gt; استفاده کردید در صورتی که اولین خانه باینری از سمت چپ مقدار 1 داشته باشد مابقی مقدار به صورت 0 به باینری اضافه می‌شود و در غیر این صورت 1 ها به همان مقدار به سمت چپ خواهد رفت.\nدر واقع 08b% یک شناساگر قالب (format specifier) برای نمایش باینری در هشت خانه است در اینجا می‌توانید بیشتر راجب شناساگرهای قالب بخوانید. عملگر \u0026amp; به انگلیسی AND به فارسی و دو مقدار باینری رو با یک دیگر مقایسه و اگر هر بیت مقدار 1 در هر دو طرف داشته باشد آن را 1 نگه می‌دارد و در غیر اینصورت آن بیت را 0 می‌کند. عملگر | به انگلیسی OR به فارسی یا دو مقدار باینری رو با یک دیگر مقایسه و اگر هر بیت مقدار 1 در یک طرف یا هر دوطرف داشته باشد آن را 1 نگه می‌دارد و در غیر اینصورت آن بیت را 0 می‌کند. عملگر ^ به انگلیسی XOR به فارسی نامی ندارد دو مقدار باینری رو با یک دیگر مقایسه و اگر هر بیت مقدار 1 در هر دوطرف داشته باشد آن را 0 می‌کند.\n//\u0026amp; operator example a := 0b01000101 b := 0b01010100 c := a \u0026amp; b fmt.Printf(\u0026quot;binary:%08b,value:%v\u0026quot;, a, a) //binary:01000101,value:69 fmt.Println(\u0026quot;\u0026quot;) fmt.Printf(\u0026quot;binary:%08b,value:%v\u0026quot;, b, b) //binary:01010100,value:84 fmt.Println(\u0026quot;\u0026quot;) fmt.Printf(\u0026quot;binary:%08b,value:%v\u0026quot;, c, c) //binary:01000100,value:68 fmt.Println(\u0026quot;\\n\\n---------------\\n\u0026quot;) //| operator example d := 0b01000101 e := 0b01010100 f := d | e fmt.Printf(\u0026quot;binary:%08b,value:%v\u0026quot;, d, d) //binary:01000101,value:69 fmt.Println(\u0026quot;\u0026quot;) fmt.Printf(\u0026quot;binary:%08b,value:%v\u0026quot;, e, e) //binary:01010100,value:84 fmt.Println(\u0026quot;\u0026quot;) fmt.Printf(\u0026quot;binary:%08b,value:%v\u0026quot;, f, f) //binary:01010101,value:85 fmt.Println(\u0026quot;\\n\\n---------------\\n\u0026quot;) //^ operator example g := 0b01000101 h := 0b01010100 i := a ^ b fmt.Printf(\u0026quot;binary:%08b,value:%v\u0026quot;, g, g) //binary:01000101,value:69 fmt.Println(\u0026quot;\u0026quot;) fmt.Printf(\u0026quot;binary:%08b,value:%v\u0026quot;, h, h) //binary:01010100,value:84 fmt.Println(\u0026quot;\u0026quot;) fmt.Printf(\u0026quot;binary:%08b,value:%v\u0026quot;, i, i) //binary:00010001,value:17 1.4.5 اولویت عملگرها # در زبان گو یکسری اولویت‌ها برای عملگرها وجود دارد و همچنین در زبان گو مثل سایر زبان‌ها پرانتز () ترویج دهنده اولویت‌ها است.\n* / % \u0026lt;\u0026lt; \u0026gt;\u0026gt; \u0026amp; \u0026amp;^ + - | ^ == != \u0026lt; \u0026lt;= \u0026gt; \u0026gt;= \u0026amp;\u0026amp; || توجه در زبان گو اولویت \u0026lt;\u0026lt; و \u0026gt;\u0026gt; بیشتر از + و - است. "},{"id":12,"href":"/chapter-1/go-variables-and-consts/","title":"1.5 متغیرها و constant","section":"فصل اول: آشنایی با مفاهیم گو","content":" 1.5.1 متغیر (Variable) # در برنامه‌نویسی رایانه، یک متغیر یک مکان در حافظه (آدرس حافظه) است که دارای یک نام نمادین با عنوان است و می‌تواند حاوی اطلاعات یا یک مقدار معلوم یا مجهول که به آن ارزش یا مقدار می‌گویند، باشد. به زبان دیگر، متغیر در برنامه‌نویسی به فضایی که برای ذخیره داده‌ها کنار گذاشته شده‌ است می‌گویند (به نقل از سایت ویکی‌پدیا)\nتعریف یک متغیر رشته # package main import ( \"fmt\" ) func main() { var s string = \"Hello World\" fmt.Println(s) } ▶ اجرای کد کپی ✖ بستن خروجی یک متغیر با استفاده از کلید واژه var ایجاد کردیم. نام متغیر را s گذاشتیم. تایپ متغیر را از نوع string تعیین کردیم. سپس با عملگر = مقدار متغیر را مشخص از نوع رشته تعیین کردیم. رشته \u0026quot;Hello World\u0026quot; به عنوان مقدار متغیر s است و این مقدار در خانه مشخصی از حافظه قرار داده شده است. از پکیج استاندارد fmt برای چاپ مقدار متغیر s استفاده کردیم که این پکیج یکسری توابع جهت انجام عملیات‌های مختلفی نظیر چاپ مقادیر را دارد که در کد بالا ما از تابع Println استفاده کردیم. 1.5.1.1 اختصاص مقدار جدید به متغیر از قبل ایجاد شده # در کد زیر ما یک متغیر از قبل تعریف کردیم و مقدار جدید را در خط ۹ به متغیر اختصاص دادیم.\npackage main import ( \"fmt\" ) func main() { var s string s = \"Hello World\" fmt.Println(s) } ▶ اجرای کد کپی ✖ بستن خروجی زمانی که شما یک متغیر بصورت var s string تعریف می‌کنید مقدار پیش‌فرض \u0026quot;\u0026quot; برای متغیر تعیین شده است. 1.5.1.2 اختصاص مقدار رشته به تایپ اشتباه # package main import ( \"fmt\" ) func main() { var i int i = \"One\" fmt.Println(i) } ▶ اجرای کد کپی ✖ بستن خروجی در کد بالا ما یک متغیر از نوع int تعریف کردیم و در خط ۹ مقدار \u0026quot;One\u0026quot; را به آن تخصیص دادیم و پس از اجرا با خطای cannot use \u0026quot;One\u0026quot; (type string) as type int in assignment مواجه شدیم. این خطا یعنی اینکه شما یک مقدار رشته را به تایپ اشتباه اختصاص داده‌اید.\n1.5.1.3 تعریف متغیر به صورت خلاصه # زبان گو علاوه بر اینکه از کلید واژه var برای تعریف متغیر پشتیبانی می‌کند, از =: به انگلیسی short variable declaration نیز برای تعریف متغیرها پشتیبانی می‌کند. شما می‌توانید یک متغیر تعریف کنید و نیازی به مشخص کردن تایپ متغیر نیست، چون زبان گو بر اساس مقدار تعیین شده تایپ متغیر را تشخیص می‌دهد.\npackage main import \"fmt\" func main() { s := \"Hello World\" fmt.Println(s) } ▶ اجرای کد کپی ✖ بستن خروجی توجه کنید شما فقط داخل تابع می‌توانید به صورت مختصر متغیر تعریف کنید و جهت تعریف متغیر به‌صورت عمومی باید از کلید واژه var استفاده کنید.\nبهتر است برای تعریف متغیر داخل تابع از روش مختصر استفاده کنید و متغیر با var بصورت عمومی در بدنه کد باشد.\npackage main import ( \u0026ldquo;fmt\u0026rdquo; )\nvar s string = \u0026ldquo;Hello World\u0026rdquo;\nfunc main() { fmt.Println(s) } ▶ اجرای کد کپی ✖ بستن خروجی\n1.5.1.4 تعریف چند متغیر در یک خط # در زبان گو شما می‌توانید همزمان چند متغیر را در یک خط تعریف کنید که در زیر یک نمونه کد مثال زدیم :\npackage main import \"fmt\" func main() { a, b, c := \"hello\", 1, 1.5 var d, e, f = \"world\", 13, 24 fmt.Println(a, b, c, d, e, f) } ▶ اجرای کد کپی ✖ بستن خروجی 1.5.1.5 تعریف متغیر با مقدار پیش‌فرض # در کد زیر ما یکسری متغیر با تایپ‌های مختلف تعریف کردیم که با مقدار پیش‌فرض ایجاد شده‌اند.\npackage main import \"fmt\" func main() { var i int var f float32 var b bool var s string fmt.Printf(\"%v %v %v %q\\n\", i, f, b, s) //0 0 false \"\" } ▶ اجرای کد کپی ✖ بستن خروجی 1.5.2 مقدار ثابت (Constant) # ثابت (Constant)‌ها بر خلاف متغیر‌ها که با کلید واژه var تعریف می‌شود, با کلید واژه const تعریف می‌شوند با این تفاوت که ثابت‌ها در طول اجرای کد مقدارشان غیرقابل تغییر هست به انگلیسی Immutable, و تضمین می‌کنند هیچ چیزی در طول اجرای برنامه, باعث تغییر مقدار ثابت نشود.\npackage main import ( \"fmt\" ) const s string = \"Hello World\" func main() { fmt.Println(s) } ▶ اجرای کد کپی ✖ بستن خروجی همانطور که در مثال فوق گفتیم شما نمی‌توانید ثابت‌ها را مجددا مقدار دهی کنید. در مثال زیر خطایی که بعد از مقدار دهی دوباره یک ثابت در زمان اجرا رخ داده است را قرار دادیم :\npackage main func main() { const a int = 8 a = 9 } ▶ اجرای کد کپی ✖ بستن خروجی 1.5.2.1 تعریف Constant بدون نیاز به تعیین تایپ # در تعریف ثابت‌ها همانند متغیر ها شما می‌توانید یک ثابت بدون تعیین تایپ تعریف کنید و زبان گو در زمان اجرا با توجه به مقدار اختصاص داده شده به ثابت شما, تایپ را تشخیص می دهد.\nconst a = 1 //Default hidden type is int const b = \u0026quot;circle\u0026quot; //Default hidden type is string const c = 5.4 //Default hidden type is float64 const d = true //Default hidden type is bool const e = 'a' //Default hidden type is rune const f = 3+5i //Default hidden type is complex128 1.5.3 نحوه مشاهده تایپ متغیر یا Constant # در مثال زیر ما با استفاده از یکی از توابع پکیج fmt نوع و مقدار متغیر یا ثابت ها را چاپ کردیم.\npackage main import \"fmt\" // Named untyped constant const a = 123 //Default hidden type is int const b = \"circle\" //Default hidden type is string const c = 5.6 //Default hidden type is float64 const d = true //Default hidden type is bool const e = 'a' //Default hidden type is rune const f = 3 + 5i //Default hidden type is complex8 var u = 123 //Default hidden type is int var v = \"circle\" //Default hidden type is string var w = 5.6 //Default hidden type is float64 var x = true //Default hidden type is bool var y = 'a' //Default hidden type is rune var z = 3 + 5i //Default hidden type is complex128 func main() { fmt.Println(\"\") fmt.Printf(\"Type: %T Value: %v\\n\", a, a) fmt.Printf(\"Type: %T Value: %v\\n\", b, b) fmt.Printf(\"Type: %T Value: %v\\n\", c, c) fmt.Printf(\"Type: %T Value: %v\\n\", d, d) fmt.Printf(\"Type: %T Value: %v\\n\", e, e) fmt.Printf(\"Type: %T Value: %v\\n\", f, f) fmt.Printf(\"Type: %T Value: %v\\n\", u, u) fmt.Printf(\"Type: %T Value: %v\\n\", v, v) fmt.Printf(\"Type: %T Value: %v\\n\", w, w) fmt.Printf(\"Type: %T Value: %v\\n\", x, x) fmt.Printf(\"Type: %T Value: %v\\n\", y, y) fmt.Printf(\"Type: %T Value: %v\\n\", z, z) } ▶ اجرای کد کپی ✖ بستن خروجی 1.5.3.1 استفاده از iota در constant # شناسه iota فقط با ثابت‌ها قابل استفاده است و با آن می‌توانید اعداد auto increment ایجاد کنید.\nایجاد auto increment بدون iota :\nconst ( a = 0 b = 1 c = 2 ) ایجاد auto increment با iota :\nconst ( a = iota // 0 b // 1 c // 2 ) توجه کنید مقدار پیش‌فرض iota صفر, و ثابت ما از نوع int است. 1.5.3.2 نحوه ایجاد enum # از iota و ثابت برای ایجاد enum ها هم می‌توان استفاده کرد که در مثال زیر یک نمونه کد برای ایجاد enum را نیز قرار داده‌ایم.\npackage main import \"fmt\" type Size uint8 const ( small Size = iota medium large extraLarge ) func main() { fmt.Println(small) fmt.Println(medium) fmt.Println(large) fmt.Println(extraLarge) } ▶ اجرای کد کپی ✖ بستن خروجی 1.5.3.3 نادیده گرفتن مقدار اول iota # وقتی که داریم از iota استفاده می‌کنیم شاید هنگام استفاده از auto increament نیاز باشد مقدار اول را نادیده بگیریم. برای اینکار می‌توان از _ استفاده کرد به شکل زیر :\nconst ( _ = iota // ignore a // 1 b // 2 c // 3 ) 1.5.3.4 خودآزمون iota # خروجی کد زیر را در ذهن محاسبه کنید و با اجرای کد صحت آن را بررسی کنید.\npackage main import \"fmt\" func main() { const ( A = iota B C D = B + C E F G = iota H I = H J K ) fmt.Println(A, B, C, D, E, F, G, H, I, J, K) } ▶ اجرای کد کپی ✖ بستن خروجی 1.5.4 قوانین نام‌گذاری متغیر و constant # در زیر ما یکسری قوانین جهت نام‌گذاری متغیر و تابت‌ها تعریف کرده‌ایم :\nنام متغیر یا ثابت باید با یک حرف انگلیسی یا _ شروع شود. نام‌ها می‌توانند ترکیبی از اعداد و حروف انگلیسی یا _ باشد. زبان گو به حروف بزرگ و کوچک در نام ها حساس است و اگر شما hello یا Hello را تعریف کنید, ۲ متغیر یا ثابت متفاوت محسوب می‌شوند. محدودیتی در تعداد حروف نام‌ها وجود ندارد ولی بهتر است از یک تعداد مطلوب و مشخصی برای نام‌ها استفاده کنید. توجه داشته باشید اصولا اسم ثابت‌ها را با حروف بزرگ و خارج از توابع تعریف می‌کنند.\nبا تعریف کردن ثابت‌ها با حروف بزرگ, هنگام استفاده مشخص‌تر خواهند بود. از آنجایی که ثابت‌ها فقط امکان read یا همان خواندن را می‌دهند ممکن است در قسمت‌های مختلف به آن مقادیر نیاز داشته باشیم. به دلیل اینکه با هر بار فراخوانی تابع, کامپایلر عملیات مقدار دهی ثابت را دوباره انجام می‌دهد, بهتر است آن را خارج از تابع تعریف کنیم. "},{"id":13,"href":"/chapter-1/go-zero-values/","title":"1.6 مقادیر صفر تایپ‌ها (zero values)","section":"فصل اول: آشنایی با مفاهیم گو","content":"در جدول زیر فهرست تمامی تایپ‌ها را با مقادیر صفرشان (پیش‌فرض) قرار دادیم:\nتایپ مقدار پیش فرض یا مقدار صفر int 0 int8 0 int16 0 int32 0 int64 0 uint 0 uint8 0 uint16 0 uint32 0 uint64 0 uintptr 0 float32 0 float64 0 complex64 0+0i complex128 0+0i bool false string \u0026quot;\u0026quot; interface nil slice nil channel nil map nil pointer nil function nil struct براساس مقدار پیش فرض فیلدها نمونه کد نمایش مقدار صفر تایپ‌ها:\npackage main import ( \"fmt\" ) func main() { var ( a int b int8 c int16 d int32 e int64 f uint g uint8 h uint16 i uint32 j uint64 k uintptr l float32 m float64 n complex64 o complex128 p bool q string r interface{} s []int t chan int u map[string]int v *int w func() x struct{} y struct { ya int yb bool yc rune } ) fmt.Println(\"int:\", a) fmt.Println(\"int8:\", b) fmt.Println(\"int16:\", c) fmt.Println(\"int32:\", d) fmt.Println(\"int64:\", e) fmt.Println(\"uint:\", f) fmt.Println(\"uint8:\", g) fmt.Println(\"uint16:\", h) fmt.Println(\"uint32:\", i) fmt.Println(\"uint64:\", j) fmt.Println(\"uintptr:\", k) fmt.Println(\"float32:\", l) fmt.Println(\"float64:\", m) fmt.Println(\"complex64:\", n) fmt.Println(\"complex128:\", o) fmt.Println(\"bool:\", p) fmt.Println(\"string:\", q) fmt.Println(\"interface:\", r) fmt.Println(\"slice:\", s) fmt.Println(\"channel:\", t) fmt.Println(\"map:\", u) fmt.Println(\"pointer:\", v) fmt.Println(\"function:\", w) fmt.Println(\"struct:\", x) fmt.Println(\"struct:\", y) } ▶ اجرای کد کپی ✖ بستن خروجی "},{"id":14,"href":"/chapter-1/go-function/","title":"1.7 تابع (function)","section":"فصل اول: آشنایی با مفاهیم گو","content":" 1.7.1 تابع چیست؟ # در برنامه‌نویسی، تابع به تکه کدهایی گفته می‌شود که برای انجام عملی خاص استفاده می‌شوند. به کمک توابع می‌توانیم تکه کدها را از یکدیگر جدا کنیم و از تکرار کدها جلوگیری کنیم.\nهمانند شکل زیر تابع مانند یک جعبه (یا قطعه کد) است. که یک مقدار ورودی گرفته و روی آن پردازش‌هایی انجام می‌دهد و یک خروجی تولید می‌کند. تابع می‌تواند هر چندتا ورودی یا خروجی داشته باشد. 1.7.1.1 چرا از توابع در برنامه نویسی استفاده می‌کنیم؟ # با استفاده از توابع، می‌توانیم یک قطعه کد را یک بار بنویسیم و چندین بار از آن استفاده کنیم. با استفاده از توابع، حجم کدنویسی ما کم‌تر می‌شود و سرعت توسعه نرم‌افزار بیشتر می‌شود. توابع به ما کمک می‌کنند تا کد خود را به تکه‌هایی کوچک‌تر تقسیم کنیم تا برنامه ی ما خوانا و قابل درک‌تر باشد. همچنین نگهداری و اشکال زدایی کد را آسان‌تر می‌کند. 1.7.2 توابع در زبان گولنگ # توابع یکی از قابلیت‌های مهم هر زبانی محسوب می‌شوند. توابع در گولنگ داری سینتکس ساده‌ای هستند.\n1.7.2.1 تعریف یک تابع # func function_name( [Parameter-list] ) [return_types] { // body of the function } func - با این کلید واژه یک تابع تعریف می‌کنیم. function_name - نام تابع باید یکتا و در طول برنامه منحصر به فرد باشد. Parameter-list - پارامترهای ورودی در این قسمت تعریف می‌شوند. پارامترها اختیاری هستند یعنی ممکن است یک تابع هیچ پارامتری نداشته باشد. Return_type - نوع داده‌های بازگشتی را در این قسمت مشخص می‌کنیم و در برخی توابع عملیات موردنظر را بدون بازگرداندن مقداری انجام می‌دهند در این توابع نیازی به تعیین return_type نیست. Function Body - این قسمت شامل کدهایی است که نشان می‌دهد تابع چه کارهایی انجام می‌دهد. 1.7.2.1.1 مثال # package main import \"fmt\" func plus(a int, b int) int { return a + b } func main() { fmt.Println(plus(4, 13)) } ▶ اجرای کد کپی ✖ بستن خروجی در اینجا یک تابع با نام plus تعریف کردیم که دو پارامتر a, b را با نوع داده int دریافت می‌کند و جمع این دو عدد را حساب می‌کند. توجه کنید که همیشه باید نوع داده را مشخص کنیم. بعد از تعریف پارامترهای ورودی و قبل از قرار دادن کد داخل براکت int را می‌بینید که نوع خروجی داده را مشخص می‌کند، یعنی خروجی این تابع باید از نوع int باشد. برای صدا زدن توابع کافی است نام تابع رو همراه با پرانتز باز و بسته تایپ کنید, برای مثال ()plus. در صورتی که پارامترهای ورودی از یک نوع باشند بجای تعریف نوع به‌صورت تکی، می‌توانیم نوع داده را در آخر همه پارامترهای هم نوع مشخص کنیم.\nfunc plus(a, b int) // or func name(a string, b,c int) 1.7.2.1.2 الگو دیگر تعریف تابع: # package main import \"fmt\" func main() { plus := func (a int, b int) int { return a + b } fmt.Println(plus(3, 4)) } ▶ اجرای کد کپی ✖ بستن خروجی 1.7.3 قوانین نام گذاری تابع در گولنگ # نام تابع باید با یک حرف شروع شود. نام تابع فقط می‌تواند شامل حروف-عدد و underscores باشد. (A-z, 0-9, _ ) نام تابع به حروف کوچک و بزرگ حساس است. در نام‌گذاری تابع از فاصله نمی‌توانیم استفاده کنیم. ‬1.7.4 توابع چند بازگشتی در گولنگ (Multiple results) # همچنین در گولنگ توابع می‌توانند چندین مقادیر را برگردانند.\npackage main import \"fmt\" func vals() (int, int) { return 3, 7 } func main() { a, b := vals() fmt.Println(a) fmt.Println(b) _, c := vals() fmt.Println(c) } ▶ اجرای کد کپی ✖ بستن خروجی در کد بالا تابعی ساختیم با اسم vals که دو خروجی از نوع int دارد بنابراین نوع تعریف توابع چندبازگشتی متفاوت است و بصورت (data-type, data-type, \u0026hellip; ) است. در مثال اول ما با کمک دو متغیر a,b دو خروجی تابع vals را دریافت کردیم. در مثال دوم ما با استفاده از _ blank identifier از دریافت یا استخراج خروجی اول صرف نظر کردیم و فقط خروجی دوم با متغیر c را دریافت کردیم. در توابع چند بازگشتی خروجی آنها را باید با , از هم جدا کرد 1.7.4.1 مقادیر بازگشتی نام گذاری شده (Named Return Values) # در گولنگ می‌توانیم مقدار بازگشتی یک تابع را نامگذاری کنیم. به مثال زیر توجه کنید:\npackage main import \"fmt\" func split(sum int) (x, y int) { x = sum * 4 / 9 y = sum - x return } func main() { fmt.Println(split(17)) } ▶ اجرای کد کپی ✖ بستن خروجی ما در این تابع مقدار بازگشتی را x, y از نوع int نام گذاری می‌کنیم. در اینجا یک دستور return بدون تعیین آرگومان بازگشتی، مقادیر نام گذاری شده را باز می‌گرداند، که به عنوان Naked return شناخته می‌شود. از naked return باید در توابع کوتاه مانند مثال بالا استفاده شود. استفاده آن در تابع طولانی منجر به کاهش خوانایی کد می شود. 1.7.5 توابع متنوع در گولنگ (Variadic Functions) # یکی از قابلیت‌های گو وجود توابع متنوع است. منظور از توابع متنوع توابعی هستند که بدون محدودیت پارامتر دریافت می‌کنند (این نکته رو در نظر بگیرین که نباید تایپ ورودی‌ها با یکدیگر فرق کند، برای مثال همه باید int باشند). ‍‍ package main import \"fmt\" func sum(nums ...int) { fmt.Print(nums, \" \") total := 0 for _, num := range nums { total += num } fmt.Println(total) } func main() { sum(1, 2) sum(1, 2, 3) nums := []int{1, 2, 3, 4} sum(nums...) } ▶ اجرای کد کپی ✖ بستن خروجی در اینجا تابعی تعریف کردیم که تعداد دلخواهی از آرگومان‌ها از نوع int را به کمک \u0026hellip; (بهش میگن Ellipsis) که قبل از نوع داده قرار گرفته به داخل تابع منتقل می‌کند. برای صدا زدن این توابع می‌توان به روش sum(num1, num2, \u0026hellip;) عمل کرد. اگر شما داده‌ای با نوع slice دارید می‌توانید آن را به کمک اپراتور \u0026hellip;(Ellipsis) به صورت sum(nums\u0026hellip;) به داخل تابع انتقال بدید. 1.7.6 توابع ناشناس در گولنگ (Anonymous Functions) # در زبان گولنگ می‌توانیم تابع بدون نام تعریف کنیم، که به عنوان توابع ناشناس شناخته می‌شوند.\npackage main import \"fmt\" func main() { // anonymous function var sum = func(n1, n2 int) int { sum := n1 + n2 return sum } // function call result := sum(5, 3) fmt.Println(\"Sum is:\", result) } ▶ اجرای کد کپی ✖ بستن خروجی از آنجایی که توابع ناشناس نامی ندارد ما در بعضی اوقات آن‌ها را به یک متغیر اختصاص می‌دهیم سپس از نام متغیر برای فراخوانی تابع استفاده می‌کنیم. در این مثال می‌بینید که ما از sum برای فراخوانی تابع استفاده می‌کنیم. مانند توابع معمولی ما می‌توانیم برای تابع ناشناس پارامتر تعریف کنیم و همچنین مقداری را از تابع برگردانیم در این مثال تابع دو مقدار با نوع داده int دریافت می‌کنید و یک خروجی با نوع int دارد. تابع ناشناس را می‌توان برای عملکردهایی که نیازی به نام‌گذاری ندارند و معمولا برای استفاده کوتاه مدت هست، استفاده کرد. اما یکی از موارد کاربردی توابع ناشناس در گولنگ پاس دادن آن‌ها به توابعی هستند که تابعی را تحت عنوان پارامتر ورودی دریافت میکنند. در مثال زیر ما یک تابع تعریف کردیم که در پارامتر سوم یک تابع دریافت می‌کند که باید دو ورودی int و یک خروجی int داشته باشد.\npackage main import \"fmt\" func add10AndSum(num1 int, num2 int, sum func(n1, n2 int) int) { result := sum(num1+10, num2+10) fmt.Println(\"Sum by adding 10 is:\", result) } func main() { add10AndSum(5, 3, func(n1, n2 int) int { sum := n1 + n2 return sum }) } ▶ اجرای کد کپی ✖ بستن خروجی 1.7.7 توابع از پیش تعریف شده (Built-in Function) # در گولنگ علاوه بر تابع‌هایی که توسط کاربر تعریف می‌شود یکسری توابع وجود دارد که از قبل تعریف شده‌اند که طراحان این زبان برای سهولت کار برنامه‌نویسان این توابع را نوشته‌اند و آن را همراه زبان گولنگ ارائه می‌دهند.\nhttps://book.gofarsi.ir/chapter-1/go-builtins/\n1.7.7 کلوژر(Function closure) # یک نوع دیگری از anonymous function ها در زبان گولنگ، کلوژر ها هستند. به بیان ساده زمانی که یک فانکشن درون خودش، متغیر هایی که اسکوپ آنها خارج از اسکوپ خودش قرار دارد استفاده کند. کلوژر میگوییم.\npackage main import \"fmt\" func main() { number := 1 func() { fmt.Println(number * 2) }() } ▶ اجرای کد کپی ✖ بستن خروجی در مثال بالا ما یک anonymous function داریم که درون خودش از متغیر اسکوپی که خارج از خودش قرار دارد استفاده کرده است. به این عمل کلوژر می گوییم.\nزمانی که از کلوژر ها استفاده می کنید. برخی مواقع بهتر است به‌جای اینکه به‌صورت مستقیم به متغیر اسکوپ خارجی دسترسی داشته باشید، در پارامتر های ورودی مقدار را دریافت کنید. به مثال زیر دقت کنید(در این مثال از concurrency استفاده کردیم. اگر آشنایی ندارید با مطالعه مقدمه ای از فصل سوم مثال را متوجه می شوید)\npackage main import ( \"fmt\" \"time\" ) func main() { for i := 0; i \u003c 10; i++ { go func() { fmt.Println(i) }() } time.Sleep(time.Second * 1) } ▶ اجرای کد کپی ✖ بستن خروجی خروجی کد برخلاف چیزی که تصور می کنیم به این شکل است:\n$ go run main.go 4 9 5 6 7 8 1 0 2 3 این اتفاق به این دلیل می افتد چون کلوژر ها به‌صورت مستقیم به مقدار اسکوپ بالایی خود دسترسی دارند. قبل از اینکه گوروتین ها مقدار را چاپ کنند حلقه به انتها می رسد و مقدار i برابر با 10 می شود. برای همین در خروجی همه گوروتین ها مقدار 10 چاپ می شود. برای حل این مشکل مقدار i را در پارامتر فانکشن دریافت می کنیم:\npackage main import ( \"fmt\" \"time\" ) func main() { for i := 0; i \u003c 10; i++ { go func(num int) { fmt.Println(num) }(i) } time.Sleep(time.Second * 1) } ▶ اجرای کد کپی ✖ بستن خروجی پس زمانی که از کلوژر ها استفاده می کنید به این نکات دقت کنید.\n"},{"id":15,"href":"/chapter-1/go-array/","title":"1.8 آرایه و slice","section":"فصل اول: آشنایی با مفاهیم گو","content":"آرایه و slice دو نوع تایپ با یک وجه اشتراک در زبان گو هستند ولی این دو نوع تایپ یکسری تفاوت‌هایی نیز با هم دارند که در ادامه به آن‌ها می‌پردازیم.\n1.8.1 تعریف آرایه # آرایه یکی از عمومی‌ترین تایپ‌ها در زبان‌های برنامه‌نویسی آرایه‌ها هستند که برای نگه داری گروهی مقادیر از یک نوع تایپ استفاده می‌شود. برای دسترسی به هر کدام از مقادیر درون آرایه باید از اندیس استفاده کرد. معمولا برای تعریف آرایه تعداد مشخص و ثابتی را برای تعداد مقادیر مشخص میکنید. یعنی این آرایه قرار است چند تا مقدار نگه داری کند.\nدر مثال زیر یک نمونه کد در خصوص چگونگی تعریف آرایه قرار داده‌ایم :\npackage main import \"fmt\" func main() { arrayInts := [5]int{1, 25, 12354, 654, 32} fmt.Println(arrayInts) } ▶ اجرای کد کپی ✖ بستن خروجی یک متغیر کوتاه از نوع آرایه با نام arrayInts تعریف کردیم. ظرفیت آرایه را با عدد ۵ تعیین کردیم (یعنی این آرایه فقط ۵ تا مقدار بیشتر نگه داری نمی‌کند) سپس تایپ آرایه را از نوع int مشخص کردیم. در نهایت در همانجا آرایه را مقدار دهی کردیم. در زبان گو مقدار دهی با باز کردن {} به انگلیسی curly bracket انجام می‌شود. 1.8.2 مفهوم اندازه و ظرفیت (size, capacity) # در آرایه ما ۲ تا مفهوم داریم: اندازه و ظرفیت که از عنوان این مفهوم مشخص است آرایه دارای یک اندازه و ظرفیت مشخصی است و اگر شما بیشتر از ظرفیت و اندازه تعیین شده مقدار دهی کنید با خطا مواجه خواهید شد.\nدر آرایه ظرفیت به نسبت اندازه تعیین می‌شود. package main import \"fmt\" func main() { arrayString := [3]string{\"a\", \"b\", \"c\", \"d\"} fmt.Println(arrayString) } ▶ اجرای کد کپی ✖ بستن خروجی در کد فوق ما یک آرایه با اندازه ۳ تعریف کردیم و ۴ تا مقدار داخلش قرار دادیم و پس از اجرا, با خطای تعداد مقادیر بیشتر از اندازه و ظرفیت می باشد مواجه شدیم.\n1.8.2.1 تابع len و cap # برای آرایه و slice ما ۲ تا تابع داریم که می‌توانیم اندازه و ظرفیت یک آرایه یا slice را بگیریم.\nتابع len یکی از توابع بسیار کاربردی و پراستفاده هنگام کار با آرایه یا slice است که می‌توانید اندازه آرایه یا slice را بگیرید. تابع cap ظرفیت آرایه و slice را نمایش می‌دهد. package main import \"fmt\" func main() { arrayString := [3]string{\"a\", \"b\", \"c\"} fmt.Printf(\"array %v, len %d, cap %d\", arrayString, len(arrayString), cap(arrayString)) } ▶ اجرای کد کپی ✖ بستن خروجی 1.8.3 تعریف آرایه و مقدارهی # در مثال زیر ما یک آرایه با مقدار 5 تعریف کردیم و قصد داریم در ادامه کد، آرایه رو مقداردهی کنیم.\npackage main import \"fmt\" func main() { nums := [5]int{} fmt.Printf(\"array nums values %v, len %d, cap %d\", nums, len(nums), cap(nums)) nums[0] = 1 nums[1] = 2 nums[2] = 10 nums[4] = 999 fmt.Println(\"\") fmt.Printf(\"array nums values %v, len %d, cap %d\", nums, len(nums), cap(nums)) } ▶ اجرای کد کپی ✖ بستن خروجی در کد فوق در ابتدا ما یک آرایه بدون مقدار تعریف کردیم. سپس با استفاده از اندیس مقدار را در خانه مشخص قرار دادیم. 1.8.3.1 تعریف آرایه با اندازه تعیین شده توسط کامپایلر (شما اندازه رو بهش نمیدین.) # شما در زبان گو می‌توانید با استفاده از ... (Ellipsis) یک آرایه با اندازه مشخص شده توسط کامپایلر تعریف کنید.\npackage main import \"fmt\" func main() { nums := [...]int{1, 25, 45, 8797, 78, 879, 541, 11} fmt.Printf(\"array nums values %v, len %d, cap %d\", nums, len(nums), cap(nums)) } ▶ اجرای کد کپی ✖ بستن خروجی توجه کنید زمانی که ... (Ellipsis) برای تعریف آرایه استفاده می‌کنید فقط در همان لحظه تعریف می‌توانید آرایه رو مقدار دهی کنید. 1.8.3.2 تعریف آرایه دو بعدی یا چند بعدی # در زبان گو همانند سایر زبان‌ها می‌توانید آرایه دو بعدی یا چند بعدی تعریف کنید. این نوع آرایه‌ها برای پیاده‌سازی ماتریس یا یکسری سناریوهای توسعه کاربردی مناسب هستند.\npackage main import \"fmt\" func main() { nums := [2][2][2]int{{{1, 2}, {2, 3}}, {{4, 5}, {6, 7}}} fmt.Printf(\"array nums values %v, len %d, cap %d\", nums, len(nums), cap(nums)) } ▶ اجرای کد کپی ✖ بستن خروجی 1.8.3.3 مقایسه آرایه‌ها # در کد زیر ما یک نمونه از مقایسه آرایه‌ها را قرار داده‌ایم که این مقایسه براساس تایپ، اندازه و مقادیر در نظر گرفته شده است.\npackage main import \"fmt\" func main() { nums := [2]int{1, 2} nums2 := [2]int{1, 3} nums3 := [2]int{1, 2} nums4 := [3]int{1, 2, 3} chars := [2]string{\"a\", \"b\"} fmt.Println(nums == nums2) // false fmt.Println(nums == nums3) // true fmt.Println(nums == nums4) // error: invalid operation: nums == nums4 (mismatched types [2]int and [3]int) fmt.Println(nums == chars) // error: invalid operation: nums == chars (mismatched types [2]int and [2]string) } ▶ اجرای کد کپی ✖ بستن خروجی 1.8.4 برش (slice) # همانطور که می‌دانید آرایه یکی از مهم‌ترین عناوین در زبان‌های برنامه‌نویسی است، اما در زبان گو slice نسبت به آرایه بسیار پر استفاده و کاربردی‌تر است. اگر بخواهیم خیلی ساده slice را توصیف کنیم در واقع \u0026ldquo;یک slice به عنوان یک بخش بهم پیوسته از یک آرایه تعریف می‌شود که شما می‌توانید المنت‌ها را در حال اجرا افزایش یا کاهش دهید بدون آنکه ظرفیت و اندازه آن را مشخص کنید.\u0026rdquo;\nاما این سوال پیش می‌آید علت اینکه slice به نسبت آرایه کاربرد بیشتری دارد چیست؟ آرایه دارای برخی از محدودیت‌ها علی الخصوص، اندازه ثابت می‌باشد اما در slice شما این محدودیت‌ها را نخواهید داشت و خیلی ساده می‌توانید المنت‌ها را افزایش، حذف و حتی کپی کنید.\nدر زبان گو slice‌ها یک پارچگی آرایه را حفظ می‌کنند و کار با آرایه خیلی ساده و آسان‌تر خواهد شد. 1.8.4.1 تعریف یک slice با اندازه مشخص # شما می توانید با استفاده از تابع make یک slice با اندازه مشخص تعریف کنید.\nslice := make([]int, 5) fmt.Println(len(slice)) // Print 5 fmt.Println(cap(slice)) // Print 5 1.8.4.2 تعریف یک slice با اندازه و ظرفیت مشخص # شما می‌توانید با استفاده از تابع make یک slice با ظرفیت و اندازه مشخص تعریف کنید.\nslice := make([]int, 3, 5) fmt.Println(len(slice)) // Print 3 fmt.Println(cap(slice)) // Print 5 توجه کنید مقدار ظرفیت نباید کمتر از مقدار اندازه باشد.\npackage main import \u0026ldquo;fmt\u0026rdquo;\nfunc main() { test := make([]int, 5, 4) fmt.Println(test) } ▶ اجرای کد کپی ✖ بستن خروجی\n1.8.4.3 تعریف یک slice با متغیر کوتاه short variable declaration # شما خیلی ساده می‌توانید یک slice را توسط متغیر کوتاه ایجاد کنید.\nslice := []string{\u0026quot;Red\u0026quot;, \u0026quot;Blue\u0026quot;, \u0026quot;Green\u0026quot;, \u0026quot;Yellow\u0026quot;, \u0026quot;Pink\u0026quot;} fmt.Println(len(slice)) //Print 5 fmt.Println(cap(slice)) //Print 5 intSlice:= []int{10, 20, 30} fmt.Println(len(intSlice)) //Print 3 fmt.Println(cap(intSlice)) //Print 3 1.8.4.4 تعریف یک slice با موقعیت‌های شاخص # شما می‌توانید یک slice را با موقعیت‌های شاخص ایجاد کنید که n تا المنت با مقدار پیش‌فرض ایجاد می‌کند و در آخر x را به آخر slice اضافه می‌کند. (در مثال زیر ۹۹ تا المنت با مقدار 0 و در اخر یک المنت با مقدار 88) درست می‌کند.\npackage main import \"fmt\" func main() { test := []int{99: 88} fmt.Println(len(test), cap(test)) } ▶ اجرای کد کپی ✖ بستن خروجی 1.8.4.5 تعریف یک slice خالی # شما می‌توانید خیلی ساده یک slice خالی ایجاد کنید.\nsliceOne := make([]int, 0) sliceTwo := []int{} fmt.Println(sliceOne == nil) // print false fmt.Println(len(sliceOne)) // print 0 fmt.Println(cap(sliceOne)) // print 0 fmt.Println(sliceTwo == nil) // print false fmt.Println(len(sliceTwo)) // print 0 fmt.Println(cap(sliceTwo)) // print 0 1.8.5 مقدار دهی مجدد یکی از المنت های slice یا آرایه # شما خیلی راحت می‌توانید مقدار یکی از المنت‌های slice یا آرایه را مقدار دهی کنید.\nslice := []int{10, 20, 30, 40} fmt.Println(slice) //print [10 20 30 40] slice[1] = 25 fmt.Println(slice) // print [10 25 30 40] 1.8.6 ایجاد یک slice جدید بر اساس یک slice از پیش تعریف شده # شما می‌توانید یک slice جدید را بر اساس یک slice از پیش تعریف شده ایجاد کنید.\nx := []int{10, 20, 30, 40, 50} fmt.Println(x) // Print [10 20 30 40 50] fmt.Println(len(x)) // Print 5 fmt.Println(cap(x)) // Print 5 y := x[1:3] fmt.Println(y) //Print [20 30] fmt.Println(len(y)) //Print 2 fmt.Println(cap(y)) //Print 4 ما یک متغیر با نام x با ۵ تا المنت مقدار دهی شده تعریف کردیم. سپس یک متغیر کوتاه با نام y تعریف کردیم که متغیر x را داخلش قرار دادیم. سپس به متغیر x گفتیم از اندیس ۱ تا ۳ را به y اختصاص بدهد. توجه کنید اتفاقی که مثال بالا رخ داد این بود که ما اندازه و ظرفیت جدیدی برای متغیر y تعیین کردیم.\nLen: 3 - 1 = 2 Cap: 5 - 1 = 4\n1.8.7 خطای index out of range در slice # یک slice فقط با توجه به اندازه و اندیس‌هایش امکان دسترسی و مقدار دهی مجدد المنت هایش را می‌دهد، اما اگر شما بخواهید خارج از اندازه تعیین شده جهت مقداری دهی و یا دسترسی به slice اقدام کنید با خطای index out of range مواجه خواهید شد.\npackage main import \"fmt\" func main() { slice := []int{10, 20, 30, 40, 50} newSlice := slice[1:3] newSlice[3] = 45 fmt.Println(newSlice) } ▶ اجرای کد کپی ✖ بستن خروجی 1.8.8 افرودن (append) المنت‌های یک slice # شما خیلی ساده می‌توانید با استفاده از تابع append به المنت‌های یک slice بیفزایید.\nslice := []int{10, 20, 30, 40, 50} newSlice := slice[1:3] fmt.Println(len(newSlice)) // Print 2 fmt.Println(cap(newSlice)) // Print 4 newSlice = append(newSlice, 60) fmt.Println(len(newSlice)) // Print 3 fmt.Println(cap(newSlice)) // Print 4 در کد زیر اتفاقی که صورت گرفته است این است که اگر شما ... Ellipsis را بعد از کلمه slice بزارید یعنی دارید می‌گید تمامی المنت‌های داخل slice به newSlice اضافه شود.\nslice := []int{10, 20, 30, 40, 50} newSlice := []int{} newSlice = append(newSlice, slice...) 1.8.9 نحوه حذف یک المنت در slice # برای حذف یک المنت در slice باید بصورت تکنیکی اینکار را انجام دهید چون زبان گو یک روش built-in برای این کار ندارد.\nدر این روش شما باید در ابتدا آخرین المنت را به المنت مورد نظر با استفاده از اندیس کپی کنید. سپس آخرین المنت را از slice حذف کنید. package main import \"fmt\" func main() { slice := []int{10, 20, 30, 40, 50} slice[1] = slice[len(slice)-1] slice = slice[:len(slice)-1] fmt.Println(slice) } ▶ اجرای کد کپی ✖ بستن خروجی یک روش دیگر برای حذف یک المنت از slice استفاده از تابع append است. به مثال زیر توجه کنید. package main import \"fmt\" func main() { slice := []int{1, 2, 3, 4, 5} index := 2 // ایندکس المنتی که میخاییم حذفش کنیم slice = append(slice[:index], slice[index+1:]...) fmt.Println(slice) // خروجی: [1 2 4 5] } ▶ اجرای کد کپی ✖ بستن خروجی 1.8.10 تابع copy در slice # شما با استفاده از تابع copy می‌توانید یک slice را به slice دیگری کپی کنید.\npackage main import \"fmt\" func main() { src := []int{1, 2, 3, 4, 5} dst := make([]int, 5) numberOfElementsCopied := copy(dst, src) fmt.Println(numberOfElementsCopied, dst) } ▶ اجرای کد کپی ✖ بستن خروجی 1.8.11 نحوه مرتب کردن (sort) یک slice # برای مرتب کردن یک slice می‌توانید از توابع کتابخانه sort در زبان گو استفاده کنید.\nsort.Ints sort.Float64s sort.Strings package main import ( \"fmt\" \"sort\" ) func main() { s := []int{4, 2, 3, 1} sort.Ints(s) fmt.Println(s) } ▶ اجرای کد کپی ✖ بستن خروجی 1.8.12 فرق بین آرایه و slice # فرق نوع تعریف آرایه و slice برای تعریف آرایه شما باید داخل براکت [] یک مقداری را قرار دهید. برای تعریف slice هیچ مقداری را داخل براکت [] نباید قرار دهید. array := [3]int{10, 20, 30} slice := []int{10, 20, 30} فرق بین مقدار صفر آرایه و slice مقدار خالی slice ها nil است. مقدار خالی یک آرایه، همان آرایه با المنت‌های مقدار پیش‌فرض است. var slice []int32 var array [2]int32 fmt.Println(slice == nil) // print true fmt.Println(len(slice)) // print 0 fmt.Println(cap(slice)) // print 0 fmt.Println(array) // print [0 0] "},{"id":16,"href":"/chapter-1/go-for/","title":"1.9 حلقه‌ها (for)","section":"فصل اول: آشنایی با مفاهیم گو","content":" 1.9.1 حلقه # حلقه‌ها را در زبان گو به ساده‌ترین شکل ممکن و فقط با استفاده از کلید واژه for و در مدل‌های مختلف (سه‌بخشی، بی نهایت، foreach و \u0026hellip;) می‌توان پیاده‌سازی کرد.\n1.9.2 حلقه سه بخشی # این نمونه که متداول‌ترین نوع حلقه for نیز هستند با استفاده از سه‌ بخش:\nمقداردهی شرط شمارنده ایجاد می‌شوند.\nfor initialization ; condition ; counter { //loop codes } در مثال زیر نمونه‌ای از این حلقه‌ قابل مشاهده و اجرا است. package main import \"fmt\" func main() { sum := 0 for i := 1; i \u003c 10; i++ { sum += i } fmt.Println(sum) } ▶ اجرای کد کپی ✖ بستن خروجی 1.9.3 حلقه while # این مدل حلقه شبیه while در بیشتر زبان ها مثل پایتون و C است. با این تفاوت که پیاده‌سازی آن، تنها با کلیدواژه‌ی for و با حذف بخش مقداردهی و شمارنده حلقه سه‌بخشی انجام می‌گیرد. در واقع در این حلقه تنها یک شرط تعریف می‌شود و تا برقرار بودن آن شرط حلقه اجرا می‌شود. به مثال زیر توجه کنید:\npackage main import \"fmt\" func main() { i := 0 for i \u003c 10 { fmt.Println(i) i++ } } ▶ اجرای کد کپی ✖ بستن خروجی 1.9.4 حلقه بی‌نهایت # اگر از حلقه‌ی while که در مثال بالا تعریف کردیم بخش شرط را حذف کنیم چه اتفاقی می‌افتد؟ در این حالت ما یک شرط بی نهایت ساخته‌ایم (شبیه به while(1)) که تا زمانی‌ که برنامه متوقف نشود و یا کدهای داخل حلقه، فرمان خروج از حلقه را ندهند، چرخه ی اجرای حلقه ادامه خواهد یافت.\npackage main import \"fmt\" func main() { sum := 0 for { sum++ } fmt.Println(\"this line will never execute\") } ▶ اجرای کد کپی ✖ بستن خروجی با اجرای کد بالا خطای تایم‌اوت دریافت خواهید کرد (اگر در playground سایت گو اجراش کنین)، به‌ دلیل اینکه حلقه هیچ‌گاه تمام نمی‌شود.\n1.9.5 حلقه for-range # حلقه for-range یکی از پرکاربردترین حلقه‌ها در زبان گو می‌باشد که شما می‌توانید برای slice، آرایه و map یا رشته از این حلقه استفاده کنید.\nfor index, value := range slice/array {} for key, value := range map {} 1.9.5.1 حلقه for-range برای slice و آرایه # شما با استفاده از حلقه for-range می‌توانید به المنت‌های آرایه یا slice و همچنین اندیس‌شان (Index) دسترسی پیدا کنید. دقت کنید ۲ حالت وجود دارد:\n1.9.5.1.1 دسترسی با استفاده از یک کپی از المنت # در کد زیر ما با استفاده از for-range به یک کپی از المنت‌های اسلایس letter دسترسی پیدا کردیم.\npackage main import \"fmt\" func main() { letters := []string{\"a\", \"b\", \"c\"} //With index and value fmt.Println(\"Both Index and Value\") for i, letter := range letters { fmt.Printf(\"Index: %d Value:%s\\n\", i, letter) } //Only value fmt.Println(\"\\nOnly value\") for _, letter := range letters { fmt.Printf(\"Value: %s\\n\", letter) } } ▶ اجرای کد کپی ✖ بستن خروجی 1.9.5.1.2 دسترسی مستقیم به خانه حافظه المنت # شما با استفاده از اندیس (index) می‌توانید مستقیماً به خانه حافظه المنت دسترسی پیدا کنید و آن المنت رو با استفاده از اندیس (Index) نمایش بدید. به مثال زیر توجه کنید:\npackage main import \"fmt\" func main() { letters := []string{\"a\", \"b\", \"c\"} fmt.Println(\"\\nOnly letter\") for i := range letters { fmt.Printf(\"letter: %s\\n\", letters[i]) } } ▶ اجرای کد کپی ✖ بستن خروجی 1.9.1.2 حلقه for-range برای map # شما با استفاده از حلقه for-range برروی map, میتوانید به کلید و مقدار هر یک از مقادیر map دسترسی پیدا کنید.\npackage main import \"fmt\" func main() { sample := map[string]string{ \"a\": \"x\", \"b\": \"y\", } //Iterating over all keys and values fmt.Println(\"Both Key and Value\") for k, v := range sample { fmt.Printf(\"key :%s value: %s\\n\", k, v) } //Iterating over only keys fmt.Println(\"\\nOnly keys\") for k := range sample { fmt.Printf(\"key :%s\\n\", k) } //Iterating over only values fmt.Println(\"\\nOnly values\") for _, v := range sample { fmt.Printf(\"value :%s\\n\", v) } } ▶ اجرای کد کپی ✖ بستن خروجی 1.9.1.3 حلقه for-range برای رشته (string) # شما با استفاده از حلقه for-range می توانید به هرکدام از کارکترهای رشته دسترسی پیدا کنید.\nfor index, character := range string { //Do something with index and character } به کد نمونه زیر توجه کنید :\npackage main import \"fmt\" func main() { sample := \"a£b\" //With index and value fmt.Println(\"Both Index and Value\") for i, letter := range sample { fmt.Printf(\"Start Index: %d Value:%s\\n\", i, string(letter)) } //Only value fmt.Println(\"\\nOnly value\") for _, letter := range sample { fmt.Printf(\"Value:%s\\n\", string(letter)) } //Only index fmt.Println(\"\\nOnly Index\") for i := range sample { fmt.Printf(\"Start Index: %d\\n\", i) } } ▶ اجرای کد کپی ✖ بستن خروجی 1.9.6 کلید واژه break # با استفاده از break می‌توان چرخه‌ی اجرای یک حلقه را پایان داد. به عنوان مثال در حلقه بی‌نهایتی که در بخش 1.9.4 مشاهده کردید، می‌توان با تعریف یک شرط خاص از حلقه خارج شد. کد زیر نمونه استفاده از break را نمایش می‌دهد.\npackage main import \"fmt\" func main() { sum := 0 for { sum++ if sum == 10 { break } } fmt.Println(sum) fmt.Println(\"now this line will execute\") } ▶ اجرای کد کپی ✖ بستن خروجی 1.9.7 label در حلقه ها # شما با قابلیت label در زبان گو می‌توانید لیبلی را به یک حلقه خاص اختصاص دهید و بعد از چند حلقه تو در تو حلقه مورد نظر را break کنید.\npackage main import \"fmt\" func main() { letters := []string{\"a\", \"b\", \"c\"} for i := 1; i \u003c 10; i++ { // define a lable with name 'second' for this loop second: for i := 2; i \u003c 9; i++ { for _, l := range letters { if l == \"b\" { // break the loop with second lable break second } } } } } ▶ اجرای کد کپی ✖ بستن خروجی در کد بالا زمانی که از لیبل استفاده نشود سومین حلقه درونی break خواهد شد. اما با استفاده از لیبل‌ها هرکدام از حلقه‌های مورد نظر را می‌توان break کرد.\n1.9.8 کلیدواژه continue # این کلید‌واژه چرخه‌ اجرای حلقه را یک مرحله جلو می‌برد. به این‌ معنی که اگر در حلقه از این کلید‌واژه استفاده شود، کدهای بعد از continue اجرا نشده و چرخه بعدی (گام بعدی) اجرا خواهد شد.\npackage main import \"fmt\" func main() { for i := 1; i \u003c 10; i++ { if i%2 == 0 { continue } fmt.Println(i) } } ▶ اجرای کد کپی ✖ بستن خروجی قابل ذکر است که continue و break در حلقه‌های تو در تو، فقط روی اولین حلقه درونی تاثیر خواهند گذاشت. 1.9.9 خودآزمون حلقه # سوال با استفاده از زبان گو برنامه‌ای بنویسید که سری‌ زیر را ایجاد کند:\n1 22 333 55555 88888888 13131313131313131313131313 212121212121212121212121212121212121212121 الگوریتم پاسخ ‍1 + 0 = 1 1 + 1 = 2 2 + 1 = 3 3 + 2 = 5 5 + 3 = 8 8 + 5 = 13 13 + 8 = 21 a + b = c b = a a = c کد پاسخ package main import \u0026quot;fmt\u0026quot; func main() { var ( n = 6 // can define any result count ... a, b, c = 1, 0, 0 ) for i := 0; i \u0026lt;= n; i++ { c = a + b for j := 1; j \u0026lt;= c; j++ { fmt.Print(c) } fmt.Println() b, a = a, c } } "},{"id":17,"href":"/chapter-1/go-map/","title":"1.10 نقشه map","section":"فصل اول: آشنایی با مفاهیم گو","content":" 1.10.1 مقدمه # نقشه ، یک نوع ساختار داده است. نقشه ها جهت جمع‌آوری و نگهداری مجموعه‌ای از داده‌ها استفاده می‌گردند. نقشه ، از نوع داده‌های انجمنی (هش) بصورت «کلید-مقدار» است. نقشه ، مجموعه‌ای از داده‌ها بصورت جفت‌‌های مرتب‌نشده است. 1.10.2 تعریف # یک مپ شبیه به فرمت زیر است:\nmap[KeyType]ValueType کلمه کلیدی map و بعد نوع کلید و در آخر هم نوع مقدار تعریف می‌شود.\nکلید: برای اشاره به یک مقدار ذخیره شده، نیاز به یک نام‌ داریم و این یعنی «کلید» آن مقدار.\nمقدار کلید در یک مپ، باید یکتا باشد. محدودیت: برای تعریف کلید، از انواع تایپ‌هایی که قابل مقایسه هستند، می‌توان استفاده کرد: Boolean(s) Number(s) String(s) Array(s) Pointer(s) Struct(s) Interface(s) (تا زمانی که از مقادیر مقایسه‌پذیر استفاده می‌کند) از Slice(s) Map(s) Function(s) نمی‌توان برای تعریف «کلید» مپ استفاده کرد. در مپ می‌توان برای کلید از مقدار داخل یک متغیر بهره برد. package main import \"fmt\" func main() { myMap := make(map[int]string) myKey := 13 myMap[myKey] = \"thirteen\" fmt.Println(myMap) //map[13:thirteen] fmt.Println(myMap[myKey]) //thirteen } ▶ اجرای کد کپی ✖ بستن خروجی مقدار: حاوی داده‌ای است که کلید به آن اشاره می‌کند و برخلاف کلید، هیچ محدودیت برای انتخاب «نوع» آن وجود ندارد، به‌عنوان نمونه می‌توان از یک مپ دیگر برای مقدار استفاده کرد. (مپ‌های تودرتو ) map[string]map[int]string 1.10.3 ایجاد و مقداردهی اولیه # مقدار پیش‌فرض برای یک مپ nil می‌باشد. برای مقداردهی مپ‌ ها از روش‌های زیر استفاده می‌شود:\nاستفاده از کلمه کلیدی var var sampleMap = map[keyType]valueType{keyName1:value1, keyName2:value2, ...} var sampleMap map[keyType]valueType = map[keyType]valueType{} استفاده از علامت =: short variable declaration sampleMap := map[keyType]valueType{keyName1:value1, keyName2:value2, ...} استفاده از تابع make var sampleMap = make(map[keyType]valueType) sampleMap := make(map[keyType]valueType) 1.10.4 مپ با مقدار nil # درصورت تعریف اولیه مپ توسط دستور var sampleMap map[keyType]valueType یک مپ با مقدار nil ساخته می‌شود که نمی‌توان بدون مقداردهی اولیه، روی آن عملیات ارسال و دریافت داده‌ انجام داد:\nvar sampleMap map[uint8]int sampleMap[13] = 9999999 //panic: assignment to entry in nil map برای مقداردهی یک مپ nil که به روش زیر ساخته اید:\nvar m map[string]string از روش‌های زیر می‌توان بهره گرفت:\nvar m map[string]string = map[string]string{} m := make(map[string]string) m := map[string]string{} 1.10.5 توابع مربوط به مپ # تابع (len): برای برگشت تعداد عناصر داخل مپ از len استفاده می‌شود: package main import \"fmt\" func main() { var sampleMap = map[string]bool{} var otherMap = make(map[string]uint) var nilMap map[bool]bool sampleMap[\"condition#1\"] = true sampleMap[\"condition#2\"] = false otherMap[\"foo\"] = 1 fmt.Println(len(sampleMap))\t//2 fmt.Println(len(otherMap))\t//1 fmt.Println(len(nilMap))\t//0 (len nil is zero) } ▶ اجرای کد کپی ✖ بستن خروجی مقدار برگشتی برای تابع len روی مپ‌ nil برابر صفر (۰) است.\n1.10.6 عملیات CRUD روی مپ # C : Create برای ایجاد مپ، اغلب از تابع make استفاده می شود:\npackage main import \u0026quot;fmt\u0026quot; func main() { animals := make(map[int]string) // nil map of string-int pairs animals[1] = \u0026quot;Gopher\u0026quot; animals[2] = \u0026quot;owl\u0026quot; animals[3] = \u0026quot;cheetah\u0026quot; animals[4] = \u0026quot;eagle\u0026quot; animals[5] = \u0026quot;lion\u0026quot; fmt.Println(animals) //map[1:Gopher 2:owl 3:cheetah 4:eagle 5:lion] } R : Read جهت خواندن مقادیر مپ می‌توان از الگوی زیر استفاده کرد: mapName[\u0026quot;keyName\u0026quot;] مثال:\npackage main import \u0026quot;fmt\u0026quot; func main() { animals := make(map[int]string) // nil map of string-int pairs animals[1] = \u0026quot;Gopher\u0026quot; animals[2] = \u0026quot;owl\u0026quot; animals[3] = \u0026quot;cheetah\u0026quot; animals[4] = \u0026quot;eagle\u0026quot; animals[5] = \u0026quot;lion\u0026quot; fmt.Println(animals[2]) //owl } U : Update برای بروزرسانی مقادیر مپ، از الگوی mapName[keyName] = newValue استفاده می‌شود. مثال:\npackage main import \u0026quot;fmt\u0026quot; func main() { animals := make(map[int]string) // nil map of string-int pairs animals[1] = \u0026quot;Gopher\u0026quot; animals[2] = \u0026quot;owl\u0026quot; animals[3] = \u0026quot;cheetah\u0026quot; animals[4] = \u0026quot;eagle\u0026quot; animals[5] = \u0026quot;lion\u0026quot; fmt.Println(animals[2]) //owl animals[2] = \u0026quot;wolf\u0026quot; fmt.Println(animals[2]) //wolf } D : Delete جهت حذف مقادیر در مپ، از تابع delete متعلق به پکیج builtin استفاده می‌شود.\npackage main import \u0026quot;fmt\u0026quot; func main() { animals := make(map[int]string) // nil map of string-int pairs animals[1] = \u0026quot;Gopher\u0026quot; animals[2] = \u0026quot;owl\u0026quot; animals[3] = \u0026quot;cheetah\u0026quot; animals[4] = \u0026quot;eagle\u0026quot; animals[5] = \u0026quot;lion\u0026quot; fmt.Println(animals) //map[1:Gopher 2:owl 3:cheetah 4:eagle 5:lion] fmt.Println(len(animals)) //5 delete(animals, 4) fmt.Println(animals) //map[1:Gopher 2:owl 3:cheetah 5:lion] fmt.Println(len(animals)) //4 } نکته: اگر کلید مورد استفاده در فانکشن delete() پیدا نشود، هیچ اتفاقی نخواهد افتاد. علت عدم بازگشت ارور در فانکشن delete() است\n// The delete built-in function deletes the element with the specified key // (m[key]) from the map. If m is nil or there is no such element, delete // is a no-op. func delete(m map[Type]Type1, key Type) 1.10.7 بررسی وجود کلید # یکی از خدماتی که مپ ارائه می‌دهد،‌ پاسخ به سوال وجود یک کلید خاص در مپ می‌باشد که به‌عنوان راهکاری برای حل مسائل از آن استفاده می‌شود. مثال زیر را ببینید:\npackage main import \"fmt\" func main() { var personData = map[string]string{\"name\": \"frank\", \"family\": \"colleti\", \"dob\": \"1970-05-12\"} name, nameExist := personData[\"name\"] family, familyExist := personData[\"family\"] dob, dobExist := personData[\"dob\"] organization, organizationExist := personData[\"organization\"] fmt.Println(name, nameExist) //frank true fmt.Println(family, familyExist) //colleti true fmt.Println(dob, dobExist) //1970-05-12 true fmt.Println(organization, organizationExist) // false } ▶ اجرای کد کپی ✖ بستن خروجی این روش بیشتر به اسم comma, ok شناخته می‌شود و بسیاری از توابع چه در کتابخانه استاندارد و چه کتابخانه‌های عمومی در گولنگ، از این نوع نام‌گذاری برای برگشت دادن مقدار و ارور پشتیبانی می‌کنند. در مثال بالا تمامی متغیرهایی که با Exist تمام می‌شوند برای برسی وجود و عدم وجود یک کلید در مپ استفاده می‌شوند، به این صورت که اگر مقدار مشخص شده در مپ وجود داشت مقدار برگشتی در این متغیرها true خواهد بود و در غیر این صورت مقدار برگشتی false. 1.10.8 مپ، یک جدول، یک منبع # وقتی یک مپ تعریف می‌شود، اگر مپ(های) دیگری از روی آن ساخته شود، دارای یک منبع (reference type) برای ذخیره و دریافت اطلاعات خواهند بود. در مثال زیر، مپ editorMap از مپ companyProfile ایجاد و وقتی ویرایش می‌شود، مپ اصلی نیز،‌ ویرایش می‌شود.\npackage main import \"fmt\" func main() { var companyProfile = map[string]string{ \"name\": \"companyName\", \"address\": \"sampleAddress\", } var editorMap = companyProfile // == editorMap := companyProfile fmt.Println(companyProfile[\"name\"], \"\\t\", companyProfile[\"address\"]) //companyName sampleAddress fmt.Println(editorMap[\"name\"], \"\\t\", editorMap[\"address\"]) //companyName sampleAddress editorMap[\"name\"] = \"new name\" editorMap[\"address\"] = \"new address\" //reference map also edited when editor map edit fmt.Println(companyProfile[\"name\"], \"\\t\", companyProfile[\"address\"]) //new name new address fmt.Println(editorMap[\"name\"], \"\\t\", editorMap[\"address\"]) //new name new address } ▶ اجرای کد کپی ✖ بستن خروجی برای اینکه بتوانید مقادیر یک مپ را درون یک مپ دیگر کپی کنید، راه حل این است داخل آن مپ پیمایش کنید و مقادیرش را در مپ جدید قرار دهید.\npackage main import \"fmt\" func main() { var companyProfile = map[string]string{ \"name\": \"companyName\", \"address\": \"sampleAddress\", } var editorMap = map[string]string{} for key, value := range companyProfile { editorMap[key] = value } fmt.Println(companyProfile[\"name\"], \"\\t\", companyProfile[\"address\"]) fmt.Println(editorMap[\"name\"], \"\\t\", editorMap[\"address\"]) editorMap[\"name\"] = \"new address\" editorMap[\"address\"] = \"new address\" fmt.Println(companyProfile[\"name\"], \"\\t\", companyProfile[\"address\"]) fmt.Println(editorMap[\"name\"], \"\\t\", editorMap[\"address\"]) } ▶ اجرای کد کپی ✖ بستن خروجی 1.10.9 پیمایش روی مپ # یکی از اصلی‌ترین اهداف ایجاد و نگهداری انواع تایپ‌های مربوط به مجموعه داده‌ها، امکان دسترسی به اجزای داده و انواع لوپ از ابزارهای آن است. با استفاده از for-range می‌توان به اجزای یک داده‌ از نوع کلید-مقدار دسترسی داشت\npackage main import ( \"fmt\" ) func main() { animals := make(map[int][]string) // nil map of string-int pairs animals[0] = []string{\"Gopher\", \"running\", \"rodent\"} animals[1] = []string{\"owl\", \"flying\", \"carnivorous\"} animals[2] = []string{\"cheetah\", \"running\", \"carnivorous\"} animals[3] = []string{\"eagle\", \"flying\", \"carnivorous\"} animals[4] = []string{\"lion\", \"running\", \"carnivorous\"} for index, animal := range animals { fmt.Printf(\"%v- %s is %s animal and can %s \\n\", index, animal[0], animal[2], animal[1]) } } ▶ اجرای کد کپی ✖ بستن خروجی به نحوه چیدمان خروجی‌ها دقت کنید، درباره علت یکسان نبودن خروجی‌ها در اجراهای متعدد تحقیق کنید تقلب کوچیک بهتون بدم :). مپ ها unordered هستن.\n1.10.10 تبدیل اطلاعات رشته − مپ − اسلایس # نمونه کد زیر یک رشته را به مپ و یک مپ را به اسلایس تبدیل می‌کند.\npackage main import ( \"fmt\" ) func seriesStringToMap(inputs ...string) map[int]string { result := make(map[int]string) for index, input := range inputs { result[index] = input } return result } func mapToSlice(inputs map[int]string) []string { result := make([]string, len(inputs)) for index, input := range inputs { result[index] = input } return result } func main() { myAnimal := \"Eagle Cheetah Owl Lion Gopher\" myMappedAnimal := seriesStringToMap(myAnimal) fmt.Println(myMappedAnimal) //map[0:Eagle Cheetah Owl Lion Gopher] mySlicedAnimal := mapToSlice(myMappedAnimal) fmt.Println(mySlicedAnimal) //[Eagle Cheetah Owl Lion Gopher] } ▶ اجرای کد کپی ✖ بستن خروجی 1.10.11 خودآزمون # کد زیر را بررسی کنید و خروجی(های) آن را با ذهن خود پردازش کنید. سپس صحت آن(ها) را بررسی و درباره آن تحقیق کنید:\npackage main import \"fmt\" func main() { var myMap map[string]int fmt.Println(myMap) var otherMap = map[string]int{} fmt.Println(otherMap) myMap[\"foo\"] = 13 fmt.Println(myMap) otherMap[\"bar\"] = 99 fmt.Println(otherMap) } ▶ اجرای کد کپی ✖ بستن خروجی "},{"id":18,"href":"/chapter-1/go-if-switch/","title":"1.11 شرط (if, switch)","section":"فصل اول: آشنایی با مفاهیم گو","content":" 1.11.1 شرط (if-else) # زبان گو همانند سایر زبان‌ها دارای شرط است که شما خیلی ساده می‌توانید از آن استفاده کنید. در مثال زیر ما فرمت استاندارد شرط در زبان گو را قرار دادیم:\nif condition { //Do something } else if condition { //Do something } else { //Do something } در بالا condition عبارتی است که قرار است وضعیت شرط را مشخص کند و در صورت true شدن شرط بر قرار می‌شود و در صورت برقرار نشدن شرط اول، برنامه وارد else if می‌شود و مجدد یک condition دیگری را چک می‌کند که وضعیتش true می‌شود یا خیر و در نهایت منتهی می‌شود به else.\nدر شرط ما یک یا چندتا condition می‌توانیم داشته باشیم که این condition‌ ها برای تعیین وضعیت از یکسری عملگرها نظیر \u0026amp;\u0026amp; , || , \u0026gt; , \u0026lt; , \u0026lt;= , =\u0026gt; , ! و \u0026hellip; استفاده می کنند.\nزبان گو از فرمت‌های زیر برای ایجاد شرط استفاده می‌کند:\nفقط if if-else تو در تو (nested) شرط کوتاه با if 1.11.2 کلمه if به تنهایی # شما می‌توانید به تنهایی از if استفاده و یک condition را بررسی کنید:\nif condition { //Do something } برای نمونه کد زیر را ببینید:\npackage main import \"fmt\" func main() { a := 6 if a \u003e 5 { fmt.Println(\"a is greater than 5\") } } ▶ اجرای کد کپی ✖ بستن خروجی در مثال بالا ما مقدار a را با عدد ۵ مقایسه کردیم، شرط ما به این صورت بود که آیا a از ۵ بزرگتر است یا خیر؟ جواب true است. a بزرگتر از 5 است و شرط برقرار میشود.\nدر مثال زیر ما چند condition را داخل یک شرط بررسی کردیم. آیا a بزرگتر از 3 و a کوچک تر از 6 است؟\npackage main import \"fmt\" func main() { a := 4 if a \u003e 3 \u0026\u0026 a \u003c 6 { fmt.Println(\"a is within range\") } } ▶ اجرای کد کپی ✖ بستن خروجی 1.11.3 کلمه else # فرمت شرط همراه با else مانند مثال زیر است:\nif condition { //Do something } else { //Do something } در مثال بالا اگر condition برقرار نشود، کدهای داخل else اجرا خواهند شد. به مثال زیر توجه کنید:\npackage main import \"fmt\" func main() { a := 1 b := 2 if a \u003e b { fmt.Println(\"a is greater than b\") } else { fmt.Println(\"b is greater than a\") } } ▶ اجرای کد کپی ✖ بستن خروجی 1.11.4 ادامه شرط با else if # شما با استفاده از کلید واژه else if دقیقا به همین فرمت که اینجا نوشته شده می‌توانید condition دیگری را بررسی کرده و در صورت برقرار شدن شرط، عملیات را انجام دهید.\nif condition1 { //Do something } else if condition2 { //Do something } else { //Do something } به مثال زیر توجه کنید:\npackage main import \"fmt\" func main() { age := 29 if age \u003c 18 { fmt.Println(\"Kid\") } else if age \u003e= 18 \u0026\u0026 age \u003c 40 { fmt.Println(\"Young\") } else { fmt.Println(\"Old\") } } ▶ اجرای کد کپی ✖ بستن خروجی 1.11.5 شرط تو در تو (nested) # در زبان گولنگ شما می‌توانید شرط‌های تو در تو (nested) داشته باشید (برای توسعه بهتر پروژه، بهتر است کمتر از شرطهای تو در تو استفاده کنید، زیرا این گونه شرط نویسی خوانایی کد را پایین می‌آورد)\nif condition { //Do something if condition2 { //Do something } //Do something } در مثال زیر یک نمونه شرط تو در تو به همراه else قرار دادیم:\nif condition1 { //... } else { //... if condition2 { //... } else { //.... } //.... } در کد زیر مثالی برای شروط تو در تو زدیم:\npackage main import \"fmt\" func main() { a := 1 b := 2 c := 3 if a \u003e b { if a \u003e c { fmt.Println(\"Biggest is a\") } else { fmt.Println(\"Biggest is c\") } } else { if b \u003e c { fmt.Println(\"Biggest is b\") } else { fmt.Println(\"Biggest is c\") } } } ▶ اجرای کد کپی ✖ بستن خروجی 1.11.6 تعریف شرط و قرار دادن condition در متغیر کوتاه # در زبان گو شرط‌ها, امکان تعریف متغیر به روش کوتاه در شرط برای condition را دارند و شما می‌توانید قبل از بررسی کردن condition اون رو در همان خط مقدار دهی کنید.\nif statement; condition { //Do something } به مثال زیر توجه کنید:\npackage main import \"fmt\" func main() { if a := 6; a \u003e 5 { fmt.Println(\"a is greater than 5\") } } ▶ اجرای کد کپی ✖ بستن خروجی در مثال بالا ما یک متغیر کوتاه با نام a را داخل شرط تعریف کردیم و مقدار 6 را بهش دادیم، سپس با قرار دادن ; semi-colon برقراری وضعیت شرط را بررسی کردیم.\n1.11.7 Switch # زبان گو ‌مانند برخی از زبان‌ها از switch پشتیبانی می‌کند. switch یک روش بسیار ساده‌تر و همچنین روشی برای جلوگیری از else if های مکرر در شرط است.\nswitch statement; expression { case expression1: //Dosomething case expression2: //Dosomething default: //Dosomething } زمانیکه switch رو تعریف می‌کنیم, هم می‌توانیم مقداری که قبلا تعریف کردیم رو برای بررسی بهش بدیم و هم می‌توانیم از روش (تعریف متغیر به روش کوتاه) یک مقدار جدید تعریف کنیم و ازش استفاده کنیم. بعد از کلمه switch باید یک مقدار رو بهش بدیم و داخل switch با استفاده از case بررسی کنیم که مقداری که داده شده با اون چیزی که مد نظر ما هست برابر هست یا خیر. اگر هیج کدام از شرط ها برقرار نبود، کد های بعد از default اجرا میشن. استفاده از شرط default اجباری نیست.\npackage main import \"fmt\" func main() { switch ch := \"b\"; ch { case \"a\": fmt.Println(\"a\") case \"b\", \"c\": fmt.Println(\"b or c\") default: fmt.Println(\"No matching character\") } } ▶ اجرای کد کپی ✖ بستن خروجی در مثال بالا ما یک متغیر با نام ch رو به روش تعریف متغیر به روش کوتاه مقدار دهی کردم و همون متغیر را برای بررسی به switch دادیم. سپس با استفاده از کلید واژه case بررسی کردیم که آیا ch برابر است با اون مقادیری که ما تعریف کردیم یا خیر. اگر برابر بود کدهای درون اون case اجرا خواهند شد و اگر برابر نبود ما با استفاده از کلید واژه default مقدار پیش‌فرضی را در خروجی چاپ می‌کنیم.\n1.11.8 fallthrough # اگر در آخر یک case از این keyword استفاده شود، case بعدی بدون هیچ شرطی اجرا می‌شود. نکته ای که حتی بسیاری از منابع انگلیسی هم به صورت واضح اشاره نکرده اند، این است وقتی از fallthrough استفاده می کنیم، کیس بعد از آن بدون بررسی اجرا می شود حتی اگر شرطش برقرار نباشد. در ادامه اول یک مثال صحیح از استفاده ی fallthrough و سپس یک مثال اشتباه می زنیم.\npackage main import \"fmt\" func main() { var dayOfWeek int fmt.Printf(\"Enter a day of week: \") fmt.Scanln(\u0026dayOfWeek) switch dayOfWeek { case 1: fmt.Println(\"Monday\") fallthrough case 2: fmt.Println(\"Tuesday\") fallthrough case 3: fmt.Println(\"Wednesday\") fallthrough case 4: fmt.Println(\"Thursday\") fallthrough case 5: fmt.Println(\"Friday\") fallthrough case 6: fmt.Println(\"Saturday\") fallthrough case 7: fmt.Println(\"Sunday\") default: fmt.Println(\"Invalid Day\") } } ▶ اجرای کد کپی ✖ بستن خروجی در این مثال از کاربر یک روز هفته را می گیریم، سپس اسم آن روز به علاوه ی اسم تعداد روز های باقی مانده از هفته را چاپ می کنیم. با استفاده از fallthrough به سادگی می توان اینکار را انجام داد.\nخروجی کد ما اگر روز سوم هفته را وارد کنیم به این صورت است:\nEnter a day of week: 3 Wednesday Thursday Friday Saturday Sunday اما اگر از fallthrough به‌صورت اشتباه استفاده کنیم، کد ما ازنظر منطقی با مشکل مواجه می شود. به مثال زیر دقت کنید:\npackage main import ( \"fmt\" \"strings\" ) func main() { var notificationType string = \"sms,email\" switch { case strings.Contains(notificationType, \"sms\"): fmt.Println(\"Sent sms\") fallthrough case strings.Contains(notificationType, \"email\"): fmt.Println(\"Sent email\") fallthrough case strings.Contains(notificationType, \"push\"): fmt.Println(\"Sent push\") default: fmt.Println(\"Unknown\") } } ▶ اجرای کد کپی ✖ بستن خروجی در این مثال، برنامه نویس اینگونه در نظر گرفته است که fallthrough روشی است تا بتواند در صورت درست بودن یک شرط، سراغ شرط بعدی برود و آن را هم چک کند. اما fallthrough بدون اینکه شرط کیس بعدی را چک کند. آن را اجرا می کند. در این مثال با اینکه مشخص کردیم فقط sms و email شود، push هم می کند.\nSent sms Sent email Sent push 1.11.9 Switch خودآزمون # تفاوت ساختار و خروجی چهار فرمت مشابه زیر را بررسی کنید:\nحالت اول switch f(); { case true: println(1) case false: println(0) } حالت دوم switch f() { case true: println(1) case false: println(0) } حالت سوم switch f() { case true: println(1) case false: println(0) } حالت چهارم switch f(); true { case true: println(1) case false: println(0) } کدها در زمان اجرا یا پیش از آن، در برخی IDE یا Code Editor(ها) فرمت می‌شوند. هدف این خودآزمون دقت به ساختار ابزار switch است. "},{"id":19,"href":"/chapter-1/go-package/","title":"1.12 اضافه کردن پکیج در کد (package)","section":"فصل اول: آشنایی با مفاهیم گو","content":"زبان برنامه‌نویسی گو به شکلی طراحی شده است تا بتوانیم شیو‌ه‌های خوب مهندسی نرم‌افزار را به سادگی پیاده‌سازی کنیم. یکی از الگوهای مهم برای ارتقای کیفیت یک نرم افزار استفاده از DRY principle است. کلمه DRY مخفف Don’t Repeat Yourself همون چرخ رو دوباره اختراع نکن خودمون است, که اگر به صورت خیلی ساده بیانش کنیم یعنی، کدی که خواهید نوشت را دوبار تکرار نکنید. تا جایی که امکان دارد باید بتوانید از کدهای قبلی که نوشته اید استفاده کنید. پکیج‌ها امکاناتی از جمله:\nقابلیت استفاده مجدد از کد را به ما میدهند. امکان ماژولار، و قابل نگهداری بودن کد را فراهم می‌کنند. امکان مدیریت بهتر فایل‌ها را در یک واحد ایجاد می‌کنند. 1.12.1 پکیج‌ها در زبان گو # پکیج در اصل یک یا مجموعه‌ای از سورس فایل‌های شما است که ممکن است داخل یک فولدر قرار بگیرد. هر سورس فایلی که در زبان گو دارید متعلق به یک پکیج است. برای تعریف یک پکیج از دستور زیر استفاده می‌کنیم:\npackage \u0026lt;packagename\u0026gt; برای تعریف پکیج باید در اولین خط فایل، آن را با کلید واژه package تعریف کنید. داخل این پکیج شما می‌توانید کد‌هایی که لازم دارید را بنویسید و تصمیم بگیرید کدام متغییر، فانکشن یا تایپ باید به صورت عمومی باشد و یا باید به صورت خصوصی فقط داخل پکیج مورد استفاده قرار بگیرد.\nقطعا می‌دانیم بعد از نوشتن پکیج اگر بخواهیم از آن پکیج داخل پکیج‌های دیگر استفاده کنیم باید از کلید واژه import استفاده کنیم.\n1.12.2 اضافه کردن پکیج # برای اضافه کردن پکیج‌های مختلف ما از کلید واژه import استفاده می‌کنیم.\nimport \u0026quot;fmt\u0026quot; برای مثال, در کد بالا ما از پکیج fmt که در کتابخانه استاندارد گو وجود دارد استفاده کردیم. این به این معنی است همراه با تعریف کلمه fmt میتوانیم از توابعی که داخل این پکیج نوشته شده است استفاده کنیم. در مثال زیر ما از تابع Println برای چاپ مقدارHello GoFarsi!‍ استفاده کردیم.\npackage main import \"fmt\" func main() { fmt.Println(\"Hello GoFarsi!\") } ▶ اجرای کد کپی ✖ بستن خروجی تعریف کردن توابع به این شکل مزایای زیادی دارد از جمله:\nاگر اسم‌های مشابهی داشته باشید، داخل پکیج‌های مختلف می‌توانید از آن‌ها استفاده کنید، همچنین خوانایی برنامه افزایش پیدا می‌کند و باعث می‌شود از نام‌های طولانی استفاده نکنیم. مجموعه کدهایی که مربوط به هم هستن را در یک پکیج می‌توانیم قرار دهیم, که باعث می‌شود پیدا کردن و استفاده مجدد از کد را برای ما راحت‌تر کند. فرایند تغییر و کامپایل را می‌تواند به حداقل برساند. 1.12.2.1 اضافه کردن چندین پکیج # ما می‌توانیم برای اضافه کردن هر پکیج از کلید واژه import به شکل زیر استفاده کنیم:\nimport \u0026quot;fmt\u0026quot; import \u0026quot;time\u0026quot; import \u0026quot;math\u0026quot; import \u0026quot;math/rand\u0026quot; اما با تشکر از زبان گو, ما می‌توانیم چندین پکیج رو به صورت زیر و فقط با یک بار نوشتن کلید واژه import فراخوانی کنیم:\nimport ( \u0026quot;fmt\u0026quot; \u0026quot;time\u0026quot; \u0026quot;math\u0026quot; \u0026quot;math/rand\u0026quot; ) یعنی یک بار از کلید واژه import استفاده کنیم و بعد اسم پکیج‌ها را به ترتیب داخل آن بنویسیم.\nهمینطور ما می‌توانیم به پکیج هایی که import کردیم یک alias هم بدیم، یعنی همون اسم مستعار, به مثال زیر توجه کنید:\nimport ( format \u0026quot;fmt\u0026quot; ) و مانند مثال زیر از آن ها استفاده کنیم:‌\npackage main import format \"fmt\" func main() { format.Println(\"Hello from Gofarsi\") } ▶ اجرای کد کپی ✖ بستن خروجی 1.12.3 اسم‌های عمومی و خصوصی (Export و Unexport) # همه توابع، متغیر‌ها، ثابت ها و تایپ‌هایی که با حروف کوچک شروع می‌شوند، فقط در همان پکیج قابل دسترس هستند. برای عمومی کردن آنها، حرف اول آنها را به صورت Capital می‌نویسیم. برای مثال به کد زیر نگاه کنید:\npackage main import \"encoding/json\" type jSON struct { Name string `json:\"name\"` } func main() { var data []byte json.Unmarshal(data, \u0026jSON{}) } ▶ اجرای کد کپی ✖ بستن خروجی چون پکیج json نیاز داره تا فیلد Name رو تغییر بده پس در نتیجه در کد بالا حتما باید این فیلد رو با حرف بزرگ می‌نوشتیم.\n1.12.4 اضافه کردن پکیج‌های 3rd party # فرض کنید می‌خواهیم از پکیج Gin (github.com) استفاده کنیم، برای اضافه کردن این پکیج ما ‌می‌توانیم به دو شکل زیر آن را اضافه کنیم.\nداخل پروژه خود از دستور زیر استفاده کنید:\n$ go get -u github.com/gin-gonic/gin بعدا می‌توانید وارد پروژه خود شوید و با کلید واژه import از آن استفاده کنید. به مثال زیر نگاه کنید:\npackage main import ( \"net/http\" \"github.com/gin-gonic/gin\" ) func main() { r := gin.Default() r.GET(\"/ping\", func(c *gin.Context) { c.JSON(http.StatusOK, gin.H{ \"message\": \"pong\", }) }) r.Run() // listen and serve on 0.0.0.0:8080 (for windows \"localhost:8080\") } ▶ اجرای کد کپی ✖ بستن خروجی حالت دیگر استفاده از go mod tidy است, به این شکل که ما از دستور go get استفاده نمی‌کنیم و به صورت مستقیم داخل پروژه آدرس gin را import می‌کنیم.\nو همان ابتدا داخل کد یک فانکشن را از همان پکیج فراخوانی می‌کنیم (اینکار لازم است چون همانطور که می‌دانید خود go tool وقتی بداند شما پکیجی را تعریف کردید و استفاده نکردید آن را خودکار پاک می‌کند. البته که کد ادیتورهای معروف هم مانند goland,vsCode و \u0026hellip;، همین کارو رو در حین نوشتن کد برای شما انجام می‌دهند.)\nسپس از دستور زیر استفاده میکنیم:\n$ go mod tidy این دستور کل کدهای شما را بررسی می‌کند و اگر ببینید پکیجی تعریف شده است و شما آن را ندارید سعی میکند آن پکیج را برای شما دانلود و به پروژه شما اضافه کند.\n"},{"id":20,"href":"/chapter-1/go-defer-panic-recovery/","title":"1.13 defer, panic, recovery","section":"فصل اول: آشنایی با مفاهیم گو","content":" 1.13.1 تعویق (defer) # کلمه کلیدی defer یکی از کاربردی‌ترین امکانات زبان گو را برای ما فراهم می‌سازد. شما می‌توانید اجرای یک تابع را به تعویق بندازید‍‍. عموماً defer برای توابعی کاربرد دارد که قصد پاک‌سازی یا بستن عملیات‌های صورت گرفته را دارند، نظیر توابع Close در برخی از جاها.\nبه مثال زیر توجه کنید:\npackage main import ( \"fmt\" ) func main() { defer fmt.Println(\"world\") fmt.Println(\"hello\") } ▶ اجرای کد کپی ✖ بستن خروجی 1.13.1.1 تعویق (defer) در توابع (Anonymous) # شما خیلی ساده می‌توانید با استفاده از توابع Anonymous توابع بینام یا گمنام :) اجرای قسمتی از برنامه خودتان را به تعویق بندازید. به مثال زیر توجه کنید:\npackage main import \"fmt\" func main() { defer func() { fmt.Println(\"In inline defer\") }() fmt.Println(\"Executed\") } ▶ اجرای کد کپی ✖ بستن خروجی به این نکته توجه کنید که defer قبل از return صدا زده می‌شود. یعنی قبل از اینکه تابع شما خروجی را برگشت بدهد اگه تابع خروجی داشته باشه defer اجرا خواهد شد.\n1.13.1.2 تعویق (defer) چندین تابع درون یک تابع # در کد زیر, ما داخل یک تابع چند تابع را با استفاده از (defer) به تعویق انداختیم. به مثال زیر توجه کنید:\npackage main import \"fmt\" func main() { i := 0 i = 1 defer fmt.Println(i) i = 2 defer fmt.Println(i) i = 3 defer fmt.Println(i) } ▶ اجرای کد کپی ✖ بستن خروجی دقت داشته باشید که مقداردهی پارامترهای ورودی، برای تابعی که آن را defer کردیم در همان لحظه call شدن آن انجام می‌شود. به مثال زیر توجه کنید:\npackage main import \"fmt\" func main() { i:=1 defer fmt.Println(i) i++ fmt.Println(i) fmt.Println(\"First\") } ▶ اجرای کد کپی ✖ بستن خروجی در این مرحله شما باید پی برده باشید که defer در همان خطی که نوشته شده است صدا زده می‌شود، ولی اجرای آن دقیقاً به قبل از return در تابع موکول می‌شود.\n1.13.2 پنیک (panic) # در زبان گو panic همانند exception به معنای خروج از برنامه در شرایط غیر عادی است. panic در ۲ حالت زیر پیش می‌آید:\nخطاهای در زمان اجرای برنامه فراخوانی تابع panic توسط برنامه نویس در بخش های مختلف برنامه func panic(v interface{}) شما می‌توانید با استفاده از تابع داخلی فوق، panic ایجاد کنید و به عنوان ورودی دلیل panic را در قالب یک رشته به تابع ارسال کنید.\n1.13.2.1 خطای panic در زمان اجرا (runtime) # خطاهای panic در زمان اجرا به دلایل زیر می‌تواند رخ دهد:\nخطای Out of bounds/range array/slice فراخوانی متغیری که nil pointer باشد یعنی به هیچ آدرسی از حافظه memory اشاره نمی‌کند ارسال داده برروی کانال‌های بسته شده type assertion نادرست package main import \"fmt\" func main() { a := []string{\"a\", \"b\"} print(a, 2) } func print(a []string, index int) { fmt.Println(a[index]) } ▶ اجرای کد کپی ✖ بستن خروجی در تابع فوق ما یک تابع نوشتیم که به عنوان ورودی یک اسلایس از نوع رشته و یک ایندکس از نوع عدد از ما دریافت می‌کند و المنت ایندکسم‌ اون اسلایس را برای ما چاپ میکند در مثال بالا یعنی اندیس شماره 2. این کار ما باعث بروز یک panic میشود, فکر میکنید به چه دلیل ؟ بله به این دلیل که اسلایس ما اندیس شماره 2 ندارد و دلیل آن هم این است که اسلایس, لیست و \u0026hellip;. از 0 شروع می‌شوند.\nپنیک یک سری اطلاعات در مورد چرایی بوجود آمدنش به ما می‌دهد که در ادامه آن‌ها را توضیح دادیم:\nپنیک رخ داده شامل متن خطا محل رخ دادن panic در قالب stacktrace 1.13.2.2 خطای panic از قبل تعیین شده توسط برنامه‌نویس # همانطور که گفتیم شما می‌توانید هرجایی از بدنه توابع خود، تابع panic را فراخوانی کنید البته این روش پیشنهاد نمی‌شود و روش پیشنهادی استفاده از شیوه ارور هندلینگ خود گولنگ است و فقط در صورت لزوم بهتر است از پنیک استفاده شود. همینطور شما باید در داکیومنت برنامه ذکر کنید که کدام قسمت برنامه امکان پنیک را دارد تا دیگران بتوانند در صورت لزوم آن را recover کنند. recover را در ادمه توضیح خواهم داد. تا برنامه در آن محل خطایی را نمایش داده و متوقف شود.\npackage main import \"fmt\" func main() { a := []string{\"a\", \"b\"} checkAndPrint(a, 2) } func checkAndPrint(a []string, index int) { if index \u003e (len(a) - 1) { panic(\"Out of bound access for slice\") } fmt.Println(a[index]) } ▶ اجرای کد کپی ✖ بستن خروجی توجه کنید استفاده از تابع panic در برخی مواقع مفید می‌باشد. به عنوان مثال قصد دارید هنگام اجرای برنامه، یکسری تنظیمات از سمت کاربر دریافت کنید و در صورتی‌که تنظیمات دارای مشکل بودند، می‌توانید با استفاده panic جلوی ادامه روند برنامه را بگیرید تا کاربر خطا را رفع کند. 1.13.3 بازیابی (recovery) # برخی اوقات panic‌ها غیرقابل پیش‌ بینی می‌شوند. ممکن است برنامه شما بدون هیچ خطایی اجرا شود و به روند خود ادامه دهد، اما این هم ممکن است که به یک دلیل نامعلوم یا بهتر است بگوییم پیش بینی نشده، panic رخ دهد و برنامه شما کاملاً متوقف و باعث از دست دادن وضعیت استیبل برنامه شود.\nبه همین منظور در گولنگ یک تابع به نام recover وجود دارد که پس از رخ دادن panic در برنامه، این قابلیت را به ما می‌دهد تا بتوانیم برنامه را به وضعیت قبلی خود بازگردانیم تا بعداً خطای panic رخ داده را بررسی و رفع کنیم.\nfunc recover() interface{} همینطور که شما هم میبینید، تابع ریکاور هیچ ورودی نمی‌گیرد و یک خروجی از تایپ interface را برمی‌گرداند.\nبه مثالی که در مورد تابع recover زدیم نگاه کنید:\npackage main import \"fmt\" func main() { a := []string{\"a\", \"b\"} checkAndPrint(a, 2) fmt.Println(\"Exiting normally\") } func checkAndPrint(a []string, index int) { defer handleOutOfBounds() if index \u003e (len(a) - 1) { panic(\"Out of bound access for slice\") } fmt.Println(a[index]) } func handleOutOfBounds() { if r := recover(); r != nil { fmt.Println(\"Recovering from panic:\", r) } } ▶ اجرای کد کپی ✖ بستن خروجی در کد فوق ما یک تابع داریم که در این تابع یک المنت از یک اسلایس را چاپ می‌کند، اما اگر این اندیس خارج از تعداد المنت‌های اسلایس باشد یک خطای panic رخ می‌دهد. ما برای جلوگیری از خطای panic تابع handleOutOfBounds را با استفاده defer درون تابع checkAndPrint قرار دادیم که پس از رخ دادن panic بصورت خودکار بازیابی صورت بگیرد تا برنامه ما متوقف نشود.\n1.13.4 چاپ اطلاعات stacktrace پس از بازیابی # شما می‌توانید پس از اینکه بازیابی را انجام دادید، جزئیات بیشتری در خصوص خطای panic رخ داده بدست آوردید. به مثال زیر توجه کنید:\npackage main import ( \"fmt\" \"runtime/debug\" ) func main() { a := []string{\"a\", \"b\"} checkAndPrint(a, 2) fmt.Println(\"Exiting normally\") } func checkAndPrint(a []string, index int) { defer handleOutOfBounds() if index \u003e (len(a) - 1) { panic(\"Out of bound access for slice\") } fmt.Println(a[index]) } func handleOutOfBounds() { if r := recover(); r != nil { fmt.Println(\"Recovering from panic:\", r) fmt.Println(\"Stack Trace:\") debug.PrintStack() } } ▶ اجرای کد کپی ✖ بستن خروجی برای چاپ اطلاعات stacktrace همانطور که می‌بینید ما از پکیج runtime که در کتابخانه استاندارد گولنگ وجود دارد استفاده کردیم\nتوضیح کوتاه در خصوص stacktrace:\nدر برنامه نویسی مفهومی به اسم stack trace و یا stack backtrace مطرح است. بصورت خیلی مختصر کاری که انجام می دهد این است مسیر اجرای کد شمارا از نقطه شروع اجرای کد تا زمانی که به اتمام برسد در استک ذخیره میکند. برای مثال زمانی که با یک panic مواجه میشوید شما می توانید مسیری که برنامه از آن عبور کرده تا به panic خورده را مشاهده کنید که این کار با کمک stack trace انجام میشود.\n"},{"id":21,"href":"/chapter-1/go-builtins/","title":"1.14 لیست تایپ‌ها و توابع Builtin","section":"فصل اول: آشنایی با مفاهیم گو","content":"در مثال زیر لیست تایپ‌ها و توابع Builtin را با توضیحات قرار دادیم.\n// Copyright 2011 The Go Authors. All rights reserved. // Use of this source code is governed by a BSD-style // license that can be found in the LICENSE file. /* Package builtin provides documentation for Go's predeclared identifiers. The items documented here are not actually in package builtin but their descriptions here allow godoc to present documentation for the language's special identifiers. */ package builtin import \u0026quot;cmp\u0026quot; // bool is the set of boolean values, true and false. type bool bool // true and false are the two untyped boolean values. const ( true = 0 == 0 // Untyped bool. false = 0 != 0 // Untyped bool. ) // uint8 is the set of all unsigned 8-bit integers. // Range: 0 through 255. type uint8 uint8 // uint16 is the set of all unsigned 16-bit integers. // Range: 0 through 65535. type uint16 uint16 // uint32 is the set of all unsigned 32-bit integers. // Range: 0 through 4294967295. type uint32 uint32 // uint64 is the set of all unsigned 64-bit integers. // Range: 0 through 18446744073709551615. type uint64 uint64 // int8 is the set of all signed 8-bit integers. // Range: -128 through 127. type int8 int8 // int16 is the set of all signed 16-bit integers. // Range: -32768 through 32767. type int16 int16 // int32 is the set of all signed 32-bit integers. // Range: -2147483648 through 2147483647. type int32 int32 // int64 is the set of all signed 64-bit integers. // Range: -9223372036854775808 through 9223372036854775807. type int64 int64 // float32 is the set of all IEEE 754 32-bit floating-point numbers. type float32 float32 // float64 is the set of all IEEE 754 64-bit floating-point numbers. type float64 float64 // complex64 is the set of all complex numbers with float32 real and // imaginary parts. type complex64 complex64 // complex128 is the set of all complex numbers with float64 real and // imaginary parts. type complex128 complex128 // string is the set of all strings of 8-bit bytes, conventionally but not // necessarily representing UTF-8-encoded text. A string may be empty, but // not nil. Values of string type are immutable. type string string // int is a signed integer type that is at least 32 bits in size. It is a // distinct type, however, and not an alias for, say, int32. type int int // uint is an unsigned integer type that is at least 32 bits in size. It is a // distinct type, however, and not an alias for, say, uint32. type uint uint // uintptr is an integer type that is large enough to hold the bit pattern of // any pointer. type uintptr uintptr // byte is an alias for uint8 and is equivalent to uint8 in all ways. It is // used, by convention, to distinguish byte values from 8-bit unsigned // integer values. type byte = uint8 // rune is an alias for int32 and is equivalent to int32 in all ways. It is // used, by convention, to distinguish character values from integer values. type rune = int32 // any is an alias for interface{} and is equivalent to interface{} in all ways. type any = interface{} // comparable is an interface that is implemented by all comparable types // (booleans, numbers, strings, pointers, channels, arrays of comparable types, // structs whose fields are all comparable types). // The comparable interface may only be used as a type parameter constraint, // not as the type of a variable. type comparable interface{ comparable } // iota is a predeclared identifier representing the untyped integer ordinal // number of the current const specification in a (usually parenthesized) // const declaration. It is zero-indexed. const iota = 0 // Untyped int. // nil is a predeclared identifier representing the zero value for a // pointer, channel, func, interface, map, or slice type. var nil Type // Type must be a pointer, channel, func, interface, map, or slice type // Type is here for the purposes of documentation only. It is a stand-in // for any Go type, but represents the same type for any given function // invocation. type Type int // Type1 is here for the purposes of documentation only. It is a stand-in // for any Go type, but represents the same type for any given function // invocation. type Type1 int // IntegerType is here for the purposes of documentation only. It is a stand-in // for any integer type: int, uint, int8 etc. type IntegerType int // FloatType is here for the purposes of documentation only. It is a stand-in // for either float type: float32 or float64. type FloatType float32 // ComplexType is here for the purposes of documentation only. It is a // stand-in for either complex type: complex64 or complex128. type ComplexType complex64 // The append built-in function appends elements to the end of a slice. If // it has sufficient capacity, the destination is resliced to accommodate the // new elements. If it does not, a new underlying array will be allocated. // Append returns the updated slice. It is therefore necessary to store the // result of append, often in the variable holding the slice itself: // //\tslice = append(slice, elem1, elem2) //\tslice = append(slice, anotherSlice...) // // As a special case, it is legal to append a string to a byte slice, like this: // //\tslice = append([]byte(\u0026quot;hello \u0026quot;), \u0026quot;world\u0026quot;...) func append(slice []Type, elems ...Type) []Type // The copy built-in function copies elements from a source slice into a // destination slice. (As a special case, it also will copy bytes from a // string to a slice of bytes.) The source and destination may overlap. Copy // returns the number of elements copied, which will be the minimum of // len(src) and len(dst). func copy(dst, src []Type) int // The delete built-in function deletes the element with the specified key // (m[key]) from the map. If m is nil or there is no such element, delete // is a no-op. func delete(m map[Type]Type1, key Type) // The len built-in function returns the length of v, according to its type: // // - Array: the number of elements in v. // - Pointer to array: the number of elements in *v (even if v is nil). // - Slice, or map: the number of elements in v; if v is nil, len(v) is zero. // - String: the number of bytes in v. // - Channel: the number of elements queued (unread) in the channel buffer; // if v is nil, len(v) is zero. // // For some arguments, such as a string literal or a simple array expression, the // result can be a constant. See the Go language specification's \u0026quot;Length and // capacity\u0026quot; section for details. func len(v Type) int // The cap built-in function returns the capacity of v, according to its type: // // - Array: the number of elements in v (same as len(v)). // - Pointer to array: the number of elements in *v (same as len(v)). // - Slice: the maximum length the slice can reach when resliced; // if v is nil, cap(v) is zero. // - Channel: the channel buffer capacity, in units of elements; // if v is nil, cap(v) is zero. // // For some arguments, such as a simple array expression, the result can be a // constant. See the Go language specification's \u0026quot;Length and capacity\u0026quot; section for // details. func cap(v Type) int // The make built-in function allocates and initializes an object of type // slice, map, or chan (only). Like new, the first argument is a type, not a // value. Unlike new, make's return type is the same as the type of its // argument, not a pointer to it. The specification of the result depends on // the type: // // - Slice: The size specifies the length. The capacity of the slice is // equal to its length. A second integer argument may be provided to // specify a different capacity; it must be no smaller than the // length. For example, make([]int, 0, 10) allocates an underlying array // of size 10 and returns a slice of length 0 and capacity 10 that is // backed by this underlying array. // - Map: An empty map is allocated with enough space to hold the // specified number of elements. The size may be omitted, in which case // a small starting size is allocated. // - Channel: The channel's buffer is initialized with the specified // buffer capacity. If zero, or the size is omitted, the channel is // unbuffered. func make(t Type, size ...IntegerType) Type // The max built-in function returns the largest value of a fixed number of // arguments of [cmp.Ordered] types. There must be at least one argument. // If T is a floating-point type and any of the arguments are NaNs, // max will return NaN. func max[T cmp.Ordered](x T, y ...T) T // The min built-in function returns the smallest value of a fixed number of // arguments of [cmp.Ordered] types. There must be at least one argument. // If T is a floating-point type and any of the arguments are NaNs, // min will return NaN. func min[T cmp.Ordered](x T, y ...T) T // The new built-in function allocates memory. The first argument is a type, // not a value, and the value returned is a pointer to a newly // allocated zero value of that type. func new(Type) *Type // The complex built-in function constructs a complex value from two // floating-point values. The real and imaginary parts must be of the same // size, either float32 or float64 (or assignable to them), and the return // value will be the corresponding complex type (complex64 for float32, // complex128 for float64). func complex(r, i FloatType) ComplexType // The real built-in function returns the real part of the complex number c. // The return value will be floating point type corresponding to the type of c. func real(c ComplexType) FloatType // The imag built-in function returns the imaginary part of the complex // number c. The return value will be floating point type corresponding to // the type of c. func imag(c ComplexType) FloatType // The clear built-in function clears maps and slices. // For maps, clear deletes all entries, resulting in an empty map. // For slices, clear sets all elements up to the length of the slice // to the zero value of the respective element type. If the argument // type is a type parameter, the type parameter's type set must // contain only map or slice types, and clear performs the operation // implied by the type argument. If t is nil, clear is a no-op. func clear[T ~[]Type | ~map[Type]Type1](t T) // The close built-in function closes a channel, which must be either // bidirectional or send-only. It should be executed only by the sender, // never the receiver, and has the effect of shutting down the channel after // the last sent value is received. After the last value has been received // from a closed channel c, any receive from c will succeed without // blocking, returning the zero value for the channel element. The form // //\tx, ok := \u0026lt;-c // // will also set ok to false for a closed and empty channel. func close(c chan\u0026lt;- Type) // The panic built-in function stops normal execution of the current // goroutine. When a function F calls panic, normal execution of F stops // immediately. Any functions whose execution was deferred by F are run in // the usual way, and then F returns to its caller. To the caller G, the // invocation of F then behaves like a call to panic, terminating G's // execution and running any deferred functions. This continues until all // functions in the executing goroutine have stopped, in reverse order. At // that point, the program is terminated with a non-zero exit code. This // termination sequence is called panicking and can be controlled by the // built-in function recover. // // Starting in Go 1.21, calling panic with a nil interface value or an // untyped nil causes a run-time error (a different panic). // The GODEBUG setting panicnil=1 disables the run-time error. func panic(v any) // The recover built-in function allows a program to manage behavior of a // panicking goroutine. Executing a call to recover inside a deferred // function (but not any function called by it) stops the panicking sequence // by restoring normal execution and retrieves the error value passed to the // call of panic. If recover is called outside the deferred function it will // not stop a panicking sequence. In this case, or when the goroutine is not // panicking, recover returns nil. // // Prior to Go 1.21, recover would also return nil if panic is called with // a nil argument. See [panic] for details. func recover() any // The print built-in function formats its arguments in an // implementation-specific way and writes the result to standard error. // Print is useful for bootstrapping and debugging; it is not guaranteed // to stay in the language. func print(args ...Type) // The println built-in function formats its arguments in an // implementation-specific way and writes the result to standard error. // Spaces are always added between arguments and a newline is appended. // Println is useful for bootstrapping and debugging; it is not guaranteed // to stay in the language. func println(args ...Type) // The error built-in interface type is the conventional interface for // representing an error condition, with the nil value representing no error. type error interface { Error() string } "},{"id":22,"href":"/chapter-1/go-string-formatting/","title":"1.15 قالب بندی رشته‌ها","section":"فصل اول: آشنایی با مفاهیم گو","content":"در زبان گو مانند سایر زبان‌ها یکسری عناوین برای قالب‌بندی رشته وجود دارد که برخی از این عناوین مشترک بین همه زبان‌ها هست و برخی مختص زبان گو.\n1.15.1 قالب بندی با توابع Printf و Sprintf # زمانیکه شما از تابع Printf یا Sprintf استفاده می‌کنید می‌توانید رشته خروجی را با استفاده از پارامترهای بعد از رشته قالب‌بندی کنید، و در نهایت به‌صورت یک رشته نمایش دهید.\nfmt.Printf(\u0026quot;{{Verb}}\u0026quot;, value1, value2, value3, ..., valueN) fmt.Sprintf(\u0026quot;{{Verb}}\u0026quot;, value1, value2, value3, ..., valueN) توجه کنید هر دو تابع فوق خیلی کاربردی و پر استفاده هستند. این ۲ تابع کارکردشان مشترک است ولی خروجی متفاوتی دارند.\nبه عنوان مثال :\nشما با استفاده از Printf می‌توانید یک رشته را قالب‌بندی کنید و در نهایت به عنوان خروجی چاپ کنید. ولی با استفاده از Sprintf می‌توانید یک رشته را قالب‌بندی کنید و در نهایت به جای اینکه مقدار خروجی را چاپ کنید، اون رو داخل یک متغیر قرار بریزید. به مثال زیر توجه کنید: x := fmt.Sprintf(\u0026quot;age %s is %d years\u0026quot;, \u0026quot;Javad\u0026quot;, 30) 1.15.1.1 قالب‌بندی یک slice # Verb fmt.Printf(\u0026quot;{{Verb}}\u0026quot;, []int64{0, 1}) خروجی توضیحات %v [0 1] فرمت پیش‌فرض %#v []int64{0, 1} قالب‌بندی کد گو %T []int64 تایپ مقدار توجه کنید v% یکی از پرکاربرد‌ترین Verb‌ها در گولنگ است و مواقعی مورد استفاده قرار می‌گیرد که شما قصد دارید یک مقدار را داخل رشته بزارید، ولی از تایپ اون مقدار خبر ندارید. 1.15.1.2 قالب‌بندی اعداد صحیح # Verb fmt.Printf(\u0026quot;{{Verb}}\u0026quot;, 15) خروجی توضیحات %d 15 عدد پایه ۱۰ %+d +15 نمایش + در کنار عدد %4d ␣␣15 ۴ کارکتر با فاصله از راست %-4d 15␣␣ ۴ کارکتر با فاصله از چپ %04d 0015 نمایش عدد با پیشوند صفر %b 1111 عدد با پایه باینری %o 17 عدد با پایه ۸ اکتال %x f عدد با پایه ۱۶ هگز حروف کوچک %X F عدد با پایه ۱۶ هگز حروف بزرگ %#x 0xf عدد با پایه ۱۶ هگز به همراه 0x 1.15.1.3 قالب‌بندی اعداد اعشاری # Verb fmt.Printf(\u0026quot;{{Verb}}\u0026quot;, 123.456) خروجی توضیحات %e 1.234560e+02 نمایش بصورت نماد عملی %f 123.456000 نقطه اعشاری، بدون نما. دقت پیش فرض 6 است %.2f 123.46 عرض پیش فرض، دقت 2 رقم بعد از نقطه اعشار %8.2f ␣␣123.46 عرض 8 کاراکتر، دقت 2 رقم بعد از نقطه اعشار. کاراکتر پیش‌فرض padding space است %08.2f 00123.46 عرض 8 کاراکتر، دقت 2 رقم بعد از نقطه اعشار. لایه سمت چپ با نویسه مشخص شده (اینجا، 0) %g 123.456 نما در صورت نیاز، فقط ارقام ضروری 1.15.1.4 قالب‌بندی کارکترها # Verb fmt.Printf(\u0026quot;{{Verb}}\u0026quot;, 'A') خروجی توضیحات %c A کارکتر %q \u0026quot;A\u0026quot; کارکتر به همراه دابل کوتیشن %U U+0041 یونیکد %#U U+0041 'A' یونیکد به همراه کارکتر 1.15.1.5 قالب‌بندی رشته (string) و slice بایت # Verb fmt.Printf(\u0026quot;{{Verb}}\u0026quot;, \u0026quot;gophers\u0026quot;) خروجی توضیحات %s gophers رشته ساده %8s ␣␣gophers با ۸ پدینگ راست چین شده %-8s gophers␣␣ با ۸ پدینگ چپ چین شده %q \u0026quot;gophers\u0026quot; رشته به همراه دابل کوتیشن %x 676f7068657273 خروجی هگز مقدار % x 67 6f 70 68 65 72 73 خروجی هگز مقدار با فاصله 1.15.1.6 قالب‌بندی بولین # Verb fmt.Printf(\u0026quot;{{Verb}}\u0026quot;, true) خروجی توضیحات %t true نمایش مقدار بولین در رشته 1.15.1.6 قالب‌بندی اشاره‌گر (pointer) # Verb fmt.Printf(\u0026quot;{{Verb}}\u0026quot;, new(int)) خروجی توضیحات %p 0xc0000b2000 نمایش آدرس حافظه با پایه ۱۶ به همراه 0x 1.15.2 مقادیر خاص در رشته # همانطور که گفتیم زبان گو یکسری کارکترهای خاص دارد که باعث تغییراتی در خروجی رشته خواهد شد و این کارکترهای خاص بین همه زبان‌ها مشترک هستند. در ادامه لیست این کاراکتر‌ها را آورده‌ایم:\nVerb توضیحات \\a U+0007 هشدار یا زنگ \\b U+0008 بک اسپیس backspace \\\\ U+005c بک اسلش backslash \\t U+0009 تب بصورت افقی \\n U+000A خط جدید \\f U+000C حالت فرم \\r U+000D حالت برگشت \\v U+000b تب بصورت عمودی %% نمایش درصد برای حالت‌های خاص نظیر fmt.Printf(\u0026quot;%05.2f%%\u0026quot;, math.Pi) 1.15.3 پکیج strings و متد های پر کاربرد آن # برای کار با رشته ها، یکی از پکیج های پرکاربرد strings است که به‌صورت built-in در گولنگ وجود دارد. در این قسمت با برخی از متد های این پکیج آشنا می شویم.\n1.15.3.1 متد Contains و ContainsAny # با استفاده از این دو متد می توانید چک کنید که در رشته مدنظر شما، آن چیزی که می خواهید وجود دارد یا نه. فرق بین Contains و ContainsAny در این است که Contains باید دقیقا همان الگویی که داده اید داخل رشته پیدا شود اما ContainsAny حتی اگر یکی از کاراکتر ها وجود داشته باشد true بر میگرداند.\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;strings\u0026quot; ) func main() { text := \u0026quot;Go will make you love programming again. We promise\u0026quot; fmt.Println(strings.Contains(text, \u0026quot;Golang\u0026quot;)) fmt.Println(strings.ContainsAny(text, \u0026quot;Golang\u0026quot;)) } پس از اجرای کد. خروجی زیر را مشاهده می کنید.\n$ go run main.go Result: false true 1.15.3.2 متد Count # با استفاده از این متد، می توانید تعداد تکرار یک الگو را بدست بیاورید. Count نسبت به بزرگ و کوچک بودن کلمات حساس است.\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;strings\u0026quot; ) func main() { text := \u0026quot;Golang go Go will make you love programming again. We promise\u0026quot; fmt.Println(strings.Count(text, \u0026quot;Go\u0026quot;)) } پس از اجرای کد. خروجی زیر را مشاهده می کنید.\n$ go run main.go Result: 2 1.15.3.3 متد Index و LastIndex # با استفاده از متد های Index می توانیم اندیس قرارگرفتن کاراکتر مدنظر را پیدا کنیم. فرق بین Index و LastIndex این است که متد Index اولین کاراکتری که پیدا می کند اندیسش را برمیگرداند، اما LastIndex آخرین کاراکتری که پیدا می کند.\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;strings\u0026quot; ) func main() { text := \u0026quot;Go will make you love programming again. We promise\u0026quot; fmt.Println(strings.Index(text, \u0026quot;o\u0026quot;)) fmt.Println(strings.LastIndex(text, \u0026quot;o\u0026quot;)) } پس از اجرای کد. خروجی زیر را مشاهده می کنید.\n$ go run main.go Result: 1 46 1.15.3.4 متد Split # با استفاده از متد Split می توانیم یک رشته را بر اساس یک الگویی(برای مثال space) تکه تکه کنیم. خروجی این متد یک slice از جنس string است.\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;strings\u0026quot; ) func main() { text := \u0026quot;Go will make you love programming again. We promise\u0026quot; textSlice := strings.Split(text, \u0026quot; \u0026quot;) for _, item := range textSlice { fmt.Println(item) } } پس از اجرای کد. خروجی زیر را مشاهده می کنید.\n$ go run main.go Result: Go will make you love programming again. We promise 1.15.3.5 متد Join # با Join می توانیم المنت های یک اسلایس از جنس string را با یک الگویی به یکدیگر بچسبانیم و در خروجی یک string از المنت های داخل اسلایس بدست بیاوریم. در این مثال text قبلی را که با Split تکه تکه کردیم و داخل textSlice ریختیم، با Join تبدیل به text می کنیم.\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;strings\u0026quot; ) func main() { // array of strings textSlice := []string{\u0026quot;Go\u0026quot;, \u0026quot;will\u0026quot;, \u0026quot;make\u0026quot;, \u0026quot;you\u0026quot;, \u0026quot;love\u0026quot;, \u0026quot;programming\u0026quot;, \u0026quot;again.\u0026quot;, \u0026quot;We\u0026quot;, \u0026quot;promise\u0026quot;} // joining the string by separator fmt.Println(strings.Join(textSlice, \u0026quot; \u0026quot;)) } پس از اجرای کد. خروجی زیر را مشاهده می کنید.\n$ go run main.go Result: Go will make you love programming again. We promise 1.15.3.6 متد HasPrefix و HasSuffix # با استفاده از HasPrefix می توانیم چک کنیم که اول رشته با چیزی که ما می خواهیم شروع شده است یا خیر. با HasSuffix می توانیم چک کنیم که اتمام رشته با آن چیزی که ما می خواهیم هست یا خیر.\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;strings\u0026quot; ) func main() { text := \u0026quot;Go will make you love programming again. We promise\u0026quot; fmt.Println(\u0026quot;HasPrefix Go:\u0026quot;, strings.HasPrefix(text, \u0026quot;Go\u0026quot;)) fmt.Println(\u0026quot;HasPrefix se:\u0026quot;, strings.HasPrefix(text, \u0026quot;se\u0026quot;)) fmt.Println(\u0026quot;HasSuffix se:\u0026quot;, strings.HasSuffix(text, \u0026quot;se\u0026quot;)) fmt.Println(\u0026quot;HasSuffix Go:\u0026quot;, strings.HasSuffix(text, \u0026quot;Go\u0026quot;)) } پس از اجرای کد. خروجی زیر را مشاهده می کنید.\n$ go run main.go Result: HasPrefix Go: true HasPrefix se: false HasSuffix se: true HasSuffix Go: false متد های پرکاربرد دیگری مانند Replace, ReplaceAll برای جاگزین کردن. متد های Compare و EqualFold برای مقایسه بین دو رشته. متد های Trim, TrimLeft, TrimRight برای حذف کردن کاراکتر های اضافی از اول و آخر رشته و \u0026hellip; نیز وجود دارند که پیشنهاد می کنم حتما مطالعه کنید.\n"},{"id":23,"href":"/chapter-2/","title":"فصل دوم: مکانیزم‌های زبان","section":"صفحه اصلی","content":"در این فصل به مکانیزیم‌های زبان گو می‌پردازیم و برخی از اصطلاحات زبان گو را با هم برسی می‌کنیم.\nدر بخش 2.1 در خصوص اشاره‌گر آموزش خواهیم داد. در بخش 2.2 به مهم‌ترین تایپ در زبان گو، یعنی ساختار می‌پردازیم و آموزش می‌دهیم چطور با استفاده از ساختار دیتامدل‌های پروژه‌های خود را پیاده سازی کنید. در بخش 2.3 به بحث متدها می‌پردازیم و برسی می‌کنیم که چطور این نوع توابع را پیاده سازی کنیم. در بخش 2.4 در خصوص اینترفیس در زبان گو توضیح می‌دهیم. دقیقا چی هستند و چطور میشه ازشون استفاده کرد. در بخش 2.5 به جاسازی ساختار و اینترفیس می‌پردازیم. در بخش 2.6 به مدیریت خطاها در زبان گو می‌پردازیم و برسی می‌کنیم که چه ویژگی‌هایی دارد. 2.7 تفاوت castin با conversion را آموزش می‌دهیم. "},{"id":24,"href":"/chapter-2/pointer/","title":"2.1 اشاره‌گر (Pointer)","section":"فصل دوم: مکانیزم‌های زبان","content":"اشاره‌گر در واقع متغیری است که، آدرس حافظه یک مقدار را نگه می‌دارد.\nvar ex *T درک اشاره‌گرها (Pointers) برای بسیاری از مبتدیان ترسناک به نظر می‌رسد، اما در واقع اگر با یک مثال ساده آن را توضیح دهیم، می‌تواند بسیار قابل فهم باشد. اجازه بدهید ترجمه و توضیحی روان بر پایه مثالی که دادی ارائه کنم:\nاشاره‌گرها پیچیده به نظر می‌رسند، اما واقعاً نیازی نیست که این‌طور باشند. اشاره‌گرها را می‌توان شبیه \u0026ldquo;فهرست مطالب یک کتاب\u0026rdquo; در نظر گرفت. برای مثال، همین کتاب را در نظر بگیر. فهرست مطالب این کتاب مثل پنج اشاره‌گر است. شما می‌توانید آن‌ها را بخوانید و بفهمید که اطلاعات مربوط به هر فصل در کجا قرار دارد. مثلاً فصل «زندگی من» در صفحه ۱ است (یعنی به صفحه ۱ اشاره می‌کند). و فصل «شغل من» در صفحه ۲۳ است.\nدر بین برنامه نویسان زبان Go همیشه این مسئله بوده که کی و کجا باید از Pointer استفاده کنیم؟!\nدیدگاه من نسبت به Pointer :\nزمانی باید از Pointer استفاده کنید که قصد دارید یک متغیری را در scope ها و توابع مختلف مقدار دهی کنید در اینجا بهتر است از Pointer استفاده کنیم تا جلو کپی شدن متغیر در خانه های مختلف حافظه گرفته شود.\nساده تر بهش بخواهیم نگاه کنیم وقتی حس کردی میخوای یک متغیر را در چند جای مختلف خارج از اونجایی که تعریف شده مقدار دهی کنی بهتر است آن متغیر را بصورت Pointer برای مقدار دهی پاس دهید.\nحتی این قضیه برای اینکه method تعریف کنیم صدق میکنه که چرا باید متد با Pointer یا بدون Pointer تعریف کنیم.\nنکته مهم 1: استفاده از Pointer باید با دقت انجام شود تا از مشکلاتی مانند دسترسی همزمان به متغیرها و اشتباهات مرتبط با حافظه جلوگیری شود.\nنکته مهم 2: استفاده از Pointer خیلی خوب و مفید است اما در جای درست چون اگر نتوانیم تشخیص دهیم کی و کجا استفاده کنیم به مرور باعث کاهش عملکرد برنامه خواهد شد.\nدر مثال بالا ما شیوه تعریف یک متغیر اشاره‌گر را توضیح دادیم. اول کلید واژه ی var بعد اسم متغیر و در آخر هم *T یعنی تایپ متغیر. به مثال زیر توجه کنید:\nvar ptr *string در تعریف اشاره‌گر ‌ها, ما ۲ تا اپراتور داریم که کارکرد هر کدام از این اپراتورها رو در ادامه توضیح میدم:\n\u0026amp; بهش میگن ampersand با استفاده از این می‌توانیم آدرس حافظه متغیر فرضا x را به متغیر دیگری بدهیم (y := \u0026amp;x) * بهش میگن asterisk با استفاده از این می‌توانیم به مقدار داخل حافظه متغیر فرضا x دسترسی پیدا کنیم (x*) برای اینکه یک اشاره گر تعریف کنیم ۲ روش وجود دارد:\nاستفاده از تابع new استفاده از اپراتور \u0026amp; (آمپرسند) مثال 1 # فرض کنید شما 1 متغیر دارید و قصد دارید داخل 3 تابع مختلف مقدارش را بروز کنید و با یک تابع دیگر نمایش دهید:\npackage main import \"fmt\" func main() { var count int addCount(\u0026count) addCount(\u0026count) addCountWithoutPointer(count) fmt.Printf(\"value = %d, address in memory = %p\\n\", count, \u0026count) printCount(count) } func addCount(x *int) { *x++ fmt.Printf(\"value = %d, address in memory = %p\\n\", *x, x) } func addCountWithoutPointer(x int) { x++ fmt.Printf(\"value = %d, address in memory = %p\\n\", x, \u0026x) } func printCount(x int) { fmt.Printf(\"value = %d, address in memory = %p\\n\", x, \u0026x) } ▶ اجرای کد کپی ✖ بستن خروجی در کد فوق ما یک متغیر به نام count ساختیم که داخل تابع (scope) main می باشد.\nرخداد اول: حال این متغیر را 2 بار بصورت Pointer به تابع addCount پاس دادیم و داخل همان تابع مقدار دهیش کردیم و پس از مقدار دهی در همان تابع print ش کردیم. اتفاقی که افتاد مقدار متغیر در همان خانه حافظه که 0xc0000a6068 هست مقدار دهی شد و عملا بخشی دیگر از حافظه گرفته نشد.\nرخداد دوم: متغیر را بدون Pointer به تابع addCountWithoutPointer پاس دادیم و در همان تابع مقدار دهید و print کردیم, اتفاقی که افتاد ما متغیر را اینبار بدون Pointer پاس دادیم یعنی عملا یک کپی از متغیر را به تابع addCountWithoutPointer فرستادیم و اگر به آدرس حافظه مقدار دقت کنید 0xc0000a6088 عملا یک خانه جدید به این کپی تخصیص داده شد و مقدارش در همان خانه بروز شده و اون متغیر x تنها در همان تابع زنده اس و در صورتیکه اگر x را از تابع بازگشت دهید دوباره یک کپی از آن به بیرون منتقل می شود.\nمثال 2 # فرض کنید یک تایپ count دارید که نام مستعار تایپ int می باشد و 3 تا متد (متد را در بخش 2.3 می توانید بخوانید) گیرنده Pointer با نام های increase , decrease و print دارند.\npackage main import \"fmt\" type count int func main() { x := new(count) x.increase() x.increase() x.decrease() x.increase() x.printWithoutPointer() } func (c *count) increase() { *c++ c.print() } func (c *count) decrease() { *c-- c.print() } func (c *count) print() { fmt.Printf(\"value = %d, address in memory = %p\\n\", *c, c) } func (c count) printWithoutPointer() { fmt.Printf(\"value = %d, address in memory = %p\\n\", c, \u0026c) } ▶ اجرای کد کپی ✖ بستن خروجی ما در مثال فوق با استفاده از تابع new اومدیم متغیر x را ایجاد کردیم سپس متد increase برای افزایش مقدار متغیر x و متد decrease را برای کاهش مقدار x و در نهایت print را برای چاپ استفاده کردیم.\nدر اینجا به دلیل گیرنده Pointer بودن تایپ count توانستیم درهمان خانه حافظه مقدار x را افزایش یا کاهش دهیم و در نهایت با استفاده از متد print اومدیم مقدار و خانه حافظه را چاپ کردیم.\nاما یک متد printWithoutPointer داریم که یک کپی از مقدار x را چاپ میکند و عملا مقدار را از یک خانه حافظه جدید را به نمایش میگذارد.\nمتد printWithoutPointer بدون Pointer می باشد و زمانیکه سایر متدهایتان با یا بدون Pointer هست بهتر است متدهای جدیدتان با Pointer باشد تا جلو سردرگمی گرفته شود. طبق داکیومنت های ارائه شده برای Go چندان لزومی ندارد چنین ترکیبی انجام دهید. 2.1.1 استفاده از تابع new # یک اشاره‌گر با استفاده از تابع new بصورت مثال زیر تعریف شده است:\na := new(int) *a = 10 fmt.Println(*a) //Output will be 10 در مثال بالا ما متغیر a را از نوع int اشاره‌گر pointer a تعریف کردیم و سپس داخل آدرس حافظه a مقدار ۱۰ را قرار دادیم.\nتوجه کنید مقدار پیش‌فرض یک متغیر از نوع اشاره‌گر nil است. اگر جایی شما متغیر از نوع اشاره‌گر را بصورت nil بفرستید ممکن است به panic از نوع nil pointer بر بخورید و اجرای برنامه شما کاملا متوقف شود. 2.1.2 استفاده از اپراتور \u0026lsquo;\u0026amp;\u0026rsquo; # برای دریافت آدرس حافظه یک متغیر از \u0026amp; می‌توان استفاده کرد:\na := 2 b := \u0026amp;a fmt.Println(*b) //Output will be 2 به مثال زیر توجه کنید:\npackage main import \"fmt\" func main() { var b *int a := 2 b = \u0026a fmt.Println(b) fmt.Println(*b) b = new(int) *b = 10 fmt.Println(*b) } ▶ اجرای کد کپی ✖ بستن خروجی در خروجی بالا 0xc0000b0018 آدرس حافظه متغیر a است. در واقع متغیر a ساخته شد و ما آدرس حافظه آن را به متغیر b دادیم. یعنی هر دو متغیر به یک آدرس از حافظه اشاره می‌کنند.\n2.1.3 اپراتور * اشاره‌گر # ما می‌توانیم اپراتور * را برای عملیات‌های زیر به کار ببریم:\nگرفتن مقدار یک آدرس حافظه که با استفاده از اشاره‌گر ذخیره شده است. تغییر مقدار یک آدرس حافظه. به مثال زیر توجه کنید: # package main import \"fmt\" func main() { a := 2 b := \u0026a fmt.Println(a) fmt.Println(*b) *b = 3 fmt.Println(a) fmt.Println(*b) a = 4 fmt.Println(a) fmt.Println(*b) } ▶ اجرای کد کپی ✖ بستن خروجی در مثال بالا a و b* هر دو دارند به یک آدرس از حافظه اشاره می‌کنند. بنابرین تغییر مقدار یکی از آن‌ها، روی هر دو متغیر تاثیر می‌گذارد.\n2.1.4 اشاره‌گر به یک اشاره‌گر (Double Pointers) # شما می‌‌توانید یک متغیر اشاره‌گر تعریف کنید و متغیر اشاره‌گر دیگری را بهش اختصاص دهید.\na := 2 b := \u0026amp;a c := \u0026amp;b همانطور که در مثال و عکس بالا می‌بینید، متغیر a مقدارش ۲ و آدرسش در حافظه 0xXXXXXX است. در مقدار متغیر b ما اشاره کردیم به آدرس حافظه متغیر a و در ادامه در متغیر c به آدرس حافظه متغیر b اشاره کردیم.\nزمانیکه شما بخواهید مقدار c را چاپ کنید کافیست از c** استفاده کنید تا مقدار ۲ را چاپ کند.\nبه مثال زیر توجه کنید:\npackage main import \"fmt\" func main() { a := 2 b := \u0026a c := \u0026b fmt.Printf(\"a: %d\\n\", a) fmt.Printf(\"b: %x\\n\", b) fmt.Printf(\"c: %x\\n\", c) fmt.Println() fmt.Printf(\"a: %d\\n\", a) fmt.Printf(\"*\u0026a: %d\\n\", *\u0026a) fmt.Printf(\"*b: %d\\n\", *b) fmt.Printf(\"**c: %d\\n\", **c) fmt.Println() fmt.Printf(\"\u0026a: %d\\n\", \u0026a) fmt.Printf(\"b: %d\\n\", b) fmt.Printf(\"\u0026*b: %d\\n\", \u0026*b) fmt.Printf(\"*\u0026b: %d\\n\", *\u0026b) fmt.Printf(\"*c: %d\\n\", *c) fmt.Println() fmt.Printf(\"\u0026b: %d\\n\", \u0026b) fmt.Printf(\"c: %d\\n\", c) fmt.Printf(\"*c: %d\\n\", *c) fmt.Printf(\"**c: %d\\n\", **c) } ▶ اجرای کد کپی ✖ بستن خروجی توجه کنید در زبان گو علی رغم زبان c استفاده از اشاره‌گر حسابی (Pointer Arithmetic) امکان پذیر نمی‌باشد و در صورت استفاده با خطای زیر مواجه خواهید شد:\npackage main func main() { a := 1 b := \u0026a b = b + 1 } ▶ اجرای کد کپی ✖ بستن خروجی "},{"id":25,"href":"/chapter-2/struct/","title":"2.2 ساختار (struct)","section":"فصل دوم: مکانیزم‌های زبان","content":"در زبان گو ساختار کالکشنی از فیلدها با تایپ‌های مختلف است. شما با استفاده از ساختار می‌توانید یک مدل کلی از بدنه پروژه خود را تعریف کنید. برای نمونه ما در مثال زیر یک نمونه از ساختار employee کارمند را مثال زدیم تا شما کمی با مفهوم ساختار آشنا شوید.\ntype employee struct { name string age int salary int } نکته: ساختار می‌تواند بصورت خالی جهت برخی اهداف ایجاد گردد. به مثال زیر دقت کنید:‌\ntype sample struct {} اگر می‌خواهید در مورد متودها اطلاعات کسب کنید به بخش متدها روی ساختار سر بزنید، هر چند توصیه می‌کنم اول این قسمت رو بخونید و تمرین کنید و بعد به قسمت متودها بروید.\nبرای ایجاد ساختار باید از کلمه کلیدی type اسم ساختار و در ادامه کلمه کلیدی struct استفاده کنید.\nسپس داخل بدنه ساختار فیلدها را تعریف کنید.\nفیلد name از نوع string فیلد age از نوع int فیلد salary از نوع int ساختار را در زبان گو، با class در سایر زبان‌ها مقایسه می‌کنند. هرچند زبان گو یک زبان شی‌گرا محسوب نمی‌شود. 2.2.1 تعریف تایپ struct # به مثال زیر توجه کنید:\ntype point struct { x float64 y float64 } در مثال بالا ما ۲ تا فیلد برای ساختار تعریف کردیم که هر دو فیلد از نوع float64 هستند.\n2.2.2 ایجاد یک متغیر ساختار (struct) # برای ایجاد یک متغیر ساختار می‌توانید یک متغیر تعریف کنید و ساختار را به عنوان مقدار به آن بدهید. به مثال زیر توجه کنید:\nemp := employee{} در مثال بالا ما یک متغیر با مقدار پیش‌فرض صفر ساختار employee تعریف کردیم.\nزمانیکه یک متغیر ساختار خالی، مانند مثال بالا تعریف می‌کنید مقدار استفاده شده از حافظه 0 بایت است. ایجاد متغیر ساختار و مقدار دهی فیلدها در یک خط: emp := employee{name: \u0026quot;Sam\u0026quot;, age: 31, salary: 2000} ایجاد متغیر ساختار و مقدار دهی فیلد در خط‌های مختلف (این روش برای خوانایی و درک بهتر توصیه می‌شود) : emp := employee{ name: \u0026quot;Sam\u0026quot;, age: 31, salary: 2000, } توجه کنید هیچ اجباری نیست که حتماً شما باید فیلدی را مقدار دهی کنید، شما می‌توانید هر زمانیکه نیاز داشتید ساختار خودتان رو مقدار دهی کنید.\nemp := employee{ name: \u0026quot;Sam\u0026quot;, age: 31, } در مثال بالا ما فیلد salary را مقدار دهی نکردیم. کامپایلر بطور پیش‌فرض با توجه به تایپ فیلد، مقدار پیش‌فرض صفر را برای اون تایپ در نظر می‌گیرد. در ادامه به مثالی که از نحوه ایجاد ساختارها زدیم، توجه کنید:\npackage main import \"fmt\" type employee struct { name string age int salary int } func main() { emp1 := employee{} fmt.Printf(\"Emp1: %+v\\n\", emp1) emp2 := employee{name: \"Sam\", age: 31, salary: 2000} fmt.Printf(\"Emp2: %+v\\n\", emp2) emp3 := employee{ name: \"Sam\", age: 31, salary: 2000, } fmt.Printf(\"Emp3: %+v\\n\", emp3) emp4 := employee{ name: \"Sam\", age: 31, } fmt.Printf(\"Emp4: %+v\\n\", emp4) } ▶ اجرای کد کپی ✖ بستن خروجی ایجاد متغیر ساختار و مقدار دهی فیلدها بدون نام فیلد: شما می‌توانید فیلدها را بدون اینکه نام فیلد را قرار دهید مقدار دهی کنید اما از نظر تکنیکی این کار توصیه نمی‌شود، دلیل این توصیه هم این است که اگر شما فیلدها رو به این روش مقدار دهی کنید، باید ترتیب رو در نظر بگیرید یعنی 1: باید نام باشد، 2: باید سن باشد، 3: باید درآمد باشد و اگر این ترتیب رعایت نشود شما دیتای اشتباهی خواهید داشت.\nemp := employee{\u0026quot;Sam\u0026quot;, 31, 2000} {Sam 31 2000} // حروجی در مثال بالا ترتیب رعایت شده. به مثال زیر توجه کنید:\nemp := employee{\u0026quot;Sam\u0026quot;, 2000, 31} {Sam 2000 31} // حروجی همانطور که در مثال بالا دیدین الان با ترتیب اشتباه سن کارمند و درآمدش جابه جا شدن و ما دیتای اشتباهی از کارمند خواهیم داشت.\n2.2.3 دسترسی و تنظیم فیلدهای ساختار (struct) # زمانیکه شما یک متغیر ساختار تعریف می‌کنید، می‌توانید خیلی آسان با استفاده از همان متغیر به فیلدهای ساختار دسترسی پیدا کنید و مقدار هر کدام از فیلدها را تغییر دهید. به مثال زیر توجه کنید:\npackage main import \"fmt\" type employee struct { name string age int salary int } func main() { emp := employee{name: \"Sam\", age: 31, salary: 2000} //Accessing a struct field fmt.Printf(\"Current name is: %s\\n\", emp.name) //Assigning a new value to name field emp.name = \"John\" fmt.Printf(\"New name is: %s\\n\", emp.name) } ▶ اجرای کد کپی ✖ بستن خروجی 2.2.4 کار با اشاره‌گر (Pointer) در ساختار (struct) # شما برای ایجاد یک struct از نوع اشاره‌گر می‌توانید از دو حالت زیر استفاده کنید:\nبا استفاده از عملگر \u0026amp; که اشاره به خانه حافظه دارد با استفاده از تابع new 2.2.4.1 ایجاد ساختار با استفاده از عملگر \u0026amp; # برای اینکه بتوانید یک ساختار از نوع اشاره گر ایجاد کنید می‌توانید از عملگر \u0026amp; استفاده کنید. به مثال زیر توجه کنید:\nemp := employee{name: \u0026quot;Sam\u0026quot;, age: 31, salary: 2000} empP := \u0026amp;emp حتی شما می‌توانید یک ساختار اشاره‌گر را مستقیماً ایجاد کنید این روش پیشنهاد می‌شود. به مثال زیر توجه کنید:\nempP := \u0026amp;employee{name: \u0026quot;Sam\u0026quot;, age: 31, salary: 2000} در مثال زیر هر دو روش رو برای شما توضیح دادیم. با دقت به کد و خروجی کد نگاه کنید:‌\npackage main import \"fmt\" type employee struct { name string age int salary int } func main() { emp := employee{name: \"Sam\", age: 31, salary: 2000} empP := \u0026emp fmt.Printf(\"Emp: %+v\\n\", empP) empP = \u0026employee{name: \"John\", age: 30, salary: 3000} fmt.Printf(\"Emp: %+v\\n\", empP) } ▶ اجرای کد کپی ✖ بستن خروجی 2.2.4.2 ایجاد ساختار با استفاده تابع new # func new(Type) *Type همینطور که در تعریف تابع new هم می‌بینید، این تابع یک تایپ از ما می‌گیرد و مقدار دهی می‌کند، و در آخر هم تایپ را از نوع اشاره‌گر برای ما بر می‌گرداند.\nبا استفاده از تابع new :\nشما یک ساختار ایجاد می‌کنید. سپس فیلدها، با مقدار پیش‌فرض صفر مقدار دهی اولیه می‌شوند. در نهایت ساختار شما از نوع اشاره‌گر بازگشت داده می‌شود. به مثال زیر توجه کنید:\nempP := new(employee) برای اینکه آدرس خانه حافظه ساختار، از نوع اشاره‌گر را ببینید کافی است با استفاده از p% اون ساختار رو چاپ کنید. به مثال زیر توجه کنید:\nfmt.Printf(\u0026quot;Emp Pointer: %p\\n\u0026quot;, empP) برای اینکه مقدار کلی فیلدها را ببینید کافی است با استفاده از v+% اون رو چاپ کنید. به مثال زیر توجه کنید:\nfmt.Printf(\u0026quot;Emp Value: %+v\\n\u0026quot;, *empP) در مثال زیر خروجی آنچه در بالا گفته شد رو قرار دادیم. لطفاً با دقت به مثال زیر نگاه کنید و در آخر هم مثال‌های مشابهی رو برای خودتان بنویسید:\npackage main import \"fmt\" type employee struct { name string age int salary int } func main() { empP := new(employee) fmt.Printf(\"Emp Pointer Address: %p\\n\", empP) fmt.Printf(\"Emp Pointer: %+v\\n\", empP) fmt.Printf(\"Emp Value: %+v\\n\", *empP) } ▶ اجرای کد کپی ✖ بستن خروجی 2.2.5 چاپ یک متغیر ساختار (struct) # برای اینکه بتوانید یک متغیر ساختار struct را چاپ کنید، از دو روش زیر می‌توانید استفاده کنید. توجه کنید متغیر ساختار بصورت key/value هست.\nبا استفاده از پکیج fmt با استفاده از پکیج json/encoding 2.2.5.1 چاپ با استفاده از fmt # در پکیج fmt ما 2 تا تابع کاربردی جهت چاپ داریم که اکثر اوقات از این دو تابع استفاده می‌کنیم:\nتابع Println ورودی را با فرمت پیش‌فرض چاپ می‌کند. تابع Printf ورودی را با فرمت مشخص شده چاپ می‌کند فرمت رو خود ما مشخص می‌کنیم. در مثال زیر ما یک نمونه از ساختار employee را ایجاد کردیم:\nemp := employee{name: \u0026quot;Sam\u0026quot;, age: 31, salary: 2000} حال با استفاده از تابع Printf ساختار را با فرمت دلخواه خودمان چاپ کردیم:\nfmt.Printf(\u0026quot;%v\u0026quot;, emp) - {Sam 31 2000} fmt.Printf(\u0026quot;%+v\u0026quot;, emp) - {name:Sam age:31 salary:2000} %v - مقدار value هر کدام از فیلدهای ساختار را چاپ می‌کند. %+v - مقدار هرکدام از فیلدها به همراه اسم فیلد key-value را چاپ می‌کند. در مثال زیر ما با استفاده از از تابع Println ساختار را چاپ کردیم:\nfmt.Println(emp) - {Sam 31 2000} در نهایت کد زیر یک مثال کلی از چاپ با استفاده از پکیج fmt است‌:\npackage main import \"fmt\" type employee struct { name string age int salary int } func main() { emp := employee{name: \"Sam\", age: 31, salary: 2000} fmt.Printf(\"Emp: %v\\n\", emp) fmt.Printf(\"Emp: %+v\\n\", emp) fmt.Printf(\"Emp: %#v\\n\", emp) fmt.Println(emp) } ▶ اجرای کد کپی ✖ بستن خروجی 2.2.5.2 چاپ ساختار با استفاده از پکیج JSON # در این روش ما با استفاده از ۲ تابع Marshal و MarshalIndent پکیج json، ساختار را encode می‌کنیم و در نهایت خروجی encode شده را چاپ می‌کنیم.\nMarshal - در این تابع ما به عنوان ورودی‌، ساختار را پاس می‌دهیم و در نهایت ۲ خروجی از نوع بایت و خطا دریافت می‌کنیم. Marshal(v interface{}) ([]byte, error) MarhsalIndent - در این تابع ما ۳ تا ورودی به تابع می‌فرستیم, به ترتیب ساختار، پیشوند و indent و در نهایت ۲ خروجی از نوع بایت و خطا دریافت می‌کنیم. MarshalIndent(v interface{}, prefix, indent string) ([]byte, error) حالا با استفاده از توابع فوق یک کد نمونه مثال می‌زنیم و به شما یاد می‌دیم که چطور از این توابع استفاده کنید. به مثال زیر دقت کنید:\npackage main import ( \"encoding/json\" \"fmt\" \"log\" ) type employee struct { Name string Age int Salary int } func main() { emp := employee{Name: \"Sam\", Age: 31, Salary: 2000} //Marshal empJSON, err := json.Marshal(emp) if err != nil { log.Fatalf(err.Error()) } fmt.Printf(\"Marshal funnction output %s\\n\", string(empJSON)) //MarshalIndent empJSON, err = json.MarshalIndent(emp, \"\", \" \") if err != nil { log.Fatalf(err.Error()) } fmt.Printf(\"MarshalIndent funnction output %s\\n\", string(empJSON)) } ▶ اجرای کد کپی ✖ بستن خروجی برای اطلاعات بیشتر در خصوص پکیج json می‌توانید به بخش آموزش کار با json مراجعه کنید. 2.2.6 کار با تگ ها در ساختار (struct) # ساختار زبان گو، به شما امکان اضافه کردن metadata به هر یک از فیلدها را می‌دهد و ما این قابلیت را به عنوان تگ می‌شناسیم. تگ‌ها برای انجام یکسری عملیات خاص نظیر encode/decode، اعتبارسنجی مقادیر فیلدها و \u0026hellip; به ما کمک می‌کند و یکی از کاربردی‌ترین عناوین در ساختار هستند.\nبه مثال های زیر توجه کنید تا کارکرد تگ ها را متوجه شوید:\ntype strutName struct{ fieldName type `key:\u0026quot;value\u0026quot; key2:\u0026quot;value2\u0026quot;` } type employee struct { Name string Age int Salary int } در این مثال، مقدار داخل متغیری که از نوع Employee است را تبدیل به json می کنیم و چاپ می کنیم.\npackage main import ( \"encoding/json\" \"fmt\" \"log\" ) type employee struct { Name string Age int Salary int } func main() { emp := employee{Name: \"Sam\", Age: 31, Salary: 2000} //Converting to jsonn empJSON, err := json.MarshalIndent(emp, \"\", \" \") if err != nil { log.Fatalf(err.Error()) } fmt.Println(string(empJSON)) } ▶ اجرای کد کپی ✖ بستن خروجی حالا به ما می گویند که اول اسم فیلد ها در خروجی json با حرف بزرگ شروع نشود و حرف کوچک باشد. اولین چیزی که شاید به ذهن شما خطور کند این است که اسم فیلد ها را در ساختار تعریف شده با حروف کوچک شروع کنیم:\npackage main import ( \"encoding/json\" \"fmt\" \"log\" ) type employee struct { name string age int salary int } func main() { emp := employee{name: \"Sam\", age: 31, salary: 2000} //Converting to jsonn empJSON, err := json.MarshalIndent(emp, \"\", \" \") if err != nil { log.Fatalf(err.Error()) } fmt.Println(string(empJSON)) } ▶ اجرای کد کپی ✖ بستن خروجی اما خروجی ما یک json خالی است. جرا؟ چون زمانی که اسم فیلد‌ ها با حروف کوچک شروع شوند private هستند و از بیرون قابل دسترسی نیستند. به همین دلیل خروجی یک json خالی است.\nبرای حل این مشکل ما برای ساختار خودمان یک تگ json اضافه می کنیم و می گوییم اسم فیلد تو در json چیز دیگری است:\npackage main import ( \"encoding/json\" \"fmt\" \"log\" ) type employee struct { Name string `json:\"name\"` Age int `json:\"age\"` Salary int `json:\"salary\"` } func main() { emp := employee{Name: \"Sam\", Age: 31, Salary: 2000} //Converting to jsonn empJSON, err := json.MarshalIndent(emp, \"\", \" \") if err != nil { log.Fatalf(err.Error()) } fmt.Println(string(empJSON)) } ▶ اجرای کد کپی ✖ بستن خروجی فکر می‌کنم خروجی بالا کاملاً برای ما روشن کرد که دقیقاً اون تگ‌هایی که قرار دادیم، برای ما چه کاری انجام دادند. بله کلید-key‌های ما را به اون نام‌هایی که در تگ‌ها نوشته بودیم تغییر دادند.\n2.2.6.1 چند نمونه از کاربرد تگ ها # تگ ها کاربرد های خیلی زیادی دارند که در بخش قرار است بعضی از آنها را بررسی کنیم.\nمی توانید با تگ (-) مشخص کنید که آن فیلد موقع سریالایز نادیده گرفته شود و نمایش داده نشود. مثال:\npackage main import ( \"encoding/json\" \"fmt\" \"log\" ) type employee struct { Name string `json:\"name\"` Age int `json:\"-\"` Salary int `json:\"salary\"` } func main() { emp := employee{Name: \"Sam\", Salary: 2000} //Converting to jsonn empJSON, err := json.MarshalIndent(emp, \"\", \" \") if err != nil { log.Fatalf(err.Error()) } fmt.Println(string(empJSON)) } ▶ اجرای کد کپی ✖ بستن خروجی با استفاده از تگ omitempty اگر آن فیلد مقداری نداشته باشد، نمایش داده نمی شود:\npackage main import ( \"encoding/json\" \"fmt\" \"log\" ) type employee struct { Name string `json:\"name,omitempty\"` Age int `json:\"age,omitempty\"` Salary int `json:\"salary,omitempty\"` } func main() { emp := employee{Age: 22, Salary: 2000} //Converting to jsonn empJSON, err := json.MarshalIndent(emp, \"\", \" \") if err != nil { log.Fatalf(err.Error()) } fmt.Println(string(empJSON)) } ▶ اجرای کد کپی ✖ بستن خروجی از دیگر کاربرد های تگ ها می توان به عملیات اعتبار سنجی اشاره کرد. برای مثال می توان چک کرد فیلد شماره موبایل از یازده رقم بیشتر و کمتر نباشد. همچنین در تعریف مدل های دیتابیس با استفاده از تگ ها ارتباط بین دیتابیس و مدل را می توانیم پیاده سازی کنیم و \u0026hellip;\n2.2.7 تعریف فیلد ناشناس در ساختار (struct) # شما در ساختار struct امکان تعریف فیلدهای ناشناس را دارید و همینطور می‌توانید فیلدهای ناشناس را نیز مقدار دهی کنید.\ntype employee struct { string age int salary int } در کد زیر یک مثال ساده در خصوص تعریف و مقدار دهی فیلدهای ناشناس زده‌ایم:\npackage main import \"fmt\" type employee struct { string age int salary int } func main() { emp := employee{string: \"Sam\", age: 31, salary: 2000} //Accessing a struct field n := emp.string fmt.Printf(\"Current name is: %s\\n\", n) //Assigning a new value emp.string = \"John\" fmt.Printf(\"New name is: %s\\n\", emp.string) } ▶ اجرای کد کپی ✖ بستن خروجی توجه داشته باشید زمانی که از فیلد های ناشناس استفاده می کنید، از هر دیتاتایپ فقط یکبار می توانید استفاده کنید:\npackage main import ( \"fmt\" ) type employee struct { string // name int // age int // salary } func main() { emp := employee{\"alireza\", 22, 10_000_000} fmt.Printf(\"%+v\", emp) } ▶ اجرای کد کپی ✖ بستن خروجی 2.2.8 تعریف ساختار تو در تو (nested) # یکی دیگر از امکانات ساختار در زبان گو بحث ساختار تو در تو است. در مثالی که در ادامه زدیم ساختار address را داخل employee قرار دادیم:\npackage main import \"fmt\" type employee struct { name string age int salary int address address } type address struct { city string country string } func main() { address := address{city: \"London\", country: \"UK\"} emp := employee{name: \"Sam\", age: 31, salary: 2000, address: address} fmt.Printf(\"City: %s\\n\", emp.address.city) fmt.Printf(\"Country: %s\\n\", emp.address.country) } ▶ اجرای کد کپی ✖ بستن خروجی توجه کنید شما طبق روش زیر می‌توانید به فیلدهای تو در تو دسترسی داشته باشید:\nemp.address.city emp.address.country بعضی مواقع بهتر است بصورت مستقیم به فیلد های درون ساختار تو‌در‌تو دسترسی داشته باشیم. به مثال زیر دقت کنید:\npackage main type Product struct { Name string Price int } type Mobile struct { Product Product Ram int SimCount int } func main() { var mobile Mobile = Mobile{} mobile.Product.Name = \"Iphone 11\" mobile.Product.Price = 1000 mobile.Ram = 8 mobile.SimCount = 1 } ▶ اجرای کد کپی ✖ بستن خروجی همانطور که می بینید برای تعریف اسم موبایل باید بگوییم mobile.Product.Name که این زیاد جالب نیست. پس به این صورت ساختار Product را درون موبایل قرار می دهیم:\npackage main type Product struct { Name string Price int } type Mobile struct { Product Ram int SimCount int } func main() { var mobile Mobile = Mobile{} mobile.Name = \"Iphone 11\" mobile.Price = 1000 mobile.Ram = 8 mobile.SimCount = 1 } ▶ اجرای کد کپی ✖ بستن خروجی الان بصورت مستقیم می توانیم به فیلد های درون Product دسترسی داشته باشیم.\n2.2.9 تعریف یک ساختار عمومی یا خصوصی (Public/Private) # در زبان گو، چیزی به عنوان کلمه کلیدی public یا private جهت تعیین وضعیت دسترسی struct به بیرون وجود ندارد، در عوض کامپایلر گو بر اساس حرف بزرگ یا کوچک عنوان ساختار یا سایر تایپ‌ها، تشخیص می‌دهد تایپ شما عمومی است یا خصوصی. در صورتیکه شما حرف اول را کوچک قرار دهید تایپ شما بیرون از پکیج قابل دسترس نخواهد بود مثل مثال‌های بالا و اگر حرف اول تایپ رو بزرگ قرار دهید، تایپ یا تابع شما بیرون از پکیج نیز در دسترس خواهد بود. مثال تابع fmt.Println.\ntype Person struct { Name string age int } type company struct { Name string } برای اطلاعات بیشتر بهتر است به بخش کپسوله سازی مراجعه کنید. 2.2.10 مقایسه ساختارها # شما در زبان گو می‌توانید ساختارها را بر اساس عنوان فیلد، تایپ و مقدارشان مقایسه کنید. اما باید توجه کنید ساختارها فقط براساس تایپ‌هایی که در ادامه معرفی کردیم, امکان مقایسه را خواهند داشت:\nboolean numeric string pointer channel interface types structs array و اما ۳ تایپ زیر امکان مقایسه را به شما نمی‌دهند:\nSlice Map Function package main import \"fmt\" type employee struct { name string age int salary int } func main() { emp1 := employee{name: \"Sam\", age: 31, salary: 2000} emp2 := employee{name: \"Sam\", age: 31, salary: 2000} if emp1 == emp2 { fmt.Println(\"emp1 annd emp2 are equal\") } else { fmt.Println(\"emp1 annd emp2 are not equal\") } } ▶ اجرای کد کپی ✖ بستن خروجی "},{"id":26,"href":"/chapter-2/method/","title":"2.3 متد (Method)","section":"فصل دوم: مکانیزم‌های زبان","content":"متد در واقع یک تابع گیرنده (receiver) است که به واسطه یک تایپ در دسترس خواهد بود. توجه کنید برای تعریف متد باید قبل از اسم تابع، داخل پرانتز یک نام و یک تایپ قرار دهید. برای درک بهتر این موضوع فکر کنید نامی که داخل پرانتز قرار می‌دید یه متغیر هست که به تایپ شما اشاره می‌کند. به مثال زیر توجه کنید:\nfunc (receiver receiver_type) some_func_name(arguments) return_values برای درک بهتر این مفهوم، می‌توانید متد را دقیقاً یک تابع در نظر بگیرید. نحوه تعریف به صورت متد صرفاً برای راحتی در زمان توسعه نرم افزار است و به برنامه‌نویس امکان توسعه بهتر بدون نیاز به حفظ کردن زیاد عملکرد‌های سیستم را می‌دهد.\nfunc (r receiver_T) some_func_name(arg1 arg1_T, ...) return_values func some_func_name(r receiver_T, arg1 arg1_T, ...) return_values نکته قابل ذکر دیگر در خصوص این مفهوم این است که متد در زبان گو از رویکرد static method به صورت مستقیم پشتیبانی نمی‌‌کند، یعنی تا زمانیکه شما یک متغیر از نوع تایپی که دارای متد است را راه اندازی نکنید، به متدهایش دسترسی نخواهید داشت.\nاکثراً متد را یکی از عناوین شی‌گرایی در زبان گو می‌شناسند که مزایای خوبی دارد، بخصوص اگر متدها برای تایپ struct تعریف شوند شما می‌توانید برای هر یک از فیلدهای ساختار، توابع بخصوصی در قالب متد بنویسید، ولی اگر بخوایم کمی دقیق‌تر بگیم مفهوم متد برگرفته از الگوی Encapsulation است که بر خلاف تصور رایج صرفاً محدود به رویکرد OOP نیست و یک الگوی پذیرفته شده حتی در زبان‌های Functional programming languages نیز است.\n2.3.1 متدها برای ساختار (struct) # زبان گو یک زبان شی گرا نیست ولی برخی از مفاهیم شی‌گرایی را بصورت قرار دادی دارد. ساختار در زبان گو یک تایپ است که این تایپ نیز کالکشنی از تایپ‌های مختلف را در بر می‌گیرد که ما در بخش قبلی بهش پرداختیم.\nبه مثالی که در مورد پیاده‌سازی متد‌ها زده‌ایم توجه کنید:\npackage main import \"fmt\" type employee struct { name string age int salary int } func (e employee) details() { fmt.Printf(\"Name: %s\\n\", e.name) fmt.Printf(\"Age: %d\\n\", e.age) } func (e employee) getSalary() int { return e.salary } func main() { emp := employee{name: \"Sam\", age: 31, salary: 2000} emp.details() fmt.Printf(\"Salary %d\\n\", emp.getSalary()) } ▶ اجرای کد کپی ✖ بستن خروجی در کد بالا ما یک ساختار با نام employee ایجاد کردیم و سپس ۲ متد با نام‌های details و getSalary برای آن تعریف کردیم. حال برای اینکه بتوانیم از این متدها استفاده کنیم داخل تابع main، یک متغیر از نوع employee تعریف کردیم و سپس با استفاده از نقطه . پس از نام متغیر به متدها دسترسی پیدا کردیم همانند دسترسی به فیلدهای ساختار.\nآیا با استفاده از متد می‌توانیم مقدار یکی از فیلدهای داخل ساختار را تغییر دهیم ؟ این سوال ۲ جواب دارد هم بله و هم خیر\nحال به مثال زیر توجه کنید تا توضیح دهیم:\npackage main import \"fmt\" type employee struct { name string age int salary int } func (e employee) setNewName(newName string) { e.name = newName } func main() { emp := employee{name: \"Sam\", age: 31, salary: 2000} emp.setNewName(\"John\") fmt.Printf(\"Name: %s\\n\", emp.name) } ▶ اجرای کد کپی ✖ بستن خروجی علت اینکه می‌گوییم خیر : به خاطر اینکه ما داریم با یک کپی از فیلدهای ساختار کار می‌کنیم و با تغییر مقدار هر یک از فیلدها تغییر بر روی کپی آن اعمال خواهد شد. اما علت اینکه می‌گوییم بله : اگر ما با استفاده از اشاره‌گر pointer به فیلدهای داخل ساختار دسترسی پیدا کنیم می‌توانیم مستقیماً به داخل خانه حافظه تایپ دسترسی داشته باشیم و مقدار فیلد مورد نظر را در هر جایی از پروژه تغییر دهیم. 2.3.2 استفاده از اشاره‌گر (pointer) در متدها # در مثال بالا ما به این اشاره کردیم که آیا می‌شود مقدار هر یک از فیلدهای ساختار را با استفاده از متد تغییر داد یا خیر و در پاسخ گفتیم هم می شود و هم نه. سپس علتش را توضیح دادیم. حال می‌خواهیم با یک مثال این مورد را توضیح دهیم چگونه می نوانیم هر یک از فیلد های ساختار را از طریق متد تغییر دهیم. به مثال زیر توجه کنید:\npackage main import \"fmt\" type employee struct { name string age int salary int } func (e *employee) setNewName(newName string) { e.name = newName } func main() { emp := \u0026employee{name: \"Sam\", age: 31, salary: 2000} emp.setNewName(\"John\") fmt.Printf(\"Name: %s\\n\", emp.name) } ▶ اجرای کد کپی ✖ بستن خروجی در مثال بالا متد setNewName یک نوع متد گیرنده از نوع اشاره‌گر است که ما داخل این متد به مقدار فیلدهای داخل خانه حافظه ساختار employee دسترسی داریم و می‌توانیم آن‌ها را مقدار دهی کنیم.\nآیا استفاده از گیرنده اشاره‌گر واقعا ضروری است؟ خیر، ضروری نیست زیرا ما وقتی به متدها دسترسی داریم که یک نمونه (instance) از تایپ مورد نظر ایجاد کنیم تا به متدهایش دسترسی داشته باشیم و همچنین اگر فرضاً نیاز داشته باشیم که یکی از فیلدهای ساختار را مقدار دهی کنیم، باز هم می‌توانیم به آدرس خانه متغیری که ساختار را نگه داری می‌کند اشاره کنیم و مقدارش را تغییر دهیم. به مثال زیر توجه کنید:\npackage main import \"fmt\" type employee struct { name string age int salary int } func (e *employee) setNewName(newName string) { e.name = newName } func main() { emp := employee{name: \"Sam\", age: 31, salary: 2000} emp.setNewName(\"John\") fmt.Printf(\"Name: %s\\n\", emp.name) (\u0026emp).setNewName(\"Mike\") fmt.Printf(\"Name: %s\\n\", emp.name) } ▶ اجرای کد کپی ✖ بستن خروجی 2.3.2.1 چه موقع باید از گیرنده اشاره‌گر برای متد استفاده کنیم؟ # زمانیکه قصد داریم متدهایی بنویسیم که برروی مقدار فیلدهای ساختار در زمان اجرا تغییراتی انجام میدهند. زمانیکه ساختار خیلی بزرگ است و فیلدهای زیادی دارد. در این سناریو بهتر است از گیرنده اشاره‌گر استفاده کنیم تا هر بار با یکی کپی از ساختار مواجه نشویم. 2.3.4 تعریف متد برای فیلدهای ساختار تو در تو (nested) # شما می‌توانید برای فیلدهایی که ساختار تو در تو دارند نیز متد بنویسید. به مثال زیر توجه کنید:\npackage main import \"fmt\" type employee struct { name string age int salary int address address } type address struct { city string country string } func (a address) details() { fmt.Printf(\"City: %s\\n\", a.city) fmt.Printf(\"Country: %s\\n\", a.country) } func main() { address := address{city: \"London\", country: \"UK\"} emp := employee{name: \"Sam\", age: 31, salary: 2000, address: address} emp.address.details() } ▶ اجرای کد کپی ✖ بستن خروجی در مثال بالا ما یک متد برای ساختار address تعریف کردیم و سپس ساختار address را داخل ساختار employee گذاشتیم. در نهایت شما با استفاده از employee می‌توانید به متدهای address هم دسترسی داشته باشید و از آن‌ها استفاده کنید.\n"},{"id":27,"href":"/chapter-2/interface/","title":"2.4 اینترفیس (Interface)","section":"فصل دوم: مکانیزم‌های زبان","content":"اینترفیس در زبان گو مجموعه‌ای از متدها است. این مجموعه متدها با توجه به ورودی و خروجی که دارند دارای رفتارهای خاصی هستند. زمانیکه شما یک اینترفیس به همراه یکسری از متدها تعریف می‌کنید باید در جایی این متدها را پیاده سازی کنید.\nاینترفیس‌ها به شما اجازه می‌دهد تا از Duck typing استفاده کنید. حالا این duck typing چیست؟\nduck typing روشی در برنامه‌نویسی کامپیوتری است که به شما امکان می‌دهد تست اردک را انجام دهید، جایی که ما نوع را بررسی نمی‌کنیم، بلکه تنها وجود برخی ویژگی‌ها یا روش‌ها را بررسی می‌کنیم. بنابراین آنچه واقعاً اهمیت دارد این است که آیا یک شی دارای ویژگی‌ها و روش‌های خاصی است و نه نوع آن.\nبرگردیم به بحث اینترفیس, در زیر ما یک نمونه اینترفیس را قرار دادیم:\ntype name_of_interface interface{ //Method signature 1 //Method signature 2 } برای درک بهتر مفهوم ارائه شده، بیایید از یک مثال ساده استفاده کنیم. فرض کنید ما یک شی به نام «animal» داریم که شامل یکسری رفتارها است، مانند نفس کشیدن و راه رفتن. این رفتارها باید به یک حیوان خاص اختصاص یابند تا بتوانیم ویژگی‌ها و رفتارهای دقیق آن حیوان را مشخص و تعریف کنیم.\ntype animal interface { breathe() walk() } در بالا ما یک اینترفیس تعریف کردیم ۲ تا متد دارد حالا بیاید یک متغیر از نوع اینترفیس animal درست کنیم و چاپ کنیم.\npackage main import \"fmt\" type animal interface { breathe() walk() } func main() { var a animal fmt.Println(a) } ▶ اجرای کد کپی ✖ بستن خروجی در بالا وقتی اینترفیس را چاپ کردیم، خروجی nil بود. توجه کنید اینترفیس مقدار پیش‌فرض یا خالی بودنش nil هست.\n2.4.1 پیاده‌سازی اینترفیس # در بالا ما یک اینترفیس animal تعریف کردیم که ۲ متد داشت حالا قصد داریم یک شی (منظور ساختار در گو) به نام lion تعریف کنیم و متدهای اینترفیس animal را پیاده‌سازی کنیم.\npackage main import \"fmt\" type animal interface { breathe() walk() } type lion struct { age int } func (l lion) breathe() { fmt.Println(\"Lion breathes\") } func (l lion) walk() { fmt.Println(\"Lion walk\") } func main() { var a animal a = lion{age: 10} a.breathe() a.walk() } ▶ اجرای کد کپی ✖ بستن خروجی در بالا ما یک متغیر با تایپ animal تعریف کردیم:\nvar a animal سپس ما یک نمونه از ساختار lion را بهش اختصاص دادیم:\na = lion{} اختصاص یک نمونه از ساختار lion به متغیر a که با تایپ lion بود موفقیت آمیز بود زیرا ما برای lion متدهای مربوط به animal را که breathe و walk بود، پیاده سازی کردیم. این مفهوم کاملاً شبیه به ducking typing هست که در بالا گفتیم. یک شیر می‌تواند نفس بکشد و راه برود از این رو او یک حیوان است.\nتوجه کنید اگر شما متد جدیدی را اضافه یا کم کنید و همچنین اگر تغییر ایجاد کنید باید این تغییرات بر روی اشیایی که با اینترفیس شما در ارتباط هستند صورت بگیرید.\nبه عنوان مثال شما اگر به اینترفیس animal یک متد جدیدی اضافه کنید حتما باید برای ساختار lion هم پیاده سازی کنید.\n2.4.2 اینترفیس‌ها بطور ضمنی (implicitly) پیاده سازی می‌شود # برای اینترفیس هیچ حالت صریح (explicit) هنگام تعریف وجود ندارد و همه چی بصورت ضمنی است تا زمانیکه یک اینترفیس برای یک شی (ساختار) متدهایش پیاده سازی نشود هیچ کاربردی نخواهد داشت.\nتوجه کنید هیچ حالت صریحی وجود ندارد که بگوید شما تمامی متدهای اینترفیس animal را برای ساختار lion پیاده سازی کردید یا خیر و فقط در زمان کامپایل اگر ایرادی وجود داشته باشد کامپایلر به شما خطا می‌دهد و البته IDE هایی مانند: Goland , Vscode به شما هنگام نوشتن کد در خصوص این مورد کمک می‌کنند قبل از کامپایل متوجه خطاهای مرتبط با پیاده سازی اینترفیس شوید.\nخب بزارید یک مثال پیچیده برای اینترفیس animal بزنیم و یک شی (ساختار) دیگر به نام dog اضافه کنیم و متدهای اینترفیس animal را برای این شی پیاده سازی کنیم.\npackage main import \"fmt\" type animal interface { breathe() walk() } type lion struct { age int } func (l lion) breathe() { fmt.Println(\"Lion breathes\") } func (l lion) walk() { fmt.Println(\"Lion walk\") } type dog struct { age int } func (l dog) breathe() { fmt.Println(\"Dog breathes\") } func (l dog) walk() { fmt.Println(\"Dog walk\") } func main() { var a animal a = lion{age: 10} a.breathe() a.walk() a = dog{age: 5} a.breathe() a.walk() } ▶ اجرای کد کپی ✖ بستن خروجی در مثال بالا ما یک ساختار با نام dog تعریف کردیم و سپس متدهای animal را برای ساختار dog پیاده سازی کردیم و در نهایت ساختار dog را به متغیر اینترفیس a اختصاص دادیم. همانطور که می‌بینیم dog هم همانند lion نفس می‌کشد و راه می‌رود.\nتوجه کنید در بالا ما برای ۲ تا شی lion و dog یک وجه مشترک به نام animal به همراه رفتار مشترک تعریف کردیم که به اینکار پلی مورفیسم می‌گویند و یکی از عناوین پر کاربرد در شی‌گرایی می باشد که در بخش شی گرایی زبان گو بیشتر می‌پردازیم. دو نکته مهم در خصوص اینترفیس‌:\nاینترفیس‌ها فقط زمان کامپایل مشخص می‌شود که برای اشیا به درستی پیاده سازی شده‌اند یا خیر و اگر فرضاً ما برای ساختار lion در کد بالا متد walk را حذف کنیم با خطای زیر رو به رو خواهیم شد: cannot use lion literal (type lion) as type animal in assignment: ورود و خروجی‌های هر متدی که پیاده سازی می‌کنید برای اشیا (ساختارها) بستگی به تعریف ضمنی متد داخل اینترفیس دارد و اگر شما متدی را داخل اینترفیس تغییر دهید حتما باید آن متد در اشیایی که قبلا پیاده سازی شده تغییر یابد. حالا فرض کنید ما برای اینترفیس animal یک متد جدیدی به نام speed تعریف کردیم که این متد به عنوان خروجی مقداری با تایپ int بر می‌گرداند:\ntype animal interface { breathe() walk() speed() int } حالا ساختار lion باید متد speed را مانند کد زیر پیاده سازی کرده باشد :\nfunc (l lion) speed() اگر دقت کنید ما داخل اینترفیس animal گفتیم متد speed یک مقدار خروجی از نوع int دارد ولی ما برای ساختار lion متد speed را بدون خروجی نوشتیم. اتفاقی که می‌افتد هنگام کامپایل با خطای زیر مواجه خواهیم شد :\ncannot use lion literal (type lion) as type animal in assignment: lion does not implement animal (wrong type for speed method) have speed() want speed() int با توجه به اتفاقی که افتاد ما نتیجه میگریم متدی که داخل اینترفیس به همراه ورودی و خروجی اضافه می‌شود باید به همان شکل برای ساختارهامون پیاده سازی کنیم.\n2.4.3 استفاده از اینترفیس به عنوان پارامتر ورودی تابع # توابع، تایپ‌های اینترفیس را به عنوان ورودی قبول می‌کنند و هر ساختار یا تایپی متدهای اینترفیس را پیاده سازی کرده باشد می‌تواند به عنوان پارامتر ورودی به تابع ارسال شود.\nبه عنوان مثال ما در کد زیر ۲ تا تابع داریم به نام های callBreathe و callWalk که به عنوان ورودی اینترفیس animal را قبول می‌کند و ما ۲ نمونه از ساختارهای lion و dog را که متدهای اینترفیس animal را پیاده سازی کرده‌اند را به این ۲ تابع پاس دادیم.\npackage main import \"fmt\" type animal interface { breathe() walk() } type lion struct { age int } func (l lion) breathe() { fmt.Println(\"Lion breathes\") } func (l lion) walk() { fmt.Println(\"Lion walk\") } type dog struct { age int } func (l dog) breathe() { fmt.Println(\"Dog breathes\") } func (l dog) walk() { fmt.Println(\"Dog walk\") } func main() { l := lion{age: 10} callBreathe(l) callWalk(l) d := dog{age: 5} callBreathe(d) callWalk(d) } func callBreathe(a animal) { a.breathe() } func callWalk(a animal) { a.walk() } ▶ اجرای کد کپی ✖ بستن خروجی 2.4.4 چرا اینترفیس؟ # شاید برای شما این سوال پیش بیاد چرا باید از اینترفیس استفاده کنیم و مزایای آن چیست؟ ما در زیر مزایای استفاده از اینترفیس و علت اینکه چرا باید از اینترفیس استفاده کنیم را توضیح خواهیم داد.\nاینترفیس به ما در نوشتن کدهای ماژولارتر و جدا شده‌‌تر بین بخش‌های مختلف کد کمک می‌کند و همچنین می‌تواند باعث کاهش وابستگی بین بخش‌های مختلف کد شود. کد باید برای تغییر بسته، و برای توسعه باز باشد. # اصل باز و بسته بودن یا اصل Open/Closed به نظر بسیاری، اساس برنامه نویسی شی گرا را تشکیل می‌دهد. رابرت مارتین (Robert C. Martin) که در بین برنامه نویسان به عمو باب (Uncle Bob) مشهور است با عبارت: \u0026ldquo;مهم‌ترین اصل طراحی شی گرا\u0026rdquo; از این اصل یاد کرده است. ما با استفاده از اینترفیس ها میتونیم این اصل مهم رو پیاده سازی کنیم.\nبزارید چند مثال کاربردی بزنیم: فرض کنید ما چند تا سرویس اس ام اس داریم و در آینده هم ممکنه که سرویس های اس ام اس تغییر کنند و از یک ارائه دهنده دیگه خدمات بگیریم. خب در این صورت ما باید چیکار کنیم که با حذف و اضافه کردن سرویس جدید کد های ما تغییر نکنند؟ میایم یک اینترفیس به اسم مثلا Sms می نویسیم و مشخص میکنیم هر کی که میخواد از این اینترفیس استفاده کنه باید متد send_sms و هر چیزی که نیاز هستش رو پیاده سازیش کنه.\nفرض کنید شما یک برنامه نوشتید که یک لایه دیتابیس دارد و داده‌ها، با توجه به کانفیگ، در یکی از دو دیتابیس mongodb یا arangodb ذخیره ‌می‌شود. حالا اگر ما بیایم در لایه دیتابیس یک اینترفیس قرار دهیم و متدهای مربوط به تعاملات با دیتابیس را ایجاد کنیم، در برنامه‌ای که نوشتیم فقط کافیست متدهای ایترفیس استفاده شود تا با توجه به نوع کانفینگ دیتابیس، پیاده سازی متود اجرا شود. یعنی اگر ما بیایم داخل کانفیگ پروژه تنظیمات arangodb را به mongodb تغییر دهیم بدون هیچ تغییری در لایه برنامه می‌توانیم به واسطه اینترفیسی که قرار دادیم با دیتابیس mongodb تعامل داشته باشیم.\nاز اینترفیس‌ها می‌توان برای پیاده‌سازی مفهوم پلی مورفیسم در زمان اجرا استفاده کرد. که به این مفهوم RunTime Polymorphism می‌گویند. بزارید یک مثال برای توضیح فوق بزنیم:\nفرض کنید کشورهای مختلف روش‌های مختلفی برای محاسبه مالیات دارند که شما می‌توانید با استفاده از یک اینترفیس این عملیات محاسبه را انجام دهید.\ntype taxCalculator interface{ calculateTax() } در بالا ما یک اینترفیس با نام taxCalculator داریم که یک متد به نام calculateTax برای محاسبه مالیات دارد. حالا ما باید به ازای هر کشور یک ساختار داشته باشیم که این ساختارها باید متد calculateTax را با توجه شیوه محاسباتی خود پیاده سازی کرده باشند.\npackage main import \"fmt\" type taxSystem interface { calculateTax() int } type indianTax struct { taxPercentage int income int } func (i *indianTax) calculateTax() int { tax := i.income * i.taxPercentage / 100 return tax } type singaporeTax struct { taxPercentage int income int } func (i *singaporeTax) calculateTax() int { tax := i.income * i.taxPercentage / 100 return tax } type usaTax struct { taxPercentage int income int } func (i *usaTax) calculateTax() int { tax := i.income * i.taxPercentage / 100 return tax } func main() { indianTax := \u0026indianTax{ taxPercentage: 30, income: 1000, } singaporeTax := \u0026singaporeTax{ taxPercentage: 10, income: 2000, } taxSystems := []taxSystem{indianTax, singaporeTax} totalTax := calculateTotalTax(taxSystems) fmt.Printf(\"Total Tax is %d\\n\", totalTax) } func calculateTotalTax(taxSystems []taxSystem) int { totalTax := 0 for _, t := range taxSystems { totalTax += t.calculateTax() // در اینجا runtime polymorphism رخ می دهد } return totalTax } ▶ اجرای کد کپی ✖ بستن خروجی در خط زیر RunTime Polymorphism رخ داده است.\ntotalTax += t.calculateTax() //This is where runtime polymorphism happens 2.4.5 استفاده از اشاره‌گر هنگام پیاده‌سازی اینترفیس # متدها تایپ‌های گیرنده خود را به دو صورت اشاره‌گر یا مقدار می‌توانند دریافت کنند. در بالا مثال animal را داشتیم که با حالت گیرنده مقدار بود. حالا می‌خواهیم بصورت گیرنده اشاره‌گر تعریف کنیم.\n2 نکته با توجه مثالی که خواهیم زد وجود دارد:\nاگر شما برای یک تایپ تمامی متدهای اینترفیس را بصورت گیرنده مقدار تعریف کرده باشید، هر دو متغیری که یک نمونه از تایپ را بصورت اشاره‌گر و بدون اشاره‌گر تعریف کرده باشد، می‌تواند به اینترفیس animal انتصاب شود و بدون هیچ مشکلی کار کند.\nاگر شما برای یک تایپی تمامی متدهای اینترفیس را بصورت گیرنده اشاره‌گر تعریف کرده باشید فقط متغیری که یک نمونه از تایپ که با اشاره‌گر تعریف کرده باشد می‌تواند به اینترفیس انتصاب یابد.\nمثال با حالت اولی که توضیح دادیم:\npackage main import \"fmt\" type animal interface { breathe() walk() } type lion struct { age int } func (l lion) breathe() { fmt.Println(\"Lion breathes\", l) } func (l lion) walk() { fmt.Println(\"Lion walk\", l) } func main() { var a animal a = lion{age: 10} a.breathe() a.walk() a = \u0026lion{age: 5} a.breathe() a.walk() } ▶ اجرای کد کپی ✖ بستن خروجی در بالا ما یک نمونه از ساختار lion با اشاره‌گر ایجاد کردیم و مقدار age را ۵ قرار دادیم و به اینترفیس animal انتصابش کردیم و بدون هیچ مشکلی کار کرد.\nحالا برای حالت دوم به مثال زیر توجه کنید:\npackage main import \"fmt\" type animal interface { breathe() walk() } type lion struct { age int } func (l *lion) breathe() { fmt.Println(\"Lion breathes\") } func (l *lion) walk() { fmt.Println(\"Lion walk\") } func main() { var a animal a = lion{age: 10} a.breathe() a.walk() a = \u0026lion{age: 5} a.breathe() a.walk() } ▶ اجرای کد کپی ✖ بستن خروجی در واقع شما فقط در صورت استفاده از اشاره‌گر، می‌توانید یک نمونه از ساختار lion بسازید در غیر این صورت با خطا مواجه خواهید شد.\n2.4.6 پیاده سازی اینترفیس برای تایپ‌های غیر ساختار # همانطور که قبلاً گفتیم شما می‌توانید برای هر تایپی متد تعریف کنید و در اینجا هم می‌توانید متدهای یک اینترفیس را برای هر تایپی پیاده سازی کنید.\npackage main import \"fmt\" type animal interface { breathe() walk() } type cat string func (c cat) breathe() { fmt.Println(\"Cat breathes\") } func (c cat) walk() { fmt.Println(\"Cat walk\") } func main() { var a animal a = cat(\"smokey\") a.breathe() a.walk() } ▶ اجرای کد کپی ✖ بستن خروجی در بالا ما یک تایپ با نام cat از نوع رشته تعریف کردیم و سپس متدهای اینترفیس animal را برای این تایپ پیاده‌سازی کردیم.\n2.4.7 پیاده‌سازی چندتایی اینترفیس برای تایپ # شما می‌توانید برای تایپ‌های خود چندین اینترفیس مختلف استفاده کنید و متدهای این اینترفیس‌ها را پیاده سازی کنید.\nدر کد زیر ما ۲ تا اینترفیس animal و mammal داریم که داخل اینترفیس mammal یک متد با نام feed وجود دارد حالا می‌خواهیم برای ساختار lion از این اینترفیس استفاده کنیم.\npackage main import \"fmt\" type animal interface { breathe() walk() } type mammal interface { feed() } type lion struct { age int } func (l lion) breathe() { fmt.Println(\"Lion breathes\") } func (l lion) walk() { fmt.Println(\"Lion walk\") } func (l lion) feed() { fmt.Println(\"Lion feeds young\") } func main() { var a animal l := lion{} a = l a.breathe() a.walk() var m mammal m = l m.feed() } ▶ اجرای کد کپی ✖ بستن خروجی 2.4.8 مقدار صفر یا پیش‌فرض اینترفیس # اینترفیس هم همانند سایر تایپ‌ها یک مقدار پیش‌فرض دارد که این مقدار پیش‌فرض nil هست.\npackage main import \"fmt\" type animal interface { breathe() walk() } func main() { var a animal fmt.Println(a) } ▶ اجرای کد کپی ✖ بستن خروجی 2.4.9 بدنه اینترفیس # اینترفیس دارای یک بدنه است که از دو بخش تشکیل شده تایپ و مقدار وقتی شما یک تایپی را به اینترفیس منتصب می‌کنید در بخش مقدار نوع و مقدار تایپی که منتصب کردید به اینترفیس در دسترس است.\ngraph TD A[Interface Variable] --\u003e B(Interface Type) \u0026 C(Interface Value) C --\u003e D(تایپ داخلی) \u0026 E(مقدار داخلی) اگر بخواهیم با توجه به مثال ساختار lion توجه کنیم به شکل زیر می‌شود:\ngraph TD A[Interface Variable] --\u003e B(Interface Type) \u0026 C(Interface Value) C --\u003e D(lion) \u0026 E(\"{age: 10}\") حالا در زیر مثالی زدیم با استفاده از T% و v% نوع و مقدار را می‌توانید چاپ کنیم.\npackage main import \"fmt\" type animal interface { breathe() walk() } type lion struct { age int } func (l lion) breathe() { fmt.Println(\"Lion breathes\") } func (l lion) walk() { fmt.Println(\"Lion walk\") } func main() { var a animal a = lion{age: 10} fmt.Printf(\"Underlying Type: %T\\n\", a) fmt.Printf(\"Underlying Value: %v\\n\", a) } ▶ اجرای کد کپی ✖ بستن خروجی 2.4.10 دسترسی به مقادیر داخلی اینترفیس # برای اینکه بتوانید به مقادیر داخلی اینترفیس دسترسی پیدا کنید ۲ تا روش وجود دارد‌:\nبا استفاده از Type Assertion با استفاده از Switch 2.4.10.1 با استفاده از Type Assertion # برای اینکه بتوانید به مقدار داخلی یک اینترفیس دسترسی پیدا کنید باید جلوی متغیر از نوع اینترفیس یک نقطه . و در ادامه داخل پرانتز تایپ مورد نظری که قصد دارید تشخیص دهید را باید قرار دهید.\nval, ok := i.({type}) در بالا زمانیکه Type Assertion انجام می‌دهید ۲ تا متغیر دارید که اولیش مقدار است و دومیش تایید می‌کند تایپی که به اینترفیس دادید همان است (منظور متغیر ok است که مقدار آن از نوع bool است)\nاگر هنگام Type Assertion شما وضعیت متغیر ok را بررسی نکنید با خطای panic مواجه خواهید شد. package main import \"fmt\" type animal interface { breathe() walk() } type lion struct { age int } func (l lion) breathe() { fmt.Println(\"Lion breathes\") } func (l lion) walk() { fmt.Println(\"Lion walk\") } type dog struct { age int } func (d dog) breathe() { fmt.Println(\"Dog breathes\") } func (d dog) walk() { fmt.Println(\"Dog walk\") } func main() { var a animal a = lion{age: 10} print(a) } func print(a animal) { l, ok := a.(lion) if ok { fmt.Printf(\"Age: %d\\n\", l.age) } } ▶ اجرای کد کپی ✖ بستن خروجی در بالا ما تایپ lion را به اینترفیس animal پاس دادیم و بررسی کردیم آیا تایپ lion از نوع تایپ داخلی اینترفیس animal هست یا خیر.\nl := a.(lion) 2.4.10.2 با استفاده از Switch # شما با استفاده از switch می‌توانید تایپ اینترفیس را تشخیص دهید.\npackage main import \"fmt\" type animal interface { breathe() walk() } type lion struct { age int } func (l lion) breathe() { fmt.Println(\"Lion breathes\") } func (l lion) walk() { fmt.Println(\"Lion walk\") } type dog struct { age int } func (d dog) breathe() { fmt.Println(\"Dog breathes\") } func (d dog) walk() { fmt.Println(\"Dog walk\") } func main() { var a animal a = lion{age: 10} print(a) } func print(a animal) { switch v := a.(type) { case lion: fmt.Println(\"Type: lion\") case dog: fmt.Println(\"Type: dog\") default: fmt.Printf(\"Unknown Type %T\", v) } } ▶ اجرای کد کپی ✖ بستن خروجی 2.4.11 اینترفیس خالی # شما می‌توانید اینترفیس بصورت خالی و بدون متد در هرجایی از کد خود استفاده کنید و هر تایپی را می‌توانید به این اینترفیس انتصاب دهید. به عنوان مثال در زیر یک تابع نوشتیم که به عنوان پارامتر ورودی یک اینترفیس خالی می‌گیرد و مقدار این پارامتر را چاپ می‌کند.\npackage main import \"fmt\" func main() { test(\"thisisstring\") test(\"10\") test(true) } func test(a interface{}) { fmt.Printf(\"(%v, %T)\\n\", a, a) } ▶ اجرای کد کپی ✖ بستن خروجی توجه کنید اینترفیس خالی خیلی کاربردی هست و usecase‌های مختلفی دارد.\n"},{"id":28,"href":"/chapter-2/type-embedding/","title":"2.5 جاسازی تایپ (type embedding)","section":"فصل دوم: مکانیزم‌های زبان","content":"در زبان گو برای ساختار و اینترفیس امکان جاسازی تایپ وجود دارد. یعنی شما می‌توانید یک ساختار یا یک اینترفیس را داخل ساختار دیگر جاسازی کنید و یا داخل اینترفیس یک اینترفیس دیگر را جاسازی کنید.\ntype animal interface { breathe() walk() } type human interface { animal speak() } type base struct { num int } type container struct { human base str string } در بالا ما اینترفیس animal را در اینترفیس human جاسازی کردیم و در ادامه داخل ساختار container اینترفیس human و ساختار base را جاسازی کردیم.\nبا اینکار ما به متدهای اینترفیس human و animal و همچنین به فیلدهای ساختار base دسترسی داریم و می توانیم از متدها و فیلدهای جاسازی با استفاده از ساختار container استفاده کنیم.\nتوجه کنید شما نمی‌توانید یک ساختار را داخل اینترفیس جاسازی کنید. 2.5.1 جاسازی ساختار # شما می‌توانید هر چندتا ساختاری که دارید داخل یک ساختاری جاسازی و به هرکدام از فیلدهای ساختارهای جاسازی شده دسترسی دارید.\nبه مثال زیر توجه کنید :\npackage main import \"fmt\" type base struct { num int } func (b base) describe() string { return fmt.Sprintf(\"base with num=%v\", b.num) } type container struct { base str string } func main() { co := container{ base: base{ num: 1, }, str: \"some name\", } fmt.Printf(\"co={num: %v, str: %v}\\n\", co.num, co.str) fmt.Println(\"also num:\", co.base.num) fmt.Println(\"describe:\", co.describe()) type describer interface { describe() string } var d describer = co fmt.Println(\"describer:\", d.describe()) } ▶ اجرای کد کپی ✖ بستن خروجی 2.5.1.1 جاسازی اینترفیس در ساختار # همانطور که گفتیم یک اینترفیس می‌‌تواند داخل یک ساختار جاسازی شود و همه متدهای اینترفیس به واسطه ساختار مورد قابل دسترس است و می‌توانید هر یک از متدها را استفاده کنید.\npackage main import \"fmt\" type animal interface { breathe() walk() } type dog struct { age int } func (d dog) breathe() { fmt.Println(\"Dog breathes\") } func (d dog) walk() { fmt.Println(\"Dog walk\") } type pet1 struct { a animal name string } type pet2 struct { animal name string } func main() { d := dog{age: 5} p1 := pet1{name: \"Milo\", a: d} fmt.Println(p1.name) // p1.breathe() // p1.walk() p1.a.breathe() p1.a.walk() p2 := pet2{name: \"Oscar\", animal: d} fmt.Println(p1.name) p2.breathe() p2.walk() p1.a.breathe() p1.a.walk() } ▶ اجرای کد کپی ✖ بستن خروجی 2.5.2 جاسازی اینترفیس # شما همانند ساختارها می‌توانید اینترفیس‌ها را جاسازی کنید و فقط کافیه اینترفیس‌ها را داخل دیگر اینترفیس‌ها جاسازی کنید تا متدهای اینترفیس‌های جاسازی شده دسترسی داشته باشید.\npackage main import \"fmt\" type animal interface { breathe() walk() } type human interface { animal speak() } type employee struct { name string } func (e employee) breathe() { fmt.Println(\"Employee breathes\") } func (e employee) walk() { fmt.Println(\"Employee walk\") } func (e employee) speak() { fmt.Println(\"Employee speaks\") } func main() { var h human h = employee{name: \"John\"} h.breathe() h.walk() h.speak() } ▶ اجرای کد کپی ✖ بستن خروجی یکی دیگه از مثال‌هایی که می‌توانیم بزنیم پکیج io اینترفیس ReadWriter هست که ۲ تا اینترفیس Reader و Writer داخل این اینترفیس جاسازی شده است.\n"},{"id":29,"href":"/chapter-2/error-handling/","title":"2.6 مدیریت خطاها","section":"فصل دوم: مکانیزم‌های زبان","content":"در این بخش قصد داریم به مقوله مدیریت خطاها در زبان گو بپردازیم و اینکه چطور می‌توانید خیلی ساده خطاها را مدیریت کنید. مدیریت خطا در زبان گو با سایر زبان‌ها متفاوت هست و شما با چیزی به نام try-catch یا try-except سروکار ندارید.\nمدیریت خطاها در زبان گو به دو روش صورت می گیرد:\nبا استفاده از پیاده سازی اینترفیس error که یک روش مرسوم جهت مدیریت و نمایش خطا است. با استفاده از panic/recover که در فصل اول توضیح دادیم. 2.6.1 مدیریت خطا با اینترفیس error # روش زبان گو برای مقابله با خطا این است که به صراحت، شما خطا را به عنوان خروجی تابع برگردانید. برای این کار کافیست اگر میخواهید خطای هر تابع را مدیریت کنید، اینترفیس error را در خروجی تابع بگذارید.\nhttps://pkg.go.dev/builtin#error\ntype error interface { Error() string } به مثال زیر توجه کنید:\npackage main import ( \"fmt\" \"os\" ) func main() { file, err := os.Open(\"non-existing.txt\") if err != nil { fmt.Println(err) } else { fmt.Println(file.Name() + \"opened succesfully\") } } ▶ اجرای کد کپی ✖ بستن خروجی در کد بالا ما با استفاده از تابع Open که در پکیج os وجود دارد فایل non-existing.txt را باز کرده‌ایم. اگر دقت کنید این تابع ۲ تا خروجی دارد یکی ساختار File هست و دیگری خطا هست. در ادامه ما با استفاده شرط آمدیم چک کردیم اینترفیس err آیا خالی است یا خیر؟ در کد بالا این اینترفیس خالی nil نیست و ما خطا را چاپ کردیم.\nاین روش به طور گسترده در پکیج‌های داخلی و شخص ثالث گو استفاده می‌شود.\nدقت کنید اینترفیس error یک متد دارد به نام ()Error که این متد متن خطا را بصورت رشته بر می‌گرداند.\nآیا همیشه نیاز است خطاها را مدیریت کنیم؟\nشاید بپرسید آیا واقعا نیاز هست ما همیشه خطاها را مدیریت کنیم؟ در جواب این سوال می توانیم بگیم هم بله و هم خیر\nعلت اینکه می‌گوییم بله از این بابت هست اگر خطاها بدرستی مدیریت نشود احتمال اینکه با panic در هر جا مواجه شویم خیلی زیاد است. بخصوص خطای nil pointer . پس بهتر است تا جایی که می‌توانید خطاها را بدرستی مدیریت کنید و همچنین اگر جایی احتمال می‌دهید panic پیش میاد بهتر است از recover استفاده کنید تا پایداری برنامه را بالا ببرید. علت اینکه می‌گوییم خیر از این بابت هست که در زبان گو، هیچ اجباری برای مدیریت خطاها وجود ندارد و گاهی اوقات می‌توانید خطاها را نادیده بگیرید که با استفاده از ـ امکان پذیر است. 2.6.2 مزایای استفاده از error به عنوان یک تایپ در زبان گو # به شما این امکان را می‌دهد کنترل بیشتری رو خطاها داشته باشید و تو هر قدم می‌توانید خطاها را بررسی کنید. جلوگیری از try-catch جهت مدیریت خطا (دقت کنید در سایر زبان ها باید تا جایی که ممکن است از try-catch کمتر استفاده کنید) 2.6.3 روش‌های مختلف برای ایجاد یک خطا # در زبان گو شما می‌توانید در هرجای کد خود یک خطا با محتوای مناسب ایجاد کنید و یا اینکه برخی از خطاهای برخی از کتابخانه‌ها را هم‌پوشانی کنید.\n1. با استفاده (\u0026ldquo;متن خطا\u0026rdquo;)errors.New\npackage main import ( \"errors\" \"fmt\" ) func main() { sampleErr := errors.New(\"error occured\") fmt.Println(sampleErr) } ▶ اجرای کد کپی ✖ بستن خروجی در بالا ما با استفاده از تابع New پکیج errors یک خطا با متن مشخص ایجاد کردیم و متغیر sampleErr از نوع اینترفیس error می‌باشد که می‌توانید در هر جای کد خود مدیریتش کنید.\n2. با استفاده از (\u0026ldquo;error is %s\u0026rdquo;, \u0026ldquo;some error message\u0026rdquo;)fmt.Errorf\nشما با استفاده از تابع Errorf در پکیج fmt می‌توانید یک خطا ایجاد کنید و توجه کنید این متن خطا قابل فرمت است و حتی شما می‌توانید متن خطا را داینامیک کنید.\npackage main import ( \"fmt\" ) func main() { msg := \"database connection issue\" sampleErr := fmt.Errorf(\"Err is: %s\", msg) fmt.Println(sampleErr) } ▶ اجرای کد کپی ✖ بستن خروجی 2.6.4 ایجاد خطا پیشرفته # در مثال زیر ما قصد داریم یک خطای پیشرفته ایجاد کنیم و آن را به آسانی مدیریت کنیم.\nویژگی‌های خطای پیشرفته :\nدر زیر inputError یک نوع ساختار است که داخلش ۲ تا فیلد message و missingField دارد و همچنین دارای یک متد ()Error است. شما می‌توانید به این ساختار خطای پیشرفته، متدهای بیشتری اضافه کنید و همچنین گسترش دهید که به عنوان مثال ما متد getMissingFields را برای گرفتن محتوای missingField اضافه کردیم. ما با استفاده از type assertion می‌توانیم اینترفیس error را به inputError تبدیل کنیم. package main import \"fmt\" type inputError struct { message string missingField string } func (i *inputError) Error() string { return i.message } func (i *inputError) getMissingField() string { return i.missingField } func main() { err := validate(\"\", \"\") if err != nil { if err, ok := err.(*inputError); ok { fmt.Println(err) fmt.Printf(\"Missing Field is %s\\n\", err.getMissingField()) } } } func validate(name, gender string) error { if name == \"\" { return \u0026inputError{message: \"Name is mandatory\", missingField: \"name\"} } if gender == \"\" { return \u0026inputError{message: \"Gender is mandatory\", missingField: \"gender\"} } return nil } ▶ اجرای کد کپی ✖ بستن خروجی 2.6.5 نادیده گرفتن خطاها # شما در هرجای کد خود با استفاده از _ می توانید متغیر خطا را نادیده بگیرید و آن را مدیریت نکنید. هر چند در بالا گفتیم نادیده گرفتن خطاها عوارضی در بر دارد و ما همیشه، تاکید می‌کنیم تا جایی که ممکن است خطاها را مدیریت کنید.\npackage main import ( \"fmt\" \"os\" ) func main() { file, _ := os.Open(\"non-existing.txt\") fmt.Println(file) } ▶ اجرای کد کپی ✖ بستن خروجی در بالا ما خطای تابع Open را نادیده گرفتیم و مقدار file را چاپ کردیم مقدار چاپ شده nil است چون تایپ خروجی با اشاره‌گر است و قطعا مقدار خالی بودش nil است.\n2.6.6 هم‌پوشانی (Wrapping) خطا # در زبان گو، شما می‌توانید خطا را با خطا و پیغام مشخصی هم پوشانی کنید. حالا هم‌پوشانی خطا چیست؟\nبزارید با یک مثال ساده توضیح دهیم، فرض کنید شما تو لایه دیتابیس خود یکسری خطاها از سمت دیتابیس دریافت می‌کنید به عنوان مثال اگر شما سندی را در دیتابیس monogdb پیدا نکنید با خطای no documents found مواجه خواهید شد. شما در اینجا نمی‌توانید همان متن خطا را به کاربر نمایش دهید بلکه باید آن خطا را با یک متن خطای مناسب هم پوشانی کنید.\npackage main import ( \"fmt\" ) type notPositive struct { num int } func (e notPositive) Error() string { return fmt.Sprintf(\"checkPositive: Given number %d is not a positive number\", e.num) } type notEven struct { num int } func (e notEven) Error() string { return fmt.Sprintf(\"checkEven: Given number %d is not an even number\", e.num) } func checkPositive(num int) error { if num \u003c 0 { return notPositive{num: num} } return nil } func checkEven(num int) error { if num%2 != 0 { return notEven{num: num} } return nil } func checkPostiveAndEven(num int) error { if num \u003e 100 { return fmt.Errorf(\"checkPostiveAndEven: Number %d is greater than 100\", num) } err := checkPositive(num) if err != nil { return err } err = checkEven(num) if err != nil { return err } return nil } func main() { num := 3 err := checkPostiveAndEven(num) if err != nil { fmt.Println(err) } else { fmt.Println(\"Givennnumber is positive and even\") } } ▶ اجرای کد کپی ✖ بستن خروجی 2.6.7 Unwrap خطاها # در بخش بالا شما با نحوه هم‌پوشانی کردن آشنا شدید، اما این امکان را داریم خطاها را unwrap کنیم با استفاده از یک تابع در پکیج errors به نام Unwrap.\nfunc Unwrap(err error) error منظورمان از unwrap کردن این است که، اگر خطایی را هم پوشانی کرده باشیم با استفاده unwrap می‌توانیم آن خطا را ببینیم.\nimport ( \"errors\" \"fmt\" ) type errorOne struct{} func (e errorOne) Error() string { return \"Error One happened\" } func main() { e1 := errorOne{} e2 := fmt.Errorf(\"E2: %w\", e1) e3 := fmt.Errorf(\"E3: %w\", e2) fmt.Println(errors.Unwrap(e3)) fmt.Println(errors.Unwrap(e2)) fmt.Println(errors.Unwrap(e1)) } ▶ اجرای کد کپی ✖ بستن خروجی در کد بالا متغیر e2 خطای داخل ساختار e1 را هم‌پوشانی کرده و سپس متغیر e3 خطای متغیر e2 را هم‌پوشانی می‌کند. در نهایت با تابع Unwrap متن خطای اصلی را چاپ کردیم.\n2.6.8 بررسی دو خطا اگر برابر هستند # در زبان گو شما می‌توانید ۲ اینترفیس را با هم مقایسه کنید و این مقایسه به وسیله اپراتور == یا با استفاده از تابع Is در پکیج errors صورت می‌گیرد. اساساً دو مقوله برای این مقایسه در نظر گرفته خواهد شد:\nfunc Is(err, target error) bool هر دو این اینترفیس‌ها به یک نوع تایپ منصوب شده باشند. مقدار داخلی اینترفیس‌ها باید با هم برابر باشند یا اینکه هر دو (nil) باشند. package main import ( \"errors\" \"fmt\" ) type errorOne struct{} func (e errorOne) Error() string { return \"Error One happended\" } func main() { var err1 errorOne err2 := do() if err1 == err2 { fmt.Println(\"Equality Operator: Both errors are equal\") } if errors.Is(err1, err2) { fmt.Println(\"Is function: Both errors are equal\") } } func do() error { return errorOne{} } ▶ اجرای کد کپی ✖ بستن خروجی "},{"id":30,"href":"/chapter-2/casting-vs-conversion/","title":"2.7 فرق casting با conversion","section":"فصل دوم: مکانیزم‌های زبان","content":" 2.7.1 conversion # conversion زمانی اتفاق می‌افتد که ما مقدار یک داده را به تایپ دیگری اختصاص دهیم.\nزبان‌هایی که Static Type هستند از این مقوله بطور ضمنی پشتیبانی می‌کنند ولی در زبان گو کمی متفاوت است. اگر شما بخواهید conversion انجام دهید باید بصورت دستی اینکار را انجام دهید. چون کامپایلر گو برخی از عناوین را بطور صریح در نظر می‌گیرد.\n2.7.2 type casting # در زبان گو، چیزی به نام type casting بطور کلی وجود ندارد. پس بهتر است در خصوص این مورد داخل داکیومنت‌ها یا سایت‌های مختلف نگردید. برای درک بهتر این موضوع بهتره https://go.dev/ref/spec#Conversions را مطالعه کنید.\n2.7.3 مثال conversion # در زیر یک مثال در خصوص conversion زدیم تا با این مقوله آشنا شوید:\npackage main import \"fmt\" func main() { var totalsum int = 846 var number int = 19 var avg float32 avg = float32(totalsum) / float32(number) fmt.Printf(\"Average = %f\\n\", avg) } ▶ اجرای کد کپی ✖ بستن خروجی "},{"id":31,"href":"/chapter-3/","title":"فصل سوم: همزمانی (concurrency)","section":"صفحه اصلی","content":"در این فصل به صورت عمیق به مباحث همزمانی در زبان گو پرداخته شده است که شامل عناوین زیر می‌باشد.\n۳.۱ آشنایی با مبحث همزمانی. ۳.۲ گوروتین چیست. ۳.۳ کالبدشکافی پکیج sync و تشریح انواع و توابع کاربردی آن برای مباحث همگام‌سازی همزمانی. ۳.۴ آشنایی با پکیج atomic و کاربردهای آن. ۳.۵ آشنایی با Data Race و روش‌های پیشگیری از آن. ۳.۶ کانال‌ها و روش‌ اشتراک‌گذاری داده از طریق آن. ۳.۷ آشنایی با کلید‌واژه select و بررسی کاربردهای متنوع آن. ۳.۸ پکیج context و اهمیت آن. ۳.۹ تکنیک‌های مورد استفاده در همزمانی. ۳.۱۰ الگوهای متداول همزمانی و کاربردهای آن. "},{"id":32,"href":"/chapter-3/go-concurrency/","title":"3.1 آشنایی با همزمانی","section":"فصل سوم: همزمانی (concurrency)","content":"\nنرم‌افزارهای بزرگ به منظور توسعه راحت‌تر و قابلیت نگهداری بیشتر و همچنین پرهیز از تکرار از ده‌ها زیر برنامه کوچک‌تر تشکیل می‌شوند که به آنها توابع می‌گوییم و تمامی این زیربرنامه‌های کوچک در کنار هم اما به صورت مستقل عملکرد کلی برنامه بزرگتر را شکل می‌دهند. به عنوان مثال یک وب سرور درخواست‌های ارسال شده از سمت مرورگرها را مدیریت می کند و در پاسخ صفحات وب HTML را آماده کرده و ارائه می‌دهد و هر در خواست از طریق فراخوانی چندین برنامه کوچک رسیدگی می شود تا نتیجه را به مرورگر برگردانده شود.\nدر طول آماده‌سازی نتیجه‌‌ی هر یک از این زیربرنامه‌ها، به دلایل گوناگون از جمله تاخیر(های) شبکه، IO و \u0026hellip; اجرای زیربرنامه‌ها برای مدتی هرچند کوتاه متوقف می‌شود و این وقفه‌ها، زمان پاسخگویی نرم‌افزارها را طولانی‌تر می‌کنند؛ گاهی‌اوقات اولویت ترتیب اجرا و وابستگی/استقلال زیربرنامه‌ها، به توسعه‌دهنده این اجازه را می‌دهد که اجرای بعضی از زیربرنامه‌ها را از حالت «صف/ترتیبی» به حالت «موازی» تغییر دهد، لذا به منظور استفاده بهینه‌ از منابع و افزایش عملکرد کلی نرم‌افزار از مقوله‌ای به نام همزمانی استفاده می کنند.\nیکی از نقاط قوت در زبان Go سهولت و امنیت استفاده از همزمانی با کمک گوروتین و کانال‌هاست که در ادامه‌ی این فصل به‌طور جامع، مباحث مربوط به آن را بررسی کرده و روش پیاده‌سازی همزمانی در برنامه‌های زبان Go را آموزش خواهیم داد.\n۳.۱.۱ فرق بین همزمانی (concurrency) و موازی (parallelism) # موازی‌سازی (parallelism) یعنی چندین فرآیند به‌طور همزمان توسط چند threads یا به طور دقیق‌تر هسته پردازشی انجام شود و این هسته‌ها می‌توانند از طریق حافظه اشتراکی با هم ارتباط برقرار کنند و در نهایت نتایج فرآیندها پس از پایان با هم ترکیب می‌شوند. لذا داشتن حداقل دو یا چند هسته پردازش فیزیکی از الزامات پیاده‌سازی موازی است.\nدر مقابل برنامه‌های همزمان الزاماً به‌صورت موازی اجرا نمی‌شوند و بیشتر در مورد ساختار یک برنامه است تا شیوه دقیق اجرای آن برنامه یا زیربرنامه. همزمانی به گونه‌ای است که دو یا چند کار مختلف ممکن است به طور همزمان در حال پیشرفت و انجام باشند. و در نهایت این فرآیندهای همزمان به نتایج مختلفی ختم می شوند.\nحال می‌خواهیم با یک مثال ملموس این دو مبحث را باز کنیم تا به درکی دقیق‌تر از تفاوت این‌ دو برسیم.\nتصور کنید که برنامه بزرگ ما یک کافی‌شاپ است که صفی از مشتریان سفارش خود را داده و منتظر دریافت آن می‌شوند.\nهمانطور که از تصویر بالا متوجه می‌شوید مشتری دوم تا پایان آماده‌سازی سفارش مشتری اول باید منتظر بماند لذا به منظور بالا بردن کارایی کلی سیستم می‌توان از پردازش موازی بهره برد به این منظور با استخدام یک فرد دیگر و یک دستگاه قهوه سازی دیگر پردازش مشتریان را به صورت موازی انجام خواهیم داد.\nچنانچه پیشتر هم گفته شد ما با محدودیت منابع روبرو هستیم و برای بالا بردن تعداد پردازش‌های موازی نیازمند خرید دستگاه قهوه ساز جدید و استخدام نیروی جدید هستیم. تا به اینجا هدف این بود که مشکل انتظار طولانی مدت مشتریان در صف را از طریق پردازش موازی حل کنیم اما این کار بسیار پرهزینه است راه حل دیگری هم وجود دارد که همان همزمانی است. بدیهی است وقفه ایجاد شده برای آماده‌سازی سفارش تنها محدود به دستگاه قهوه‌ساز نیست و بخشی از آن مربوط به زمان سپری شده برای دریافت سفارش از مشتریان توسط باریستا و مراجعه به دستگاه برای آماده‌سازی آن می‌شود لذا می‌توان با استخدام یک نیروی جدید بدون خرید دستگاه قهوه‌ساز جدید سفارش مشتریان را به صورت جداگانه پردازش کرده و به‌جای صف سفارش یک صف انتظار آماده‌سازی تشکیل داد به این ترتیب مدت زمان انتظار افراد برای دریافت سفارش کوتاه تر شده و عملکرد کلی سیستم افزایش می‌یابد.\nالبته هیچ چیز ما را محدود به پردازش سریال در حالت همزمانی نمی‌کند یعنی در صورت تشکیل صف طولانی می توانیم عملکرد موازی را اینجا هم اعمال کنیم به تصویر پایین دقت کنید.\nهمانطور که مشاهده می‌شود در پردازش همزمان ما با تغییر ساختار به صورت موازی یا غیرموازی عملکرد کلی سیستم را افزایش داده‌ایم.\nنکته: تا به اینجا بارها برروی عملکرد کلی سیستم تأکید نموده‌ایم. این مسئله از آنجا حائز اهمیت است که خواننده باید به درکی درست از مقوله همزمانی برسد. ما در همزمانی سرعت پردازش یک درخواست را افزایش نمی‌دهیم در حقیقت به دلیل پیچیده‌تر شدن پیاده‌سازی و روند اجرا، زمان پردازش یک درخواست منحصر به فرد طولانی‌تر هم می‌شود اما آنچه در مبحث همزمانی بهبود می‌یابد عملکرد کلی سیستم است. لذا استفاده از همزمانی تنها در صورتی می‌تواند به بهبود کارایی یک سیستم نرم‌افزاری منجر شود که صفی از درخواست‌ها تشکیل شده باشد و تأخیرات مختلف مانع از پردازش بی‌درنگ درخواست‌ها در اکثر مواقع نشود لذا با استفاده از پیاده‌سازی همزمانی از منابع سیستم در زمان انتظار درخواست‌ها به صورت بهینه استفاده خواهد شد.\nدر زبان Go با استفاده از متغیرهای محیطی GOMAXPROCS در کنار همزمانی از موازی‌سازی (parallelism) هم استفاده می‌شود. هرچند بطور پیش فرض برنامه‌ای که با زبان گو نوشته می‌شود از تمامی هسته‌های CPU استفاده می‌کند ولی شما می‌توانید با GOMAXPROCS تعداد هسته‌ها را محدود کنید. لازم به ذکر است که در زبان Go شما به طور مستقیم نمی‌توانید اجرای موازی زیربرنامه‌ای را به کامپایلر دیکته کنید و تصمیم‌گیری در این مورد به عهده Go Runtime Scheduler است.\n۳.۱.۲ توضیح مختصر در خصوص Go Runtime Scheduler # در زبان گولنگ نحوه اجرا و مدیریت گوروتین ها در سطح زبان انجام می شود، بر خلاف برخی زبان ها که مدیریت و اجرای ترد ها بر عهده سیستم عامل است.\nنحوه اجرای گوروتین ها چگونه است؟ در قدم اول گوروتین ها وارد یک صف به اسم Global run queue می شوند. سپس Go run scheduler بر اساس تعداد هسته های لاجیکال، از سیستم عامل ترد می گیرد. سپس گوروتین ها‌را بین ترد های دریافت شده تقسیم می کند تا اجرا شوند.\nنکته: همانطور که گفته شد، شما می توانید تعداد هسته هایی که گولنگ می تواند استفاده کند را به‌صورت دستی تنظیم کنید. توجه داشته باشید خود گولنگ به‌صورت پیشفرض از قدرت تمامی هسته ها استفاده می کند.\n"},{"id":33,"href":"/chapter-3/goroutine/","title":"3.2 گوروتین (goroutine)","section":"فصل سوم: همزمانی (concurrency)","content":"گوروتین ها را می توان به عنوان یک thread سبک در نظر گرفت که بصورت مستقل می توانند همزمان با سایر گوروتین های دیگر کارها را انجام دهند. و همچنین گوروتین ها می توانند به واسطه کانال داده ها را بین هم به اشتراک گذاشته و منتقل کنند.\nحداکثر اندازه stack یک گوروتین در زبان گو ۱ گیگابایت می باشد.\nvar maxstacksize uintptr = 1 \u0026lt;\u0026lt; 20 // enough until runtime.main sets it for real if newsize \u0026gt; maxstacksize || newsize \u0026gt; maxstackceiling { if maxstacksize \u0026lt; maxstackceiling { print(\u0026quot;runtime: goroutine stack exceeds \u0026quot;, maxstacksize, \u0026quot;-byte limit\\n\u0026quot;) } else { print(\u0026quot;runtime: goroutine stack exceeds \u0026quot;, maxstackceiling, \u0026quot;-byte limit\\n\u0026quot;) } print(\u0026quot;runtime: sp=\u0026quot;, hex(sp), \u0026quot; stack=[\u0026quot;, hex(gp.stack.lo), \u0026quot;, \u0026quot;, hex(gp.stack.hi), \u0026quot;]\\n\u0026quot;) throw(\u0026quot;stack overflow\u0026quot;) } در زیر با استفاده از کلمه کلیدی go یک نمونه گوروتین ایجاد کردیم و توجه کنید شما فقط توابع را می توانید به صورت همزمان اجرا کنید.\ngo functionName(parameters) به عنوان مثال :\npackage main import ( \"fmt\" \"time\" ) func main() { go start() fmt.Println(\"Started\") time.Sleep(1 * time.Second) fmt.Println(\"Finished\") } func start() { fmt.Println(\"In Goroutine\") } ▶ اجرای کد کپی ✖ بستن خروجی در کد فوق ما تابع ()start را توسط کلمه کلیدی go داخل گوروتین قرار دادیم و این تابع بصورت مستقل از تابع main اجرا شد. اما این وسط یک نکته ای وجود دارد. همانطور که گفتیم تابع اصلی جهت اجرا برنامه های زبان گو تابع main می باشد و اگر شما تابعی را توسط گوروتین از main جدا کنید ممکن است فرآیندهای داخل تابع main زود اتمام شود و شما خروجی تابعی که داخل گوروتین گذاشتید را نبینید.\nما در کد بالا با استفاده از تابع Sleep پکیج time یک وقفه ۱ ثانیه گذاشتیم و این وقفه باعث شد تا عملیات داخل تابع ()start تمام شود و خروجی نمایش داده شود.\nخب حالا بزارید مثال فوق را بدون وقفه تست کنیم :\npackage main import ( \"fmt\" ) func main() { go start() fmt.Println(\"Started\") fmt.Println(\"Finished\") } func start() { fmt.Println(\"In Goroutine\") } ▶ اجرای کد کپی ✖ بستن خروجی در خروجی بالا هرگز پیغام داخل تابع ()start چاپ نمی شود.\nIn Goroutine علت اصلی این اتفاق این است که تابع main خودش داخل یک گوروتین اجرا می شود و زمانیکه شما یک تابع دیگری را داخل گوروتین قرار می دهید تا لحظه ای که تابع برای اجرا برنامه ریزی شود برنامه اتمام می شود.\n3.2.1 گوروتین تابع main # تابع main را وقتی می توانید ایجاد کنید که نام پکیج شما main و گوروتین اصلی شما main باشد. همه گوروتین ها از تابع main شروع می شوند و گوروتین ها بطور همزمان باز می توانند سایر گوروتین ها را اجرا کنند.\nزمانیکه شما تابع main را فراخوانی می کنید بخش اصلی و شروع برنامه شما است. و اگر تابع main شما به هر دلیلی متوقف شود یا اتمام شود سایر گوروتین ها از بین می روند.\nگوروتین ها چیزی به نام parent یا child ندارند. زمانیکه شما یک گوروتین را اجرا می کنید این گوروتین در کنار سایر گوروتین ها اجرا می شود و کارش را انجام می دهد. زمانی کار یک گوروتین تمام می شود که تابع بازگشت (return) داشته باشد.\nبزارید یک مثال بزنیم تا ببینید چیزی به نام parent یا child برای گوروتین نداریم :\npackage main import ( \"fmt\" \"time\" ) func main() { go start() fmt.Println(\"Started\") time.Sleep(1 * time.Second) fmt.Println(\"Finished\") } func start() { go start2() fmt.Println(\"In Goroutine\") } func start2() { fmt.Println(\"In Goroutine2\") } ▶ اجرای کد کپی ✖ بستن خروجی در کد بالا داخل تابع main ما تابع start را با گوروتین اجرا کردیم و داخل تابع start تابع start2 را با گوروتین اجرا کردیم. این ۲ تابع start و start2 در کنار هم اجرا می شود و در نهایت کارشان اتمام می شود و هیچ کدام منتظر دیگری نخواهد بود.\n3.2.2 ایجاد گوروتین چندتایی # شما می توانید n تا گوروتین بطور همزمان در کنار هم اجرا کنید, در زیر یک مثال زدیم ببینید :\npackage main import ( \"fmt\" \"time\" ) func execute(id int) { fmt.Printf(\"id: %d\\n\", id) } func main() { fmt.Println(\"Started\") for i := 0; i \u003c 10; i++ { go execute(i) } time.Sleep(time.Second * 2) fmt.Println(\"Finished\") } ▶ اجرای کد کپی ✖ بستن خروجی در کد فوق ما یک حلقه قرار دادیم از i برابر ۰ تا ۱۰ که داخلش تابع execute را ۱۰ بار اجرا می کند. و هربار اجرا می شود خروجی های مختلفی دارد و ترتیبی درست نخواهید علت این اتفاق این است بطور همزمان اجرا می شوند در کنار هم و هرکدام از گوروتین ها زودتر کارش تمام شود خروجی را نمایش می دهد. به همین دلیل ترتیب درستی نخواهد داشت.\n3.2.3 زمانبندی گوروتین ها # زمانیکه یک برنامه گو اجرا می شود. go runtime رشته های (threads) سیستم عامل را راه اندازی می کند که معادل تعداد CPU های logical قابل استفاده برای فرآیند فعلی است. هر یک از logical CPU ها یک هسته مجازی دارد.\nvirtual_cores = x*number_of_physical_cores در کد بالا x برابر است با تعداد thread ها به ازای هر هسته از CPU\nدر گو ما یک تابع به نام NumCPU داخل پکیج runtime داریم که می توانید تعداد logical Proccessors موجود برای برنامه گو را ببینید.\npackage main import ( \"fmt\" \"runtime\" ) func main() { fmt.Println(runtime.NumCPU()) } ▶ اجرای کد کپی ✖ بستن خروجی روی سیستم من عدد 8 را چاپ کرد یعنی سیستم من ۴ هسته که هر هسته دارای ۲ threads است. که قابل استفاده برای برنامه گو روی سیستم من می باشد.\n"},{"id":34,"href":"/chapter-3/go-sync-package/","title":"3.3 پکیج sync","section":"فصل سوم: همزمانی (concurrency)","content":"پکیج sync توی گو مثل یک جعبه‌ابزار تخصصی برای همگام‌سازی (synchronize) و مدیریت دسترسی چندتا goroutine به داده یا منبع مشترکه.\nوقتی چند goroutine همزمان به یک داده دسترسی پیدا می‌کنن، بدون هماهنگی ممکنه داده خراب بشه یا رفتار برنامه غیرقابل پیش‌بینی بشه (Data Race).\nsync دقیقا برای جلوگیری از این اتفاق ساخته شده و ابزارهایی رو ارائه می‌ده که اجازه می‌ده دسترسی همزمان رو کنترل کنید.\nابزارهای اصلی sync:\nMutex — قفل ساده برای جلوگیری از دسترسی همزمان به منبع مشترک. RWMutex — قفل خواندن/نوشتن: چند خواننده همزمان یا یک نویسنده در هر لحظه. WaitGroup — منتظر موندن تا همه goroutineها کارشون رو تموم کنن. Once — اجرای یک کد فقط یک بار حتی بین چند goroutine. Pool — نگه‌داری مجموعه‌ای از آبجکت‌های آماده برای استفاده مجدد. Cond — هماهنگی بر اساس شرط یا رویداد (Condition Variable). نکته: sync فقط برای هماهنگ‌کردن دسترسی به منابع مشترک ساخته شده، نه برای زمان‌بندی یا اجرای همزمان.\nتوجه کنید که پکیج sync فقط و فقط برای مدیریت و همگام سازی دسترسی های گوروتین ها به یک داده مشترک استفاده می شود. 3.3.1 Mutex — قفل متقابل # Mutex یا قفل متقابل یکی از اصلی‌ترین ابزارهای همگام‌سازی در زبان Go است که برای جلوگیری از دسترسی همزمان ناامن (Data Race) به داده‌های مشترک استفاده می‌شود. وقتی یک goroutine قفل را با Lock() می‌گیرد، سایر goroutineهایی که سعی کنند همان قفل را بگیرند، باید منتظر بمانند تا قفل با Unlock() آزاد شود. این مکانیزم تضمین می‌کند که در هر لحظه فقط یک goroutine می‌تواند بخش بحرانی (Critical Section) کد را اجرا کند. بخش بحرانی همان قسمتی از کد است که به داده‌ی مشترک دسترسی دارد و تغییر آن ممکن است باعث بروز خطا یا رفتار غیرقابل پیش‌بینی شود.\nیکی از نکات کلیدی در استفاده از Mutex این است که قفل باید تا حد امکان کوتاه‌مدت نگه داشته شود. یعنی فقط همان بخش ضروری از کد را قفل کنید، چون قفل‌کردن طولانی می‌تواند باعث کاهش کارایی و ایجاد گلوگاه (Bottleneck) شود. همچنین هرگز نباید Mutex را کپی کنید، چون هر Mutex داخلی یک وضعیت دارد و کپی آن باعث می‌شود قفل‌ها به‌درستی عمل نکنند.\nمثال تئوری — آشپزخانه و سیب‌زمینی سرخ‌کرده # فرض کنید مادرتان در آشپزخانه در حال سرخ کردن سیب‌زمینی خلالی است. برای اینکه کسی وسط کار مزاحم نشود و نظم کار به هم نخورد، درِ آشپزخانه را می‌بندد. حالا این در مثل یک Mutex عمل می‌کند:\nوقتی در بسته است (Lock شده)، فقط مادرتان داخل آشپزخانه است و می‌تواند روی سیب‌زمینی‌ها کار کند. اگر کسی (مثلاً یکی از بچه‌ها) بخواهد وارد آشپزخانه شود، باید منتظر بماند تا مادرتان در را باز کند (Unlock). وقتی مادرتان کارش را تمام کرد و در را باز کرد، نفر بعدی می‌تواند وارد شود و کاری انجام دهد. حالا فرض کنید در طول کار، یکی از بچه‌ها خیلی عجله دارد و بدون اجازه وارد می‌شود و یک مشت سیب‌زمینی برمی‌دارد. این همان Data Race است که بدون قفل اتفاق می‌افتد و می‌تواند باعث خراب شدن برنامه (یا در این مثال، کمتر شدن سیب‌زمینی‌ها 😄) شود. Mutex دقیقاً برای جلوگیری از این نوع تداخل ساخته شده است.\n3.1.1.1 ساختار Mutex در Go # sync.Mutex دو متد اصلی داره:\nLock() وقتی یک goroutine این متد رو صدا بزنه، قفل رو می‌گیره. اگه قفل قبلاً توسط goroutine دیگه گرفته شده باشه، این goroutine منتظر می‌مونه (مسدود می‌شه) تا قفل آزاد بشه. Unlock() قفل رو آزاد می‌کنه تا goroutineهای دیگه بتونن وارد بخش قفل‌شده بشن. ⚡ نکته مهم تولیدی:\nبعد از هر Lock() بلافاصله defer Unlock() بنویسید تا حتی اگر وسط کار panic یا return اتفاق افتاد، قفل آزاد بشه:\nmu.Lock() defer mu.Unlock() 3.1.1.2 مثال ساده Mutex # در این مثال، چهار goroutine می‌خوان همزمان مقدار یک متغیر مشترک (count) رو تغییر بدن:\npackage main import ( \"fmt\" \"sync\" \"time\" ) var count int // متغیر مشترک var mu sync.Mutex func main() { for i := 0; i \u003c 4; i++ { go increment() } time.Sleep(time.Second) } func increment() { mu.Lock() // گرفتن قفل defer mu.Unlock() // آزاد کردن قفل بعد از اتمام کار count++ fmt.Printf(\"Count: %d\\n\", count) } ▶ اجرای کد کپی ✖ بستن خروجی 3.1.1.3 نکات کاربردی و تولیدی Mutex # محدوده قفل رو کوچک نگه دارید\nقفل رو فقط برای بخشی از کد که نیاز به حفاظت داره بگیرید. قفل‌کردن بخش‌های بزرگ کد می‌تونه باعث افت کارایی بشه. از کپی Mutex خودداری کنید\nهمیشه Mutex رو با اشاره‌گر (pointer) پاس بدید، چون کپی‌کردن Mutex می‌تونه باعث رفتار غیرقابل پیش‌بینی بشه. احتیاط در قفل‌های تو در تو (Nested Locks)\nگرفتن چند قفل به ترتیب اشتباه می‌تونه باعث Deadlock بشه. همیشه ترتیب قفل‌گیری رو یکسان نگه دارید. استفاده در ساختار داده‌ها\nمی‌تونید Mutex رو به عنوان فیلد در یک struct بذارید تا عملیات روی داده‌های اون struct ایمن بشه. 3.1.1.4 مثال پیشرفته: Mutex در struct # package main import ( \"fmt\" \"sync\" ) type SafeCounter struct { mu sync.Mutex value int } func (c *SafeCounter) Inc() { c.mu.Lock() defer c.mu.Unlock() c.value++ } func (c *SafeCounter) Value() int { c.mu.Lock() defer c.mu.Unlock() return c.value } func main() { counter := \u0026SafeCounter{} var wg sync.WaitGroup for i := 0; i \u003c 1000; i++ { wg.Add(1) go func() { defer wg.Done() counter.Inc() }() } wg.Wait() fmt.Println(\"Final Count:\", counter.Value()) } ▶ اجرای کد کپی ✖ بستن خروجی 3.1.1.5 مزایا و معایب Mutex # مزایا:\nپیاده‌سازی ساده و مستقیم. بدون overhead اضافی برای مدیریت channel یا ساختار پیچیده. معایب:\nقفل‌گذاری بیش از حد می‌تونه باعث افت کارایی بشه. اشتباه در مدیریت Lock/Unlock ممکنه باعث Deadlock یا Data Race بشه. 3.3.1.6 سناریوهای استفاده # همگام سازی دسترسی به متغیرهای مشترک: یک mutex می تواند برای همگام سازی دسترسی به متغیرهای مشترک بین چندین گوروتین استفاده شود. این می تواند در مواردی مفید باشد که چندین گوروتین نیاز به خواندن یا به روز رسانی یک متغیر به طور همزمان دارند.\nهماهنگی دسترسی به حالت مشترک: یک mutex می تواند برای هماهنگ کردن دسترسی به حالت مشترک بین چندین گوروتین استفاده شود. به عنوان مثال، ممکن است از یک mutex استفاده کنید تا اطمینان حاصل کنید که فقط یک گوروتین می تواند یک ساختار داده مشترک را در یک زمان تغییر دهد.\nپیاده سازی الگوهای تولیدکننده-مصرف کننده (producer-consumer): یک mutex می تواند برای پیاده سازی الگوهای تولیدکننده-مصرف کننده استفاده شود، که در آن یک یا چند گوروتین داده تولید می کنند و یک یا چند گوروتین آن را مصرف می کنند. mutex می تواند برای همگام سازی دسترسی به ساختار داده مشترک که داده ها را نگه می دارد استفاده شود.\n۲ نکته خیلی مهم\nسعی کنید پس از اینکه تابع Lock را فراخوانی میکنید تابع Unlock را داخل defer قرار دهید. زمانیکه قصد دارید Mutex را به عنوان پارامتر ورودی برای توابع تعریف کنید بهتر است از نوع اشاره گر باشد. 3.3.2 RWMutex — قفل خواندن/نوشتن # RWMutex مخفف Read-Write Mutex هست و درواقع نسخه‌ی پیشرفته‌تر Mutex محسوب می‌شه.\nوظیفه‌اش همگام‌سازی دسترسی همزمان به یک داده یا منبع مشترکه، ولی با یک قابلیت اضافه: چند goroutine می‌تونن همزمان داده رو بخونن، ولی فقط یک goroutine می‌تونه بنویسه و وقتی در حال نوشتنه، هیچ‌کس حق خواندن نداره.\n3.3.2.1 چرا RWMutex؟ # در خیلی از برنامه‌ها، تعداد عملیات خواندن (Read) روی داده‌ها خیلی بیشتر از نوشتن (Write) هست. مثلا:\nکش (Cache) که بیشتر وقت‌ها داده رو از حافظه می‌خونیم و فقط گاهی به‌روزرسانی می‌کنیم. تنظیمات برنامه (Configuration) که بارها خونده می‌شه ولی به ندرت تغییر پیدا می‌کنه. در این مواقع، استفاده از یک Mutex ساده باعث می‌شه حتی وقتی چند goroutine فقط می‌خوان داده رو بخونن، مجبور بشن منتظر هم بمونن. اما RWMutex اجازه می‌ده چند خواننده همزمان کار کنن و فقط موقع نوشتن همه منتظر بمونن.\n3.3.2.2 متدهای اصلی RWMutex # RLock() — گرفتن قفل خواندن. چند goroutine می‌تونن همزمان RLock بگیرن. RUnlock() — آزاد کردن قفل خواندن. Lock() — گرفتن قفل نوشتن. فقط یک goroutine می‌تونه همزمان Lock بگیره و تا زمانی که قفل نوشتن فعاله، هیچ‌کس نمی‌تونه بخونه یا بنویسه. Unlock() — آزاد کردن قفل نوشتن. 3.3.2.3 مثال ساده RWMutex # package main import ( \"fmt\" \"sync\" \"time\" ) type SafeMap struct { mu sync.RWMutex data map[string]string } func (s *SafeMap) Read(key string) string { s.mu.RLock() defer s.mu.RUnlock() return s.data[key] } func (s *SafeMap) Write(key, value string) { s.mu.Lock() defer s.mu.Unlock() s.data[key] = value } func main() { smap := SafeMap{data: make(map[string]string)} // نویسنده go func() { for i := 0; i \u003c 5; i++ { smap.Write(\"name\", fmt.Sprintf(\"value-%d\", i)) time.Sleep(500 * time.Millisecond) } }() // چند خواننده همزمان for i := 0; i \u003c 3; i++ { go func(id int) { for j := 0; j \u003c 5; j++ { fmt.Printf(\"Reader %d: %s\\n\", id, smap.Read(\"name\")) time.Sleep(300 * time.Millisecond) } }(i) } time.Sleep(3 * time.Second) } ▶ اجرای کد کپی ✖ بستن خروجی در این مثال، چند goroutine همزمان از متد Read() استفاده می‌کنن و چون RLock() استفاده شده، همه می‌تونن بدون منتظر موندن بخونن. ولی موقع نوشتن، قفل نوشتن (Lock()) همه رو متوقف می‌کنه تا عملیات امن انجام بشه.\n3.3.2.4 نکات و ترفندهای استفاده از RWMutex # وقتی بیشتر خواندن داریم، از RWMutex استفاده کنید\nاگر نسبت خواندن به نوشتن پایین باشه (یعنی نوشتن زیاد باشه)، استفاده از RWMutex ممکنه حتی کندتر از Mutex ساده باشه، چون مدیریت قفل‌های خواندن/نوشتن پیچیده‌تره. هرگز قفل خواندن و نوشتن را همزمان نگیرید\nگرفتن RLock() و سپس تلاش برای گرفتن Lock() در همان goroutine باعث Deadlock می‌شه. محدوده قفل را کوچک نگه دارید\nفقط همان بخش حساس به تغییر داده را قفل کنید. این کار باعث افزایش عملکرد و کاهش زمان انتظار می‌شود. قفل‌ها را جفت باز و بسته کنید\nهر RLock() باید با RUnlock() و هر Lock() باید با Unlock() جفت شود. 3.3.2.5 مثال کاربردی — کش خواندنی/نوشتنی # فرض کنید یک سیستم داریم که قیمت ارز را ذخیره می‌کند:\nده‌ها goroutine در حال خواندن قیمت هستند. فقط یک goroutine هر چند ثانیه یکبار قیمت را به‌روزرسانی می‌کند. در این سناریو RWMutex باعث می‌شود خواننده‌ها معطل همدیگر نشوند و فقط هنگام بروزرسانی، همه منتظر بمانند.\ntype PriceCache struct { mu sync.RWMutex price float64 } func (p *PriceCache) Get() float64 { p.mu.RLock() defer p.mu.RUnlock() return p.price } func (p *PriceCache) Set(val float64) { p.mu.Lock() defer p.mu.Unlock() p.price = val } 3.3.3 WaitGroup — هماهنگی پایان کار goroutineها # WaitGroup در پکیج sync یکی از پرکاربردترین ابزارها برای همگام‌سازی است که به شما اجازه می‌دهد منتظر بمانید تا گروهی از goroutineها کارشان را تمام کنند.\nایده‌اش ساده است: شما قبل از اجرای goroutineها به WaitGroup می‌گویید که چندتا کار قرار است انجام شود، هر goroutine بعد از اتمام کار به WaitGroup خبر می‌دهد، و وقتی همه کارها تمام شد، برنامه ادامه پیدا می‌کند.\n3.3.3.1 متدهای اصلی WaitGroup # Add(delta int) تعداد کارهایی که WaitGroup باید منتظرشان بماند را اضافه یا کم می‌کند. معمولاً قبل از اجرای goroutineها استفاده می‌شود (Add(n) برای n تا goroutine). Done() نشان می‌دهد که یکی از کارها تمام شده است. معادل Add(-1) است. معمولاً در ابتدای goroutine با defer فراخوانی می‌شود. Wait() برنامه را تا زمانی که شمارش WaitGroup به صفر برسد مسدود می‌کند. 3.3.3.2 مثال ساده WaitGroup # package main import ( \"fmt\" \"sync\" \"time\" ) func main() { var wg sync.WaitGroup wg.Add(3) // انتظار برای 3 goroutine go worker(\"A\", \u0026wg) go worker(\"B\", \u0026wg) go worker(\"C\", \u0026wg) wg.Wait() // صبر تا پایان همه goroutineها fmt.Println(\"All workers finished!\") } func worker(name string, wg *sync.WaitGroup) { defer wg.Done() // اعلام پایان کار fmt.Printf(\"Worker %s starting...\\n\", name) time.Sleep(time.Second) fmt.Printf(\"Worker %s done.\\n\", name) } ▶ اجرای کد کپی ✖ بستن خروجی 3.3.3.3 مثال کاربردی — دانلود همزمان فایل‌ها # فرض کنید می‌خواهیم چند فایل را به صورت موازی دانلود کنیم و منتظر بمانیم تا همه دانلودها کامل شوند:\nfunc downloadFile(url string, wg *sync.WaitGroup) { defer wg.Done() fmt.Println(\u0026quot;Downloading:\u0026quot;, url) time.Sleep(2 * time.Second) fmt.Println(\u0026quot;Downloaded:\u0026quot;, url) } func main() { var wg sync.WaitGroup files := []string{\u0026quot;file1.zip\u0026quot;, \u0026quot;file2.zip\u0026quot;, \u0026quot;file3.zip\u0026quot;} wg.Add(len(files)) for _, f := range files { go downloadFile(f, \u0026amp;wg) } wg.Wait() fmt.Println(\u0026quot;All downloads complete!\u0026quot;) } 3.3.3.4 نکات و ترفندهای استفاده از WaitGroup # همیشه Add() را قبل از شروع goroutineها انجام دهید\nاگر Add() را بعد از شروع goroutineها انجام دهید، ممکن است WaitGroup صفر شود و Wait() بلافاصله ادامه پیدا کند (Race Condition). از اشاره‌گر برای پاس دادن WaitGroup استفاده کنید\nWaitGroup را کپی نکنید، چون هر کپی شمارش خودش را دارد و هماهنگی از بین می‌رود. تعداد Add و Done باید دقیقاً برابر باشد\nاگر تعداد Done() کمتر از Add() باشد، Wait() برای همیشه مسدود می‌ماند.\nاگر تعداد بیشتر باشد، Panic رخ می‌دهد. ترکیب با Channel برای نتایج\nمی‌توانید WaitGroup را با Channel ترکیب کنید تا بعد از اتمام همه goroutineها، داده‌ها را پردازش کنید. 3.3.3.5 اشتباه رایج — Add داخل goroutine # اشتباه:\nfor _, task := range tasks { go func(t string) { wg.Add(1) // ❌ اشتباه doTask(t) wg.Done() }(task) } چرا اشتباهه؟\nچون ممکنه goroutine هنوز Add نکرده باشه ولی main Wait() رو صدا بزنه و شمارش صفر بشه.\nراه درست:\nwg.Add(len(tasks)) for _, task := range tasks { go func(t string) { defer wg.Done() doTask(t) }(task) } 3.3.3.6 مثال پیشرفته — پردازش موازی با WaitGroup و Semaphore # گاهی تعداد goroutineهای همزمان باید محدود شود. ترکیب WaitGroup با Channel به عنوان Semaphore می‌تواند این کار را انجام دهد:\nاگر درخصوص پترن Semaphore بیشتر میخواید بدانید به اینجا مراجعه کنید. func process(id int, wg *sync.WaitGroup, sem chan struct{}) { defer wg.Done() sem \u0026lt;- struct{}{} // گرفتن اسلات fmt.Printf(\u0026quot;Processing %d\\n\u0026quot;, id) time.Sleep(time.Second) \u0026lt;-sem // آزاد کردن اسلات } func main() { var wg sync.WaitGroup sem := make(chan struct{}, 3) // حداکثر 3 goroutine همزمان for i := 0; i \u0026lt; 10; i++ { wg.Add(1) go process(i, \u0026amp;wg, sem) } wg.Wait() fmt.Println(\u0026quot;All processing complete!\u0026quot;) } ۳ نکته خیلی مهم\nساختار WaitGroup یکی از پرکاربرد ترین قابلیت ها برای بحث همزمانی می باشد و برخی اوقات برای جلوگیری از Data race و همچنین برای ترتیب دهی عملیات همزمانی هم می توان از این استفاده کرد. سعی کنید WaitGroup را بصورت اشاره گر به توابعی که داخل گوروتین قرار دارند پاس دهید. هیچوقت تعداد گوروتین را بیشتر یا کمتر از اون تعدادی که دارید به متد Add ‌ندهید چون با خطای Panic مواجه خواهید شد. 3.3.4 Once — اجرای یک کد فقط یکبار # sync.Once یکی از ابزارهای پکیج sync هست که تضمین می‌کنه یک تکه کد فقط یکبار در کل طول اجرای برنامه اجرا بشه، حتی اگر چندین goroutine به طور همزمان اون رو صدا بزنن.\nاین ابزار معمولاً برای کارهایی مثل مقداردهی اولیه (Initialization) یا ساخت منابع مشترک استفاده می‌شه که نیازه فقط یکبار انجام بشن.\n3.3.4.1 متد اصلی Once # Do(func())\nاین متد یک تابع رو می‌گیره و فقط اولین باری که صدا زده بشه، اون تابع رو اجرا می‌کنه.\nاگر چند goroutine همزمان Do() رو صدا بزنن، فقط یکی اجرا می‌شه و بقیه منتظر می‌مونن تا تابع اجرا بشه. 3.3.4.2 چرا از Once استفاده کنیم؟ # بدون Once، اگر بخواهیم کاری رو فقط یکبار انجام بدیم، مجبوریم از یک Mutex برای محافظت از کد استفاده کنیم و خودمون وضعیت (state) رو چک کنیم که آیا قبلاً اجرا شده یا نه. Once این کار رو به صورت thread-safe و بهینه انجام می‌ده، بدون اینکه نیاز باشه ما خودمون مدیریت کنیم.\n3.3.4.3 مثال ساده Once # package main import ( \"fmt\" \"sync\" ) var once sync.Once func initConfig() { fmt.Println(\"Config initialized\") } func main() { for i := 0; i \u003c 5; i++ { go once.Do(initConfig) } // کمی صبر می‌کنیم تا goroutineها اجرا بشن var wg sync.WaitGroup wg.Add(1) go func() { defer wg.Done() }() wg.Wait() } ▶ اجرای کد کپی ✖ بستن خروجی حتی با اجرای چندین goroutine، پیام فقط یکبار چاپ می‌شه.\n3.3.4.4 استفاده از Once برای پیاده‌سازی Singleton # Once یکی از بهترین راه‌ها برای پیاده‌سازی الگوی Singleton در Go هست، چون به صورت ایمن و همزمانی (thread-safe) تضمین می‌کنه که فقط یک instance ساخته می‌شه.\ntype singleton struct { data string } var ( instance *singleton once sync.Once ) func GetInstance() *singleton { once.Do(func() { instance = \u0026amp;singleton{data: \u0026quot;my singleton data\u0026quot;} }) return instance } func main() { s1 := GetInstance() s2 := GetInstance() if s1 == s2 { fmt.Println(\u0026quot;Same instance\u0026quot;) } } مزیت: نیازی به نوشتن قفل‌های اضافه یا متغیر flag نیست، چون Once همه چیز رو مدیریت می‌کنه.\n3.3.4.5 نکات و ترفندهای استفاده از Once # حتماً از همان متغیر Once برای تمام دسترسی‌ها استفاده کنید\nاگر در جاهای مختلف متغیرهای Once جداگانه بسازید، هرکدوم تابع رو یکبار اجرا می‌کنن. تابع Do نباید nil باشه\nاگر nil بدید، Panic اتفاق می‌افته. Once برای reset کردن نیست\nوقتی تابعی با Once اجرا شد، دیگه نمی‌تونید اون رو دوباره اجرا کنید. اگر نیاز به reset دارید، باید ساختار جدیدی بسازید. بهینه و سبک\nOnce به صورت داخلی فقط در اولین اجرا قفل می‌گیره و بعد از اون بدون هزینه قفل، مستقیماً ادامه می‌ده. 3.3.5 Pool # در نسخه ۱.۳ زبان گو امکانی تایپی به نام Pool در پکیج sync که امکان ایجاد استخر آبجکت ها بطور موقت بدون اینکه بخواهد بخشی از حافظه را اشتغال کند اضافه شد. هر آبجکتی که در Pool ذخیره شود بطور خودکار در هرزمانی بدون اینکه اطلاع رسانی کند حذف می شود. امکان استفاده مجدد از آبجکت هایی که داخل استخر می گیرند وجود دارد و این باعث می شود سربار استفاده حافظه کاهش یابد.\npackage main import ( \"bytes\" \"io\" \"os\" \"sync\" \"time\" ) var bufPool = sync.Pool{ New: func() any { // The Pool's New function should generally only return pointer // types, since a pointer can be put into the return interface // value without an allocation: return new(bytes.Buffer) }, } // timeNow is a fake version of time.Now for tests. func timeNow() time.Time { return time.Unix(1136214245, 0) } func Log(w io.Writer, key, val string) { b := bufPool.Get().(*bytes.Buffer) b.Reset() // Replace this with time.Now() in a real logger. b.WriteString(timeNow().UTC().Format(time.RFC3339)) b.WriteByte(' ') b.WriteString(key) b.WriteByte('=') b.WriteString(val) w.Write(b.Bytes()) bufPool.Put(b) } func main() { Log(os.Stdout, \"path\", \"/search?q=flowers\") } ▶ اجرای کد کپی ✖ بستن خروجی در بالا ما یک متغیر به نام bufPool ایجاد کردیم که یک آبجکت از نوع bytes.Buffer ایجاد می کند. سپس داخل تابع Log ما با استفاده از متد Get آبجکت مورد نظر را از Pool خارج و داخل متغیر b قرار دادیم و پس از آن عملیات لازم را برروی Buffer انجام و در نهایت با استفاده از متد Put آبجکت را به Pool اضافه کردیم. حالا اتفاقی که صورت گرفته ما عملیاتی که نیاز داشتیم را برروی آبجکت انجام دادیم بدون اینکه بخوایم بخشی از حافظه را درگیر کنیم.\n3.3.5.1 بنچمارک در خصوص Pool # package main import ( \"sync\" \"testing\") type Person struct { Age int } var personPool = sync.Pool{ New: func() interface{} { return new(Person) }, } func BenchmarkWithoutPool(b *testing.B) { var p *Person b.ReportAllocs() b.ResetTimer() for i := 0; i \u003c b.N; i++ { for j := 0; j \u003c 10000; j++ { p = new(Person) p.Age = 23 } } } func BenchmarkWithPool(b *testing.B) { var p *Person b.ReportAllocs() b.ResetTimer() for i := 0; i \u003c b.N; i++ { for j := 0; j \u003c 10000; j++ { p = personPool.Get().(*Person) p.Age = 23 personPool.Put(p) } } } ▶ اجرای کد کپی ✖ بستن خروجی 3.3.5.2 مثال های کاربردی # مثال اول :\nفرض کنید شما می خواهید یک فایل csv را با کلی رکورد parse کنید. هر رکورد نیازمند این است که داخل یک ساختاری قرار بگیرد و ایجاد یک ساختار باعث می شود بخشی از حافظه اختصاص یابد به آن ساختار. حالا فکر کنید میلیون ها رکورد داشته باشید و این تخصیص حافظه می تواند باعث توقف برنامه شود.\nحالا برای اینکه بخواهیم جلوی این اتفاق را بگیریم و سربار را کاهش دهیم بهتر است ما از sync.Pool استفاده کنیم و ساختارها را داخل استخر قرار دهیم. و زمانیکه هرکدام از ساختارها مورد نیاز نباشد می توانند داخل استخر قرار گیرند و مجدد استفاده شوند. اینکار باعث می شود بطور خیلی قابل توجهی تعداد تخصیص حافظه کاهش یابد و عملکرد برنامه چند برابر شود.\nمثال دوم :\nموارد استفاده دیگر از sync.Pool برای ذخیره کردن آبجکت های پرکاربرد نظیر کانکشن دیتابیس یا شبکه و همچنین آبجکت هایی که قصد داریم برروی آن عملیات serialize و deserialize انجام دهیم.\n3.3.6 Cond # پکیج sync.Cond یکی از ابزارهای پیشرفته همزمانی در زبان Go است که امکان پیاده‌سازی الگوی \u0026ldquo;مانیتور\u0026rdquo; یا همان شرط انتظاری (Condition Variable) را فراهم می‌کند. Cond به شما اجازه می‌دهد تا مجموعه‌ای از goroutineها را تا زمانی که یک شرط یا رویداد خاص برقرار نشده، به صورت امن و کارآمد (بدون busy-waiting یا مصرف بی‌مورد CPU) منتظر نگه دارید. زمانی که شرط مورد نظر برقرار شد، می‌توانید یک یا همه goroutineهای منتظر را بیدار کنید تا کارشان را ادامه دهند. این تکنیک، در بسیاری از الگوهای معروف concurrency مانند producer-consumer، صف انتظار، صف پیام و کنترل منابع محدود کاربرد اساسی دارد.\nنحوه کار Cond و نقش قفل (Mutex / RWMutex) # برای ساخت یک شیء Cond باید یک قفل (معمولاً از نوع *sync.Mutex یا *sync.RWMutex) به آن بدهید. این قفل به Cond اجازه می‌دهد تا وضعیت مشترک (shared state) را در میان چند goroutine به طور thread-safe بررسی و کنترل کند. قفل، تضمین می‌کند که هیچ دو goroutineای همزمان نتوانند وضعیت را تغییر دهند یا به متدهای Cond دسترسی پیدا کنند، که این برای جلوگیری از race condition کاملاً حیاتی است.\nlock := \u0026amp;sync.Mutex{} cond := sync.NewCond(lock) عملکرد متدها # Wait(): وقتی یک goroutine متد Wait را صدا می‌زند، دو اتفاق پشت‌سرهم رخ می‌دهد:\nقفل داده‌شده (مثلاً Mutex) به طور موقت آزاد می‌شود تا سایر goroutineها بتوانند وضعیت مشترک را تغییر دهند. goroutine تا زمان دریافت سیگنال (Signal یا Broadcast) به حالت تعلیق (sleep) می‌رود و هیچ پردازشی انجام نمی‌دهد (کاملاً غیرمسدودکننده). پس از دریافت سیگنال و بیدار شدن، Wait دوباره به صورت اتمیک قفل را در اختیار می‌گیرد و اجرا از همان خط ادامه پیدا می‌کند. معمولاً قبل از Wait باید شرط را داخل یک حلقه (for) بررسی کنید تا از spurious wakeup و رقابت داده‌ای جلوگیری شود: cond.L.Lock() for !شرط_برقرار_است { cond.Wait() } // ادامه منطق ... cond.L.Unlock() Signal(): این متد تنها یکی از goroutineهای منتظر را بیدار می‌کند (اگر کسی در صف انتظار باشد). انتخاب اینکه کدام goroutine بیدار شود به سیاست زمان‌بندی runtime وابسته است و تضمینی برای ترتیب خاصی وجود ندارد. Signal معمولاً زمانی به کار می‌رود که انتظار دارید فقط یک مصرف‌کننده با داده جدید یا تغییر وضعیت بیدار شود.\nBroadcast(): این متد همه goroutineهای منتظر روی آن Cond را بیدار می‌کند تا شرط را دوباره بررسی کنند. Broadcast زمانی کاربرد دارد که یک رویداد می‌تواند برای همه‌ی منتظرها مهم باشد (مثلاً اتمام کار یا آزاد شدن منبع برای همه مصرف‌کننده‌ها).\nبه مثال زیر توجه کنید :\npackage main import ( \"fmt\" \"sync\" ) var sharedResource = make(map[string]interface{}) func main() { var wg sync.WaitGroup wg.Add(2) locker := sync.Mutex{} condition := sync.NewCond(\u0026locker) go waitForResourceUpdate(\u0026wg, condition, \"rsc1\") go waitForResourceUpdate(\u0026wg, condition, \"rsc2\") // this one writes changes to sharedResource condition.L.Lock() sharedResource[\"rsc1\"] = \"a string\" sharedResource[\"rsc2\"] = 123456 condition.Broadcast() condition.L.Unlock() wg.Wait() } // waitForResourceUpdate waits for a signal that a resource changed and prints it. func waitForResourceUpdate(wg *sync.WaitGroup, cond *sync.Cond, key string) { defer wg.Done() cond.L.Lock() for len(sharedResource) == 0 { cond.Wait() } fmt.Println(\"Resource\", key, \":\", sharedResource[key]) cond.L.Unlock() } ▶ اجرای کد کپی ✖ بستن خروجی "},{"id":35,"href":"/chapter-3/go-atomic/","title":"3.4 پکیج atomic","section":"فصل سوم: همزمانی (concurrency)","content":"پکیج sync/atomic در زبان Go مجموعه‌ای از توابع سطح پایین (low-level) را برای انجام عملیات خواندن و نوشتن اتمی (atomic) روی متغیرهای حافظه فراهم می‌کند. منظور از عملیات اتمیک، عملیاتی است که به طور کامل و یکپارچه توسط CPU انجام می‌شود؛ یعنی هیچ گوروتین، thread یا پردازش دیگری نمی‌تواند مقدار متغیر را بین شروع و پایان یک عملیات اتمیک مشاهده یا تغییر دهد. این ویژگی برای پیاده‌سازی الگوهای همگام‌سازی سبک و بدون قفل (lock-free synchronization) و متغیرهای اشتراکی با دسترسی سریع و ایمن ضروری است.\nمهم‌ترین کاربردها و عملیات: # پیاده‌سازی شمارنده‌های اتمیک (atomic counters): مثلاً افزایش شمارنده تعداد درخواست، جمع یا کم کردن بدون نیاز به Mutex. فلگ‌ها یا وضعیت‌های اشتراکی: تنظیم و خواندن یک فلگ مشترک بین چند goroutine به شکلی که دچار race condition نشود. ساخت primitiveهای همگام‌سازی سفارشی: مثل اسپین‌لاک، قفل ساده، lock-free queue، semaphore سطح پایین و… متدهای مهم atomic: # atomic.AddInt32 / AddUint64 — جمع یا کم کردن مقدار به صورت اتمیک atomic.LoadInt32 / LoadPointer — خواندن مقدار به شکل اتمیک atomic.StoreInt32 / StorePointer — نوشتن مقدار به شکل اتمیک atomic.CompareAndSwapInt32 — عمل مقایسه و جایگزینی اتمیک (CAS)، قلب الگوریتم‌های lock-free atomic.Value — یک ساختار wrapper برای نگهداری داده با خواندن و نوشتن اتمیک (ایده‌آل برای ساخت cacheهای ساده یا حافظه به اشتراک گذاشته شده) به مثال زیر توجه کنید :\npackage main import ( \"fmt\" \"sync\" \"sync/atomic\" ) type Cache struct { mu sync.Mutex data map[string]string } func (c *Cache) Set(key, value string) { c.mu.Lock() defer c.mu.Unlock() c.data[key] = value } func (c *Cache) Get(key string) (value string, ok bool) { c.mu.Lock() defer c.mu.Unlock() value, ok = c.data[key] return } type AtomicCache struct { mu sync.Mutex data atomic.Value } func (c *AtomicCache) Set(key, value string) { c.mu.Lock() defer c.mu.Unlock() c.data.Store(map[string]string{key: value}) } func (c *AtomicCache) Get(key string) (value string, ok bool) { data := c.data.Load().(map[string]string) value, ok = data[key] return } func main() { cache := Cache{data: map[string]string{}} cache.Set(\"key\", \"value\") fmt.Println(cache.Get(\"key\")) // Output: value, true atomicCache := AtomicCache{data: atomic.Value{}} atomicCache.Set(\"key\", \"value\") fmt.Println(atomicCache.Get(\"key\")) // Output: value, true } ▶ اجرای کد کپی ✖ بستن خروجی در مثال فوق ما یک ساختار به نام Cache داریم که داخلش یک فیلد از نوع map داریم و قصد داریم یکسری اطلاعات را داخل کش بریزیم حال زمانیکه Set/Get می کنیم با استفاده از Mutex اون بخش از عملیات را لاک میکنیم تا جلوی عملیات نوشتن چندین گوروتین برروی یک آدرس حافظه را بگیریم. حال این عملیات رو ما با استفاده از atomic انجام دادیم و همگام سازی داده را بردیم تو سطح خیلی پایین تر در حافظه و با استفاده از atomic.Value که یک اینترفیس است این عملیات را انجام دادیم و این عملیات Set/Get حالت atomic پیدا کرده است.\nآیا استفاده از atomic نیازمند mutex می باشد یا خیر؟\nدر این کد، mutex در متد Set برای جلوگیری از رخ دادن race condition یا داده‌های نامنظم استفاده شده است. بدون mutex، چندین گوروتین ممکن است همزمان به دسترسی و تغییر داده‌های map data بپردازند که موجب رفتار نامنظم و فساد داده می‌شود. با گرفتن mutex قبل از تغییر map data، متد Set اطمینان حاصل می‌کند که تنها یک گوروتین در هر زمان می‌تواند به داده‌ها دسترسی پیدا کند و تداخل داده‌ها را جلوگیری می‌کند.\nاستفاده از mutex در متد Get نیز مهم است، زیرا این اطمینان را به ما می‌دهد که در هنگام دسترسی به map data، هیچ گوروتین دیگری دارای مجوز تغییر داده‌ها نیست. بدون mutex، یک race condition ممکن است ایجاد شود اگر یک گوروتین دیگر در حال تغییر داده‌های map باشد در حالی که یک گوروتین دیگر سعی در خواندن از آن دارد.\nدر پیاده‌سازی AtomicCache، یک atomic.Value برای ذخیره map استفاده شده است که به انجام عملیات اتمی روی آن اجازه می‌دهد. با این حال، حتی با استفاده از یک مقدار اتمی، همچنان نیاز به mutex وجود دارد تا فقط یک گوروتین در هر زمان به map دسترسی داشته باشد و تداخل داده‌ها را جلوگیری کند.\n3.4.1 نکات و هشدارهای تولیدی (Production Caveats) # memory safety: پکیج atomic از ویژگی‌های سطح پایین CPU استفاده می‌کند و bypass کردن حافظه امن زبان Go را ممکن می‌سازد؛ یعنی اگر به درستی از آن استفاده نکنید، به‌راحتی دچار bugهای عجیب و غیرقابل ردیابی خواهید شد. استفاده اشتباه می‌تواند باعث بروز race condition، memory corruption و مشکلات شدید تولیدی شود.\nتراز حافظه (memory alignment): متغیرهایی که به صورت اتمیک تغییر می‌کنند باید به درستی روی حافظه align شوند (مثلاً در ساختار struct کنار سایر داده‌ها قرار نگیرند). بی‌توجهی به این نکته ممکن است باعث crash برنامه در معماری‌های خاص شود.\nمناسب برای عملیات ساده: atomic برای primitive data types (int32, int64, pointer, \u0026hellip;)، عملیات ساده و سناریوهایی با هماهنگی حداقلی طراحی شده است؛ اگر منطق پیچیده‌تر دارید یا باید چندین متغیر را همزمان به شکل اتمیک تغییر دهید، از sync.Mutex یا سایر ابزارهای همزمانی ایمن Go استفاده کنید.\nکاملاً lock-free نیست: گرچه atomic سریع و سبک است، اما فقط برای primitiveها کاملاً lock-free است. برای کار با داده‌های پیچیده یا ساختارهای بزرگ، باید با احتیاط و دانش کافی عمل کنید.\natomic.Value برای داده‌های ساختاری، اما فقط با خواندن و نوشتن کامل؛ عملیات mutate روی داده ذخیره‌شده (مثلاً map یا slice) اتمیک نیست مگر کل value جایگزین شود.\n3.4.2 برخی از کاربردهای atomic # در زیر چندتا use case برای استفاده از پکیج atomic معرفی کردیم :\nپیاده سازی همگام سازی بدون مسدودیت : پکیج atomic توابع سطح پایینی را برای انجام عملیات حافظه اتمی فراهم می کند که می تواند برای پیاده سازی الگوریتم های همگام سازی غیرمسدود مانند مقایسه و تعویض (CAS) یا بارگذاری لینک/ذخیره شرطی استفاده شود. LL/SC).\nپیاده سازی ساختارهای داده با همزمانی سطح (high-concurrency) بالا : با پکیج atomic می توان برای پیاده سازی ساختارهای داده ای استفاده کرد که برای دسترسی همزمان و اصلاح توسط چندین گوروتین ایمن هستند. به عنوان مثال، می توانید از بسته اتمی برای پیاده سازی نقشه یا صف همزمان استفاده کنید.\nپیاده سازی شمارنده (counter) از نوع atomic : شما با استفاده از پکیج atomic می توانید برای افزایش و کاهش شمارنده ها به صورت اتمی که می تواند برای اجرای مواردی مانند شمارش مرجع یا محدود کردن ratelimit استفاده شود.\n"},{"id":36,"href":"/chapter-3/goroutine-data-race/","title":"3.5 آموزش مقابله با data race","section":"فصل سوم: همزمانی (concurrency)","content":"معمولا تو بحث همزمانی یکی از اتفاقاتی که خیلی ممکن است رخ دهد بحث data race است و data race زمانی رخ می دهد که ۲ یا چند گوروتین قصد دارند به یک آدرس حافظه در یک زمان دسترسی داشته باشند. حال اگر ما جلوی data race را نگیریم ممکن است تغییرات نادرست برروی مقادیر داخل خانه حافظه صورت گیرد.\nراه هایی برای مقابله با data race وجود دارد که به شرح زیر است :\nاستفاده از Mutex داخل پکیج sync برای قفل گذاشتن/برداشتن یک بخش دیتا. استفاده RWMutex داخل پکیج sync می توانید داده اشتراک گذاری شده را قفل کنید فقط یک گوروتین عملیات نوشتن داشته باشد. استفاده از پکیج atomic برای عملیات بصورت atomic برروی مقادیر. 3.5.1 تشخیص Data Race # به لطف امکان جانبی زبان گو شما می توانید خیلی راحت بخش هایی که data race رخ داده را تشخیص دهید. کافیه سوییچ race- را هنگام build اضافه کنید تا در زمان data race ها را تشخیص دهید.\n$ go run -race main.go ================== WARNING: DATA RACE Write at 0x00c000522c20 by goroutine 29: git.ramooz.org/ramooz/golang-components/event-driven/rabbitmq.(*Connection).handleReconnect() /home/user/Project/go/ramooz.org/medx/software-builder/vendor/git.ramooz.org/ramooz/golang-components/event-driven/rabbitmq/rabbit.go:86 +0x89 git.ramooz.org/ramooz/golang-components/event-driven/rabbitmq.NewConnection.func1() /home/user/Project/go/ramooz.org/medx/software-builder/vendor/git.ramooz.org/ramooz/golang-components/event-driven/rabbitmq/rabbit.go:35 +0x58 Previous read at 0x00c000522c20 by main goroutine: git.ramooz.org/ramooz/golang-components/event-driven/rabbitmq.NewConnection() /home/user/Project/go/ramooz.org/medx/software-builder/vendor/git.ramooz.org/ramooz/golang-components/event-driven/rabbitmq/rabbit.go:37 +0x324 git.ramooz.org/ramooz/golang-components/logger.initializeRabbitMQ() /home/user/Project/go/ramooz.org/medx/software-builder/vendor/git.ramooz.org/ramooz/golang-components/logger/rabbit.conn.go:11 +0x226 git.ramooz.org/ramooz/golang-components/logger.NewLogger() /home/user/Project/go/ramooz.org/medx/software-builder/vendor/git.ramooz.org/ramooz/golang-components/logger/logger.go:37 +0x456 ramooz.org/ramooz/user-service/configs.initNewLogger() /home/user/Project/go/ramooz.org/medx/software-builder/configs/configs.go:158 +0x938 ramooz.org/ramooz/user-service/configs.ConfigServer() /home/user/Project/go/ramooz.org/medx/software-builder/configs/configs.go:54 +0x15a main.main() /home/user/Project/go/ramooz.org/medx/software-builder/main.go:17 +0x29 Goroutine 29 (running) created at: git.ramooz.org/ramooz/golang-components/event-driven/rabbitmq.NewConnection() /home/user/Project/go/ramooz.org/medx/software-builder/vendor/git.ramooz.org/ramooz/golang-components/event-driven/rabbitmq/rabbit.go:35 +0x2da git.ramooz.org/ramooz/golang-components/logger.initializeRabbitMQ() /home/user/Project/go/ramooz.org/medx/software-builder/vendor/git.ramooz.org/ramooz/golang-components/logger/rabbit.conn.go:11 +0x226 git.ramooz.org/ramooz/golang-components/logger.NewLogger() /home/user/Project/go/ramooz.org/medx/software-builder/vendor/git.ramooz.org/ramooz/golang-components/logger/logger.go:37 +0x456 ramooz.org/ramooz/user-service/configs.initNewLogger() /home/user/Project/go/ramooz.org/medx/software-builder/configs/configs.go:158 +0x938 ramooz.org/ramooz/user-service/configs.ConfigServer() /home/user/Project/go/ramooz.org/medx/software-builder/configs/configs.go:54 +0x15a main.main() /home/user/Project/go/ramooz.org/medx/software-builder/main.go:17 +0x29 ================== در خروجی بالا یک هشدار data race داده است که در فلان خط کد شما فلان گوروتین ها در یک زمان دسترسی برروی یک داده را دارند. و شما با توجه به خروجی می توانید سناریو های جلوگیری را انجام دهید.\n"},{"id":37,"href":"/chapter-3/go-channel/","title":"3.6 کانال (channel)","section":"فصل سوم: همزمانی (concurrency)","content":" کانال یک نوع تایپ است که داده از نوع خاصی را نگه داری میکند و امکان برقراری ارتباط و همگام سازی داده بین گوروتین ها را فراهم می کند. شما می توانید کانال ها را به عنوان خط لوله هایی در نظر بگیرید که این خط لوله ها به گوروتین ها متصل می شوند و باعث برقراری ارتباط بین گوروتین ها می شوند. این ارتباط بین گوروتین ها به هیچ قفل صریحی نیاز ندارد (منظورم mutex و \u0026hellip;) چون کانال ها بصورت داخلی قفل ها را مدیریت میکنند و در زمان های مناسب و مشخص Lock و UnLock می کنند.\nبه نقل از رابرت گریزمر که یکی از توسعه دهنده های اصلی زبان برنامه نویسی گو می باشد در خصوص کانال ها می گوید : با برقراری ارتباط حافظه را به اشتراک بزارید ولی با اشتراک گذاری حافظه ارتباط برقرار نکنید.\nمنظور از نقل فوق این است شما برای اینکه بخوای بین گوروتین ها ارتباط برقرار کنی این کار را با اشتراک گذاری حافظه نکنید. بلکه باید بواسطه کانال ها حافظه را بین گوروتین ها به اشتراک بزارید.\nزبان گو برای بحث همزمانی ۲ تا مقوله خیلی مهم دارد که این دو با هم در ارتباط هستند :\nگوروتین ها : یک thread مستقل و سبک وزن در زبان گو که قابلیت برنامه نویسی همزمان (concurrency) را فراهم می کند. کانال ها : فراهم کننده ارتباط و همگام سازی داده ها بین گوروتین ها. 3.6.1 تعریف کانال ها # همانطور که گفتیم کانال یک نوع تایپ است که داده از نوع خاصی را نگه داری میکند. برای استفاده از کانال ها، شما باید این تایپ را برای متغیری تعریف کنید تا بتوانید بواسطه آن متغیر از کانال استفاده کنید و بین گوروتین ها ارتباط برقرار کنید.\nvar \u0026lt;variable_name\u0026gt; chan \u0026lt;type\u0026gt; به مثال زیر توجه کنید :\npackage main import \"fmt\" func main() { var a chan int fmt.Println(a) } ▶ اجرای کد کپی ✖ بستن خروجی در بالا ما یک متغیر با نام a تعریف کردیم که از نوع کانال با تایپ int می باشد و این کانال فقط انتقال داده از نوع int را انجام می دهد. و مقدار پیش فرض کانال nil می باشد که در خروجی می توانید ببینید.\nتوجه کنید همیشه سعی کنید کانال را با استفاده از تابع make ایجاد کنید. package main import \"fmt\" func main() { a := make(chan int) fmt.Println(a) } ▶ اجرای کد کپی ✖ بستن خروجی در خروجی کد بالا همانطور که مشاهده می کنید به جای nil آدرس حافظه داده را نمایش می دهد.\nزمانیکه شما یک کانال را به واسطه make ایجاد می کنید در واقع دارید یک instance از ساختار hchan ایجاد می کنید و تمامی فیلدهای این ساختار مقدار پیش فرض میگیرند.\ntype hchan struct { qcount uint // total data in the queue dataqsiz uint // size of the circular queue buf unsafe.Pointer // points to an array of dataqsiz elements elemsize uint16 closed uint32 // denotes weather channel is closed or not elemtype *_type // element type sendx uint // send index recvx uint // receive index recvq waitq // list of recv waiters sendq waitq // list of send waiters lock mutex } 3.6.2 عملیات ها برروی کانال # زمانیکه شما یک کانال ایجاد می کنید، دو عملیات اصلی بر روی کانال می توانید انجام دهید :\nارسال : ارسال داده به داخل کانال دریافت : دریافت داده از کانال 3.6.2.1 عملیات ارسال # برای ارسال داده به داخل کانال یک اپراتور استاندارد وجود دارد که بهتر است همیشه به خاطر بسپارید :\nch \u0026lt;- val متغیر ch همان کانالی است که با استفاده از تایپ chan ساخته شده است. متغیر val هم مقداری است که توسط اپراتور \u0026lt;- به کانال ارسال شده است. توجه کنید تایپ val باید با تایپی که برای کانال مشخص کردید حتما یکی باشد. 3.6.2.2 عملیات دریافت # عملیات دریافت در کانال صرفا جهت خواندن داده از طریق کانال می باشد که یک قالب استاندارد همانند عملیات ارسال دارد :\nval := \u0026lt;- ch در اینجاهم ch همان متغیر کانال می باشد. متغیر val هم منتظر دریافت داده به واسطه \u0026gt;- از طریق کانال ch می باشد. 3.6.2.3 مثال عملیات ارسال و دریافت # در زیر یک مثال میزنیم که داده ای را بواسطه کانال ارسال/دریافت می کنیم بین گوروتین ها.\npackage main import ( \"fmt\" \"time\" ) func main() { ch := make(chan int) fmt.Println(\"Sending value to channel\") go send(ch) fmt.Println(\"Receiving from channel\") go receive(ch) time.Sleep(time.Second * 1) } func send(ch chan int) { ch \u003c- 1 } func receive(ch chan int) { val := \u003c-ch fmt.Printf(\"Value Received=%d in receive function\\n\", val) } ▶ اجرای کد کپی ✖ بستن خروجی در کد فوق ما یک کانال با نام ch از نوع int ایجاد کردیم. سپس ۲ تابع send و received را داخل گوروتین قرار دادیم که هر دو تابع به عنوان پارامتر ورودی تایپ int را بصورت کانال میگیرد. حال متغیر کانال ch را به هر دو تابع پاس دادیم. و در هر دو تابع ۲ تا عملیات صورت گرفته :\nتابع send مقدار عدد ۱ را به داخل کانال ارسال کرده تابع recived مقدار را از کانال ch دریافت کرده و داخل متغیر val قرار داده است و در نهایت متغیر val را چاپ کرده است. در انتهای تابع main ما یک sleep به مدت ۱ ثانیه قرار دادیم که بتوانیم خروجی برنامه را ببینیم. اگر اینکار را نکنیم گوروتین main ممکن است سریع تر از اینکه دو گوروتین دیگر اجرا شوند و خروجی آنها را ببینیم، کارش به اتمام برسد و برنامه متوقف شود.\nیک نکته بسیار مهمی که در مورد کانال ها وجود دارد و باید به آن توجه کنید این است که یک مقدار زمانی که داخل کانال ارسال می شود، فقط یکبار قابل دریافت کردن است. همانطور که می بینید هیچ قفلی در گوروتین ها موقع ارسال و دریافت استفاده نشده است و قفل ها توسط خود کانال مدیریت می شوند و نیازی به استفاده از قفل ها در کد نیست.\nبزارید یک مثال ساده برای اینکه ببینید چطور کانال ها Lock و UnLock می شوند بزنیم :\npackage main import ( \"fmt\" \"time\" ) func main() { ch := make(chan int) go send(ch) go receive(ch) time.Sleep(time.Second * 2) } func send(ch chan int) { time.Sleep(time.Second * 1) fmt.Println(\"Timeout finished\") ch \u003c- 1 } func receive(ch chan int) { val := \u003c-ch fmt.Printf(\"Receiving Value from channel finished. Value received: %d\\n\", val) } ▶ اجرای کد کپی ✖ بستن خروجی در کد فوق ما داخل تابع send یک sleep به مدت ۱ ثانیه قرار دادیم. و پس از اینکه ۱ ثانیه تمام شد مقدار را داخل کانال ch ارسال کردیم و سپس مقدار داخل تابع recived دریافت شد.\nاتفاقی که در کد فوق رخداد زمانیکه شما عملیات دریافت را انجام می دهید تا زمانیکه مقداری از کانال دریافت نشود اون بخش از کد شما Lock می شود و پس از اینکه دریافت شد مقدار از کانال آن بخش Unlock خواهد شد.\n3.6.3 ایجاد کانال بافر شده # تا اینجای کار ما از کانال های Un Buffered استفاده کردیم. در این نوع کانال ها تا زمانی که یک دریافت کننده نداشته باشیم نمی توانیم چیزی را در کانال ارسال کنیم و کد ما در آن خط لاک می شود تا دریافت کننده ای پیدا شود. برای درک کانال های Un Buffered بازی تنیس را درنظر بگیرید. فقط یک توپ داریم و یک شخص منتظر دریافت کردن توپ است و شخص دیگر در حال ارسال توپ.\nدر زبان گو شما می توانید کانال های بافر شده ایجاد کنید. یک کانال بافر دارای ظرفیتی مشخص برای نگه داری داده است. در این صورت نیازی نیست حتما یک دریافت کننده منتظر دریافت داده باشد تا بتوانیم داخل کانال چیزی ارسال کنیم. بلکه تا زمانی که ظرفیت کانال پر نشده باشد، می توانیم داده ارسال کنیم.\nبزارید کمی ساده تر توضیح دهیم شما برای کانال همانند آرایه و slice می توانید یک ظرفیت مشخصی تعیین کنید که این کانال فقط می تواند این مقدار از داده را نگه داری کند و تا زمانیکه مقادیر از کانال خارج نشود ظرفیت کانال پرخواهد بود و مقدار جدیدی را نمی توانید به کانال ارسال کنید.\nبرای ایجاد یک کانال بافر شده از روش زیر استفاده کنید :\na := make(chan , capacity) مقدار capacity که بصورت عدد هست تعداد بافر کانال را مشخص می کند که این کانال فقط می تواند این حجم از داده را داخل کانال نگه داری کند.\nبه مثال زیر توجه کنید :\npackage main import ( \"fmt\" ) func main() { ch := make(chan int, 1) ch \u003c- 1 fmt.Println(\"Sending value to channnel complete\") val := \u003c-ch fmt.Printf(\"Receiving Value from channel finished. Value received: %d\\n\", val) } ▶ اجرای کد کپی ✖ بستن خروجی در کد فوق ما یک کانال بافر شده با ظرفیت ۱ ایجاد کردیم و مقدار ۱ را به کانال ارسال کردیم و در ادامه این مقدار را از کانال دریافت کردیم.\nch := make(chan int, 1) 3.6.3.1 ارسال داده برروی کانال با ظرفیت پر # حالا فرض کنید می خواهیم به کانال بافر شده کد فوق یک مقدار دیگری را ارسال کنیم :\npackage main import ( \"fmt\" ) func main() { ch := make(chan int, 1) ch \u003c- 1 ch \u003c- 2 fmt.Println(\"Sending value to channnel complete\") val := \u003c-ch fmt.Printf(\"Receiving Value from channel finished. Value received: %d\\n\", val) } ▶ اجرای کد کپی ✖ بستن خروجی در کد فوق اتفاقی که افتاد ما یک کانال بافر شده با ظرفیت ۱ ایجاد کردیم ولی به این کانال ۲ تا مقدار ارسال کردیم:\nch \u0026lt;- 1 ch \u0026lt;- 2 در ادامه اتفاقی که صورت گرفت کانال ما به خاطر پر شدن ظرفیتش بلاک شده بود و داده دیگه ای را نمی توانست نگه داری کند. در نتیجه با خطای deadlock مواجه شد و برنامه کاملا متوقف شد :\nfatal error: all goroutines are asleep - deadlock! دریافت مجدد داده از کانال خالی شده # به مثال زیر توجه کنید :\npackage main import ( \"fmt\" ) func main() { ch := make(chan int, 1) ch \u003c- 1 fmt.Println(\"Sending value to channnel complete\") val := \u003c-ch val = \u003c-ch fmt.Printf(\"Receiving Value from channel finished. Value received: %d\\n\", val) } ▶ اجرای کد کپی ✖ بستن خروجی در کد فوق ما یک کانال بافر شده با ظرفیت ۱ ایجاد کردیم و یک مقدار را به کانال ارسال کردیم و در نهایت ۲ بار دریافت از کانال را فرخوانی کردیم. اما اتفاقی که افتاده بازم با خطای deadlock مواجه شدیم چون کانال خالی شده است و هیچ داده ای بیشتر از بافر اش ندارد.\n3.6.4 جهت های کانال # شما می توانید کانال را با جهت های مختلفی تعریف کنید که به شرح زیر است :\nدو طرفه : کانال با جهت دوطرفه مانند مثال های قبلی می باشد که شما chan int به این شکل تعریف می کنید. یک طرفه فقط ارسال : شما می توانید یک کانال ایجاد کنید که فقط عملیات ارسال chan\u0026lt;- int را انجام می دهد. یک طرفه فقط دریافت : شما می توانید یک کانال ایجاد کنید که فقط عملیات دریافت \u0026lt;-chan int را انجام می دهد. حالا این سوال پیش می آید چرا باید ما یک کانال ایجاد کنیم که عملیات فقط ارسال یا عملیات فقط دریافت را انجام می دهد. این کار وقتی مفید است که شما بخواهید برای پارامترهای ورودی یا خروجی توابع خود را محدود به یک عملیات در کانال کنید.\nکانال حالت های مختلفی دارد که شما پارامترهای ورودی و خروجی تابع استفاده کنید :\nchan کانال دوطرفه chan \u0026lt;- کانال فقط ارسال \u0026lt;-chan کانال فقط دریافت 3.6.4.1 کانال فقط ارسال # برای ایجاد کانال فقط ارسال شما می توانید به شکل زیر برای ورودی یا خروجی تابع تعریف کنید :\nfunc process(ch chan\u0026lt;- int){ doSomething } زمانیکه شما تلاش کنید کانال با جهت های مختلف به پارامتر ورودی تابع فقط ارسال کانالی را پاس دهید با خطای زیر مواجه خواهید شد :\ninvalid operation: \u0026lt;-ch (receive from send-only type chan\u0026lt;- int) به مثال ساده زیر توجه کنید :\npackage main import \"fmt\" func main() { ch := make(chan int, 3) go process(ch) fmt.Println(\u003c-ch) } func process(ch chan\u003c- int) { ch \u003c- 2 } ▶ اجرای کد کپی ✖ بستن خروجی در کد فوق ما یک تابع به نام process ایجاد کردیم که کانال فقط ارسال به عنوان پارامتر ورودی دارد و در ادامه ما کانال ch را که دو طرفه است به این تابع پاس دادیم و مقدار دریافتی را چاپ کردیم.\n3.6.4.2 کانال فقط دریافت # برای ایجاد کانال فقط دریافت شما می توانید به شکل زیر برای ورودی یا خروجی تابع تعریف کنید :\nfunc process(ch \u0026lt;-chan int){ doSomething } زمانیکه شما تلاش کنید کانال با جهت های مختلف به پارامتر ورودی تابع فقط دریافت پاس دهید با خطای زیر مواجه خواهید شد :\ninvalid operation: ch \u0026lt;- 2 (send to receive-only type \u0026lt;-chan int) به مثال ساده زیر توجه کنید :\npackage main import \"fmt\" func main() { ch := make(chan int, 3) ch \u003c- 2 process(ch) } func process(ch \u003c-chan int) { s := \u003c-ch fmt.Println(s) } ▶ اجرای کد کپی ✖ بستن خروجی 3.6.5 گرفتن ظرفیت یک کانال # شما می توانید همانند slice یا آرایه ظرفیت یک کانال را با استفاده از تابع ()cap ببینید.\npackage main import \"fmt\" func main() { ch := make(chan int, 3) fmt.Printf(\"Capacity: %d\\n\", cap(ch)) } ▶ اجرای کد کپی ✖ بستن خروجی توجه کنید ظرفیت کانال بافر نشده همیشه صفر است. 3.6.6 گرفتن طول یک کانال # شما با استفاده از تابع ()len می توانید طول و اندازه یک کانال را بگیرید و ببینید چه مقدار داده داخل کانال قرار دارد.\npackage main import \"fmt\" func main() { ch := make(chan int, 3) ch \u003c- 5 fmt.Printf(\"Len: %d\\n\", len(ch)) ch \u003c- 6 fmt.Printf(\"Len: %d\\n\", len(ch)) ch \u003c- 7 fmt.Printf(\"Len: %d\\n\", len(ch)) } ▶ اجرای کد کپی ✖ بستن خروجی 3.6.7 عملیات بستن (close) یک کانال # در زبان گو ما یک تابع Built-in به نام close داریم که می توانیم برای بستن یک کانال استفاده کنیم و زمانیکه که یک کانال بسته شود دیگر نمی توانیم داده ای را به آن کانال ارسال کنیم. کانال معمولا زمانی بسته می شود که همه داده ها ارسال شده است و داده دیگری برای ارسال نداریم و باید کانال را ببندیم.\nبه مثال زیر توجه کنید :\npackage main import ( \"fmt\" \"time\" ) func main() { ch := make(chan int) go sum(ch, 3) ch \u003c- 2 ch \u003c- 2 ch \u003c- 2 close(ch) time.Sleep(time.Second * 1) } func sum(ch chan int, len int) { sum := 0 for i := 0; i \u003c len; i++ { sum += \u003c-ch } fmt.Printf(\"Sum: %d\\n\", sum) } ▶ اجرای کد کپی ✖ بستن خروجی در کد فوق ما یک کانال بافر شده با ظرفیت ۳ ایجاد کردیم و سپس ۳ تا مقدار را به کانال ارسال کردیم و پس از آن کانال را با تابع close بستیم چون دیگر نمیخواهیم داده دیگری را ارسال کنیم.\nتوجه کنید ارسال داده برروی کانال بسته شده ممکن است برنامه شما با خطای panic مواجه و کاملا متوقف شود.\npackage main func main() { ch := make(chan int) close(ch) ch \u003c- 2 } ▶ اجرای کد کپی ✖ بستن خروجی اما برای اینکه بتوانیم جلوی این panic رخ داده را بگیریم می توانیم زمانیکه داریم از کانال مقدار دریافت می کنیم assertion انجام دهیم تا متوجه بسته بودن کانال شویم :\npackage main import ( \"fmt\" ) func main() { ch := make(chan int, 1) ch \u003c- 2 val, ok := \u003c-ch fmt.Printf(\"Val: %d OK: %t\\n\", val, ok) close(ch) val, ok = \u0026lt;-ch fmt.Printf(\u0026quot;Val: %d OK: %t\\n\u0026quot;, val, ok) } ▶ اجرای کد کپی ✖ بستن خروجی\nاگر مقدار ok از کانال دریافتی true باشد یعنی کانال بسته نشده است و اگر مقدار false دریافت کنیم یعنی کانال بسته شده است.\n3.6.8 استفاده از حلقه for-range برروی کانال # یکی از کاربردی ترین حالت های دریافت داده از کانال استفاده از حلقه for-range است که می توانید تا زمان بسته شدن کانال مقدار دریافت کنید.\npackage main import ( \"fmt\" \"time\" ) func main() { ch := make(chan int, 3) ch \u003c- 2 ch \u003c- 2 ch \u003c- 2 close(ch) go sum(ch) time.Sleep(time.Second * 1) } func sum(ch chan int) { sum := 0 for val := range ch { sum += val } fmt.Printf(\"Sum: %d\\n\", sum) } ▶ اجرای کد کپی ✖ بستن خروجی در کد فوق ما یک کانال بافر شده با ظرفیت ۳ ایجاد کردیم سپس ۳ تا مقدار به کانال ارسال کردیم و داخل تابع sum مقادیر را با استفاده از حلقه for-range دریافت و پس از آن چاپ کردیم.\nحالا یک سوال پیش می آید آیا ما اگر کانال را در تابع main نبندیم چه اتفاقی می افتد؟ اگر شما کانال را نبندید بطور حتمی با خطا deadlock مواجه خواهید شد. حلقه ای که داخل تابع sum قرار دادید برای دریافت داده هیچوقت متوقف نخواهد شد.\nپس سعی کنید همیشه و همه جا در جای درست بستن کانال را انجام دهید تا دچار مشکلات مختلف نشوید.\n3.6.9 کانال nil # همانطور که در اوایل این بخش گفتیم مقدار پیش فرض یک کانال nil است و زمانیکه ما یک کانال بدون تابع make تعریف می کنیم مقدار پیش فرضش nil خوهد بود.\npackage main import \"fmt\" func main() { var a chan int fmt.Print(\"Default zero value of channel: \") fmt.Println(a) } ▶ اجرای کد کپی ✖ بستن خروجی یکسری نکات در خصوص کانال nil وجود دارد :\nارسال داده به یک کانالی که nil است باعث بلاک شدن همیشگی کد شما در آن خط خواهد شد. دریافت داده به یک کانالی که nil است باعث بلاک شدن همیشگی کد شما در آن خط خواهد شد. بستن یک کانالی که nil باشد باعث panic برنامه شما خواهد شد. "},{"id":38,"href":"/chapter-3/go-select/","title":"3.7 آموزش استفاده از select","section":"فصل سوم: همزمانی (concurrency)","content":"در زبان گو select همانند switch می باشد که دارای case و default هستش اما یک فرق کلی دارد که به عملکردش برمیگردد. case های select برای عملیات ارسال و دریافت از کانال منتظر می ماند. در کل شما با استفاده از select می توانید از کانال های مختلف اطلاعات ارسال و دریافت کنید و پس از آن برروی آن اطلاعات عملیات انجام دهید.\nselect تا زمانی که یکی از case ها آماده شود بلاک می شود. اگر همزمان چندتا case برای انجام عملیات آماده شود select بصورت تصادفی یکی را انتخاب میکند تا عملیات تکمیل شود. select { case channel_send_or_receive: //Dosomething case channel_send_or_receive: //Dosomething default: //Dosomething } select از بین case ها موردی را انتخاب می کند که در آن عملیات ارسال یا دریافت کانال بلاک نشده باشد و آماده اجرا باشد. اگر چند مورد از case ها آماده باشد یکی از آنها بصورت تصادفی انتخاب می شود تا فرآیند را تکمیل کند.\nبزارید یک مثال ساده بزنیم :\npackage main import \"fmt\" func main() { ch1 := make(chan string) ch2 := make(chan string) go goOne(ch1) go goTwo(ch2) select { case msg1 := \u003c-ch1: fmt.Println(msg1) case msg2 := \u003c-ch2: fmt.Println(msg2) } } func goOne(ch chan string) { ch \u003c- \"From goOne goroutine\" } func goTwo(ch chan string) { ch \u003c- \"From goTwo goroutine\" } ▶ اجرای کد کپی ✖ بستن خروجی در کد فوق ما ۲ تا کانال تعریف کردیم و کانال ها را به توابع goOne و goTwo پاس دادیم سپس داخل تابع به هرکدام از کانال مقداری ارسال شد. حالا در ادامه بدنه main یک select قرار دادیم که هر یک از case ها منتظر دریافت اطلاعات از کانال مشخص شده‌اش است.\nبلافاصله پس از‌اینکه یکی از کانال ها آماده ارسال داده شود، کیس آن اجرا می شود. اگر هر دوی کانال ها همزمان آماده ارسال داده شوند، به‌صورت تصادفی یکی از case ها انتخاب می شود تا عملیات را تکمیل کند.\nکه در خروجی مقداری که از ch1 آمده را نمایش می دهد. اما اگر بخواهیم خروجی هر دو کانال را ببینیم می توانیم از حلقه استفاده کنیم. به مثال زیر توجه کنید :\npackage main import \"fmt\" func main() { ch1 := make(chan string) ch2 := make(chan string) go goOne(ch1) go goTwo(ch2) for i := 0; i \u003c 2; i++ { select { case msg1 := \u003c-ch1: fmt.Println(msg1) case msg2 := \u003c-ch2: fmt.Println(msg2) } } } func goOne(ch chan string) { ch \u003c- \"From goOne goroutine\" } func goTwo(ch chan string) { ch \u003c- \"From goTwo goroutine\" } ▶ اجرای کد کپی ✖ بستن خروجی در کد فوق ما select را داخل یک حلقه for قرار دادیم و گفتیم اگر مقدار i کوچکتر از ۲ بود ++i شود. که در هر دو تایم مقدار دریافتی از کانال ها را توانستیم به عنوان خروجی چاپ کنیم.\nهمانطور که قبلا گفتیم اگر شما داخل select یک case را بزارید که هیچ اطلاعات از کانال دریافت نکند ممکن است برنامه شما کاملا بلاک شود و با خطای deadlock مواجه شوید.\npackage main import \"fmt\" func main() { ch1 := make(chan string) select { case msg := \u003c-ch1: fmt.Println(msg) } } ▶ اجرای کد کپی ✖ بستن خروجی اتفاقی که در کد فوق رخ داد ما یک کانال ایجاد کردیم و سپس داخل select یک case قرار دادیم که منتظر دریافت داده از کانال می باشد. اما چون هیچ داده‌ای به کانال ارسال نمی شود برنامه بطور کلی در همان تیکه از کد بلاک می شود و در نهایت شما با این خطا مواجه خواهید شد.\n3.7.1 نحوه کنترل عملیات های کانال با select # در بالا در خصوص select توضیح دادیم که چه کاربردی هایی دارد اما بذارید توضیحات را تکمیل کنیم. وقتی شما قصد دارید از گوروتین و کانال استفاده کنید در اینجا select نقش خیلی پررنگی در کنترل عملیات کانال ها دارد. اینجاست که بحث همزمانی در زبان گو خیلی زیبا می شود. select می تواند بطور همزمان داده را از کانال دریافت کند و برای اجرا سایر عملیات آماده کند. بنابراین select همراه با کانال و گوروتین خیلی ابزار قدرتمندی برای کنترل و مدیریت همگام سازی و همزمانی می باشد.\n3.7.1.1 عملیات ارسال با select # در زیر یک مثالی زدیم که با استفاده از select داده ای را به کانال میریزیم و سپس آن داده را از کانال دیگر دریافت می کنیم :\npackage main import \"fmt\" func main() { ch1 := make(chan string) ch2 := make(chan string) go goOne(ch1) go goTwo(ch2) select { case msg1 := \u003c-ch1: fmt.Println(msg1) case ch2 \u003c- \"To goTwo goroutine\": } } func goOne(ch chan string) { ch \u003c- \"From goOne goroutine\" } func goTwo(ch chan string) { msg := \u003c-ch fmt.Println(msg) } ▶ اجرای کد کپی ✖ بستن خروجی در کد فوق ما با استفاده از یکی از case های select داده‌ای را داخل کانال ریختیم و آن داده را داخل گوروتین تابع goTwo دریافت کردیم و پس آن مقدار دریافتی را چاپ کردیم.\n3.7.2 استفاده از default در select # در زبان گو switch و select می توانند یک default داشته باشند. در اینجا default مربوط select رفتارش همانند default داخل switch می باشد. حالا اگر هر یک از case ها عملیات دریافت یا ارسالی برای اجرا نداشته باشند می توانید با استفاده از default از بلاک شدن برای همیشه جلوگیری کنید. و خیلی مهمه که بدانید وقتی دارید داخل select از default استفاده می کنید select از نوع non-blocking می شود. اگر شما داخل select از default استفاده نکنید ممکن است آن بخش کد شما مسدود شود تا زمانیکه یکی از case ها از کانال داده ای را دریافت کند تا ادامه عملیات صورت گیرد.\nبه مثال زیر توجه کنید :\npackage main import \"fmt\" func main() { ch1 := make(chan string) select { case msg := \u003c-ch1: fmt.Println(msg) default: fmt.Println(\"Default statement executed\") } } ▶ اجرای کد کپی ✖ بستن خروجی در کد فوق ما یک کانال ایجاد کردیم و دریافت داده از کانال را داخل یکی از case های select قرار دادیم و پس از آن default را قرار دادیم که از مسدود شدن برنامه جلوگیری کند.\n3.7.3 مسدود سازی select با استفاده از timeout # شما می توانید یک select را با استفاده از timeout بطور موقت تا یک بازه زمانی مسدود کنید. که اینکار توسط تابع After داخل پکیج time صورت میگیرد.\nfunc After(d Duration) \u0026lt;-chan Time تابع After یک مدت زمان میگیرد و سپس به عنوان خروجی یک کانال فقط دریافت از نوع Time برمیگرداند.\nبه مثال زیر توجه کنید :\npackage main import ( \"fmt\" \"time\" ) func main() { ch1 := make(chan string) go goOne(ch1) select { case msg := \u003c-ch1: fmt.Println(msg) case \u003c-time.After(time.Second * 1): fmt.Println(\"Timeout\") } } func goOne(ch chan string) { time.Sleep(time.Second * 2) ch \u003c- \"From goOne goroutine\" } ▶ اجرای کد کپی ✖ بستن خروجی در کد فوق ما در یکی از case های select تابع After را به عنوان کانال دریافت کننده قرار دادیم و سپس مقدار ۱ ثانیه به تابع After پاس دادیم و پس از ۱ ثانیه select از مسدودی خارج شد.\n3.7.4 select خالی # یک select خالی و بدون case می تواند برنامه شما را به‌طور کلی بلاک کند و باعث بروز خطای deadlock شود. اگر select خالی داخل یک گوروتین دیگری قرار گیرد آن گوروتین بطور کلی برای همیشه بلاک خواهد شد اما اگر داخل تابع main قرار دهید باعث بروز deadlock خواهد شد.\npackage main func main() { select {} } ▶ اجرای کد کپی ✖ بستن خروجی 3.7.5 استفاده از select در حلقه بینهایت # ما می توانیم select را داخل یک حلقه بینهایت قرار دهیم تا برای همیشه از case ها چندتا داده را بواسطه کانال دریافت کنیم و عملیاتی را انجام دهیم. همچنین اگر قصد داریم که آنقدر کیس ها چک شوند تا یکی از کانال ها برای ارسال و یا دریافت داده آماده باشد، می توانیم از این روش استفاده کنیم و در نهایت با return کردن از حلقه بینهایت خارج شویم.\npackage main import ( \"fmt\" \"time\" ) func main() { news := make(chan string) go newsFeed(news) printAllNews(news) } func printAllNews(news chan string) { for { select { case n := \u003c-news: fmt.Println(n) case \u003c-time.After(time.Second * 1): fmt.Println(\"Timeout: News feed finished\") return } } } func newsFeed(ch chan string) { for i := 0; i \u003c 2; i++ { time.Sleep(time.Millisecond * 400) ch \u003c- fmt.Sprintf(\"News: %d\", i+1) } } ▶ اجرای کد کپی ✖ بستن خروجی در کد فوق ما یک کانال بافر نشده با نام news ایجاد کردیم و این کانال را داخل گوروتین newsFeed و تابع printAllNews قرار داده‌ایم. تابع newsFeed یک مقداری را به کانال ارسال می کند. و ما داخل تابع printAllNews بواسطه حلقه بینهایت و select دریافت می کنیم و یکی از case های select عملیات timeout را دارد که بعد ۱ ثانیه حلقه را کاملا متوقف کند.\n3.7.6 select با یک کانال nil # معمولا اگر یک کانال nil را برای ارسال یا دریافت داخل case قرار دهید برنامه شما همیشه بلاک می شود. اگر شما داخل یکی از case ها بیاید پس از انجام عملیات مقدار یک کانال را nil بزارید case ای که مقدار داخل کانال را دریافت می کند غیرفعال می شود و به هیچ عنوان دیگر قابل استفاده نخواهد بود. و توسط select آن case کاملا نادیده گرفته خواهد شد و select منتظر دریافت و ارسال داده از سایر case ها خواهد بود.\npackage main import ( \"fmt\" \"time\" ) func main() { news := make(chan string) go newsFeed(news) printAllNews(news) } func printAllNews(news chan string) { for { select { case n := \u003c-news: fmt.Println(n) news = nil case \u003c-time.After(time.Second * 1): fmt.Println(\"Timeout: News feed finished\") return } } } func newsFeed(ch chan string) { for i := 0; i \u003c 2; i++ { time.Sleep(time.Millisecond * 400) ch \u003c- fmt.Sprintf(\"News: %d\", i+1) } } ▶ اجرای کد کپی ✖ بستن خروجی در کد فوق ما داخل case n := \u0026lt;-news پس از اینکه مقدار دریافتی را چاپ کردیم اومدیم مقدار کانال news را برابر nil قرار دادیم. حالا اگر داده‌ای به اون کانال ارسال شود دیگر نمی توانیم دریافت کنیم و select آن case را بطور کلی نادیده میگیرد.\ncase n := \u0026lt;-news: fmt.Println(n) news = nil 3.7.7 استفاده از break در select # شما می توانید break را داخل هر یک از case های select استفاده کنید.\nimport \"fmt\" func main() { ch := make(chan string, 1) ch \u003c- \"Before break\" select { case msg := \u003c-ch: fmt.Println(msg) break fmt.Println(\"After break\") default: fmt.Println(\"Default case\") } } ▶ اجرای کد کپی ✖ بستن خروجی در کد فوق ما با استفاده از break توانستیم select را کاملا متوقف کنیم و برنامه اتمام شود و اگر دقت کرده باشید بعد از break کلمات After break چاپ نشده.\nfmt.Println(\u0026quot;After break\u0026quot;) "},{"id":39,"href":"/chapter-3/go-context/","title":"3.8 پکیج context","section":"فصل سوم: همزمانی (concurrency)","content":" پکیج context یک پکیج built-in است که یکی از پرکاربرد ترین پکیج های زبان گو می باشد. کار اصلی این پکیج فراهم کردن بستری است که بتوان به داده های مشترک دسترسی داشت و یا بتوان آنها را به اشتراک گذاشت و مدیریت کرد. حتی اگر شما نخواسته باشید سمت این پکیج بروید به مرور زمان که جلوتر می روید با این پکیج رو به رو خواهید شد و مجبور خواهید بود این پکیج را یاد بگیرید.\nاین پکیج چندان بزرگ نیست و شاید بتوانید توابع و مفاهیم آن را خیلی زود یاد بگیرید اما حتما یک روزی این پکیج تبدیل به یکی از بنیادی ترین قسمت های کدتان خواهد شد.\nدر این بخش از کتاب سعی خواهد شد مفاهیم context به صورت ساده و قابل درک، بیان شود.\n3.8.1 context چیست؟ # در واقع context مانند یک درخت می باشد که کلی شاخه دارد و هر شاخه به شاخه های ریزتری تقسیم شده و در نهایت به برگ ها و میوه های درخت منتهی می شوند. حال شما می توانید در هر ناحیه شاخه والد را قطع کنید تا شاخه های فرزند از بین برود. در زبان گو context یک اینترفیس است که یکسری متد دارد که هریک از متدها می تواند عملیاتی را انجام دهد و این امکان را فراهم می کند هر وقت یک درخواست از سمت کلاینت به سرور می آید این درخواست می تواند در لایه های مختلف منتهی شود و داخل context می تواند یکسری key/value های مهم باشد که شما بتوانید در هر لایه، به آنها دسترسی داشته باشید و همچنین در صورت لزوم می توانید سیگنال cancel بفرستید که درخواستی که تا هرجا رفته است کنسل شود.\nدر ادامه با طرح یک مثال ساده به درک بهتر این موضوع کمک می کنیم :\nفرض کنید یک سرور http راه اندازی کردید (در فصل ۵ آشنا خواهید شد) که یکسری آدرس API دارد که کلاینت می تواند با استفاده از این آدرس ها با سرور شما ارتباط برقرار کند و عملیات مشخصی را انجام دهد. حال وقتی کلاینت درخواست می دهد. درخواست تا زمانیکه کامل شود و خروجی به کاربر نمایش داده شود می توانید این درخواست را بواسطه context در لایه های مختلف پروژه خود منتهی کنید و یکسری عملیات یا اطلاعات را در هر لایه از context بگیرید. اگر به دیاگرام فوق نگاه کنید اگر کلاینت درخواستش را لغو کند و درخواست کاربر به واسط context تا لایه Manager رفته باشد می تواند این درخواست در همان لایه متوقف شود و عملیات تکمیل نشود.\nبرای درک بهتر مثال فوق بهتره فایل صوتی زیر را گوش دهید تا بهتر بتوانید درک کنید :\nدانلود فایل صوت 3.8.1.1 کاربردهای context # لغو یک درخواستی که منتهی شده به لایه های مختلف پروژه بواسطه تابع cancel در پکیج context انتقال داده های حساس به لایه های مختلف بواسطه تابع WithValue در پکیج context گذاشتن timeout برروی context جهت لغو درخواستی که خیلی باعث منتظر ماندن می شود بواسطه تابع WithTimeout در پکیج context 3.8.1.2 معرفی اینترفیس context # بدنه اصلی یک context از اینترفیس تشکیل شده که یکسری متدها برای مدیریت یک درخواست برروی لایه های مختلف را دارد.\ntype Context interface { //It retures a channel when a context is cancelled, timesout (either when deadline is reached or timeout time has finished) Done() \u0026lt;-chan struct{} //Err will tell why this context was cancelled. A context is cancelled in three scenarios. // 1. With explicit cancellation signal // 2. Timeout is reached // 3. Deadline is reached Err() error //Used for handling deallines and timeouts Deadline() (deadline time.Time, ok bool) //Used for passing request scope values Value(key interface{}) interface{} } متد Done : بواسطه این متد که یک کانال فقط دریافت است شما می توانید سیگنال توقف درخواست را دریافت کنید و خطا برگردانید. متد Err : داخل این متد اینترفیس خطا وجود دارد که خطاهای مربوط به context را می توانید دریافت و مدیریت کنید. متد Deadline : با استفاده از این متد می توانید context هایی که از نوع Deadline هستند را مدیریت کنید. متد Value : با استفاده از این می توانید مقادیری که بصورت key/value داخل context ذخیره شده را دریافت کنید که بصورت اینترفیس یک key میگیرد و به صورت اینترفیس مقدار داخل key را برمیگرداند. 3.8.2 ایجاد یک context # شما با استفاده از ۲ تابع داخل پکیج context می توانید اولین context خام را ایجاد کنید و در واقع این context ایجاد شده می تواند والد تمامی context هایی که در لایه مختلف ایجاد کردید باشد.\nبرای ایجاد context گفتیم ۲ تابع وجود دارد که به شرح زیر می باشد :\ncontext.Background() : # داخل پکیج context ما یک تابع داریم به نام Background که اولین context خام و والد را میسازد و به شما یک اینترفیس از نوع Context می دهد.\nاین context ایجاد شده هیچ مقداری داخلش ندارد. هیچ وقت نمی تواند کنسل شود. و هیچ deadline ندارد. در هر صورت بدانید ریشه اصلی context شما با این تابع ایجاد می شود و نقطه شروع انتقال یک درخواست بین لایه هایتان با این context والد خواهد بود.\nfunc Background() Context context.ToDo() : # داخل پکیج context ما یک تابع داریم به نام ToDo که یک context خالی ایجاد می کند و هدف از این context ایجاد شده با ToDo این است هنوز برایمان مشخص نیست چکار میخوایم انجام بدیم با context می توانیم از این تابع استفاده کنیم. و معمولا برای تست ها و اعتبارسنجی و آنالیز کد خیلی کاربردی هست.\nو دقت کنید در پایه اصلی پروژه اتون بهتره از Background همیشه استفاده کنید.\nfunc TODO() Context 3.8.3 درخت Context # در واقع context خام یا ریشه که بواسطه تابع Background یا ToDo ایجاد می شود همانند یک درخت است که قرار است این درخت به شاخه های ریزتری تقسیم شود و هر یک از شاخه ها عملیات مختلفی کنترل شود و به شاخه های دیگر منتقل شود.\n3.8.3.1 ایجاد یک فرزند برای context # شما خیلی ساده مانند کد زیر می توانید یک فرزند برای درخت خود ایجاد کنید :\nrootCtx := context.Background() childCtx := context.WithValue(rootCtx, \u0026quot;key\u0026quot;, \u0026quot;value\u0026quot;) در کد فوق ما یک rootCtx ایجاد کردیم که همان درخت است و سپس اومدیم با استفاده از تابع WithValue یک شاخه ایجاد کردیم که داخل این شاخه یک key/value قرار دارد. که این key/value در لایه های دیگر که منتقل می شود قرار دارد.\n3.8.3.2 ایجاد دو فرزند برای context # rootCtx := context.Background() childCtx := context.WithValue(rootCtx, \u0026quot;key\u0026quot;, \u0026quot;value\u0026quot;) childOfChildCtx, cancelFunc := context.WithCancel(childCtx) در کد فوق :\nrootCtx درخت است childCtx فرزند اول است که با استفاده از WithValue ایجاد شده و یک مقدار key/value را نگه داری می کند. childOfChildCtx برای فرزند اول context ما یک فرزند دیگری ایجاد کردیم با استفاده از تابع WithCancel که این تابع به شما یک context و یک تابع از نوع cancelFunc برمیگرداند. 3.8.3.3 درخت چند سطحی # rootCtx := context.Background() childCtx1 := context.WithValue(rootCtx, \u0026quot;key1\u0026quot;, \u0026quot;value1\u0026quot;) childCtx2, cancelFunc := context.WithCancel(childCtx1) childCtx3 := context.WithValue(rootCtx, \u0026quot;user_id\u0026quot;, \u0026quot;some_user_id\u0026quot;) در کد فوق :\nrootCtx درخت است childCtx1 فرزند اول است که با استفاده از WithValue ایجاد شده و یک مقدار key/value را نگه داری می کند. childCtx2 برای فرزند اول context ما یک فرزند دیگری ایجاد کردیم با استفاده از تابع WithCancel که این تابع به شما یک context و یک تابع از نوع cancelFunc برمیگرداند. childCtx3 با استفاده از WithValue از rootCtx که درخت است تشکیل شده حالا اگر ما برای childCtx1 بیایم یک فرزند دیگر با نام childCtx4 اضافه کنیم بصورت زیر خواهد شد :\nchildCtx4 := context.WithValue(childCtx1, \u0026quot;current_time\u0026quot;, \u0026quot;some_time) 3.8.4 تابع context.WithValue # همانطور که گفتیم شما با استفاده از تابع WithValue می توانید مقادیری را بصورت key/value به context اضافه کنید و سپس این مقادیر را با استفاده از context به لایه های مختلف منتقل کنید.\nwithValue(parent Context, key, val interface{}) (ctx Context) دقت کنید شما می توانید بواسطه context.WithValue مقادیر خیلی مهم و حساس نظیر توکن ها و \u0026hellip; را به لایه های مختلف خود منتقل کنید و این مورد خیلی قابل اهمیت است با استفاده از context انجام دهید. // Root Context ctxRoot := context.Background() // Below ctxChild has acess to only one pair {\u0026quot;a\u0026quot;:\u0026quot;x\u0026quot;} ctxChild := context.WithValue(ctxRoot, \u0026quot;a\u0026quot;, \u0026quot;x\u0026quot;) // Below ctxChildofChild has access to both pairs {\u0026quot;a\u0026quot;:\u0026quot;x\u0026quot;, \u0026quot;b\u0026quot;:\u0026quot;y\u0026quot;} as it is derived from ctxChild ctxChildofChild := context.WithValue(ctxChild, \u0026quot;b\u0026quot;, \u0026quot;y\u0026quot;) در بالا ما یک ctxRoot ایجاد کردیم و سپس یک فرزند با استفاده از تابع WithValue ایجاد کردیم که یک مقدار از نوع key/value با نام a را داخل context فرزند قرار دادیم. حالا برای context فرزند مجدد با استفاده از WithValue یک فرزند دیگری ایجاد کردیم که یک مقدار دیگر از نوع key/value با نام b قرار دادیم حالا اگر دقت کنید ctxChildofChild دارای ۲ مقدار a و b هستش.\nبزارید یک مثال ساده بزنیم :\npackage main import ( \"context\" \"fmt\" ) func main() { ctx := context.WithValue(context.Background(), \"language\", \"Go\") fmt.Println(manager(ctx, \"language\")) } func manager(ctx context.Context, key string) string { if v := ctx.Value(key); v != nil { return v.(string) } return \"not found value\" } ▶ اجرای کد کپی ✖ بستن خروجی در کد فوق ما یک context ایجاد کردیم و داخلش با استفاده از WithValue مقدار key/value قرار دادیم و سپس این context را تابع manager پاس دادیم و داخل تابع manager ما با استفاده از متد Value که داخل اینترفیس ctx هست مقدار کلید language را گرفتیم.\nنکته کاربردی و مهم همیشه سعی کنید context را به عنوان اولین پارامتر برای توابع تعریف کنید. و بهتر است برای نام پارامتر ctx یا c بزارید. 3.8.5 تابع context.WithCancel # زمانیکه شما با استفاده از تابع WithCancel یک context فرزند ایجاد می کنید ۲ تا خروجی به شما می دهد اولی context و دومی تابع cancel می باشد. که شما می توانید تابع cancel را برای لغو درخواستی که از سمت کلاینت یا لایه های بالاتر اومده را انجام دهید.\ntype CancelFunc func() func WithCancel(parent Context) (ctx Context, cancel CancelFunc) حالا با استفاده از مثال زیر میتوانید بحث لغو کردن را بهتر درک کنید :\npackage main import ( \"context\" \"fmt\" \"time\" ) func main() { ctx := context.Background() cancelCtx, cancelFunc := context.WithCancel(ctx) go task(cancelCtx) time.Sleep(time.Second * 3) cancelFunc() time.Sleep(time.Second * 1) } func task(ctx context.Context) { i := 1 for { select { case \u003c-ctx.Done(): fmt.Println(\"Gracefully exit\") fmt.Println(ctx.Err()) return default: fmt.Println(i) time.Sleep(time.Second * 1) i++ } } } ▶ اجرای کد کپی ✖ بستن خروجی در کد فوق ما یک context فرزند با استفاده از WithCancel ایجاد کردیم که به عنوان خروجی cancelCtx و cancelFunc را داد. سپس cancelCtx را به تابع task منتقل کردیم تا عملیاتی را انجام دهد. حال در ادامه کد تابع main ما یک Sleep در حد ۳ ثانیه گذاشتیم و گفتیم تابع cancelFunc اجرا شود. اگر دقت کنید پس ۳ ثانیه سیگنال لغو به تابع task ارسال شده و خطای Gracefully exit را چاپ کردیم و پس از آن خطای context چاپ کردیم.\nنکته کاربردی و مهم همیشه سعی کنید تابع cancelFunc را پس از اینکه context فرزند را با WithCancel ایجاد کردید داخل defer قرار دهید.\nctx := context.Background() cancelCtx, cancelFunc := context.WithCancel(ctx) defer cancelFunc() 3.8.6 تابع context.WithTimeout # تابع WithTimeout یکی از کاربردی ترین context ها را برای ما ایجاد میکند و باعث می شود جلوی طول کشیدن یک درخواست خارجی یا عملیاتی را بگیرد و درخواست را لغو کند. این تابع همانند تابع WithCancel به شما تابع cancelFunc را می دهد و در عوض از شما یک مدت زمان را میگیرد.\nfunc WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) بزارید یک مثال ساده بزنیم :\npackage main import ( \"context\" \"fmt\" \"time\" ) func main() { ctx := context.Background() cancelCtx, cancel := context.WithTimeout(ctx, time.Second*3) defer cancel() go task1(cancelCtx) time.Sleep(time.Second * 4) } func task1(ctx context.Context) { i := 1 for { select { case \u003c-ctx.Done(): fmt.Println(\"Gracefully exit\") fmt.Println(ctx.Err()) return default: fmt.Println(i) time.Sleep(time.Second * 1) i++ } } } ▶ اجرای کد کپی ✖ بستن خروجی در کد فوق ما یک context فرزند با استفاده از تابع WithTimeout ایجاد کردیم و مدت زمان ۳ ثانیه به این تابع پاس دادیم و پس از آن context فرزند به همراه تابع cancelFunc دریافت کردیم. حالا تابع cancel را داخل defer قرار دادیم و cancelCtx را به تابع task1 که داخل گوروتین است پاس داده ایم سپس و یک Sleep به مدت ۴ ثانیه گذاشتیم تا، تابع main کارش تمام نشود. حال پس از اینکه ۳ ثانیه گذشت داخل select سیگنال cancel را دریافت کردیم و خطای context deadline exceeded که نشان دهنده اتمام شدن مدت زمان هست را چاپ کرده ایم. همانطور که متوجه شدید درخواست کلی ما لغو شده.\n3.8.7 تابع context.WithDeadline # تابع WithDeadline تا حدی شبیه به WithTimeout است اما با این تفاوت که پارامتر زمانی که میگیرد از نوع time.Time است و مدت زمانی که میگیرد براساس تایم هست مثلا شما میگید ۵ ثانیه بعد از زمان الان درخواست را لغو کند در صورتیکه withTimeout مدت زمان میگیرد که درخواست ۵ ثانیه مهلت دارد کارش را انجام دهد.\nfunc WithDeadline(parent Context, d time.Time) (Context, CancelFunc) به مثال زیر توجه کنید :\npackage main import ( \"context\" \"fmt\" \"time\" ) func main() { ctx := context.Background() cancelCtx, cancel := context.WithDeadline(ctx, time.Now().Add(time.Second*5)) defer cancel() go task(cancelCtx) time.Sleep(time.Second * 6) } func task(ctx context.Context) { i := 1 for { select { case \u003c-ctx.Done(): fmt.Println(\"Gracefully exit\") fmt.Println(ctx.Err()) return default: fmt.Println(i) time.Sleep(time.Second * 1) i++ } } } ▶ اجرای کد کپی ✖ بستن خروجی در کد فوق یک context فرزند با استفاده از تابع WithDeadline ایجاد کردیم و سپس با توجه به زمان فعلی مدت زمان ۵ ثانیه بعد را درنظر گرفتیم که مثلا اگر الان ساعت است 10:45:30 درخواست را در 10:45:35 لغو کند.\n3.8.8 نکات کاربردی # هیچوقت سعی نکنید اینترفیس context را داخل یک ساختار ذخیره کنید اما می توانید embed کنید. همیشه context باید بین لایه‌های خود منتقل کنید تا بتوانید کنترل بهتری برروی درخواست ها داشته باشید. همیشه سعی کنید context را به عنوان اولین پارامتر توابع قرار دهید. نام context به عنوان پارامتر توابع بهتر است ctx یا c باشد. اگر هنوز مطمئن نیستید که با context چکاری میخواهید انجام دهید بهتر است context را با context.ToDo ایجاد کنید. توجه کنید فقط تابعی که context والد را ایجاد کرده می تواند درخواست را لغو کند پس سعی نکنید تابع cancelFunc را به توابع زیرین پاس دهید. "},{"id":40,"href":"/chapter-3/go-concurrency-teqniques/","title":"3.9 تکنیک های همزمانی","section":"فصل سوم: همزمانی (concurrency)","content":" 3.9.1 ارسال سیگنال انجام شدن با کانال ساختار # شما می توانید با استفاده از کانال struct سیگنالی برای تکمیل شدن انجام یک کار را بفرستید.\npackage main import ( \"fmt\" \"time\" ) func task1(done chan struct{}) { // Do some work here fmt.Println(\"doing task 1\") time.Sleep(2 * time.Second) fmt.Println(\"task 1 has been completed\") done \u003c- struct{}{} } func task2(done \u003c-chan struct{}) { select { case \u003c-done: // Do some work here fmt.Println(\"doing task 2\") time.Sleep(2 * time.Second) fmt.Println(\"task 2 has been completed\") } } func main() { done := make(chan struct{}) go task1(done) go task2(done) time.Sleep(5 * time.Second) fmt.Println(\"all tasks has been completed\") } ▶ اجرای کد کپی ✖ بستن خروجی در کد فوق ما دو تابع به نام task1 و task2 داریم که داخل گوروتین هستند و به عنوان پارامتر ورودی یک کانال ساختار خالی میگیرد حال کانال ساختار را به هر دو تابع پاس دادیم در ابتدا task1 فرآیند خود را انجام می دهد و سپس سیگنال انجام شدن را می فرستد و در ادامه تابع task2 سیگنال را دریافت می کند و فرآیندهای خود را انجام می دهد.\nدر زبان گو شما وقتی یک struct کاملا خالی و بدون فیلد میسازید هیچ تخصیص حافظه‌ای برایش صورت نمیگیرد. 3.9.2 بررسی یک سرویس یا فرآیند با heartbeat # شما با استفاده از همزمانی می توانید یک heartbeat پیاده سازی کنید تا یک سرویس یا فرآیند را بطور مداوم طی بازه زمانی مشخصی زیر نظر داشته باشد و از وضعیت آن سرویس یا فرآیند به شما اطلاع دهد.\npackage main import ( \"fmt\" \"time\" ) func heartbeat(interval time.Duration, c chan\u003c- struct{}) { ticker := time.NewTicker(interval) for { select { case \u003c-ticker.C: c \u003c- struct{}{} } } } func task() { // Do some work here fmt.Println(\"Task running...\") } func main() { c := make(chan struct{}) go heartbeat(1*time.Second, c) for { select { case \u003c-c: task() } } } ▶ اجرای کد کپی ✖ بستن خروجی در کد فوق ما یک تابع به نام heartbeat ایجاد کردیم که طی مدت زمانی یک سیگنال می فرستد تا تابع task اجرا شود که وضعیت فرآیند یا سرویس را گزارش دهد. ما مدت زمان را ۱ ثانیه گذاشتیم و یک کانال ساختار ایجاد کردیم و به تابع heartbeat که داخل یک گوروتین هست پاس دادیم سپس هر ۱ ثانیه از طریق کانال c ما سیگنال اجرای task برای بررسی وضعیت سرویس یا فرآیند را دریافت میکنیم.\n3.9.3 ارسال درخواست‌های تکراری به سرور یا سرویسی # فرض کنید شما نیاز دارید به یک سرور یا سرویسی چندین درخواست تکراری را بصورت موازی بفرستید که به اینکار replicated requests می گویند.\nبه مثال زیر توجه کنید :\npackage main import ( \"fmt\" \"net/http\" ) func makeRequest(url string, c chan\u003c- *http.Response) { resp, err := http.Get(url) if err != nil { c \u003c- nil } else { c \u003c- resp } } func main() { urls := []string{\"http://example.com\", \"http://example.org\", \"http://example.net\"} c := make(chan *http.Response) defer close(c) for _, url := range urls { go makeRequest(url, c) } for i := 0; i \u003c len(urls); i++ { resp := \u003c-c if resp == nil { fmt.Println(\"Error making request\") } else { fmt.Println(resp.Status) } } } ▶ اجرای کد کپی ✖ بستن خروجی در کد فوق ما یک تابع makeRequest داریم که ۲ تا پارامتر ورودی دارد اولین پارامتر url میگیرد و دومین پارامتر یک کانال فقط ارسال از نوع http.Response* میگیرد. سپس یک ریکوئست با متد GET ایجاد میکند و خروجی را داخل کانال میفرستد. در تابع main ما یک لیست url داریم که قرار است بصورت موازی به این آدرس ها درخواست بفرستیم و خروجی را دریافت کنیم در اینجا یک کانال از نوع http.Response* ایجاد کردیم و سپس یک حلقه for-range قرار دادیم و به ازای هر یک از url ها تابع makeRequest را فراخوانی کرده‌ایم و سپس داخل گوروتین قرار داده‌ایم، در نهایت یک حلقه for-i داریم که به تعداد url ها شمارش میکند و از طریق کانال ریسپانس را دریافت می کند.\n3.9.4 بازیابی سلامتی یک گوروتین # در برنامه نویسی همزمانی خیلی مهم است شما به سلامتی یک گوروتین رسیدگی کنید که اگر گوروتین قادر به انجام کاری نیست مجدد بتوانید سلامتی گوروتین را بازیابی کنید. در زبان گو شما می توانید با استفاده از پکیج context گوروتین هایی که وضعیت سالمی ندارد را با راه اندازی مجدد سلامتی آنها را بازیابی کنید.\npackage main import ( \"context\" \"fmt\" \"time\" ) func unhealthyGoroutine(ctx context.Context) { for { select { case \u003c-ctx.Done(): fmt.Println(\"Goroutine is unhealthy, exiting\") return default: // Do some work here fmt.Println(\"Goroutine running...\") time.Sleep(500 * time.Millisecond) } } } func main() { ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second) defer cancel() for { go unhealthyGoroutine(ctx) \u003c-time.After(4 * time.Second) } } ▶ اجرای کد کپی ✖ بستن خروجی در کد فوق ما یک تابع به نام unhealthyGoroutine داریم که بصورت جداگانه در گوروتین های مختلف اجرا می شود و کاری را انجام می دهد. داخل تابع ما یک select داریم که در یکی از case هایش context.Done را بررسی میکنیم آیا فرآیند لغو شده است یا خیر. داخل تابع main ما یک context از نوع Timeout با مدت زمان ۳ ثانیه‌ای ایجاد کردیم و در ادامه داخل یک حلقه بینهایت تابع unhealthyGoroutine داخل گوروتین قرار دادیم و هر ۴ ثانیه یک نمونه از این تابع داخل گوروتین های مختلف اجرا می شود.\nدر اینجا کارهای داخل تابع unhealthyGoroutine انجام شود پس از ۳ ثانیه بواسطه context فرآیندها لغو می شود و از گوروتین خارج می شود. حال ما داخل تابع main اجازه دادیم یک گوروتین جدید و سالم را اجرا کند و جایگزین گوروتین ناسالم شود.\n3.9.5 پیاده سازی الگوریتم فیبوناچی با همزمانی # دنباله فیبوناچی مجموعه‌ای از اعداد است که در آن هر عدد حاصل جمع دو عدد قبلی است که معمولا با 0 و 1 شروع می شود. ، 55، 89، 144 و غیره. دنباله فیبوناچی به نام ریاضیدان ایتالیایی، لئوناردو پیزا، که به فیبوناچی نیز معروف بود، نامگذاری شده است. الگوریتم فیبوناچی روشی برای محاسبه عدد n در دنباله فیبوناچی است. روش‌های مختلفی برای پیاده‌سازی الگوریتم فیبوناچی وجود دارد، اما رایج‌ترین روش استفاده از بازگشت است.\nدر علوم و مهندسی کامپیوتر، از دنباله فیبوناچی برای تحلیل عملکرد الگوریتم هایی مانند برج هانوی و تکنیک جستجوی فیبوناچی استفاده می شود.\nدر زیر ما برای اینکه بتوانید در سریعترین حالت ممکن محاسبات را انجام دهیم خیلی ساده می توانیم از همزمانی و کانال استفاده کنیم و در کسری از ثانیه محاسبه کنیم.\npackage main import ( \"fmt\" ) func fibo(n int) \u003c-chan int { result := make(chan int) go func() { defer close(result) if n \u003c= 2 { result \u003c- 1 return } result \u003c- \u003c-fibo(n-1) + \u003c-fibo(n-2) }() return result } func main() { fmt.Println(\u003c-fibo(25)) } ▶ اجرای کد کپی ✖ بستن خروجی "},{"id":41,"href":"/chapter-3/go-concurrency-patterns/","title":"3.10 الگو های همزمانی","section":"فصل سوم: همزمانی (concurrency)","content":"الگو های همزمانی را در فصل ۹ در کنار سایر الگوهای طراحی قرار دادیم یک مرجع کامل از الگوهای طراحی برای زبان گو داشته باشیم. در این بخش فقط ما خلاصه توضیحی در خصوص الگوها قرار دادیم و شما را ارجاع می دهیم به صفحه الگو :\nعنوان توضیحات وضعیت Wait For Result با استفاده از الگو Wait For Result می توانید یک عملیاتی را بصورت همزمانی انجام دهید و سپس منتظر نتیجه عملیات صورت گرفته بمانید. برای اینکار از کانال استفاده می شود. ✅ Fan Out/In الگو Fan Out/In یک تکنیک همزمانی در زبان گو می باشد که به شما اجازه می دهد چندین کار را با گوروتین همزمان انجام دهید و در نتیجه خروجی این کارها را با هم ترکیب کنید و به عنوان نتیجه نهایی دریافت کنید. ✅ Wait For Task الگو wait for task یکی از الگوهای رایج در زبان گو می باشد و انتظار برای تکمیل یک تسک یا فرآیند استفاده می شود. یک تسک با استفاده از گوروتین اجرا می شود و پس اتمامش کار تسک از طریق کانال سیگنال انجام می فرستد. ✅ Drop الگو Drop یک الگو مهم برای انجام خدمات سنگین می باشد. خدماتی که مواقعی باعث می شود حجم درخواست هایش بیش از ظرفیت موجود باشد و این درخواست ها بواسطه این الگو می تواند Drop شود. به عنوان مثال سرویس های DNS باید از این الگو استفاده کنند. ✅ Context Cancellation Pattern الگو cancellation که حرکت تکنیکی هست برای ارسال سینگال به گوروتین ها استفاده می شود که باید اجرای کاری را متوقف کند و ایده اصلی این کار با استفاده بستن کانال صورت میگیرد. ✅ Semaphore الگو Semaphore برای مدیریت کنترل دسترسی به منابع مشترک در همزمانی استفاده می شود. فرض کنید بصورت موازی ۱۰۰ درخواست HTTP سمت سرور میاد و I/O شبکه برای پردازش همزمان این ۱۰۰ درخواست درگیر میشود و به مرور عملکرد کاهش می یابد. حال اگر ما بیایم این ۱۰۰ درخواست موازی را تقسیم کنیم به ۵ دسته ۲۰ تایی که بصورت همزمانی انجام شود باعث می شود I/O شبکه کاهش یابد و عملکرد بهتری را خواهیم داشت. ✅ Worker Pool با استفاده از الگو Bounded Work Pooling امکان محدود سازی تعداد گوروتین ها را براساس کار مشخصی دارید و گوروتین ها را محدود به تعداد دفعات کار مشخص شده محدود می شود. این الگو برای وقت مفید است که شما می خواهید منابع را به یک کار خاص محدود کنید. ✅ Retry Timeout شما از الگو Retry Timeout برای تلاش مجدد یکسری عملیات استفاده کنید. برای اینکار شما می توانید از حلقه و تابع After در پکیج time کمک بگیرید و برای هرتلاش یک timeout مشخص کنید. ✅ Channel Cancellation از کانال ها برای ارتباط بین گوروتین ها و هماهنگ کردن اجرا استفاده می شود. حال گاهی اوقات نیاز است که ما یکسری فرآیند را داخل گوروتین لغو کنیم. در اینجا می توانیم با استفاده از کانال سیگنال لغو کردن بفرستید تا عملیات هایی که گوروتین مورد نظر انجام می داد لغو شود. ✅ Producer-Consumer الگو producer-consumer یکی از کاربردی ترین الگوها در زبان گو می باشد که با استفاده از الگو می توانید بطور همزمان یکسری اطلاعات تولید کنید و بفرستید داخل کانال و این اطلاعات توسط مصرف کننده بواسطه کانال دریافت شود. ✅ Monitor الگوی مانیتور به گروتین‌ ها اجازه می‌دهد هنگام ورود به حالت خواب بدون مسدود کردن اجرا یا مصرف منابع، منتظر شرایط خاصی باشند. ✅ Future در زبان گو الگو Future راهی برای نمایش نتیجه یک عملیات ناهمزمان (asynchronous) است که ممکن است آن عملیات هنوز تکمیل نشده باشد اما این الگو به شما این امکان را می دهد کدی بنویسید که طوری رفتار کند که گویی نتیجه یک عملیات فورا در دسترس است. حتی اگر عملیات در پس زمینه در حال اجرا باشد. ✅ Pipeline الگو خط لوله (Pipeline) یکی از پرکاربردی ترین الگوها در همزمانی می باشد شما با استفاده از این الگو می توانید تسک های بزرگ را به تسک های کوچکتر و مستقل تقسیم کنید که می توانند بطور همزمان کار کنند. هر stage داخل یک گوروتین انجام می شود و بواسطه کانال داده ها بین stage های مختلف منتقل می شود. ✅ Subscription الگو Subscription یکی از الگوهای کاربردی برای پیاده سازی consumer می باشد که به یک آدرسی مشترک شوید و در بازده زمانی مختلف درخواست دهید و یکسری اطلاعات دریافت کنید. ✅ Bridge Channel با استفاده از الگو Bridge Channel می توانید بین ۲ کانال داده ای را منتقل کنید فرض کنید یک داده را به کانال input میفرستید و از دریافت داده آن را می توانید به کانال دیگری منتقل کنید و عملا شما یک پل برای انتقال داده ایجاد کردید. ✅ Queuing الگوی \u0026ldquo;صف\u0026rdquo; در زبان گو الگویی است که در آن از یک گوروتین برای بافر کردن و مدیریت ترتیب مقادیر ارسال شده و دریافت شده از یک کانال استفاده می شود. ✅ Rate limit الگوی Rate Limiting برای کنترل تعداد درخواست‌ها یا وظایف همزمان در یک بازه زمانی مشخص استفاده می‌شود. این الگو با استفاده از یک time.Ticker یا روش‌های مشابه، اجرای گوروتین‌ها یا پردازش داده‌ها را محدود می‌کند. ✅ Deadlock Recovery الگوی بازیابی از بن‌بست (Deadlock Recovery) برای شناسایی و بازیابی از وضعیت‌های بن‌بست استفاده می‌شود، جایی که چندین گوروتین به طور نامحدود منتظر منابعی هستند که توسط یکدیگر نگه داشته شده‌اند. بن‌بست می‌تواند به دلیل همگام‌سازی نادرست یا رقابت برای منابع در برنامه‌های همزمان رخ دهد. ✅ Lock-free synchronization همگام‌سازی بدون قفل (lock-free synchronization) به مجموعه‌ای از تکنیک‌ها و الگوهای برنامه‌نویسی گفته می‌شود که به چندین thread یا goroutine اجازه می‌دهد به طور همزمان و ایمن به داده‌های مشترک دسترسی پیدا کنند، بدون اینکه از primitiveهایی مثل Mutex یا قفل‌های سنتی استفاده شود. هدف اصلی این الگوها افزایش بازدهی (throughput)، کاهش زمان انتظار (latency) و جلوگیری از مشکلات رایج قفل‌گذاری (مثل deadlock، priority inversion و contention) است. الگوریتم‌های lock-free تضمین می‌کنند که حتی اگر برخی از threadها متوقف شوند یا دچار کندی شوند، باقی سیستم همچنان قادر به پیشرفت خواهد بود (progress guarantee). ✅ "},{"id":42,"href":"/chapter-4/","title":"فصل چهارم: مباحث پیشرفته","section":"صفحه اصلی","content":"در این بخش به مباحث پیشرفته تری از زبان گو می پردازیم که شامل بخش های زیر می باشد.\n۴.۱ پروژه Build آموزش ‌. ۴.۲ Debuggingآموزش کار با. ۴.۳ go mod آموزش کار با . ۴.۴ workspace آموزش کار با. ۴.۵ Vendor آموزش کار با. ۴.۶ command line آموزش نوشتن برنامه. آموزش کار با فایل ۴.۷. ۴.۸ json آموزش کار با. ۴.۹ toml آموزش کار با. ۴.۱۰ yaml آموزش کار با. ۴.۱۱ CSV آموزش کار با. ۴.۱۲ ini آموزش کار با. ۴.۱۳ enviroment variable آموزش کار با. ۴.۱۴ regexp آموزش کار با. ۴.۱۵ reflection آموزش. ۴.۱۶ generator آموزش. ۴.۱۷ stringerآموزش. تکنیک های کد نویسی زبان گو ۴.۱۸. اصول کامنت نویسی ۴.۱۹. قوانین کد نویسی در زبان گو ۴.۲۰. ۴.۲۱ (garbage collector)زباله جمع کن. ۴.۲۲ Plugin کتابخانه. ۴.۲۳ شی گرایی در زبان گو. ۴.۲۴ tracing آموزش ۴.۲۵ profiling آموزش "},{"id":43,"href":"/chapter-4/build-go-file/","title":"4.1 آموزش Build پروژه","section":"فصل چهارم: مباحث پیشرفته","content":"برای build یک پروژه شما باید از کامند go build استفاده کنید که این کامند دارای یکسری سوییچ می باشد که در زیر ما معرفی خواهیم کرد.\n4.1.1 نحوه build یک فایل گو # معمولا شما باید برای build فایلی که دارای package main هست را برای build استفاده کنید مانند مثال زیر :\n$ go build main.go پس از build در محل همان فایل یک فایل با نام main ایجاد می شود.\nاگر فایل main شما در روت پروژه باشد نیازی نیست به دستور go build نام فایل را بدهید کافیه مانند دستور زیر پروژه را build کنید.\n$ go build . خروجی یک فایل با نام پروژه ایجاد می شود.\n4.1.2 استفاده از gcflags برای build # همانطور که گفتیم کامند build دارای یکسری سوییچ می باشد که یکی از سوییچ هایش gcflags می باشد که می توانید هنگام build یکسری اطلاعات مربوط به دیباگ به فایل خروجی اضافه می شود.\n$ go build -gcflags \u0026quot;-N -l\u0026quot; main.go توجه کنید این نوع build گرفتن برای انجام Remote Debugging که در بخش بعدی آموزش می دهیم خیلی کاربردی می باشد.\n4.1.3 تعیین نام خروجی فایل, معماری و سیستم عامل # اگر یادتان باشد در بخش تاریخچه زبان گو یکی از ویژگی های بارزی که در خصوص زبان گو گفتیم بحث Cross-Platform Build بود که شما می توانید در همان سیستم عاملی که هستید برای سایر پلت فرم ها و سیستم عامل ها خروجی بگیرید.\n$ GOOS=linux GOARCH=amd64 go build -o myproject main.go کامند فوق در لینوکس و سیستم عامل های یونیکسی کاربردی است که شما می توانید قبل از فرمان اصلی یکسری environment variables تعیین کنید. که در کامند فوق ما ۲ تا environment قرار دادیم اولی برای تعیین سیستم عامل هست و دومی معماری هست که ۳۲ بیت یا ۶۴ بیت و همچنین از نوع arm باشد. سپس فرمان go build را قرار دادیم حال خروجی فایل مناسب برای هر سیستم عامل لینوکس با معماری amd64 (۶۴ بیت) می باشد. و در انتهای کامند یک سوییچ o- قرار دادیم که نام خروجی فایل build شده چی باشد.\n4.1.4 گرفتن build به همراه race detector # در فصل سوم یک بخشی داشتیم به نام data race که در خصوصش توضیح دادیم چطور جلوی این اتفاق را در همزمانی بگیریم. حال یک سوییچ در کامند build داریم به نام race- برای تشخیص data race کمک می کند.\n$ go build -race 4.1.5 مقدار دهی متغیر هنگام build # اما یکی از سوییچ های خیلی جالب در زبان گو هست که هنگام build پروژه می تواند متغیری را در هرجای پروژه مقدار دهی کند و از کاربردهای آن می توان برای تعیین ورژن پروژه و\u0026hellip; می باشد.\npackage main import \u0026quot;fmt\u0026quot; var ( Version string BuildTime string ) func main() { fmt.Printf(\u0026quot;version %s, build time %s\u0026quot;, Version, BuildTime) } $ go build -ldflags \u0026quot;-X main.Version=1.0.0 -X main.BuildTime=`date -u +%Y-%m-%dT%H:%M:%SZ`\u0026quot; main.go $ ./main version 1.0.0, build time 2023-01-27T14:19:23Z در کد فوق ما ۲ متغیر ایجاد کردیم که هنگام build مقدار دهی کنیم و به کامند build ما یک سوییچ ldflags- اضافه کردیم و آدرس متغیرها را جهت مقدار دهی به این کامند داده‌ایم.\nتوجه کنید اگر متغیرهایتان داخل پکیج (پوشه ای) مانند configs بود آدرس متغییر بصورت زیر می شود :\n$ go build -ldflags \u0026quot;-X configs.Version=1.0.0 -X configs.BuildTime=`date -u +%Y-%m-%dT%H:%M:%SZ`\u0026quot; main.go "},{"id":44,"href":"/chapter-4/debugging-go-code/","title":"4.2 آموزش کار با Debugging","section":"فصل چهارم: مباحث پیشرفته","content":"برای بحث debugging در زبان گو روش های مختلفی وجود دارد که محبوبترین روش ها به شرح زیر می باشد :\nبا استفاده پکیج fmt : شما با استفاده از تابع fmt.Println می توانید مقادیر برخی از متغیرها را چاپ کنید و یکی از روش های ساده برای بحث دیباگ هستش. با استفاده از پکیج log : یکی از کاربردی ترین روش ها بحث لاگ کردن هستش که شما می توانید هر بخش از کدهای خود را لاگ کنید و بصورت زنده در console یا داخل فایل ببینید و از همه مهمتر شما می توانید لاگ های خود را سطح بندی کنید تا بهتر بتوانید دیباگ کنید. استفاده از پکیج pprof : پکیج pprof به شما کمک می کند تا راحتر مشکلات عملکردی برنامه خود را بیابید و همچنین خروجی profile از عملکرد برنامه با CPU و Memory را آنالیز کنید. با استفاده از IDE ها: اکثر IDE هایی (Goland, Vscode) که قبلا معرفی کردیم دارای دیباگر داخلی می باشند که شما می توانید در هر بخش از کد خود breakpoint بزارید و خط به خط کد را دیباگ کنید و مشکلات را برطرف کنید. با استفاده از دیباگر dlv : یکی از محبوبترین دیباگرهایی بصورت متن باز در حال توسعه است delve می باشد که به شما برای دیباگ کردن بصورت تعاملی هنگام اجرا کمک می کند. حال در ادامه ما با مثال هایی نحوه کار با این شیوه هایی که معرفی کردیم آموزش می دهیم.\n4.2.1 نحوه دیباگ با fmt # شما با استفاده از تابع fmt.Println می توانید مقادیر برخی از متغیرها را چاپ کنید و برای اینکار به مثال ساده زیر توجه کنید :\npackage main import \"fmt\" func fibonacci(n uint) uint { if n \u003c 2 { return n } var a, b uint b = 1 for n--; n \u003e 0; n-- { a += b a, b = b, a fmt.Println(\"this is example debugging value a is \", a, \" value b is \", b) } return b } func main() { fmt.Println(fibonacci(100)) } ▶ اجرای کد کپی ✖ بستن خروجی در کد فوق برای اینکه مقدار a, b را ببینیم از تابع Println استفاده کردیم تا مقدار داخل این دو متغیر را ببینیم.\n4.2.2 نحوه دیباگ با استفاده log # یکی از کاربردی ترین روش ها بحث لاگ کردن هستش که شما می توانید هر بخش از کدهای خود را لاگ کنید و بصورت زنده در console یا داخل فایل ببینید و از همه مهمتر شما می توانید لاگ های خود را سطح بندی کنید تا بهتر بتوانید دیباگ کنید. حال برای اینکه با log دیباگ کنید یک پکیج استاندارد به نام log داریم که می توانید بسته به نیازتان تغییرات دهید و هچنین پکیج هایی نظیر zap, logrus و \u0026hellip; هست برای بحث لاگ به شما خیلی کمک می کنند.\npackage main import ( \"log\" \"os\" ) func main() { // Set the log level to Info log.SetFlags(0) log.SetPrefix(\"[Info] \") log.SetOutput(os.Stdout) log.Println(\"This is an informational message\") // Set the log level to Warning log.SetPrefix(\"[Warn] \") log.SetOutput(os.Stdout) log.Println(\"This is a warning message\") // Set the log level to Error log.SetPrefix(\"[Error] \") log.SetOutput(os.Stderr) log.Println(\"This is an error message\") } ▶ اجرای کد کپی ✖ بستن خروجی در کد فوق ما با استفاده از تابع SetPrefix یک پیشوند برای لاگ ها اضافه کردیم تا بتوانیم لاگ با سطح های مختلف ایجاد کنیم. و با استفاده از log.Println لاگ را چاپ کردیم. در ادامه این فصل به بحث آموزش کار به log میپردازیم.\n4.2.3 دیباگ عملکرد با استفاده از pprof # زبان گو یک ابزار داخلی دارد جهت آنالیز و دیباگ عملکرد به نام pprof که با استفاده از آن می توانید یکسری اطلاعات در خصوص عملکرد برنامه تهیه کنید و براساس آنالیز اطلاعات مشکلات عملکردی را می توانید برطرف کنید.\npackage main import ( \"log\" \"net/http\" _ \"net/http/pprof\" ) func main() { log.Println(http.ListenAndServe(\"localhost:6060\", nil)) } ▶ اجرای کد کپی ✖ بستن خروجی در کد فوق ما از پکیج مسیر net/http/pprof استفاده کردیم تا عملکرد برنامه را در وب سرور زبان گو را آنالیز و دیباگ کنیم. حال اگر به آدرس http://localhost:6060/debug/pprof/ بروید می توانید وضعیت عملکرد وب سرور را در لحظه ببینید و آنالیز کنید.\n4.2.3.1 آنالیز وضعیت CPU # برای آنالیز وضعیت CPU کافیه کامند زیر را بزنید :\ngo tool pprof http://localhost:6060/debug/pprof/profile 4.2.3.2 آنالیز وضعیت heap memory # برای آنالیز حافظه heap کافیه کامند زیر را بزنید :\ngo tool pprof http://localhost:6060/debug/pprof/heap Fetching profile over HTTP from http://localhost:6060/debug/pprof/heap Saved profile in /home/javad/pprof/pprof.main.alloc_objects.alloc_space.inuse_objects.inuse_space.001.pb.gz File: main Type: inuse_space Time: Jan 27, 2023 at 6:46pm (+0330) Entering interactive mode (type \u0026quot;help\u0026quot; for commands, \u0026quot;o\u0026quot; for options) (pprof) pdf زمانیکه کامند فوق را بزنید وارد شل pprof خواهید شد که می توانید با زدن help کامندهای کاربردی را جهت آنالیز ببینید. به عنوان مثال pdf را بزنید یک خروجی pdf بصورت گراف از وضعیت حافظه heap ارائه می دهد که می توانید وضعیت را آنالیز کنید (جهت خواندن گراف این آموزش را مطالعه کنید).\n4.2.4 دیباگ با استفاده از GDB # این قسمت با استفاده از مستندات رسمی GO در مورد 1. Debugging Go Code with GDB نوشته شده است. دستورالعمل های زیر برای استاندارد toolchain (کامپایلر و ابزارهای gc Go) اعمال می شود. Gccgo دارای پشتیبانی از native gdb به صورت پیش فرض است.\nتوجه داشته باشید که هنگام اشکال زدایی برنامه های Go که باstandard toolchain ساخته شده اند، Delve جایگزین بهتری برای GDB است. زیرا Go runtime را بهتر تشخیص می‌دهد و ساختارهای داده و عبارات را بهتر از GDB درک می کند. Delve در حال حاضر از Linux، OSX و Windows در amd64 پشتیبانی می کند. برای به روزترین لیست پلتفرم های پشتیبانی شده، لطفاً به Delve documentation مراجعه کنید.\nGDB برنامه های Go را به خوبی درک نمی کند. مدیریت stack و threading و runtime شامل جنبه هایی هستند که به اندازه کافی با مدل اجرایی متفاوت است که GDB انتظار دارد که می توانند debugger را اشتباه گرفته و نتایج نادرستی را حتی زمانی که برنامه با gccgo کامپایل می شود ایجاد کنند. در نتیجه، اگرچه GDB می‌تواند در برخی موقعیت‌ها مفید باشد (به عنوان مثال، اشکال‌زدایی کد Cgo، یا اشکال‌زدایی خود زمان اجرا)، اما برای برنامه‌های Go، به‌ویژه برنامه‌های به‌شدت همزمان هستند، اشکال‌زدایی با این روش چندان قابل اعتمادی نیست. علاوه بر این، پرداختن به این مسائل که دشوار هستند، برای پروژه Go در اولویت نیست.\nبه طور خلاصه، دستورالعمل‌های زیر باید تنها به‌عنوان راهنمای نحوه استفاده از GDB در هنگام کارکرد آن در نظر گرفته شود، نه به عنوان تضمین موفقیت اجرای درست برنامه. علاوه بر این نمای کلی، ممکن است بخواهید به GDB manual مراجعه کنید.\n4.2.4.1 مقدمه اولیه GDB # وقتی برنامه‌های Go را با toolchain مربوط gc در Linux، macOS، FreeBSD یا NetBSD کامپایل و link می‌دهید، باینری‌های به دست آمده حاوی اطلاعات اشکال‌زدایی DWARFv4 هستند که نسخه‌های اخیر (≥7.5) اشکال‌زدای GDB می‌توانند از آن برای بازرسی یک live process یا یک core dump استفاده کنند. .\nپرچم \u0026lsquo;-w\u0026rsquo; را به linker ارسال کنید تا اطلاعات debug را حذف کنید (به عنوان مثال، go build -ldflags=-w prog.go).\nکد تولید شده توسط کامپایلر gc شامل درون خطی کردن فراخوانی تابع و ثبت متغیرها است. این بهینه سازی ها گاهی اوقات می تواند اشکال زدایی با gdb را سخت تر کند. اگر متوجه شدید که باید این بهینه سازی ها را غیرفعال کنید، برنامه خود را با استفاده از go build -gcflags=all=-N -l بسازید.\nاگر می‌خواهید از gdb برای بررسی یک core dump استفاده کنید، می توانید یک Dump را در یک program crash راه اندازی کنید و برای این کار باید GOTRACEBACK=crash در environment تنظیم کنید (برای اطلاعات بیشتر به runtime package documentation مراجعه کنید).\n4.2.4.2 Common Operations # نمایش فایل و شماره خط برای کد، تعیین breakpoints و disassemble:\n(gdb) list (gdb) list _line_ (gdb) list _file.go_:_line_ (gdb) break _line_ (gdb) break _file.go_:_line_ (gdb) disas نمایش backtraces و باز کردن stack frames:\n(gdb) bt (gdb) frame _n_ نمایش نام، type و location در stack frame و local variables، آرگومان ها و مقادیر بازگشتی:\n(gdb) info locals (gdb) info args (gdb) p variable (gdb) whatis variable نمایش نام، type و location و global variables:\n(gdb) info variables _regexp_ 4.2.4.3 Go Extensions # اخیرا یک نوع extension به GDB اجازه می دهد تا extension scripts را برای یک باینری معین load کند. این toolchain برای extend GDB با تعداد انگشت شماری از command ها برای بررسی داخلی runtime code (مانند گوروتین ها) و pretty print the built-in map و slice وchannel types استفاده می کند.\nPretty printing a string, slice, map, channel or interface:(gdb) p var A $len() and $cap() function for strings, slices and maps: (gdb) p $len(var) A function to cast interfaces to their dynamic types: (gdb) p $dtype(var) (gdb) iface var مشکلات شناخته شده: GDB نمی تواند به طور خودکار dynamic type یک interface value را پیدا کند اگر نام طولانی آن با نام کوتاه آن متفاوت باشد (در هنگام printing stacktraces آزاردهنده است، pretty printer به نمایش نام short type و اشاره گر بازمی گردد).\nبررسی گوروتین ها:\n(gdb) info goroutines (gdb) goroutine _n_ _cmd_ (gdb) help goroutine به عنوان مثال:\n(gdb) goroutine 12 bt می توانید همه گوروتین ها را با pass کردن همه به جای goroutine\u0026rsquo;s ID خاص بررسی کنید. مثلا:\n(gdb) goroutine all bt اگر می‌خواهید ببینید که این حالت چگونه کار می‌کند یا می‌خواهید آن را گسترش دهید، به src/runtime/runtime-gdb.py در توزیع Go source نگاهی بیندازید. این به برخی از type های جادویی خاص (hash\u0026lt;T,U\u0026gt;) و متغیرهایی (runtime.m و runtime.g) بستگی دارد کهlinker (src/cmd/link/internal/ld/dwarf.go) اطمینان حاصل می کند که در کد DWARF توضیح داده شده اند.\nاگر به debugging information علاقه دارید، objdump -W a.out را اجرا کنید و در بخش های مرتبط با .debug_* مرور کنید.\nمشکلات شناخته شده: # ۱- حالت String pretty printing فقط برای type string فعال می شود، نه برای انواع مشتق شده از آن. ۲-Type information برای قسمت های C که در runtime library هستند، وجود ندارد. ۳- GDB شرایط Go’s name را نمی‌فهمد و «fmt.Print» را به‌عنوان یک کلمه بدون ساختار با یک «» در نظر می‌گیرد. که باید نقل شود. حتی با شدت بیشتری به method names فرم pkg.(*MyType).Meth. برخورد می کند. ۴- از Go 1.11، قسمت debug information به طور پیش فرض فشرده شده است. نسخه‌های قدیمی‌تر gdb، مانند نسخه‌ای که به‌طور پیش‌فرض در MacOS موجود است، فشرده‌سازی را درک نمی‌کنند. شما می توانید با استفاده از go build -ldflags=-compressdwarf=false‍ اطلاعات اشکال زدایی فشرده نشده تولید کنید. (برای راحتی می توانید گزینه -ldflags را در GOFLAGS environment variable قرار دهید تا مجبور نباشید هر بار آدرس آن را مشخص کنید.)\n4.2.4.4 مثال های GDB # در این آموزش ما باینری unit tests پکیج regexp را بررسی می کنیم. برای ساخت باینری، به GOROOT/src/regexp$ تغییر دهید و go test -c را اجرا کنید. این باید یک فایل اجرایی به نام regexp.test تولید کند.\nشروع دیباگ # Launch GDB, debugging regexp.test:\n$ gdb regexp.test GNU gdb (GDB) 7.2-gg8 Copyright (C) 2010 Free Software Foundation, Inc. License GPLv 3+: GNU GPL version 3 or later \u0026lt;http://gnu.org/licenses/gpl.html\u0026gt; Type \u0026quot;show copying\u0026quot; and \u0026quot;show warranty\u0026quot; for licensing/warranty details. This GDB was configured as \u0026quot;x86_64-linux\u0026quot;. Reading symbols from /home/user/go/src/regexp/regexp.test... done. Loading Go Runtime support. (gdb) پیام \u0026lsquo;Loading Go Runtime Support\u0026rsquo; به این معنی است که GDB برنامه extension را از مسیر GOROOT/src/runtime/runtime-gdb.py$ بارگیری کرده است.\nبرای کمک به GDB در یافتن آدرس Go runtime sources و سایر اسکریپت‌های همراه، $GOROOT را با پرچم \u0026lsquo;-d\u0026rsquo; ارسال کنید:\ngdb regexp.test -d $GOROOT$ اگر به دلایلی هنوز GDB نمی تواند آن دایرکتوری یا آن اسکریپت را پیدا کند، می توانید آن را دستی load کنید (با فرض اینکه go sources در آدرس ~/go/ باشد):\n(gdb) source ~/go/src/runtime/runtime-gdb.py Loading Go Runtime support. بررسی کردن source # از دستور \u0026rsquo;l\u0026rsquo; یا \u0026rsquo;list\u0026rsquo; برای بررسی source code استفاده کنید.\n(gdb) l بخش خاصی از منبع را که \u0026rsquo;list\u0026rsquo; را پارامتر می کند با نام تابع فهرست کنید (باید با نام بسته آن مرتبط باشد).\n(gdb) l main.main یک file خاص و line number را فهرست کنید:\n(gdb) l regexp.go:1 (gdb) _# Hit enter to repeat last command. Here, this lists next 10 lines._ Naming # نام متغیرها و توابع باید با نام package هایی که به آنها تعلق دارند قابل بازیابی باشند. به عنوان مثال تابع Compile از بسته regexp برای GDB به عنوان \u0026lsquo;regexp.Compile\u0026rsquo; شناخته می شود.\nمتدها باید با نام receiver types خود قابل بازیابی باشند. به عنوان مثال، *Regexp type’s String به عنوان 'regexp.(*Regexp).String' شناخته می شود.\nمتغیرهایی که سایر متغیرها را تحت shadow قرار می دهند، به صورت جادویی با یک عدد در debug info پسوند می شوند. متغیرهایی که توسط بسته‌ها ارجاع می‌شوند به‌عنوان اشاره‌گرهایی با پیشوند جادویی «\u0026amp;» ظاهر می‌شوند.\nقراردادن breakpoints # یک breakpoint در تابع TestFind تنظیم کنید: ‍‍\n(gdb) b 'regexp.TestFind' Breakpoint 1 at 0x424908: file /home/user/go/src/regexp/find_test.go, line 148. اجرا کردن برنامه:\n(gdb) run Starting program: /home/user/go/src/regexp/regexp.test Breakpoint 1, regexp.TestFind (t=0xf8404a89c0) at /home/user/go/src/regexp/find_test.go:148 148\tfunc TestFind(t *testing.T) { اجرا در breakpoint متوقف شده است. ببینید کدام گوروتین ها در حال اجرا هستند و چه کار می کنند:\n(gdb) info goroutines 1 waiting runtime.gosched * 13 running runtime.goexit موردی که با * مشخص شده است، گوروتین فعلی است.\nبررسی کردن stack # به خروجی از stack برای جایی که برنامه را متوقف کرده ایم نگاه کنید:\n(gdb) bt _# backtrace_ #0 regexp.TestFind (t=0xf8404a89c0) at /home/user/go/src/regexp/find_test.go:148 #1 0x000000000042f60b in testing.tRunner (t=0xf8404a89c0, test=0x573720) at /home/user/go/src/testing/testing.go:156 #2 0x000000000040df64 in runtime.initdone () at /home/user/go/src/runtime/proc.c:242 #3 0x000000f8404a89c0 in ?? () #4 0x0000000000573720 in ?? () #5 0x0000000000000000 in ?? () گوروتین دیگر، شماره 1، در runtime.gosched گیر کرده و در channel receive مسدود شده است:\n(gdb) goroutine 1 bt #0 0x000000000040facb in runtime.gosched () at /home/user/go/src/runtime/proc.c:873 #1 0x00000000004031c9 in runtime.chanrecv (c=void, ep=void, selected=void, received=void) at /home/user/go/src/runtime/chan.c:342 #2 0x0000000000403299 in runtime.chanrecv1 (t=void, c=void) at/home/user/go/src/runtime/chan.c:423 #3 0x000000000043075b in testing.RunTests (matchString={void (struct string, struct string, bool *, error *)} 0x7ffff7f9ef60, tests= []testing.InternalTest = {...}) at /home/user/go/src/testing/testing.go:201 #4 0x00000000004302b1 in testing.Main (matchString={void (struct string, struct string, bool *, error *)} 0x7ffff7f9ef80, tests= []testing.InternalTest = {...}, benchmarks= []testing.InternalBenchmark = {...}) at /home/user/go/src/testing/testing.go:168 #5 0x0000000000400dc1 in main.main () at /home/user/go/src/regexp/_testmain.go:98 #6 0x00000000004022e7 in runtime.mainstart () at /home/user/go/src/runtime/amd64/asm.s:78 #7 0x000000000040ea6f in runtime.initdone () at /home/user/go/src/runtime/proc.c:243 #8 0x0000000000000000 in ?? () همانطور که stack frame نشان می دهد، انتظار می رود الان باید در حال اجرای تابع regexp.TestFind باشیم.\n(gdb) info frame Stack level 0, frame at 0x7ffff7f9ff88: rip = 0x425530 in regexp.TestFind (/home/user/go/src/regexp/find_test.go:148); saved rip 0x430233 called by frame at 0x7ffff7f9ffa8 source language minimal. Arglist at 0x7ffff7f9ff78, args: t=0xf840688b60 Locals at 0x7ffff7f9ff78, Previous frame's sp is 0x7ffff7f9ff88 Saved registers: rip at 0x7ffff7f9ff80 دستور info locals همه متغیرهای محلی تابع و مقادیر آنها را فهرست می‌کند، اما استفاده از آن کمی خطرناک است، زیرا سعی می‌کند متغیرهای اولیه را نیز چاپ کند. برش‌های بدون مقدار اولیه ممکن است باعث شوند که gdb سعی کند آرایه‌های بزرگ دلخواه را چاپ کند.\nآرگومان های تابع:\n(gdb) info args t = 0xf840688b60 هنگام چاپ آرگومان، توجه کنید که نشانگر یک مقدار Regexp است. توجه داشته باشید که GDB به اشتباه * را در سمت راست نام تایپ قرار داده و یک کلمه کلیدی \u0026lsquo;struct\u0026rsquo; به سبک سنتی C ساخته است.\n(gdb) p re (gdb) p t $1 = (struct testing.T *) 0xf840688b60 (gdb) p t $1 = (struct testing.T *) 0xf840688b60 (gdb) p *t $2 = {errors = \u0026quot;\u0026quot;, failed = false, ch = 0xf8406f5690} (gdb) p *t-\u0026gt;ch $3 = struct hchan\u0026lt;*testing.T\u0026gt; که ساختار hchan\u0026lt;*testing.T\u0026gt; نمایش runtime-internal یک کانال است و در حال حاضر خالی است، وگرنه gdb محتویات آن را به زیبایی چاپ می کرد. حالا به قسمت مهم پیمایش دیباگر میرسیم که با حرف n صورت می‌گیرد.\nپیمایش دیباگر :\n(gdb) n _# execute next line_ 149 for _, test := range findTests { (gdb) _# enter is repeat_ 150 re := MustCompile(test.pat) (gdb) p test.pat $4 = \u0026quot;\u0026quot; (gdb) p re $5 = (struct regexp.Regexp *) 0xf84068d070 (gdb) p *re $6 = {expr = \u0026quot;\u0026quot;, prog = 0xf840688b80, prefix = \u0026quot;\u0026quot;, prefixBytes = []uint8, prefixComplete = true, prefixRune = 0, cond = 0 '\\000', numSubexp = 0, longest = false, mu = {state = 0, sema = 0}, machine = []*regexp.machine} (gdb) p *re-\u0026gt;prog $7 = {Inst = []regexp/syntax.Inst = {{Op = 5 '\\005', Out = 0, Arg = 0, Rune = []int}, {Op = 6 '\\006', Out = 2, Arg = 0, Rune = []int}, {Op = 4 '\\004', Out = 0, Arg = 0, Rune = []int}}, Start = 1, NumCap = 2} می توانیم با حرف \u0026rsquo;s\u0026rsquo; وارد فراخوانی Stringfunction شویم:\n(gdb) s regexp.(*Regexp).String (re=0xf84068d070, noname=void) at /home/user/go/src/regexp/regexp.go:97 97 func (re *Regexp) String() string { یک stack trace بگیرید تا ببینید کجا هستیم:\n(gdb) bt #0 regexp.(*Regexp).String (re=0xf84068d070, noname=void) at /home/user/go/src/regexp/regexp.go:97 #1 0x0000000000425615 in regexp.TestFind (t=0xf840688b60) at /home/user/go/src/regexp/find_test.go:151 #2 0x0000000000430233 in testing.tRunner (t=0xf840688b60, test=0x5747b8) at /home/user/go/src/testing/testing.go:156 #3 0x000000000040ea6f in runtime.initdone () at /home/user/go/src/runtime/proc.c:243 .... به source code نگاه کنید:\n(gdb) l 92 mu sync.Mutex 93 machine []*machine 94 } 95 96 // String returns the source text used to compile the regular expression. 97 func (re *Regexp) String() string { 98 return re.expr 99 } 100 101 // Compile parses a regular expression and returns, if successful, Pretty Printing\nمکانیسم چاپ زیبا GDB توسط regexp matches به صورت زیر می‌باشد:\n(gdb) p utf $22 = []uint8 = {0 '\\000', 0 '\\000', 0 '\\000', 0 '\\000'} از آنجایی که slice ها، آرایه ها و رشته ها اصلا اشاره‌گرهای C نیستند در نتیجه GDB نمی تواند عملیات subscripting را برای شما تفسیر کند، اما می توانید برای انجام این کار به نمایش runtime نگاه کنید (tab completion در اینجا کاربرد دارد):\n(gdb) p slc $11 = []int = {0, 0} (gdb) p slc-\u0026gt;* _\u0026lt;TAB\u0026gt;_ array slc len (gdb) p slc-\u0026gt;array $12 = (int *) 0xf84057af00 (gdb) p slc-\u0026gt;array[1] $13 = 0 توابع extension یا افزونه $len و $cap روی strings, arrays , slices کار می‌کنند:\n(gdb) p $len(utf) $23 = 4 (gdb) p $cap(utf) $24 = 4 Channelها و mapها در واقع typeهایی از جنس «reference» هستند که gdb آن‌ها را به‌عنوان اشاره‌گر به C++ like types مانند \u0026lt;hash\u0026lt;int,string\u0026gt;* نشان می‌دهد. Interface ها در runtime به عنوان یک اشاره گر به یک توصیفگر(descriptor) و یک اشاره گر به یک مقدار نشان داده می شوند. پسوند Go GDB در runtime این را رمزگشایی می کند و به طور خودکار pretty printing را برای runtime type ایجاد می کند. تابع افزونه dtype$ درنهایت یک dynamic type را برای شما رمزگشایی می‌کند (مثال‌هایی از یک breakpoint در خط 293 regexp.go گرفته شده‌اند.)\n(gdb) p i $4 = {str = \u0026quot;cbb\u0026quot;} (gdb) whatis i type = regexp.input (gdb) p $dtype(i) $26 = (struct regexp.inputBytes *) 0xf8400b4930 (gdb) iface i regexp.input: struct regexp.inputBytes * 4.2.5 معرفی دیباگر DELVE # delve یک debugger برای زبان برنامه نویسی GO است. هدف این پروژه ارائه یک ابزار ساده و کامل debugger برای GO است. DeLve باید به راحتی استفاده می‌شود و استفاده از آن آسان بسیار آسان می‌باشد.\n4.2.5.1 راهنمای نصب DELVE # دستورالعمل های زیر برای کار بر روی Linux، macOS، Windows و FreeBSD مورد استفاده قرار می‌گیرد.\nبرای Clone و build دستورات زیر رو داریم\ngit clone https://github.com/go-delve/delve cd delve go install github.com/go-delve/delve/cmd/dlv برای Go version 1.16 و بالاتر هم داریم:\n# Install the latest release: $ go install github.com/go-delve/delve/cmd/dlv@latest # Install at tree head: $ go install github.com/go-delve/delve/cmd/dlv@master # Install at a specific version or pseudo-version: $ go install github.com/go-delve/delve/cmd/dlv@v1.7.3 $ go install github.com/go-delve/delve/cmd/dlv@v1.7.4-0.20211208103735-2f13672765fe برای جزئیات در مورد محل ذخیره فایل اجرایی dlv به راهنمای نصب یا دستور go help install مراجعه کنید.\nاگر در مرحله نصب با خطای مشابه زیر مواجه شدید: 2\nfound packages native (proc.go) and your_operating_system_and_architecture_combination_is_not_supported_by_delve (support_sentinel.go) in /home/pi/go/src/github.com/go-delve/delve/pkg/proc/native یعنی از سیستم عامل یا معماری CPU شما پشتیبانی نمی شود، خروجی go version را بررسی کنید.\nبرای نصب در macOS از لینک macOS استفاده کنید.\n4.2.5.2 شروع استفاده از DELVE # هدف Delve یک ابزار بسیار ساده و قدرتمند است، اما اگر به استفاده از source level debugger در یک زبان کامپایل شده عادت ندارید این ابزار می‌تواند گیج‌کننده باشد. البته این سند تمام اطلاعاتی را که برای شروع اشکال زدایی برنامه های Go خود نیاز دارید را ارائه می دهد.\n4.2.5.3 Debugging \u0026lsquo;main\u0026rsquo; packages # اولین CLI subcommand که بررسی خواهیم کرد کلیدواژه debug است. این subcommand را می توان بدون آرگومان اجرا کرد اگر شما در همان دایرکتوری main package خود هستید، در غیر این صورت به صورت اختیاری یک package path را می پذیرد.\nبه عنوان مثال با توجه به این project layout داریم:\ngithub.com/me/foo ├── cmd │ └── foo │ └── main.go └── pkg └── baz ├── bar.go └── bar_test.go اگر در دایرکتوری github.com/me/foo/cmd/foo هستید، می توانید به سادگی dlv debug را از command line اجرا کنید. از هر جای دیگری، مثلاً project root، می توانید به سادگی package را معرفی کنید، به عنوان مثال: dlv debug github.com/me/foo/cmd/foo . برای ارسال flag‌ها به برنامه خود، آنها را به صورت زیر جدا سازی کنید:\n--: dlv debug github.com/me/foo/cmd/foo -- -arg1 value\nفراخوانی آن دستور باعث می شود که Delve برنامه را به روشی مناسب برای اشکال زدایی کامپایل کند و سپس برنامه اجرا شده و دیباگر به برنامه attach می شود و debug session را شروع می کند. حالا، هنگامی که جلسه debug session برای اولین بار شروع شده است، شما در ابتدای شروع اولیه برنامه هستید. برای رسیدن به جایی که مورد نظر هست باید یک یا دو breakpoint تعیین کنید و اجرا را تا آن نقطه ادامه دهید.\nبه عنوان مثال، برای ادامه اجرا به تابع main برنامه:\n$ dlv debug github.com/me/foo/cmd/foo Type 'help' for list of commands. (dlv) break main.main Breakpoint 1 set at 0x49ecf3 for main.main() ./test.go:5 (dlv) continue \u0026gt; main.main() ./test.go:5 (hits goroutine(1):1 total:1) (PC: 0x49ecf3) 1:\tpackage main 2: 3:\timport \u0026quot;fmt\u0026quot; 4: =\u0026gt; 5:\tfunc main() { 6:\tfmt.Println(\u0026quot;delve test\u0026quot;) 7:\t} (dlv) 4.2.5.4 Debugging tests # با توجه به ساختار دایرکتوری مشابه با بالا، می توانید کد خود را با اجرای مجموعه آزمایشی خود اشکال زدایی کنید. برای این کار می توانید از subcommand یا دستور dlv test استفاده کنید، که همان package path اختیاری را به عنوان dlv debug طی می کند و در صورت عدم ارائه آرگومان، package فعلی را نیز می سازد.\n$ dlv test github.com/me/foo/pkg/baz Type 'help' for list of commands. (dlv) funcs test.Test* /home/me/go/src/github.com/me/foo/pkg/baz/test.TestHi (dlv) break TestHi Breakpoint 1 set at 0x536513 for /home/me/go/src/github.com/me/foo/pkg/baz/test.TestHi() ./test_test.go:5 (dlv) continue \u0026gt; /home/me/go/src/github.com/me/foo/pkg/baz/test.TestHi() ./bar_test.go:5 (hits goroutine(5):1 total:1) (PC: 0x536513) 1:\tpackage baz 2: 3:\timport \u0026quot;testing\u0026quot; 4: =\u0026gt; 5:\tfunc TestHi(t *testing.T) { 6:\tt.Fatal(\u0026quot;implement me!\u0026quot;) 7:\t} (dlv) همانطور که می بینید، ما شروع به دیباگ کردن یک test binary کردیم، تابع تست خود را از طریق دستور funcs پیدا کردیم که یک regexp برای فیلتر کردن لیست توابع می گیرد، حالا یک breakpoint تعیین می کنیم و سپس اجرا را ادامه می دهیم تا زمانی که به آن breakpoint رسیدیم.\nبرای اطلاعات بیشتر در مورد subcommands که می‌توانید استفاده کنید، dlv help را تایپ کنید، و یک بار در debug session می‌توانید با تایپ help در هر زمانی، تمام دستورات موجود را مشاهده کنید.\n4.2.5.5 Synopsis و گزینه های Command line options # Delve شما را قادر می سازد تا با کنترل اجرای فرآیند، ارزیابی متغیرها و ارائه اطلاعات state thread / goroutine، همینطور CPU register state و موارد دیگر، با برنامه خود تعامل داشته باشید.\nهدف این ابزار ارائه یک رابط ساده و در عین حال قدرتمند برای اشکال زدایی برنامه های Go است. flagبرای استفاده از قابلیت های delve باید flagها را به برنامه‌ای که با استفاده از آن اشکال‌زدایی می‌کنید ارسال کنید، به کمک دستور -- برای مثال:\ndlv exec ./hello -- server --config conf/config.toml\nدر سایر گزینه ها داریم:\n--accept-multiclient Allows a headless server to accept multiple client connections via JSON-RPC or DAP. --allow-non-terminal-interactive Allows interactive sessions of Delve that don't have a terminal as stdin, stdout and stderr --api-version int Selects JSON-RPC API version when headless. New clients should use v2. Can be reset via RPCServer.SetApiVersion. See Documentation/api/json-rpc/README.md. (default 1) --backend string Backend selection (see 'dlv help backend'). (default \u0026quot;default\u0026quot;) --build-flags string Build flags, to be passed to the compiler. For example: --build-flags=\u0026quot;-tags=integration -mod=vendor -cover -v\u0026quot; --check-go-version Exits if the version of Go in use is not compatible (too old or too new) with the version of Delve. (default true) --disable-aslr Disables address space randomization --headless Run debug server only, in headless mode. Server will accept both JSON-RPC or DAP client connections. -h, --help help for dlv --init string Init file, executed by the terminal client. -l, --listen string Debugging server listen address. (default \u0026quot;127.0.0.1:0\u0026quot;) --log Enable debugging server logging. --log-dest string Writes logs to the specified file or file descriptor (see 'dlv help log'). --log-output string Comma separated list of components that should produce debug output (see 'dlv help log') --only-same-user Only connections from the same user that started this instance of Delve are allowed to connect. (default true) -r, --redirect stringArray Specifies redirect rules for target process (see 'dlv help redirect') --wd string Working directory for running the program. همینطور دستورات زیر را داریم:\ndlv attach - Attach to running process and begin debugging.\ndlv connect - Connect to a headless debug server with a terminal client.\ndlv core - Examine a core dump.\ndlv dap - Starts a headless TCP server communicating via Debug Adaptor Protocol (DAP).\ndlv debug - Compile and begin debugging main package in current directory, or the package specified.\ndlv exec - Execute a precompiled binary, and begin a debug session.\ndlv replay - Replays a rr trace.\ndlv run - Deprecated command. Use \u0026lsquo;debug\u0026rsquo; instead.\ndlv test - Compile test binary and begin debugging program.\ndlv trace - Compile and begin tracing program.\ndlv version - Prints version.\ndlv log - Help about logging flags\ndlv backend - Help about the --backend flag\n"},{"id":45,"href":"/chapter-4/go-mod/","title":"4.3 آموزش کار با go mod","section":"فصل چهارم: مباحث پیشرفته","content":"از نسخه 1.11 زبان گو مفهوم جدیدی برای مدیریت وابستگی ها آمد و جایگزین GOPATH شد. ماژول های گو این امکان را می دهد خیلی راحت ماژول های مختلف را به پروژه اضافه کنید و نسخه های هر ماژول را مدیریت کنید. با استفاده از ماژول گو برنامه نویسان گو محدود به GOPATH برای توسعه نخواهد بود و در جایی می توانند پروژه خود را ایجاد و ماژول های پروژه را به آسانی مدیریت کند.\nدر زیر یک نمونه از محتوای داخل فایل go.mod را قرار دادیم :\nmodule github.com/user/repo go 1.20 require ( github.com/sirupsen/logrus v1.8.1 github.com/spf13/cobra v1.2.1 ) در خط اول نام ماژول می باشد که داخل کد هرجایی که import انجام می دهید نام ماژول اولش قرار می گیرد مانند : package cmd import \u0026quot;github.com/user/repo/internal/app\u0026quot; علت اینکه نام ماژول را آدرس یک مخزن گیت را قرار می دهیم جهت قابل استفاده بودن ماژول می باشد که خیلی ساده بتوانید به پروژه های دیگر ماژولی که نوشتید را اضافه کنید.\nدر خط سوم نسخه زبان گو وجود دارد که شما هر نسخه ای را که تعیین میکنید فقط از ویژگی های همان نسخه به قبل را می توانید استفاده کنید. مثلا شما اگر نسخه 1.17 را گذاشته باشید و قصد داشته باشید از ویژگی جنریک که مربوط به نسخه 1.18 است استفاده کنید, هنگام کامپایل خطا می خورید.\nپس توجه کنید در اینجا سعی کنید از نسخه متناسب با نیاز خود را تعیین کنید هرچند هنگام ایجاد فایل go.mod زبان گو پیش فرض نسخه ای که نصب کرده اید را قرار می دهد.\nدر قسمت require ماژول های خارجی قرار میگیرد که داخل پروژه استفاده کردید. نظیر : github.com/sirupsen/logrus github.com/spf13/cobra به همراه نسخه مشخص اون ماژول.\nاما ماژول گو یک خوبی دارد خیلی راحت می توانید نسخه ماژول ها را به آسانی مدیریت کنید و ارتقا دهید.\nبرای مدیریت ماژول های گو یک کامند داریم به نام mod که یک سری دستورات کمکی برای مدیریت ماژول ها دارد که در ادامه آموزش می دهیم :\n$ go mod Go mod provides access to operations on modules. Note that support for modules is built into all the go commands, not just 'go mod'. For example, day-to-day adding, removing, upgrading, and downgrading of dependencies should be done using 'go get'. See 'go help modules' for an overview of module functionality. Usage: go mod \u0026lt;command\u0026gt; [arguments] The commands are: download download modules to local cache edit edit go.mod from tools or scripts graph print module requirement graph init initialize new module in current directory tidy add missing and remove unused modules vendor make vendored copy of dependencies verify verify dependencies have expected content why explain why packages or modules are needed Use \u0026quot;go help mod \u0026lt;command\u0026gt;\u0026quot; for more information about a command. برای اینکه اطلاعات بیشتری در خصوص کامند های go mod کسب کنید کافیه go help mod را قبل از کامند بزارید تا توضیحات بیشتری را ببینید.\n4.3.1 ایجاد go.mod # برای ایجاد فایل go.mod کافیه دستور زیر را در ریشه پروژه بزنید :\n$ go mod init github.com/user/repo پس از اینکه دستور فوق را زدید یک فایل go.mod ایجاد می شود داخلش محتوای زیر بدون ماژول خارجی می باشد :\nmodule github.com/user/repo go 1.20 4.3.2 افزودن ماژول خارجی به go.mod # برای افزودن یک ماژول خارجی به پروژه کافیه دستور زیر را در محل فایل go.mod بزنید :\n$ go get github.com/spf13/cobra زمانیکه دستور فوق را می زنید آخرین نسخه ماژول github.com/spf13/cobra را دریافت و به پروژه اضافه می کند.\nدقت کنید وقتی ماژول جدیدی را دریافت می کنید یک فایل go.sum در کنار فایل go.mod ایجاد می شود که داخل این فایل اطلاعات ماژول های خارجی به همراه ساب ماژول ها قرار دارد. که برای اطمینان از یکپارچگی و امنیت وابستگی های مورد استفاده در پروژه Go طراحی شده است. این فایل بصورت خودکار ایجاد و بروز می شود پس بهتر است تغییری در این فایل ندهید. 4.3.3 افزودن ماژول خارجی با تعیین نسخه # با دستور زیر می توانید یک ماژول خارجی با تعیین نسخه به پروژه خود اضافه کنید :\n$ go get github.com/spf13/cobra@v1.8.1 زمانیکه دستور فوق را می زنید نسخه v1.8.1 ماژول github.com/spf13/cobra را دریافت خواهید کرد.\n4.3.4 آپدیت یک ماژول خارجی به آخرین نسخه # برای آپدیت یک ماژول خارجی به آخرین نسخه کافیه دستور زیر را بزنید :\n$ go get -u github.com/spf13/cobra در دستور فوق ما سوییچ u- را اضافه کردیم تا آخرین نسخه ماژول github.com/spf13/cobra به پروژه اضافه و جایگزین نسخه های قدیمی شود.\n4.3.5 دستور go mod tidy # یک کامند پر کاربرد به نام tidy داریم که هر زمانی که اجرا می کنید کدهایی که در محل فایل go.mod قرار دارد بررسی می کند و ماژول های ایمپورت شده را به پروژه اضافه می کند و در صورتیکه شما ماژولی را حذف کردید و به هیچ عنوان در پروژه خود استفاده نکردید را از go.mod حذف می کند.\n$ go mod tidy اگر ماژول خارجی را استفاده کرده باشید در کدهای خود و هنوز به فایل go.mod اضافه نکرده باشید کامند tidy بصورت خودکار آخرین نسخه ماژول خارجی را دریافت و به فایل go.mod اضافه میکند.\n4.3.6 دستور go mod download # با استفاده از این کامند می توانید ماژول های خارجی داخل فایل go.mod را دریافت کرده و در لوکال خود کش کنید. تا بعدا از آن ماژول استفاده کنید.\n$ go mod download زمانیکه این دستور را بزنید شروع به دانلود ماژول های خارجی می شود و در لوکال شما این ماژول ها ذخیره می شود.\nبرای اینکه بتوانید ببینید وضعیت دانلود تا چه پیشرفته است می توانید سوییچ x- را اضافه کنید تا به شما وضعیت ماژول های در حال دریافت را نمایش دهد :\n$ go mod download -x 4.3.7 دستور go mod verify # با این دستور شما می توانید وضعیت ماژول ها را بررسی کنید که مورد تایید هست یا نه.\n$ go mod verify "},{"id":46,"href":"/chapter-4/workspace/","title":"4.4 آموزش کار با workspace","section":"فصل چهارم: مباحث پیشرفته","content":"با استفاده از workspace می توانید همزمان چندین ماژول در یک محل داشته باشید و هر ماژول را به راحتی مدیریت کنید و همچنین همزمان به آسانی این ماژول ها را build و اجرا کنید.\n$ go help work Work provides access to operations on workspaces. Note that support for workspaces is built into many other commands, not just 'go work'. See 'go help modules' for information about Go's module system of which workspaces are a part. See https://go.dev/ref/mod#workspaces for an in-depth reference on workspaces. See https://go.dev/doc/tutorial/workspaces for an introductory tutorial on workspaces. A workspace is specified by a go.work file that specifies a set of module directories with the \u0026quot;use\u0026quot; directive. These modules are used as root modules by the go command for builds and related operations. A workspace that does not specify modules to be used cannot be used to do builds from local modules. go.work files are line-oriented. Each line holds a single directive, made up of a keyword followed by arguments. For example: go 1.18 use ../foo/bar use ./baz replace example.com/foo v1.2.3 =\u0026gt; example.com/bar v1.4.5 The leading keyword can be factored out of adjacent lines to create a block, like in Go imports. use ( ../foo/bar ./baz ) The use directive specifies a module to be included in the workspace's set of main modules. The argument to the use directive is the directory containing the module's go.mod file. The go directive specifies the version of Go the file was written at. It is possible there may be future changes in the semantics of workspaces that could be controlled by this version, but for now the version specified has no effect. The replace directive has the same syntax as the replace directive in a go.mod file and takes precedence over replaces in go.mod files. It is primarily intended to override conflicting replaces in different workspace modules. To determine whether the go command is operating in workspace mode, use the \u0026quot;go env GOWORK\u0026quot; command. This will specify the workspace file being used. Usage: go work \u0026lt;command\u0026gt; [arguments] The commands are: edit edit go.work from tools or scripts init initialize workspace file sync sync workspace build list to modules use add modules to workspace file Use \u0026quot;go help work \u0026lt;command\u0026gt;\u0026quot; for more information about a command. پیش نیاز ها\nبرای استفاده از workspace حتما باید از نسخه 1.18 گو استفاده کنید. یک ابزار ادیت برای کار باید داشته باشید یک ترمینال مناسب جهت اجرا دستورات 4.4.1 ایجاد workspace # برای ایجاد یک workspace کافیه دستور زیر را بزنید تا در محل پروژه یک فایل go.work ایجاد شود.\n$ go work init 4.4.2 افزودن ماژول به workspace # در محل workspace یک پوشه ایجاد کنید و دستور go mod init را بزنید تا ماژول ایجاد شود و داخل این محل کدهای ماژول خود را قرار دهید. سپس با دستور go work use می توانید ماژول خود را به workspace اضافه کنید.\ngo work use ./module1 زمانیکه دستور فوق را بزنید پوشه module1 که داخلش ماژول از قبل ایجاد شده به فایل go.work اضافه می شود.\nحال اگر دستور زیر را بزنید می توانید آن ماژول را اگر پکیج main داشته باشد را می تواند اجرا کند :\n$ go run ./module1 "},{"id":47,"href":"/chapter-4/vendor/","title":"4.5 آموزش کار با Vendor","section":"فصل چهارم: مباحث پیشرفته","content":"در زبان گو یک کامند کاربردی در go mod به نام vendor داریم که ماژول هایی که داخل پروژه استفاده شده و مورد نیاز برای اجرا و بیلد می باشد را در محل پروژه کش می کند و به شما این امکان را می دهد خیلی سریع و راحت بدون نیاز به دانلود مجدد ماژول پروژه را بیلد و اجرا کنید.\n$ go help mod vendor usage: go mod vendor [-e] [-v] [-o outdir] Vendor resets the main module's vendor directory to include all packages needed to build and test all the main module's packages. It does not include test code for vendored packages. The -v flag causes vendor to print the names of vendored modules and packages to standard error. The -e flag causes vendor to attempt to proceed despite errors encountered while loading packages. The -o flag causes vendor to create the vendor directory at the given path instead of \u0026quot;vendor\u0026quot;. The go command can only use a vendor directory named \u0026quot;vendor\u0026quot; within the module root directory, so this flag is primarily useful for other tools. See https://golang.org/ref/mod#go-mod-vendor for more about 'go mod vendor'. 4.5.1 ایجاد vendor # با دستور زیر می توانید در محل پروژه خود پوشه vendor ایجاد کنید و ماژول های استفاده شده را داخل این پوشه کش کنید.\n$ go mod vendor 4.5.2 افزودن ماژول های جدید به vendor # در صورتیکه ماژول جدیدی را به پروژه اضافه کردید حتما باید بصورت دستی vendor را بروز کنید و کافیه دستور زیر را بزنید :\n$ go mod vendor 4.5.3 اجرا و بیلد پروژه با vendor # شما می توانید پروژه خود را با ماژول های کش شده داخل vendor اجرا و بیلد کنید و دیگر نیازی به دریافت ماژول ها و کش کردن محلی نمی باشد.\nنحوه بیلد\n$ go build -mod vendor -o main cmd/main.go نحوه اجرا\n$ go run -mod vendor main.go 4.5.4 نکات کاربردی # یکسری نکات در خصوص استفاده از vendor قرار دادم که به شما می کند تا از vendor به درستی استفاده کنید.\nاز vendor فقط برای پروژه ای استفاده کنید که می خواهد در محیط های مختلف اجرا شود. استفاده از vendor باعث افزایش سریع روند CI/CD هنگام بیلد و تست می شود. زمانیکه vendor ایجاد می کنید فایل بخش های استفاده شده هر ماژول خارجی قرار میگیرد و باعث می شود حجم vendor خیلی کم باشد (پس نگران اینکه vendor مانند npm_module است نباشید) استفاده vendor به IDE گولند کمک می کند در زمان باز کردن پروژه با سرعت بیشتری ماژول ها را index کرده و کدها را سریعتر اسکن کند "},{"id":48,"href":"/chapter-4/command-line-go/","title":"4.6 آموزش نوشتن برنامه command line","section":"فصل چهارم: مباحث پیشرفته","content":" 4.6.1 مقدمه # هنگامی که می‌خواهید نرم‌افزاری بنویسید، ممکن است بخواهید از محیط Command Line یا خط فرمان استفاده کنید. خط فرمان، رابط کاربری ساده‌تری نسبت به محیط گرافیکی دارد و در برخی موارد، سرعت بخش بسیار قابل توجهی است. برای آموزش نوشتن برنامه در خط فرمان، شما به یک زبان برنامه‌نویسی نیاز دارید که از بسیاری از کانسپت‌هایی که در برنامه‌نویسی استفاده می‌شوند، پشتیبانی کند. ما به شما پیشنهاد می‌دهیم که از زبان برنامه‌نویسی Go استفاده کنید زیرا برای کار با Command Line بسیار مناسب است.\nآموزش نوشتن برنامه Command Line به کمک زبان برنامه‌نویسی گو:\nدر اینجا، ما یک مثال ساده از برنامه Hello World با استفاده از Go و Command Line ارائه می‌دهیم. این برنامه، یک پیام ساده را به صفحه نمایش خط فرمان چاپ می‌کند.\nاولین چیزی که شما باید در نظر داشته باشید این است که برنامه‌ی شما باید یک فایل با پسوند .go باشد. برای مثال، می‌توانید یک فایل با نام helloworld.go ایجاد کنید.\nبعد از ایجاد فایل، شما باید کد زیر را به فایل خود اضافه کنید:\npackage main import \"fmt\" func main() { fmt.Println(\"Hello, World!\") } ▶ اجرای کد کپی ✖ بستن خروجی اگر کد بالا را به فایل helloworld.go اضافه کردید، می‌توانید با استفاده از Command Line، فایل را اجرا کنید. برای اجرای فایل، ابتدا باید به دایرکتوری فایل برید. سپس می‌توانید دستور برای اجرای فایل را وارد کنید.\nبرای مثال، فرض کنید فایل helloworld.go در دایرکتوری Documents قرار دارد. به عنوان نوشته، این دستورات را در Command Line وارد کنید:\n$ cd Documents $ go run helloworld.go\nبا اجرای دستور بالا، برنامه شما اجرا خواهد شد و پیام \u0026ldquo;Hello, World!\u0026rdquo; را در Command Line چاپ می‌کند.\nنتیجه‌گیری:\nاستفاده از خط فرمان برای نوشتن برنامه‌های شما می‌تواند بسیار مفید باشد، اگر یادگیری زبان برنامه‌نویسی Go و چگونگی کار با Command Line را یاد بگیرید. در این مقاله، به شما یک مثال ساده از نوشتن برنامه Command Line با استفاده از Go برای شروع ارائه شد. با ادامه‌ی یادگیری زبان برنامه نویسی Go، شما می‌توانید برنامه‌های پیچیده‌تر را با استفاده از Command Line بسازید.\n4.6.2 نحوه گرفتن arguments به عنوان ورودی از ترمینال # برای گرفتن ورودی از Command Line به عنوان Argument در یک برنامه Go، شما می‌توانید از پایگاه‌داده os در Go استفاده کنید. برای دسترسی به Argumentها، شما می‌توانید متغیرهای os.Args را استفاده کنید. آرایه‌ی os.Args شامل تمامی Argumentهایی است که در Command Line به برنامه شما داده شده است. در زیر، یک مثال ساده از گرفتن دو Argument از Command Line در یک برنامه Go آورده شده است:\npackage main import ( \"fmt\" \"os\" ) func main() { args := os.Args fmt.Println(\"First Argument:\", args[1]) fmt.Println(\"Second Argument:\", args[2]) } ▶ اجرای کد کپی ✖ بستن خروجی در کد بالا، ابتدا، ما متغیر os.Args را به متغیر args اختصاص داده‌ایم. سپس، با استفاده از این متغیر، ما مقادیر دو Argument اول را چاپ کرده‌ایم. در اینجا، args[0] نام برنامه Go در Command Line است، بنابراین اولین Argument بعد از آن در args[1] و دومین Argument در args[2] قرار دارد. با تغییر این شماره‌ها، شما می‌توانید به Argument‌های دیگر در Command Line دسترسی داشته باشید.\n4.6.3 کار با flag در زبان گو # در زبان Go، شما می‌توانید از پکیج flag برای ایجاد و مدیریت Flagها در Command Line استفاده کنید. با استفاده از قابلیت Flag، شما می‌توانید به آرگومان های اختیاری و پارامترهای Command Line برنامه خود دسترسی پیدا کنید.\nدر پکیج flag، سه نوع Flag مختلف وجود دارند: string، bool و int. برای ایجاد یک Flag از هر نوع، می‌توانید از توابع flag.String، flag.Bool و flag.Int استفاده کنید.\nدر مثال زیر، ما به کمک Flag یک رشته، یک boolean و یک integer را تعریف و مقداردهی اولیه آن‌ها را انجام می‌دهیم:\npackage main import ( \"flag\" \"fmt\" ) func main() { // تعریف یک Flag رشته برای نام کاربری userName := flag.String(\"username\", \"\", \"نام کاربری\") // تعریف یک Flag boolean برای پرینت نتیجه printResult := flag.Bool(\"print\", false, \"پرینت نتیجه؟\") // تعریف یک Flag integer برای تعداد تکرار repeatCount := flag.Int(\"count\", 1, \"تعداد تکرار\") flag.Parse() // استفاده از Flag ها fmt.Println(\"نام کاربری:\", *userName) fmt.Println(\"پرینت نتیجه؟\", *printResult) fmt.Println(\"تعداد تکرار:\", *repeatCount) } ▶ اجرای کد کپی ✖ بستن خروجی در مثال بالا، ما سه Flag ایجاد کرده‌ایم: username، print و count که به ترتیب متناظر با یک رشته، یک boolean و یک integer هستند. پارامتر اول تابع هر Flag نام آن است، پارامتر دوم مقدار پیش‌فرض و پارامتر سوم توضیحاتی در مورد Flag است.\nدر انتهای برنامه، با استفاده از تابع flag.Parse()، مقدار داده‌شده به Flagها از Command Line دریافت و مقداردهی به متغیرهای var استفاده شده در Flagها انجام می‌گیرد. در مثال بالا، ما با استفاده از اپراتور * به مقدار داده‌شده به هر Flag دریافت شده از Command Line دسترسی پیدا می‌کنیم.\nبا اجرای برنامه و وارد کردن یک Command Line مخصوص مثل زیر، می‌توانید مقدارهای مختلفی به Flagهای برنامه خود اختصاص دهید.\nدر این مثال، مقدار Flag username برابر با \u0026ldquo;John\u0026rdquo;، print برابر با true و count برابر با ۵ می‌باشد.\n"},{"id":49,"href":"/chapter-4/work-with-file-in-go/","title":"4.7 آموزش کار با فایل","section":"فصل چهارم: مباحث پیشرفته","content":" 4.7.1 مقدمه # توسعه دهندگان Go می‌توانند از پکیج‌های built-in مانند \u0026ldquo;os\u0026rdquo; و \u0026ldquo;io\u0026rdquo; برای کار با فایل‌ها استفاده کنند. همچنین، پکیج‌های دیگری نیز برای کار با فایل وجود دارند که می‌توان به عنوان پکیج استاندارد نامید. نمونه ای از این پکیج‌ها، پکیج \u0026ldquo;bufio\u0026rdquo; است که برای کار با بافرهای ورودی/خروجی استفاده شده و به توسعه دهندگان اجازه می‌دهد تا برنامه‌هایی با عملکرد بهتر و با کارایی بالاتر ایجاد کنند.\n4.7.2 باز کردن فایل و خواندن محتوای فایل با پکیج os # برای باز کردن یک فایل متنی و خواندن محتوای آن، می‌توانیم از پکیج \u0026ldquo;os\u0026rdquo; و متد \u0026ldquo;Open\u0026rdquo; استفاده کنیم. در کد زیر، ما یک فایل به نام \u0026ldquo;example.txt\u0026rdquo; باز می‌کنیم و محتوای آن را به صورت خط به خط خوانده و به صفحه کنسول چاپ می‌کنیم:\npackage main import ( \"bufio\" \"fmt\" \"log\" \"os\" ) func main() { // باز کردن فایل برای خواندن file, err := os.Open(\"example.txt\") if err != nil { log.Fatal(err) } defer file.Close() // خواندن خط به خط از فایل scanner := bufio.NewScanner(file) for scanner.Scan() { fmt.Println(scanner.Text()) } if err := scanner.Err(); err != nil { log.Fatal(err) } } ▶ اجرای کد کپی ✖ بستن خروجی در کد بالا، با استفاده از متد \u0026ldquo;os.Open\u0026rdquo;، فایل \u0026ldquo;example.txt\u0026rdquo; برای خواندن به صورت فایل شیء باز می‌شود. سپس، با استفاده از متد \u0026ldquo;bufio.NewScanner\u0026rdquo; محتوای فایل به شیء \u0026ldquo;scanner\u0026rdquo; انتقال داده می‌شود و در نهایت با استفاده از حلقه، محتوای فایل خوانده شده خط به خط و به صورت متنی چاپ می‌شود.\nدر نهایت، با استفاده از \u0026ldquo;scanner.Err\u0026rdquo;، خطاهایی که در پروسه خواندن ممکن است بوجود آیند، بررسی شده و مورد احتیاط قرار می‌گیرند.\n4.7.3 نحوه ایجاد فایل و نوشتن محتوا داخل فایل با os # برای ایجاد یک فایل جدید و نوشتن محتوای دلخواه در آن، می‌توانیم از پکیج \u0026ldquo;os\u0026rdquo; و متدهای آن استفاده کنیم. در کد زیر، یک فایل با نام \u0026ldquo;example.txt\u0026rdquo; ساخته شده و پس از باز شدن، متن \u0026ldquo;Hello, World!\u0026rdquo; در داخل آن نوشته می‌شود:\npackage main import ( \"fmt\" \"os\" ) func main() { // ساخت فایل با نام example.txt file, err := os.Create(\"example.txt\") if err != nil { fmt.Println(err) return } defer file.Close() // نوشتن محتوا در فایل fmt.Fprintln(file, \"Hello, World!\") } ▶ اجرای کد کپی ✖ بستن خروجی در کد بالا، با استفاده از متد \u0026ldquo;os.Create\u0026rdquo;، یک فایل با نام \u0026ldquo;example.txt\u0026rdquo; ایجاد شده و به عنوان یک فایل شیء باز شده است. سپس با استفاده از متد \u0026ldquo;fmt.Fprintln\u0026rdquo;، متن \u0026ldquo;Hello, World!\u0026rdquo; در داخل فایل نوشته می‌شود.\nدر نهایت، با استفاده از \u0026ldquo;file.Close\u0026rdquo;، فایل بسته شده و تمام تغییرات آن ذخیره می‌شود.\n4.7.4 خواندن و نوشتن فایل با استفاده از پکیج io # برای خواندن و نوشتن فایل‌ها می‌توان از پکیج \u0026ldquo;io\u0026rdquo; استفاده کرد. این پکیج امکانات بسیاری را برای کار با بیت‌ها و داده‌های ورودی/خروجی فراهم می‌کند. در کد زیر، یک فایل با نام \u0026ldquo;example.txt\u0026rdquo; باز شده و محتوای آن خوانده شده و به فایل دیگری با نام \u0026ldquo;output.txt\u0026rdquo; کپی می‌شود:\npackage main import ( \"io\" \"log\" \"os\" ) func main() { // باز کردن فایل برای خواندن inputFile, err := os.Open(\"example.txt\") if err != nil { log.Fatal(err) } defer inputFile.Close() // باز کردن فایل برای نوشتن outputFile, err := os.Create(\"output.txt\") if err != nil { log.Fatal(err) } defer outputFile.Close() // کپی کردن اطلاعات از فایل ورودی به فایل خروجی _, err = io.Copy(outputFile, inputFile) if err != nil { log.Fatal(err) } } ▶ اجرای کد کپی ✖ بستن خروجی در کد بالا، با استفاده از متدهای \u0026ldquo;os.Open\u0026rdquo; و \u0026ldquo;os.Create\u0026rdquo;، فایل‌های ورودی و خروجی باز شده و به عنوان فایل شیء به برنامه اضافه شده‌اند. سپس با استفاده از متد \u0026ldquo;io.Copy\u0026rdquo;، اطلاعات از فایل ورودی، به فایل خروجی کپی شده‌اند.\nدر نهایت، با استفاده از \u0026ldquo;defer\u0026rdquo; و \u0026ldquo;Close\u0026rdquo;، فایل‌ها بسته شده‌اند و تغییرات آن‌ها ذخیره شده‌اند.\n"},{"id":50,"href":"/chapter-4/work-with-json-file-in-go/","title":"4.8 آموزش کار با json","section":"فصل چهارم: مباحث پیشرفته","content":" 4.8.1 مقدمه # JSON یک فرمت متنی است که برای مبادله و ذخیره داده‌ها استفاده می‌شود. نام JSON مخفف عبارت JavaScript Object Notation است و در ابتدا به عنوان یک زبان مبتنی بر جاوااسکریپت توسعه یافته است. با این حال، در حال حاضر JSON به راحتی با بیشتر زبان‌های برنامه‌نویسی سازگار است.\nJSON یک مجموعه از جفت‌های «key: value» است که با کاما از یکدیگر جدا شده‌اند و بین آنها با «:» ارتباط دارند. JSON در بین برنامه‌نویسان به عنوان یک ساختار داده‌ای محبوب است و به راحتی داده‌ها را به صورت ساختاردهی شده در برنامه‌های کاربردی مختلف به کار می‌رود. این فرمت دیتا استاندارد و مستقل از زبان‌ها و پلتفرم‌های برنامه‌نویسی است و برای برنامه‌های تحت وب، موبایل، دسکتاپ و سرور قابل استفاده است.\nساختار یک فایل JSON شامل تعدادی از آبجکت‌ها و آرایه‌ها می‌باشد. به عبارتی داده‌های JSON می‌توانند در سه نوع اصلی “جسم آرکی”(object) ، “کالکشن آرای”(array) و “مقادیر اولیه”(values) تعریف شوند. آبجکت یک گروه از خصوصیات است که دارای یک کلید منحصر به فرد به عنوان “عنوان شی” می‌باشد. همچنین، آرایه نیز به مشابه یک لیست یا آرایه از خصوصیات است.\nیک مثال ساده JSON:\n{ \u0026quot;name\u0026quot;: \u0026quot;John Doe\u0026quot;, \u0026quot;age\u0026quot;: 30, \u0026quot;email\u0026quot;: \u0026quot;johndoe@example.com\u0026quot;, \u0026quot;address\u0026quot;: { \u0026quot;street\u0026quot;: \u0026quot;123 Main St\u0026quot;, \u0026quot;city\u0026quot;: \u0026quot;Anytown\u0026quot;, \u0026quot;state\u0026quot;: \u0026quot;CA\u0026quot;, \u0026quot;zip\u0026quot;: \u0026quot;12345\u0026quot; }, \u0026quot;phone\u0026quot;: [ { \u0026quot;type\u0026quot;: \u0026quot;home\u0026quot;, \u0026quot;number\u0026quot;: \u0026quot;555-555-1234\u0026quot; }, { \u0026quot;type\u0026quot;: \u0026quot;work\u0026quot;, \u0026quot;number\u0026quot;: \u0026quot;555-555-5678\u0026quot; } ] } در این مثال، یک شیء با عنوان \u0026ldquo;John Doe\u0026rdquo; تعریف شده است. این شیء دارای خصوصیاتی همچون نام، سن، ایمیل، آدرس و تلفن است. آدرس نیز یک شیء است که شامل خصوصیاتی همچون خیابان، شهر، ایالت و کد پستی است. همچنین، تلفن به عنوان یک آرایه از شیء‌ها تعریف شده است که شامل نوع تلفن و شماره تلفن است.\n4.8.2 کار با marshal و unmarshal پکیج json # در زبان برنامه‌نویسی Go، پکیج \u0026ldquo;encoding/json\u0026rdquo; برای کار با داده‌های JSON بسیار مفید است. این پکیج امکاناتی برای تبدیل داده‌های Go به فرمت JSON (marshal) و برعکس (unmarshal) در اختیار برنامه‌نویسان قرار می‌دهد.\n4.8.2.1 کار با marshal # با استفاده از تابع \u0026ldquo;Marshal\u0026rdquo;، برای مثال، می‌توان یک شیء با فرمت JSON تولید کرد. در کد زیر، یک شیء از نوع \u0026ldquo;person\u0026rdquo; تعریف شده است و با استفاده از تابع \u0026ldquo;Marshal\u0026rdquo; به فرمت JSON تبدیل شده است:\npackage main import ( \"encoding/json\" \"fmt\" ) type person struct { Name string `json:\"name\"` Age int `json:\"age\"` Email string `json:\"email\"` } func main() { p := \u0026person{Name: \"John Doe\", Age: 30, Email: \"john.doe@example.com\"} b, err := json.Marshal(p) if err != nil { fmt.Println(\"error:\", err) } fmt.Println(string(b)) } ▶ اجرای کد کپی ✖ بستن خروجی در کد بالا، ابتدا یک شیء از نوع \u0026ldquo;person\u0026rdquo; با مقادیر مشخص تعریف شده است. سپس از تابع \u0026ldquo;Marshal\u0026rdquo; برای تبدیل این شیء به فرمت JSON استفاده شده است. خروجی تابع \u0026ldquo;Marshal\u0026rdquo; یک بایت‌آرایه است که به عنوان یک رشته و با استفاده از تبدیل به \u0026ldquo;string\u0026rdquo; چاپ شده است.\n4.8.2.2 کار با unmarshal # با استفاده از تابع \u0026ldquo;Unmarshal\u0026rdquo; نیز می‌توان یک رشته JSON را به شیء Go تبدیل کرد. در کد زیر، یک رشته JSON با نام \u0026ldquo;data\u0026rdquo; تعریف شده است و با استفاده از تابع \u0026ldquo;Unmarshal\u0026rdquo; به یک شیء از نوع \u0026ldquo;person\u0026rdquo; تبدیل شده است:\npackage main import ( \"encoding/json\" \"fmt\" ) type person struct { Name string `json:\"name\"` Age int `json:\"age\"` Email string `json:\"email\"` } func main() { data := `{\"name\":\"John Doe\",\"age\":30,\"email\":\"john.doe@example.com\"}` var p person err := json.Unmarshal([]byte(data), \u0026p) if err != nil { fmt.Println(\"error:\", err) } fmt.Println(p.Name, p.Age, p.Email) } ▶ اجرای کد کپی ✖ بستن خروجی در کد بالا، ابتدا یک رشته JSON با نام \u0026ldquo;data\u0026rdquo; تعریف شده است. سپس یک شیء از نوع \u0026ldquo;person\u0026rdquo; با استفاده از تابع \u0026ldquo;Unmarshal\u0026rdquo; و با این رشته JSON به شکل مقداردهی شده است. خروجی تابع \u0026ldquo;Unmarshal\u0026rdquo;، شیء \u0026ldquo;person\u0026rdquo; است که بعداً در کد چاپ شده است. توجه داشته باشید که در اینجا از \u0026ldquo;[]byte\u0026rdquo; برای تبدیل رشته به بایت‌آرایه استفاده شده است.\n4.8.3 تبدیل آرایه و slice به json # در Go، می‌توان آرایه‌ها و slice‌ها را به فرمت JSON تبدیل کرد. برای این کار، از تابع \u0026ldquo;Marshal\u0026rdquo; پکیج \u0026ldquo;encoding/json\u0026rdquo; استفاده می‌شود.\nبرای مثال، فرض کنید یک slice‌ از اعداد صحیح داشته باشیم. برای تبدیل این slice به فرمت JSON، کد زیر نمونه‌ای از چگونگی استفاده از تابع \u0026ldquo;Marshal\u0026rdquo; را نشان می‌دهد:\npackage main import ( \"encoding/json\" \"fmt\" ) func main() { numbers := []int{1, 2, 3, 4, 5} data, err := json.Marshal(numbers) if err != nil { fmt.Println(\"error:\", err) } fmt.Println(string(data)) } ▶ اجرای کد کپی ✖ بستن خروجی در این کد، ابتدا یک slice‌ از اعداد صحیح تعریف شده است. سپس با استفاده از تابع \u0026ldquo;Marshal\u0026rdquo; این slice‌ به فرمت JSON تبدیل شده و در متغیر \u0026ldquo;data\u0026rdquo; ذخیره شده است. در نهایت، با استفاده از تبدیل به \u0026ldquo;string\u0026rdquo;، خروجی تابع \u0026ldquo;Marshal\u0026rdquo; به صورت یک رشته چاپ شده است.\nهمچنین، می‌توان آرایه‌های چند بعدی را نیز به فرمت JSON تبدیل کرد. در کد زیر، یک آرایه دوبعدی از اعداد صحیح تعریف شده است و به فرمت JSON تبدیل می‌شود:\npackage main import ( \"encoding/json\" \"fmt\" ) func main() { var matrix [2][3]int = [2][3]int{{1, 2, 3}, {4, 5, 6}} data, err := json.Marshal(matrix) if err != nil { fmt.Println(\"error:\", err) } fmt.Println(string(data)) } ▶ اجرای کد کپی ✖ بستن خروجی در این کد نیز، بعد از تعریف یک آرایه دوبعدی از اعداد صحیح، با استفاده از تابع \u0026ldquo;Marshal\u0026rdquo; آن را به فرمت JSON تبدیل شده و در متغیر \u0026ldquo;data\u0026rdquo; ذخیره شده است. خروجی تابع \u0026ldquo;Marshal\u0026rdquo; نیز به صورت یک رشته چاپ می‌شود.\n4.8.4 تبدیل map به json # در Go، می‌توان map را به فرمت JSON تبدیل کرد با استفاده از تابع \u0026ldquo;Marshal\u0026rdquo; در پکیج \u0026ldquo;encoding/json\u0026rdquo; میتوان این کار را انجام داد.\nبرای مثال، فرض کنید یک map از داده‌های شخصی داشته باشیم که شامل نام، سن و ایمیل است. برای تبدیل این map به فرمت JSON، کد زیر نمونه‌ای از چگونگی استفاده از تابع \u0026ldquo;Marshal\u0026rdquo; را نشان می‌دهد:\npackage main import ( \"encoding/json\" \"fmt\" ) func main() { data := map[string]interface{}{ \"name\": \"John Doe\", \"age\": 30, \"email\": \"john.doe@example.com\", } output, err := json.Marshal(data) if err != nil { fmt.Println(\"error:\", err) } fmt.Println(string(output)) } ▶ اجرای کد کپی ✖ بستن خروجی در کد بالا، یک map از داده‌های شخصی با نام \u0026ldquo;data\u0026rdquo; تعریف شده است و سپس با استفاده از تابع \u0026ldquo;Marshal\u0026rdquo; به فرمت JSON تبدیل شده است. خروجی تابع \u0026ldquo;Marshal\u0026rdquo; نیز به صورت یک رشته چاپ شده است.\nتوجه داشته باشید که در این نمونه، نوع داده‌ی مقدارهای مپ از نوع خاصی استفاده نشده است و به جای آن، از نوع \u0026ldquo;interface{}\u0026rdquo; برای مقادیر استفاده شده است. این به این دلیل است که ممکن است مقادیر مختلفی در map وجود داشته باشد ولی نوعشان کاملاً شناخته شده نباشد. با استفاده از \u0026ldquo;interface{}\u0026quot;، مقادیر به صورت پویا تعریف شده و برنامه قادر است به درستی تبدیل را انجام دهد.\n4.8.5 کتابخانه GJSON # استفاده از فرمت json در زبان برنامه نویسی گو به راحتی استفاده از این فرمت در سایر زبان های برنامه نویسی دیگر مثل پایتون نیست و برای اینکه این مورد ساده‌تر شود توصیه میشود از کتابخانه GJSON استفاده شود.\nکتابخانه GJSON یک بسته Go است که راهی سریع و ساده برای دریافت مقادیر از یک سند json ارائه می دهد. دارای ویژگی هاییone line retrieval, dot notation paths, iteration,، و parsing json lines است.\nاین توضیحات یک نمای کلی از نحوه استفاده از GJSON است، برای اطلاعات بیشتر،GJSON Syntax را بررسی کنید.\n4.8.5.1 راه اندازی و نصب GJSON # برای نصب می توانیم از کد زیر استفاده کنیم.\ngo get -u github.com/tidwall/gjson با این کار کتابخانه نصب می شود.\n4.8.5.2 خواندن مقادیر با GJSON # برای جستجوی مقدار مورد نظر json را برای آدرس یا فایل مشخص شده دریافت کنید. کافیست کلید های تو در تو را تنها توسط یک نقطه، مانند \u0026rsquo;name.last\u0026rsquo; یا \u0026lsquo;age\u0026rsquo; فراخوانی کرده و مقدار درون آن را بدست آورید. به عنوان مثال در کد زیر:\npackage main import \"github.com/tidwall/gjson\" const json = `{\"name\":{\"first\":\"Janet\",\"last\":\"Prichard\"},\"age\":47}` func main() { value := gjson.Get(json, \"name.last\") println(value.String()) } ▶ اجرای کد کپی ✖ بستن خروجی خروجی به صورت زیر خواهد بود:\nPrichard همچنین تابع GetMany برای دریافت چندین مقدار در یک زمان و GetBytes برای کار با slices بایت JSON وجود دارد.\n4.8.5.3 Path Syntax # در زیر یک نمای کلی از path syntax ارائه شده است، برای اطلاعات کامل تر لطفاً GJSON Syntax را بررسی کنید.\nیک path مجموعه ای از کلیدها است که با یک نقطه از هم جدا شده اند. یک کلید ممکن است حاوی کاراکترهای ویژه \u0026lsquo;*\u0026rsquo; و \u0026lsquo;؟\u0026rsquo; باشد. برای دسترسی به مقدار آرایه از شاخص به عنوان کلید استفاده کنید. برای به دست آوردن تعداد عناصر در یک آرایه یا دسترسی به یک path فرزند، از کاراکتر \u0026lsquo;#\u0026rsquo; استفاده کنید. کاراکترهای dot و wildcard را می توان با \u0026rsquo;\u0026rsquo; escape کرد.\n‍‍\n{ \u0026quot;name\u0026quot;: {\u0026quot;first\u0026quot;: \u0026quot;Tom\u0026quot;, \u0026quot;last\u0026quot;: \u0026quot;Anderson\u0026quot;}, \u0026quot;age\u0026quot;:37, \u0026quot;children\u0026quot;: [\u0026quot;Sara\u0026quot;,\u0026quot;Alex\u0026quot;,\u0026quot;Jack\u0026quot;], \u0026quot;fav.movie\u0026quot;: \u0026quot;Deer Hunter\u0026quot;, \u0026quot;friends\u0026quot;: [ {\u0026quot;first\u0026quot;: \u0026quot;Dale\u0026quot;, \u0026quot;last\u0026quot;: \u0026quot;Murphy\u0026quot;, \u0026quot;age\u0026quot;: 44, \u0026quot;nets\u0026quot;: [\u0026quot;ig\u0026quot;, \u0026quot;fb\u0026quot;, \u0026quot;tw\u0026quot;]}, {\u0026quot;first\u0026quot;: \u0026quot;Roger\u0026quot;, \u0026quot;last\u0026quot;: \u0026quot;Craig\u0026quot;, \u0026quot;age\u0026quot;: 68, \u0026quot;nets\u0026quot;: [\u0026quot;fb\u0026quot;, \u0026quot;tw\u0026quot;]}, {\u0026quot;first\u0026quot;: \u0026quot;Jane\u0026quot;, \u0026quot;last\u0026quot;: \u0026quot;Murphy\u0026quot;, \u0026quot;age\u0026quot;: 47, \u0026quot;nets\u0026quot;: [\u0026quot;ig\u0026quot;, \u0026quot;tw\u0026quot;]} ] } \u0026quot;name.last\u0026quot; \u0026gt;\u0026gt; \u0026quot;Anderson\u0026quot; \u0026quot;age\u0026quot; \u0026gt;\u0026gt; 37 \u0026quot;children\u0026quot; \u0026gt;\u0026gt; [\u0026quot;Sara\u0026quot;,\u0026quot;Alex\u0026quot;,\u0026quot;Jack\u0026quot;] \u0026quot;children.#\u0026quot; \u0026gt;\u0026gt; 3 \u0026quot;children.1\u0026quot; \u0026gt;\u0026gt; \u0026quot;Alex\u0026quot; \u0026quot;child*.2\u0026quot; \u0026gt;\u0026gt; \u0026quot;Jack\u0026quot; \u0026quot;c?ildren.0\u0026quot; \u0026gt;\u0026gt; \u0026quot;Sara\u0026quot; \u0026quot;fav\\.movie\u0026quot; \u0026gt;\u0026gt; \u0026quot;Deer Hunter\u0026quot; \u0026quot;friends.#.first\u0026quot; \u0026gt;\u0026gt; [\u0026quot;Dale\u0026quot;,\u0026quot;Roger\u0026quot;,\u0026quot;Jane\u0026quot;] \u0026quot;friends.1.last\u0026quot; \u0026gt;\u0026gt; \u0026quot;Craig\u0026quot; همچنین می‌توانید با استفاده از #(...), آرایه‌ای را برای پیدا کردن اولین match یا تطابق مورد نظر بررسی کنید، یا همه موارد مورد نظر را با #(...)# را پیدا کنید. کوئری ها از عملگرهای مقایسه ==, !=, \u0026lt;, \u0026lt;=, \u0026gt;, \u0026gt;= و الگوی ساده تطبیق عملگرهای % (like) و !% (not like) پشتیبانی می کنند.\n‍‍‍‍‍\nfriends.#(last==\u0026quot;Murphy\u0026quot;).first \u0026gt;\u0026gt; \u0026quot;Dale\u0026quot; friends.#(last==\u0026quot;Murphy\u0026quot;)#.first \u0026gt;\u0026gt; [\u0026quot;Dale\u0026quot;,\u0026quot;Jane\u0026quot;] friends.#(age\u0026gt;45)#.last \u0026gt;\u0026gt; [\u0026quot;Craig\u0026quot;,\u0026quot;Murphy\u0026quot;] friends.#(first%\u0026quot;D*\u0026quot;).last \u0026gt;\u0026gt; \u0026quot;Murphy\u0026quot; friends.#(first!%\u0026quot;D*\u0026quot;).last \u0026gt;\u0026gt; \u0026quot;Craig\u0026quot; friends.#(nets.#(==\u0026quot;fb\u0026quot;))#.first \u0026gt;\u0026gt; [\u0026quot;Dale\u0026quot;,\u0026quot;Roger\u0026quot;] لطفاً توجه داشته باشید که قبل از نسخه 1.3.0، کوئری ها از براکت های #[\u0026hellip;] استفاده می کردند. این در نسخه 1.3.0 تغییر کرد تا از سردرگمی با سینتکس چند مسیری جدید جلوگیری شود. برای backwards compatibility ، #[\u0026hellip;] تا نسخه اصلی بعدی به کار خود ادامه خواهد داد.\n4.8.5.4 Result Type # کتابخانه GJSON از انواع json string، number، bool و null پشتیبانی می کند. آرایه ها و اشیاء به عنوان نوع خام json خود برگردانده می شوند.\nنوع Result یکی از این موارد را دارد:\n‍‍‍\nbool, for JSON booleans float64, for JSON numbers string, for JSON string literals nil, for JSON null برای دسترسی مستقیم به مقدار مورد نظر:\nresult.Type // can be String, Number, True, False, Null, or JSON result.Str // holds the string result.Num // holds the float64 number result.Raw // holds the raw json result.Index // index of raw value in original json, zero means index unknown result.Indexes // indexes of all the elements that match on a path containing the '#' query character. انواع مختلفی از توابع مفید وجود دارد که بر روی یک نتیجه کار می کنند:\nresult.Exists() bool result.Value() interface{} result.Int() int64 result.Uint() uint64 result.Float() float64 result.String() string result.Bool() bool result.Time() time.Time result.Array() []gjson.Result result.Map() map[string]gjson.Result result.Get(path string) Result result.ForEach(iterator func(key, value Result) bool) result.Less(token Result, caseSensitive bool) bool تابع result.Value() یک interface{} را برمی‌گرداند که به type assertion نیاز دارد و که یکی از type های Go به صورت زیر است:\nboolean \u0026gt;\u0026gt; bool number \u0026gt;\u0026gt; float64 string \u0026gt;\u0026gt; string null \u0026gt;\u0026gt; nil array \u0026gt;\u0026gt; []interface{} object \u0026gt;\u0026gt; map[string]interface{} تابع result.Array() آرایه ای از مقادیر را برمی گرداند. اگر نتیجه یک مقدار غیر موجود را نشان دهد، یک آرایه خالی برگردانده می شود. اگر نتیجه یک آرایه JSON نباشد، مقدار بازگشتی یک آرایه حاوی یک نتیجه خواهد بود.\n64-bit integers # فراخوانی های result.Int() و result.Uint() قادر به خواندن تمام 64 بیت هستند و امکان کار با اعداد صحیح JSON را فراهم می کنند.\nresult.Int() int64 // -9223372036854775808 to 9223372036854775807 result.Uint() uint64 // 0 to 18446744073709551615 4.8.5.5 Modifiers and path chaining # اصلاح کننده یک جزء مسیر است که پردازش custom شده‌ای را روی json انجام می دهد.\nچندین مسیر را می توان با استفاده از pipe character به هم «chained» کرد. این برای دریافت نتایج از یک query اصلاح شده مفید است.\nبه عنوان مثال، با استفاده از اصلاح‌کننده @reverse داخلی در سند json بالا، آرایه فرزندان را دریافت می‌کنیم و ترتیب را برعکس می‌کنیم:\n‍\n\u0026quot;children|@reverse\u0026quot; \u0026gt;\u0026gt; [\u0026quot;Jack\u0026quot;,\u0026quot;Alex\u0026quot;,\u0026quot;Sara\u0026quot;] \u0026quot;children|@reverse|0\u0026quot; \u0026gt;\u0026gt; \u0026quot;Jack\u0026quot; در حال حاضر اصلاح کننده های داخلی زیر وجود دارد:\n@reverse: یک آرایه یا اعضای یک شی را معکوس کنید. @ugly: تمام فضای خالی را از یک سند json حذف کنید. @pretty: سند json را برای انسان قابل خواندن تر کنید. @this: عنصر فعلی را برمی‌گرداند. می توان از آن برای بازیابی عنصر ریشه استفاده کرد. @valid: مطمئن شوید که سند json معتبر است. @flatten: یک آرایه را صاف می کند. @join: چندین شی را به یک شیء متصل می کند. @keys: آرایه ای از کلیدها را برای یک شی برمی گرداند. @values: آرایه ای از مقادیر را برای یک شی برمی گرداند. @tostr: json را به یک رشته تبدیل می کند. یک رشته json را می پیچد. @fromstr: یک رشته را از json تبدیل می کند. یک رشته json را باز می کند. @group: آرایه های اشیاء را گروه بندی می کند. e4fc67c. را ببینید. Modifier arguments\nیک اصلاح کننده ممکن است یک آرگومان اختیاری را بپذیرد. آرگومان می تواند یک سند JSON معتبر یا فقط کاراکتر باشد.\nبه عنوان مثال، اصلاح کننده @pretty یک شی json را به عنوان آرگومان خود می گیرد.\n@pretty:{\u0026quot;sortKeys\u0026quot;:true} که json را زیبا می کند و تمام کلیدهای آن را سفارش می دهد.\n{ \u0026quot;age\u0026quot;:37, \u0026quot;children\u0026quot;: [\u0026quot;Sara\u0026quot;,\u0026quot;Alex\u0026quot;,\u0026quot;Jack\u0026quot;], \u0026quot;fav.movie\u0026quot;: \u0026quot;Deer Hunter\u0026quot;, \u0026quot;friends\u0026quot;: [ {\u0026quot;age\u0026quot;: 44, \u0026quot;first\u0026quot;: \u0026quot;Dale\u0026quot;, \u0026quot;last\u0026quot;: \u0026quot;Murphy\u0026quot;}, {\u0026quot;age\u0026quot;: 68, \u0026quot;first\u0026quot;: \u0026quot;Roger\u0026quot;, \u0026quot;last\u0026quot;: \u0026quot;Craig\u0026quot;}, {\u0026quot;age\u0026quot;: 47, \u0026quot;first\u0026quot;: \u0026quot;Jane\u0026quot;, \u0026quot;last\u0026quot;: \u0026quot;Murphy\u0026quot;} ], \u0026quot;name\u0026quot;: {\u0026quot;first\u0026quot;: \u0026quot;Tom\u0026quot;, \u0026quot;last\u0026quot;: \u0026quot;Anderson\u0026quot;} } لیست کامل گزینه های @pretty عبارتند از sortKeys, indent, prefix, و width. لطفاً برای اطلاعات بیشتر به _Pretty Options_مراجعه کنید.\nCustom modifiers # همچنین می توانید اصلاح کننده های سفارشی اضافه کنید. به عنوان مثال، در اینجا ما یک اصلاح کننده ایجاد می کنیم که کل سند json را upper case یا lower case می کند.\ngjson.AddModifier(\u0026quot;case\u0026quot;, func(json, arg string) string { if arg == \u0026quot;upper\u0026quot; { return strings.ToUpper(json) } if arg == \u0026quot;lower\u0026quot; { return strings.ToLower(json) } return json }) \u0026quot;children|@case:upper\u0026quot; \u0026gt;\u0026gt; [\u0026quot;SARA\u0026quot;,\u0026quot;ALEX\u0026quot;,\u0026quot;JACK\u0026quot;] \u0026quot;children|@case:lower|@reverse\u0026quot; \u0026gt;\u0026gt; [\u0026quot;jack\u0026quot;,\u0026quot;alex\u0026quot;,\u0026quot;sara\u0026quot;] 4.8.5.6 JSON Lines # پشتیبانی از JSON Lines با استفاده از پیشوند .. وجود دارد که یک سند چند خطی را به عنوان یک آرایه در نظر می گیرد.\nبه عنوان مثال:\n{\u0026quot;name\u0026quot;: \u0026quot;Gilbert\u0026quot;, \u0026quot;age\u0026quot;: 61} {\u0026quot;name\u0026quot;: \u0026quot;Alexa\u0026quot;, \u0026quot;age\u0026quot;: 34} {\u0026quot;name\u0026quot;: \u0026quot;May\u0026quot;, \u0026quot;age\u0026quot;: 57} {\u0026quot;name\u0026quot;: \u0026quot;Deloise\u0026quot;, \u0026quot;age\u0026quot;: 44} تابع ForEachLines از طریق خطوط JSON تکرار می شود.\ngjson.ForEachLine(json, func(line gjson.Result) bool{ println(line.String()) return true }) 4.8.5.7 خواندن مقدارهای تو در تو یا nested # فرض کنید همه نام‌های خانوادگی را از json زیر می‌خواهید:\n‍‍\n{ \u0026quot;programmers\u0026quot;: [ { \u0026quot;firstName\u0026quot;: \u0026quot;Janet\u0026quot;, \u0026quot;lastName\u0026quot;: \u0026quot;McLaughlin\u0026quot;, }, { \u0026quot;firstName\u0026quot;: \u0026quot;Elliotte\u0026quot;, \u0026quot;lastName\u0026quot;: \u0026quot;Hunter\u0026quot;, }, { \u0026quot;firstName\u0026quot;: \u0026quot;Jason\u0026quot;, \u0026quot;lastName\u0026quot;: \u0026quot;Harold\u0026quot;, } ] } شما می توانید از مسیر \u0026lsquo;programmers.#.lastName\u0026rsquo; مانند این استفاده کنید:\n‍‍\nresult := gjson.Get(json, \u0026quot;programmers.#.lastName\u0026quot;) for _, name := range result.Array() { println(name.String()) } همچنین می توانید یک شی در داخل یک آرایه را پرس و جو کنید:\nname := gjson.Get(json, `programmers.#(lastName=\u0026quot;Hunter\u0026quot;).firstName`) println(name.String()) // prints \u0026quot;Elliotte\u0026quot; 4.8.5.8 پیمایش یک شی یا آرایه # تابع ForEach امکان تکرار سریع از طریق یک شی یا آرایه را فراهم می کند. کلید و مقدار برای اشیا به تابع تکرار کننده ارسال می شود. فقط مقدار برای آرایه ها ارسال می شود. برگرداندن false از یک تکرار کننده، تکرار را متوقف می کند.\nresult := gjson.Get(json, \u0026quot;programmers\u0026quot;) result.ForEach(func(key, value gjson.Result) bool { println(value.String()) return true // keep iterating }) 4.8.5.9 Simple Parse and Get # یک تابع Parse(json) وجود دارد که یک تجزیه ساده را انجام می دهد و result.Get(path) که یک نتیجه را جستجو می کند. به عنوان مثال، همه اینها نتیجه یکسانی را نشان می دهند:\ngjson.Parse(json).Get(\u0026quot;name\u0026quot;).Get(\u0026quot;last\u0026quot;) gjson.Get(json, \u0026quot;name\u0026quot;).Get(\u0026quot;last\u0026quot;) gjson.Get(json, \u0026quot;name.last\u0026quot;) 4.8.5.10 بررسی جهت وجود یک value خاص # گاهی اوقات فقط می خواهیم بدانیم که آیا یک مقدار وجود دارد یا خیر.\nvalue := gjson.Get(json, \u0026quot;name.last\u0026quot;) if !value.Exists() { println(\u0026quot;no last name\u0026quot;) } else { println(value.String()) } // Or as one step if gjson.Get(json, \u0026quot;name.last\u0026quot;).Exists() { println(\u0026quot;has a last name\u0026quot;) } 4.8.5.11 اعتبار سنجی JSON # توابع Get* و Parse* انتظار دارند که فایل حاوی json به سالم و استاندارد باشد. خطا در فایل json باعث حالت panic نمی‌شود، اما ممکن است نتایج غیرمنتظره را بازگرداند.\nاگر JSON را از یک منبع غیرقابل نامشخص استفاده کنید، ممکن است بخواهید قبل از استفاده از GJSON اعتبار سنجی کنید.\n‍\nif !gjson.Valid(json) { return errors.New(\u0026quot;invalid json\u0026quot;) } value := gjson.Get(json, \u0026quot;name.last\u0026quot;) 4.8.5.12 Unmarshal به یک map # برای unmarshal به مپ به صورت map[string]interface{}:\n‍‍\nm, ok := gjson.Parse(json).Value().(map[string]interface{}) if !ok { // not a map } 4.8.5.13 کار با byte ها # اگر درJSON فایل مورد نظر شما []byte slice وجود دارد، تابع GetBytes برای این حالت وجود دارد. این تابع در استفاده از Get(string(data), path) ترجیح داده می شود.\n‍‍\nvar json []byte = ... result := gjson.GetBytes(json, path) اگر از تابع gjson.GetBytes(json, path) استفاده می کنید و می خواهید از تبدیل result.Raw به []byte اجتناب کنید، می توانید از این الگو استفاده کنید:\nvar json []byte = ... result := gjson.GetBytes(json, path) var raw []byte if result.Index \u0026gt; 0 { raw = json[result.Index:result.Index+len(result.Raw)] } else { raw = []byte(result.Raw) } این روش از فیلد result.Index استفاده می‌کند که موقعیت داده‌های خام در json فایل است. ممکن است که مقدار result.Index برابر با صفر باشد، در این صورت result.Raw به یک []byte تبدیل می‌شود.\n4.8.5.14 خواندن چندین value # تابع GetMany می تواند برای دریافت چندین مقدار به طور همزمان استفاده شود.\n‍‍\nresults := gjson.GetMany(json, \u0026quot;name.first\u0026quot;, \u0026quot;name.last\u0026quot;, \u0026quot;age\u0026quot;) مقدار بازگشتی یک []Result است، که همیشه دارای دقیقاً همان تعداد آیتم‌هایی است که مسیرهای ورودی دارند.\n4.8.6 کتابخانه SJSON # در واقع SJSON یک کتابخانه‌ای است که یک راه بسیار سریع و ساده برای تنظیم یک value در یک سند json ارائه می دهد. در بخش قبلی فقط می‌توانستیم مقادیر موجود در یک سند json بازخوانی کنیم ولی به کمک sjson می توانیم مقادیر مورد نظر را در یک سند json وارد کرده یا به روزرسانی و حذف دهیم.\n4.8.6.1 راه اندازی و نصب SJSON # برای شروع استفاده از SJSON باید آن را نصب کنید و go get را اجرا کنید:\n$ go get -u github.com/tidwall/sjson با این کار کتابخانه نصب می شود.\n4.8.6.2 Set a value # دستور Set مقدار یا value ای را برای path مشخص شده اجرا می کند. یک path در یک dot syntax مشخص می‌شود، مانند \u0026rsquo;name.last\u0026rsquo; یا \u0026lsquo;age\u0026rsquo;. در این عملکرد انتظار می‌رود که ساختار کلی json صحیح و valid باشد. در صورت اشکال در ساختار json فایل و Invalid بودن آن، حالت panic رخ نمی‌دهد، اما ممکن است نتایج غیرمنتظره‌ای را برگرداند. البته pathهای نامعتبر ممکن است ایجاد خطا کند. به عنوان مثال کد زیر:\npackage main import \u0026quot;github.com/tidwall/sjson\u0026quot; const json = `{\u0026quot;name\u0026quot;:{\u0026quot;first\u0026quot;:\u0026quot;Janet\u0026quot;,\u0026quot;last\u0026quot;:\u0026quot;Prichard\u0026quot;},\u0026quot;age\u0026quot;:47}` func main() { value, _ := sjson.Set(json, \u0026quot;name.last\u0026quot;, \u0026quot;Anderson\u0026quot;) println(value) } خروجی به شکل زیر خواهد بود:\n{\u0026quot;name\u0026quot;:{\u0026quot;first\u0026quot;:\u0026quot;Janet\u0026quot;,\u0026quot;last\u0026quot;:\u0026quot;Anderson\u0026quot;},\u0026quot;age\u0026quot;:47} 4.8.6.3 Path syntax # در واقع path یا مسیر مجموعه ای از کلیدها است که با یک نقطه از هم جدا شده اند. کاراکترهای dot و colon را می توان با کاراکتر \\ به راحتی escape کرد.\n{ \u0026quot;name\u0026quot;: {\u0026quot;first\u0026quot;: \u0026quot;Tom\u0026quot;, \u0026quot;last\u0026quot;: \u0026quot;Anderson\u0026quot;}, \u0026quot;age\u0026quot;:37, \u0026quot;children\u0026quot;: [\u0026quot;Sara\u0026quot;,\u0026quot;Alex\u0026quot;,\u0026quot;Jack\u0026quot;], \u0026quot;fav.movie\u0026quot;: \u0026quot;Deer Hunter\u0026quot;, \u0026quot;friends\u0026quot;: [ {\u0026quot;first\u0026quot;: \u0026quot;James\u0026quot;, \u0026quot;last\u0026quot;: \u0026quot;Murphy\u0026quot;}, {\u0026quot;first\u0026quot;: \u0026quot;Roger\u0026quot;, \u0026quot;last\u0026quot;: \u0026quot;Craig\u0026quot;} ] } \u0026quot;name.last\u0026quot; \u0026gt;\u0026gt; \u0026quot;Anderson\u0026quot; \u0026quot;age\u0026quot; \u0026gt;\u0026gt; 37 \u0026quot;children.1\u0026quot; \u0026gt;\u0026gt; \u0026quot;Alex\u0026quot; \u0026quot;friends.1.last\u0026quot; \u0026gt;\u0026gt; \u0026quot;Craig\u0026quot; از کلید -1 می توان برای افزودن یک مقدار به آرایه موجود استفاده کرد:\n\u0026quot;children.-1\u0026quot; \u0026gt;\u0026gt; appends a new value to the end of the children array معمولاً از کلیدهای عددی برای اصلاح آرایه ها استفاده می شود، اما می توان با استفاده از کاراکتر دو نقطه، یک کلید شی عددی را اجرا کرد:\n{ \u0026quot;users\u0026quot;:{ \u0026quot;2313\u0026quot;:{\u0026quot;name\u0026quot;:\u0026quot;Sara\u0026quot;}, \u0026quot;7839\u0026quot;:{\u0026quot;name\u0026quot;:\u0026quot;Andy\u0026quot;} } } همینطور colon path به صورت زیر است:\n\u0026quot;users.:2313.name\u0026quot; \u0026gt;\u0026gt; \u0026quot;Sara\u0026quot; 4.8.6.4 Supported types # در کتابخانه SJSON تقریباً هر نوع متغیر یا type ای پشتیبانی می شود:\nsjson.Set(`{\u0026quot;key\u0026quot;:true}`, \u0026quot;key\u0026quot;, nil) sjson.Set(`{\u0026quot;key\u0026quot;:true}`, \u0026quot;key\u0026quot;, false) sjson.Set(`{\u0026quot;key\u0026quot;:true}`, \u0026quot;key\u0026quot;, 1) sjson.Set(`{\u0026quot;key\u0026quot;:true}`, \u0026quot;key\u0026quot;, 10.5) sjson.Set(`{\u0026quot;key\u0026quot;:true}`, \u0026quot;key\u0026quot;, \u0026quot;hello\u0026quot;) sjson.Set(`{\u0026quot;key\u0026quot;:true}`, \u0026quot;key\u0026quot;, []string{\u0026quot;hello\u0026quot;, \u0026quot;world\u0026quot;}) sjson.Set(`{\u0026quot;key\u0026quot;:true}`, \u0026quot;key\u0026quot;, map[string]interface{}{\u0026quot;hello\u0026quot;:\u0026quot;world\u0026quot;}) هنگامی که یک type شناسایی نمی شود، SJSON به رمزگذاری encoding/json باز می گردد.\n4.8.6.5 مثال SJSON # در این بخش به بررسی چند مثال از SJSON می پردازیم:\nوارد کردن یک مقدار در یک json document خالی.\nvalue, _ := sjson.Set(\u0026quot;\u0026quot;, \u0026quot;name\u0026quot;, \u0026quot;Tom\u0026quot;) println(value) // Output: // {\u0026quot;name\u0026quot;:\u0026quot;Tom\u0026quot;} وارد کردن یک مقادیر تو در تو یا nested در یک json document خالی.\nvalue, _ := sjson.Set(\u0026quot;\u0026quot;, \u0026quot;name.last\u0026quot;, \u0026quot;Anderson\u0026quot;) println(value) // Output: // {\u0026quot;name\u0026quot;:{\u0026quot;last\u0026quot;:\u0026quot;Anderson\u0026quot;}} وارد کردن مقدار جدید در سند:\nvalue, _ := sjson.Set(`{\u0026quot;name\u0026quot;:{\u0026quot;last\u0026quot;:\u0026quot;Anderson\u0026quot;}}`, \u0026quot;name.first\u0026quot;, \u0026quot;Sara\u0026quot;) println(value) // Output: // {\u0026quot;name\u0026quot;:{\u0026quot;first\u0026quot;:\u0026quot;Sara\u0026quot;,\u0026quot;last\u0026quot;:\u0026quot;Anderson\u0026quot;}} بروزرسانی و آپدیت یک سند:\nvalue, _ := sjson.Set(`{\u0026quot;name\u0026quot;:{\u0026quot;last\u0026quot;:\u0026quot;Anderson\u0026quot;}}`, \u0026quot;name.last\u0026quot;, \u0026quot;Smith\u0026quot;) println(value) // Output: // {\u0026quot;name\u0026quot;:{\u0026quot;last\u0026quot;:\u0026quot;Smith\u0026quot;}} وارد کردن مقدار آرایه جدید:\nvalue, _ := sjson.Set(`{\u0026quot;friends\u0026quot;:[\u0026quot;Andy\u0026quot;,\u0026quot;Carol\u0026quot;]}`, \u0026quot;friends.2\u0026quot;, \u0026quot;Sara\u0026quot;) println(value) // Output: // {\u0026quot;friends\u0026quot;:[\u0026quot;Andy\u0026quot;,\u0026quot;Carol\u0026quot;,\u0026quot;Sara\u0026quot;] اضافه کردن مقدار جدید به انتهای آرایه با استفاده از گزینه 1- :\nvalue, _ := sjson.Set(`{\u0026quot;friends\u0026quot;:[\u0026quot;Andy\u0026quot;,\u0026quot;Carol\u0026quot;]}`, \u0026quot;friends.-1\u0026quot;, \u0026quot;Sara\u0026quot;) println(value) // Output: // {\u0026quot;friends\u0026quot;:[\u0026quot;Andy\u0026quot;,\u0026quot;Carol\u0026quot;,\u0026quot;Sara\u0026quot;] اضافه کردن مقدار جدید به انتهای آرایه و null کردن سایر سلول‌های آرایه که بین انتهای آرایه و آخرین سلولی که دارای مقدار مشخص بوده است :\nvalue, _ := sjson.Set(`{\u0026quot;friends\u0026quot;:[\u0026quot;Andy\u0026quot;,\u0026quot;Carol\u0026quot;]}`, \u0026quot;friends.4\u0026quot;, \u0026quot;Sara\u0026quot;) println(value) // Output: // {\u0026quot;friends\u0026quot;:[\u0026quot;Andy\u0026quot;,\u0026quot;Carol\u0026quot;,null,null,\u0026quot;Sara\u0026quot;] حذف کردن یک مقدار:\nvalue, _ := sjson.Delete(`{\u0026quot;name\u0026quot;:{\u0026quot;first\u0026quot;:\u0026quot;Sara\u0026quot;,\u0026quot;last\u0026quot;:\u0026quot;Anderson\u0026quot;}}`, \u0026quot;name.first\u0026quot;) println(value) // Output: // {\u0026quot;name\u0026quot;:{\u0026quot;last\u0026quot;:\u0026quot;Anderson\u0026quot;}} حذف کردن مقادیر آرایه ای:\nvalue, _ := sjson.Delete(`{\u0026quot;friends\u0026quot;:[\u0026quot;Andy\u0026quot;,\u0026quot;Carol\u0026quot;]}`, \u0026quot;friends.1\u0026quot;) println(value) // Output: // {\u0026quot;friends\u0026quot;:[\u0026quot;Andy\u0026quot;]} حذف کردن انتهای آرایه:\nvalue, _ := sjson.Delete(`{\u0026quot;friends\u0026quot;:[\u0026quot;Andy\u0026quot;,\u0026quot;Carol\u0026quot;]}`, \u0026quot;friends.-1\u0026quot;) println(value) // Output: // {\u0026quot;friends\u0026quot;:[\u0026quot;Andy\u0026quot;]} "},{"id":51,"href":"/chapter-4/work-with-toml-file-in-go/","title":"4.9 آموزش کار با toml","section":"فصل چهارم: مباحث پیشرفته","content":" 4.9.1 مقدمه # فایل‌های TOML یک نمونه از فایل‌های پیکربندی هستند که در سیستم‌های مدرن مورد استفاده قرار می‌گیرند، این فایل‌ها به صورت متنی و قابل خواندن برای انسان و در عین حال قابل پردازش برای ماشین طراحی شده‌اند.\nTOML مخفف کلمات (Tom\u0026rsquo;s Obvious, Minimal Language) می‌باشد. جمعیت بزرگتری از افراد آن را مفسرند به این شکل که TOML ابزاری ساده برای پیکربندی بسیار درون‌فرمانی است. این فرمت فایل متنی دارای مقادیر شبیه به دیکشنری بوده و در بسیاری از نرم‌افزارها، به‌طور خاص در نرم‌افزارهای ساخته شده با golang بسیار به‌کار می‌رود.\nمثال زیر یک فایل TOML معتبر را نمایش می‌دهد:\n[database] server = \u0026quot;localhost\u0026quot; port = 3306 user = \u0026quot;username\u0026quot; password = \u0026quot;password\u0026quot; database = \u0026quot;myDB\u0026quot; در این مثال، تمام اطلاعات پیکربندی مربوط به یک پایگاه‌داده وجود دارد (server، port، user و غیره)، و به صورت مشخصی تعریف شده‌اند، به طوری که برای برنامه‌نویسی با استفاده از این پیکربندی بسیار سرعت‌بخش خواهد بود. از آنجا که فایل TOML قابل‌خواندی و ویرایش توسط انسان است، برنامه‌نویسی با این نوع فایل‌ها آسان و قابل فهم خواهد بود.\n4.9.2 کار با marshal و unmarshal پکیج toml # پکیج toml در زبان Go، حاوی توابع Marshal و Unmarshal برای تبدیل داده‌های Go به فرمت TOML و برعکس می‌باشد.\n4.9.2.1 Marshal # تابع Marshal برای تبدیل یک متغیر ساخته شده در Go به فرمت TOML مورد استفاده قرار می‌گیرد. برای استفاده از این تابع، باید داده‌های خود را به یک متغیر با نوع interface{} تبدیل کنید و سپس این متغیر را به تابع Marshal بدهید.\nبه عنوان مثال، برای تبدیل داده‌های map[string]interface{} به فرمت TOML، می‌توانید این کد را به کار ببرید:\npackage main import ( \"github.com/BurntSushi/toml\" \"fmt\" ) func main() { data := map[string]interface{}{ \"name\": \"John\", \"email\": \"john@example.com\", \"age\": 22, } tomlData, err := toml.Marshal(data) if err != nil { panic(err) } fmt.Println(string(tomlData)) } ▶ اجرای کد کپی ✖ بستن خروجی این کد یک دیکشنری ساده را تعریف می‌کند و سپس آن را به فرمت TOML تبدیل می‌کند. خروجی به صورت زیر خواهد بود:\n$ go run main.go age = 22 email = \u0026quot;john@example.com\u0026quot; name = \u0026quot;John\u0026quot; 4.9.2.2 Unmarshal # تابع Unmarshal، برای تبدیل یک رشته فرمت TOML به داده‌های Go استفاده می‌شود. برای استفاده از این تابع، باید با استفاده از تابع ioutil.ReadFile، فایل TOML مورد نظر را بخوانید و سپس رشته خوانده‌شده را به تابع Unmarshal بدهید.\nبه عنوان مثال، برای خواندن یک فایل TOML و تبدیل آن به یک دیکشنری در Go، می‌توانید این کد را به کار ببرید:\npackage main import ( \"github.com/BurntSushi/toml\" \"fmt\" \"io/ioutil\" ) type Person struct { Name string Email string Age int } func main() { data, err := ioutil.ReadFile(\"file.toml\") if err != nil { panic(err) } var person Person if _, err := toml.Decode(string(data), \u0026person); err != nil { panic(err) } fmt.Printf(\"%#v\\n\", person) } ▶ اجرای کد کپی ✖ بستن خروجی این کد یک فایل TOML با فرمت زیر را می‌خواند و مقادیر موجود در آن را به داده‌های Go مناسب تبدیل می‌کند:\nname = \u0026quot;John\u0026quot; email = \u0026quot;john@example.com\u0026quot; age = 22 خروجی به صورت زیر خواهد بود:\n$ go run main.go main.Person{Name:\u0026quot;John\u0026quot;, Email:\u0026quot;john@example.com\u0026quot;, Age:22} 4.9.3 تبدیل struct به toml و بلعکس # برای تبدیل یک struct به فرمت TOML و بلعکس، می‌توان از تابع‌های Marshal و Unmarshal پکیج toml استفاده کرد. در این روش، فیلدهای struct بر اساس نام آن‌ها و به صورت حروف کوچک در فایل TOML با نام فیلد متناظر ذخیره می‌شوند.\nهمچنین می‌توان از تگ‌ها در داخل struct برای تعیین نام فیلد در فایل TOML استفاده کرد. با استفاده از تگ toml:\u0026quot;name\u0026quot; می‌توان نامی دلخواه برای فیلد در فایل TOML مشخص کرد. همچنین می‌توان از تگ‌های دیگری مانند toml:\u0026quot;omitempty\u0026quot; برای اجباری نبودن یک فیلد در فایل TOML استفاده کرد.\nبه عنوان مثال، فرض کنید یک struct به نام Person با فیلدهای Name، Emailو Age داریم. با استفاده از تگ‌ها، نام فیلدها در فایل TOML و پیش‌فرض برای آن‌ها مشخص می‌شود.\npackage main import ( \"github.com/BurntSushi/toml\" \"fmt\" ) type Person struct { Name string `toml:\"name\"` Email string `toml:\"email,omitempty\"` Age int `toml:\"age\"` } func main() { // Marshaling from struct to TOML person := Person{Name: \"John\", Age: 30} tomlData, err := toml.Marshal(person) if err != nil { panic(err) } fmt.Println(string(tomlData)) // Unmarshaling from TOML to struct var p Person if _, err := toml.Decode(string(tomlData), \u0026p); err != nil { panic(err) } fmt.Printf(\"%#v\\n\", p) } ▶ اجرای کد کپی ✖ بستن خروجی در این مثال، struct با نام Person تعریف شده و از تگ برای نام‌گذاری فیلدها استفاده شده است. در تابع main، ابتدا از متد Marshal پکیج toml برای تبدیل یک شیء Person به فرمت TOML استفاده شده است. سپس با استفاده از متد Decode از پکیج toml، فایل TOML به داخل شیء Person تبدیل می‌شود.\nخروجی کد بالا به صورت زیر است:\n$ go run main.go name = \u0026quot;John\u0026quot; age = 30 main.Person{Name:\u0026quot;John\u0026quot;, Email:\u0026quot;\u0026quot;, Age:30} همان‌طور که مشاهده می‌کنید، نام فیلدها در فایل TOML با تگ‏های تعیین‌شده در struct مطابقت می‌کند. همچنین با توجه به تگ omitempty که در فیلد Email وجود دارد، این فیلد در فایل TOML نمایش داده نشده است، چرا که در شی person مقداری برای آن تعریف نشده بود.\n"},{"id":52,"href":"/chapter-4/work-with-yaml-file-in-go/","title":"4.10 آموزش کار با yaml","section":"فصل چهارم: مباحث پیشرفته","content":" 4.10.1 مقدمه # YAML یک زبان فراهم کننده ساختار پذیر برای نمایش اطلاعات است که در قالب متن موجود می‌باشد. این زبان ابتدا برای نوشتن سند‌های XML توسعه یافت که با پیشرفت کاربردهای آن به محل جایگزینی برای فرمت‌های رایجی همچون JSON و اقلیتاً TOML تبدیل شده است.\nاین فرمت در صنعت‌های مختلف مورد استفاده و ستوده شده ‌است، مانند ذخیره سازی تنظیمات سیستمی، فایل‌های کانفیگ مختلف، فایل‌های داده و \u0026hellip; . همچنین به خاطر قابل خواندن بودن برای انسان، استفاده از YAML در فایل‌هایی که باید توسط بشر خوانده شوند مانند فایل‌های خودرو، پروژه و\u0026hellip; صورت گرفته است.\nیکی از نمونه‌های کاربردی YAML، استفاده از آن در فایل‌های کانفیگ ‌Docker است. در فایل docker-compose.yaml، بخش‌های مختلفی از یک سرویس در قالب Block mapping و با کلید‌های خاصی مانند version، services، ports و غیره تعریف شده است. این فرمت به طور کل شرکت‌های بزرگی مانند مایکروسافت، ای‌بی‌ای و گوگل، در محصولات خود به صورت فایل‌های YAML استفاده می‌کنند.\nبنابراین، می‌توان گفت YAML یک فرمت متنی ساده و پذیرفتنی است که در بسیاری از پروژه‌های نرم‌افزاری استفاده می‌شود، به خاطر پشتیبانی از انواع داده‌ها و ساختارهای مختلف، قابلیت خواندن و نوشتن آسان برای انسان و قابل استفاده در زبان‌های مختلفی استفاده از YAML در صنایع مختلفی از جمله فناوری‌های اطلاعات، اینترنت اشیا و\u0026hellip; رایج است.\n4.10.2 کار با marshal و unmarshal پکیج yaml # پکیج YAML در زبان Go شامل توابع Marshal و Unmarshal برای تبدیل داده‌های Go به فرمت YAML و بالعکس می‌شود. استفاده از این توابع بسیار ساده است و می‌توان به سرعت با استفاده از ویژگی‌های زبان Go به داده‌ها دسترسی پیدا کرد.\nبرای مثال، فرض کنید یک پرونده YAML با محتوای زیر داریم:\nname: John age: 25 isStudent: true 4.10.2.1 Marshal # همچنین، می‌توان از تابع Marshal برای تبدیل ساختار داده‌ای Go به فرمت YAML استفاده کرد. به عنوان مثال، برای تبدیل ساختار Person به فرمت YAML می‌توان از کد زیر استفاده کرد:\npackage main import ( \"fmt\" \"gopkg.in/yaml.v2\" \"log\" ) func main() { person := Person{ Name: \"John\", Age: 25, IsStudent: true, } yamlData, err := yaml.Marshal(\u0026person) if err != nil { log.Fatalf(\"error: %v\", err) } fmt.Printf(\"%s\", string(yamlData)) } ▶ اجرای کد کپی ✖ بستن خروجی در این کد، یک شیء از ساختار Person را ایجاد می کنیم و سپس از تابع Marshal برای تبدیل آن به فرمت YAML استفاده می کنیم. سپس محتوای YAML را به کمک تابع Printf چاپ می کنیم.\nبه این ترتیب پکیج YAML از امکانات و قابلیت بالایی برای کد نویسی و کار با فرمت YAML در زبان Go برخوردار می‌باشد.\n4.10.2.2 Unmarshal # می‌توانیم این پرونده را به کمک تابع Unmarshal به یک ساختار Go تبدیل کنیم. برای این کار، ابتدا نیاز است که یک ساختار داده‌ای برای ذخیره اطلاعات YAML تعریف کنیم. در این حالت، می‌توانیم از ساختار زیر استفاده کنیم:\ntype Person struct { Name string `yaml:\u0026quot;name\u0026quot;` Age int `yaml:\u0026quot;age\u0026quot;` IsStudent bool `yaml:\u0026quot;isStudent\u0026quot;` } حالا می توانیم از تابع Unmarshal برای تبدیل داده‌ی YAML به ساختار Go استفاده کنیم:\npackage main import ( \"fmt\" \"gopkg.in/yaml.v2\" \"log\" ) type Person struct { Name string `yaml:\"name\"` Age int `yaml:\"age\"` IsStudent bool `yaml:\"isStudent\"` } func main() { yamlData := ` name: John age: 25 isStudent: true ` var person Person err := yaml.Unmarshal([]byte(yamlData), \u0026person) if err != nil { log.Fatalf(\"error: %v\", err) } fmt.Printf(\"Name: %s\\nAge: %d\\nIsStudent: %v\", person.Name, person.Age, person.IsStudent) } ▶ اجرای کد کپی ✖ بستن خروجی این کد پرونده YAML را به متغیر yamlData منتسب کرده، از تابع Unmarshal برای تجزیه و تحلیل داده‌های YAML استفاده و ساختار Person را با مقادیر معادل پر کرده‌است. سپس جزئیات این ساختار را چاپ می‌کنیم.\n"},{"id":53,"href":"/chapter-4/work-with-csv-file-in-go/","title":"4.11 آموزش کار با csv","section":"فصل چهارم: مباحث پیشرفته","content":" 4.11.1 مقدمه # CSV یکی از فرمت‌های متداول برای ذخیره داده‌های جدولی است. خروجی اکثر برنامه‌های قابلیت دستکاری داده، همراه با نرم‌افزار‌های آفیس، به فرمت CSV تولید می‌شود. فرمت CSV چندین ستون در یک ردیف را با استفاده از کاما (,) جدا کرده و هر ردیف را با استفاده از عبارت جدید (newline) جدا می‌کند.\nدر زبان برنامه‌نویسی Go نیز پکیج encoding/csv وجود دارد که در آن، توابع مربوط به خواندن و نوشتن داده‌های CSV به صورت دستی یا از طریق پرونده‌ها فراهم شده است. با استفاده از این پکیج، می‌توان داده‌های CSV را به داده‌های جدولی تبدیل کرد و برعکس.\nبه عنوان مثال، در ادامه یک فایل CSV به نام \u0026ldquo;data.csv\u0026rdquo; حاوی اطلاعات چند شخص را در نظر بگیرید:\nName,Age,City John,25,New York Jane,30,San Francisco Bob,40,Los Angeles 4.11.2 نحوه خواندن فایل csv # برای خواندن فایل csv می‌توان با استفاده از پکیج encoding/csv پرونده CSV را باز کرد:\npackage main import ( \"encoding/csv\" \"fmt\" \"os\" ) func main() { f, err := os.Open(\"data.csv\") if err != nil { panic(err) } r := csv.NewReader(f) records, err := r.ReadAll() if err != nil { panic(err) } for _, row := range records { for _, col := range row { fmt.Print(col, \"\\t\") } fmt.Println() } } ▶ اجرای کد کپی ✖ بستن خروجی در این کد، تابع os.Open برای باز کردن پرونده CSV استفاده می‌شود. یک رابط csv.Reader ایجاد شده و یک رشته ساختارمند، پرونده CSV را می‌خواند. سپس با استفاده از یک حلقه، داده‌های جدولی چاپ می‌شود.\nفراداده‌های CSV بسیار گسترده هستند و می‌توانند شامل شماره دسته، توضیحات، یادداشت‌های شخصی و غیره باشند. برای کار با این نوع داده‌ها، پکیج encoding/csv امکاناتی مانند تنظیمات csv.Reader را فراهم می‌کند، که در آن، می‌توانیم تنظیماتی مانند علامت‌گذاری مناسب فایل CSV و دیگر علامت‌گذاری‌ها را بهبود ببخشیم.\n4.11.3 ReadAll فایل csv # تابع ReadAll تمام رکوردهای باقی مانده را از reader می خواند. هر رکورد یک قسمتی از fieldها است.\nfirst_name,last_name,occupation John,Doe,gardener Lucy,Smith,teacher Brian,Bethamy,programmer نام این فایل users.csv است. خط اول نام ستون ها هستند.\npackage main import ( \"encoding/csv\" \"fmt\" \"log\" \"os\" ) type User struct { firstName string lastName string occupation string } func main() { records, err := readData(\"users.csv\") if err != nil { log.Fatal(err) } for _, record := range records { user := User{ firstName: record[0], lastName: record[1], occupation: record[2], } fmt.Printf(\"%s %s is a %s\\n\", user.firstName, user.lastName, user.occupation) } } func readData(fileName string) ([][]string, error) { f, err := os.Open(fileName) if err != nil { return [][]string{}, err } defer f.Close() r := csv.NewReader(f) // skip first line if _, err := r.Read(); err != nil { return [][]string{}, err } records, err := r.ReadAll() if err != nil { return [][]string{}, err } return records, nil } ▶ اجرای کد کپی ✖ بستن خروجی اسم فایل بالا read_all.go می‌باشد و این مثال فایل users.csv را می خواند. هر line به یک User type را بر می‌گرداند.\n// skip first line if _, err := r.Read(); err != nil { return [][]string{}, err } در اینجا از خط اول که شامل نام ستون هاست می گذریم.\nrecords, err := r.ReadAll() در نهایت همه رکوردها را یک جا با ReadAll دریافت می کنیم.\n$ go run read_all.go John Doe is a gardener Lucy Smith is a teacher Brian Bethamy is a programmer 4.11.4 delimiter CSV دلخواه # علیرغم نام CSV ، CSV ممکن است دارای جداکننده های دیگری غیر از کاما باشد. این به دلیل استاندارد نبودن قالب CSV است.\n# user.csv # this is users.csv file John;Doe;gardener Lucy;Smith;teacher Brian;Bethamy;programmer در فایل users.csv فیلدها با نقطه ویرگول از هم جدا شده اند. این فایل حاوی یک comment نیز می‌باشد.\n//different_delimiter.go// package main import ( \"encoding/csv\" \"fmt\" \"log\" \"os\" ) func main() { f, err := os.Open(\"users.csv\") if err != nil { log.Fatal(err) } r := csv.NewReader(f) r.Comma = ';' r.Comment = '#' records, err := r.ReadAll() if err != nil { log.Fatal(err) } fmt.Print(records) } ▶ اجرای کد کپی ✖ بستن خروجی این مثال تمام داده های این فایل را می خواند.\nr := csv.NewReader(f) r.Comma = ';' r.Comment = '#' در اینجا separator و کاراکتر comment را تنظیم می کنیم تا package بداند چگونه فایل را parse یا تجریه تحلیل کند.\n4.11.5 نوشتن CSV # تابع Write یک رکورد CSV را برای writer می نویسد. رکورد برشی از strings است که هر string یک فیلد است. write ها buffer شده هستند، بنابراین باید Flush فراخوانی شود تا اطمینان حاصل شود که رکورد برای writer اصلی نوشته شده است.\n//write_fun.go// package main import ( \"encoding/csv\" \"log\" \"os\" ) func main() { records := [][]string{ {\"first_name\", \"last_name\", \"occupation\"}, {\"John\", \"Doe\", \"gardener\"}, {\"Lucy\", \"Smith\", \"teacher\"}, {\"Brian\", \"Bethamy\", \"programmer\"}, } f, err := os.Create(\"users.csv\") defer f.Close() if err != nil { log.Fatalln(\"failed to open file\", err) } w := csv.NewWriter(f) defer w.Flush() for _, record := range records { if err := w.Write(record); err != nil { log.Fatalln(\"error writing record to file\", err) } } } ▶ اجرای کد کپی ✖ بستن خروجی در مثال بالا، چند رکورد را با تابع Write در فایل users.csv نوشتیم.\n4.11.6 نوشتن WriteAll CSV # تابع WriteAll چندین رکورد CSV را با استفاده از Write برای writer می‌نویسد و سپس Flush را فراخوانی می‌کند.\n//write_all.go// package main import ( \"encoding/csv\" \"log\" \"os\" ) func main() { records := [][]string{ {\"first_name\", \"last_name\", \"occupation\"}, {\"John\", \"Doe\", \"gardener\"}, {\"Lucy\", \"Smith\", \"teacher\"}, {\"Brian\", \"Bethamy\", \"programmer\"}, } f, err := os.Create(\"users.csv\") defer f.Close() if err != nil { log.Fatalln(\"failed to open file\", err) } w := csv.NewWriter(f) err = w.WriteAll(records) // calls Flush internally if err != nil { log.Fatal(err) } } ▶ اجرای کد کپی ✖ بستن خروجی در نهایت ما چند رکورد را در یک لحظه با WriteAll می نویسیم.\n"},{"id":54,"href":"/chapter-4/work-with-ini-file-in-go/","title":"4.12 آموزش کار با ini","section":"فصل چهارم: مباحث پیشرفته","content":"بطور خلاصه فایل های ini.* جهت ذخیره تنظیمات مختلف استفاده می شود تنظیماتی مثل: آدرس خاص در شبکه، اطلاعات ورود به سیستم های مختلف و موارد از این قبیل.\nبرای شروع ساختار پروژه ما به این شکل است\n$ mkdir -p /tmp/ini $ cd /tmp/ini $ touch my.ini main.go $ tree . . ├── main.go └── my.ini در پروژه دو فایل ایجاد کردیم یکی فایل اصلی برنامه main.go و دیگری my.ini که می خواهیم تنظیمات برنامه را در آن نگهداری کنیم. محتوای داخل فایل ini را بصورت ذیل تعریف کرده ایم\n# possible values : production, development app_mode = development [paths] # Path to where grafana can store temp files, sessions, and the sqlite3 db (if that is used) data = /home/git/grafana [server] # Protocol (http or https) protocol = http # The http port to use http_port = 9999 # Redirect to correct domain if host header does not match domain # Prevents DNS rebinding attacks enforce_domain = true همانطور که در توصیف کد آمده است 5 مقدار مختلف داخل فایل آمده است برخی را توضیح می دهیم\nمقدار app_mode که در واقع میخواهیم جهت تشخیص مود توسعه استفاده کنیم برای مثال به کمک این مقدار میخواهیم لاگ های برنامه در پروداکشن نمایش داده نشود ولی در زمان توسعه دهنده بتوانیم لاگ هایم مختلف را مشاهده کنیم. قسمت بعد protocol است که کاملا مشخص می باشد و در واقع میخواهیم پروتکل استفاده شده را مشخص کنیم حط بعد شماره پورت مورد استفاده برنامه است که مقدار 9999 می باشد مقادیر وارد شده صرفا برای مثال می باشد و می توان هر مقداری را که در برنامه نیاز دارید ایجاد کنید.\npackage main import ( \"fmt\" \"os\" \"gopkg.in/ini.v1\" ) func main() { cfg, err := ini.Load(\"my.ini\") if err != nil { fmt.Printf(\"Fail to read file: %v\", err) os.Exit(1) } // Classic read of values, default section can be represented as empty string fmt.Println(\"App Mode:\", cfg.Section(\"\").Key(\"app_mode\").String()) fmt.Println(\"Data Path:\", cfg.Section(\"paths\").Key(\"data\").String()) // Let's do some candidate value limitation fmt.Println(\"Server Protocol:\", cfg.Section(\"server\").Key(\"protocol\").In(\"http\", []string{\"http\", \"https\"})) // Value read that is not in candidates will be discarded and fall back to given default value fmt.Println(\"Email Protocol:\", cfg.Section(\"server\").Key(\"protocol\").In(\"smtp\", []string{\"imap\", \"smtp\"})) // Try out auto-type conversion fmt.Printf(\"Port Number: (%[1]T) %[1]d\\n\", cfg.Section(\"server\").Key(\"http_port\").MustInt(9999)) fmt.Printf(\"Enforce Domain: (%[1]T) %[1]v\\n\", cfg.Section(\"server\").Key(\"enforce_domain\").MustBool(false)) // Now, make some changes and save it cfg.Section(\"\").Key(\"app_mode\").SetValue(\"production\") cfg.SaveTo(\"my.ini.local\") } ▶ اجرای کد کپی ✖ بستن خروجی کد بالا به اندازه کافی شفاف و ساده است که نیازی به توضیح بیشتر ندارد در ابتدا نیاز است تا بسته \u0026ldquo;gopkg.in/ini.v1\u0026rdquo; را به برنامه اضافه کنیم سپس با متد load فایل کانفیگ موجود را به حافظه بارگذاری می کنیم تا محتوای آن را بخوانیم و خط های بعد مقادیر آن را میخوانیم در خط پایانی نیز مقدار app_mode را به production تغییر دادیم و در فایل جدیدی به نام my.ini.local ذخیره کردیم .\nمی توانیم به شکل های مختلف یک فایل را بارگذاری یا ایجاد کنیم به مثال ذیل توجه کنید:\ncfg, err := ini.Load( []byte(\u0026quot;raw data\u0026quot;), // Raw data \u0026quot;filename\u0026quot;, // File ioutil.NopCloser(bytes.NewReader([]byte(\u0026quot;some other data\u0026quot;))), ) در این قطعه کد ما تنظیمات خود را به 3 شکل می توانیم فراخوانی کنیم رشته، فایل و io.ReadCloser البته در صورت نیاز می توانیم یک فایل خالی در فضای حافظه بشکل ذیل نیز ایجاد کنیم.\ncfg := ini.Empty() در ابتدا می توانید هر تعداد فایل ini را بارگذاری و یا فرخوانی کنید ولیکن مواقعی نیاز دارید که یک منبع دیگر به آنها اضافه کنید که برای این منظور می توانید از دستور Append استفاده نمائید\nerr := cfg.Append(\u0026quot;other file\u0026quot;, []byte(\u0026quot;other raw data\u0026quot;)) و یا مواقعی از چند منبع اقدام به بارگذاری می نمائید که احتمال دارد برخی از آن منابع خطا در بارگذاری دهد در این شرایط بهتر از تابع ()LooseLoadd استفاده کنید\ncfg, err := ini.LooseLoad(\u0026quot;filename\u0026quot;, \u0026quot;filename_404\u0026quot;) و در نهایت می توانید پس از تغییرات دلخواه فایل را بصورت ذیل ذخیره نمائید\n// ... err = cfg.SaveTo(\u0026quot;my.ini\u0026quot;) err = cfg.SaveToIndent(\u0026quot;my.ini\u0026quot;, \u0026quot;\\t\u0026quot;) همانطور که در بالا دید برای دسترسی به یک قسمت از فایل ما از تابع Section بصورت ذیل استفاده می کنیم\nsec, err := cfg.GetSection(\u0026quot;section name\u0026quot;) که در اینجا \u0026ldquo;section name\u0026rdquo; نام قطعه کد ما در فایل تنظیمات است. برخی از توابع مهم این بسته عبارت اند از : 1.\nerr := cfg.NewSection(\u0026quot;new section\u0026quot;) جهت ایجاد قطعه جدید 2.\nsecs := cfg.Sections() names := cfg.SectionStrings() برای بدست آوردن تمامی قطعات داخل فایل 3.\nkey, err := cfg.Section(\u0026quot;\u0026quot;).GetKey(\u0026quot;app_mode\u0026quot;) برای بدست آوردن key یک section بطور مثال \u0026ldquo;app_mode\u0026rdquo; 4.\nkey, err := cfg.Section(\u0026quot;\u0026quot;).HasKey(\u0026quot;app_mode\u0026quot;) برای بررسی وجود یک key 5.\nkey, err := cfg.Section(\u0026quot;\u0026quot;).NewKey(\u0026quot;name\u0026quot;, \u0026quot;value\u0026quot;) برای ایجاد یک key جدید\n"},{"id":55,"href":"/chapter-4/work-with-environment-variable/","title":"4.13 آموزش کار با environment variable","section":"فصل چهارم: مباحث پیشرفته","content":"Environment Variables یا متغیرهای محیطی، متغیرهایی هستند که در فضای محیطی سیستم عامل مشخص شده‌اند. این متغیرها، شامل اطلاعاتی مانند مسیر فایل‌ها، تنظیمات سیستم، ترجیحات و تعیینات ساده و دیگر اطلاعات مورد استفاده توسط برنامه‌ها هستند.\nبه عنوان مثال، در سیستم عامل لینوکس، PATH یک متغیر محیطی است که شامل یک فهرست از دایرکتوری‌هایی است که سیستم به دنبال فایل‌ها و برنامه‌ها می‌گردد. برای دسترسی به این متغیر، می‌توان از دستور زیر در خط فرمان استفاده کرد:\necho $PATH همچنین، در زبان برنامه‌نویسی Go نیز استفاده از Environment Variables بسیار رایج است. برای نمونه، تنظیمات پایگاه داده را می‌توان با استفاده از Environment Variables در برنامه اصلی تنظیم کرد. در این مثال بسیار کوتاه، متصل شدن به پایگاه داده با استفاده از متغیرهای محیطی بیان شده است:\npackage main import ( \"database/sql\" \"os\" ) func main() { db, err := sql.Open(\"postgres\", os.Getenv(\"DATABASE_URL\")) if err != nil { panic(err) } defer db.Close() // Do something with the database } ▶ اجرای کد کپی ✖ بستن خروجی در این مثال، پایگاه داده PostgreSQL از طریق پارامتر DATABASE_URL قابل تنظیم است. با استفاده از os.Getenv مقدار متغیر محیطی با همین نام به دست می‌آید و سپس به عنوان آرگومان به sql.Open ارائه می‌شود.\nاستفاده از Environment Variables یک روش مدیریتی عالی برای محیط برنامه است. این روش، به برنامه‌ها امکان می‌دهد که بدون اینکه برای هر برنامه یک سری تنظیمات خاص وجود داشته باشد، با یک سری تنظیمات کلی کار کنند و به صورت پویا و گسترده پاسخگو باشند.\n4.13.1 نحوه set کردن # در زبان برنامه‌نویسی Go، برای set کردن Environment Variables می‌توان از پکیج os استفاده کرد. برای مثال، برای تعیین متغیر محیطی با نام \u0026ldquo;DATABASE_URL\u0026rdquo; به مقدار \u0026ldquo;postgresql://localhost/mydb\u0026rdquo; می‌توانید از تابع os.Setenv استفاده کنید:\npackage main import ( \"fmt\" \"os\" ) func main() { err := os.Setenv(\"DATABASE_URL\", \"postgresql://localhost/mydb\") if err != nil { panic(err) } fmt.Println(\"Environment variable set successfully\") } ▶ اجرای کد کپی ✖ بستن خروجی در این مثال، با استفاده از تابع os.Setenv، متغیر محیطی با نام DATABASE_URL و مقدار postgresql://localhost/mydb تنظیم شده است. اگر خطا رخ دهد، با استفاده از تابع panic خطا ثبت می‌شود. سپس یک پیام تاییدی برای نشان دادن موفقیت set کردن متغیر محیطی نمایش داده می‌شود.\nاگر بخواهید یک Environment Variable را به یک مقدار خالی تنظیم کنید، می‌توانید از تابع os.Unsetenv استفاده کنید. برای مثال، برای حذف متغیر محیطی DATABASE_URL، کد زیر را می‌توانید استفاده کنید:\npackage main import ( \"fmt\" \"os\" ) func main() { err := os.Unsetenv(\"DATABASE_URL\") if err != nil { panic(err) } fmt.Println(\"Environment variable unset successfully\") } ▶ اجرای کد کپی ✖ بستن خروجی در این مثال، با استفاده از تابع os.Unsetenv، متغیر محیطی با نام DATABASE_URL حذف شده است. اگر خطا رخ دهد، با استفاده از تابع panic خطا ثبت می‌شود. سپس یک پیام تاییدی برای نشان دادن موفقیت unset کردن متغیر محیطی نمایش داده می‌شود.\n4.13.2 نحوه get کردن # در زبان برنامه‌نویسی Go، برای get کردن Environment Variables می‌توان از پکیج os استفاده کرد. برای مثال، برای به دست آوردن مقدار متغیر محیطی با نام \u0026ldquo;DATABASE_URL\u0026rdquo; می‌توانید از تابع os.Getenv استفاده کنید:\npackage main import ( \"fmt\" \"os\" ) func main() { dbUrl := os.Getenv(\"DATABASE_URL\") fmt.Printf(\"Database URL: %s\\n\", dbUrl) } ▶ اجرای کد کپی ✖ بستن خروجی در این مثال، با استفاده از تابع os.Getenv، متغیر محیطی با نام DATABASE_URL به عنوان پارامتر به تابع ارسال شده و مقدار آن در یک متغیر به نام dbUrl ذخیره شده است. سپس با استفاده از تابع fmt.Printf، مقدار dbUrl به همراه یک پیام مشابه \u0026ldquo;Database URL: postgresql://localhost/mydb\u0026rdquo; نمایش داده می‌شود.\nاگر مقدار متغیر محیطی مورد نظر وجود نداشته باشد، تابع os.Getenv مقدار خالی برمی‌گرداند. لذا برای اطمینان از وجود مقدار متغیر محیطی، می‌توانید از تابع os.LookupEnv استفاده کنید. برای مثال، کد زیر چک می‌کند که آیا متغیر محیطی EMAIL تنظیم شده است یا خیر:\npackage main import ( \"fmt\" \"os\" ) func main() { email, ok := os.LookupEnv(\"EMAIL\") if ok { fmt.Printf(\"Email address: %s\\n\", email) } else { fmt.Println(\"Email address is not set\") } } ▶ اجرای کد کپی ✖ بستن خروجی در این مثال، با استفاده از تابع os.LookupEnv، متغیر محیطی با نام EMAIL برای وجود مقدار بررسی شده است. اگر مقدار موجود بود، با استفاده از تابع fmt.Printf، مقدار این متغیر به همراه یک پیام مشابه \u0026ldquo;Email address: user@example.com\u0026rdquo; نمایش داده می‌شود. در صورتی که مقداری برای این متغیر وجود نداشته باشد، با استفاده از تابع fmt.Println، یک پیام مشابه \u0026ldquo;Email address is not set\u0026rdquo; نمایش داده می‌شود.\n4.13.3 کار با فایل env. # فایل .env یک فایل متنی است که حاوی متغیرهای محیطی برای برنامه شما است. در Go، می‌توانیم از پکیج godotenv استفاده کنیم تا مقادیر متغیرهای محیطی را از فایل .env بخوانیم و در متغیرهای خود بارگذاری کنیم.\nبرای استفاده از پکیج godotenv، ابتدا باید آن را با استفاده از دستور زیر نصب کنید:\ngo get github.com/joho/godotenv سپس می‌توانید از تابع godotenv.Load() استفاده کنید تا متغیرهای محیطی از فایل .env خوانده شود. در زیر یک مثال برای استفاده از پکیج godotenv به همراه فایل .env نشان داده شده است:\nفرض کنید فایل .env شما به شکل زیر باشد:\nDATABASE_URL=postgresql://localhost/mydb API_KEY=AbCdEfGhIjKlMnOp حال در کد Go خود، پکیج godotenv را import کرده و با استفاده از تابع godotenv.Load()، متغیرهای محیطی از فایل .env خوانده شده و در متغیرهای خود بارگذاری کنید:\npackage main import ( \"fmt\" \"github.com/joho/godotenv\" \"os\" ) func main() { // Load environment variables from .env file err := godotenv.Load() if err != nil { fmt.Println(\"Error loading .env file\") os.Exit(1) } // Get values of environment variables dbUrl := os.Getenv(\"DATABASE_URL\") apiKey := os.Getenv(\"API_KEY\") // Print the values fmt.Printf(\"Database URL: %s\\n\", dbUrl) fmt.Printf(\"API Key: %s\\n\", apiKey) } ▶ اجرای کد کپی ✖ بستن خروجی در این مثال، با استفاده از تابع godotenv.Load()، متغیرهای محیطی از فایل .env خوانده شده و در متغیرهای خود بارگذاری شده‌اند. سپس با استفاده از تابع os.Getenv()، مقادیر این متغیرها به دست آمده و با استفاده از تابع fmt.Printf نمایش داده شده‌اند.\nبا استفاده از این روش، مقادیری که در فایل .env تعریف شده‌اند، در زمان اجرای برنامه به راحتی قابل دسترس خواهند بود و این اجازه را به شما می‌دهد که مقادیر مورد نیاز را به راحتی تغییر دهید و حتی بدون تغییر کد، برنامه خود را در محیط‌های مختلف اجرا کنید.\n"},{"id":56,"href":"/chapter-4/go-regular-expressions/","title":"4.14 آموزش کار با regexp","section":"فصل چهارم: مباحث پیشرفته","content":"مواقعی در کد نویسی دارید که نیاز هست تا یک عبارتی مثل شماره تلفن،کد پستی و یا شماره پاسپورت وارد شده را بصورت قاعده مند بررسی کنید به عبارتی کاربر نتواند برای فیلد شماره تلفن، کاراکتر غیر عددی وارد کند. در این مواقع بهتر است داده وارد شده بصورت قاعده مند بررسی شود. برای درک بهتر موضوع به رشته وارد شده توسط کاربر که می تواند سهوا باشد دقت کنید\n+989121234#566 در این رشته کاربر مرتکب دو اشتباه شده است.\nشماره موبایل یک رقم بیشتر وارد شده است کاربر بجای رقم از علامت # استفاده کرده است در چنین شرایطی روش های بررسی مرسوم داده پاسخگو نیست و بهتر است از عبارات با قاعده استفاده کنیم.\nدر زبان برنامه نویسی Go بسته از پیش تعریف شده regexp برای اینکار وجود دارد.\nimport ( \u0026quot;regexp\u0026quot; ) برای شروع و درک بهتر مطلب اجازه دهید از یک مثال ساده شروع کنیم. میخواهیم بررسی کنیم آیا کاربر کارکتر نقطه [.] را وارد کرده است یا خیر .\npackage main import ( \"fmt\" \"regexp\" ) func main() { sampleRegex := regexp.MustCompile(\"[.]\") match := sampleRegex.Match([]byte(\".\")) fmt.Println(match) } ▶ اجرای کد کپی ✖ بستن خروجی در کد فوق به کمک تابع MustCompile عبارت قاعده مند را دریافت می کنیم در صورتیکه عبارت وارد شده قابل قبول یا معتبر نباشد panic اتفاق خواهد افتاد . دقت داشته باشید که خود عبارت قاعده مند دارای استاندارد و چارچوب های مشخص است که بهتر است درصورت عدم اطلاع از ابتدا آن را بیاموزید.\nدقت کنید که در کد فوق عبارت مد نظر خود را داخل [] قرار داده ایم و در خط بعد با تابع Match که مقدار مورد نظر را بصورت رشته ای از بایت ها به آن معرفی کرده ایم بررسی می کنیم که \u0026ldquo;.\u0026rdquo; در رشته وجود دارد یا خیر که خروجی این بررسی یک مقدار بولین بصورت ذیل است.\ntrue در واقع می توانید رشته های ساده را نیز با این روش مقایسه کنید بطور مثال :\npackage main import ( \"fmt\" \"regexp\" ) func main() { first := \"abc\" second := \"xyz\" third := \"123\" sampleRegex := regexp.MustCompile(first + second + third) match := sampleRegex.Match([]byte(\"abcxyz123\")) fmt.Println(match) } ▶ اجرای کد کپی ✖ بستن خروجی اگر به کد فوق دقت کنید متوجه خواهید شد که مقادیر بررسی شده بصورت کامل بوده و چنانچه بررسی شما شامل بخشی از عبارت وارد شده باشد باز نتیجه بررسی اشتباه خواهد بود برای مثال ما قسمتی از کد را تغییر می دهیم\npackage main ... func main() { ... match := sampleRegex.Match([]byte(\u0026quot;abcxyz\u0026quot;)) fmt.Println(match) } در اینجا نتیجه بررسی برای عبارت \u0026ldquo;abcxyz\u0026rdquo; که در عبارت اصلی یعنی \u0026ldquo;abcxyz123\u0026rdquo; قرار دارد مقدار false نمایش داده خواهد شد که این به معنای بررسی کل عبارت است. برای رفع این اشتباه می بایست از ساختار عبارات قاعده مند بهر بگیریم و به این شکل به برنامه اطلاع دهیم که عبارت مد نظر ما می تواند بخشی از عبارت وارد شده باشد.\npackage main import ( \"fmt\" \"regexp\" ) func main() { sampleRegex := regexp.MustCompile(\"[abc]\") match := sampleRegex.Match([]byte(\"abcd\")) fmt.Printf(\"For abcd: %t\\n\", match) match = sampleRegex.Match([]byte(\"1abc23\")) fmt.Printf(\"For 1abc23: %t\\n\", match) match = sampleRegex.Match([]byte(\"abc\")) fmt.Printf(\"For abc: %t\\n\", match) } ▶ اجرای کد کپی ✖ بستن خروجی در کد فوق کارکترهای [] به این معنا است که عبارت مورد نظر می تواند شامل عبارت مورد مقایسه نیز باشد. به چند تا از علائم و معانی پرکاربرد در عبارات قاعده مند توجه کنید.\n\\w فقط شامل حروف باشد \\W شامل حروف نباشد \\d شامل اعداد باشد \\Dشامل اعداد نباشد \\s شامل فضای خالی باشد \\S شامل فضای خالی نباشد \\+ شامل حداقل یک یا بیشتر باشد \\* شامل صفر یا بیشتر باشد \\| شامل عبارت مورد نظر و یا مورد دیگر باشد لیست کامل این عبارات را می توانید در اینجا مشاهده کنید.\nدر مواقعی مایل هستیم که عبارت مورد نظر در رشته را جستجو و نمایش دهیم بطور مثال:\npackage main import ( \"fmt\" \"regexp\" ) func main() { sampleRegexp := regexp.MustCompile(`(ab){2}`) matches := sampleRegexp.FindString(\"abab\") fmt.Println(matches) matches = sampleRegexp.FindString(\"ababbc\") fmt.Println(matches) } ▶ اجرای کد کپی ✖ بستن خروجی در اینجا از برنامه خواسته ایم که به دنبال ترکیبی از ab با تکرار دوبار متوالی باشد و در انتها عبارت پیدا شده توسط تابع FindString را نمایش دهد که علامت () تاکید روی عبارت مورد نظر است و {2} به معنی تکرار حداقل دوبار متوالی است.\nخروجی کد بالا\n$go run main.go abab abab در پایان می خواهیم یک مثال سختر را که در ابتدا به آن اشاره کردیم بنویسیم و آن بررسی شماره تلفن است.\npackage main import ( \"fmt\" \"regexp\" ) func main() { sampleRegexp := regexp.MustCompile(`^\\+989(1[0-9]|3[1-9]|2[1-9])?[0-9]{7}$`) matches := sampleRegexp.Match([]byte(\"+989121234#566\")) fmt.Println(matches) matches = sampleRegexp.Match([]byte(\"+989121234567\")) fmt.Println(matches) } ▶ اجرای کد کپی ✖ بستن خروجی در کد فوق علامت ^ در عبارات با قاعده به معنی شروع ساختار عبارت است و علامت $ به معنای پایان عبارت. درواقع تمامی رشته های که قرار است عتبار سنجی شوند باید در ساختار بین این تو کاراکتر تطبیق شوند. در ادامه نیاز است تا با کمک کاراکتر \\ اثر کارکتر + را خنثی کنیم به این معنی که تمامی شماره های وارد شده باید علامت + در ابتدا داشته باشند سپس قید شده است که 989 که پیش شمار ایران و موبایل است را قید کرده ایم . از آنجا که شماره موبایلهای ایران 911|912|913 شروع می شود با این عبارت \u0026ldquo;(1[0-9]|3[1-9]|2[1-9])\u0026rdquo; مشخص کرده ایم. علامت ؟ به معنی حداقل یکبار تکرار شده عبارت قبل خودش است و در انتها کاربر می بایست هفت رقم وارد که به این صورت مشخص شده است \u0026ldquo;[0-9]{7}\u0026rdquo;. همانطور مشاهده می کنید رشته اول معتبر نبوده ولی رشته دوم صحیح است.\n"},{"id":57,"href":"/chapter-4/go-reflection/","title":"4.15 آموزش reflection","section":"فصل چهارم: مباحث پیشرفته","content":"پکیج reflect در زبان Go، امکانات reflection زمان اجرا را فراهم می‌کند که به یک برنامه اجازه می‌دهد تا با اشیاءی با انواع دلخواه کار کند. استفاده اصلی این پکیج، گرفتن اطلاعات نوع پویای یک مقدار با نوع استاتیک interface{} با فراخوانی تابع TypeOf است که یک مقدار Type را برمی‌گرداند.\nبا فراخوانی تابع ValueOf، یک شیء Value که حاوی دادهٔ زمان اجراست، برمی‌گرداند. تابع Zero یک مقدار Type دریافت کرده و یک شیء Value را که مقدار صفر برای آن نوع است، برمی‌گرداند.\n4.15.1 تعریف reflection و metaprogramming # قبل از شروع آموزش، باید مفاهیم metaprogramming و reflection زمان اجرا را بفهمیم. می‌توانیم کدهای منبع خود را به دو شکل کد و داده در نظر بگیریم.\nاگر کدهای منبع را به عنوان کد در نظر بگیریم، می‌توانیم آن‌ها را روی CPU اجرا کنیم.\nاز طرف دیگر، اگر کدهای منبع را به عنوان داده در نظر بگیریم، می‌توانیم مانند داده‌های معمولی فرآیند برنامه را برای آن‌ها بررسی و به‌روزرسانی کنیم. به عنوان مثال، می‌توانید تمام خصوصیات یک ساختار را بدون داشتن همه خصوصیات آن بدانید.\nmetaprogramming به تکنیکی از برنامه نویسی گفته می‌شود که برنامه را به عنوان داده مورد بررسی قرار می‌دهد. تکنیک‌های metaprogramming می‌توانند برنامه‌های دیگر را بررسی و پردازش کنند، یا حتی در حین اجرای برنامه به خود برنامه دسترسی داشته باشند.\nreflection زمان اجرا زیر مجموعه‌ای از الگوی metaprogramming است. تقریباً تمام زبان‌های محبوب، API داخلی را برای مدیریت metaprogramming برای زبان برنامه‌نویسی خود ارائه می‌دهند. این API ها به عنوان امکانات reflection زمان اجرا شناخته می‌شوند و به عنوان قابلیت زبان برنامه‌نویسی خاصی برای بررسی، تغییر و اجرای ساختار کد عمل می‌کنند.\nبنابراین، ما می‌توانیم کارهایی مانند:\nبررسی خصوصیات یک ساختار بررسی وجود یک تابع در یک نمونه ساختار بررسی نوع اتمی یک متغیر ناشناخته با API های reflection زمان اجرا را انجام دهیم. حال به بررسی بیشتر اینکه این چگونه در زبان برنامه نویسی Go کار می‌کند، می‌پردازیم.\n4.15.2 کاربردهای reflection # مفهوم reflection به طور معمول یک API اصلی را برای بررسی یا تغییر برنامه فعلی ارائه می‌دهد. ممکن است فکر کنید که در مورد کد منبع برنامه خود آگاه هستید، پس چرا نیاز به بررسی کد نوشته شده خود با استفاده از reflection دارید؟ اما reflection دارای موارد کاربرد مفید زیادی است، که در زیر ذکر شده است:\nبرنامه‌نویسان می‌توانند از reflection استفاده کنند تا با کمترین کد، مشکلات برنامه‌نویسی را حل کنند. به عنوان مثال، اگر از یک نمونه ساختاری برای ساخت یک پرس و جوی SQL استفاده می‌کنید، می‌توانید با استفاده از reflection، فیلدهای ساختار را بدون هاردکد کردن نام هر فیلد ساختاری استخراج کنید. با توجه به اینکه reflection یک روش برای بررسی ساختار برنامه ارائه می‌دهد، ممکن است با استفاده از آن، تحلیلگرهای کد استاتیکی ساخته شود. با استفاده از API reflection، ما می‌توانیم کد را به صورت پویا اجرا کنیم. به عنوان مثال، شما می‌توانید متدهای موجود یک ساختار را پیدا کرده و با نام آن‌ها تماس بگیرید. بخش آموزشی زیر همه اصول مورد نیاز برای پیاده‌سازی موارد کاربرد فوق را پوشش خواهد داد. همچنین، به شما نشان خواهم داد که چگونه می‌توانید یک برنامه shell ساده با API reflection بسازید.\nاکنون که مفهوم reflection را پوشش دادیم، با مثال‌های عملی شروع کنیم.\nپکیج reflection Go به ما reflect در زمان اجرا را ارائه می‌دهد، لذا این مثال‌ها ساختار برنامه را در طول زمان اجرا بررسی یا تغییر می‌دهند. با توجه به اینکه Go یک زبان کامپایل شده با نوع استاتیک است، API reflection آن بر اساس دو عنصر کلیدی، نوع reflection و مقدار reflection، ساخته شده است.\n5.15.3 بررسی تایپ های متغیرها # در ابتدا، می‌توانیم با پکیج reflect، از بررسی نوع متغیرها برای شروع استفاده کنیم. کد زیر را ببینید که نوع چندین متغیر را چاپ می‌کند.\npackage main import ( \"fmt\" \"reflect\" ) func main() { x := 10 name := \"Go Lang\" type Book struct { name string author string } sampleBook := Book{\"Reflection in Go\", \"John\"} fmt.Println(reflect.TypeOf(x)) // int fmt.Println(reflect.TypeOf(name)) // string fmt.Println(reflect.TypeOf(sampleBook)) // main.Book } ▶ اجرای کد کپی ✖ بستن خروجی کد بالا نوع داده‌های متغیرها را با استفاده از تابع reflect.TypeOf چاپ می‌کند. تابع TypeOf یک نمونه reflection Type بازگردانده می‌کند که توابعی برای دسترسی به اطلاعات بیشتر درباره نوع فعلی فراهم می‌کند. برای مثال، می‌توانیم از تابع Kind برای بدست آوردن نوع ابتدایی یک متغیر استفاده کنیم. به خاطر داشته باشید که کد بالا نوع داده ساختار اختصاصی main.Book برای متغیر sampleBook را نشان می‌دهد - نه نوع ساختار ابتدایی.\nبرای بدست آوردن نوع ابتدایی، کد بالا را به صورت زیر تغییر دهید:\npackage main import ( \"fmt\" \"reflect\" ) func main() { var ( str = \"Hello, world!\" num = 42 flt = 3.14 boo = true slice = []int{1, 2, 3} mymap = map[string]int{\"foo\": 1, \"bar\": 2} structure = struct{ Name string }{Name: \"John Doe\"} interface1 interface{} = \"hello\" interface2 interface{} = \u0026structure ) fmt.Println(reflect.TypeOf(str).Kind()) fmt.Println(reflect.TypeOf(num).Kind()) fmt.Println(reflect.TypeOf(flt).Kind()) fmt.Println(reflect.TypeOf(boo).Kind()) fmt.Println(reflect.TypeOf(slice).Kind()) fmt.Println(reflect.TypeOf(mymap).Kind()) fmt.Println(reflect.TypeOf(structure).Kind()) fmt.Println(reflect.TypeOf(interface1).Kind()) fmt.Println(reflect.TypeOf(interface2).Kind()) } ▶ اجرای کد کپی ✖ بستن خروجی دلیلی که در کد بالا برای سومین دستور چاپ، struct چاپ می‌شود، این است که تابع Kind reflection Type یک reflection Kind بازگردانده که اطلاعات نوع اولیه را نگه می‌دارد. در این حالت، reflection Kind نوع اولیه ساختار است.\n5.15.3.1 اندازه تایپ های مقداردهی شده # همچنین می‌توانیم از تابع Size reflection Type استفاده کنیم تا تعداد بایت‌های مورد نیاز برای ذخیره نوع فعلی را بدست آوریم. کد زیر را ببینید:\npackage main import ( \"fmt\" \"reflect\" ) func main() { var ( str = \"Hello, world!\" num = 42 flt = 3.14 boo = true slice = []int{1, 2, 3} mymap = map[string]int{\"foo\": 1, \"bar\": 2} structure = struct{ Name string }{Name: \"John Doe\"} ) fmt.Printf(\"Size of str: %d\\n\", reflect.TypeOf(str).Size()) fmt.Printf(\"Size of num: %d\\n\", reflect.TypeOf(num).Size()) fmt.Printf(\"Size of flt: %d\\n\", reflect.TypeOf(flt).Size()) fmt.Printf(\"Size of boo: %d\\n\", reflect.TypeOf(boo).Size()) fmt.Printf(\"Size of slice: %d\\n\", reflect.TypeOf(slice).Size()) fmt.Printf(\"Size of mymap: %d\\n\", reflect.TypeOf(mymap).Size()) fmt.Printf(\"Size of structure: %d\\n\", reflect.TypeOf(structure).Size()) } ▶ اجرای کد کپی ✖ بستن خروجی این کد، با استفاده از تابع Size reflection Type، تعداد بایت‌های مورد نیاز برای ذخیره هر نوع را چاپ می‌کند. با اجرای این کد، خروجی زیر را خواهید داشت:\n$ go run main.go Size of str: 16 Size of num: 8 Size of flt: 8 Size of boo: 1 Size of slice: 24 Size of mymap: 8 Size of structure: 0 در این کد، تعداد بایت‌های مورد نیاز برای نوع string 16 بایت، برای نوع int 8 بایت، برای نوع float64 8 بایت، برای نوع bool 1 بایت، برای نوع slice 24 بایت و برای نوع map 8 بایت است. برای نوع ساختاری structure بایتی نیاز نیست و برابر با صفر است.\n5.15.4 بررسی مقدار یک متغیر # قبلاً، اطلاعات نوع داده‌ها را بررسی کردیم. همچنین با استفاده از پکیج reflect، می‌توانیم مقادیر متغیرها را استخراج کنیم. کد زیر، مقادیر متغیرها را با استفاده از تابع reflect.ValueOf چاپ می‌کند:\npackage main import ( \"fmt\" \"reflect\" ) func main() { var ( str = \"Hello, world!\" num = 42 flt = 3.14 boo = true slice = []int{1, 2, 3} mymap = map[string]int{\"foo\": 1, \"bar\": 2} structure = struct{ Name string }{Name: \"John Doe\"} ) fmt.Printf(\"Value of str: %v\\n\", reflect.ValueOf(str)) fmt.Printf(\"Value of num: %v\\n\", reflect.ValueOf(num)) fmt.Printf(\"Value of flt: %v\\n\", reflect.ValueOf(flt)) fmt.Printf(\"Value of boo: %v\\n\", reflect.ValueOf(boo)) fmt.Printf(\"Value of slice: %v\\n\", reflect.ValueOf(slice)) fmt.Printf(\"Value of mymap: %v\\n\", reflect.ValueOf(mymap)) fmt.Printf(\"Value of structure: %v\\n\", reflect.ValueOf(structure)) } ▶ اجرای کد کپی ✖ بستن خروجی این کد، با استفاده از تابع reflect.ValueOf، مقادیر متغیرها را چاپ می‌کند. با اجرای این کد، خروجی زیر را خواهید داشت:\n$ go run main.go Value of str: Hello, world! Value of num: 42 Value of flt: 3.14 Value of boo: true Value of slice: [1 2 3] Value of mymap: map[bar:2 foo:1] Value of structure: {John Doe} در این کد، مقادیر متغیرها با استفاده از تابع reflect.ValueOf چاپ می‌شوند. به خاطر داشته باشید که تابع ValueOf یک نمونه reflection Value بازگردانده می‌کند، که اطلاعات مربوط به مقدار و نوع متغیر را نگه‌داری می‌کند. برای چاپ مقدار واقعی، باید از توابع مربوط به reflection Value استفاده کنیم.\n5.15.5 تغییر مقدار یک متغیر # قبلاً، ساختار کد را با استفاده از چندین تابع در پکیج reflect بررسی کردیم. همچنین با استفاده از API بازتاب Go، امکان تغییر کد در حین اجرا وجود دارد. در کد زیر، نحوه به‌روزرسانی یک فیلد رشته‌ای در یک ساختار را مشاهده می‌کنید:\npackage main import ( \"fmt\" \"reflect\" ) type Person struct { Name string Age int } func main() { p := Person{Name: \"John\", Age: 30} fmt.Println(\"Before update:\", p) v := reflect.ValueOf(\u0026p) if v.Kind() == reflect.Ptr { v = v.Elem() } f := v.FieldByName(\"Name\") if f.IsValid() \u0026\u0026 f.CanSet() { f.SetString(\"Jane\") } fmt.Println(\"After update:\", p) } ▶ اجرای کد کپی ✖ بستن خروجی در این کد، یک ساختار به نام Person تعریف شده است که دو فیلد Name و Age دارد. در تابع main، یک نمونه از ساختار Person با مقدار پیش‌فرض Name: \u0026ldquo;John\u0026rdquo; و Age: 30 ایجاد شده است. سپس با استفاده از تابع reflect.ValueOf، نمونه ساختار Person به یک reflection Value تبدیل شده و با استفاده از تابع Kind، نوع آن بررسی می‌شود. اگر نوع نمونه یک اشاره‌گر باشد، با استفاده از تابع Elem، به مقدار اشاره شده تبدیل می‌شود.\nدر ادامه، با استفاده از تابع FieldByName، فیلد Name در نمونه ساختار Person بدست آورده می‌شود. سپس با استفاده از تابع IsValid بررسی می‌شود که آیا فیلد موجود است یا خیر. در صورت وجود، با استفاده از تابع CanSet بررسی می‌شود که آیا می‌توان آن را تغییر داد یا خیر. در صورت امکان تغییر، با استفاده از تابع SetString، مقدار فیلد Name به \u0026ldquo;Jane\u0026rdquo; تغییر می‌یابد.\nدر نهایت، با چاپ دوباره مقدار نمونه ساختار Person، تغییر در فیلد Name را مشاهده می‌کنیم. با اجرای این کد، خروجی زیر را خواهید داشت:\n$ go run main.go Before update: {John 30} After update: {Jane 30} در این حالت، با استفاده از پکیج reflect، می‌توانیم برنامه را در حین اجرا تغییر داده و به داده‌های موجود در حافظه دسترسی پیدا کنیم.\n5.15.6 بررسی اطلاعات یک struct # بیایید یک کد نمونه برای بررسی همه فیلدهای یک ساختار بنویسیم. در طول بررسی، می‌توانیم نام و مقدار هر فیلد ساختار را نمایش دهیم. کد زیر این کار را انجام می‌دهد:\npackage main import ( \"fmt\" \"reflect\" ) type Person struct { Name string Age int Address string } func main() { p := Person{Name: \"John\", Age: 30, Address: \"123 Main St.\"} v := reflect.ValueOf(p) if v.Kind() == reflect.Ptr { v = v.Elem() } for i := 0; i \u003c v.NumField(); i++ { field := v.Field(i) fmt.Printf(\"Field %d: %s = %v\\n\", i, v.Type().Field(i).Name, field.Interface()) } } ▶ اجرای کد کپی ✖ بستن خروجی در این کد، یک ساختار به نام Person تعریف شده است که دارای سه فیلد Name، Age و Address است. در تابع main، یک نمونه از ساختار Person با مقدار پیش‌فرض Name: \u0026ldquo;John\u0026rdquo;، Age: 30 و Address: \u0026ldquo;123 Main St.\u0026rdquo; ایجاد شده است.\nسپس با استفاده از تابع reflect.ValueOf، نمونه ساختار Person به یک reflection Value تبدیل شده و با استفاده از تابع Kind، نوع آن بررسی می‌شود. اگر نوع نمونه یک اشاره‌گر باشد، با استفاده از تابع Elem، به مقدار اشاره شده تبدیل می‌شود.\nدر ادامه، با استفاده از تابع NumField، تعداد فیلدهای موجود در نمونه ساختار Person بدست آورده می‌شود. سپس در یک حلقه، با استفاده از تابع Field، مقدار هر فیلد به همراه نام آن چاپ می‌شود. با استفاده از تابع Type، نوع نمونه ساختار Person به دست می‌آید، و با استفاده از تابع Field(i).Name، نام فیلد در ایندکس i بدست می‌آید. در نهایت، با استفاده از تابع Interface، مقدار فیلد به صورت یک interface{} برگردانده می‌شود و چاپ می‌شود.\nبا اجرای این کد، خروجی زیر را خواهید داشت:\n$ go run main.go Field 0: Name = John Field 1: Age = 30 Field 2: Address = 123 Main St. در این حالت، با استفاده از پکیج reflect، می‌توانیم برای هر ساختار، همه فیلدها را بررسی کرده و نام و مقدار هر فیلد را چاپ کنیم.\n5.15.7 بررسی متدها (Methods) # فرض کنید شما یک موتور دستور سفارشی برای یک برنامه شل پیاده‌سازی می‌کنید و برای اجرای توابع Go بر اساس دستورات ورودی کاربر، نیاز دارید دستورات را به توابع مرتبط تخصیص دهید. اگر تعداد توابع کم باشد، می‌توانید از یک switch-case statement استفاده کنید. اما اگر تعداد توابع صد‌ها نفر باشد؟ در این صورت، ما می‌توانیم توابع Go را براساس نام آن‌ها به صورت پویا فراخوانی کنیم. برنامه شل پایه‌ای زیر با استفاده از بازتاب این کار را انجام می‌دهد:\npackage main import ( \"fmt\" \"reflect\" \"bufio\" \"os\" ) type NativeCommandEngine struct{} func (nse NativeCommandEngine) Method1() { fmt.Println(\"INFO: Method1 executed!\") } func (nse NativeCommandEngine) Method2() { fmt.Println(\"INFO: Method2 executed!\") } func (nse NativeCommandEngine) callMethodByName(methodName string) { method := reflect.ValueOf(nse).MethodByName(methodName) if !method.IsValid() { fmt.Println(\"ERROR: \\\"\" + methodName + \"\\\" is not implemented\") return } method.Call(nil) } func (nse NativeCommandEngine) ShowCommands() { val := reflect.TypeOf(nse) for i := 0; i \u003c val.NumMethod(); i++ { fmt.Println(val.Method(i).Name) } } func main() { nse := NativeCommandEngine{} fmt.Println(\"A simple Shell v1.0.0\") fmt.Println(\"Supported commands:\") nse.ShowCommands() scanner := bufio.NewScanner(os.Stdin) fmt.Print(\"$ \") for scanner.Scan() { nse.callMethodByName(scanner.Text()) fmt.Print(\"$ \") } } ▶ اجرای کد کپی ✖ بستن خروجی برنامه شلی که پیشتر نوشتیم، ابتدا تمام دستورات پشتیبانی شده را نشان می‌دهد. سپس کاربر می‌تواند دستورات را به دلخواه خود وارد کند. هر دستور شل یک متد متناظر دارد، و اگر یک متد خاص وجود نداشته باشد، شل پیام خطا چاپ می‌کند.\n5.15.8 نوشتن custom tag برای فیلد های ساختار # تگ سفارشی مانند json:\u0026quot;name\u0026quot; در گو، برای اتصال متاداده به فیلدهای یک ساختار استفاده می‌شود. بسته reflect در گو، یک راه برای دسترسی به این تگ‌ها در زمان اجرا فراهم می‌کند. برای ایجاد یک تگ سفارشی در گو، می‌توان از بسته reflect برای دسترسی به تگ‌ها بر روی یک فیلد ساختار استفاده کرد.\nدر ادامه مثالی از چگونگی ایجاد یک تگ سفارشی با بسته reflect در گو آورده شده است:\npackage main import ( \"fmt\" \"reflect\" ) type Person struct { Name string `customtag:\"myname\"` Age int `customtag:\"myage\"` } func main() { p := Person{\"John\", 30} t := reflect.TypeOf(p) v := reflect.ValueOf(p) for i := 0; i \u003c t.NumField(); i++ { field := t.Field(i) value := v.Field(i) tag := field.Tag.Get(\"customtag\") fmt.Printf(\"Field: %s, Value: %v, Tag: %s\\n\", field.Name, value.Interface(), tag) } } ▶ اجرای کد کپی ✖ بستن خروجی در این مثال، یک ساختار Person با دو فیلد Name و Age تعریف شده است. هر یک از این فیلدها با استفاده از کلید customtag یک تگ سفارشی دارند.\nبرای دسترسی به تگ‌ها در زمان اجرا، از بسته reflect استفاده می‌شود. با استفاده از reflect.TypeOf و reflect.ValueOf نوع و مقدار ساختار Person بدست می‌آیند. سپس با استفاده از حلقه for و توابع t.NumField() و t.Field(i) بر روی فیلدهای ساختار حرکت می‌کنیم. برای هر فیلد، با استفاده از v.Field(i) مقدار آن را و با استفاده از field.Tag.Get(\u0026quot;customtag\u0026quot;) تگ سفارشی آن را بدست می‌آوریم.\nدر نهایت با استفاده از fmt.Printf نام فیلد، مقدار آن و تگ سفارشی آن را چاپ می‌کنیم. خروجی این برنامه به شکل زیر خواهد بود:\n$ go run main.go Field: Name, Value: John, Tag: myname Field: Age, Value: 30, Tag: myage این نشان می‌دهد که چگونه می‌توان با استفاده از بسته reflect در گو تگ‌های سفارشی را ایجاد کرد.\n"},{"id":58,"href":"/chapter-4/go-generator/","title":"4.16 آموزش generator","section":"فصل چهارم: مباحث پیشرفته","content":"کد generator در گو، یک ابزار است که برای تولید کد خودکار استفاده می‌شود. برای ایجاد یک کد generator در گو، می‌توان از قابلیت‌هایی که در زبان گو موجود است، مانند بسته‌های go/ast و go/parser استفاده کرد.\nبا استفاده از بسته go/ast می‌توانید ساختار داده‌های AST (Abstract Syntax Tree) را برای کد خود بسازید. AST، ساختار درختی از کدهای گو است که به طور معمول برای بررسی و تحلیل کد استفاده می‌شود.\nبا استفاده از بسته go/parser می‌توانید کد منبع گو را به عنوان ورودی بگیرید و برای آن AST بسازید.\nبا استفاده از این دو بسته، می‌توانید یک کد generator بسازید که برای تولید کد خودکار، کد منبع گو را تحلیل کرده و براساس آن، کد جدیدی را ایجاد کند. برای مثال، می‌توانید یک کد generator بسازید که برای تولید کد تست، کد منبع گو را تحلیل کرده و برای هر تابع یا متد، تست مربوطه را بسازد.\nبا توجه به این که کد generator‌ها برای تولید کد خودکار استفاده می‌شوند، باید دقت شود که کد تولید شده باید قابل خواندن و تصحیح باشد. همچنین، باید از بهبود کیفیت کد تولید شده نیز اطمینان حاصل شود.\nدر کل، با استفاده از بسته‌های go/ast و go/parser می‌توانید یک کد generator قدرتمند در گو بسازید که برای تولید کد خودکار بسیار مفید است.\nاین بخش ادامه دارد\u0026hellip;\n"},{"id":59,"href":"/chapter-4/go-stringer/","title":"4.17 آموزش stringer","section":"فصل چهارم: مباحث پیشرفته","content":"Stringer به طور کلی برای پیاده‌سازی مفهوم شمارشی (enumeration) استفاده می‌شود در حالی که از برنامه‌نویسی ثابت رشته‌های مقدار استفاده نمی‌کند. شمارشی یا enum زمانی استفاده می‌شود که می‌خواهید مجموعه‌ای متناهی و ثابتی از مقادیر یک نوع داده‌ای را تعریف کنید. به عنوان مثال، انواع غذا در منو (پیش غذا، اصلی، دسر)، انواع پوکمون (گیاهی، آبی، آتشی، و غیره).\nبنابراین، زمانی که می‌خواهیم از این مجموعه‌های تعریف شده استفاده کنیم، باید از برنامه‌نویسی ثابت رشته‌های مقدار استفاده کنیم زیرا ممکن است به خطاهای انسانی مانند اشتباهات املایی منجر شود. اگر از Stringer استفاده کنیم، مقادیر را یکبار تولید می‌کنیم و مطمئن می‌شویم که هیچ خطایی ایجاد نمی‌شود. پس از آن، می‌توانیم از آن‌ها بدون نگرانی از خطاهای انسانی استفاده کنیم.\n4.17.1 پیاده سازی متد String برای آبجکت ها # شما می توانید برای هر یک از آبجکت ها متد String را پیاده سازی کنید و یک خروجی استرینگ در خصوص مقادیر آبجکت داشته باشید.\nبه مثال کاربردی زیر توجه کنید:\npackage main import \"fmt\" type Age int const ( CHILDERN Age = iota ADOLESCENTS ADULTS ) func (a Age) String() string { switch a { case CHILDERN: return \"childern\" case ADOLESCENTS: return \"adolescents\" case ADULTS: return \"adults\" default: return \"\" } } func main() { fmt.Println(CHILDERN.String()) } ▶ اجرای کد کپی ✖ بستن خروجی در مثال فوق ما یک تایپ Age تعریف کردیم و سپس یکسری enum با همان تایپ قرار دادیم پس از آن متد String را پیاده سازی کردیم که بتوانیم رشته هرکدام از enum ها را بگیریم.\n4.17.2 استفاده از ابزار stringer # شما با استفاده از ابزار stringer می توانید به راحتی برای enum های خود رشته را بصورت خودکار ایجاد کنید.\nبرای نصب این ابزار در ابتدا باید دستور زیر را بزنید تا داخل go bin نصب شود:\n$ go install golang.org/x/tools/cmd/stringer@latest اکنون بخواهیم با استفاده از ابزار stringer متد استرینگ جنریت کنیم کافیه مثال زیر توجه کنید:\npackage main import \"fmt\" //go:generate stringer -type=Age type Age int const ( CHILDERN Age = iota ADOLESCENTS ADULTS ) func main() { fmt.Println(CHILDERN.String()) } ▶ اجرای کد کپی ✖ بستن خروجی در کد فوق ما یک directive comment اضافه کردیم حال کافیه با استفاده از دستور go generate متد استرینگ تایپ را جنریت کنیم.\ngo generate ./... "},{"id":60,"href":"/chapter-4/effective-go/","title":"4.18 تکنیک های کدنویسی زبان گو","section":"فصل چهارم: مباحث پیشرفته","content":"در این بخش به موارد زیر می پردازیم.\nکارآمدی (effective) استایل اوبر تکنیک ها نکات فنی بهینه سازی 4.18.1 کارآمدی (Effective) # در زیر به کارآمدی زبان گو می پردازیم.\n4.18.1.1 نام پکیج ها # زمانیکه شما یک پکیج را ایمپورت میکنید نام پکیج در بالای بدنه فایل گو قرار میگیرد مانند :\nimport \u0026quot;bytes\u0026quot; حال وقتی که پکیج ایمپورت می شود و نام اش در بالای بدنه فایل کد شما قرار میگیرد می توانید در ادامه نام پکیج توابع, تایپ ها و یا متغیر و const ها را مانند bytes.Buffer فراخوانی کنید.\nانتخاب یک نام خوب برای پکیج خیلی قابل اهمیت است و شما برای انتخاب یک نام خوب بهتر است موارد زیر را رعایت کنید :\nنام کوتاه باشد. مختصر باشد. نام پکیج طوری باشد که به آسانی بتوان بهش دسترسی داشت نام پکیج باشد تماما حروف کوچک باشد. تک کلمه ای باشد. 4.18.1.2 پیاده سازی Getter/Setter # در زبان گو هیچ Getter یا Setter خودکاری وجود ندارد. به همین منظور شما باید Getter/Setter را در قالب متد یک آبجکت پیاده سازی کنید.\nowner := obj.GetOwner() if owner != user { obj.SetOwner(user) } 4.18.1.3 نام اینترفیس # نام اینترفیس یک حالت قراردادی دارد که بهتر است این حالت قرار دادی را رعایت کنید. نام اینترفیس با مشخصه یک رفتار کلی باشد که برپایه متدهای اینترفیس تعیین می شود و در نهایت در انتهای نام اینترفیس دو حرف er اضافه می شود. مانند : Reader , Writer, Formmater\ntype Writer interface { Write([]byte) error } 4.18.1.4 نوع نام گذاری متغیر, تابع, تایپ و \u0026hellip; # در زبان گو نام گذاری حالت قراردادی دارد که کامپایلر نسبت به نوع نام گذاری شما رفتار نشان می دهد. بطوری که شما می توانید نام ها را بصورت MixedCaps یا mixedCaps بنویسید که این حالت نام گذاری را camleCase و PascalCase می گویند.\nزمانیکه شما نام را بصورت PascalCase می نویسید در واقع حالت شما آن متغیر, تابع, تایپ و \u0026hellip; را بصورت Public در نظر گرفتید. اگر شما نام را بصورت camleCase بنویسید در واقع شما متغیر, تابع, تایپ و \u0026hellip; را بصورت Private در نظر گرفتید وفقط در پکیج لول شما در دسترس می باشد. 4.18.1.5 نقطه ویرگول (Semicolons) # مانند C، گرامر رسمی Go از نقطه ویرگول برای پایان دادن به عبارات استفاده می کند، اما برخلاف C، این نقطه ویرگول ها در منبع ظاهر نمی شوند. در عوض، lexer از یک قانون ساده برای درج خودکار نقطه ویرگول ها در حین اسکن استفاده می کند، بنابراین متن ورودی عمدتاً فاقد آنها است.\n4.18.1.6 ساختارهای کنترلی if, for, switch # در زبان گو همانند سایر زبان ها ساختارهای کنترلی نظیر if, for, switch داریم که در زیر می توانید با حالت های کارآمد استفاده از این کنترل ها آن ها آشنا شوید.\nif\nدر زبان گو حالت ساده شرط به شکل زیر است :\nif x \u0026gt; 0 { return y } حال اگر شما یک تابعی داشته باشید که یک مقدار مانند خطا برگرداند می توانید داخل عبارت شرط یک متغییر راه اندازی کنید و تابع را داخلش قرار دهید سپس با قرار دادن نقطه ویرگول شرط را بررسی کرده.\nif err := file.Chmod(0664); err != nil { log.Print(err) return err } اما اگر تابع شما ۲ تا خروجی داشته باشد بهتر است داخل دو متغییر خروجی را بگیرید و در خط بعدی شرط را جهت بررسی هریک از متغیرها قرار دهید:\nf, err := os.Open(name) if err != nil { return err } codeUsing(f) 4.18.2 استایل اوبر (Uber) # در زیر استایل کدنویسی که تیم مهندسی شرکت اوبر تهیه کردند می پردازیم.\n4.18.3 تکنیک ها # در زیر به تکنیک های زبان گو می پردازیم.\n4.18.4 نکات فنی # در زیر چندین نکات فنی قرار دادم که کاربردی می باشد.\n4.18.4.1 مقدار صفر تایپ ها و مقادیر # همانطور در فصل های قبل اشاره کردیم تایپ ساختار (struct) بدون فیلد مقدارش در حافظه کاملا صفر است. اندازه تایپ آرایه بدون هیچ المنتی صفر است. حال در زیر یک مثال میزنیم تا ببینید:\npackage main import \"unsafe\" type A [0][256]int type S struct { x A y [1 \u003c\u003c 30]A z [1 \u003c\u003c 30]struct{} } type T [1 \u003c\u003c 30]S func main() { var a A var s S var t T println(unsafe.Sizeof(a)) // 0 println(unsafe.Sizeof(s)) // 0 println(unsafe.Sizeof(t)) // 0 } ▶ اجرای کد کپی ✖ بستن خروجی در Go، اندازه ها اغلب به عنوان مقادیر int نشان داده می شوند. این به این معنی است که بزرگترین طول ممکن یک آرایه MaxInt است که مقدار آن در سیستم عامل های 64 بیتی 2^63-1 است. با این حال، طول آرایه با اندازه عناصر غیر صفر به سختی توسط کامپایلر استاندارد رسمی Go و زمان اجرا محدود می شود.\nvar x [1\u0026lt;\u0026lt;63 - 1]struct{} // okay var y [2000000000 + 1]byte // compilation error var z = make([]byte, 1\u0026lt;\u0026lt;49) // panic: runtime error: makeslice: len out of range 4.18.4.2 نحوه تخصیص مقادیر اندازه صفر به کامپایلر بستگی دارد # در اجرای استاندارد رسمی فعلی کامپایلر Go (نسخه 1.20)، همه مقادیر محلی صفر تخصیص داده شده روی heap و آدرس یکسانی دارند. به عنوان مثال، موارد زیر دو بار false را چاپ می کنند، سپس دو بار true را چاپ می کنند.\npackage main var g *[0]int var a, b [0]int //go:noinline func f() *[0]int { return new([0]int) } func main() { // x and y are allocated on stack. var x, y, z, w [0]int // Make z and w escape to heap. g = \u0026z g = \u0026w println(\u0026b == \u0026a) // false println(\u0026x == \u0026y) // false println(\u0026z == \u0026w) // true println(\u0026z == f()) // true } ▶ اجرای کد کپی ✖ بستن خروجی لطفا توجه داشته باشید که خروجی های برنامه فوق به کامپایلرهای خاصی بستگی دارد. خروجی ها ممکن است برای نسخه های کامپایلر استاندارد رسمی Go در آینده متفاوت باشند. 4.18.4.3 فیلد با اندازه صفر را به عنوان فیلد نهایی یک نوع ساختار قرار ندهید # در کد زیر اندازه تایپ Tz از تایپ Ty بزرگتر است.\npackage main import \"unsafe\" type Ty struct { _ [0]func() y int64 } type Tz struct { z int64 _ [0]func() } func main() { var y Ty var z Tz println(unsafe.Sizeof(y)) // 8 println(unsafe.Sizeof(z)) // 16 } ▶ اجرای کد کپی ✖ بستن خروجی چرا اندازه نوع Tz بیشتر است؟\nدر پیاده‌سازی runtime Go استاندارد کنونی، تا زمانی که یک بلوک حافظه توسط حداقل یک اشاره‌گر زنده مشارکت شود، آن بلوک حافظه به عنوان زباله در نظر گرفته نمی‌شود و جمع‌آوری نمی‌شود. همه فیلدهای یک مقدار ساختار قابل دسترسی می‌توانند آدرس‌گرفته شوند. اگر اندازه فیلد نهایی در یک مقدار ساختار با اندازه غیر صفر صفر باشد، آنگاه گرفتن آدرس فیلد نهایی در مقدار ساختاری، آدرسی را که خارج از بلوک حافظه اختصاص داده شده برای مقدار ساختاری است باز خواهد گرداند. آدرس بازگردانده شده ممکن است به بلوک حافظه دیگری که به طور نزدیکی پس از بلوک حافظه اختصاص داده شده برای مقدار ساختاری با اندازه غیر صفر قرار دارد، اشاره کند. تا زمانی که آدرس بازگردانده شده در یک مقدار اشاره‌گر زنده ذخیره شود، بلوک حافظه دیگری که به جمع‌آوری زباله می‌روید جمع‌آوری نخواهد شد که ممکن است باعث نشت حافظه شود. برای جلوگیری از این نوع مشکلات نشت حافظه، کامپایلر Go استاندارد تضمین می‌کند که دریافت آدرس فیلد نهایی در یک ساختار با اندازه غیر صفر هرگز آدرسی را که خارج از بلوک حافظه اختصاص داده شده برای ساختار نیست را بازنخواهد گرداند. کامپایلر Go استاندارد این کار را با وارد کردن برخی بایت‌ها پس از فیلد صفر آخرین انجام می‌دهد. بنابراین، حداقل یک بایت پس از فیلد نهایی (صفر) نوع Tz وجود دارد. به همین دلیل اندازه نوع Tz بزرگتر از Ty است. در واقع، در سیستم عامل‌های ۶۴ بیتی، ۸ بایت پس از فیلد نهایی (صفر) Tz وجود دارد. برای توضیح این موضوع، باید دو حقیقت را در پیاده‌سازی کامپایلر استاندارد رسمی بدانیم:\nتضمین ترازبندی یک نوع ساختاری، بزرگترین تضمین ترازبندی فیلدهای آن است. اندازه یک نوع همیشه یک ضریبی از تضمین ترازبندی آن است. حقیقت اول، علت برابری تضمین ترازبندی نوع Tz با ۸ (که تضمین ترازبندی نوع int64 است) را توضیح می‌دهد. حقیقت دوم، علت برابری اندازه نوع Tz با ۱۶ را توضیح می‌دهد. منبع : https://github.com/golang/go/issues/9401\n4.18.5 بهینه سازی # در زیر به بهینه سازی در زبان گو می پردازیم.\n"},{"id":61,"href":"/chapter-4/go-commentry/","title":"4.19 اصول کامنت نویسی","section":"فصل چهارم: مباحث پیشرفته","content":"اصول کامنت‌نویسی در زبان گو\n4.19.1 تعریف # «کامنت» به توضیحات‌ی گفته می‌شود که داخل کد، به‌قصد «یادآوری»، «جلب‌توجه مخاطب به موضوع‌(ها)ی خاص»، کمک به onboard شدن اعضاء جدید تیم و مانند اون نگارش می‌شود. در زبان گو، به شیوه‌های زیر کامنت می‌گذاریم:\nقرار دادن // در ابتدای سطر.\n// defined to store multi string (see below why this is not a good comment) var sliceVar []string قراردادن متن کامنت داخل یک بلوک که با */ شروع می‌شود و /* تمام می‌شود.\nfor index, row := range sliceVar { row /* for loop lifetime */ = \u0026quot;new_val\u0026quot; sliceVar[index] /* apply to sliceVar out of loop */ = \u0026quot;new_val\u0026quot; fmt.Println(row) // hint to sliceVar large len } دستور ‍gofmt کامنت‌ها را مانند سایر فرمت‌ها، مرتب می‌نماید. اما روش بهتر درصورت امکان، نظم آنها توسط خود توسعه‌دهنده جهت رعایت الگوها و ساختار خاص هر پروژه است.\ngofmt -w main.go 4.19.2 دیدگاه‌ها درباره «کامنت» # با توجه به این موضوع که در جوامع‌تخصصی توسعه نرم‌افزار، درارتباط با اصل وجود کامنت، مزایا/معایب و چگونگی استفاده از آن، مطالب گوناگون و بعضاً متضادی، حتی از جانب متخصصین، وجود دارد، در این قسمت سعی خواهیم کرد، تاجای‌ممکن پاسخ حساب‌شده‌ای به نیازمندی‌های مختلف در ارتباط با «کامنت‌گذاری» بدهیم.\n4.19.3 کامنت؛ خوب، بد، زشت # در کدهایی که بارها نسخه‌های متفاوتی از آن ایجاد شده و در طول زمان، نیازمندی‌ها عوض شده، کیفیت، کارایی و سرعت اجرا بهبود پیدا کرده، «کامنت» گزارش «چرایی» کد هست برای این: نیاز/کیفیت/کارایی/سرعت اجرا، برای اینکه همه این‌ها رو دوباره تجربه نکنند ... یک کد خوب، هیچ نیازی به کامنت ندارد، به‌زبان‌دیگر، اگر نیاز می‌بینید که برای کدی «کامنت» بنویسید، احتمالاً، کد خوبی ننوشتید ... یک ساختار جدید، ناشناخته و احتمالاً حجیم، به‌قدر‌کافی ماهیتاً اینقدر پیچیدگی دارد که اضافه شدن، یک توضیح به زبان کاملاً انسانی (داخل زبان کامپایلر/مفسری برای زبان ماشین)، نه‌تنها باعث روشن‌تر شدن آن نمی‌شود بلکه مسئله‌ی فهم منظور نگارنده «کامنت» به مجموعه مسائل قبلی اضافه می‌گردد. هیچ‌چیز بیشتر از یک کد پیچیده با کلی «کامنت‌های» پیچیده برای مخاطبی که انتظار روشن بودن چرایی و چگونگی کد را دارد، عذاب‌آور نیست ... همه این‌ها پاسخ‌های متفاوت‌ی است که توسعه‌دهندگان به موضوع «کامنت» می‌دهند. اما «اصولاً» کامنت پرفایده است یا بی‌فایده؟\n4.19.4 آنالیز محصول و محیط توسعه # وقتی در ارتباط با کامنت صحبت می‌کنیم این خیلی مهم است که ما به‌تنهایی مشغول توسعه یک محصول هستیم یا در یک دپارتمان کوچک یا در یک ابَرپروژه \u0026hellip; آیا ما مجبور به تبعیت از یک‌سری دستورالعمل‌های کدنویسی هستیم یا می‌توانیم سلیقه‌شخصی خود را داشته باشیم؟ \u0026hellip;\nشرایط تیم توسعه. نحوه مدیریت(افراد/روش‌ها) پروژه در فرآیند توسعه کد. تعداد زیرمجموعه‌ها و تعداد توسعه‌دهندگان در بخش‌های مختلف. میزان ارتباط و حساسیت کدها بین واحدها و توسعه‌دهندگان. سرعت تغییرات جابجایی توسعه‌دهندگان در پروژه. و موارد مشابه دیگر. تحلیل نیازمندی‌های محصول. مقیاس پروژه. زمان توسعه پروژه. زمان تغییرات همزمان با نسخه‌های ریلیز شده. پیچیدگی و ماهیت نیازهای محصول. و موارد مانند این‌ها. نتیجه اینکه: ابتدا نیازمندی، توانایی و شرایط تیم/محصول را مشخص کنیم، و بعد تصمیم به چرایی و چگونگی کامنت‌نویسی اصولی بگیریم. 4.19.5 انواع کامنت # کامنت فایل/پکیج (Doc Comment) این‌نوع کامنت‌ها درباره «چیستی» کل فایل یا پکیج توضیح دارد.\n// Copyright 2011 The Go Authors. All rights reserved. // Use of this source code is governed by a BSD-style // license that can be found in the LICENSE file. /* Package builtin provides documentation for Go's predeclared identifiers. The items documented here are not actually in package builtin but their descriptions here allow godoc to present documentation for the language's special identifiers. */ package builtin مثال بالا از پکیج builtin درباره حق‌چاپ / تعریف اولیه پکیج و اینکه مستندات در godoc ارائه می‌شود، توضیح داده است.\nکامنت داخلی فانکشن/متد/بلوک/تایپ/متغیر/دستور و مانند آن (Ordinary Comments) این‌نوع کامنت درباره «چرایی» آن قسمتِ خاص اشاره دارد. // The delete built-in function deletes the element with the specified key // (m[key]) from the map. If m is nil or there is no such element, delete // is a no-op. func delete(m map[Type]Type1, key Type) در مثال بالا، توسط کامنت توضیح داده شده که وظیفه فانکشن-داخلی delete حذف المنت با کلید مشخص هست، و توضیح دقیق‌تر اینکه اگر المنت مربوط به کلید nil باشد یا وجود نداشته باشد، فانکشن delete هیچ عملیاتی انجام نمی‌دهد. (مثلاً خطا باز نمی‌گرداند − گزارش نمی‌کند و \u0026hellip;)\n4.19.6 اصول کامنت‌نویسی # یک کامنت خوب:\nتوضیح واضحات را نمی‌دهد. در حداقل مقدار «لازم» و «کافی» نگارش می‌شود. بیشتر درباره «چیستی/چرایی» اشاره دارد و نه «چگونگی». دارای یک الگو و دستورالعمل نگارشی واحد برای نظم و سرعت ارتباط مخاطب است. وجودش آگاه‌کننده موضوع بااهمیت بالاست. مربوط به موضوعی است که اکنون وجود دارد (بروزرسانی کامنت‌ها-حذف کامنت‌های اضافی) ادبیات کامنت، بسته به تیم و دستورالعمل‌ها، بهتر است رسمی نگارش شود تا عمومی بماند. البته گاهی کمی شوخ‌طبعی هم اگر کنترل‌شده باشد، باعث انتقال‌مطلب بهتر می‌شود. درصورت لازم بودن یک یا چند منبع مرتبط با کد، حاوی لینک url خواهد بود. // flip the buffer for this connection if we need to drain it. // note that for a successful query (i.e. one where rows.next() // has been called until it returns false), `rows.mc` will be nil // by the time the user calls `(*Rows).Close`, so we won't reach this // see: https://github.com/golang/go/commit/651ddbdb5056ded455f47f9c494c67b389622a47 mc.buf.flip() 4.19.7 به پرتگاه نزدیک می‌شوید! # زامبی کد: به کدی می‌گویند که به دلیل عدم کارایی، اصلاح با کد جدید، و یا مشابه این موارد، بجای «حذف»، «کامنت» می‌شوند. کامنت اسپاگتی کد: به کامنت‌های دنباله‌داری گفته می‌شود که برای توضیح یک کدی که ساختار منظم و مشخصی ندارد، نگارش می‌شود. یکی دیگر از استفاده‌های کامنت، وظیفه‌ی برنامه‌ریزی‌شده می‌باشد که اگر کنترل نشود، یکی دیگر از عذاب‌های عظیم خواهد بود. جای کلمات عبور و مقادیر امنیتی در کامنت نیست. اگر دائماً نیاز می‌بینید که در مراحل مختلف به همکاران بصورت کامنت «هشدار» بنویسید، شاید باید به‌فکر اصلاح معماری نرم‌افزار باشید. کامنت‌های شما، نباید تبدیل به «نویز» درکدنویسی دیگران شود. تعدد کامنت‌ها کد را تبدیل به کد کثیف می‌کند که خوانایی ضعیفی خواهد داشت. کامنت، جای دردل کردن، شکایت از مدیرپروژه، تعریف از خود و گفتگو نیست. 4.19.8 انواع directive comment # //go:generate: این کامنت برای مشخص کردن یک دستور است که باید توسط ابزار go generate اجرا شود. این کامنت معمولاً قبل از یک دستور تولید کد قرار داده می‌شود که به شما اجازه می‌دهد کد Go را به صورت خودکار تولید کنید.\n//go:binary-only-package: این کامنت برای اعلام این استفاده می‌شود که یک بسته باید به عنوان یک بسته فقط دودویی در کامنت گرفته شود، به معنای این است که کد منبع بسته در دسترس نیست. این برای بسته‌هایی استفاده می‌شود که شامل کد‌های محصولی یا بسته‌های مشخص سیستم‌عامل هستند.\n//go:build: این کامنت برایمحدودیت‌های ساخت استفاده می‌شود. این به شما امکان می‌دهد که کنترل کنید که یک فایل باید بر اساس شرایط خاصی مانند سیستم عامل، معماری یا برچسب ساخت، در ساخت شامل شود یا خیر.\n//go:cgo_\u0026hellip;: چندین کامنت دستوری وجود دارد که با cgo_ شروع می‌شوند، مانند //go:cgo_import_dynamic و //go:cgo_export_dynamic. این کامنتات همراه با cgo استفاده می‌شوند، ابزاری که به کد Go اجازه می‌دهد تا به کد C و بالعکس برای فراخوانی دستورات استفاده شود. آن‌ها دستوراتی را به ابزار cgo ارائه می‌دهند که نحوه برخورد کد C را مشخص می‌کنند.\n//go:noinline: این کامنت برای مشخص کردن این استفاده می‌شود که یک تابع توسط کامپایلر به صورت inline نباید درج شود. Inline کردن یک تابع یک تکنیک بهینه‌سازی است که کد یک تابع به طور مستقیم در کد فراخواننده آن قرار می‌گیرد و هزینه فراخوانی تابع را حذف می‌کند. استفاده از این کامنت از کامپایلر جلوگیری می‌کند تا برای تابع مشخص شده inline کردن انجام دهد.\n//go:nosplit: این کامنت برای مشخص کردن این استفاده می‌شود که یک تابع باید توسط برنامه‌ریز Go runtime اجرا شده (split) نشود. این معمولاً برای توابع سطح پایین استفاده می‌شود که نیاز به کنترل دقیق بر روی اجرای آن‌ها دارند و نباید وقفه داده شوند.\n//go:linkname: این کامنت برای برقراری ارتباط بین کد Go و نمادهای خارجی یا کد غیر Go استفاده می‌شود. این به شما اجازه می‌دهد تا به یک نماد با نام متفاوت یا از بسته‌ای دیگر ارجاع دهید.\n//go:noescape: این کامنت برای مشخص کردن این استفاده می‌شود که آرگومان‌های اشاره گر تابع escape نمی‌کنند، به معنایی که در طول عمر تابع ذخیره یاستفاده نمی‌شوند یا استفاده نمی‌شوند. این اطلاعات به کامپایلر اجازه می‌دهند که بهینه‌سازی‌های حافظه تابع را انجام دهد.\n//go:embed: این کامنت برای اضافه کردن فایل‌های استاتیک یا دایرکتوری‌ها به طور مستقیم به باینری Go در زمان کامپایل استفاده می‌شود. این فرآیند از جمله فرآیند بسته‌بندی و توزیع منابع با برنامه‌های Go خود است.\n//go:generate go run: این کامنت یک نوع دیگر از کامنت //go:generate است. این کامنت مشخص می‌کند که دستور زیر کامنت باید توسط اجرای برنامه Go با استفاده از دستور go run اجرا شود.\n//go:build \u0026hellip;: این کامنت یک فرم گسترده‌تر از کامنت build است. این به شما امکان می‌دهد شرایط ساخت را با استفاده از اپراتورهای منطقی بولی، پرانتز و نفی مشخص کنید. این امکانات بیشتری در کنترل کردن فایل‌هایی که در ساخت شامل می‌شوند، فراهم می‌کند.\n//go:protofile: این کامنت برای مشخص کردن پروتوباف فایل مرتبط با یک فایل منبع Go استفاده می‌شود. این معمولاً در کد Go استفاده می‌شود که شامل کد پروتوباف تولید شده است، اجازه می‌دهد که کامپایلر فایل‌های Go و پروتوباف رابه درستی به هم پیوند دهد.\n//go:nowritebarrier: این کامنت برای مشخص کردن این استفاده می‌شود که یک تابع بدون write barrier باید اجرا شود. Write barrier برای تعقیب و به‌روزرسانی اشاره‌گرها در زمان تخصیص و آزادسازی حافظه توسط garbage collector استفاده می‌شود. استفاده از این کامنت ممکن است خطرناک باشد و تنها در موارد خاصی که مدیریت دستی حافظه لازم است، باید استفاده شود.\n//go:norace: این کامنت دستوری برای غیرفعال کردن ردیابی race برای یک تابع خاص است. ردیاب race یک ابزار در Go است که به شناسایی دسترسی همزمان به متغیرهای مشترک که ممکن است منجر به دور زدن داده‌ها (race condition) بشود، کمک می‌کند. این دستور می‌تواند هنگامی استفاده شود که از عدم وجود شرایط race برای یک تابع خاص اطمینان دارید.\n//go:buildignore: این کامنت دستوری برای حذف یک فایل از فرآیند ساخت استفاده می‌شود. این به سیستم ساخت Go می‌گوید که این فایل را نادیده بگیرد و در هنگام کامپایل بسته، شامل نشود.\n//go:generate goimports: این کامنت دستوری برای استفاده در ارتباط با دستور //go:generate استفاده می‌شود تا به صورت خودکار ابزار goimports اجرا شود. goimports به طور خودکار import statements را به روزرسانی و فرمت دهی می‌کند، اطمینان حاصل می‌کند که import های بسته درست هستند و import های بی‌استفاده را حذف می‌کند.\n//go:embed pattern: این کامنت دستوری یک فرم گسترده‌تر از //go:embed است و به شما اجازه می‌دهد الگویی را برای تطبیق با فایل‌ها یا دایرکتوری‌ها برای جاسازی در حالت تعبیه شده مشخص کنید. این امکانات، در انتخاب فایل‌ها یا دایرکتوری‌های خاص بیشتری ارائه می‌دهد.\n//go:nolint: این کامنت دستوری برای سرکوب خطاها و هشدارهای خاص لینتر برای یک خط کد خاص استفاده می‌شود. این اغلب هنگامی استفاده می‌شود که یک قانون لینتر یک false positive را سیگنال می‌دهد یا وقتی دلیل معتبری برای نادیده گرفتن یک مسئله لینتینگ موقتا وجود دارد.\n//go:generate go test: این کامنت دستوری برای استفاده در ارتباط با دستور //go:generate استفاده می‌شود تا به صورت خودکار دستور go test اجرا شود. این دستور معمولاً برای تولید و اجرای کد آزمایشی برای یک بسته استفاده می‌شود.\n//go:uintptrescapes: این کامنت دستوری برای نشان دادن این است که یک مقدار uintptr ممکن است به حافظه heap فرار کند. به طور پیش فرض، کامپایلر فرض می‌کند که مقدارهای uintptr فرار نمی‌کنند، اما استفاده از این دستور اجازه تجزیه و تحلیل فرار دقیق‌تر را می‌دهد.\n//go:build !constraint: این کامنت دستوری برای حذف یک فایل از فرآیند ساخت بر اساس شرط ساخت خاص استفاده می‌شود. این به شما اجازه می‌دهد یک شرط را مشخص کنید که برای شامل شدن فایل در فرآیند ساخت باید برآورده نشود.\n//go:checkptr: این کامنت دستوری برای فعال کردن بررسی‌های ایمنی اضافی برای اشاره‌گرها در کد استفاده می‌شود. این دستور به کامپایلر دستور می‌دهد تا بررسی‌های رانتایم اضافی را برای شناسایی عملیات اشاره‌گر ناموفق و مسائل امنیتی حافظه انجام دهد.\n//go:nosplitcheck: این کامنت دستوری برای غیرفعال کردن بررسی nosplit برای یک تابع استفاده می‌شود. بررسی nosplit بررسی می‌کند که یک تابع بدون پیش‌بینی از برنامه‌ای که در آینده اجرا می‌شود، بدون توقف توسط برنامه اجرا شود.استفاده از این دستور ممکن است خطرناک باشد و فقط در صورت ضرورت باید استفاده شود.\n//go:noruntime: این کامنت دستوری برای نشان دادن این است که یک بسته به Go runtime وابسته نیست. این به کامپایلر اطلاع می‌دهد که بسته می‌تواند در یک محیط استفاده شود که Go runtime در دسترس نیست یا نیاز نیست.\nمثال استفاده از directive comment:\npackage main import \u0026quot;fmt\u0026quot; //go:generate stringer -type=Age type Age int const ( CHILDERN Age = iota ADOLESCENTS ADULTS ) func main() { fmt.Println(CHILDERN.String()) } در کد فوق ما یک directive comment اضافه کردیم حال کافیه با استفاده از دستور go generate متد استرینگ تایپ را جنریت کنیم.\n$ go generate ./... "},{"id":62,"href":"/chapter-4/go-code-rules/","title":"4.20 قوانین کدنویسی در گو","section":"فصل چهارم: مباحث پیشرفته","content":"قوانین در زبان گو همانند دیگر زبان های برنامه نویسی به دو دسته تقسیم می شود. بخشی از قوانین در سطح سینتکس زبان مطرح می شوند، لذا رعایت آنها مهم هست، در غیر اینصورت کامپایلر قادر به کامپایل درست کدهای شما نخواهد بود و در بعضی شرایط ممکن است به صورت خاموش خطا به محیط اجرا (runtime) نیز برده شود. بخشی از قوانین به عنوان پیشنهاد و ترجیح مطرح هستند که عموما توسط لینتر بررسی می شوند و تاثیر اصلی بر خوانایی منطق کدها دارند. یعنی رعایت آنها الزام قطعی ندارد. به طور مثال استفاده از _ در نام گذاری ها در گو توصیه نمی شود ولی در کتابخانه استاندارد (الحاقی به زبان گو) به وفور عدم رعایت این موضوع دیده می شود.\nلازم به ذکر است که سازمان ها می توانند قوانین پیشنهادی خود را توسعه دهند و با توسعه لینتر اختصاصی در فرآیند توسعه نرم افزار خود با روش هایی مانند CI/CD از رعایت قوانین خود توسط توسعه دهندگان پروژه های نرم‌افزاری خود اطمینان حاصل نمایند.\n4.20.1 قوانین نام گذاری # در زبان برنامه‌نویسی Go برای نامگذاری توابع، همان گونه که در بالا نیز توضیح داده شد دو مدل قوانین (اجباری و اختیاری) وجود دارد. قوانین اجباری باید رعایت شوند و قوانین اختیاری بهتر است رعایت شوند تا کد هم خوانایی بیشتری داشته باشد و هم از نظر تعاریف و نام‌گذاری مطابق رویه های (پروتکل های) معرفی شده توسط تیم توسعه زبان، به صورت استاندارد باشند.\n4.20.1.1 نام توابع # نام توابع باید با حروف بزرگ یا کوچک شروع شود. توابعی که با حروف بزرگ شروع می‌شوند، به عنوان public تلقی می‌شوند و از سمت بیرون پکیج برای دیگران قابل دسترس هستند. توابعی که با حروف کوچک شروع می‌شوند، به عنوان private تلقی می‌شوند و فقط در داخل پکیج موجود هستند.\nنام توابع public بصورت Pascal Case هستند مانند: ()CalculateInterestRate نام توابع private بصورت camel Case هستند مانند: ()calculateInterestRate برای اطلاعات بیشتر درخصوص public یا private میتوانید به بخش Encapsulation مراجعه کنید.\n4.20.1.2 نام فایل های پسوند go. # نام فایل باید با حرف کوچک شروع شود. نام فایل باید از حروف بزرگ و خط تیره (-) استفاده نکند. نام فایل باید با نام پکیج مطابقت داشته باشد. نام فایل باید از جمله معانی آن و بخشی از توضیح فایل باشد. برای مثال: database_connection.go، calculator_test.go 4.20.1.3 نام interface # نام اینترفیس باید با I شروع نشود. نام اینترفیس باید با camelCase باشد. نام اینترفیس باید صفت یا اسم باشد و معمولاً با حرف I شروع نمی‌شود. برای مثال: Reader، Writer در انتهای نام حتما er داشته باشد. 4.20.1.4 نام پارامترهای توابع # نام پارامترها باید با حروف کوچک شروع شود. نام پارامترها باید با camelCase باشد. برای مثال، تابع زیر درست نام‌گذاری شده است:\nfunc CalculateInterestRate(principal float64, interestRate float64, termInYears int) float64 { // function code here } در این مثال، تمامی پارامترهای تابع با حروف کوچک، با CamelCase نام‌گذاری شده‌اند.\nبه طور کلی، هدف از این قوانین نام‌گذاری، رعایت استانداردهایی برای نام‌گذاری است تا کد خواناتر و قابل فهم باشد و همچنین قابلیت نگهداری و توسعه را بهتری داشته باشد.\n4.20.1.5 نام پکیج # نام پکیج در Go باید با حرف کوچک شروع شود و نام پکیج باید شامل تنها حروف کوچک انگلیسی، اعداد و خط فاصله (-) باشد. همچنین در نام پکیج از حروف بزرگ استفاده نشود، همچنین اسم پکیج باید توصیفی از محتوای آن باشد. برای نام‌گذاری پکیج، معمولاً از نام اصلی محصول یا سرویسی که پیاده‌سازی می‌شود، یا نام ماژول یا قسمتی از نرم‌افزار استفاده می‌شود.\nمثلاً اگر یک پروژه برای پردازش تصویر داریم، نام پکیج می‌تواند \u0026ldquo;imageprocessing\u0026rdquo; باشد. همچنین اگر می‌خواهیم یک کتابخانه بخشی از پروژه خود را به اشتراک بگذاریم، می‌توانیم از نام پروژه یا نام ماژول استفاده کنیم.\nتوجه داشته باشید که نام پکیج باید با نام پوشه‌ای که فایل‌های پروژه در آن هستند همخوانی داشته باشد. برای مثال، اگر فایل‌های پروژه در پوشه imageprocessing قرار دارند، نام پکیج باید imageprocessing باشد.\n4.20.1.6 نام متغیر و const # برای متغیرها و ثابت‌ها در زبان برنامه‌نویسی Go نیز نام‌های خاصی وجود دارد که برای آن‌ها پیشنهاد می‌شود. در ادامه به برخی از قوانین نام‌گذاری برای متغیرها و ثابت‌ها در Go اشاره می‌شود:\nمتغیر\nنام متغیر باید با حرف کوچک شروع شود. نام متغیر باید جهت نمایش نوع متغیر در نام آن و حاوی توضیح مختصر در مورد نام متغیر باشد. نام متغیر باید با camelCase باشد. نام متغیر باید کاملاً توصیفی باشد و نیازی به توضیحات اضافی در مورد آن نباشد. برای مثال، به جای تعریف متغیر x برای نگهداری مقدار سن، می‌توان از نام age استفاده کرد:\nvar age int // تعریف متغیر برای سن شخص const\nنام ثابت باید با حروف بزرگ شروع شود. نام ثابت باید جهت نمایش نوع ثابت در نام آن و حاوی توضیح مختصر در مورد مقدار ثابت باشد. نام ثابت باید با Snake_case باشد. نام ثابت باید کاملاً توصیفی باشد و نیازی به توضیحات اضافی در مورد آن نباشد. برای مثال، برای تعریف ثابت مقدار پاییز در فصل های سال، می‌توانیم از نام SEASON_AUTUMN استفاده کنیم:\nconst SEASON_AUTUMN = \u0026quot;پاییز\u0026quot; توجه داشته باشید که برای نام‌گذاری متغیرها و ثابت‌ها در Go، پیشنهاد می‌شود از نام‌هایی استفاده کنید که بهره بیشتری از خوانایی و قابلیت نگهداری کد برداشته شود. و نام‌هایی که توصیف کننده‌تر و صحیح‌تر هستند برای این منظور بهتر استفاده می‌شوند.\n"},{"id":63,"href":"/chapter-4/go-garbage-collector/","title":"4.21 زباله جمع کن (garbage collector)","section":"فصل چهارم: مباحث پیشرفته","content":"یکی از جذابیت های زبان های برنامه نویسی جدید قابلیت زباله جمع کن (garbage collector) ایجاد شده در آنها است. بطور خلاصه مدیریت و آزاد سازی منابع اختصاص داده شده از حافظه را که بصورت خودکار در زبان های برنامه نویسی مدرن انجام می شود را garbage collector می شناسیم.\nمدیریت منابع حافظه که بسیار حساس و در مواقعی زمان بر است توسط برخی زبان ها بصورت توکار پشتیبانی می شود و این کار به افزایش سرعت و همچنین کاهش خطا در زمان و پروسه تولید نرم افزار می شود. با تمام این تفاسیر مواقعی است که برنامه نویس می باید خودش مدیریت حافظه را در دست گرفته و پیش از بروز شرایط بحرانی اقدام به آزاد سازی حافظه و یا منابع اختصاص یافته نماید. خبر خوب اینکه در زبان Go مدیریت منابع حافظه نسبت به زبان های دیگر ساده تر و راحتر است ولی در این نوشته سعی می کنیم تا درک خوبی از مدیریت منابع و نحوه عملکرد آن داشته باشید بنابر این در ادامه با یک مثال که نیاز به بررسی کد در سطوح پایین دارد می پردازیم.\nاستفاده از uprobes # برای بررسی وضعیت حافظه ما از uprobes استفاده می کنیم این بسته امکان بسیاری در اختیارمان قرار می دهد برای مثال نیازی به تغییر کد برنامه نمی باشد و برای برنامه های درحال اجرا نیز می توان استفاده نمود.\nمراحل garbage collection # مکانیزم garbage collection در زبان go بصورت هم رونده یا concurrent در کنار برنامه ما اجرا می شود که همین قابلیت دلیل عدم توقف یا مکث برنامه در زمان پاکسازی حافظه است و دو مرحله کلی را برای پاکسازی حافظه اجرا می کند.\n1- مرحله Mark phase در این مرحله GC اشیاء و متغیرهای مرده دربرنامه که بخشی از حافظه را اشغال کرده‌اند را جستجو و شناسایی می کند.\n2- مرحله Sweep phase در این مرحله اشیائی که در فاز قبل نشانه گذاری شده‌اند بصورت فیزیکی از حافظه دور ریخته می شود.\nتصویر بالا مراحل مختلف شناسایی و پاکسازی را نشان می دهد\nدر ادامه قطعه کد ذیل را داریم که در واقع یک عمل ساده درخواست و پاسخ به یک آدرس وب است\nhttp.HandleFunc(\u0026quot;/allocate-memory-and-run-gc\u0026quot;, func(w http.ResponseWriter, r *http.Request) { arrayLength, bytesPerElement := parseArrayArgs(r) arr := generateRandomStringArray(arrayLength, bytesPerElement) fmt.Fprintf(w, fmt.Sprintf(\u0026quot;Generated string array with %d bytes of data\\n\u0026quot;, len(arr) * len(arr[0]))) runtime.GC() fmt.Fprintf(w, \u0026quot;Ran garbage collector\\n\u0026quot;) }) در این قطعه کد یک متغیر که محتوای آن آرایه‌ای از رشته ها است تولید می شود و در پایان با صدا زدن تابع runtime.GC از GC درخواست می کنیم که حافظه را پاکسازی کند دقت کنید که در این قسمت از کد شی arr دیگر مورد استفاده قرار نمی گیرد و از نظر طول عمر مرده به حساب می آید و GC اقدام به پاکسازی فظای اشغال شده توسط این متغیر را می کند.\nاما داستان به این سادگی هم نیست برای مثال مهمترین ویژگی GC این است که بصورت خودکار در زمان های مناسب وارد عمل می شود و اقدام به رها سازی حافظه می نماید باید توجه داشته باشیم که خود عملیات GC بدون سربار به سیستم نیست و شامل موارد ذیل است\nGC Pause Time: عملیات پاکسازی بصورت همزمان با اجرای برنامه انجام می شود ولیکن در برنامه های سنگین بصورت لحظه ای می شود متوجه سربار زمان توقف برنامه برای عملیات پاکسازی شد. هرچند که برای کاربران عادی مشهود نباشد.\nMemory Allocation: جهت نشانه گذاری اشیاء مرده نیز نیاز به تخصیص حافظه است.\nCPU usage: تمامی فعالیت های انجام شده نیاز به پردازش دارد که قاعدتا به پردازنده سربار اضافی تحمیل خواهد کرد.\nGC trigger threshold این قابلیت در زبان go قابل تنظیم است و اجازه می دهد تا یک آستانه برای عملیات پاکسازی در نظر بگیریم که به بصورت درصد مشخص می شود. چنانچه درصد استفاده از حافظه از مقدار تعیین شده در متغیر آستانه بیشتر شود عملیات پاکسازی اجرا خواهد شد که این به نوبه خود چالش برانگیز است برای مثال اگر مقدار آستانه را زیاد تعریف کنیم ممکن است برنامه با کمبود منابع روبرو شود و یا درصورت تعیین مقدار پایین منابعی مانند پردازنده بیش از حد درگیر خواهند شد. Memory Pressure: مواقعی که برنامه به لحاظ منابع حافظه تحت فشار و محدودیت است در این زمان GC بطور متوالی اجرا خواهد شد که می تواند دلیل توقف برنامه اصلی شود\nمانیتور نحوه کار GC # در ادامه میخواهیم توابع ذیل که در runtime موجود است را به کمک uprobes زیر نظر بگیریم تا علاوه بر مقادیر تولید شده در آنها، فرآیند آنها نیز برایمان قابل درک باشد.\nGC تابع اجرای عملیات پاکسازی gcWaitOnMark تابع تشخیص اشیا جهت رها سازی gcSweep تابع رها سازی منابع دقت داشته باشید که تنظیم و اجرا uprobes نیاز به اطلاع بیشتر دارد که در حوصله این نوشتار نیست و متوانید با جستجو در اینترنت به منابع مورد نیاز دسترسی داشته باشید\n$ curl '127.0.0.1/allocate-memory-and-run-gc?arrayLength=10\u0026amp;bytesPerElement=20' Generated string array with 200 bytes of data Ran garbage collector پس از اجرای کوئری بالا بر روی آدرس برنامه خود نتایج ذیل حاصل می شود نکته قابل توجه اینجاست که تابع gcWaitOnMark دو بار در طول عملیات پاکسازی اجار می شود که بار اول جهت اعتبار سنجی منابع نشانه گذاری شده قسمت قبل است.\nبا این توضیحات حال می خواهیم به بررسی چند مثال ساده بپردازیم تا ببینیم در چه مواقعی بهتر است برنامه نویس در بخش های مناسب خود اقدام به پاکسازی حافظه نماید\npackage main import ( \"fmt\" \"runtime\" ) func main() { // Allocate some memory for the program to use s := make([]string, 0, 100000) for i := 0; i \u003c 100000; i++ { s = append(s, \"hello, world\") } // Print the initial memory usage var m runtime.MemStats runtime.ReadMemStats(\u0026m) fmt.Println(\"Initial HeapAlloc: \", m.HeapAlloc) // Trigger the garbage collector runtime.GC() // Print the memory usage after the garbage collector has run runtime.ReadMemStats(\u0026m) fmt.Println(\"After GC HeapAlloc: \", m.HeapAlloc) // Release the memory s = nil // Trigger the garbage collector runtime.GC() // Print the memory usage after the garbage collector has run runtime.ReadMemStats(\u0026m) fmt.Println(\"After release HeapAlloc: \", m.HeapAlloc) } ▶ اجرای کد کپی ✖ بستن خروجی در کد بالا به کمک یک حلقه در هربار اجرای آن مقداری را به رشته قبلی خود اضافه نموده ایم و بعد از آن مقدار فضای اشغال شده توسط رشته ما در حافظه را نمایش می دهیم در ادامه به کمک runtime.GC حافظه را تخلیه می کنیم و در انتها بررسی می کنیم که آیا مقدار متغیر ما بصورت واقعی تخلیه شده است که نتایج خروجی موارد فوق را تائید می نماید. به یاد داشته باشید که منابع سیستم همواره محدود می باشد و در شرایط این چنینی می بایست خود برنامه نویس با تشخیص درست اقدام به تخلیه حافظه نماید.\nاستفاده از GODEBUG # در مواقعی نیاز است تا GC را بدونه کتابخانه و ابزار اضافی و فقط با قابلیت‌های داخلی خود زبان go بررسی نمائیم که در چنین شرایطی بهتر است از GODEBUG استفاده کنیم.\npackage main import ( \"fmt\" \"runtime\" \"time\" ) func printStats(mem runtime.MemStats) { runtime.ReadMemStats(\u0026mem) fmt.Println(\"mem.Alloc:\", mem.Alloc) fmt.Println(\"mem.TotalAlloc:\", mem.TotalAlloc) fmt.Println(\"mem.HeapAlloc:\", mem.HeapAlloc) fmt.Println(\"mem.NumGC:\", mem.NumGC) fmt.Println(\"-----\") } func main() { var mem runtime.MemStats printStats(mem) for i := 0; i \u003c 10; i++ { s := make([]byte, 100000000) if s == nil { fmt.Println(\"Operation failed!\") } } printStats(mem) for i := 0; i \u003c 10; i++ { s := make([]byte, 100000000) if s == nil { fmt.Println(\"Operation failed!\") } time.Sleep(5 * time.Second) } printStats(mem) } ▶ اجرای کد کپی ✖ بستن خروجی در کد فوق برنامه بدون دیباگ خروجی فوق را تولید نموده است که مقدار منابع مصرف شده در هر چرخه را نمایش می دهد اما اگر بخواهیم برنامه را با دستور GODEBUG اجرا کنیم خروجی متفاوت خواهد بود به یاد داشته باشید ما در اینجا میخواهیم مقادیر تولید شده که بصورت key-value است و با علامت کاما از هم جدا شده اند و فقط برای GC را بررسی کنیم درحالی که می توان بخش های دیگر برنامه را نیز با سوئیچ های مختلف دیباگ کرد بنابراین اینبار برنامه را با دستور ذیل اجرا می کنیم\n# GODEBUG=gctrace=1 go run main.go a gc 1 @0.019s 1%: 0.014+2.4+0.001 ms clock, 0.014+0.33/0/0+0.001 ms cpu, 4-\u0026gt;4-\u0026gt;0 MB, 5 MB goal, 1 P gc 2 @0.050s 3%: 0.027+5.1+0.002 ms clock, 0.027+0.37/1.0/0+0.002 ms cpu, 4-\u0026gt;4-\u0026gt;1 MB, 5 MB goal, 1 P gc 3 @0.089s 2%: 0.067+3.3+0.002 ms clock, 0.067+0.66/0/0+0.002 ms cpu, 4-\u0026gt;4-\u0026gt;1 MB, 5 MB goal, 1 P gc 4 @0.128s 2%: 0.032+2.6+0.003 ms clock, 0.032+0.82/0/0+0.003 ms cpu, 4-\u0026gt;4-\u0026gt;1 MB, 5 MB goal, 1 P gc 5 @0.153s 2%: 0.046+5.1+0.002 ms clock, 0.046+0.81/0/0+0.002 ms cpu, 4-\u0026gt;5-\u0026gt;1 MB, 5 MB goal, 1 P gc 6 @0.175s 3%: 0.030+11+0.002 ms clock, 0.030+1.4/0.16/0+0.002 ms cpu, 4-\u0026gt;5-\u0026gt;1 MB, 5 MB goal, 1 P gc 7 @0.224s 2%: 0.027+2.4+0.003 ms clock, 0.027+0.63/0/0+0.003 ms cpu, 4-\u0026gt;5-\u0026gt;2 MB, 5 MB goal, 1 P # command-line-arguments gc 1 @0.004s 17%: 0.009+2.4+0.002 ms clock, 0.009+1.3/0/0+0.002 ms cpu, 4-\u0026gt;6-\u0026gt;5 MB, 5 MB goal, 1 P gc 2 @0.036s 16%: 0.014+8.7+0.004 ms clock, 0.014+4.0/2.2/0+0.004 ms cpu, 9-\u0026gt;9-\u0026gt;8 MB, 11 MB goal, 1 P mem.Alloc: 48128 mem.TotalAlloc: 48128 mem.HeapAlloc: 48128 mem.NumGC: 0 ----- gc 1 @0.007s 1%: 0.011+0.11+0.002 ms clock, 0.011+0.10/0/0+0.002 ms cpu, 95-\u0026gt;95-\u0026gt;0 MB, 96 MB goal, 1 P gc 2 @0.054s 0%: 0.030+0.13+0.002 ms clock, 0.030+0.12/0/0+0.002 ms cpu, 95-\u0026gt;95-\u0026gt;0 MB, 96 MB goal, 1 P gc 3 @0.106s 0%: 0.023+0.12+0.002 ms clock, 0.023+0.12/0/0+0.002 ms cpu, 95-\u0026gt;95-\u0026gt;0 MB, 96 MB goal, 1 P gc 4 @0.141s 0%: 0.023+0.15+0.004 ms clock, 0.023+0.15/0/0+0.004 ms cpu, 95-\u0026gt;95-\u0026gt;0 MB, 96 MB goal, 1 P gc 5 @0.185s 0%: 0.021+0.12+0.001 ms clock, 0.021+0.11/0/0+0.001 ms cpu, 95-\u0026gt;95-\u0026gt;0 MB, 96 MB goal, 1 P gc 6 @0.221s 0%: 0.023+0.22+0.002 ms clock, 0.023+0.22/0/0+0.002 ms cpu, 95-\u0026gt;95-\u0026gt;0 MB, 96 MB goal, 1 P gc 7 @0.269s 0%: 0.025+0.12+0.001 ms clock, 0.025+0.12/0/0+0.001 ms cpu, 95-\u0026gt;95-\u0026gt;0 MB, 96 MB goal, 1 P gc 8 @0.311s 0%: 0.032+0.33+0.002 ms clock, 0.032+0.32/0/0+0.002 ms cpu, 95-\u0026gt;95-\u0026gt;0 MB, 96 MB goal, 1 P gc 9 @0.350s 0%: 0.022+0.10+0.006 ms clock, 0.022+0.097/0/0+0.006 ms cpu, 95-\u0026gt;95-\u0026gt;0 MB, 96 MB goal, 1 P gc 10 @0.390s 0%: 0.021+0.11+0.005 ms clock, 0.021+0.10/0/0+0.005 ms cpu, 95-\u0026gt;95-\u0026gt;0 MB, 96 MB goal, 1 P mem.Alloc: 100045256 mem.TotalAlloc: 1000128368 mem.HeapAlloc: 100045256 mem.NumGC: 9 ----- در نگاه اول خروجی کد بالا کمی گند به نظر می رسد که سعی می کنیم در ذیل آنها را توضیح دهیم\nخروجی توضیح gc 1 شماره پاکسازی که در هربار اجرای عملیات پاکسازی بصورت خودکار به آن اضافه می شود @0.007s زمان اجرای پاکسازی بعد از شروع به کار برنامه 0% درصد منابع پردازشی استفاده شده بعد از اجرای برنامه 0.011+0.11+0.002 ms clock مقدار این متغیر متشکل از چند مقدار است که بصورت ذیل محاسبه می شود Tgc = Tseq + Tmark + Tsweep 95-\u0026gt;95-\u0026gt;0 MB این متغیر نیز چند مقداری است و مقادیر اول نشانگر عملکرد حافظه قبل از اجرای پاکسازی ، دوم بعد از اجرای پاکسازی و سوم مقدار پشته است 96 MB goal اندازه پشته برنامه مورد نظر 1 P تعداد پردازنده مورد استفاده شده Tseq: زمان توقف گوروتین های کاربر Tmark: زمان مورد استفاده جهت فاز mark Tsweep: زمان مورد استفاده جهت فاز sweep\n"},{"id":64,"href":"/chapter-4/go-plugin/","title":"4.22 کتابخانه Plugin","section":"فصل چهارم: مباحث پیشرفته","content":"در میان ویژگی‌های قابل توجه Go نسخه 1.8، سیستم جدید پلاگین‌های Go قرار دارد. این ویژگی به برنامه‌نویسان اجازه می‌دهد تا برنامه‌های ماژولار بدون ارتباط زنجیره‌ای با هم، با استفاده از بسته‌هایی که به صورت کتابخانه‌های اشیا شیء‌گرا کامپایل شده‌اند، ساخته شوند و به‌صورت پویا در زمان اجرا بارگذاری و به‌صورت پیوسته به آن‌ها پیوند داده شوند.\nاین تغییر بزرگی است! چرا که توسعه‌دهندگان نرم‌افزارهای سیستمی بزرگ در Go، بدون شک، نیاز به ماژولارسازی کد خود دارند. ما برای دستیابی به ماژولارسازی کد، از طراحی‌های متعدد out-of-process، مانند OS exec calls، سوکت و RPC/gRPC (و غیره) استفاده کرده‌ایم. این روش‌ها ممکن است به خوبی کار کنند، اما در بسیاری از زمینه‌ها به‌عنوان پایانه‌ای برای پردازش با قبل نبود یک سیستم پلاگین‌ای ناتیو در Go بکار رفته‌اند.\nدر این بخش از کتاب، من بررسی می‌کنم که ایجاد نرم‌افزار ماژولار با استفاده از سیستم پلاگین‌های Go (plugin) چه تبعاتی دارد.\nاز نسخه 1.8، plugin فقط در لینوکس کار می‌کند. با توجه به سطح علاقمندی به این ویژگی، این احتمالا در نسخه‌های آینده تغییر خواهد کرد. 4.22.1 طراحی ماژولار با Go # ایجاد برنامه‌های ماژولار با پلاگین﻿‌های Go، نیاز به همان شیوه کار قابل اعتماد نرم‌افزاری دارد که به بسته‌های Go رایج اعمال می‌شود. با این‌حال، پلاگین‌ها نگرانی‌های طراحی جدید را با توجه به اتصالشان به دیگر اجزای برنامه، بیشتر کرده‌اند.\nدر هنگام ساخت سیستم نرم‌افزاری قابل پلاگین‌گذاری، بسیار مهم است که قابلیت‌های واضحی برای اجزای سیستم تعریف شوند. سیستم باید رابط‌های ساده و شفافی برای یکپارچه‌سازی پلاگین فراهم کند. از سوی دیگر، توسعه‌دهندگان پلاگین باید به عنوان یک جعبه سیاه برای سیستم در نظر گرفته شوند و علاوه بر قراردادهای ارائه‌شده، هیچ فرضیاتی را انجام ندهند. پلاگین باید به عنوان یک اجزای مستقل در نظر گرفته شود که از دیگر اجزا جدا شده است. این باعث می‌شود که پلاگین‌ها بتوانند دوره‌ی life cycle توسعه و استقرار خود را بدون وابستگی به مصرف‌کنندگانشان دنبال کنند. کد پلاگین باید طراحی شود تا تمرکز خود را فقط بر روی یکی از مسائل عملکردی داشته باشد و نه بیشتر از آن. از آنجایی که پلاگین‌ها اجزای مستقل‌ای هستند که در زمان اجرا بارگیری می‌شوند، مهم این است که از مستندات خوبی برخوردار باشند. به عنوان مثال، نام توابع و متغیرهای پیاده سازی باید به طور واضح مشخص شوند تا خطاهای جستجوی symbol ها را جلوگیری کنند. پلاگین‌های Go می‌توانند تابع‌های بسته و متغیرهایی از هر نوع را به‌صورت خروجی دهند. می‌توانید پلاگین‌تان را طراحی کنید تا قابلیت‌های خود را به‌صورت یک مجموعه‌ی تابع‌های آزاد گروه‌بندی کند. سردرگمی، این است که شما باید به‌صورت جداگانه هر symbol تابع را جستجو و به آن متصل شوید. راهکار بهتر این است که از انواع interface استفاده کنید. ایجاد یک interface برای صادرکردن قابلیت‌ها، یک سطح تعاملی یکنواخت و مختصر با نشانگرهای عملیاتی واضح فراهم می‌کند. جستجو و متصل کردن به‌نمادی که به یک رابط حل می‌شود، دسترسی به کل مجموعه شیوه های تابعی برای قابلیت‌ها را فراهم می‌کند، نه فقط یکی از آن‌ها. 4.22.2 کتابخانه plugin # کتابخانه plugin، یک کتابخانه خیلی ساده و آسان است و فقط یک تابع Open و یک متد Lookup دارد که به شما برای بازکردن فایل so. و استفاده ازinterface های پیاده سازی شده کمک می کند.\ntype Plugin func Open(path string) (*Plugin, error) func (p *Plugin) Lookup(symName string) (Symbol, error) type Symbol کتابخانه plugin، یک پکیج اصلی Go با توابع و متغیرهای صادرشده است که با استفاده از دستور زیر برای کامپایل ساخته شده است:\n$ go build -buildmode=plugin وقتی که یک plugin برای اولین بار باز می‌شود، تابع init تمام بسته‌هایی که هنوز قسمت برنامه نیستند فراخوانی می‌شوند. تابع اصلی اجرا نمی‌شود. یک plugin تنها یکبار مقداردهی اولیه می‌شود و نمی‌تواند بسته شود.\n4.22.3 پیاده سازی قدم به قدم یک برنامه ماژولار با plugin # فرض کنید قصد یک پروژه بنویسیم که hello world را به زبان های مختلف در خروجی terminal چاپ کنیم.\n4.22.3.1 نمونه ساختار پروژه # در ابتدا نیاز داریم یک پروژه با ساختار زیر پیاده سازی کنیم:\n├── [ 22] go.mod ├── [ 779] main.go └── [ 224] plugin ├── [ 240] en │ └── [ 152] en.go └── [ 240] fa ├── [ 155] fa.go 4.22.3.2 نوشتن پلاگین # در ابتدا یک دایرکتوری plugin ایجاد کنید سپس براساس زبان مورد نظر خود یک یا چند sub directory ایجاد کنید.\nحال برای زبان فارسی و انگلیسی از کد زیر استفاده کنید:\nEnglish\npackage main import \u0026quot;fmt\u0026quot; type hello string func (h hello) Hello() { fmt.Println(\u0026quot;Hello 🌎\u0026quot;) } // Hello exported as symbol named var Hello hello Persian\npackage main import \u0026quot;fmt\u0026quot; type hello string func (h hello) Hello() { fmt.Println(\u0026quot;سلام 🌎\u0026quot;) } // Hello exported as symbol named var Hello hello در کد فوق ما به ازای هر زبان یک فایل go ایجاد کردیم که با پکیج main شروع می شود و داخلش یک type مشخص قرار دادیم و متد Hello را پیاده سازی کردیم. سپس یک متغییر با نام Hello تعریف کردیم تا به عنوان symbol برای پلاگین در دسترس باشد.\nاگر package شما نام دیگری غیر از main باشد با خطا مواجه خواهید شد به دلیل build شدن ماژول هستش.\n-buildmode=plugin requires exactly one main package 4.22.3.3 بیلد پلاگین ها # برای بیلد گرفتن پلاگین ها باید از دستورات زیر استفاده کنید:\ngo build -buildmode=plugin -o plugin/en/en.so plugin/en/en.go go build -buildmode=plugin -o plugin/fa/fa.so plugin/fa/fa.go زمانیکه بیلد میگیرید فایل پلاگین ها در محل plugin/en یا plugin/fa با پسوند so. قرار میگیرد.\nحال با استفاده از ابزار file در لینوکس می توانید اطلاعات ماژول بیلد شده را ببینید که به عنوان dynamic shared object شناخته می شود:\n$ file plugin/en/en.so plugin/en/en.so: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, BuildID[sha1]=d23f35974563f658267b158466cbb551a97fb049, with debug_info, not stripped ساختار پروژه پس از بیلد پلاگین ها\n├── [ 22] go.mod ├── [ 779] main.go └── [ 224] plugin ├── [ 240] en │ ├── [ 152] en.go │ └── [ 3.5M] en.so └── [ 240] fa ├── [ 155] fa.go └── [ 3.5M] fa.so 4.22.3.4 استفاده از پلاگین ها # داخل روت پروژه یک فایل main.go ایجاد کنید و کد زیر را قرار دهید.\nتوجه کنید نیاز دارید فایل های پلاگین را در هر محلی هست load کنید.\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;os\u0026quot; \u0026quot;plugin\u0026quot; ) type Greeter interface { Hello() } func main() { // determine plugin to load lang := \u0026quot;english\u0026quot; if len(os.Args) == 2 { lang = os.Args[1] } var mod string switch lang { case \u0026quot;english\u0026quot;: mod = \u0026quot;./plugin/en/en.so\u0026quot; case \u0026quot;persian\u0026quot;: mod = \u0026quot;./plugin/fa/fa.so\u0026quot; default: fmt.Println(\u0026quot;don't support your language\u0026quot;) os.Exit(1) } // load module plug, err := plugin.Open(mod) if err != nil { fmt.Println(err) os.Exit(1) } // lookup for symbol symbol, err := plug.Lookup(\u0026quot;Hello\u0026quot;) if err != nil { fmt.Println(err) os.Exit(1) } // assert symbol with interface p, ok := symbol.(Greeter) if !ok { fmt.Println(\u0026quot;unexpected type from module symbol\u0026quot;) os.Exit(1) } // call interface method p.Hello() } $ go run main.go english Hello 🌎 در ابتدا یک interface به همراه متد مشابه داخل پلاگین قرار دادیم. سپس داخل main یک زبان پیش فرض را داخل متغیر lang تعیین کردیم سپس از طریق os.Args زبان از طریق os.Stdin گرفتیم و داخل lang قرار دادیم پس از آن با استفاده از switch چک کردیم براساس زبان یک پلاگین یا ماژول مشخص را داخل متغیر mod مسیر دهی کنیم. سپس تابع Open کتابخانه plugin را فراخوانی کردیم و مسیر پلاگین را قرار دادیم. حال پس از باز شدن پلاگین متد Lookup را برای پیدا کردن symbol فراخوانی کردیم که ما نام symbol را Hello گذاشتیم. پس از اینکه symbol بدون خطا load شد ما symbol را با اینترفیس Greeter گرفتیم Assert کردیم تا بتوانیم از متدهای پیاده سازی شده استفاده کنیم. 4.22.4 پروژه هایی که از plugin استفاده کرده اند # در زیر ما لیستی از پروژه های فعالی که از پلاگین استفاده کرده اند را قرار دادیم تا بتوانید برای پیاده سازی پروژه های ماژولار ایده بگیرید:\nhttps://github.com/hashicorp/go-plugin https://github.com/luraproject/lura https://github.com/smartcontractkit/chainlink-starknet https://github.com/ava-labs/blobvm https://github.com/easysoft/zentaoatf 4.22.5 کلام آخر # ماژولارنویسی یکی از مهم ترین عناوین توسعه و طراحی نرم افزار بوده که شما با اینکار می توانید پلاگین های reusable بنویسید و در هر پروژه ای بسته به نیازتان استفاده کنید. شرکت های بزرگی نظیر hashicorp برای اکثر پروژهایش نظیر terraform یا consul از این قابلیت استفاده کرده است.\n"},{"id":65,"href":"/chapter-4/oop/","title":"4.23 شی گرایی در زبان گو","section":"فصل چهارم: مباحث پیشرفته","content":"گو یک زبان statically-typed است و بطور کلی امکانات شی گرایی را به شیوه قدیم و مرسوم پشتیبانی نمی کند. اما در عوض یک شیوه قرار دادی وجود دارد که به شما کمک می کند برخی از مفاهیم شی گرایی را با کمک اینترفیس, composition, متد و type embedding پیاده سازی کنید.\nاین مفاهیم شامل :\nکپسوله سازی ارث بری پلی مورفیسم overriding abstraction تعریف شی گرایی به زبان ساده # بیاید با چند تا مثال ساده، سوا از اینکه با چه زبانی کار می کنیم، با مفهوم شی گرایی آشنا شویم.\nقراره با یه سری مثال از دنیای واقعی شی گرایی رو براتون توضیح بدم. ما موجودی داریم به اسم گربه (class) که این موجود ویژگی (Attribute) و رفتار (Method) هایی رو داره. برای مثال گربه ویژگی هایی مثل رنگ چشم، وزن و \u0026hellip; داره. همچنین رفتار هایی رو داره مثل راه رفتن،‌ میو میو کردن.\nخب تا الان گربه رو به صورت انتزاعی گفتیم که فلان ویژگی ها و رفتار هارو داره. به یک نمونه واقعی از گربه object و یا instance میگیم.\nگربه خودش از یک کلاس والد ارث بری (Inheritance) کرده. مثلا کلاسی داریم به اسم حیوان. کلاس حیوان یه سری ویژگی ها و رفتار هایی رو داره. حالا که گربه از کلاس حیوان ارث بری کرده رفتار ها و ویژگی های والدش رو ارث میگیره.\nخب اینجا یه سوالی پیش میاد! ما کلی موجود داریم که کلاس والدشون حیوان هستش ولی آیا همشون شبیه به همدیگه رفتار می کنن؟ برای مثال همشون یه شکلی راه میرن و صدا در میارن؟ جواب قطعا خیر هستش. اینجاس که چند ریختگی (Polymorphism) اتفاق میوفته. درسته که هم سگ و هم گربه صدا دارن ولی یکیش میو میکنه یکیش هاپ هاپ\nبعضی وقتا نیازه که ما یک سری ویژگی ها و متد هایی رو تعریف کنیم اما از بیرون قابل دسترس نباشه. مثلا attribute به اسم score داریم که امتیاز رو نگه میداریم. بقیه قسمت های کد نباید بصورت مستقیم بتونن مقدار score رو تغییر بدن پس میایم socre رو مخفی می کنیم تا از بیرون دسترسی نداشته باشن و برای تغییر دادن socre یک متد به اسم increase_score می نویسیم که هربار صدا زده بشه به امتیاز کاربر اضافه بشه.\nمثال دوم: فرض کن یه پکیجی رو داری مینویسی که قراره یه سری کارهایی رو انجام بده. نمیخوای برنامه نویسی که قراره از پکیجت استفاده کنه یه سری رفتار و ویژگی هارو ببینه. مثلا متد get_response رو داری که خود این متد چند تا متد دیگه رو صدا میزنه تا بتونه پاسخ مناسب رو نشون بده.\nاین متد هایی که توی get_response استفاده کردیم فقط برای استفاده داخلی نوشته شدن و نمیخوایم برنامه نویس بهشون دسترسی داشته باشه. پس میایم مخفی میکنیمشون و از encapsulation استفاده می کنیم\nهر ساله ماشین ها از نظر فنی کلی تغییر می کنن اما شخصی که با یک ماشین چند سال پیش رانندگی کرده باشه با ماشین الانم میتونه رانندگی کنه. اینجاست که abstraction باعث میشه این اتفاق بیوفته. اومدن بصورت انتزاعی تعریف کردن که ماشین دنده داره، پدال گاز داره و فرمون داره و هر کدومشون به چه صورت عمل می کنن.\nبه همین دلیل با اینکه از نظر فنی و داخلی کلی تغییر میکنن اما طرز استفاده ازش تغییر خاصی نمیکنه.\nبیاید یه مثال دیگه بزنیم: فرض کنید شما یک وب سایت طراحی کردید. یه سری دکمه ها و قابلیت ها قرار دادید تا کاربر بتونه ازش استفاده کنه. با اینکه سبد خرید برای کاربر همونه اما پشت صحنه کلی تغییر دادید و بروزرسانیش کردید.\nهمچنین شما هم برای طراحی وب سایت از یک سری ابزار ها استفاده کردید که این ابزار ها همش در حال بروز رسانی هستند اما نحوه استفاده شما تغییری نمیکنه.\nبه این مفهوم Abstraction میگن.\nدر ادامه این بخش بررسی می کنیم که در زبان گولنگ آیا مفاهیم شی گرایی رو داریم یا نه. اگه داریم به چه صورت قابل پیاده سازی هستند.\n"},{"id":66,"href":"/chapter-4/oop/go-encapsulation/","title":"4.23.1 کپسوله سازی (Encapsulation)","section":"4.23 شی گرایی در زبان گو","content":"کپسوله سازی در زبان گو یا هر زبان دیگری یک مفهوم مشترک می باشد که شما یک داده یک تابع را پشت یک آبجکت یا یک واحد مستقل بپوشانید. با اینکار شما جلوی دسترسی مستقیم برروی داده را میگیرید. این کار در شی گرایی کمک می کند شما کدهای خود را بهتر سازماندهی کنید و جلوی دسترسی مستقیم ناخواسته را بگیرید.\nدر زبان گو برای Public/Private کردن یک آبجکت یا تابع کلمه کلیدی به نام public/private ندارد ولی در عوض شما می توانید داخل هر پکیج با بزرگ یا کوچک کردن حرف اول نام هر آبجکت یا تابع جلو دسترسی مستقیم را بگیرید.\nvar DatabaseName string // public var databaseName string // private func Greeting() {} // public func greeting() {} // private زمانی که شما یک آبجکت یا تابع را به شیوه فوق private می کنید در واقع آن آبجکت یا تابع فقط در همان package level خود در دسترس می باشد.\nبه عنوان مثال اگر تابع greeting داخل پکیج message باشد فقط در همان جا در دسترس می باشد.\n└── message ├── data.go ├── message.go └── resp.go در زیر یک مثال ساده زدیم توجه کنید :\npackage main import \"fmt\" type Person struct { name string age int } func (p *Person) GetAge() int { return p.age } func (p *Person) getName() string { return p.name } func (p *Person) SetAge(age int) { p.age = age } func main() { person := Person{ name: \"Javad\", } person.SetAge(29) fmt.Printf(\"%s with age %d\", person.getName(), person.GetAge()) } ▶ اجرای کد کپی ✖ بستن خروجی کد فوق ما یک ساختار (آبجکت) Person ایجاد کردیم که داخلش ۲ فیلد name, age بصورت private وجود دارد که سایر پکیج ها نمی توانند دسترسی مستقیم به فیلد های Person دسترسی داشته باشند. حال ۳ متد تعریف کردیم GetAge برای گرفتن سن شخص , SetAge برای تعیین سن شخص , getName گرفتن نام شخص که فقط داخل همان پکیج در دسترس است این متد.\n"},{"id":67,"href":"/chapter-4/oop/go-inheritance/","title":"4.22.2 ارث بری","section":"4.23 شی گرایی در زبان گو","content":"در زبان گو ارث بری در واقع type embedding هست با استفاده type embedding می توانید یک type را داخل type دیگری جاسازی کنید و به واسطه type والد قابل دسترس است.\npackage main import \"fmt\" type Person struct { Name string } func (p *Person) Introduce() { fmt.Printf(\"Hi, my name is %s\\n\", p.Name) } type Student struct { Person School string } func main() { s := \u0026Student{Person{\"John Doe\"}, \"Go University\"} s.Introduce() } ▶ اجرای کد کپی ✖ بستن خروجی "},{"id":68,"href":"/chapter-4/oop/go-polymorphism/","title":"4.23.3 پلی مورفیسم (Polymorphism)","section":"4.23 شی گرایی در زبان گو","content":"پلی مورفیسم یکی از مفاهیم مهم در شی گرایی می باشد و هدف استفاده از پلی مورفیسم این است بین آبجکت ها رفتار مشترکی ایجاد کنیم. در زبان گو شما می توانید یک اینترفیس تعریف کنید و برای ساختارهای مختلف متدهای اینترفیس را پیاده سازی کنید.\nبه مثال زیر توجه کنید :\npackage main import \"fmt\" // Shape is an interface that defines a method named `Area` type Shape interface { Area() float64 } // Rectangle is a struct that represents a rectangle type Rectangle struct { width float64 height float64 } // Area implements the Shape interface for Rectangle func (r Rectangle) Area() float64 { return r.width * r.height } // Circle is a struct that represents a circle type Circle struct { radius float64 } // Area implements the Shape interface for Circle func (c Circle) Area() float64 { return 3.14 * c.radius * c.radius } func CalcArea(shapes ...Shape) { for _, shape := range shapes { fmt.Println(shape.Area()) } } func main() { r := Rectangle{width: 10, height: 5} c := Circle{radius: 5} CalcArea(r, c) } ▶ اجرای کد کپی ✖ بستن خروجی در کد فوق ما یک اینترفیس Shape داریم که داخلش یک متد به نام Area هست حال این متد را برای ساختارهای Rectangle و Circle پیاده سازی کردیم که مساحت دایره و مستطیل را محاسبه کنیم. حال یک تابع CalcArea داریم به عنوان پارامتر slice از Shape ها میگیرد که ما داخل تابع main ساختار Rectangle و Circle که متد Area اینترفیس Shape را پیاده سازی کرده اند را پاس دادیم و در نهایت محاسبه مساحت را در خروجی چاپ می کند.\n"},{"id":69,"href":"/chapter-4/oop/go-overriding/","title":"4.23.4 overriding","section":"4.23 شی گرایی در زبان گو","content":"در زبان گو مثل سایر زبان های شی گرا امکان overriding مستقیم یک متد وجود ندارد اما در عوض شما می توانید با استفاده از type embedding و پیاده سازی متد یک اینترفیس این تکنیک را انجام دهید و به متدی که override انجام داده Shadow Method می گویند.\nبه مثال زیر توجه کنید :\npackage main import \"fmt\" type User interface { PrintName() } type Person struct { Name string } func (p Person) PrintName() { fmt.Println(\"My name is\", p.Name) } type Student struct { Person } func (s Student) PrintName() { fmt.Println(\"I am a student and my name is\", s.Name) } func main() { p := Person{Name: \"John\"} s := Student{Person{Name: \"Jane\"}} p.PrintName() s.PrintName() } ▶ اجرای کد کپی ✖ بستن خروجی در کد فوق ما یک اینترفیس User داریم که داخلش یک متد PrintName وجود دارد که این متد نام شخص یا دانش آموز را به همراه توضیحات چاپ می کند. حال ۲ تا ساختار داریم Person و Student که ساختار student فقط Person را جاسازی کرده است. سپس برای این ۲ ساختار متد PrintName را پیاده سازی کردیم با این تفاوت که داخل متد PrintName ساختار Student متن دیگری قرار دادیم. در تابع main ما متغیر p, s را از نوع Person و Student ایجاد و مقدار دهی کردیم. سپس متد PrintName هر دو را فراخوانی کردیم.\n"},{"id":70,"href":"/chapter-4/oop/go-abstraction/","title":"4.23.5 abstraction","section":"4.23 شی گرایی در زبان گو","content":"Abstraction (به معنای انتزاع)، فرآیند حذف یا از بین بردن برخی ویژگی‌های غیرضروری یک چیز به‌منظور کاهش، خلاصه‌سازی و به کار بردن آن در مجموعه‌ای از ویژگی‌های ضروری است. در برنامه‌نویسی شیءگرا(OOP)، انتزاع یکی از سه مفهوم اصلی (به همراه مفاهیم Encapsulation و Inheritance) است.\nبه نقل از ویکی پدیا : انتزاع،[۱] (به انگلیسی: Abstraction) تجرید یا آهنجش فرایند اختصار، فشرده‌سازی، و تلخیص اطّلاعات از طریق شناسائی، استخراج و سپس، جداسازی و پنهان‌سازی جزئیّات[۲] از کلیّات[۳] است. انتزاع در لغت به معنای جدا کردن، گرفتن، درآوردن جزئی از یک کل[۴] و به معنای بازداشتن و امتناع کردن، برکندن و از جای کشیدن، گرفتن، و دور شدن می‌باشد.[۵]\nانتزاع فرایند یا نتیجهٔ تعمیم بخشیدن با کاهش محتوای اطلاعاتی یک مفهوم یا یک پدیدهٔ قابل مشاهده، جهت حفظ اطلاعات برای منظور خاص می‌باشد.\nدر زبان گو abstraction با استفاده از اینترفیس می توان انجام داد. یک اینترفیس یکسری متد دارد که ما این متدها را برای هریک از تایپ های مختلف پیاده سازی می کنیم.\nبه مثال زیر توجه کنید :\npackage main import \"fmt\" // Shape is an interface that defines the basic methods for a shape. type Shape interface { Area() float64 Perimeter() float64 } // Rectangle is a struct that implements the Shape interface. type Rectangle struct { width, height float64 } // Area returns the area of the rectangle. func (r Rectangle) Area() float64 { return r.width * r.height } // Perimeter returns the perimeter of the rectangle. func (r Rectangle) Perimeter() float64 { return 2 * (r.width + r.height) } // Circle is a struct that implements the Shape interface. type Circle struct { radius float64 } // Area returns the area of the circle. func (c Circle) Area() float64 { return 3.14 * c.radius * c.radius } // Perimeter returns the perimeter of the circle. func (c Circle) Perimeter() float64 { return 2 * 3.14 * c.radius } func main() { // Create a rectangle and a circle. r := Rectangle{width: 10, height: 20} c := Circle{radius: 5} // Declare a slice of Shape interfaces. shapes := []Shape{r, c} // Iterate over the shapes and print their area and perimeter. for _, shape := range shapes { fmt.Println(\"Area:\", shape.Area()) fmt.Println(\"Perimeter:\", shape.Perimeter()) fmt.Println(\"\") } } ▶ اجرای کد کپی ✖ بستن خروجی در کد فوق ما یک اینترفیس Shape داریم که ۲ تا متد Area و Perimeter داریم که مساحت و محیط را محاسبه می کند. در ادامه ۲ ساختار Rectangle و Circle داریم که برای این ساختارها متدهای اینترفیس Shape را پیاده سازی کردیم و در نهایت اندازه مساحت و محیط را محاسبه می کنیم.\n"},{"id":71,"href":"/chapter-4/tracing/","title":"4.24 آموزش tracing","section":"فصل چهارم: مباحث پیشرفته","content":"در این فصل، این مورد را یاد خواهیم گرفت که چگونه یک برنامه در حال اجرا را ردیابی کنیم و آن را با ابزار ردیابی مشاهده کنیم. در این حالت با استفاده از کتابخانه استاندارد، یک ردیابی ایجاد خواهیم کرد.\n4.24.1 مثال از tracing # ما برنامه ای داریم که تعداد دفعات یافتن یک topic را در collection ای ازRSS news feed document را می شمارد. این برنامه از یک threaded algorithm به نام freq استفاده می کند که روی collection تکرار می شود و هر سند را یک به یک پردازش می کند و تعداد دفعاتی که topic پیدا شده است را برمی‌گرداند.\nfunc freq(topic string, docs []string) int { var found int for _, doc := range docs { file := fmt.Sprintf(\"%s.xml\", doc[:8]) f, err := os.OpenFile(file, os.O_RDONLY, 0) if err != nil { log.Printf(\"Opening Document [%s] : ERROR : %v\", doc, err) return 0 } data, err := io.ReadAll(f) f.Close() if err != nil { log.Printf(\"Reading Document [%s] : ERROR : %v\", doc, err) return 0 } var d document if err := xml.Unmarshal(data, \u0026d); err != nil { log.Printf(\"Decoding Document [%s] : ERROR : %v\", doc, err) return 0 } for _, item := range d.Channel.Items { if strings.Contains(item.Title, topic) { found++ continue } if strings.Contains(item.Description, topic) { found++ } } } return found } ▶ اجرای کد کپی ✖ بستن خروجی تابع Freq کار را به چهار مرحله تقسیم می کند: باز کردن، خواندن، باز کردن و جستجو. برای تست تابع freq، تابع main مجموعه ای از فایل های 4k را می سازد و freq را فراخوانی می کند.\npackage main import ( \"encoding/xml\" \"fmt\" \"log\" ) type ( item struct { XMLName xml.Name `xml:\"item\"` Title string `xml:\"title\"` Description string `xml:\"description\"` } channel struct { XMLName xml.Name `xml:\"channel\"` Items []item `xml:\"item\"` } document struct { XMLName xml.Name `xml:\"rss\"` Channel channel `xml:\"channel\"` } ) func main() { docs := make([]string, 4000) for i := range docs { docs[i] = fmt.Sprintf(\"newsfeed-%.4d.xml\", i) } topic := \"president\" n := freq(topic, docs) log.Printf(\"Searching %d files, found %s %d times.\", len(docs), topic, n) } ▶ اجرای کد کپی ✖ بستن خروجی کدی که تکه‌ای از اسناد 4k را می‌سازد، مجموعه‌ای از فایل‌های منحصربه‌فرد را براساس یک فایل واقعی که ما newfeed.xml نامیده‌ایم ایجاد می‌کند.\nnewsfeed.xml \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;?xml-stylesheet title=\u0026quot;XSL_formatting\u0026quot; type=\u0026quot;text/xsl\u0026quot;?\u0026gt; \u0026lt;rss\u0026gt; \u0026lt;channel\u0026gt; \u0026lt;title\u0026gt;\u0026lt;![CDATA[BBC News - US \u0026amp; Canada]]\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;description\u0026gt;\u0026lt;![CDATA[BBC News - US \u0026amp; Canada]]\u0026gt;\u0026lt;/description\u0026gt; \u0026lt;item\u0026gt; \u0026lt;title\u0026gt;\u0026lt;![CDATA[President China visit: US leader strik]]\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;description\u0026gt;\u0026lt;![CDATA[The US president praises]]\u0026gt;\u0026lt;/description\u0026gt; \u0026lt;/item\u0026gt; \u0026lt;/channel\u0026gt; \u0026lt;/rss\u0026gt; این یک نمونه بسیار کوچک از فایل newsfeed.xml است. به جای اینکه فایل های واقعی 4k را نگه داریم، فقط یک فایل را نگه می داریم و تلاش می کنیم که 4k یکی از آنها را نشان دهد. الگوریتم freq کاراکترهای اضافی را از نام فایل، قبل از باز کردن فایل حذف می کند. خوب است که یک ایده اولیه از مدت زمان لازم برای پردازش این 4000 فایل با نسخه تک رشته ای Freq داشته باشید. پس می توانیم این کار را با استفاده از time command در ارتباط با اجرای برنامه انجام دهیم.\n$ go build $ time ./trace 2021/05/12 09:30:52 Searching 4000 files, found president 28000 times. ./trace 2.63s user 0.18s system 101% cpu 2.763 total می بینیم که زمان اجرای برنامه حدود 2.7 ثانیه طول کشید تا فایل های 4k را پردازش کند. اگر قرار بود فقط فایل‌های 4k یا شاید حتی چند هزار فایل دیگر را پردازش کنیم، این برنامه تکمیل شده و تمام بود. با این حال، در نظر داریم که توانایی پردازش یک میلیون فایل را داشته باشیم و تجزیه و تحلیل آن ساعت‌ها طول نکشد. پس باید راهی برای افزایش سرعت این برنامه پیدا کنیم. در واقع می‌توانیم از یک memory profile استفاده کنیم، هر چند که این برنامه از memory گذرا زیادی استفاده می‌کند و کار زیادی نمی‌توانیم در مورد آن انجام دهیم. پس می‌توانیم از یک cpu profile استفاده کنیم. این روش به در واقع بیان می‌کند که به لطف فراخوانی با os.OpenFile، بیشتر زمان را در فراخوانی و رخدادهای سیستمی مصرف می‌کنیم. مشکل استفاده از profiler در اینجا این است که یک profiler فقط می تواند بگوید که چه اتفاقی می افتد ولی باید بدانیم چه چیزی اتفاقی می افتد و چه چیزی اتفاق نمی افتد تا راهی برای سرعت بخشیدن به این برنامه پیدا کنیم. وقتی باید ببینیم چه اتفاقی نیافتاده، ابزار ردیابی گزینه خوبی است.\n4.24.2 Generating Traces # از آنجایی که این برنامه در عرض چند ثانیه شروع و متوقف می شود، می توانیم از کتابخانه استاندارد برای ایجاد ردی از این برنامه استفاده کنم. به طور کلی، ایجاد ردیابی برای بیش از چند ثانیه از زمان اجرا می‌تواند برای بررسی سخت باشد، زیرا یک ردیابی مقدار زیادی داده تولید می‌کند. ما می خواهیم بر روی ردپاهای کوچک و هدفمند تمرکز کنیم.\npackage main import ( \"fmt\" \"log\" \"os\" \"runtime/trace\" //\u003c-- ADDED ) func main() { trace.Start(os.Stdout) // \u003c-- ADDED defer trace.Stop() // \u003c-- ADDED docs := make([]string, 4000) for i := range docs { docs[i] = fmt.Sprintf(\"newsfeed-%.4d.xml\", i) } topic := \"president\" n := freq(topic, docs) log.Printf(\"Search %d files, found %s %d times.\", len(docs), topic, n) } ▶ اجرای کد کپی ✖ بستن خروجی پس از افزودن بسته trace به importها، می توانیم از توابع trace.Start و Stop استفاده کنیم. نوشتن ردیابی در stdout گرفتن و تغییر مسیر داده های ردیابی به یک فایل را ساده می کند. حالا می توانم دوباره برنامه را اجرا کنیم.\n$ go build $ time ./trace \u0026gt; t.out 2021/05/12 11:57:06 Search 4000 files, found president 28000 times. ./trace \u0026gt; t.out 2.71s user 0.19s system 102% cpu 2.827 total $ time ./trace \u0026gt; t.out 2021/05/12 11:57:11 Search 4000 files, found president 28000 times. ./trace \u0026gt; t.out 2.73s user 0.18s system 108% cpu 2.683 total $ ls -l total 9136 -rw-r--r-- 1 bill staff 2108 Jan 4 08:16 README.md -rw-r--r-- 1 bill staff 25544 Jan 4 08:16 newsfeed.xml -rw-r--r-- 1 bill staff 1501618 May 12 11:57 t.out -rwxr-xr-x 1 bill staff 2470208 May 12 11:57 trace -rw-r--r-- 1 bill staff 8135 May 12 11:56 trace.go ما همیشه برنامه را دو بار اجرا می کنیم تا مطمئن شوم دستگاه گرم شده است. اجرای دوم معمولا بهتر از اولین اجرا می شود و من می توانم 144 میلی ثانیه تفاوت بین این دو اجرا ببینم. همچنین می‌توانم ببینم که فایل t.out در فهرست، 1.5 مگ داده در طول 2.6 ثانیه زمان اجرا گرفته است.\n4.24.3 Generating Traces # برای بررسی ردیابی، باید از ابزار ردیابی استفاده کنم.\n$ go tool trace t.out 2021/05/12 12:00:19 Parsing trace... 2021/05/12 12:00:19 Splitting trace... 2021/05/12 12:00:19 Opening browser. Trace viewer is listening on http://127.0.0.1:64321 پس از تجزیه و تقسیم فایل، یک برگه مرورگر با مجموعه ای از linkها باز می شود.\nحالا می‌خواهیم اولین link را انتخاب کنیم که یک رابط کاربری مبتنی بر Chrome را باز می‌کند که می‌تواند داده‌های ردیابی را ارائه دهد. این ابزار فقط در کروم کار می کند.\nتمام اطلاعاتی که ارائه می شود تا میکروثانیه زمان وقوع آن ثبت می شود. در سمت چپ، می توانیم دسته های مختلف اطلاعات نموداری را ببینم.\nدر هر زمان معین در ردیابی موارد زیر را داریم:\n● Goroutines: The number of Goroutines.\n● Heap: The amount of memory in-use on the heap.\n● Threads: The number of operating system threads.\n● GC: The start/end of each GC with details.\n● Syscalls: The start/end of any system call with details.\n● Procs: The activity on each logical processor.\nاولین کاری که باید انجام دهیم اندازه گیری مدت زمان اجرای برنامه بر اساس داده های ردیابی است. می‌توانیم این کار را با ابزار زمان بندی، که آخرین ابزار در toolbar است، انجام دهیم.\nاگرtimeline کل ردیابی را انتخاب کنیم، برابر 2.67 ثانیه خواهد بود که تقریباً به آنچه time command ارائه شده است نزدیک است. نکته بعدی که می‌خواهم بدانم این است که اندازه heap چقدر ثابت مانده است یا چقدر بزرگ‌تر شده است. برای این کار باید نمای نمودار را گسترش می دهیم و سپس از ابزار انتخاب (اولین ابزار در نوار ابزار) برای انتخاب قسمت بالای نمودار heap استفاده می کنبم.\nدو رنگ (یا سایه) وجود دارد که در نمودار heap نشان داده شده است. نارنجی (سایه تیره تر) میزان حافظه در حال استفاده روی heap را در هر میکروثانیه نشان می دهد. سبز (سایه روشن‌تر) نشان‌دهنده زمانی است که GC بعدی بر اساس زمانی که آن مقدار حافظه دوباره در heap مورد استفاده قرار می‌گیرد، راه‌اندازی می‌شود.\nبه همین دلیل است که وقتی ناحیه نارنجی به بالای منطقه سبز می رسد، یک خط در قسمت GC وجود دارد. هر خط نشان دهنده یک GC است که اتفاق افتاده است.\nاز آنجایی که ناحیه سبز در یک خط مستقیم ثابت برای کل اجرای برنامه است، می توانم هر نقطه نارنجی را برای دیدن حداکثر اندازه heap انتخاب کنیم. در این صورت اگر بخواهم در مورد این عدد وضوح بیشتری داشته باشم، می توانیم از GODEBUG استفاده کنیم و دوباره برنامه را اجرا کنیم.\n$ time GODEBUG=gctrace=1 ./trace \u0026gt; t.out gc 1 @0.016s 0%: 0.020+0.29+0.024 ms clock, 0.32+0.18/0.12/0.12+0.39 ms cpu, 4-\u0026gt;4-\u0026gt;0 MB, 5 MB goal, 16 P gc 2 @0.029s 0%: 0.030+0.23+0.002 ms clock, 0.49+0.15/0.17/0.001+0.037 ms cpu, 4-\u0026gt;4-\u0026gt;0 MB, 5 MB goal, 16 P gc 3 @0.040s 0%: 0.033+0.26+0.019 ms clock, 0.52+0.15/0.15/0.059+0.31 ms cpu, 4-\u0026gt;4-\u0026gt;0 MB, 5 MB goal, 16 P . . . gc 273 @2.793s 0%: 0.043+0.46+0.040 ms clock, 0.70+0.24/0.18/0.25+0.65 ms cpu, 4-\u0026gt;4-\u0026gt;0 MB, 5 MB goal, 16 P gc 274 @2.804s 0%: 0.043+0.35+0.002 ms clock, 0.69+0.28/0.37/0.16+0.042 ms cpu, 4-\u0026gt;4-\u0026gt;0 MB, 5 MB goal, 16 P gc 275 @2.814s 0%: 0.032+0.28+0.017 ms clock, 0.52+0.20/0.26/0.026+0.28 ms cpu, 4-\u0026gt;4-\u0026gt;0 MB, 5 MB goal, 16 P 2021/05/12 15:17:24 Searching 4000 files, found president 28000 times. اینطور به نظر می‌رسد که ، heap در meg 4 نگهداری می شد و تمام memory گذرا بوده است زیرا هر GC منجر به صفر بودن تعداد مقادیر زنده می شد. دقیقاً همان چیزی است که در ردیابی می بینیم. چیزی که واقعاً به آن نیاز داریم اطلاعات بیشتری در مورد GC است. این در مورد 1 GC نیست، بلکه در مورد همه GCهایی است که باید انجام شوند. پس می توانیم این اطلاعات را با استفاده از ابزار انتخاب و دوبار کلیک کردن روی هر خط آبی GC بدست بیاورم.\nاین اعداد در تعیین میزان کار GC در اجرای برنامه مفید هستند. با این اعداد ما یک پایه برای عملکرد برنامه داریم. با اعداد پایه، هنوز پاسخی در مورد اینکه چگونه می توانم برنامه را سرعت بخشم، نداریم. شاید نگاه کردن به بخش بزرگتری از نمودار کمک کند؟\n![[Pasted image 20230619032144.png]]\nاگر به این بخش از ردیابی دقیق تر نگاه کنیم، می توانیم مشکل را ببینیم. این برنامه فقط از یک پردازنده منطقی در هر زمان معین برای اجرای کار برنامه استفاده می کند. با این حال GC بیشتر منابع استفاده می کند. اگر الگوریتم را به صورت همزمان و friendly برای استفاده از تمام هسته‌های موجود در دستگاه خود تغییر دهیم، شاید این باید به بهبود performance کمک کند.\n4.24.4 الگوی Fan-Out # یکی از الگوهای concurrency که می‌توانم استفاده کنیم، الگوی fan-out است. این الگو به ما اجازه می دهد تا یک الگوریتم همزمان با کمترین مقدار تغییر کد داشته باشم. ایده این الگو این است که برای هر فایلی که نیاز به پردازش دارد، یک گوروتین ایجاد می‌کند و به scheduler اجازه می‌دهد تمام Goroutine را مدیریت کند و آنها را در تمام پردازنده‌های منطقی زمان‌بندی کند. ما می توانیم همه این گوروتین ها را fan-out کنیم زیرا ترتیب کار مهم نیست. مهم این است که همه چیز درست انجام شود.\nfunc freqConcurrent(topic string, docs []string) int { var found int g := len(docs) // \u0026lt;-- ADDED var wg sync.WaitGroup // \u0026lt;-- ADDED wg.Add(g) // \u0026lt;-- ADDED for _, doc := range docs { . . . } wg.Wait() //\u0026lt;-- ADDED return int } برای شروع، باید کدی اضافه کنیم که مطمئن شویم تا زمانی که کار کامل نشده است، تابع freq برنگردد. این به بهترین وجه با استفاده از WaitGroup پیاده سازی می شود. ما با شناسایی تعداد گوروتین هایی که باید ایجاد شوند شروع می کنیم، که با طول docs collection نشان داده می شود. سپس آن عدد را به WaitGroup اضافه می کنم و در پایان تابع منتظر می مانم تا WaitGroup دوباره به صفر برسد.\nfunc freqConcurrent(topic string, docs []string) int { var found int g := len(docs) var wg sync.WaitGroup wg.Add(g) for _, doc := range docs { go func(doc string) { // \u0026lt;-- ADDED defer wg.Done() // \u0026lt;-- ADDED . . . }(doc) // \u0026lt;-- ADDED } wg.Wait() return int } برای شروع، باید کدی اضافه کنیم که مطمئن شود تا زمانی که کار کامل نشده است، تابع freq برنگردد. این به بهترین وجه با استفاده از WaitGroup پیاده سازی می شود. من با شناسایی تعداد گوروتین هایی که باید ایجاد شوند شروع می کنیم، که با طول مجموعه اسناد نشان داده می شود. سپس آن عدد را به WaitGroup اضافه می کنیم و در پایان تابع منتظر می مانم تا WaitGroup دوباره به صفر برسد.\nدر مرحله بعد، کد موجود را در داخل حلقه for range حول یک Goroutine می پیچیم، جایی که هر document تکرار شده به Goroutine جدید منتقل می شود تا از هرگونه اشکال بسته شدن جلوگیری شود. با وجود Goroutine، می‌توانیم کد WaitGroup را با اطمینان از اینکه هر Goroutine ()wg.Done را قبل از پایان آن فراخوانی می‌کند، نهایی کنیم. آخرین کاری که باید انجام دهیم این است که هنگام پردازش یک فایل، مقدار بازگشتی 0 را از تمام شرایط خطای داخل حلقه حذف کنیم. ممکن است فکر کنیم این کد آماده است زیرا تمام هماهنگی ها با WaitGroup در جای خود است، اما اگر این کد را با race detector اجرا کنیم چه اتفاقی می افتد؟\n$ go build -race $ ./trace \u0026gt; t.out ================== WARNING: DATA RACE Read at 0x00c000157548 by goroutine 21: main.freq.func1() /Users/bill/code/go/src/github.com/ardanlabs/gotraining/topics/go/ profiling/trace/trace.go:103 +0x644 Previous write at 0x00c000157548 by goroutine 66: main.freq.func1() /Users/bill/code/go/src/github.com/ardanlabs/gotraining/topics/go/ profiling/trace/trace.go:103 +0x65d . . . ================== دو خط اول در خروجی می گوید که یک خواندن و یک نوشتن قبلی در همان محل حافظه در همان خط کد در داخل تابع تحت اللفظی وجود دارد. با این وجود در خط 103 چه کدی وجود دارد؟\n96 for _, item := range d.Channel.Items { 97 if strings.Contains(item.Title, topic) { 98 found++ 99 continue 100 } 101 102 if strings.Contains(item.Description, topic) { 103 found++ 104 } 105 } اگر شماره خطوط را به کد اضافه کنیم، می توانیم ببیینم که مورد مربوط به افزایش متغیر پیدا شده است. این کد در واقع دوباره در خط 98 استفاده می شود، بنابراین هر دو خط کد (98، 103) حاوی یک data race است. برای رفع این data race، باید افزایش متغیر پیدا شده را برای استفاده از یک atomic instruction. تغییر دهیم. برای این کار می توانم از atomic package استفاده کنم.\n96 for _, item := range d.Channel.Items { 97 if strings.Contains(item.Title, topic) { 98 atomic.AddInt32(\u0026amp;found, 1) // \u0026lt;-- CHANGED 99 continue 100 } 101 102 if strings.Contains(item.Description, topic) { 103 atomic.AddInt32(\u0026amp;found, 1) // \u0026lt;-- CHANGED 104 } 105 } ما خطوط 98 و 103 را برای استفاده از تابع atomic.AddInt32 جایگزین کردم. مشکل این است که این تابع به int32 نیاز دارد نه int، بنابراین باید دو تغییر دیگر انجام دهم.\nfunc freq(topic string, docs []string) int { var found int32 // \u0026lt;-- CHANGED . . . wg.Wait() return int(found) // \u0026lt;-- CHANGED } این تغییرات برای استفاده از تابع atomic.AddInt32 و بازگرداندن یک عدد صحیح ضروری است. با این تغییرات، data race از بین خواهد رفت. با این حال، هنوز مشکل دیگری در مورد کد وجود دارد. اینکه آنقدرها هم که می‌توانست با حافظه پنهان سازگار نباشد.\n4.24.5 Cache Friendly # در حال تکمیل \u0026hellip;\n"},{"id":72,"href":"/chapter-4/profiling/","title":"4.25 آموزش profiling","section":"فصل چهارم: مباحث پیشرفته","content":"پروفایلینگ یک تکنیک مفید برای شناسایی گلوگاه‌های عملکرد ، بررسی مصرف حافظه و به دست آوردن بینش درباره سربار جمع‌آوری زباله (Garbage Collection) و موارد دیگر است. اکوسیستم Go ابزارهای فوق‌العاده‌ای برای این منظور ارائه می‌دهد. امکان فعال و غیرفعال کردن پروفایلینگ به ویژه هنگام رفع اشکال در یک برنامه CLI نوشته شده با Go بسیار مفید است.\nنقل و قول نویسنده:\nشاید profiling برای حال حاضر قابل اهمیت نباشد اما روزی خواهد رسید که در بخش هایی از پروژه دچار مصرف بیش از حد memory, CPU خواهید شد و اینجاس که profiling به شما کمک خواهد کرد سریز منابع را پیدا کنید.\nسعی کنید این مطلب را یاد بگیرید قطعا یک روزی با این موضوع مواجه خواهید شد.\nچه زمانی پروفایل کنیم؟\nموارد استفاده رایج پروفایلینگ عبارتند از:\nکشف گلوگاه‌های عملکرد و رفع آن‌ها برای بهبود عملکرد کلی یافتن تخصیص‌های اضافی حافظه و کاهش آن‌ها به منظور کاهش تاثیر منفی Garbage Collection بر عملکرد. سرریز یا نشت حافظه یا CPU در بلند مدت (نشت منابع وقتی مشخص می شود که سرویس شما برای مدت طولانی چند روز در حال اجرا باشد.) 4.25.1 مدل ذهنی (mental) برای Go # ممکن است بتوانید در نوشتن کد Go به مهارت بالایی برسید بدون اینکه درک دقیقی از نحوه عملکرد این زبان در پشت صحنه داشته باشید. اما وقتی به عملکرد و اشکال‌زدایی می‌رسیم، داشتن یک مدل ذهنی از جزئیات داخلی زبان به شدت به نفع شما خواهد بود. بنابراین، ابتدا یک مدل ابتدایی از Go را شرح می‌دهیم. این مدل به اندازه کافی خوب است که به شما کمک کند از اشتباهات رایج اجتناب کنید، اما تمامی مدل‌ها محدودیت دارند، بنابراین توصیه می‌شود که برای حل مشکلات پیچیده‌تر در آینده، به منابع تخصصی‌تر مراجعه کنید.\nوظیفه اصلی Go، مشابه یک سیستم‌عامل، این است که منابع سخت‌افزاری را چندوظیفه‌ای و انتزاعی کند. این کار عمدتاً با استفاده از دو انتزاع اصلی انجام می‌شود:\nزمان‌بند Goroutine: مدیریت نحوه اجرای کد شما بر روی پردازنده‌های سیستم. جمع‌آوری زباله (Garbage Collector): حافظه مجازی را فراهم می‌کند که به طور خودکار در صورت نیاز آزاد می‌شود. 4.25.1.1 زمان‌بند (scheduler) گوروتین # ابتدا با استفاده از مثال زیر در مورد زمان‌بند صحبت کنیم:\nfunc main() { res, err := http.Get(\u0026quot;https://example.org/\u0026quot;) if err != nil { panic(err) } fmt.Printf(\u0026quot;%d\\n\u0026quot;, res.StatusCode) } در اینجا یک goroutine واحد داریم که آن را G1 می‌نامیم و این goroutine تابع main را اجرا می‌کند. تصویر زیر یک خط زمانی ساده‌شده از نحوه اجرای این goroutine روی یک پردازنده را نشان می‌دهد. ابتدا G1 بر روی پردازنده اجرا می‌شود تا درخواست HTTP را آماده کند. سپس پردازنده بیکار می‌شود زیرا goroutine باید منتظر شبکه بماند. در نهایت، goroutine دوباره روی پردازنده زمان‌بندی می‌شود تا کد وضعیت را چاپ کند.\nاز دیدگاه زمان‌بند، برنامه بالا به این صورت اجرا می‌شود. ابتدا G1 در حال اجرا روی پردازنده 1 است. سپس goroutine از پردازنده خارج می‌شود و در حال انتظار برای شبکه قرار می‌گیرد. زمانی که زمان‌بند متوجه می‌شود شبکه پاسخ داده است (با استفاده از ورودی/خروجی غیرمسدودکننده، مشابه Node.js) گوروتین را به عنوان \u0026quot; آماده اجرا \u0026quot; علامت‌گذاری می‌کند. و به محض اینکه یک هسته پردازنده آزاد شود، goroutine دوباره شروع به اجرا می‌کند. در مثال ما تمام هسته‌ها در دسترس هستند، بنابراین G1 بلافاصله بدون صرف زمانی در حالت \u0026ldquo;آماده اجرا\u0026rdquo; می‌تواند به اجرای تابع fmt.Printf() بر روی یکی از پردازنده‌ها برگردد.\nدر اکثر مواقع، برنامه‌های Go چندین goroutine را به طور همزمان اجرا می‌کنند، بنابراین تعدادی از goroutineها در حال اجرای روی برخی از هسته‌های پردازنده هستند، تعداد زیادی از goroutineها به دلایل مختلف در حالت \u0026ldquo;انتظار\u0026rdquo; قرار دارند، و ایده‌آل این است که هیچ goroutineی در حالت \u0026ldquo;آماده اجرا\u0026rdquo; نباشد، مگر اینکه برنامه شما بار پردازشی بسیار بالایی بر روی پردازنده ایجاد کند. یک مثال از این حالت را می‌توان در زیر مشاهده کرد.\nالبته مدل بالا بسیاری از جزئیات را نادیده می‌گیرد. در واقعیت، زمان‌بند Go بر روی نخ‌هایی (threads) که توسط سیستم‌عامل مدیریت می‌شوند، کار می‌کند و حتی خود پردازنده‌ها نیز قادر به استفاده از هایپرتردینگ (hyper-threading) هستند که می‌توان آن را نوعی زمان‌بندی در نظر گرفت.\nبا این حال، مدل فوق باید برای درک بخش‌های باقی‌مانده از این راهنما کافی باشد. به طور خاص، باید روشن شود که زمان اندازه‌گیری‌شده توسط پروفایلرهای مختلف Go در اصل زمانی است که goroutineهای شما در حالت \u0026ldquo;اجرا\u0026rdquo; (Executing) و \u0026ldquo;انتظار\u0026rdquo; (Waiting) صرف می‌کنند، همان‌طور که در نمودار زیر نشان داده شده است.\n4.25.1.2 زباله جمع کن (Garbage Collector) # دیگر انتزاع مهم در Go، جمع‌آوری زباله (Garbage Collector) است. در زبان‌هایی مانند C، برنامه‌نویس باید به صورت دستی تخصیص و آزادسازی حافظه را با استفاده از malloc() و free() مدیریت کند. این رویکرد کنترل خوبی ارائه می‌دهد، اما در عمل بسیار مستعد خطا است. یک جمع‌آوری‌کننده زباله (GC) می‌تواند این بار را کاهش دهد، اما مدیریت خودکار حافظه ممکن است به راحتی به یک گلوگاه عملکرد تبدیل شود. این بخش از راهنما یک مدل ساده برای GC در Go ارائه می‌دهد که برای شناسایی و بهینه‌سازی مشکلات مربوط به مدیریت حافظه مفید خواهد بود.\nبرای یک راهنمای جامع‌تر درباره GC در Go، به مستندات رسمی مراجعه کنید.\n4.25.1.2.1 پشته (Stack) # با اصول اولیه شروع کنیم. Go می‌تواند حافظه را در یکی از دو مکان تخصیص دهد: پشته یا هیپ. هر goroutine پشته خاص خود را دارد که یک ناحیه پیوسته از حافظه است. علاوه بر این، یک ناحیه بزرگ از حافظه وجود دارد که بین goroutineها به اشتراک گذاشته می‌شود و به آن هیپ می‌گویند. این حالت را می‌توان در تصویر زیر مشاهده کرد.\nوقتی یک تابع تابع دیگری را فراخوانی می‌کند، یک بخش مخصوص روی پشته به آن اختصاص داده می‌شود که به آن «فریم پشته» (stack frame) می‌گویند و می‌تواند برای قرار دادن متغیرهای محلی از آن استفاده کند. یک اشاره‌گر پشته (stack pointer) برای شناسایی محل آزاد بعدی در فریم استفاده می‌شود. زمانی که یک تابع به پایان می‌رسد، داده‌های فریم قبلی به سادگی با بازگرداندن اشاره‌گر پشته به انتهای فریم قبلی حذف می‌شوند. داده‌های فریم همچنان می‌توانند در پشته باقی بمانند و با فراخوانی بعدی تابع بازنویسی شوند. این فرآیند بسیار ساده و کارآمد است زیرا Go نیازی به پیگیری هر متغیر ندارد.\nfunc main() { sum := 0 sum = add(23, 42) fmt.Println(sum) } func add(a, b int) int { return a + b } برای درک بهتر این موضوع، به مثال زیر توجه کنید:\nدر اینجا یک تابع main() داریم که با رزرو مقداری فضا روی پشته برای متغیر sum شروع می‌شود. وقتی تابع add() فراخوانی می‌شود، یک فریم مخصوص برای نگه داشتن پارامترهای محلی a و b به آن اختصاص داده می‌شود. پس از اتمام اجرای add()، داده‌های آن با بازگرداندن اشاره‌گر پشته به انتهای فریم تابع main() حذف می‌شوند و متغیر sum با نتیجه به‌روز می‌شود. در همین حال، مقادیر قدیمی تابع add() فراتر از اشاره‌گر پشته باقی می‌مانند تا با فراخوانی بعدی تابع بازنویسی شوند. در زیر یک تصویرسازی از این فرآیند آمده است:\nمثال بالا به شدت ساده شده است و بسیاری از جزئیات مانند مقادیر بازگشتی، اشاره‌گرهای فریم، آدرس‌های بازگشت و درون‌خطی‌سازی (inlining) توابع را حذف کرده است. در واقع، از نسخه Go 1.17 به بعد، ممکن است برنامه بالا نیازی به فضای پشته نداشته باشد، زیرا مقدار کم داده می‌تواند توسط کامپایلر با استفاده از ثبات‌های پردازنده (CPU registers) مدیریت شود. اما این مسئله مشکلی ایجاد نمی‌کند. این مدل همچنان به شما یک شهود معقول از نحوه تخصیص و حذف متغیرهای محلی در برنامه‌های پیچیده‌تر Go روی پشته می‌دهد.\nشاید در این مرحله این سوال برای شما پیش بیاید که چه اتفاقی می‌افتد اگر فضای پشته تمام شود. در زبان‌هایی مانند C، این موضوع باعث خطای سرریز پشته (stack overflow) می‌شود. اما در Go، این مشکل به صورت خودکار با ایجاد یک نسخه کپی از پشته که دو برابر بزرگتر است، مدیریت می‌شود. این قابلیت به goroutineها اجازه می‌دهد که با پشته‌های بسیار کوچک، معمولاً 2 کیلوبایت، شروع کنند و یکی از عوامل اصلی مقیاس‌پذیری بیشتر goroutineها نسبت به نخ‌های سیستم‌عامل همین موضوع است.\n4.25.1.2.2 هیپ (Heap) # تخصیص‌های پشته عالی هستند، اما در بسیاری از موارد Go نمی‌تواند از آن‌ها استفاده کند. رایج‌ترین حالت زمانی است که باید اشاره‌گری به یک متغیر محلی از یک تابع بازگردانده شود. این موضوع را می‌توان در نسخه اصلاح‌شده مثال تابع add() که در بالا آمد، مشاهده کرد:\nfunc main() { fmt.Println(*add(23, 42)) } func add(a, b int) *int { sum := a + b return \u0026amp;sum } در حالت عادی، Go می‌تواند متغیر sum را داخل تابع add() روی پشته تخصیص دهد. اما همانطور که یاد گرفتیم، این داده‌ها هنگام بازگشت تابع add() از بین می‌روند. بنابراین، برای بازگرداندن ایمن یک اشاره‌گر به \u0026amp;sum، Go باید حافظه را از خارج از پشته تخصیص دهد. اینجا است که هیپ وارد عمل می‌شود.\nهیپ برای ذخیره‌سازی داده‌هایی استفاده می‌شود که ممکن است پس از پایان اجرای تابع سازنده، همچنان مورد نیاز باشند، همچنین برای هر داده‌ای که بین goroutineها با استفاده از اشاره‌گرها به اشتراک گذاشته می‌شود. اما این سوال پیش می‌آید که چگونه این حافظه آزاد می‌شود؟ چون برخلاف تخصیص‌های پشته، تخصیص‌های هیپ را نمی‌توان به محض اتمام تابعی که آن‌ها را ایجاد کرده، حذف کرد.\nGo این مشکل را با استفاده از جمع‌آوری زباله داخلی (GC) خود حل می‌کند. جزئیات پیاده‌سازی آن بسیار پیچیده است، اما از یک دید کلی، GC حافظه شما را به این شکل مدیریت می‌کند. در تصویر زیر می‌بینید که سه goroutine دارای اشاره‌گرهایی به تخصیص‌های سبز رنگ روی هیپ هستند. برخی از این تخصیص‌ها همچنین به تخصیص‌های سبز دیگری اشاره می‌کنند. علاوه بر این، تخصیص‌های خاکستری وجود دارند که ممکن است به تخصیص‌های سبز یا یکدیگر اشاره کنند، اما خودشان توسط تخصیص‌های سبز مرجع نشده‌اند. این تخصیص‌ها زمانی قابل دسترس بودند، اما اکنون به عنوان زباله در نظر گرفته می‌شوند. این اتفاق ممکن است زمانی رخ دهد که تابعی که اشاره‌گرهای آن‌ها را روی پشته ایجاد کرده بود بازگردد، یا مقدارشان بازنویسی شده باشد. وظیفه GC این است که به صورت خودکار این تخصیص‌ها را شناسایی و آزاد کند.\nاجرای جمع‌آوری زباله (GC) شامل پیمایش گراف‌های پرهزینه و تخلیه کش (cache thrashing) است. این فرایند حتی نیاز به فازهای متوقف‌کننده کل جهان (stop-the-world) دارد که اجرای کل برنامه شما را متوقف می‌کند. خوشبختانه نسخه‌های اخیر Go این زمان را به کسری از یک میلی‌ثانیه کاهش داده‌اند، اما بسیاری از هزینه‌های باقی‌مانده ذاتاً به هر GC مربوط می‌شود. در واقع، معمولاً ۲۰ تا ۳۰ درصد از اجرای یک برنامه Go صرف مدیریت حافظه می‌شود.\nبه‌طور کلی، هزینه GC متناسب با مقدار تخصیص‌های هیپ (heap allocations) است که برنامه شما انجام می‌دهد. بنابراین وقتی صحبت از بهینه‌سازی هزینه‌های مرتبط با حافظه می‌شود، شعار این است:\nکاهش (Reduce): سعی کنید تخصیص‌های هیپ را به تخصیص‌های پشته تبدیل کنید یا از آن‌ها به‌طور کلی اجتناب کنید. کاهش تعداد اشاره‌گرها در هیپ نیز کمک می‌کند. بازاستفاده (Reuse): تخصیص‌های هیپ را دوباره استفاده کنید به جای اینکه آن‌ها را با تخصیص‌های جدید جایگزین کنید. بازیافت (Recycle): برخی از تخصیص‌های هیپ غیرقابل اجتناب هستند. بگذارید GC آن‌ها را بازیافت کند و بر روی مسائل دیگر تمرکز کنید. همانند مدل ذهنی قبلی در این راهنما، همه موارد بالا نمایی به شدت ساده شده از واقعیت است. اما امیدوارم که این مدل به اندازه کافی مفید باشد تا باقی‌مانده این راهنما را درک کنید و شما را به مطالعه مقالات بیشتری در این زمینه ترغیب کند.\n4.25.2 درک عمیق پروفایلرهای (Profilers) گو # در اینجا مروری بر پروفایلرهای ساخته‌شده در زمان اجرای Go (Go runtime) ارائه می‌شود. برای جزئیات بیشتر، به لینک‌ها مراجعه کنید.\nدر زیر جدول مربوط به پروفایلرهای مختلف موجود در Go ارائه شده است:\nویژگی CPU Memory Block Mutex Goroutine ThreadCreate Production Safety ✅ ✅ ⚠ (1.) ✅ ⚠️ (2.) 🐞 (3.) نرخ ایمنی default default ❌ (1.) 100 1000 goroutines - دقت ⭐️⭐️ ⭐⭐⭐ ⭐⭐⭐ ⭐⭐⭐ ⭐⭐⭐ - عمق حداکثر پشته 64 32 32 32 32 - 100 (4.) - برچسب‌های پروفایلر ✅ ❌ ❌ ❌ ✅ - پروفایلر بلوک (block profiler): اگر به درستی پیکربندی نشده باشد، پروفایلر بلوک می‌تواند منبع قابل توجهی از بار CPU باشد. توقف‌های جهانی (stop-the-world): یک توقف جهانیO(N) وجود دارد که N تعداد goroutineها است. انتظار می‌رود هر goroutine بین ~1-10 میکروثانیه توقف داشته باشد. پروفایلر ThreadCreate: این پروفایلر به طور کامل معیوب است و بهتر است از آن استفاده نکنید. عمق حداکثر پشته: این مورد به API وابسته است. 4.25.2.1 پروفایلر CPU # پروفایلر CPU در Go می‌تواند به شما کمک کند تا قسمت‌هایی از کد خود را که زمان CPU زیادی مصرف می‌کنند، شناسایی کنید.\n⚠️ توجه داشته باشید که زمان CPU معمولاً با زمان واقعی که کاربران شما تجربه می‌کنند (که به آن تاخیر می‌گویند) متفاوت است. به عنوان مثال، یک درخواست HTTP معمولاً ممکن است ۱۰۰ میلی‌ثانیه طول بکشد، اما تنها ۵ میلی‌ثانیه از زمان CPU را مصرف کند و ۹۵ میلی‌ثانیه را در انتظار پاسخ از پایگاه داده بگذراند. همچنین ممکن است یک درخواست ۱۰۰ میلی‌ثانیه طول بکشد، اما ۲۰۰ میلی‌ثانیه از زمان CPU را صرف کند اگر دو goroutine به طور همزمان کارهای پردازشی سنگین انجام دهند. اگر این موضوع برای شما گیج‌کننده است.\nشما می‌توانید پروفایلر CPU را از طریق APIهای مختلف کنترل کنید:\ngo test -cpuprofile cpu.pprof: این دستور تست‌های شما را اجرا کرده و پروفایل CPU را در فایلی به نام cpu.pprof می‌نویسد.\npprof.StartCPUProfile(w): این دستور پروفایل CPU را به w ضبط می‌کند و زمان را تا زمانی که pprof.StopCPUProfile() فراخوانی شود، پوشش می‌دهد.\nimport _ \u0026quot;net/http/pprof\u0026quot;: این کد به شما اجازه می‌دهد با درخواست GET به آدرس /debug/pprof/profile?seconds=30 از سرور HTTP پیش‌فرض که می‌توانید با استفاده از http.ListenAndServe(\u0026quot;localhost:6060\u0026quot;, nil) راه‌اندازی کنید، یک پروفایل CPU به مدت ۳۰ ثانیه درخواست کنید.\nruntime.SetCPUProfileRate(): این تابع به شما اجازه می‌دهد نرخ نمونه‌گیری پروفایلر CPU را کنترل کنید. برای محدودیت‌های فعلی به محدودیت‌های پروفایلر CPU مراجعه کنید.\nruntime.SetCgoTraceback(): این تابع می‌تواند برای دریافت ردیابی‌های پشته به کد cgo استفاده شود. benesch/cgosymbolizer یک پیاده‌سازی برای Linux و macOS دارد.\nاگر به یک قطعه کد سریع نیاز دارید که بتوانید در تابع main() خود قرار دهید، می‌توانید از کد زیر استفاده کنید:\nfile, _ := os.Create(\u0026quot;./cpu.pprof\u0026quot;) pprof.StartCPUProfile(file) defer pprof.StopCPUProfile() صرف نظر از اینکه چگونه پروفایلر CPU را فعال می‌کنید، پروفایل به‌دست‌آمده در اصل یک جدول از ردیابی‌های پشته است که به فرمت باینری pprof قالب‌بندی شده است. در زیر نسخه‌ای ساده‌شده از چنین جدولی نشان داده شده است:\nstack trace samples/count cpu/nanoseconds main;foo 5 50000000 main;foo;bar 3 30000000 main;foobar 4 40000000 پروفایلر CPU این داده‌ها را با درخواست از سیستم‌عامل برای نظارت بر استفاده از CPU برنامه جمع‌آوری می‌کند و هر ۱۰ میلی‌ثانیه که CPU زمانی را مصرف می‌کند، سیگنال SIGPROF را به آن ارسال می‌کند. همچنین سیستم‌عامل زمان صرف‌شده توسط کرنل به نمایندگی از برنامه را در این نظارت شامل می‌کند. از آنجا که نرخ تحویل سیگنال به مصرف CPU وابسته است، این نرخ دینامیک بوده و می‌تواند به حداکثر N * 100Hz برسد که در آن N تعداد هسته‌های منطقی CPU در سیستم است.\nهنگامی که سیگنال SIGPROF دریافت می‌شود، هندلر سیگنال Go یک ردیابی پشته از goroutine فعالی که در حال حاضر در حال اجرا است، جمع‌آوری می‌کند و مقادیر مربوطه در پروفایل را افزایش می‌دهد. مقدار cpu/nanoseconds در حال حاضر مستقیماً از تعداد نمونه‌ها مشتق می‌شود، بنابراین این مقدار تکراری است، اما راحت است.\n4.25.2.1.1 برچسب‌های پروفایلر (Profiler Labels) CPU # یکی از ویژگی‌های جالب پروفایلر CPU در Go این است که می‌توانید جفت‌های کلید و مقدار دلخواهی را به یک goroutine متصل کنید. این برچسب‌ها توسط هر goroutine‌ای که از آن goroutine متولد می‌شود، به ارث برده می‌شوند و در پروفایل نهایی نمایش داده می‌شوند.\nبیایید مثالی را در نظر بگیریم که برخی از کارهای CPU را به نمایندگی از یک کاربر انجام می‌دهد. با استفاده از API های pprof.Labels() و pprof.Do()، می‌توانیم کاربر را با goroutine که در حال اجرای تابع work() است، مرتبط کنیم. علاوه بر این، برچسب‌ها به‌طور خودکار توسط هر goroutine‌ای که در همان بلوک کد متولد می‌شود، به ارث برده می‌شوند، برای مثال goroutine backgroundWork().\nfunc work(ctx context.Context, user string) { labels := pprof.Labels(\u0026quot;user\u0026quot;, user) pprof.Do(ctx, labels, func(_ context.Context) { go backgroundWork() directWork() }) } پروفایل نهایی شامل یک ستون برچسب جدید خواهد بود و ممکن است به شکل زیر باشد:\nstack trace label samples/count cpu/nanoseconds main.backgroundWork user:bob 5 50000000 main.backgroundWork user:alice 2 20000000 main.work;main.directWork user:bob 4 40000000 main.work;main.directWork user:alice 3 30000000 مشاهده همان پروفایل با نمای گراف pprof نیز شامل برچسب‌ها خواهد بود:\nچگونگی استفاده از این برچسب‌ها به شما بستگی دارد. می‌توانید مواردی مانند شناسه‌های کاربری، شناسه‌های درخواست، نقاط پایانی HTTP، برنامه‌های اشتراک یا داده‌های دیگر را شامل کنید که به شما کمک می‌کند درک بهتری از اینکه کدام نوع درخواست‌ها باعث مصرف بالای CPU می‌شوند، حتی زمانی که توسط همان مسیرهای کد پردازش می‌شوند، به دست آورید. با این حال، استفاده از برچسب‌ها اندازه فایل‌های pprof شما را افزایش می‌دهد. بنابراین بهتر است با برچسب‌های با کاردینالیته پایین مانند نقاط پایانی شروع کنید و سپس به برچسب‌های با کاردینالیته بالا بروید، زمانی که احساس می‌کنید بر عملکرد برنامه شما تأثیر نمی‌گذارد.\n⚠️ نسخه‌های Go 1.17 و پایین‌تر حاوی چندین اشکال بودند که می‌توانستند منجر به عدم وجود برخی برچسب‌های پروفایلر در پروفایل‌های CPU شوند، برای اطلاعات بیشتر به محدودیت‌های پروفایلر CPU مراجعه کنید.\n4.25.2.1.2 مصرف CPU # از آنجایی که نرخ نمونه‌گیری پروفایلر CPU با توجه به مقدار CPU که برنامه شما مصرف می‌کند، تنظیم می‌شود، می‌توانید مصرف CPU را از پروفایل‌های CPU استخراج کنید. در واقع، pprof این کار را به طور خودکار برای شما انجام می‌دهد. به عنوان مثال، پروفایل زیر از برنامه‌ای استخراج شده است که دارای میانگین مصرف CPU برابر با 147.77% بود:\n$ go tool pprof guide/cpu-utilization.pprof Type: cpu Time: Sep 9, 2021 at 11:34pm (CEST) Duration: 1.12s, Total samples = 1.65s (147.77%) Entering interactive mode (type \u0026quot;help\u0026quot; for commands, \u0026quot;o\u0026quot; for options) (pprof) روش دیگری که برای بیان مصرف CPU محبوب است، استفاده از هسته‌های CPU است. در مثال بالا، برنامه به‌طور میانگین از 1.47 هسته CPU در طول دوره پروفایل‌سازی استفاده می‌کرد.\n⚠️ در نسخه‌های Go 1.17 و پایین‌تر، نباید به این عدد به خصوص اگر نزدیک یا بیشتر از 250% باشد، اعتماد زیادی داشته باشید. با این حال، اگر عدد بسیار پایینی مانند 10% مشاهده کردید، معمولاً نشان‌دهنده این است که مصرف CPU برای برنامه شما مشکلی نیست. یک اشتباه رایج این است که به این عدد توجه نکرده و نگران یک تابع خاص باشید که زمان زیادی نسبت به بقیه پروفایل صرف می‌کند. این معمولاً وقت تلف کردن است، زمانی که مصرف کلی CPU پایین است، زیرا از بهینه‌سازی این تابع چندان سودی نخواهید برد.\n4.25.2.1.3 فراخوانی‌های سیستم در پروفایل‌های CPU # اگر در پروفایل‌های CPU خود فراخوانی‌های سیستمی مانند syscall.Read() یا syscall.Write() را مشاهده کردید که زمان زیادی را صرف می‌کنند، لطفاً توجه داشته باشید که این فقط زمان CPU صرف شده در داخل این توابع در هسته است. زمان I/O خود به‌طور جداگانه پیگیری نمی‌شود. صرف زمان زیادی در فراخوانی‌های سیستمی معمولاً نشانه‌ای از انجام بیش از حد آن‌ها است، بنابراین شاید افزایش اندازه بافرها بتواند کمک کند. برای موقعیت‌های پیچیده‌تر مانند این، باید استفاده از Linux perf را در نظر بگیرید، زیرا می‌تواند stack trace های هسته را نیز به شما نشان دهد که ممکن است سرنخ‌های اضافی برای شما فراهم کند.\n4.25.2.1.4 محدودیت‌های پروفایلر CPU # چندین مشکل و محدودیت شناخته‌شده برای پروفایلر CPU وجود دارد که ممکن است بخواهید از آن‌ها آگاه باشید:\n🐞 GH #35057: پروفایل‌های CPU که با نسخه‌های Go \u0026lt;= 1.17 گرفته شده‌اند، به‌طور نسبی برای برنامه‌هایی که از بیش از 2.5 هسته CPU استفاده می‌کنند، دقت کمتری دارند. به‌طور کلی، استفاده کلی از CPU به‌طور نادرست گزارش می‌شود و پیک‌های بارکاری ممکن است به‌درستی در پروفایل حاصل نمایان نشوند. این مشکل در Go 1.18 برطرف شده است. در عین حال، می‌توانید از Linux perf به‌عنوان یک راه‌حل موقت استفاده کنید.\n🐞 برچسب‌های پروفایلر در Go \u0026lt;= 1.17 از چندین باگ رنج می‌بردند.\nGH #48577 و CL 367200: برچسب‌ها برای goroutineهایی که بر روی استک سیستم، کد C را اجرا می‌کنند یا فراخوانی‌های سیستمی را انجام می‌دهند، گم شده بودند. CL 369741: اولین دسته از نمونه‌ها در یک پروفایل CPU دارای خطای off-by-one بودند که باعث نسبت‌گذاری نادرست برچسب‌ها می‌شد. CL 369983: سیستم goroutineهایی که به نمایندگی از goroutineهای کاربر ایجاد شده‌اند (مثلاً برای جمع‌آوری زباله) به‌طور نادرست برچسب‌های والدین خود را به ارث بردند. ⚠️️ می‌توانید از runtime.SetCPUProfileRate() برای تنظیم نرخ پروفایلر CPU قبل از فراخوانی runtime.StartCPUProfile() استفاده کنید. این عمل یک هشدار را چاپ می‌کند که می‌گوید runtime: cannot set cpu profile rate until previous profile has finished. با این حال، این عمل هنوز در چارچوب محدودیت‌های باگ ذکر شده عمل می‌کند. این مسئله ابتدا در اینجا مطرح شد و یک پیشنهاد پذیرفته شده برای بهبود API وجود دارد.\n⚠️ حداکثر تعداد فراخوانی‌های تو در توی تابعی که می‌تواند در stack trace ها توسط پروفایلر CPU ضبط شود، در حال حاضر 64 است. اگر برنامه شما از الگوهایی مانند بازگشت عمیق یا دیگر الگوهایی استفاده کند که به عمق استک بالایی منجر می‌شود، پروفایل CPU شما شامل stack trace هایی خواهد بود که برش داده شده‌اند. این به این معناست که شما بخشی از زنجیرهٔ فراخوانی که به تابعی که در زمان نمونه‌برداری فعال بود، منجر شده، را از دست خواهید داد.\n4.25.2.2 پروفایلر حافظه (Memory) # پروفایلر حافظه در Go می‌تواند به شما کمک کند تا شناسایی کنید کدام بخش‌های کد شما دارای تعداد زیادی تخصیصات حافظه در هیپ (heap) هستند و همچنین چند تا از این تخصیصات در آخرین جمع‌آوری زباله (garbage collection) هنوز در دسترس بودند. به همین دلیل، پروفایل تولید شده توسط پروفایلر حافظه معمولاً به‌عنوان پروفایل هیپ نیز شناخته می‌شود.\nمدیریت حافظه هیپ معمولاً مسئول حدود 20-30% از زمان CPU مصرفی توسط فرآیندهای Go است. علاوه بر این، حذف تخصیصات هیپ می‌تواند تأثیرات ثانویه‌ای داشته باشد که بخش‌های دیگر کد شما را به‌دلیل کاهش مقدار هدر رفت کش (cache thrashing) که در هنگام اسکن هیپ توسط جمع‌آورنده زباله (garbage collector) رخ می‌دهد، سریع‌تر می‌کند. به این معنی که بهینه‌سازی تخصیص‌های حافظه می‌تواند معمولاً بازگشت بهتری نسبت به بهینه‌سازی مسیرهای کد وابسته به CPU در برنامه شما داشته باشد.\n⚠️ پروفایلر حافظه تخصیصات استک را نشان نمی‌دهد زیرا این‌ها به‌طور کلی بسیار ارزان‌تر از تخصیصات هیپ هستند. برای اطلاعات بیشتر به بخش جمع‌آورنده زباله مراجعه کنید.\nشما می‌توانید پروفایلر حافظه را از طریق API های مختلف کنترل کنید:\ngo test -memprofile mem.pprof تست‌های شما را اجرا می‌کند و پروفایل حافظه را در فایلی به نام mem.pprof می‌نویسد. pprof.Lookup(\u0026quot;allocs\u0026quot;).WriteTo(w, 0) پروفایل حافظه‌ای که شامل رویدادهای تخصیص از زمان شروع فرآیند است را به w می‌نویسد. import _ \u0026quot;net/http/pprof\u0026quot; به شما امکان می‌دهد که یک پروفایل حافظه 30 ثانیه‌ای با فراخوانی GET /debug/pprof/allocs?seconds=30 از سرور HTTP پیش‌فرض که می‌توانید با http.ListenAndServe(\u0026quot;localhost:6060\u0026quot;, nil) راه‌اندازی کنید، درخواست کنید. این پروفایل به‌طور داخلی به عنوان پروفایل دلتا (delta profile) شناخته می‌شود. runtime.MemProfileRate به شما اجازه می‌دهد تا نرخ نمونه‌برداری پروفایلر حافظه را کنترل کنید. برای محدودیت‌های کنونی به محدودیت‌های پروفایلر حافظه مراجعه کنید. اگر به یک قطعه کد سریع نیاز دارید که بتوانید آن را به تابع main() خود اضافه کنید، می‌توانید از کد زیر استفاده کنید:\nfile, _ := os.Create(\u0026quot;./mem.pprof\u0026quot;) defer pprof.Lookup(\u0026quot;allocs\u0026quot;).WriteTo(file, 0) defer runtime.GC() صرف نظر از اینکه چگونه پروفایلر حافظه را فعال کنید، پروفایل حاصل اساساً یک جدول از ردیابی‌های پشته است که به فرمت باینری pprof فرمت‌بندی شده است. نسخه‌ای ساده‌شده از چنین جدولی در زیر نشان داده شده است:\nstack trace alloc_objects/count alloc_space/bytes inuse_objects/count inuse_space/bytes main;foo 5 120 2 48 main;foo;bar 3 768 0 0 main;foobar 4 512 1 128 یک پروفایل حافظه شامل دو بخش اصلی اطلاعات است:\nalloc_*: مقدار تخصیص‌هایی که برنامه شما از زمان شروع فرایند (یا دوره پروفایل‌گیری برای پروفایل‌های دلتا) انجام داده است. inuse_*: مقدار تخصیص‌هایی که برنامه شما انجام داده و در آخرین جمع‌آوری زباله (GC) همچنان قابل دسترسی بودند. شما می‌توانید از این اطلاعات برای مقاصد مختلف استفاده کنید. به عنوان مثال، می‌توانید از داده‌های alloc_* برای تعیین اینکه کدام مسیرهای کد ممکن است زباله زیادی تولید کنند که GC باید با آن برخورد کند، استفاده کنید. همچنین بررسی داده‌های inuse_* در طول زمان می‌تواند به شما در بررسی نشت حافظه یا استفاده بالای حافظه توسط برنامه‌تان کمک کند.\n4.25.2.2.1 تفاوت پروفایل‌های Allocations و Heap # تابع pprof.Lookup() و همچنین بسته [net/http/pprof](https://pkg.go.dev/net/http/pprof) پروفایل حافظه را تحت دو نام مختلف عرضه می‌کنند: allocs و heap. هر دو پروفایل شامل داده‌های یکسانی هستند، تنها تفاوت این است که پروفایل allocs به عنوان نوع نمونه پیش‌فرض alloc_space/bytes را دارد، در حالی که پروفایل heap به طور پیش‌فرض inuse_space/bytes را انتخاب می‌کند. این موضوع توسط ابزار pprof برای تصمیم‌گیری درباره نوع نمونه‌ای که باید به طور پیش‌فرض نشان داده شود، استفاده می‌شود.\n4.25.2.2.2 نمونه‌برداری (Sampling) پروفایل حافظه # برای حفظ بار کم، پروفایل حافظه از نمونه‌برداری پواسون استفاده می‌کند تا به طور متوسط فقط یک تخصیص از هر 512KiB باعث شود که یک ردیابی پشته گرفته شده و به پروفایل اضافه شود. با این حال، قبل از اینکه پروفایل به فایل نهایی pprof نوشته شود، زمان‌اجرا مقادیر نمونه جمع‌آوری شده را با تقسیم بر احتمال نمونه‌برداری مقیاس می‌دهد. این بدان معناست که مقدار تخصیص‌های گزارش شده باید تخمینی خوب از مقدار واقعی تخصیص‌ها باشد، صرف‌نظر از نرخ runtime.MemProfileRate که استفاده می‌کنید.\nبرای پروفایل‌گیری در محیط تولید، معمولاً نیازی به تغییر نرخ نمونه‌برداری نیست. تنها دلیلی که برای این کار وجود دارد، نگرانی درباره این است که در شرایطی که تخصیص‌های بسیار کمی انجام می‌شود، ممکن است تعداد کافی نمونه‌ها جمع‌آوری نشود.\n4.25.2.2.3 Memory Inuse در مقابل RSS # یک اشتباه رایج این است که مقدار کل حافظه گزارش‌شده توسط نوع نمونه inuse_space/bytes را با مقدار استفاده از حافظه RSS که توسط سیستم‌عامل گزارش می‌شود مقایسه کنید و متوجه شوید که این دو با هم مطابقت ندارند. دلایل مختلفی برای این عدم تطابق وجود دارد:\nبه‌طور تعریف شده، RSS شامل مواردی بیشتر از فقط استفاده از حافظه پشته Go است، مانند حافظه استفاده شده توسط پشته‌های گوروتین‌ها، فایل اجرایی برنامه، کتابخانه‌های مشترک و همچنین حافظه تخصیص یافته توسط توابع C. GC (جمع‌کننده زباله) ممکن است تصمیم بگیرد که حافظه آزاد را فوراً به سیستم‌عامل بازنگرداند، اما بعد از تغییرات زمان‌اجرا در Go 1.16 این موضوع کمتر مشکل‌ساز شده است. Go از GC غیرمتحرک استفاده می‌کند، بنابراین در برخی موارد، حافظه آزاد پشته ممکن است به گونه‌ای تکه‌تکه شود که مانع از بازگشت آن به سیستم‌عامل شود. 4.25.2.2.4 پیاده‌سازی پروفایلر حافظه # کد زیر باید جنبه‌های اساسی پیاده‌سازی پروفایلر حافظه را پوشش دهد تا شما درک بهتری از آن داشته باشید. همانطور که مشاهده می‌کنید، تابع malloc() در داخل زمان‌اجرای Go از تابع poisson_sample(size) برای تعیین این که آیا باید یک تخصیص نمونه‌گیری شود یا خیر استفاده می‌کند. اگر جواب مثبت باشد، یک دنباله پشته (stack trace) به نام s گرفته می‌شود و به عنوان کلید در mem_profile (یک نقشه هش) استفاده می‌شود تا شمارنده‌های allocs و alloc_bytes افزایش یابند. علاوه بر این، فراخوانی track_profiled(object, s)، شیء تخصیص یافته را به عنوان یک تخصیص نمونه‌گیری شده در پشته علامت‌گذاری می‌کند و دنباله پشته s را با آن مرتبط می‌سازد.\nfunc malloc(size): object = ... // allocation magic if poisson_sample(size): s = stacktrace() mem_profile[s].allocs++ mem_profile[s].alloc_bytes += size track_profiled(object, s) return object هنگامی که GC (جمع‌آوری زباله‌ها) تعیین می‌کند که زمان آزادسازی یک شیء تخصیص یافته فرا رسیده است، تابع sweep() را فراخوانی می‌کند که از is_profiled(object) استفاده می‌کند تا بررسی کند آیا شیء به عنوان یک شیء نمونه‌گیری شده علامت‌گذاری شده است یا خیر. اگر جواب مثبت باشد، دنباله پشته s که منجر به تخصیص شده بود بازیابی می‌شود و شمارنده‌های frees و free_bytes برای آن داخل mem_profile افزایش می‌یابد.\nfunc sweep(object): if is_profiled(object) s = alloc_stacktrace(object) mem_profile[s].frees++ mem_profile[s].free_bytes += sizeof(object) // deallocation magic شمارنده‌های free_* به‌طور مستقیم در پروفایل نهایی حافظه گنجانده نمی‌شوند. در عوض، از آن‌ها برای محاسبه شمارنده‌های inuse_* در پروفایل از طریق کم کردن ساده‌ی frees از allocs استفاده می‌شود. همچنین، مقادیر خروجی نهایی با تقسیم آن‌ها بر احتمال نمونه‌گیری مقیاس‌بندی می‌شوند.\n4.25.2.2.5 محدودیت‌های پروفایلر حافظه # چندین مشکل و محدودیت شناخته‌شده برای پروفایلر حافظه وجود دارد که باید از آن‌ها آگاه باشید:\n🐞 GH #49171: پروفایل‌های دلتا (که با مثلاً GET /debug/pprof/allocs?seconds=60 گرفته می‌شوند) ممکن است به دلیل یک باگ در هم‌نمادسازی مرتبط با closures داخلی در Go 1.17 شمارش تخصیص منفی را گزارش کنند. این مشکل در Go 1.18 رفع شده است. ⚠️ runtime.MemProfileRate باید فقط یک بار و در اسرع وقت در ابتدای اجرای برنامه تغییر داده شود؛ برای مثال در ابتدای تابع main(). تغییر این مقدار به‌صورت چندباره در طول اجرای برنامه باعث تولید پروفایل‌های نادرست خواهد شد. ⚠ هنگام عیب‌یابی نشتی‌های حافظه احتمالی، پروفایلر حافظه می‌تواند نشان دهد که این تخصیص‌ها کجا ایجاد شده‌اند، اما نمی‌تواند نشان دهد که کدام مراجع باعث زنده نگه‌داشتن آن‌ها هستند. چندین تلاش برای حل این مشکل انجام شده است، اما هیچ‌کدام با نسخه‌های اخیر Go کار نمی‌کنند. ⚠ برچسب‌های پروفایلر CPU یا مشابه آن توسط پروفایلر حافظه پشتیبانی نمی‌شوند. اضافه کردن این ویژگی به پیاده‌سازی فعلی سخت است زیرا می‌تواند منجر به نشتی حافظه در جدول هش داخلی داده‌های پروفایل حافظه شود. ⚠ تخصیص‌های انجام شده توسط کد C (cgo) در پروفایل حافظه نمایش داده نمی‌شوند. ⚠ داده‌های پروفایل حافظه ممکن است تا دو چرخه‌ی جمع‌آوری زباله قدیمی باشند. اگر نیاز به یک عکس فوری مداوم دارید، می‌توانید قبل از درخواست پروفایل حافظه، runtime.GC() را فراخوانی کنید. net/http/pprof از آرگومان ?gc=1 برای این منظور پشتیبانی می‌کند. ⚠ حداکثر تعداد توابع تو در تو که توسط پروفایلر حافظه در اثر فراخوانی ثبت می‌شوند، در حال حاضر 32 است. برای اطلاعات بیشتر در مورد این محدودیت، به محدودیت‌های پروفایلر CPU مراجعه کنید. ⚠ هیچ محدودیتی برای اندازه‌ی جدول هش داخلی که پروفایل حافظه را نگه‌ می‌دارد وجود ندارد. این جدول تا زمانی که تمام مسیرهای تخصیص کد شما را پوشش دهد، بزرگ می‌شود. این مسئله در عمل مشکل‌ساز نیست اما ممکن است به‌نظر برسد که مانند یک نشتی حافظه کوچک است اگر از میزان استفاده حافظه فرآیند خود نظارت کنید. 4.25.2.3 پروفایلر بلاک # پروفایلر بلاک در Go اندازه‌گیری می‌کند که چقدر زمان گوروتین‌های شما در حالت Off-CPU صرف می‌شود، در حالی که منتظر عملیات کانال و mutexهای ارائه‌شده توسط پکیج sync هستند. عملیات‌های Go زیر توسط پروفایلر بلاک کنترل می‌شوند:\nselect chan send chan receive semacquire (مثل Mutex.Lock، RWMutex.RLock، RWMutex.Lock، WaitGroup.Wait) notifyListWait (مثل Cond.Wait) ⚠️ پروفایل‌های بلاک شامل زمان انتظار روی I/O، خواب (Sleep)، GC و سایر حالات انتظار نیستند. همچنین رویدادهای مسدود کننده تا زمانی که کامل نشوند ثبت نمی‌شوند، بنابراین پروفایل بلاک نمی‌تواند برای اشکال‌زدایی از اینکه چرا یک برنامه Go در حال حاضر قفل کرده استفاده شود. برای این منظور، از پروفایلر گوروتین می‌توان استفاده کرد.\n4.25.2.3.1 کنترل پروفایلر بلاک با API‌های مختلف: # دستور go test -blockprofile block.pprof تست‌ها را اجرا کرده و پروفایلی از هر رویداد مسدودکننده در فایلی به نام block.pprof ذخیره می‌کند. تابع runtime.SetBlockProfileRate(rate) به شما اجازه می‌دهد نرخ نمونه‌گیری پروفایلر بلاک را کنترل کنید. دستور pprof.Lookup(\u0026quot;block\u0026quot;).WriteTo(w, 0) پروفایلی از رویدادهای مسدودکننده از ابتدای فرآیند تا کنون ایجاد می‌کند و در خروجی w می‌نویسد. دستور import _ \u0026quot;net/http/pprof\u0026quot; اجازه می‌دهد تا با استفاده از درخواست GET /debug/pprof/block?seconds=30 یک پروفایل بلاک 30 ثانیه‌ای درخواست کنید. 4.25.2.3.2 کد نمونه برای استفاده از پروفایلر بلاک در برنامه: # runtime.SetBlockProfileRate(100_000_000) // هشدار: می‌تواند باعث افزایش استفاده از CPU شود file, _ := os.Create(\u0026quot;./block.pprof\u0026quot;) defer pprof.Lookup(\u0026quot;block\u0026quot;).WriteTo(file, 0) صرف‌نظر از نحوه فعال کردن پروفایلر بلاک، پروفایل نهایی یک جدول از ردپاهای پشته خواهد بود که در فرمت باینری pprof فرمت شده است.\nstack trace contentions/count delay/nanoseconds main;foo;runtime.selectgo 5 867549417 main;foo;bar;sync.(*Mutex).Lock 3 453510869 main;foobar;runtime.chanrecv1 4 5351086 4.25.2.3.3 پیاده‌سازی پروفایلر بلاک # کد شبه زیر جنبه‌های اساسی از پیاده‌سازی پروفایلر بلاک را نشان می‌دهد تا درک بهتری از آن به شما بدهد. هنگام ارسال پیام به یک کانال، یعنی ch \u0026lt;- msg، Go تابع chansend() را در runtime فراخوانی می‌کند. اگر کانال برای دریافت پیام آماده باشد (ready())، عملیات send() بلافاصله انجام می‌شود. در غیر این صورت، پروفایلر بلاک زمان شروع رویداد مسدودکننده را ثبت می‌کند و از تابع wait_until_ready() استفاده می‌کند تا گوروتین از CPU خارج شود تا زمانی که کانال آماده شود. هنگامی که کانال آماده شد، مدت زمان مسدود شدن تعیین می‌شود و با استفاده از تابع random_sample() و نرخ نمونه‌گیری، بررسی می‌شود که آیا باید این رویداد مسدودکننده ثبت شود یا خیر. در صورت مثبت بودن پاسخ، ردپای پشته فعلی (stack trace) گرفته شده و به عنوان کلید درون نقشه هش block_profile استفاده می‌شود تا شمارنده‌های count و delay افزایش یابند. پس از آن، عملیات send() ادامه می‌یابد.\nfunc chansend(channel, msg): if ready(channel): send(channel, msg) return start = now() wait_until_ready(channel) // Off-CPU Wait duration = now() - start if random_sample(duration, rate): s = stacktrace() // note: actual implementation is a bit trickier to correct for bias block_profile[s].contentions += 1 block_profile[s].delay += duration send(channel, msg) تابع random_sample به این صورت عمل می‌کند. اگر پروفایلر بلاک فعال باشد، همه رویدادهایی که duration \u0026gt;= rate باشند ثبت می‌شوند و رویدادهای کوتاه‌تر با احتمال duration/rate ثبت می‌شوند.\nfunc random_sample(duration, rate): if rate \u0026lt;= 0 || (duration \u0026lt; rate \u0026amp;\u0026amp; duration/rate \u0026gt; rand(0, 1)): return false return true به عبارت دیگر، اگر نرخ (rate) را برابر 10,000 تنظیم کنید (واحد در اینجا نانوثانیه است)، همه رویدادهای مسدودکننده‌ای که 10 µsec یا بیشتر طول می‌کشند ثبت می‌شوند. علاوه بر این، 10% از رویدادهای با طول 1 µsec و 1% از رویدادهای با طول 100 نانوثانیه و\u0026hellip; نیز ثبت می‌شوند.\n4.25.2.3.4 تفاوت پروفایلر بلاک و پروفایلر Mutex # هر دو پروفایلر بلاک و mutex زمان انتظار روی mutexها را گزارش می‌دهند. تفاوت این است که پروفایلر بلاک زمان انتظار برای به دست آوردن Lock() را ثبت می‌کند، در حالی که پروفایلر mutex زمانی که گوروتین دیگری منتظر Unlock() است تا اجرا شود را ثبت می‌کند.\n4.25.2.3.5 محدودیت‌های پروفایلر بلاک # 🚨 پروفایلر بلاک می‌تواند باعث افزایش قابل توجه مصرف CPU در محیط تولید شود. توصیه می‌شود که تنها برای توسعه و تست استفاده شود. اگر نیاز به استفاده از آن در محیط تولید دارید، با نرخ بسیار بالا شروع کنید، مثلاً 100 میلیون، و تنها در صورت نیاز آن را کاهش دهید. ⚠ پروفایل‌های بلاک تنها شامل زیر مجموعه کوچکی از حالات انتظار Off-CPU هستند که یک گوروتین می‌تواند وارد آن‌ها شود. ⚠ حداکثر تعداد توابع تو در تو که می‌توانند در ردپاهای پشته توسط پروفایلر بلاک ثبت شوند، فعلاً برابر 32 است. ⚠ نقشه هش داخلی که پروفایل بلاک را نگه می‌دارد هیچ محدودیتی در اندازه ندارد. 4.25.2.4 پروفایلر Mutex # پروفایلر mutex زمانی را اندازه‌گیری می‌کند که گوروتین‌ها صرف مسدود کردن سایر گوروتین‌ها می‌کنند. به عبارتی، این پروفایلر منابع رقابت برای قفل‌ها را ثبت می‌کند. پروفایلر mutex می‌تواند رقابت ناشی از sync.Mutex و sync.RWMutex را ثبت کند.\n⚠️ پروفایل‌های mutex شامل سایر منابع رقابت مثل sync.WaitGroup، sync.Cond یا دسترسی به توصیف‌کننده‌های فایل نمی‌شوند. همچنین، رقابت mutex تا زمانی که mutex آزاد نشود، ثبت نمی‌شود. بنابراین، پروفایل mutex برای اشکال‌زدایی از دلیل معلق بودن برنامه Go قابل استفاده نیست؛ برای این کار می‌توانید از پروفایلر گوروتین استفاده کنید.\n4.25.2.4.1 کنترل پروفایلر Mutex # چندین API برای کنترل پروفایلر mutex در دسترس است:\ngo test -mutexprofile mutex.pprof تست‌ها را اجرا می‌کند و پروفایل mutex را در یک فایل با نام mutex.pprof می‌نویسد. runtime.SetMutexProfileRate(rate) به شما امکان می‌دهد نرخ نمونه‌گیری پروفایلر mutex را فعال و کنترل کنید. اگر نرخ نمونه‌گیری برابر با R تنظیم شود، به طور متوسط 1/R از رویدادهای رقابت mutex ثبت می‌شوند. اگر نرخ برابر 0 یا کمتر باشد، هیچ رویدادی ثبت نمی‌شود. pprof.Lookup(\u0026quot;mutex\u0026quot;).WriteTo(w, 0) پروفایل mutex را از شروع پردازش تا زمان نوشتن به w ثبت می‌کند. import _ \u0026quot;net/http/pprof\u0026quot; به شما امکان می‌دهد با ارسال درخواست به مسیر GET /debug/pprof/mutex?seconds=30 یک پروفایل 30 ثانیه‌ای از mutex‌ها دریافت کنید. 4.25.2.4.2 نمونه سریع استفاده از پروفایلر Mutex # اگر نیاز به کد سریع برای قرار دادن در تابع main() دارید، می‌توانید از کد زیر استفاده کنید:\nruntime.SetMutexProfileFraction(100) file, _ := os.Create(\u0026quot;./mutex.pprof\u0026quot;) defer pprof.Lookup(\u0026quot;mutex\u0026quot;).WriteTo(file, 0) پروفایل mutex به دست آمده در اصل جدولی از ردپای پشته‌ها (stack traces) خواهد بود که به صورت فرمت دودویی pprof ذخیره می‌شود.\nstack trace contentions/count delay/nanoseconds main;foo;sync.(*Mutex).Unlock 5 867549417 main;bar;baz;sync.(*Mutex).Unlock 3 453510869 main;foobar;sync.(*RWMutex).RUnlock 4 5351086 4.25.2.4.3 تفاوت پروفایل‌های Block و Mutex # پروفایل‌های block و mutex هر دو زمان انتظار روی mutex‌ها را ثبت می‌کنند، اما تفاوت در این است که پروفایل block زمانی که گوروتین در حال انتظار برای قفل شدن است را ثبت می‌کند، در حالی که پروفایل mutex زمانی که یک گوروتین قفل را در اختیار دارد و باعث جلوگیری از ادامه کار سایر گوروتین‌ها می‌شود، را ثبت می‌کند.\n4.25.2.4.4 پیاده‌سازی پروفایلر Mutex # پروفایلر mutex با ثبت زمانی که یک گوروتین تلاش می‌کند قفلی را بگیرد (مثلاً mu.Lock())، تا زمانی که گوروتین صاحب قفل آن را آزاد کند (مثلاً mu.Unlock())، کار می‌کند. ابتدا یک گوروتین semacquire() را برای گرفتن قفل فراخوانی می‌کند و اگر قفل در حال حاضر توسط گوروتین دیگری گرفته شده باشد، زمان شروع انتظار ثبت می‌شود. وقتی گوروتین صاحب قفل آن را با فراخوانی semrelease() آزاد می‌کند، گوروتین منتظر بررسی می‌شود و زمان انتظار آن محاسبه می‌گردد. در نهایت، اگر رویداد به صورت تصادفی برای ثبت انتخاب شود، زمان مسدودی به یک نقشه هش (hash map) اضافه می‌شود که کلید آن پشته فراخوانی گوروتین آزادکننده قفل است.\n4.25.2.4.5 محدودیت‌های پروفایلر Mutex # ⚠️ حداکثر تعداد فراخوانی‌های تو در تو که می‌توان در پشته فراخوانی‌های پروفایل mutex ثبت کرد، در حال حاضر 32 است. برای اطلاعات بیشتر درباره محدودیت‌های پروفایلر CPU، به مستندات مرتبط مراجعه کنید. ⚠️ هیچ محدودیتی برای اندازه نقشه هش داخلی که داده‌های پروفایل mutex را نگه می‌دارد وجود ندارد. این بدان معناست که اندازه آن تا زمانی که تمام مسیرهای مسدودکننده در کد شما پوشش داده شوند، رشد خواهد کرد. در عمل، این مشکل چندانی ایجاد نمی‌کند، اما ممکن است به عنوان یک نشت حافظه کوچک به نظر برسد. ⚠️ برچسب‌های پروفایلر CPU در پروفایل mutex پشتیبانی نمی‌شوند. اضافه کردن این ویژگی به پیاده‌سازی فعلی ممکن است باعث ایجاد نشت حافظه در نقشه هش داخلی که داده‌های پروفایل حافظه را نگه می‌دارد، شود. ⚠️ تعداد رقابت‌ها و زمان‌های تأخیر در یک پروفایل mutex بر اساس آخرین نرخ نمونه‌برداری تنظیم شده، تنظیم می‌شوند، نه در زمان نمونه‌برداری. در نتیجه، برنامه‌هایی که نرخ نمونه‌برداری پروفایل mutex را در میانه اجرای خود تغییر می‌دهند، ممکن است نتایج نادقیقی را مشاهده کنند. 4.25.2.5 پروفایلر Goroutine # در زمان اجرای Go، تمام گوروتین‌ها در یک آرایه ساده به نام allgs نگهداری می‌شوند. این آرایه شامل گوروتین‌های فعال و غیرفعال (مرده) است. گوروتین‌های مرده برای استفاده مجدد زمانی که گوروتین‌های جدید ایجاد می‌شوند، نگه داشته می‌شوند.\nGo دارای API‌های مختلفی برای بررسی گوروتین‌های فعال در allgs است که به همراه استک ترِیس و برخی دیگر از ویژگی‌های آنها اطلاعاتی ارائه می‌دهند. برخی از این API‌ها اطلاعات آماری ارائه می‌دهند، در حالی که برخی دیگر اطلاعات مربوط به هر گوروتین را به صورت جداگانه فراهم می‌کنند.\nعلیرغم تفاوت‌های بین این API‌ها، تعریف مشترک از گوروتین \u0026ldquo;فعال\u0026rdquo; به نظر می‌رسد که شامل موارد زیر باشد:\nگوروتین از بین رفته نباشد. گوروتین سیستمی یا گوروتین نهایی‌کننده نباشد. به عبارت دیگر، گوروتین‌هایی که در حال اجرا هستند و همچنین آنهایی که منتظر ورودی/خروجی (I/O)، قفل‌ها، کانال‌ها، برنامه‌ریزی و غیره هستند، همه به عنوان \u0026ldquo;فعال\u0026rdquo; در نظر گرفته می‌شوند، حتی اگر به نظر برسد که برخی از این حالت‌ها غیرفعال هستند.\n4.25.2.5.1 سربار (Overhead) # همه پروفایل‌گیری‌های گوروتین در Go نیاز به یک فاز متوقف‌سازی جهان (stop-the-world) به اندازه O(N) دارند، که در آن N تعداد گوروتین‌های تخصیص داده شده است. یک بنچمارک ساده نشان می‌دهد که جهان به طور تقریبی به ازای هر گوروتین حدود ~1µs متوقف می‌شود، وقتی از API runtime.GoroutineProfile() استفاده می‌شود. اما این مقدار ممکن است بسته به عواملی مانند عمق استک برنامه، تعداد گوروتین‌های مرده و غیره تغییر کند.\nبه طور کلی، برنامه‌هایی که بسیار حساس به تأخیر هستند و از هزاران گوروتین فعال استفاده می‌کنند، ممکن است بخواهند در پروفایل‌گیری گوروتین در محیط تولید با دقت بیشتری عمل کنند. با این حال، تعداد زیاد گوروتین‌ها و حتی شاید خود زبان Go ممکن است برای چنین برنامه‌هایی ایده‌ی مناسبی نباشد.\nبیشتر برنامه‌هایی که تعداد زیادی گوروتین ایجاد نمی‌کنند و می‌توانند چند میلی‌ثانیه تأخیر اضافی را تحمل کنند، نباید مشکلی با پروفایل‌گیری مستمر گوروتین در محیط تولید داشته باشند.\n4.25.2.5.2 ویژگی‌های گوروتین # گوروتین‌ها دارای بسیاری از ویژگی‌ها هستند که می‌توانند به اشکال‌زدایی برنامه‌های Go کمک کنند. موارد زیر جالب توجه هستند و به طرق مختلف از طریق API‌هایی که در ادامه این سند توضیح داده شده‌اند، در دسترس قرار دارند:\ngoid: شناسه‌ی یکتای گوروتین؛ گوروتین اصلی دارای شناسه 1 است. atomicstatus: وضعیت گوروتین، یکی از موارد زیر: idle: تازه تخصیص داده شده است. runnable: در صف اجرا، منتظر زمان‌بندی. running: در حال اجرا روی یک نخ (thread) سیستم‌عامل. syscall: مسدود شده در یک فراخوان سیستمی. waiting: توسط زمان‌بندی‌کننده متوقف شده، نگاه کنید به g.waitreason. dead: تازه خارج شده یا در حال دوباره‌سازی. copystack: استک در حال انتقال است. preempted: تازه از اجرا خودداری کرده است. waitreason: دلیلی که گوروتین در وضعیت waiting قرار دارد، مانند خواب، عملیات کانال، I/O، جمع‌آوری زباله (GC) و غیره. waitsince: زمان تقریبی که گوروتین وارد وضعیت waiting یا syscall شده است که توسط اولین GC بعد از شروع انتظار تعیین می‌شود. labels: مجموعه‌ای از کلید/مقدار برچسب‌های پروفایل‌گیر که می‌توانند به گوروتین‌ها متصل شوند. stack trace: تابعی که در حال اجراست و همچنین توابع فراخواننده آن. این به صورت خروجی متنی شامل نام فایل‌ها، نام توابع و شماره خطوط یا به صورت یک آرایه از آدرس‌های شمارنده برنامه (PCs) نمایش داده می‌شود. 🚧تحقیق بیشتر درباره این موضوع: آیا می‌توان متن تابع/فایل/خط را به PCs تبدیل کرد؟ gopc: آدرس شمارنده برنامه (PC) مربوط به فراخوانی go ... که باعث ایجاد این گوروتین شده است. این می‌تواند به فایل، نام تابع و شماره خط تبدیل شود. lockedm: نخی که این گوروتین به آن قفل شده است، در صورتی که وجود داشته باشد. 4.25.2.5.3 ماتریس ویژگی‌ها (Feature Matrix) # جدول ماتریس ویژگی‌های زیر به شما یک ایده کلی از دسترسی کنونی این ویژگی‌ها از طریق APIهای مختلف ارائه می‌دهد.\n4.25.2.5.4 APIها # runtime.Stack() / pprof.Lookup(debug=2)\nاین تابع خروجی متنی بدون ساختار بازمی‌گرداند که شامل استک (Stack) تمام گوروتین‌های فعال و ویژگی‌هایی که در ماتریس ویژگی‌ها ذکر شده است، می‌باشد.\nویژگی waitsince به عنوان nanotime() - gp.waitsince() بر حسب دقیقه نمایش داده می‌شود، اما تنها زمانی که مدت زمان بیش از 1 دقیقه باشد.\npprof.Lookup(debug=2) یک نام مستعار ساده‌شده برای استفاده از این پروفایل است. فراخوانی واقعی به این شکل است:\nprofile := pprof.Lookup(\u0026quot;goroutine\u0026quot;) profile.WriteTo(os.Stdout, 2) پیاده‌سازی پروفایل به سادگی runtime.Stack() را فراخوانی می‌کند.\nدر زیر مثالی کوتاه از خروجی بازگردانده شده آمده است.\ngoroutine 1 [running]: main.glob..func1(0x14e5940, 0xc0000aa7b0, 0xc000064eb0, 0x2) /Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:29 +0x6f main.writeProfiles(0x2, 0xc0000c4008, 0x1466424) /Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:106 +0x187 main.main() /Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:152 +0x3d2 goroutine 22 [sleep, 1 minutes]: time.Sleep(0x3b9aca00) /usr/local/Cellar/go/1.15.6/libexec/src/runtime/time.go:188 +0xbf main.shortSleepLoop() /Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:165 +0x2a created by main.indirectShortSleepLoop2 /Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:185 +0x35 goroutine 3 [IO wait, 1 minutes]: internal/poll.runtime_pollWait(0x1e91e88, 0x72, 0x0) /usr/local/Cellar/go/1.15.6/libexec/src/runtime/netpoll.go:222 +0x55 internal/poll.(*pollDesc).wait(0xc00019e018, 0x72, 0x0, 0x0, 0x1465786) /usr/local/Cellar/go/1.15.6/libexec/src/internal/poll/fd_poll_runtime.go:87 +0x45 internal/poll.(*pollDesc).waitRead(...) /usr/local/Cellar/go/1.15.6/libexec/src/internal/poll/fd_poll_runtime.go:92 internal/poll.(*FD).Accept(0xc00019e000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0) /usr/local/Cellar/go/1.15.6/libexec/src/internal/poll/fd_unix.go:394 +0x1fc net.(*netFD).accept(0xc00019e000, 0x7d667d63cbbded3e, 0x1789ccbbded3e, 0x100000001) /usr/local/Cellar/go/1.15.6/libexec/src/net/fd_unix.go:172 +0x45 net.(*TCPListener).accept(0xc000188060, 0x60006709, 0xc000196da8, 0x109abe6) /usr/local/Cellar/go/1.15.6/libexec/src/net/tcpsock_posix.go:139 +0x32 net.(*TCPListener).Accept(0xc000188060, 0xc000196df8, 0x18, 0xc000001200, 0x12e9eec) /usr/local/Cellar/go/1.15.6/libexec/src/net/tcpsock.go:261 +0x65 net/http.(*Server).Serve(0xc00019c000, 0x14ec6e0, 0xc000188060, 0x0, 0x0) /usr/local/Cellar/go/1.15.6/libexec/src/net/http/server.go:2937 +0x266 net/http.(*Server).ListenAndServe(0xc00019c000, 0xc00019c000, 0x1475536) /usr/local/Cellar/go/1.15.6/libexec/src/net/http/server.go:2866 +0xb7 net/http.ListenAndServe(...) /usr/local/Cellar/go/1.15.6/libexec/src/net/http/server.go:3120 main.main.func1(0xc000032120) /Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:123 +0x126 created by main.main /Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:121 +0xc5 goroutine 4 [sleep, 1 minutes]: time.Sleep(0x3b9aca00) /usr/local/Cellar/go/1.15.6/libexec/src/runtime/time.go:188 +0xbf main.shortSleepLoop() /Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:165 +0x2a created by main.main /Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:130 +0x195 goroutine 5 [sleep, 1 minutes]: time.Sleep(0x34630b8a000) /usr/local/Cellar/go/1.15.6/libexec/src/runtime/time.go:188 +0xbf main.sleepLoop(0x34630b8a000) /Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:171 +0x2b created by main.main /Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:131 +0x1bc goroutine 6 [chan receive, 1 minutes]: main.chanReceiveForever() /Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:177 +0x4d created by main.main /Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:132 +0x1d4 goroutine 24 [select, 1 minutes]: net/http.(*persistConn).writeLoop(0xc0000cea20) /usr/local/Cellar/go/1.15.6/libexec/src/net/http/transport.go:2340 +0x11c created by net/http.(*Transport).dialConn /usr/local/Cellar/go/1.15.6/libexec/src/net/http/transport.go:1709 +0xcdc goroutine 23 [IO wait, 1 minutes]: internal/poll.runtime_pollWait(0x1e91da0, 0x72, 0x14e6ca0) /usr/local/Cellar/go/1.15.6/libexec/src/runtime/netpoll.go:222 +0x55 internal/poll.(*pollDesc).wait(0xc00010e198, 0x72, 0x14e6c00, 0x16db878, 0x0) /usr/local/Cellar/go/1.15.6/libexec/src/internal/poll/fd_poll_runtime.go:87 +0x45 internal/poll.(*pollDesc).waitRead(...) /usr/local/Cellar/go/1.15.6/libexec/src/internal/poll/fd_poll_runtime.go:92 internal/poll.(*FD).Read(0xc00010e180, 0xc000256000, 0x1000, 0x1000, 0x0, 0x0, 0x0) /usr/local/Cellar/go/1.15.6/libexec/src/internal/poll/fd_unix.go:159 +0x1a5 net.(*netFD).Read(0xc00010e180, 0xc000256000, 0x1000, 0x1000, 0x103b1dc, 0xc000199b58, 0x10680e0) /usr/local/Cellar/go/1.15.6/libexec/src/net/fd_posix.go:55 +0x4f net.(*conn).Read(0xc000010008, 0xc000256000, 0x1000, 0x1000, 0x0, 0x0, 0x0) /usr/local/Cellar/go/1.15.6/libexec/src/net/net.go:182 +0x8e net/http.(*persistConn).Read(0xc0000cea20, 0xc000256000, 0x1000, 0x1000, 0xc00009e300, 0xc000199c58, 0x10074b5) /usr/local/Cellar/go/1.15.6/libexec/src/net/http/transport.go:1887 +0x77 bufio.(*Reader).fill(0xc0001801e0) /usr/local/Cellar/go/1.15.6/libexec/src/bufio/bufio.go:101 +0x105 bufio.(*Reader).Peek(0xc0001801e0, 0x1, 0x0, 0x0, 0x1, 0x0, 0xc0001d0060) /usr/local/Cellar/go/1.15.6/libexec/src/bufio/bufio.go:139 +0x4f net/http.(*persistConn).readLoop(0xc0000cea20) /usr/local/Cellar/go/1.15.6/libexec/src/net/http/transport.go:2040 +0x1a8 created by net/http.(*Transport).dialConn /usr/local/Cellar/go/1.15.6/libexec/src/net/http/transport.go:1708 +0xcb7 goroutine 41 [IO wait, 1 minutes]: internal/poll.runtime_pollWait(0x1e91cb8, 0x72, 0x14e6ca0) /usr/local/Cellar/go/1.15.6/libexec/src/runtime/netpoll.go:222 +0x55 internal/poll.(*pollDesc).wait(0xc00019e098, 0x72, 0x14e6c00, 0x16db878, 0x0) /usr/local/Cellar/go/1.15.6/libexec/src/internal/poll/fd_poll_runtime.go:87 +0x45 internal/poll.(*pollDesc).waitRead(...) /usr/local/Cellar/go/1.15.6/libexec/src/internal/poll/fd_poll_runtime.go:92 internal/poll.(*FD).Read(0xc00019e080, 0xc000326000, 0x1000, 0x1000, 0x0, 0x0, 0x0) /usr/local/Cellar/go/1.15.6/libexec/src/internal/poll/fd_unix.go:159 +0x1a5 net.(*netFD).Read(0xc00019e080, 0xc000326000, 0x1000, 0x1000, 0x203000, 0x203000, 0x203000) /usr/local/Cellar/go/1.15.6/libexec/src/net/fd_posix.go:55 +0x4f net.(*conn).Read(0xc000186028, 0xc000326000, 0x1000, 0x1000, 0x0, 0x0, 0x0) /usr/local/Cellar/go/1.15.6/libexec/src/net/net.go:182 +0x8e net/http.(*connReader).Read(0xc00007c300, 0xc000326000, 0x1000, 0x1000, 0x100000006, 0x10, 0x1819408) /usr/local/Cellar/go/1.15.6/libexec/src/net/http/server.go:798 +0x1ad bufio.(*Reader).fill(0xc000290060) /usr/local/Cellar/go/1.15.6/libexec/src/bufio/bufio.go:101 +0x105 bufio.(*Reader).ReadSlice(0xc000290060, 0xa, 0x1819408, 0xc000337988, 0x100f6d0, 0xc000110000, 0x100) /usr/local/Cellar/go/1.15.6/libexec/src/bufio/bufio.go:360 +0x3d bufio.(*Reader).ReadLine(0xc000290060, 0xc000110000, 0x1079694, 0xc0001a4000, 0x0, 0x1010038, 0x30) /usr/local/Cellar/go/1.15.6/libexec/src/bufio/bufio.go:389 +0x34 net/textproto.(*Reader).readLineSlice(0xc000182300, 0xc000110000, 0x10d7c4d, 0xc00019e080, 0x1068000, 0xc000282900) /usr/local/Cellar/go/1.15.6/libexec/src/net/textproto/reader.go:58 +0x6c net/textproto.(*Reader).ReadLine(...) /usr/local/Cellar/go/1.15.6/libexec/src/net/textproto/reader.go:39 net/http.readRequest(0xc000290060, 0x0, 0xc000110000, 0x0, 0x0) /usr/local/Cellar/go/1.15.6/libexec/src/net/http/request.go:1012 +0xaa net/http.(*conn).readRequest(0xc0000c6320, 0x14ed4a0, 0xc000322000, 0x0, 0x0, 0x0) /usr/local/Cellar/go/1.15.6/libexec/src/net/http/server.go:984 +0x19a net/http.(*conn).serve(0xc0000c6320, 0x14ed4a0, 0xc000322000) /usr/local/Cellar/go/1.15.6/libexec/src/net/http/server.go:1851 +0x705 created by net/http.(*Server).Serve /usr/local/Cellar/go/1.15.6/libexec/src/net/http/server.go:2969 +0x36c pprof.Lookup(debug=1)\nاین روش پروفایل‌گیری مشابه pprof.Lookup(debug=2) فراخوانی می‌شود، اما داده‌های کاملاً متفاوتی تولید می‌کند:\nبه جای لیست کردن هر گوروتین به صورت جداگانه، گوروتین‌هایی با استک و برچسب‌های یکسان فقط یک بار همراه با تعداد آنها لیست می‌شوند. برچسب‌های pprof در این حالت گنجانده می‌شوند، در حالی که debug=2 آنها را شامل نمی‌شود. بیشتر ویژگی‌های دیگر گوروتین که در debug=2 وجود دارند، در اینجا وجود ندارند. فرمت خروجی همچنان به صورت متنی است، اما ظاهری بسیار متفاوت نسبت به debug=2 دارد. در زیر یک نمونه کوتاه از خروجی برگردانده شده آورده شده است.\ngoroutine profile: total 9 2 @ 0x103b125 0x106cd1f 0x13ac44a 0x106fd81 # labels: {\u0026quot;test_label\u0026quot;:\u0026quot;test_value\u0026quot;} #\t0x106cd1e\ttime.Sleep+0xbe\t/usr/local/Cellar/go/1.15.6/libexec/src/runtime/time.go:188 #\t0x13ac449\tmain.shortSleepLoop+0x29\t/Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:165 1 @ 0x103b125 0x10083ef 0x100802b 0x13ac4ed 0x106fd81 # labels: {\u0026quot;test_label\u0026quot;:\u0026quot;test_value\u0026quot;} #\t0x13ac4ec\tmain.chanReceiveForever+0x4c\t/Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:177 1 @ 0x103b125 0x103425b 0x106a1d5 0x10d8185 0x10d91c5 0x10d91a3 0x11b8a8f 0x11cb72e 0x12df52d 0x11707c5 0x117151d 0x1171754 0x1263c2c 0x12d96ca 0x12d96f9 0x12e09ba 0x12e5085 0x106fd81 #\t0x106a1d4\tinternal/poll.runtime_pollWait+0x54\t/usr/local/Cellar/go/1.15.6/libexec/src/runtime/netpoll.go:222 #\t0x10d8184\tinternal/poll.(*pollDesc).wait+0x44\t/usr/local/Cellar/go/1.15.6/libexec/src/internal/poll/fd_poll_runtime.go:87 #\t0x10d91c4\tinternal/poll.(*pollDesc).waitRead+0x1a4\t/usr/local/Cellar/go/1.15.6/libexec/src/internal/poll/fd_poll_runtime.go:92 #\t0x10d91a2\tinternal/poll.(*FD).Read+0x182\t/usr/local/Cellar/go/1.15.6/libexec/src/internal/poll/fd_unix.go:159 #\t0x11b8a8e\tnet.(*netFD).Read+0x4e\t/usr/local/Cellar/go/1.15.6/libexec/src/net/fd_posix.go:55 #\t0x11cb72d\tnet.(*conn).Read+0x8d\t/usr/local/Cellar/go/1.15.6/libexec/src/net/net.go:182 #\t0x12df52c\tnet/http.(*connReader).Read+0x1ac\t/usr/local/Cellar/go/1.15.6/libexec/src/net/http/server.go:798 #\t0x11707c4\tbufio.(*Reader).fill+0x104\t/usr/local/Cellar/go/1.15.6/libexec/src/bufio/bufio.go:101 #\t0x117151c\tbufio.(*Reader).ReadSlice+0x3c\t/usr/local/Cellar/go/1.15.6/libexec/src/bufio/bufio.go:360 #\t0x1171753\tbufio.(*Reader).ReadLine+0x33\t/usr/local/Cellar/go/1.15.6/libexec/src/bufio/bufio.go:389 #\t0x1263c2b\tnet/textproto.(*Reader).readLineSlice+0x6b\t/usr/local/Cellar/go/1.15.6/libexec/src/net/textproto/reader.go:58 #\t0x12d96c9\tnet/textproto.(*Reader).ReadLine+0xa9\t/usr/local/Cellar/go/1.15.6/libexec/src/net/textproto/reader.go:39 #\t0x12d96f8\tnet/http.readRequest+0xd8\t/usr/local/Cellar/go/1.15.6/libexec/src/net/http/request.go:1012 #\t0x12e09b9\tnet/http.(*conn).readRequest+0x199\t/usr/local/Cellar/go/1.15.6/libexec/src/net/http/server.go:984 #\t0x12e5084\tnet/http.(*conn).serve+0x704\t/usr/local/Cellar/go/1.15.6/libexec/src/net/http/server.go:1851 ... pprof.Lookup(debug=0)\nاین روش پروفایل‌گیری دقیقاً مانند pprof.Lookup(debug=1) فراخوانی می‌شود و همان داده‌ها را تولید می‌کند. تنها تفاوت این است که فرمت داده‌ها به صورت پروتکل بافر pprof است.\nدر زیر یک نمونه کوتاه از خروجی برگشتی که توسط go tool pprof -raw گزارش شده است آورده شده است.\nPeriodType: goroutine count Period: 1 Time: 2021-01-14 16:46:23.697667 +0100 CET Samples: goroutine/count 2: 1 2 3 test_label:[test_value] 1: 1 4 5 6 test_label:[test_value] 1: 1 7 8 9 10 11 12 13 14 15 16 17 18 19 20 1: 1 7 8 9 10 11 12 21 14 22 23 test_label:[test_value] 1: 1 7 8 9 24 25 26 27 28 29 30 1: 1 31 32 test_label:[test_value] 1: 1 2 33 test_label:[test_value] 1: 34 35 36 37 38 39 40 41 test_label:[test_value] Locations 1: 0x103b124 M=1 runtime.gopark /usr/local/Cellar/go/1.15.6/libexec/src/runtime/proc.go:306 s=0 2: 0x106cd1e M=1 time.Sleep /usr/local/Cellar/go/1.15.6/libexec/src/runtime/time.go:188 s=0 3: 0x13ac449 M=1 main.shortSleepLoop /Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:165 s=0 4: 0x10083ee M=1 runtime.chanrecv /usr/local/Cellar/go/1.15.6/libexec/src/runtime/chan.go:577 s=0 5: 0x100802a M=1 runtime.chanrecv1 /usr/local/Cellar/go/1.15.6/libexec/src/runtime/chan.go:439 s=0 6: 0x13ac4ec M=1 main.chanReceiveForever /Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/goroutine/main.go:177 s=0 ... Mappings 1: 0x0/0x0/0x0 [FN] runtime.GoroutineProfile()\nاین تابع در واقع یک slice از تمام گوروتین‌های فعال و trace استک فعلی آنها را برمی‌گرداند. استک ترِیس‌ها به صورت آدرس‌های برنامه ارائه می‌شوند که می‌توان آنها را با استفاده از تابع runtime.CallersFrames() به نام‌های توابع ترجمه کرد.\nاین روش توسط fgprof برای پیاده‌سازی پروفایل‌گیری دیوار ساعت استفاده می‌شود.\nویژگی‌های زیر در حال حاضر در دسترس نیستند، اما ممکن است برای پیشنهاد به پروژه Go در آینده جالب باشند:\nشامل کردن ویژگی‌های گوروتین‌هایی که هنوز در دسترس نیستند، به خصوص برچسب‌ها. فیلتر کردن بر اساس برچسب‌های pprof، این کار می‌تواند stop-the-world را کاهش دهد، اما نیاز به نگهداری اضافی توسط runtime خواهد داشت. محدود کردن تعداد گوروتین‌های بازگشتی به یک زیرمجموعه تصادفی، که می‌تواند stop-the-world را کاهش دهد و ممکن است پیاده‌سازی آن نسبت به فیلتر بر اساس برچسب آسان‌تر باشد. در زیر یک مثال کوتاه از خروجی بازگشتی آورده شده است.\n[ { \u0026quot;Stack0\u0026quot;: [ 20629256, 20629212, 20627047, 20628306, 17018153, 17235329, ... ] }, { \u0026quot;Stack0\u0026quot;: [ 17019173, 17222943, 20628554, 17235329, ... ] }, ... ] net/http/pprof\nاین پکیج پروفایل‌های توصیف‌شده در بخش pprof.Lookup(\u0026quot;goroutine\u0026quot;) را از طریق endpointهای HTTP فراهم می‌کند. خروجی دقیقاً همان چیزی است که در روش‌های دیگر دیده می‌شود.\n4.25.2.5.5 تاریخچه # پروفایل‌گیری گوروتین توسط Russ Cox پیاده‌سازی شد و برای اولین بار در نسخه weekly.2012-02-22 پیش از انتشار go1 ظاهر شد.\n4.25.2.6 پروفایلر ThreadCreate # 🐞 پروفایل threadcreate برای نمایش استک ترِیس‌هایی طراحی شده که منجر به ایجاد نخ‌های (threads) جدید سیستم‌عامل شده‌اند. با این حال، از سال ۲۰۱۳ خراب شده است، بنابراین بهتر است از آن دوری کنید.\n4.25.3 آموزش کار با ابزار go pprof # پروفایلرهای مختلف داخلی در Go برای کار با ابزار بصری‌سازی pprof طراحی شده‌اند. pprof خود یک پروژه غیررسمی از گوگل است که برای تحلیل داده‌های پروفایل‌گیری از برنامه‌های C++، Java و Go طراحی شده است. این پروژه یک فرمت پروتکل بافر را تعریف می‌کند که توسط تمام پروفایلرهای Go استفاده می‌شود و در این سند توضیح داده شده است.\nپروژه Go خود یک نسخه از pprof را به‌همراه دارد که می‌توان آن را از طریق دستور go tool pprof فراخوانی کرد. این ابزار تا حد زیادی با ابزار اصلی مشابه است، به‌جز چند تغییر جزئی. Go توصیه می‌کند که برای کار با پروفایل‌های Go همیشه از go tool pprof به‌جای ابزار اصلی استفاده شود.\n4.25.3.1 ویژگی‌ها # ابزار pprof دارای یک رابط خط فرمان تعاملی است، اما همچنین یک رابط کاربری وب و گزینه‌های مختلف فرمت خروجی دیگر نیز دارد.\n4.25.3.2 فرمت فایل # فرمت pprof در تعریف پروتکل بافر profile.proto تعریف شده است که شامل نظرات مفیدی است. علاوه بر این، یک README رسمی برای آن وجود دارد. فایل‌های pprof همیشه با فشرده‌سازی gzip در دیسک ذخیره می‌شوند.\nیک تصویر به اندازه هزار کلمه می‌ارزد، بنابراین در زیر یک تجسم خودکار تولید شده از این فرمت قرار داده شده است. لطفاً توجه داشته باشید که فیلدهایی مانند filename اشاره‌گرهایی به string_table هستند که در تجسم نشان داده نمی‌شوند و بهبودهای این حوزه خوش‌آمد است!\n4.25.3.3 فرمت داده‌های pprof # فرمت داده‌های pprof به نظر می‌رسد که برای کارایی، زبان‌های مختلف و انواع پروفایل‌های مختلف (CPU، Heap و غیره) طراحی شده است، اما به دلیل این موضوع، بسیار انتزاعی و پر از اشاره‌گری است. اگر می‌خواهید جزئیات کامل را مشاهده کنید، به لینک‌های بالا مراجعه کنید. اگر به دنبال خلاصه‌ای مختصر هستید، ادامه دهید:\nیک فایل pprof شامل فهرستی از پشته‌های تراشه است که به آن‌ها نمونه‌ها گفته می‌شود و یک یا چند مقدار عددی با آن‌ها مرتبط است. برای یک پروفایل CPU، مقدار ممکن است مدت زمان CPU در نانوثانیه باشد که پشته تراشه در طول پروفایل‌سازی مشاهده شده است. برای یک پروفایل Heap، ممکن است تعداد بایت‌های تخصیص‌یافته باشد. نوع‌های مقداری خود در ابتدای فایل توصیف شده و برای پر کردن فهرست \u0026ldquo;نمونه\u0026rdquo; در رابط کاربری pprof استفاده می‌شوند. علاوه بر مقادیر، هر پشته تراشه می‌تواند شامل مجموعه‌ای از برچسب‌ها نیز باشد. برچسب‌ها زوج‌های کلید-مقدار هستند و حتی می‌توانند شامل واحد نیز باشند. در Go، این برچسب‌ها برای برچسب‌های پروفایلر استفاده می‌شوند.\nاین پروفایل همچنین شامل زمان (در UTC) است که پروفایل ثبت شده و مدت زمان ضبط را نشان می‌دهد.\nعلاوه بر این، فرمت امکان استفاده از عبارات منظم drop/keep برای حذف یا شامل کردن برخی از پشته‌های تراشه را فراهم می‌کند، اما آن‌ها توسط Go استفاده نمی‌شوند. همچنین فضایی برای فهرستی از نظرات (توسط Go نیز استفاده نمی‌شود) و توصیف فاصله دوره‌ای که در آن نمونه‌ها گرفته شده‌اند وجود دارد.\nکد تولید خروجی pprof در Go در runtime/pprof/proto.go موجود است.\n4.25.3.4 رمزگشایی (Decoding) # در زیر تعدادی ابزار برای رمزگشایی فایل‌های pprof به خروجی متنی قابل خواندن انسان آورده شده است. آن‌ها بر اساس پیچیدگی فرمت خروجی خود مرتب شده‌اند، به طوری که ابزارهایی که خروجی ساده‌تری ارائه می‌دهند ابتدا فهرست شده‌اند:\n4.25.3.5 استفاده از pprofutils # pprofutils ابزاری کوچک برای تبدیل بین فایل‌های pprof و فرمت متنی جمع شده Brendan Gregg است (folded text). می‌توانید از آن به صورت زیر استفاده کنید:\n$ pprof2text \u0026lt; examples/cpu/pprof.samples.cpu.001.pb.gz golang.org/x/sync/errgroup.(*Group).Go.func1;main.run.func2;main.computeSum 19 golang.org/x/sync/errgroup.(*Group).Go.func1;main.run.func2;main.computeSum;runtime.asyncPreempt 5 runtime.mcall;runtime.gopreempt_m;runtime.goschedImpl;runtime.schedule;runtime.findrunnable;runtime.stopm;runtime.notesleep;runtime.semasleep;runtime.pthread_cond_wait 1 runtime.mcall;runtime.park_m;runtime.schedule;runtime.findrunnable;runtime.checkTimers;runtime.nanotime;runtime.nanotime1 1 runtime.mcall;runtime.park_m;runtime.schedule;runtime.findrunnable;runtime.stopm;runtime.notesleep;runtime.semasleep;runtime.pthread_cond_wait 2 runtime.mcall;runtime.park_m;runtime.resetForSleep;runtime.resettimer;runtime.modtimer;runtime.wakeNetPoller;runtime.netpollBreak;runtime.write;runtime.write1 7 runtime.mstart;runtime.mstart1;runtime.sysmon;runtime.usleep 3 4.25.3.6 استفاده از go tool pprof # خود pprof دارای یک حالت خروجی به نام -raw است که محتوای یک فایل pprof را نمایش می‌دهد. با این حال، باید توجه داشت که این حالت آنچنان -raw نیست که می‌توان به آن رسید، به protoc زیر نگاه کنید:\n$ go tool pprof -raw examples/cpu/pprof.samples.cpu.001.pb.gz PeriodType: cpu nanoseconds Period: 10000000 Time: 2021-01-08 17:10:32.116825 +0100 CET Duration: 3.13 Samples: samples/count cpu/nanoseconds 19 190000000: 1 2 3 5 50000000: 4 5 2 3 1 10000000: 6 7 8 9 10 11 12 13 14 1 10000000: 15 16 17 11 18 14 2 20000000: 6 7 8 9 10 11 18 14 7 70000000: 19 20 21 22 23 24 14 3 30000000: 25 26 27 28 Locations 1: 0x1372f7f M=1 main.computeSum /Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/cpu/main.go:39 s=0 2: 0x13730f2 M=1 main.run.func2 /Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/cpu/main.go:31 s=0 3: 0x1372cf8 M=1 golang.org/x/sync/errgroup.(*Group).Go.func1 /Users/felix.geisendoerfer/go/pkg/mod/golang.org/x/sync@v0.0.0-20201207232520-09787c993a3a/errgroup/errgroup.go:57 s=0 ... Mappings 1: 0x0/0x0/0x0 [FN] 4.25.3.7 استفاده از protoc # برای کسانی که به دنبال دیدن داده‌ها نزدیک به ذخیره‌سازی باینری خام هستند، ما به کامپایلر پروتکل بافر protoc نیاز داریم. در macOS می‌توانید از brew install protobuf برای نصب آن استفاده کنید، برای سایر پلتفرم‌ها به بخش نصب README مراجعه کنید.\nحالا بیایید به همان پروفایل CPU از بالا نگاهی بیندازیم:\n$ gzcat examples/cpu/pprof.samples.cpu.001.pb.gz | protoc --decode perftools.profiles.Profile ./profile.proto sample_type { type: 1 unit: 2 } sample_type { type: 3 unit: 4 } sample { location_id: 1 location_id: 2 location_id: 3 value: 19 value: 190000000 } sample { location_id: 4 location_id: 5 location_id: 2 location_id: 3 value: 5 value: 50000000 } ... mapping { id: 1 has_functions: true } location { id: 1 mapping_id: 1 address: 20393855 line { function_id: 1 line: 39 } } location { id: 2 mapping_id: 1 address: 20394226 line { function_id: 2 line: 31 } } ... function { id: 1 name: 5 system_name: 5 filename: 6 } function { id: 2 name: 7 system_name: 7 filename: 6 } ... string_table: \u0026quot;\u0026quot; string_table: \u0026quot;samples\u0026quot; string_table: \u0026quot;count\u0026quot; string_table: \u0026quot;cpu\u0026quot; string_table: \u0026quot;nanoseconds\u0026quot; string_table: \u0026quot;main.computeSum\u0026quot; string_table: \u0026quot;/Users/felix.geisendoerfer/go/src/github.com/felixge/go-profiler-notes/examples/cpu/main.go\u0026quot; ... time_nanos: 1610122232116825000 duration_nanos: 3135113726 period_type { type: 3 unit: 4 } period: 10000000 این دستورات به ما این امکان را می‌دهند که ساختارهای ورودی و مقادیر خود را مشاهده کنیم، به ما کمک می‌کنند تا در نهایت فرمت را بهتر درک کنیم.\n4.25.3.8 استفاده از net/http/pprof پروفایلینگ ریموت # امکان دیباگ سرویس با استفاده از pprof برروی http.Server یا سایر وب سرورها. شما می توانید از پکیج net/http/pprof استفاده کنید اما دقت کنید ۲ مسئله وجود دارد باید در نظر بگیرید هنگام استفاده:\nزمانیکه این پکیج را در هر جایی از پروژه خود فراخوانی کنید تابع init() داخل پکیج اجرا می شود و خودکار به http.Handler سرور mux اضافه می شود و نیازی به ریجستر کردن handler نیست اما اگر web framework های دیگر را استفاده میکنید باید بصورت دستی استفاده کنید. امکان اینکه پکیج pprof قابلیت configuration شدن را داشته باشد ندارد و اطلاعات دیباگ خیلی حساس هستند اگر سرویس شما روی پروداکشن هست ممکن است اطلاعات حساسی بیرون درز دهد, به عنوان مثال debug/pprof/cmdline اطلاعات flag, switch هایی که سرویس شما اجرا شده است را نمایش می دهد و در صورتیکه فلگی داشته باشید شامل اطلاعات حساسی نظیر secret key, password و\u0026hellip; باشد دیده می شود. برای مورد دوم راه حلی داریم که می توانید جلو خودکار ریجستر شدن handler های pprof را بگیرید و موارد مورد نیاز را ریجستر کنید.\nبرای مورد دوم راه حلی داریم که می توانید جلو خودکار ریجستر شدن handler های pprof را بگیرید و موارد مورد نیاز را ریجستر کنید.\nبه نمونه کد زیر توجه کنید:\npackage main import ( \u0026quot;flag\u0026quot; \u0026quot;fmt\u0026quot; \u0026quot;github.com/PacViewer/synker/internal/logger\u0026quot; _ \u0026quot;go.uber.org/automaxprocs\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;net/http/pprof\u0026quot;) var ( pprofAddr *string ) func init() { pprofAddr = flag.String(\u0026quot;pprof-addr\u0026quot;, \u0026quot;\u0026quot;, \u0026quot;start pprof on server\u0026quot;) flag.Parse() // init disables default pprof handlers registered by importing net/http/pprof. // Your pprof is showing (https://mmcloughlin.com/posts/your-pprof-is-showing) http.DefaultServeMux = http.NewServeMux() } func main() { log := logger.DefaultLogger if *pprofAddr != \u0026quot;\u0026quot; { mux := http.NewServeMux() mux.HandleFunc(\u0026quot;/debug/pprof/\u0026quot;, pprof.Index) mux.HandleFunc(\u0026quot;/debug/pprof/profile\u0026quot;, pprof.Profile) mux.HandleFunc(\u0026quot;/debug/pprof/symbol\u0026quot;, pprof.Symbol) mux.HandleFunc(\u0026quot;/debug/pprof/trace\u0026quot;, pprof.Trace) sv := \u0026amp;http.Server{ Addr: *pprofAddr, Handler: mux, } log.Info(\u0026quot;pprof listened\u0026quot;, \u0026quot;addr\u0026quot;, fmt.Sprintf(\u0026quot;http://%s/debug/pprof\u0026quot;, *pprofAddr)) go func() { if err := sv.ListenAndServe(); err != nil { log.Fatal(\u0026quot;failed to listen pprof server\u0026quot;, \u0026quot;err\u0026quot;, err) } }() } } پس از اینکه net/http/pprof را ریجستر کردید برروی سرور روی روت /debug/pprof در دسترس است.\n4.25.3.9 دستورات pprof # در زیر ما یکسری دستوارت کاربردی pprof را معرفی میکنیم که میتوانید بصورت visualization اطلاعات پروفایل را در لوکال یا ریموت ببینید.\n4.25.3.9.1 دیدن CPU Profile آنلاین روی لوکال # برای دیدن اطلاعات CPU Profile بصورت آنلاین روی لوکال دستور زیر را بزنید:\ngo tool pprof -http=:8081 http://localhost:8080/debug/pprof/profile 4.25.3.9.2 دیدن Memory Profile آنلاین روی لوکال # برای دیدن اطلاعات Memory Profile بصورت آنلاین روی لوکال دستور زیر را بزنید:\nدیدن allocation ها go tool pprof -http=:8081 http://localhost:8080/debug/pprof/allocs دیدن heap ها go tool pprof -http=:8081 http://localhost:8080/debug/pprof/heap برای دیدن در قالب flame graph می توانید به آدرس زیر برروید:\nhttp://localhost:8082/ui/flamegraph 4.25.3.9.3 گرفتن خروجی pdf, png, svg # برای اینکه بتوانید از اطلاعات profiling خروجی فایل بگیرید دستور زیر را بزنید.\nPDF go tool pprof -pdf heap_profile.pprof SVG go tool pprof -svg heap_profile.pprof PNG go tool pprof -png heap_profile.pprof 4.25.3.9 نتیجه‌گیری # مدیریت کارآمد حافظه در Go، به همراه ابزارهای پروفایل‌سازی‌اش، به توسعه‌دهندگان پلتفرمی قوی برای ساخت برنامه‌های کارآمد ارائه می‌دهد. با درک رفتار حافظه در Go و پروفایل‌سازی منظم برنامه خود، می‌توانید اطمینان حاصل کنید که این برنامه حتی در بارهای سنگین نیز کارآمد و پاسخگو باقی می‌ماند.\n"},{"id":73,"href":"/chapter-5/","title":"فصل پنجم: برنامه نویسی شبکه با گو","section":"صفحه اصلی","content":"در این فصل به مباحث برنامه نویسی شبکه در زبان گو میپردازیم\u0026hellip;\n"},{"id":74,"href":"/chapter-5/network-basic/","title":"5.1 شبکه چیست","section":"فصل پنجم: برنامه نویسی شبکه با گو","content":"به تجهیزات متصل یکدیگر شبکه گفته می‌شود. مکانیزم‌های اتصال ممکن است از طریق سیم مسی، اترنت، فیبر نوری یا بی‌سیم. اندازه ی شبکه می تواند به اندازه ی اینترنت بزرگ یا به اندازه ی یک شبکه خانگی کوچک باشد. یک شبکه محلی (LAN) کامپیوترهایی را که در نزدیکی یکدیگر هستند، معمولاً تعلق به یک خانه، سازمان کوچک یا قسمتی از یک سازمان بزرگ دارند، به هم متصل می‌کند.\nیک شبکه گسترده (WAN) کامپیوترها را در یک منطقه فیزیکی بزرگتر، مانند بین شهرها متصل می‌کند. انواع دیگری هم وجود دارند، مانند MANs (شبکه‌های منطقه شهری)، PANs (شبکه‌های منطقه شخصی) و حتی BANs (شبکه‌های منطقه بدن).\nتفاوت‌های قابل توجهی بین یک اینترنت و یک اینترانت وجود دارد. معمولاً، یک اینترانت تحت کنترل مدیریت واحد قرار خواهد گرفت و یک مجموعه یکپارچه از سیاست‌ها را اعمال خواهد کرد. از طرفی، یک اینترنت تحت کنترل یک بدنه یکپارچه نخواهد بود و کنترل‌های انجام شده بر روی بخش‌های مختلف حتی سازگاری نخواهد داشت.\n5.1.1 چند تعریف و مفهوم کلی در شبکه # 5.1.1.1 پروتکل # پروتکل های شبکه مجموعه قواعد و روش هایی از پیش تعریف شده برای ارتباط دو کامپیوتر در یک شبکه هستند\n5.1.1.2 هسته (node) # هر دستگاه متصل به شبکه یک نود به حساب می آید.\n5.1.1.3 پروتکل اینترنت IP # پروتکل اینترنت یا (internet protocol) یک ادرس منحصر بفرد برای هر دستگاه متصل به اینترنت است هر ایپی (v4) شامل چهار بخش یا octet است که هر بخش را عددی بین ۰ تا ۲۵۵ تشکیل می دهد\n5.1.1.3.1 ایپی ورژن ۶ # زمان شروع و توسعه پروتکل اینترنت هر دستگاه در شبکه نیاز به یک شناسه منحصر به فرد داشت. ایپی ورژن ۴ تنها قابلیت ایجاد 4 بیلیون شناسه یونیک را داشتند (که بنظر برای تمام دستگاه های موجود کافی و مناسب بود) بعد از رشد چشم گیر اینترنت و دستگاه های متصل به اینترنت تعداد IP موجود حدودا کافی نبود ایپی ورژن ۶ جدید ترین نسخه ایپی است که شمال 8 octet است و از hexadecimal استفاده میکند. در نتیجه حدود 340 undecillion ایپی ورژن ۶ منحصر به فرد میتوان تولید کرد که برای عدد قابل توجهی دستگاه متصل به شبکه کافی است. مثال ایپی ورژن ۶: ‍‍2001:0db8:85a3:0000:0000:8a2e:0370:7334\n5.1.1.3.2 تفاوت ها # تفاوت های IPv4 and IPv6\nحافظه:\nورژن ۴: ‍‍32bit ورژن ۶:‍‍ ‍‍128bit نوع ایپی:\nورژن ۴ : ‍‍numeric dot-decimal ورژن ۶ : alphanumeric hexadecimal در نهایت گفتنی است که ورژن ۶ ایپی با استفاده از موارد امنیتی از جمله رمزنگاری و احراز هویت امنیت این پروتوکول را گسترش داده است.\n5.1.2 لایه های پروتکل # سیستم‌های توزیع شده دشوار هستند. چندین کامپیوتر درگیر هستند که باید به یکدیگر متصل شوند. برنامه‌ها برای اجرا بر روی هر کامپیوتر در سیستم باید نوشته شوند و همه باید با همکاری یک وظیفه توزیع شده را انجام دهند. روش رایج برای مقابله با پیچیدگی، تجزیه آن به بخش‌های کوچکتر و ساده‌تر است. این بخش‌ها ساختار خود را دارند، اما همچنین وسایل مشخصی برای ارتباط با بخش‌های مرتبط دیگر دارند. در سیستم‌های توزیع شده، بخش‌ها لایه پروتکل نامیده می‌شوند و وظایف دقیقی دارند. آن‌ها یک پشته را تشکیل می‌دهند، هر لایه با لایه بالایی و پایینی خود ارتباط برقرار می‌کند. ارتباط بین لایه‌ها توسط پروتکل‌ها تعریف می‌شود. ارتباطات شبکه نیازمند پروتکل‌هایی برای پوشش ارتباطات بالارونده بین برنامه‌های کاربردی تا ارتباطات سیم و پیچیدگی‌های پروتکلی در لایه‌های پروتکلی است.\n5.1.2.1 پروتکل ISO OSI # اگرچه هرگز به درستی پیاده‌سازی نشده است، پروتکل‌های OSI (اتصالات باز سیستم‌ها) تأثیر بزرگی در روش‌های گفتگو و طراحی سیستم‌های توزیع شده داشته‌اند. معمولاً آن‌ها به شکلی نشان داده می‌شوند که در شکل زیر نشان داده شده است.\nوظیفه هر لایه از پایین به بالا به شرح زیر است:\nلایه فیزیکی با استفاده از فناوری‌های الکتریکی، نوری یا رادیویی جریان بیت را منتقل می‌کند. لایه اتصال داده‌ها، بسته‌های اطلاعاتی را به فریم‌های شبکه تبدیل کرده و آن‌ها را برای انتقال از طریق لایه فیزیکی و بازگشت به بسته‌های اطلاعاتی آماده می‌کند. لایه شبکه فناوری‌های سوئیچینگ و روتینگ را فراهم می‌کند. لایه حمل و نقل انتقال شفاف داده بین سیستم‌های پایانی را فراهم می‌کند و مسئول بازیابی خطا در سراسر انتها به انتها و کنترل پایین است. لایه جلسه، ارتباطات بین برنامه‌ها را برقرار، مدیریت و پایان می‌دهد. لایه ارائه، استقلال را از تفاوت‌های در نمایش داده‌ها (مانند رمزگذاری) فراهم می‌کند. لایه برنامه، پردازش‌های برنامه و کاربران پایانی را پشتیبانی می‌کند. یک لایه در مدل OSI معمولاً با یک پروتکل مدرن نقش مشابهی دارد؛ به عنوان مثال، پروتکل IP از TCP/IP با لایه شبکه، همچنین شناخته شده به عنوان لایه 3 (لایه فیزیکی لایه 1) مرتبط است. لایه برنامه، یعنی لایه 7، با HTTP مرتبط است. برخی از پروتکل‌ها مانند HTTPS به نظر می‌رسد لایه‌ها را با هم تلفیق می‌کنند، 5 (جلسه) و 6 (ارائه). هیچ مدلی کامل نیست؛ جایگزین‌هایی برای مدل OSI وجود دارد که به واقعیت مشخصی نزدیکتر هستند، مانند مدل پروتکل TCP/IP.\n5.1.2.2 پروتکل TCP/IP # در حالی که مدل OSI در حال بحث و جدل، پیاده‌سازی جزئی، و جنگیدن بود، پروژه تحقیقاتی DARPA در اینترنت مشغول ساخت پروتکل‌های TCP/IP بود. این پروتکل‌ها بسیار موفق بوده و منجر به ایجاد اینترنت (با حروف بزرگ) شده است. این پشته بسیار ساده‌تر است، همانطور که در شکل زیر نشان داده شده است.\n5.1.2.3 پروتکل http # پروتکل http یکی از پرکابردترین و در دسترس ترین پروتکل های دنیا است. تا حدی که شما با یک کلیک و باز کردن مروگر خود به آن درسترسی دارید.\nHttp مخفف عبارت Hyper Text Transfer Protocol است که به معنی پروتکلی برای انتقال ابرمتن‌ها می‌باشد\nاین پروتکل به منظور ایجاد صفحات وب انتقال ابر متن ها توسط تیم برنزلی طراحی و پیاده سازی شد.\nپروتکل Http از Handshaking به منظور ارسال و دریافت اطلاعات استفاده می‌کند. در این روش برای شروع و پایان عملیات تبادل اطلاعات بین سرور و کاربر چندین درخواست و پاسخ جابه جا میشود.\n5.1.3 دروازه (Gateways) # یک دروازه (Gateway) یک عبارت کلی برای یک جسم است که برای اتصال دو یا چند شبکه استفاده می‌شود. یک تکرار کننده (Repeater) در سطح فیزیکی عمل کرده و اطلاعات را از یک زیرشبکه به دیگری کپی می‌کند. یک پل (Bridge) در سطح لایه داده‌ای عمل می‌کند و فریم‌ها را بین شبکه‌ها کپی می‌کند. یک مسیریاب (Router) در سطح شبکه عمل می‌کند و نه تنها اطلاعات را بین شبکه‌ها منتقل می‌کند، بلکه بر روی مسیر تصمیم می‌گیرد.\nدروازه یک نقطه واسط برای ارتباط بین دو شبکه است و معمولاً دروازه‌ها برای ارتباط بین شبکه‌های مختلفی با ساختار‌های مختلف استفاده می‌شوند. تکرار کننده اطلاعات را در سطح فیزیکی از یک شبکه به شبکه دیگر منتقل می‌کند. پل از طریق بررسی آدرس MAC در هر فریم، فریم‌ها را بین شبکه‌های مختلف انتقال می‌دهد. مسیریاب به عنوان یک دروازه هوشمند عمل می‌کند و برای انتقال بسته‌های داده بین شبکه‌های مختلف از پروتکل‌های مسیریابی مانند RIP، OSPF و BGP استفاده می‌کند. همچنین، مسیریاب‌ها مسیر بهینه برای انتقال بسته‌های داده را انتخاب می‌کنند و مسیریابی برای کنترل ترافیک شبکه مورد استفاده قرار می‌گیرد.\n5.1.4 Host-Level Networking # در شبکه مبتنی بر یک میزبان، ما دارای نگرانی‌های اضافی هستیم که در طراحی، اشکال زدایی و پیاده‌سازی نرم‌افزار مبتنی بر شبکه مورد استفاده قرار می‌گیرند. برخی از این موارد عبارتند از:\nDNS (نظام نام دامنه، به عنوان نام‌گذاری سازگار با انسان) Firewalls (مانند مسدود کردن ترافیک ورودی یا خروجی) Routing (به عنوان مثال، فهمیدن کدام شبکه برای قرار دادن یک بسته مناسب است) مدیریت هویت میزبان (به عنوان مثال، آدرس IP) کنترل عملکرد (به عنوان مثال، شکل دهی و یا تلاش مجدد برای ترافیک) مسائل اتصال (به عنوان مثال، عدم وجود آداپتور شبکه، ارتباطات داخلی پردازش درون‌ساختمانی) در کل، طراحی، پیاده‌سازی و مدیریت شبکه در سطح میزبان به دلیل وجود این نگرانی‌های اضافی، بسیار پیچیده تر از طراحی، پیاده‌سازی و مدیریت شبکه در سطح شبکه به شمار می‌آید.\n5.1.5 کپسوله سازی Packet # در هرکدام از مدل OSI یا TCP/IP، ارتباط بین لایه‌ها با ارسال بسته‌های داده از یک لایه به لایه بعدی و در نهایت از طریق شبکه انجام می‌شود. هر لایه اطلاعات مدیریتی دارد که باید درباره لایه خود نگه داشته شود. برای این کار، هر لایه با اضافه کردن اطلاعات هدر به بسته‌ای که از لایه بالایی دریافت می‌کند، همانند یک لایه زیر، بسته را به لایه بعدی منتقل می‌کند. در سمت دریافت کننده، هدرهای این بسته‌ها با حرکت بسته به سمت لایه بالاتر حذف می‌شوند.\nبه عنوان مثال، پروتکل انتقال پرونده‌های ساده (TFTP) فایل‌ها را از یک کامپیوتر به کامپیوتر دیگری منتقل می‌کند. این پروتکل از پروتکل UDP روی پروتکل IP استفاده می‌کند که ممکن است از طریق اترنت ارسال شود. این به صورتی است که در شکل زیر نشان داده شده است.\n5.1.6 مدل های ارتباط # برای دو کامپیوتر برای ارتباط با یکدیگر، آن‌ها باید یک مسیر راه‌اندازی کنند که امکان ارسال حداقل یک پیام در یک جلسه را برای آن‌ها فراهم کند. دو مدل اصلی برای این کار وجود دارد:\n5.1.6.1 مدل مبتنی بر اتصال (Connection Oriented) # در این مدل، ابتدا یک اتصال بین دو کامپیوتر برقرار می‌شود و سپس داده‌ها در قالب یک جلسه انتقال می‌یابند. این مدل برای انتقال داده‌هایی که نیاز به اطمینان بالا و کیفیت خدمات دارند مفید است، به عنوان مثال، ارسال فایل‌های بزرگ، ارتباطات صوتی و تصویری، اتصال به اینترنت و غیره. پروتکل TCP مثالی از یک مدل مبتنی بر اتصال است.\n5.1.6.2 مدل بدون اتصال (Connectionless) # در این مدل، هیچ اتصالی بین دو کامپیوتر برقرار نمی‌شود و هر بسته به صورت مستقل از دیگر بسته‌ها ارسال می‌شود. این مدل برای انتقال داده‌هایی که نیاز به سرعت بالا و حجم کمتری از اطلاعات دارند مفید است، به عنوان مثال، ارسال پیام‌های کوتاه، سرور های بازی، درخواست اطلاعات از یک سرور و غیره. پروتکل UDP مثالی از یک مدل بدون اتصال است.\n5.1.7 مدل های ارتباطات # در یک سیستم توزیع‌شده، بسیاری از اجزا (یعنی فرآیندها) در حال اجرا هستند که باید با یکدیگر ارتباط برقرار کنند. دو مدل اصلی برای این کار وجود دارند: ارسال پیام و فراخوانی رویه‌های از راه دور (Remote Procedure Call).\nدر زمینه شبکه‌ها، این مدل‌ها اجازه ارتباط بین فرآیندها (و/یا رشته‌ها) با هدف فراخوانی رفتار روی فرآیند از راه دور را می‌دهند.\nدر مدل ارسال پیام، فرآیندها با یکدیگر به صورت غیرمستقیم و از طریق ارسال پیام‌هایی که شامل داده‌های خاصی هستند، ارتباط برقرار می‌کنند. این پیام‌ها ممکن است برای انتقال داده‌ها، درخواست خدمات، یا هر نوع ارتباطی بین فرآیندها استفاده شوند. این مدل برای سیستم‌هایی که ارتباطات غیرهمزمان، توزیع شده و یا برای ارتباطاتی که نیاز به پیچیدگی بیشتری دارند، مفید است.\nدر مدل فراخوانی رویه‌های از راه دور، فرآیند فراخواننده یک رویه محلی را فراخوانی می‌کند که در فرآیند دیگری اجرا می‌شود. در این مدل، فرآیند فراخواننده به عنوان مشتری عمل می‌کند و فرآیند دیگر به عنوان سرور. درخواست‌های مشتری به صورت پیام‌هایی به سرور فرستاده می‌شود و سرور درخواست‌ها را پردازش می‌کند و نتیجه را به مشتری می‌فرستد. این مدل برای سیستم‌هایی که نیاز به ارتباطات همزمان و یا درخواست‌هایی که نیاز به پردازش پیچیده دارند، مفید است.\n5.1.7.1 Message Passing # بعضی زبان‌ها بر اساس اصل ارسال پیام ساخته شده‌اند. زبان‌ها و ابزارهای همزمان از این مکانیزم استفاده می‌کنند و مثال شناخته شده‌ترین آن ممکن است خط لوله UNIX باشد. خط لوله UNIX یک خط لوله از بایت‌هاست، اما این یک محدودیت ذاتی نیست: PowerShell شرکت مایکروسافت می‌تواند اشیاء را از طریق خطوط لوله خود ارسال کند و زبان‌های همزمان مانند Parlog می‌توانند ساختارهای داده منطقی دلخواه را در پیام‌های بین فرآیندهای همزمان ارسال کنند. زبان‌های جدید مانند Go دارای مکانیزم‌هایی برای ارسال پیام (بین تردها) هستند.\nارسال پیام یک مکانیزم اولیه برای سیستم‌های توزیع‌شده است. یک اتصال راه‌اندازی کرده و برخی از داده‌ها را از آن پمپ کنید. در سمت دیگر، پیام را تشخیص دهید و به آن پاسخ دهید، با احتمال ارسال پیام‌های بازگشتی. این در شکل زیر نشان داده شده است.\nسیستم‌های مبتنی بر رویداد نیز به همین شکل عمل می‌کنند. در سطح پایین، زبان برنامه‌نویسی Node.js یک حلقه رویداد اجرا می‌کند که منتظر رویدادهای ورود/خروج است، برای این رویدادها شیء‌های اجرایی را فراخوانی کرده و به آن‌ها پاسخ می‌دهد. در سطح بالاتر، اکثر سیستم‌های رابط کاربری از یک حلقه رویداد برای انتظار ورودی کاربر استفاده می‌کنند، در حالی که در دنیای شبکه، Ajax از XMLHttpRequest برای ارسال و دریافت درخواست‌ها استفاده می‌کند.\n5.1.7.2 Remote Procedure Call # در هر سیستمی، انتقال اطلاعات و کنترل کم از یک بخش از سیستم به بخش دیگری اتفاق می‌افتد. در زبان‌های رویه‌ای، این ممکن است شامل فراخوانی رویه باشد، که در آن اطلاعات بر روی یک پشته فراخوانی قرار داده می‌شود و سپس کنترل به بخش دیگری از برنامه منتقل می‌شود. حتی با فراخوانی رویه، تفاوت‌هایی وجود دارد. کد ممکن است به طور استاتیک متصل شود تا کنترل از قسمتی از کد اجرایی برنامه به بخش دیگری از آن منتقل شود. به دلیل استفاده روزافزون از روتین‌های کتابخانه، معمول شده است کد را در شیء‌های به اشتراک گذاشته شده (.so) یا کتابخانه‌های پیوندی پویای (.dll) داشته باشیم، که کنترل به یک قطعه کد مستقل منتقل می‌شود.\nکتابخانه‌ها در همان ماشینی که کد فراخواننده در آن اجرا می‌شود، اجرا می‌شوند. این یک مرحله ساده (مفهومی) برای انتقال کنترل به یک رویه اجرا شده در ماشین دیگر (یعنی کتابخانه از راه دور) است. اما مکانیک این کار به این سادگی نیست! با این حال، این مدل کنترل باعث بروز فراخوانی رویه از راه دور (RPC) شده است که در یک فصل بعدی به طور جزئیات بیشتری بحث می‌شود. این در شکل زیر نشان داده شده است.\nهمانطور که گفته شد، بسیاری از مثال‌هایی که وجود دارد، بر اساس زبان‌های برنامه‌نویسی خاصی مانند بسته rpc Go یا سیستم‌های RPC پوشش دهی چندین زبان مانند SOAP و gRPC شرکت گوگل است.\nممکن است مبهم باشد که چگونه ارسال پیام و RPC از هم متفاوت هستند. در یک سطح، هردو با فراخوانی رفتار \u0026ldquo;جای دیگری\u0026rdquo; مرتبط هستند. به طور کلی، RPC در مقایسه با ارسال پیام کمتر انتزاعی است (یعنی به نظر می‌رسد و به احساس فراخوانی روتین‌های معمولی شبیه است)، در حالی که در ارسال پیام ممکن است به سیستم صف‌های از راه دور فراخوانی شده باشیم. با این حال، در پشت صحنه، RPC نیز پیام‌ها را ارسال می‌کند.\n5.1.7.3 مدل محاسبات توزیع شده (Distributed Computing) # در سطح بالاتر، می‌توانیم معادل بودن یا عدم معادل بودن اجزای یک سیستم توزیع شده را مورد بررسی قرار دهیم. شاید رایج‌ترین حالت یک حالت نامتقارن باشد: یک مشتری درخواست‌های خود را به یک سرور ارسال می‌کند و سرور پاسخ می‌دهد. این یک سیستم client-server است.\nاگر هر دو اجزای سیستم معادل باشند، قادر به شروع کردن و پاسخ دادن به پیام‌ها باشند، آنگاه یک سیستم همتا به همتا داریم. توجه کنید که این یک طبقه‌بندی منطقی است: یک همتا ممکن است یک ابرکامپیوتر با ۱۶۰۰۰ هسته باشد؛ دیگری ممکن است یک تلفن همراه باشد. اما اگر هر دو می‌توانند به طور مشابه عمل کنند، آنگاه آن‌ها همتای یکدیگر هستند.\nدر مثال سیستم client-server، مرورگری که با یک سرور وب صحبت می‌کند، یک مثال است. مثالی از یک سیستم همتا به همتا، سیستم پایگاه داده است که داده‌ها در آن تکثیر می‌شوند و در هر دو همتا در دسترس هستند.\nترکیب این سیستم‌ها باعث بوجود آمدن معماری‌های چند لایه می‌شود، که یکی از رایج‌ترین آن‌ها سه لایه است (یعنی ارائه -\u0026gt; برنامه -\u0026gt; داده یا مرورگر -\u0026gt; سرور وب -\u0026gt; پایگاه داده).\n5.1.7.3.1 سیستم client-server # به عکس زیر توجه کنید:\nدر سیستم فوق ممکن است توسط یک توسعه‌دهنده که نیاز به شناخت اجزای یک سیستم دارد، داشته باشد. همچنین، کاربری که از یک مرورگر استفاده می‌کند، می‌داند که مرورگر در سیستمش اجرا می‌شود، اما با سرورهای دیگری در جای دیگری ارتباط برقرار می‌کند.\nنمودار قبلی شبیه به مدل OSI است که در ابتدای کتاب بحث شد. لایه‌های موجود در شکل فوق نیز اختیاری هستند؛ به عنوان مثال، می‌توانیم هم مشتری و هم سرور را روی یک پاره‌ای از سخت افزار نصب کنیم. قرار گرفتن روی همان ماشین به این معنی است که ما می‌توانیم برخی از لایه‌های مدل OSI را از جمله لایه ۱ (فیزیکی)، لایه ۲ (پیوند داده) و لایه ۳ (شبکه) را حذف کنیم. ما می‌گوییم \u0026ldquo;احتمالا\u0026rdquo;، زیرا این لایه‌ها هنوز ممکن است برای دلایل مختلفی از جمله همگنی ابزارها یا امنیت، مورد نیاز باشند.\n5.1.7.3.2 اپلیکیشن Client-Server # برخی از برنامه‌ها ممکن است به طور شفاف توزیع شده باشند، به طوری که کاربر نمی‌داند که آن توزیع شده است. کاربران دید خود را از سیستم خود مشاهده می‌کنند، همانطور که در شکل زیر نشان داده شده است.\nبرای عملکرد، هر دو اجزا باید نصب شده باشند. چقدر پیچیدگی برنامه باید شفاف باشد، به برنامه و استفاده آن بستگی دارد.\n5.1.7.3.3 سرور توزیع شده # یک سیستم client-server نیازمند پیچیدگی نیست. مدل ابتدایی، یک سیستم مشتری-سرور تکی است که در شکل زیر نشان داده شده است.\nاما می‌توانید چندین مشتری و یک سرور داشته باشید، همانطور که در شکل زیر نشان داده شده است.\nدر این سیستم، مستر درخواست‌ها را دریافت کرده و به جای اینکه خودش آن‌ها را یکی یکی پردازش کند، آن‌ها را به سرورهای دیگر برای پردازش ارسال می‌کند. این یک مدل رایج است زمانی که مشتریان همزمان ممکن است وجود داشته باشند.\nهمچنین، می‌توانید یک مشتری و چندین سرور داشته باشید، همانطور که در شکل زیر نشان داده شده است.\nاین نوع سیستم بسیار رایج است زمانی که یک سرور باید به عنوان مشتری به سرورهای دیگر عمل کند، مانند یک سرور منطق تجاری که اطلاعات را از سرور پایگاه داده دریافت می‌کند. و البته، می‌تواند چندین مشتری با چندین سرور باشد.\nدوباره، این اجزا ممکن است روی یک سخت‌افزار فیزیکی قرار نگرفته باشند.\n"},{"id":75,"href":"/chapter-5/go-tcp-server-begginer/","title":"5.2 سرور tcp مقدماتی","section":"فصل پنجم: برنامه نویسی شبکه با گو","content":"ما میتوانیم در گو با استفاده از کتابخانه net یک سرور tcp ایجاد کنیم بعد از تکمیل شدن سرور با استفاده از دستور telnet به آن متصل میشویم\nدر قطعه کد زیر با تابع acceptLoop() درخواست های اتصال را مپذیریم و با تابع readLoop() پیام های اتصال را میخوانیم\npackage main import ( \"fmt\" \"log\" \"net\" ) // ساختار هر پیام در سرور type Message struct { // ادرس ip ارسال کننده پیام from string // متن و محتوای پیام payload []byte } // ساختار سرور type Server struct { // ادرس و یا پورت سرور listenAddr string // listener ln net.Listener // چنل پیام برای انتقال پیام های دریافتی از اتصال ها بین گوروتین ها msgch chan Message } // ایجاد یک سرور جدید func newServer(listenAddr string) *Server { return \u0026Server{ listenAddr: listenAddr, msgch: make(chan Message, 10), } } // شروع سرور و دریافت اتصال های جدید func (s *Server) start() error { // شروع سرور ln, err := net.Listen(\"tcp\", s.listenAddr) if err != nil { return err } // مقدار دهی listener s.ln = ln // با تابع acceptLoop اتصال های جدید به سرور را مدیریت میکنیم // با استفاده از go هر اتصال را روی یک گوروتین مجزا مدیریت میکنیم go s.acceptLoop() return nil } // اینجا برای استاپ کردن سرور یک متد جدید تعریف میکنیم func (s *Server) stop() { if s.ln != nil { s.ln.Close() } } func (s *Server) acceptLoop() { for { // اتصال های موجود را تایید میکنیم متغییر conn را با اتصال مورد نظر مقدار دهی میکنیم conn, err := s.ln.Accept() if err != nil { fmt.Println(\"accept error:\", err) continue } // با استفاده از این تابع مقادیر ارسال شده توسط اتصال را به چنل message میدهیم go s.readLoop(conn) } } func (s *Server) readLoop(conn net.Conn) { defer conn.Close() buf := make([]byte, 2048) for { // پیام ارسال شده توسط هر اتصال را به متغییر buf میدهیم n, err := conn.Read(buf) if err != nil { fmt.Println(\"read error:\", err) continue } s.msgch \u003c- Message{ // ادرس ip ارسال کننده پیام از نوع net.IP from: conn.RemoteAddr().String(), // متن پیام payload: buf[:n], } // بعد از دریافت هر پیام یک پیام به عنوان پاسخ ارسال میکنیم conn.Write([]byte(\"your message recived!\\n\")) } } func main() { // ساخت سرور server := newServer(\":3000\") //start the server if err := server.start(); err != nil { log.Fetal(err) } go func() { // در ازای هر پیام مقادیر آن را چاپ میکنیم for msg := range server.msgch { fmt.Printf(\"recived new from connection(%s): %s\\n\", msg.from, msg.payload) } }() // Run an infinite loop to keep the program running select {} } ▶ اجرای کد کپی ✖ بستن خروجی بعد از پایان پیاده سازی سرور tcp با دستور زیر سرور خود را اجرا میکنیم: go run main.go\nو با دستور زیر در یک ترمینال مجزا به سرور متصل میشویم: telnet localhost 3000\nحال با نوشتن پیام و ارسال آن در ترمینال telnet متن پیام و ادرس اتصال در ترمینال سرور قابل مشاهده است.\nتوجه داشته باشید که دستور ‍telnet در ویندوز نیاز به فعال سازی دارد.\n"},{"id":76,"href":"/chapter-5/go-tcp-server-advanced/","title":"5.3 سرور tcp پیشرفته","section":"فصل پنجم: برنامه نویسی شبکه با گو","content":"در این قسمت به طراحی و ساخت یک سرور tcp بصورت پیشرفته میپردازیم. در قسمت قبل بعد از ایجاد سرور TCP ساده با استفاده از کلاینت telnet به آن متصل شدیم و دیتایی را انتقال دادیم.\nدر این قسمت یک سرور tcp را با هدف انتقال فایل های حجیم بصورت جریان ایجاد میکنم.\nقبل از شروع ایجاد سرور خود به دلیل اینکه چرا فایل های حجیم را استریم میکنیم و یا اصلا استریم چیست میپردازیم. زمانی که شما فایل های کم حجم را مستقیما انتقال میدهید با تاخیر کم و بصورت مطلوب انجام میشود. اما روایت برای فایل های سنگین تر متفاوت است، اگر این عمل بصورت مستقیم و یکجا انجام شود باعث ایجاد تاخیر و مصرف منابع بیش از حد روی سرور میشود. اما ما با استفاده از روش استریم، داده و فایل خود را بصورت قطعه های کم حجم و پشت سر هم ارسال میکنیم.\nدر ادامه به پیاده سازی سرور خود با استفاده از پروتکل tcp میپردازیم:\npackage main import ( \"bytes\" \"crypto/rand\" \"encoding/binary\" \"fmt\" \"io\" \"log\" \"net\" \"time\" ) type FileServer struct { } func (fs *FileServer) start() { ln, err := net.Listen(\"tcp\", \"0.0.0.0:3000\") if err != nil { panic(err) } for { conn, err := ln.Accept() if err != nil { log.Fatal(err) continue } fmt.Printf(\"new connection: %s\\n\", conn.RemoteAddr().String()) // read data from accepted connections go fs.readLoop(conn) } } func (fs *FileServer) readLoop(conn net.Conn) { // make a new buffer buf := new(bytes.Buffer) for { var size int64 // get the size from connection binary.Read(conn, binary.LittleEndian, \u0026size) // copy from connection until the end of file n, err := io.CopyN(buf, conn, size) if err != nil { log.Fatal(err) continue } fmt.Println(buf.Bytes()) fmt.Printf(\"received %d bytes over the network\\n\", n) } } func main() { go func () { time.Sleep(4 * time.Second) // set your file szie sendFile(2000000) }() s := \u0026FileServer{} s.start() } // client example that send a large file to server! func sendFile(size int) error { file := make([]byte, size) // make a random file from the size provided _, err := io.ReadFull(rand.Reader, file) if err != nil { return err } // dial with the tcp server (you can do this is an other file) conn, err := net.Dial(\"tcp\", \":3000\") if err != nil { return err } // send the size of file binary.Write(conn, binary.LittleEndian, int64(size)) // copy file over the network until the end of file n, err := io.CopyN(conn, bytes.NewReader(file), int64(size)) if err != nil { return err } fmt.Printf(\"written %d byte over the network\\n\", n) return nil } ▶ اجرای کد کپی ✖ بستن خروجی بعد از پایان نوشتن کد شما میتوانید با اجرا کردن کد خود (ترجیحا انتخاب یک عدد بزرگ برای حجم فایل یا همان ورودی تابع sendFile) میتوانید استریم شدن بایت هارا بصورت چانک چانک در لاگ های سمت سرور ببینید.\n"},{"id":77,"href":"/chapter-5/go-udp-server-begginer/","title":"5.4 سرور udp مقدماتی","section":"فصل پنجم: برنامه نویسی شبکه با گو","content":"در این قسمت به طراحی و ساخت یک سرور UDP مقدماتی با گولنگ می پردازیم.\n5.4.1 معرفی UDP # پروتکل(User Datagram Protocol) یک پروتکل فاقد اتصال است. به این معنا که بسته های این پروتکل بدون اتصال قبلی و بررسی اینکه ایا همه بسته ها به درستی ارسال شده اند به دستگاه مورد نظر ارسال میشود. به همین دلیل سرعت در این پروتکل از پروتکل tcp پایین تر است اما تظمین ارسال کامل و سالم داده وجود ندارد. از موارد استفاده این پروتکل میتوان سرور بازی های انلاین را مثال زد.\n5.4.2 پیاده سازی # برای پیاده سازی یک سرور udp در گولنگ و اتصال به آن همچنان از کتابخانه net استفاده میکنیم.\npackage main import ( \"fmt\" \"net\" \"strings\" ) func main() { // ادرس IP و پورت مورد نظر را برای گوش سپردن به پکت های UDP مشخص میکنیم (مقدار بازگشتی این تابع اتصال ما است که قابلیت نوشتن و خواندن آن را داریم) conn, err := net.ListenUDP(\"udp\", \u0026net.UDPAddr{ Port: 3000, IP: net.ParseIP(\"0.0.0.0\"), }) if err != nil { panic(err) } defer conn.Close() fmt.Printf(\"server listening %s\\n\", conn.LocalAddr().String()) for { message := make([]byte, 20) // تمام پیام های نوشته شده (ارسال شده) را میخوانیم // متغییر message را با مقدار ارسال شده پر میکنیم (مقدار های بازگشتی این تابع طول پیام و آدرس ریموت ارسال کننده است) readLen, remote, err := conn.ReadFromUDP(message[:]) if err != nil { panic(err) } // متن پیام را تا قسمت خوانده شده به string تبدیل میکنیم data := strings.TrimSpace(string(message[:readLen])) // داده خروجی را چاپ میکنیم fmt.Printf(\"received: %s from %s\\n\", data, remote) } } ▶ اجرای کد کپی ✖ بستن خروجی بعد از انجام مراحل بالا با دستور ‍go run main.go کد خود را اجرا میکنیم.\n5.4.3 کد کلاینت برای اتصال به سرور ساخته شده # اکنون با چند خط کد در زبان گولنگ به سرور خود متصل میشویم پیامی را به آن ارسال میکنیم\npackage main import \"net\" func main() { // یک اتصال به سرور ایجاد میکنیم Conn, _ := net.DialUDP(\"udp\", nil, \u0026net.UDPAddr{IP:[]byte{127,0,0,1},Port:3000,Zone:\"\"}) defer Conn.Close() // متن زیر را به سرور ارسال میکنیم Conn.Write([]byte(\"hello, gofarsi!\")) } ▶ اجرای کد کپی ✖ بستن خروجی اکنون همزمان با اجرا بودن کد سرور این قطعه کد را با دستور ‍‍go run client.go اجرا میکنیم (بسته به اسمی که برای فایل انتخاب کرده اید)\nخروجی در کنسول کد سرور به این صورت خواهد بود: received: hello, gofarsi! from 127.0.0.1:54960\n"},{"id":78,"href":"/chapter-5/go-udp-server-advanced/","title":"5.5 سرور udp پیشرفته","section":"فصل پنجم: برنامه نویسی شبکه با گو","content":"در قسمت قبل به ایجاد یک سرور udp ساده و ارسال پکت به آن پرداختیم. در این قسمت با استفاده از یک سرور و کلاینت udp یک پیام رسان بصورت feed میسازیم. عملکرد سرور و کلاینت: یک سرور udp ایجاد میکنیم که تمام کانکشن های موجود را ذخیره میکند و به محض دریافت پیام از هر یک از کانکشن ها پیام را برای تمام کانکشن های دیگر بجر کانکشن ارسال کننده پیام ارسال میکند.\nدر مرحله اول سروری که کانکشن ها و ارسال پیام را مدیریت میکنید مینویسیم:\npackage main import ( \"fmt\" \"net\" ) func main() { // Set up the server addr := net.UDPAddr{ Port: 8000, IP: net.ParseIP(\"0.0.0.0\"), } conn, err := net.ListenUDP(\"udp\", \u0026addr) if err != nil { fmt.Println(\"Error listening:\", err) return } defer conn.Close() fmt.Println(\"Server started on port\", addr.Port) // Listen for incoming messages buffer := make([]byte, 1024) clients := make(map[string]*net.UDPAddr) for { n, clientAddr, err := conn.ReadFromUDP(buffer) if err != nil { fmt.Println(\"Error reading:\", err) continue } // Add new client if _, ok := clients[clientAddr.String()]; !ok { clients[clientAddr.String()] = clientAddr fmt.Println(\"New client joined:\", clientAddr.String()) } // Broadcast message to all clients message := buffer[:n] for _, addr := range clients { if addr.String() != clientAddr.String() { _, err = conn.WriteToUDP(message, addr) if err != nil { fmt.Println(\"Error broadcasting message:\", err) } } } } } ▶ اجرای کد کپی ✖ بستن خروجی در این قسمت یک سرور udp ایجاد کرده ایم و هر کانکشن جدید را به لیست کانکشن های خود اضافه میکنیم. همچنین در ازای هر پیام دریافتی از سمت کانکشن ها آن را برای کانکشن های دیگر ارسال میکنیم.\nدر ادامه یک کلاینت ساده برای سرور خود مینویسیم که پیام هارا نمایش دهد و متن ورودی در ترمینال را به سرور ارسال کند.\npackage main import ( \"bufio\" \"fmt\" \"net\" \"os\" ) func main() { // Set up connection to the server conn, err := net.Dial(\"udp\", \"localhost:8000\") if err != nil { fmt.Println(\"Error connecting:\", err) return } defer conn.Close() go func() { for { buf := make([]byte, 1024) // buffer for incoming message n, err := conn.Read(buf) if err != nil { fmt.Println(\"Error receiving message:\", err) continue } fmt.Printf(\"Received message: %s\\n\", string(buf[:n])) } }() // Read input from terminal and send to server scanner := bufio.NewScanner(os.Stdin) for { // send messages to server fmt.Print(\"Enter message: \") if !scanner.Scan() { break } message := scanner.Text() _, err = conn.Write([]byte(message)) if err != nil { fmt.Println(\"Error sending message:\", err) continue } } } ▶ اجرای کد کپی ✖ بستن خروجی در این کد ما تمام پیام های دریافتی از سرور را چاپ میکنیم و هر پیامی که کاربر در ترمینال وارد کند را به سرور ارسال میکنیم.\nبعد از اتمام کار برای تست کد خود سه ترمینال مجزا بار میکنیم. و در یکی از سرور ها فایل server.go و در دو ترمینال دیگر فایل client.go را اجرا میکنیم.\nهر پیامی که توسط هر کلاینتی ارسال شود برای دیگر کلاینت ها قابل مشاهده است.\nتوجه کنید اسم فایل ها بر اساس اسم انتخابی شما است. همچنین توجه داشته باشید که شما میتوانید هر تعداد دلخواهی کلاینت را اجرا کنید.\n"},{"id":79,"href":"/chapter-5/go-http-server-begginer/","title":"5.6 کتابخانه http سمت سرور مقدماتی","section":"فصل پنجم: برنامه نویسی شبکه با گو","content":"یکی از قابلیت های زبان گو این است که می توان با استفاده از کتابخانه http داخلی گو استفاده کرده و وب سرور پیاده سازی کرد.\nبرای پیاده سازی یک وب سرور حداقل به 3 چیز نیاز داریم: 1) مسیر 2) درگاه وب سرور 3) مقدار برگشتی\nمسیر: عبارت است از URL منحصر به فرد برای ارسال و دریافت اطلاعات ورودی\nدرگاه وب سرور: هر وب سرور نیاز دارد که درگاه (Port) خاصی را در اختیار داشته باشد و همواره به آن درگاه گوش بسپارد.\nمقدار برگشتی: هرگاه کاربر به مسیری وارد میشود یا اطلاعاتی را برای وب سرور ارسال میکند، مقداری از سمت سرور برای کاربر ارسال میشود.\nیک نمونه وب سرور در گو\npackage main import ( \"fmt\" \"net/http\" ) func main() { // مسیر / یا root را برای این تابع انتخاب میکنیم (کد این تابع با صدا شدن مسیر localhost:3000 اجرا می شود) http.HandleFunc(\"/\", func(writer http.ResponseWriter, request *http.Request) { // مقدار hello world را در مسیر مشخص شده برمیگردانیم _, err := fmt.Fprint(writer, \"Hellow World!\") if err != nil { return } }) fmt.Println(\"Starting The Server on :3000...\") // به درخواست های ارسال شده به پورت 3000 با پروتوکول http گوش میکنیم (سرور در انتظار درخواست از سمت کاربر یا client) می ماند err := http.ListenAndServe(\":3000\", nil) if err != nil { return } } ▶ اجرای کد کپی ✖ بستن خروجی با وارد شدن به آدرس localhost:3000 مقدار برگشته شده در ‍handleFunc را مشاهده خواهید کرد.\n"},{"id":80,"href":"/chapter-5/go-http-server-advanced/","title":"5.7 کتابخانه http سمت سرور پیشرفته","section":"فصل پنجم: برنامه نویسی شبکه با گو","content":"در قسمت قبل با استفاده از کتابخانه net/http یک api ساده ایجاد کردیم.\nدر این قسمت به پیاده سازی یک سرور http برای مدیریت لیست TODO های خود میپردازیم و از چهار متد GET, POST, DELET and PATCH استفاده میکنیم.\nدر این پروژه از دیتابیس استفاده نمیشود. روش ذخیره سازی اطلاعات درون متغییر هاست دلیل استفاده نکردن از یک دیتابیس تمرکز این قسمت روی کتابخانه و پروتکل http است.\nدر ادامه به ایجاد سرور خود میپردازیم.\npackage main import ( \"encoding/json\" \"fmt\" \"log\" \"net/http\" ) // todo struct with json tags type Todo struct { ID int `json:\"id\"` Title string `json:\"title\"` Status bool `json:\"status\"` } // just work as a DB for us! var todos []Todo // get all the items in the Todo list and write it. GET func getTodos(w http.ResponseWriter, r *http.Request) { w.Header().Set(\"Content-Type\", \"application/json\") json.NewEncoder(w).Encode(todos) } // append a new data in array. POST func addTodo(w http.ResponseWriter, r *http.Request) { w.Header().Set(\"Content-Type\", \"application/json\") var todo Todo json.NewDecoder(r.Body).Decode(\u0026todo) // NOTE: this isn't a good way to set ids in production! todo.ID = len(todos) + 1 todos = append(todos, todo) json.NewEncoder(w).Encode(todo) } // change the todo status. PATCH func updateTodo(w http.ResponseWriter, r *http.Request) { w.Header().Set(\"Content-Type\", \"application/json\") var todo Todo json.NewDecoder(r.Body).Decode(\u0026todo) for i, t := range todos { if t.ID == todo.ID { todos[i].Status = todo.Status json.NewEncoder(w).Encode(todos[i]) return } } w.WriteHeader(http.StatusNotFound) json.NewEncoder(w).Encode(map[string]string{\"message\": \"TODO not found\"}) } // remove the TODO from array. DELETE func deleteTodo(w http.ResponseWriter, r *http.Request) { w.Header().Set(\"Content-Type\", \"application/json\") var todo Todo json.NewDecoder(r.Body).Decode(\u0026todo) for i, t := range todos { if t.ID == todo.ID { todos = append(todos[:i], todos[i+1:]...) json.NewEncoder(w).Encode(map[string]string{\"message\": \"TODO deleted\"}) return } } w.WriteHeader(http.StatusNotFound) json.NewEncoder(w).Encode(map[string]string{\"message\": \"TODO not found\"}) } func main() { // set routes http.HandleFunc(\"/todos\", getTodos) http.HandleFunc(\"/todos/add\", addTodo) http.HandleFunc(\"/todos/update\", updateTodo) http.HandleFunc(\"/todos/delete\", deleteTodo) // start server fmt.Println(\"Server starting at port 8080\") log.Fatal(http.ListenAndServe(\":8080\", nil)) } ▶ اجرای کد کپی ✖ بستن خروجی بعد از اتمام نوشتن سرور با استفاده از یک کلاینت http مثل postman سرور خود را به روش زیر تست میکنیم:\nنکته: شما می توانید کلاینت خود را خودتان با استفاده از اموزش کلاینت http در قسمت های دیگر بنویسید!\nadd todo # endpoint: localhost:8080/todos/add\nmethod:POST\nrequest:\n{ \u0026quot;title\u0026quot;:\u0026quot;todo1 test\u0026quot; } response:\n{ \u0026quot;id\u0026quot;: 1, \u0026quot;title\u0026quot;: \u0026quot;todo1 test\u0026quot;, \u0026quot;status\u0026quot;: false } get todo\u0026rsquo;s # endpoint: localhost:8080/todos\nmethod:GET\nrequest:\nresponse:\n[ { \u0026quot;id\u0026quot;: 1, \u0026quot;title\u0026quot;: \u0026quot;todo1 test\u0026quot;, \u0026quot;status\u0026quot;: false }, //... ] update todo # endpoint: localhost:8080/todos/update\nmethod:PATCH\nrequest:\n{ \u0026quot;id\u0026quot;:1, \u0026quot;status\u0026quot;:true } response:\n{ \u0026quot;id\u0026quot;: 1, \u0026quot;title\u0026quot;: \u0026quot;todo1 test\u0026quot;, \u0026quot;status\u0026quot;: true } delete todo # endpoint: localhost:8080/todos/delete\nmethod:DELETE\nrequest:\n{ \u0026quot;id\u0026quot;:1 } response:\n{ \u0026quot;message\u0026quot;: \u0026quot;TODO deleted\u0026quot; } "},{"id":81,"href":"/chapter-5/go-http-client-begginer/","title":"5.8 کتابخانه http سمت کلاینت مقدماتی","section":"فصل پنجم: برنامه نویسی شبکه با گو","content":"برای ایجاد کلاینت http در گولنگ نیاز به کتابخانه net/http داریم. قبل از شروع به نوشتن کلاینت خود چند مفهوم کلی راه بررسی میکنیم.\n5.8.1 سرور # همانطور که میدانیم سرور های http برای تعریف مسیر ها منطق سرور و دریافت درخواست ها طراحی و ساخته میشوند. (در قسمت های قبل ایجاد سرور http بصورت کامل یادگرفتیم)\n5.8.2 کلاینت # کلاینت های در پروتوکول http برای صدا کردن (call) و ارسال درخواست به سرور ها طراحی و ساخته میشوند. در ادامه یک کلاینت مقدماتی و ساده را در زبان گولنگ ایجاد میکنیم.\n‍‍ package main import ( \"fmt\" \"io/ioutil\" \"net/http\" \"time\" ) func main() { // کلاینت خود را با استفاده از ماژول http ایجاد میکنیم c := http.Client{Timeout: time.Duration(1) * time.Second} // از طریق کلاینت ایجاد شده یک درخواست با متد GET به آدرس example.com ارسال میکنیم // دقیقا سروری مشابه به سرور هایی که در قسمت های قبل ایجاد کردیم در آدرسی که الان به آن درخوایت ارسال میکنیم درحال گوش سپردن به درخواست ها میباشد. resp, err := c.Get(\"https://www.example.com\") if err != nil { fmt.Printf(\"Error %s\", err) return } defer resp.Body.Close() // مقادیر دریافت شده از سرور را میخوانیم و چاپ میکنیم body, err := ioutil.ReadAll(resp.Body) fmt.Printf(\"Body : %s\", body) } ▶ اجرای کد کپی ✖ بستن خروجی در نهایت با اجرای قطعه کد بالا خروجی ما پاسخی است که از سرور دریافت کرده ایم:\nBody : \u0026lt;!doctype html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Example Domain\u0026lt;/title\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot; /\u0026gt; \u0026lt;meta http-equiv=\u0026quot;Content-type\u0026quot; content=\u0026quot;text/html; charset=utf-8\u0026quot; /\u0026gt; \u0026lt;meta name=\u0026quot;viewport\u0026quot; content=\u0026quot;width=device-width, initial-scale=1\u0026quot; /\u0026gt; \u0026lt;style type=\u0026quot;text/css\u0026quot;\u0026gt; body { background-color: #f0f0f2; margin: 0; padding: 0; font-family: -apple-system, system-ui, BlinkMacSystemFont, \u0026quot;Segoe UI\u0026quot;, \u0026quot;Open Sans\u0026quot;, \u0026quot;Helvetica Neue\u0026quot;, Helvetica, Arial, sans-serif; } div { width: 600px; margin: 5em auto; padding: 2em; background-color: #fdfdff; border-radius: 0.5em; box-shadow: 2px 3px 7px 2px rgba(0,0,0,0.02); } a:link, a:visited { color: #38488f; text-decoration: none; } @media (max-width: 700px) { div { margin: 0 auto; width: auto; } } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Example Domain\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;This domain is for use in illustrative examples in documents. You may use this domain in literature without prior coordination or asking for permission.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://www.iana.org/domains/example\u0026quot;\u0026gt;More information...\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; "},{"id":82,"href":"/chapter-5/go-http-client-advanced/","title":"5.9 کتابخانه http سمت کلاینت پیشرفته","section":"فصل پنجم: برنامه نویسی شبکه با گو","content":"در قسمت قبل به ایجاد یک کلاینت http ساده و ارسال یک درخواست با متد get پرداختیم.\nدر این قسمت به موارد کامل تر و جزیی تر کلاینت http میپردازیم.\nبرای انجام تمرین های این قسمت از یک api تستی که جهت یادگیری ساخته شده است استفاده میکنیم (شما میتوانید از هر api یا سروری استفاده کنید حتی سرور http که خودتان نوشته باشید.)\nدر این آموزش ما از api زیر استفاده میکنیم: api docs\n5.9.1 نوع درخواست های یک سرور http # یکی از مواردی که حین اتصال به یک سرور http باید مورد توجه قرار بگیرد متد یا نوع درخواست است.\nانواع متد ها: GET : پیام هایی که در این روش ارسال می‌شوند تنها برای دریافت اطلاعات از سرور میباشد.\nPOST : در این نوع پیام ها اطلاعاتی برای ثبت شدن در سرور به سمت سرور http ارسال میشود\nPUT : در این روش برای جایگزاری مقداری در سرور اطلاعاتی ارسال میشود.\nDELETE : از این روش برای حذف مقداری از روی سرور استفاده میشود\nPATCH : این روش برای ویرایش جزیی استفاده میشود.\nاین موارد ۵ تا از پرکابرد ترین نوع درخواست های http هستند.\n5.9.2 نوع پاسخ های یک سرور http # در پاسخ یک سرور http یکی از موارد پر اهمیت کد وضعیت یا status code است. این کد ها اعدادی بین ۱۰۰ تا ۵۹۹ هستند که نشان دهنده وضعیت درخوایت از سمت سرور میباشند.\nانواع کد وضعیت: 1XX: این دسته از کد های وضعیت نمایانگر اطلاعات درخواست هستند\n2XX: این دسته از کد های وضعیت نمایانگر موفقیت درخواست در ارسال ثبت یا ویرایش اطلاعات میباشد\n3xx: این دسته از کد های نشانگر ریدایرکت میباشد\n4xx: این دسته از کد ها نشانگر ارور از سمت کلاینت میباشند\n5xx: این دسته از کد های نشانگر ارور از سمت سرور میباشند\nدر قسمت های بعد به پیاده سازی کلاینت و سرور HTTP خواهیم پرداخت و شاهد این موارد در عمل خواهید بود.\nدر قسمت زیر فهرست تعدادی از کد های وضعیت پرکاربرد را میبینیم:\n200 ok : این کد وضعیت نشانگر موفقیت در پاسخ به متد GET است 404 NotFound : این کد وضعیت نشانگر پیدا نشدن مقدار درخواستی کاربر در سرور است که یکی از معروف ترین کد های وضعیت است 500 InternalServerError: این کد وضعیت نشانگر خطای فنی از سمت سرور است 401 Unauthorized : این کد وضعیت نشانگر این است که درخواست ارسال شده نیاز به احراز هویت دارد 403 Forbidden : این کد وضعیت نشانگر این است که دسترسی به URL مورد نظر نیازمند سطح دسترسی متفاوتی است(این مورد با ۴۰۱ متفاوت است) 5.9.3 GET request # در مرحله اول به ایجاد یک درخواست GET به سرور میپردازیم.\npackage main import ( \"fmt\" \"io/ioutil\" \"net/http\" ) func main() { // به url مورد نظر برای دریافت لیست محصولات موجود یک درخوایت با متد GET ایجاد میکنیم resp, err := http.Get(\"https://fakestoreapi.com/products\") if err != nil { fmt.Println(\"Error:\", err) return } defer resp.Body.Close() // کد وضعیت پاسخ سرور را چاپ میکنیم fmt.Println(resp.StatusCode) // خروجی را در یک اسلایس ذخیره میکنیم body, err := ioutil.ReadAll(resp.Body) if err != nil { fmt.Println(\"Error:\", err) return } // خروجی را چاپ میکنیم fmt.Println(string(body)) } ▶ اجرای کد کپی ✖ بستن خروجی خروجی:\n[ { \u0026quot;id\u0026quot;:1, \u0026quot;title\u0026quot;:\u0026quot;Fjallraven - Foldsack No. 1 Backpack, Fits 15 Laptops\u0026quot;,\u0026quot;price\u0026quot;:109.95,\u0026quot;description\u0026quot;:\u0026quot;Your perfect pack for everyday use and walks in the forest. Stash your laptop (up to 15 inches) in the padded sleeve, your everyday\u0026quot;, \u0026quot;category\u0026quot;:\u0026quot;men's clothing\u0026quot;, \u0026quot;image\u0026quot;:\u0026quot;https://fakestoreapi.com/img/81fPKd-2AYL._AC_SL1500_.jpg\u0026quot;, \u0026quot;rating\u0026quot;:{\u0026quot;rate\u0026quot;:3.9,\u0026quot;count\u0026quot;:120} }, // ..... ] 5.9.4 POST request # در مرحله بعد با استفاده از متد POST یک محصول جدید به سرور اضافه میکنیم.\npackage main import ( \"bytes\" \"fmt\" \"net/http\" ) func main() { url := \"https://fakestoreapi.com/products\" // جیسان مورد نظر برای ارسال و ثبت در سرور را ایجاد میکنیم (مقادیر مورد نیاز در مستندات api ذکر میشود) jsonStr := []byte(` { title: 'test product', price: 13.5, description: 'lorem ipsum set', image: 'https://i.pravatar.cc', category: 'electronic' } `) // یک درخواست یه ادرس سرور میسازیم req, err := http.NewRequest(\"POST\", url, bytes.NewBuffer(jsonStr)) if err != nil { fmt.Println(err) } client := \u0026http.Client{} // درخواست را انجام میدهیم resp, err := client.Do(req) if err != nil { fmt.Println(err) } defer resp.Body.Close() // کد وضعیت و پاسخ سرور را چاپ میکنیم fmt.Println(\"Status:\", resp.Status) fmt.Println(\"Response:\", resp) } ▶ اجرای کد کپی ✖ بستن خروجی در صورت برابر بودن کد وضعیت با ۲۰۰ محصول ایجاد شده توسط شما با موفقیت ثبت شده است.\n5.9.5 DELETE request # در مرحله بعد به ایجاد یک درخواست DELETE و پاک کردن یک محصول از سرور میپردازیم:\npackage main import ( \"fmt\" \"net/http\" ) func main() { // شماره محصول مورد نظر را در انتهای url اضافه میکنیم (طبق مستندات) url := \"https://fakestoreapi.com/products/1\" // یک درخواست با متد DELETE ایجاد میکنیم req, err := http.NewRequest(\"DELETE\", url, nil) if err != nil { fmt.Println(err) } client := \u0026http.Client{} // درخواست را به سرور ارسال میکنیم resp, err := client.Do(req) if err != nil { fmt.Println(err) } defer resp.Body.Close() // درصورت موفقیت آمیز بودن درخواست خروجی عدد 200 است fmt.Println(\"Status:\", resp.Status) } ▶ اجرای کد کپی ✖ بستن خروجی 5.9.6 PUT request # در مرحله بعد به ایجاد یک درخواست PUT و اپدیت کردن اطلاعات یک محصول میپردازیم:\npackage main import ( \"bytes\" \"fmt\" \"net/http\" ) func main() { // ایدی محول مورد نظر را به انتهای url اضافه میکنیم url := \"https://fakestoreapi.com/products/7\" // مقدار های جدید را برای اپدیت شدن وارد میکنیم requestBody := []byte(` { title: 'test product', price: 13.5, description: 'lorem ipsum set', image: 'https://i.pravatar.cc', category: 'electronic' } `) ‍‍ // درخواست را ایجاد میکنیم req, err := http.NewRequest(\"PUT\", url, bytes.NewBuffer(requestBody)) if err != nil { fmt.Println(err) return } client := \u0026http.Client{} // درخواست را به سرور ارسال میکنیم resp, err := client.Do(req) if err != nil { fmt.Println(err) return } defer resp.Body.Close() // درصورت 200 بودن کد وضعیت اپدیت با موفقیت انجام شده. fmt.Println(resp.StatusCode) } ▶ اجرای کد کپی ✖ بستن خروجی "},{"id":83,"href":"/chapter-5/go-quic-prtoocol/","title":"5.10 پروتکل quic","section":"فصل پنجم: برنامه نویسی شبکه با گو","content":"پروتکل quic یک پروتکل توسعه یافته توسط google است. این پروتکل برای امنیت و سرعت بیشتر توسعه داده شده است.\nپروتکل quic از UDP استفاده میکند و در لایه transport قرار میگیرد.\nاین پروتکل اجازه ایجاد چند کانکشن بصورت همزمان را فراهم میکنید و همچنین http/3 بر اساس این پروتکل طراحی و ایجاد شده است.\nچند مورد از ویژگی های کلیدی quic : ۱. ایجاد کانکشن سریع تر به دلیل اسفاده از udp. ۲. نیازی به دست دادن سه مرحله مثل tcp ندارد. ۳. بصورت پیش فرص از رمزنگاری استفاده میکند.\nدر ادامه با استفاده از یک پکیج خارجی به نام quic-go یک سرور ساده با این پروتکل ایجاد میکنیم و یک پیام به آن ارسال میکنیم (عملکرد سرور ما تنها برگرداندن همان متن یا به اصطلاحی echo کردن آن است)\nبرای شروع کار ابتدا نیاز داریم پکیج مورد نظر خود را نصب کنیم\nبا استفاده از دستور زیر: go get github.com/quic-go/quic-go\nبعد از اتمام مرحله نصب شروع به نوشتن کد سرور و کلاینت خود میکنیم.\npackage main import ( \"context\" \"crypto/rand\" \"crypto/rsa\" \"crypto/tls\" \"crypto/x509\" \"encoding/pem\" \"fmt\" \"io\" \"log\" \"math/big\" \"github.com/quic-go/quic-go\" ) const addr = \"localhost:4242\" // the message we sent to server you can also change it! const message = \"hello gifarsi!\" // starting the server and call the client function. func main() { go func() { log.Fatal(echoServer()) }() err := clientMain() if err != nil { panic(err) } } // this function start our echo server func echoServer() error { // make a new listner with quic listener, err := quic.ListenAddr(addr, generateTLSConfig(), nil) if err != nil { return err } // accept incoming connections conn, err := listener.Accept(context.Background()) if err != nil { return err } // accept incoming streams stream, err := conn.AcceptStream(context.Background()) if err != nil { panic(err) } // Echo using the loggingWriter _, err = io.Copy(loggingWriter{stream}, stream) return err } // client function thah send the message to our server func clientMain() error { // set up a tls config tlsConf := \u0026tls.Config{ InsecureSkipVerify: true, NextProtos: []string{\"quic-echo-example\"}, } // dial with our udp server conn, err := quic.DialAddr(context.Background(), addr, tlsConf, nil) if err != nil { return err } // opening a new stream from our connection stream, err := conn.OpenStreamSync(context.Background()) if err != nil { return err } // write the message over the stream fmt.Printf(\"Client: Sending '%s'\\n\", message) _, err = stream.Write([]byte(message)) if err != nil { return err } // read and print incoming answer from server buf := make([]byte, len(message)) _, err = io.ReadFull(stream, buf) if err != nil { return err } fmt.Printf(\"Client: Got '%s'\\n\", buf) return nil } // A wrapper for io.Writer that also logs the message. type loggingWriter struct{ io.Writer } func (w loggingWriter) Write(b []byte) (int, error) { fmt.Printf(\"Server: Got '%s'\\n\", string(b)) return w.Writer.Write(b) } // Setup a bare-bones TLS config for the server func generateTLSConfig() *tls.Config { key, err := rsa.GenerateKey(rand.Reader, 1024) if err != nil { panic(err) } template := x509.Certificate{SerialNumber: big.NewInt(1)} certDER, err := x509.CreateCertificate(rand.Reader, \u0026template, \u0026template, \u0026key.PublicKey, key) if err != nil { panic(err) } keyPEM := pem.EncodeToMemory(\u0026pem.Block{Type: \"RSA PRIVATE KEY\", Bytes: x509.MarshalPKCS1PrivateKey(key)}) certPEM := pem.EncodeToMemory(\u0026pem.Block{Type: \"CERTIFICATE\", Bytes: certDER}) tlsCert, err := tls.X509KeyPair(certPEM, keyPEM) if err != nil { panic(err) } return \u0026tls.Config{ Certificates: []tls.Certificate{tlsCert}, NextProtos: []string{\"quic-echo-example\"}, } } ▶ اجرای کد کپی ✖ بستن خروجی بعد از اتمام نوشتن کد های سرور میتوانیم کد خود را اجرا و تست کنیم\ngo run main.go\nخروجی لاگ های ما به این صورت خواهد بود :\nClient: Sending 'hello gifarsi!' Server: Got 'hello gifarsi!' Client: Got 'hello gifarsi!' در انتها توجه داشته باشید این یک مثال ساده از quic در گولنگ بود شما میتوانید با استفاده از همین پکیج سرور های کامل تر و پیچیده تر را توسعه دهید و همچنین با استفاده از quic-go/http3 یک سرور http3 توسعه دهید.\n"},{"id":84,"href":"/chapter-4/go-project-layout/","title":"4.26 ساختار پروژه","section":"فصل چهارم: مباحث پیشرفته","content":" 4.26.1 نمای کلی project-layout # این متن یک طرح اساسی برای پروژه‌های برنامه‌نویسی به زبان Go است. توجه داشته باشید که این طرح از نظر محتوا ساده است، زیرا فقط روی layout کلی تمرکز دارد و نه آنچه در داخل آن قرار دارد. همچنین ساده است هر چند که از نظر محتوی پیشرفته است ولی به جزئیات زیادی در مورد نحوه ساختاردهی بیشتر پروژه شما نمی‌پردازد. برای مثال، سعی نمی‌کند ساختار پروژه‌ای را با چیزی مانند Clean Architecture پوشش دهد. برای بررسی نمونه کدهای مشابه و مرجع این متن به این لینک مراجعه کنید. این یک استاندارد رسمی تعریف شده توسط تیم توسعه اصلی Go نیست. این مجموعه‌ای از الگوهای layout پروژه‌های رایج با سابقه و نوظهور در اکوسیستم Go است. برخی از این الگوها از بقیه محبوب‌تر هستند. همچنین دارای تعدادی بهبود کوچک همراه با چندین دایرکتوری پشتیبانی مشترک در هر برنامه واقعی به اندازه کافی بزرگ است. توجه داشته باشید که تیم اصلی Go مجموعه خوبی از دستورالعمل‌های عمومی در مورد ساختاردهی پروژه‌های Go و معنای آن برای پروژه شما هنگام وارد شدن و نصب آن ارائه می‌دهد. برای اطلاعات بیشتر، به صفحه Organizing a Go module در اسناد رسمی Go مراجعه کنید. این صفحه شامل الگوهای دایرکتوری داخلی و cmd (که در زیر توضیح داده شده است) و سایر اطلاعات مفید است. اگر در حال یادگیری Go هستید یا یک PoC یا یک پروژه ساده برای خودتان می‌سازید، این طرح پروژه بیش از حد پیچیده است. در عوض، با چیزی بسیار ساده شروع کنید (یک فایل main.go و go.mod بیش از اندازه کافی است). با پیشرفت پروژه، به خاطر داشته باشید که ساختاردهی مناسب کد شما بسیار مهم خواهد بود، در غیر این صورت در نهایت با یک کد نامرتب با وابستگی‌های پنهان (hidden dependencies) و global state زیادی مواجه خواهید شد. وقتی افراد بیشتری روی پروژه کار می‌کنند، به ساختار بیشتری نیاز خواهید داشت. در این زمان است که معرفی یک روش مشترک برای مدیریت بسته‌ها/کتابخانه‌ها اهمیت دارد. وقتی یک پروژه متن‌باز دارید یا می‌دانید که پروژه‌های دیگر کد را از مخزن پروژه شما وارد می‌کنند، آن زمان است که داشتن بسته‌ها و کدهای خصوصی (معادل internal) اهمیت دارد. repository را کپی کنید، آنچه را که نیاز دارید نگه دارید و بقیه را حذف کنید! فقط به این دلیل که وجود دارد، به این معنی نیست که باید از همه آن استفاده کنید. هیچ یک از این الگوها در هر پروژه‌ای استفاده نمی‌شوند. حتی الگوی vendor نیز universal نیست. با آمدن Go 1.14 در نهایت Go Modules برای production آماده شدند. از Go Modules استفاده کنید، مگر اینکه دلیل خاصی برای استفاده نکردن از آن‌ها داشته باشید و اگر اینطور است، نیازی به نگرانی در مورد $GOPATH و جایی که پروژه خود را قرار می‌دهید ندارید. فایل go.mod پایه در مخزن فرض می‌کند که پروژه شما در GitHub میزبانی می‌شود، اما این یک الزام نیست. module path می‌تواند هر چیزی باشد، اگرچه اولین جزء module path باید یک نقطه در نام خود داشته باشد (نسخه فعلی Go دیگر آن را اجباری نمی‌کند، اما اگر از نسخه‌های کمی قدیمی‌تر استفاده می‌کنید، تعجب نکنید اگر ساخت‌های شما بدون آن شکست بخورد). اگر می‌خواهید درباره آن بیشتر بدانید، به Issues 37554 و 32819مراجعه کنید. این طرح پروژه عمداً عمومی است و سعی نمی‌کند یک ساختار پکیج Go خاص را تحمیل کند. این یک تلاش مشترک است. اگر الگوی جدیدی مشاهده کردید یا فکر می‌کنید یکی از الگوهای موجود نیاز به به‌روزرسانی دارد، یک issue را باز کنید. اگر به کمک در مورد نام‌گذاری، قالب‌بندی و style نیاز دارید، ابتدا gofmt و staticcheck را اجرا کنید. linter استاندارد قبلی، golint، اکنون منسوخ شده است و نگهداری نمی‌شود؛ استفاده از یک linter در حال توسعه و نگهداری شده مانند staticcheck توصیه می‌شود. همچنین مطمئن شوید که این دستورالعمل‌ها و توصیه‌های Go code style را بخوانید:\nhttps://talks.golang.org/2014/names.slide https://golang.org/doc/effective_go.html#names https://blog.golang.org/package-names https://go.dev/wiki/CodeReviewComments Style guideline for Go packages (rakyll/JBD) برای اطلاعات بیشتر ، Go Project Layout را ببینید. اطلاعات بیشتر در مورد نامگذاری و سازماندهی بسته‌ها و همچنین سایر توصیه‌های ساختار کد: GopherCon EU 2018: Peter Bourgon-Best Practices for Industrial Programming GopherCon Russia 2018: Ashley McNamara + Brian Ketelsen - Go best practices. GopherCon 2017: Edward Muller-Go Anti-Patterns GopherCon 2018: Kat Zien - How Do You Structure Your Go Apps 4.25.2 دایرکتوری‌ها در Go # /cmd # این دایرکتوری شامل برنامه‌های اصلی پروژه شما است. نام هر دایرکتوری فرعی باید با نام برنامه اجرایی مطابقت داشته باشد (برای مثال، /cmd/myapp). از قرار دادن حجم کد زیاد در دایرکتوری برنامه خودداری کنید. اگر فکر می‌کنید این کد‌ها قابلیت وارد شدن و استفاده در پروژه‌های دیگر را دارد، باید در دایرکتوری /pkg قرار گیرد. اگر کد قابل استفاده مجدد نیست یا نمی‌خواهید دیگران از آن استفاده مجدد کنند، آن کد را در دایرکتوری /internal قرار دهید. تعجب خواهید کرد که دیگران چه کارهایی انجام می‌دهند، بنابراین در مورد اهداف خود صریح باشید! معمولاً یک تابع اصلی کوچک وجود دارد که کد را از دایرکتوری‌های /internal و /pkg وارد کرده و فراخوانی می‌کند و کار دیگری انجام نمی‌دهد. به‌عنوان‌مثال به دایرکتوری /cmd مراجعه کنید.\n/internal # شامل کد Private application و library code است. این کدی است که نمی‌خواهید دیگران آن را در برنامه‌ها یا کتابخانه‌های خود وارد کنند. توجه داشته باشید که این الگوی چیدمان توسط خود کامپایلر Go اعمال می‌شود. برای جزئیات بیشتر، Go 1.4 release notesرا ببینید. توجه داشته باشید که شما به دایرکتوری internal سطح بالا محدود نیستید. شما می‌توانید در هر سطحی از درخت پروژه خود بیش از یک دایرکتوری internal داشته باشید. به‌صورت اختیاری می‌توانید برای جدا کردن کد داخلی مشترک و غیرمشترک خود، کمی ساختار اضافی به بسته‌های داخلی (internal packages) خود اضافه کنید. این کار الزامی نیست (به ویژه برای پروژه‌های کوچک‌تر)، اما داشتن نشانه‌های بصری برای نشان دادن نحوه استفاده موردنظر package بسیار مناسب است. کد application واقعی شما می‌تواند در دایرکتوری /internal/app (مثلاً /internal/app/myapp) و کد مشترک بین آن برنامه‌ها در دایرکتوری /internal/pkg/ (مثلاً , /internal/pkg/myprivlib) قرار گیرد. شما از دایرکتوری‌های internal برای private کردن package‌ها استفاده می‌کنید. اگر یک package را داخل یک internal directory قرار دهید، بسته‌های دیگر نمی‌توانند آن را وارد کنند مگر اینکه یک جد مشترک (common ancestor) داشته باشند. این تنها دایرکتوری‌ای است که در مستندات Go نام برده شده و نحوه برخورد با آن توسط کامپایلر Go خاص و متفاوت است.\n/pkg # کد کتابخانه که امکان استفاده توسط برنامه‌های خارجی را دارد (به‌عنوان مثال، /pkg/mypubliclib). سایر پروژه‌ها این کتابخانه‌ها را import می‌کنند و انتظار کارکرد درست آنها را دارند، بنابراین قبل از قرار دادن چیزی در اینجا خوب فکر کنید :-) و توجه داشته باشید که internal directory، راه بهتری برای اطمینان از وارد نشدن private packages شماست، زیرا توسط Go اجرا می‌شود. دایرکتوری /pkgهمچنان راه خوبی برای بیان صریح این است که کد موجود در آن دایرکتوری برای استفاده توسط دیگران ایمن است. مقاله وبلاگ « I'll take pkg over internal» توسط Travis Jeffery، نمای کلی خوبی از دایرکتوری‌های pkg و internal و زمان‌هایی که استفاده از آنها منطقی است ارائه می‌دهد. همچنین این راهی برای گروه‌بندی کد Go در یک مکان است، زمانی که دایرکتوری اصلی شما حاوی بسیاری از اجزا و دایرکتوری‌های غیر Go باشد، این کار اجرای ابزارهای مختلف Go را آسان‌تر می‌کند (همانطور که در این سخنرانی‌ها ذکر شده است: Best Practices for Industrial Programming از GopherCon EU و GopherCon 2018: Kat Zien - How Do You Structure Your Go Apps و GoLab 2018 - Massimiliano Pippi - Project layout patterns in Go). اگر می‌خواهید ببینید کدام مخازن محبوب Go از این layout pattern پروژه استفاده می‌کنند، به دایرکتوری /pkg مراجعه کنید. این یک الگوی layout رایج است، اما به‌طور جهانی پذیرفته نشده است و برخی از اعضای جامعه Go آن را توصیه نمی‌کنند. اگر پروژه برنامه‌ی شما واقعاً کوچک است و جایی که لایه‌ی اضافی تودرتو بودن ارزش زیادی اضافه نمی‌کند، استفاده نکردن از آن اشکالی ندارد (مگر اینکه واقعاً بخواهید :-)). در مورد آن فکر کنید زمانی که پروژه به اندازه کافی بزرگ می شود و دایرکتوری اصلی شما شلوغ می شود (به خصوص اگر اجزای برنامه غیر Go زیادی دارید). ریشه‌های دایرکتوری pkg: کد منبع قدیمی Go برای بسته‌های خود از pkg استفاده می‌کرد و سپس پروژه‌های مختلف Go در جامعه شروع به کپی کردن این الگو کردند (برای درک بهتر به این توییت Brad Fitzpatrick مراجعه کنید).\n/vendor # وابستگی‌های برنامه (به‌صورت دستی یا توسط ابزار مدیریت وابستگی مورد علاقه شما مانند ویژگی جدید Go Modulesداخلی مدیریت می‌شود). دستور go mod vendor دایرکتوری vendor/ را برای شما ایجاد می‌کند. توجه داشته باشید که اگر از Go 1.14 استفاده نمی‌کنید که به صورت پیش‌فرض فعال است، ممکن است نیاز به اضافه کردن پرچم -mod=vendor به دستور go build خود داشته باشید. اگر در حال ساخت کتابخانه هستید، وابستگی‌های برنامه خود را commit نکنید. توجه داشته باشید که از Go 1.13 ، قابلیت module proxy نیز در Go فعال شد (که به طور پیش‌فرض از https://proxy.golang.org به عنوان سرور پراکسی ماژول خود استفاده می‌کند). برای اینکه ببینید آیا این قابلیت با تمام الزامات و محدودیت‌های شما مطابقت دارد، در اینجا بیشتر در مورد آن بخوانید. اگر اینطور باشد، اصلاً به دایرکتوری vendor نیاز نخواهید داشت.\n4.26.3 دایرکتوری‌های سرویس application # /api # مشخصات OpenAPI/Swagger، فایل‌های JSON schema، فایل‌های تعریف پروتکل. برای مثال به دایرکتوری /api/ مراجعه کنید.\n4.26.4 دایرکتوری‌های سرویس وب # اجزای خاص برنامه وب: static web assets و templateهای سمت سرور و SPAها.\n4.26.5 دایرکتوری‌های مشترک در application # /configs # قالب‌های فایل پیکربندی یا تنظیمات پیش‌فرض. فایل‌های قالب confd یا consul-template خود را اینجا قرار دهید.\n/init # پیکربندی‌های init سیستم (systemd، upstart، sysv) و process manager/supervisor (runit, supervisord).\n/scripts # اسکریپت‌هایی برای انجام عملیات‌های مختلف build, install, analysis و غیره. این اسکریپت‌ها Makefile سطح ریشه را کوچک و ساده نگه می‌دارند (به عنوان مثال،https://github.com/hashicorp/terraform/blob/main/Makefile). برای مثال به دایرکتوری scripts/ مراجعه کنید.\n/build # ‏برای Packaging و Continuous Integration\nپیکربندی‌ها و اسکریپت‌های package‌های ابری (AMI)، کانتینری (Docker)، سیستم‌عامل (deb، rpm، pkg) را در این دایرکتوری قرار دهید. /build # پیکربندی‌ها و اسکریپت‌های CI (travis، circle، drone) را در این دایرکتوری قرار دهید. توجه داشته باشید که برخی از ابزارهای CI (مانند Travis CI) در مورد مکان فایل‌های پیکربندی خود بسیار حساس هستند. سعی کنید فایل‌های پیکربندی را در دایرکتوری /build/ci قرار داده و آن‌ها را به مکانی که ابزارهای CI انتظار دارند (در صورت امکان) لینک کنید. /deployments # پیکربندی‌ها و قالب‌های deployment یا استقرار IaaS، PaaS، سیستم و orchestration کانتینر (dockerCompose, kubernetes/helm, terraform). توجه داشته باشید که در برخی از repoها (به ویژه برنامه‌هایی که با kubernetes استقرار می‌یابند) این دایرکتوری deploy/ نامیده می‌شود. /test # برنامه‌های تست خارجی اضافی و داده‌های تست. می‌توانید دایرکتوری test/ را به هر شکلی که می‌خواهید ساختار دهید. برای پروژه‌های بزرگ‌تر، داشتن یک زیردایرکتوری data منطقی است. برای مثال، می‌توانید test/testdata/ یا test/data/ را داشته باشید اگر نیاز دارید که Go آنچه در آن دایرکتوری است را نادیده بگیرد. توجه داشته باشید که Go همچنین دایرکتوری‌ها یا فایل‌هایی که با \u0026ldquo;.\u0026rdquo; یا \u0026quot;\u0026quot; شروع می‌شوند را نادیده می‌گیرد، بنابراین در نحوه نام‌گذاری دایرکتوری داده‌های تست خود انعطاف بیشتری دارید. برای نمونه‌ها به دایرکتوری test/مراجعه کنید. دایرکتوری‌های دیگر # اسناد طراحی و کاربر (علاوه بر مستندات ایجاد شده توسط godoc شما). برای مثال به دایرکتوری docs/ مراجعه کنید.\n/tools # ابزارهای پشتیبانی این پروژه توجه داشته باشید که این ابزارها می توانند کد را از دایرکتوری های pkg/ و internal/ وارد کنند. برای مثال به دایرکتوری tools/ مراجعه کنید.\n/examples # نمونه‌هایی برای application و یا کتابخانه‌های public شما. برای مثال به دایرکتوری examples/ مراجعه کنید.\n/third_party # ابزارهای کمکی خارجی، کد fork شده و سایر ابزارهای شخص ثالث (مانند Swagger UI).\n/githooks # برای Git hooks.\n/assets # سایر assetها برای همراهی با repository شما (image, logoها و غیره).\n/website # اگر از GitHub pages استفاده نمی‌کنید، اینجا مکانی است که می توانید داده‌های وب‌سایت پروژه خود را قرار دهید. برای مثال به دایرکتوری website/مراجعه کنید.\nدایرکتوری‌هایی که نباید داشته باشید # /src # برخی از پروژه‌های Go دارای یک پوشه src هستند، اما این معمولاً زمانی اتفاق می‌افتد که توسعه‌دهندگان از دنیای جاوا آمده‌اند که در آنجا یک الگوی رایج است. اگر می‌توانید، سعی کنید این الگوی جاوا را نپذیرید. شما واقعاً نمی‌خواهید که کد Go یا پروژه‌های Go شما شبیه جاوا به نظر برسند :-) دایرکتوری /src در سطح پروژه را با دایرکتوری /src که Go برای کارگاه‌های خود استفاده می‌کند، اشتباه نگیرید که در How to Write Go Code توضیح داده شده است. $GOPATH environment variable به (current) workspace فعلی شما اشاره می‌کند (به طور پیش‌فرض به $HOME/go در سیستم‌های غیر ویندوزی اشاره می‌کند). این workspace شامل دایرکتوری‌های سطح بالا /pkg, /bin و /src است. پروژه واقعی شما در نهایت یک زیردایرکتوری زیر /src می‌شود، بنابراین اگر دایرکتوری /src را در پروژه خود دارید، مسیر پروژه به این شکل خواهد بود: /some/path/to/workspace/src/your_project/src/your_code.go. توجه داشته باشید که با Go 1.11 امکان دارد پروژه خود را خارج از GOPATH خود داشته باشید، اما این هنوز به معنای این نیست که استفاده از این الگوی layout pattern ایده خوبی است.\n4.26.6 بررسی Badgeها # ‏ Go Report Card کد شما را با gofmt، go vet، gocyclo، golint، ineffassign، مجوز و غلط املایی اسکن می کند. مرجع پروژه خود را جایگزین github.com/golang-standards/project-layout کنید. ‏ GoDoc این نسخه آنلاین اسناد تولید شده GoDoc شما را ارائه می‌دهد. link را تغییر دهید تا به پروژه شما اشاره کند. ‏ Pkg.go.dev ‏ Pkg.go.dev مقصد جدیدی برای شناسایی و مستندات Go است. می‌توانید با استفاده از badge generation toolآن را ایجاد کنید. در مورد Release - آخرین شماره انتشار پروژه شما را نشان می دهد. لینک github را تغییر دهید تا به پروژه شما اشاره کند.\n4.26.8 نکته‌ها # یک الگوی پروژه با نظر بیشتر با تنظیمات sample/reusable استفاده مجدد، اسکریپت‌ها و کد یک WIP است.\n"},{"id":85,"href":"/chapter-4/go-io-package/","title":"4.27 آموزش کار با پکیج io","section":"فصل چهارم: مباحث پیشرفته","content":" پکیج io در زبان Go یکی از ابزارهای پایه و همه‌فن‌حریف برای کار با عملیات Input/Output است. فلسفه‌اش اینه که ما بدون وابستگی به نوع خاص داده (مثل فایل، شبکه یا حافظه) بتونیم از یک Interface ساده استفاده کنیم. این یعنی اگر یک شیء فقط متد مورد نیاز رو پیاده‌سازی کنه، می‌تونه در تمام جاهایی که اون رابط انتظار میره استفاده بشه. مثلا io.Reader فقط یک متد Read داره و io.Writer یک متد Write، ولی همین دو قرارداد ساده پایه تمام سیستم I/O Abstraction در Go رو تشکیل میدن.\nاینترفیس‌های اصلی این پکیج مثل io.Reader و io.Writer رو میشه ترکیب کرد و ساختارهای جدیدی ساخت، مثل io.ReadWriter که هم قابلیت خواندن داره و هم نوشتن، یا io.ReadCloser که علاوه بر خواندن، قابلیت بستن منبع داده رو هم فراهم می‌کنه. این ترکیب‌ها به ما امکان میدن با منابع داده‌ای مختلف، از فایل گرفته تا اتصال شبکه، به شکلی یکپارچه کار کنیم. وقتی کد رو بر اساس اینترفیس‌ها بنویسیم، نه‌تنها تست‌پذیرتر و قابل توسعه‌تر میشه، بلکه وابستگی به پیاده‌سازی‌های خاص هم از بین میره.\nپکیج io فقط به رابط‌ها محدود نیست و مجموعه‌ای از Helper Functions رو هم ارائه میده که کار رو به شدت ساده‌تر و بهینه‌تر می‌کنن. مثلا io.Copy داده رو مستقیم از یک Reader به یک Writer منتقل می‌کنه بدون اینکه ما نیاز به نوشتن حلقه خواندن و نوشتن داشته باشیم. io.MultiWriter خروجی رو به چند مقصد به طور همزمان ارسال می‌کنه، و io.TeeReader برای زمانی که می‌خوای داده رو بخونی و همزمان یک نسخه ازش رو برای Logging یا Debugging ذخیره کنی عالیه. همچنین ابزارهایی مثل io.LimitReader یا io.SectionReader وجود دارن که اجازه میدن فقط بخش خاصی از داده رو پردازش کنیم.\nدر بخش پیشرفته‌تر، این پکیج امکاناتی مثل io.Pipe رو هم ارائه میده که دو سر ورودی و خروجی رو به هم وصل می‌کنه و به‌ویژه برای Streaming و ارتباط بین Goroutines بسیار کاربردیه. نکته مهم توی استفاده از این پکیج مدیریت درست خطاست؛ مثلا تفاوت io.EOF که فقط نشون‌دهنده پایان داده‌ست با یک خطای واقعی رو باید بدونیم. همچنین استفاده از بافرها (bufio) برای بهبود کارایی و کاهش هزینه I/O در پروژه‌های Production توصیه میشه.\n4.27.1 معرفی پکیج io و فلسفه طراحی # پکیج io در زبان Go یک بخش کلیدی از کتابخانه استاندارد است که پایه و اساس تمام عملیات Input/Output را فراهم می‌کند. هدف اصلی این پکیج، ایجاد یک Abstraction ساده اما قدرتمند برای خواندن و نوشتن داده است، بدون این‌که برنامه‌نویس به منبع یا مقصد خاصی وابسته باشد. این یعنی چه داده از یک فایل بیاید، چه از یک اتصال شبکه یا حتی از حافظه، کدی که آن را پردازش می‌کند یکسان خواهد بود.\nدر قلب این پکیج دو Interface بسیار ساده قرار دارند: io.Reader و io.Writer.\nio.Reader: فقط یک متد Read دارد که داده را به صورت بایت‌اسلایس می‌خواند. io.Writer: فقط یک متد Write دارد که داده را به یک مقصد ارسال می‌کند. هر نوعی (type) که این متدها را پیاده‌سازی کند، به طور خودکار به یک منبع یا مقصد داده قابل استفاده در اکوسیستم io تبدیل می‌شود. همین سادگی باعث شده که اجزای مختلف سیستم، از جمله پکیج‌هایی مثل os، net، bufio و compress، بتوانند به راحتی با هم ترکیب شوند.\nیکی از مزیت‌های بزرگ این طراحی این است که به‌جای وابستگی به نوع خاص، وابستگی به رفتار داریم. مثلا تابعی که یک io.Reader را می‌گیرد، می‌تواند بدون تغییر، هم از یک فایل روی دیسک بخواند و هم از یک جریان داده آنلاین یا حتی داده تولیدشده در حافظه. این قابلیت انعطاف‌پذیری بالا را ممکن می‌سازد و کد را برای تست و توسعه آسان‌تر می‌کند.\nدر نتیجه، پکیج io نه فقط یک ابزار برای کار با داده، بلکه یک لایه انتزاعی است که ساختار و معماری برنامه را ساده، منسجم و مقیاس‌پذیر نگه می‌دارد. این فلسفه مینیمالیستی و ماژولار، از دلایلی است که Go را برای پروژه‌های بزرگ و طولانی‌مدت به انتخابی محبوب تبدیل کرده است.\n4.27.1.1 اهمیت abstraction در I/O # وقتی صحبت از Input/Output می‌شود، خیلی‌ها اولین چیزی که به ذهنشان می‌رسد یک فایل روی دیسک یا یک اتصال شبکه است. اما در عمل، منابع داده می‌توانند بسیار متنوع باشند: یک فایل محلی، یک API، یک بافر حافظه، یا حتی داده تولیدشده لحظه‌ای توسط یک الگوریتم. اگر برای هر کدام بخواهیم کد جداگانه بنویسیم، خیلی زود با یک مجموعه توابع و کلاس‌های تکراری و پیچیده روبه‌رو می‌شویم که نگهداری آن‌ها کابوس خواهد بود.\nاینجاست که Abstraction وارد میدان می‌شود. با تعریف یک Interface مشترک مثل io.Reader یا io.Writer، می‌توانیم منطق اصلی کد را مستقل از منبع یا مقصد داده بنویسیم. این یعنی یک تابعی که داده را از ورودی می‌خواند و روی خروجی می‌نویسد، می‌تواند بدون تغییر هم روی فایل کار کند، هم روی شبکه، و هم روی داده‌های در حافظه.\nمثلا تصور کنید می‌خواهیم یک تابع بنویسیم که محتوا را از یک Reader به یک Writer منتقل کند:\nfunc TransferData(src io.Reader, dst io.Writer) error { _, err := io.Copy(dst, src) return err } این تابع اصلاً اهمیتی نمی‌دهد که src یک فایل است (*os.File)، یک اتصال TCP (net.Conn) یا حتی یک رشته متنی در حافظه (strings.Reader). کافی است آن منبع متد Read را داشته باشد. همین موضوع باعث می‌شود کد قابل استفاده مجدد، ساده و به راحتی تست‌پذیر شود.\nبه این شکل، abstraction در I/O مثل یک پل عمل می‌کند که لایه منطق برنامه را از جزئیات فنی منابع داده جدا می‌کند. این کار نه تنها خوانایی و نگهداری کد را بهتر می‌کند، بلکه توسعه ویژگی‌های جدید را هم سریع‌تر و بی‌خطرتر می‌سازد.\n4.27.1.2 نقش io در کتابخانه استاندارد Go # پکیج io رو میشه به‌نوعی ستون فقرات عملیات Input/Output در کل اکوسیستم Go دونست. خیلی از پکیج‌های کتابخانه استاندارد روی همین رابط‌های ساده io.Reader و io.Writer ساخته شدن. این یعنی وقتی با اینترفیس‌های io کار می‌کنید، عملاً دارید با یک استاندارد مشترک صحبت می‌کنید که بقیه پکیج‌ها هم اون رو می‌فهمن.\nبرای مثال:\nپکیج os که برای کار با فایل‌ها استفاده میشه، وقتی فایل رو با os.Open باز می‌کنید، یک شیء برمی‌گردونه که هم io.Reader هست، هم io.Writer، هم io.Seeker و هم io.Closer. پکیج net برای کار با شبکه، اتصالات TCP و HTTP رو به شکلی پیاده‌سازی کرده که اون‌ها هم این اینترفیس‌ها رو داشته باشن. پکیج bufio که برای افزایش کارایی از بافر استفاده می‌کنه، عملاً روی همین رابط‌ها سوار شده و می‌تونه هر چیزی که io.Reader یا io.Writer باشه رو بپذیره. پکیج‌های فشرده‌سازی مثل compress/gzip و compress/zlib هم با همین استاندارد کار می‌کنن، بنابراین می‌تونید یک فایل gzip رو بخونید و بدون تغییر خاصی روی خروجی HTTP بفرستید. این یکپارچگی باعث میشه بتونید اجزای مختلف رو خیلی راحت به هم وصل کنید. مثلا می‌تونید یک فایل فشرده رو باز کنید، خروجیش رو مستقیم از طریق شبکه بفرستید، یا برعکس داده‌های دریافتی رو مستقیماً داخل یک فایل ذخیره کنید، همه این‌ها فقط با چند خط کد.\nدر واقع پکیج io نقش یک زبان مشترک رو بین اجزای مختلف Go بازی می‌کنه. وقتی هر منبع یا مقصد داده این رابط‌ها رو پیاده‌سازی می‌کنه، شما می‌تونید اون‌ها رو به صورت ماژولار ترکیب کنید و بدون دغدغه از تفاوت‌های داخلی هر منبع، به یک جریان داده واحد برسید. این دقیقاً همون چیزی هست که Go رو در پروژه‌های بزرگ و چندبخشی، ساده و قابل اعتماد نگه می‌داره.\n4.27.2 اینترفیس‌های اصلی پکیج io # پکیج io بر پایه چند Interface کلیدی ساخته شده که هر کدوم رفتار مشخصی رو تعریف می‌کنن. این اینترفیس‌ها شبیه یک قرارداد عمل می‌کنن؛ هر نوعی که این قرارداد رو پیاده‌سازی کنه، می‌تونه به عنوان ورودی یا خروجی در هر کدی که با اون اینترفیس کار می‌کنه استفاده بشه. این رویکرد باعث میشه کدها انعطاف‌پذیر، قابل توسعه و ماژولار باقی بمونن.\n4.27.2.1 io.Reader و متد Read # io.Reader مهم‌ترین و پرکاربردترین اینترفیس پکیج io است:\ntype Reader interface { Read(p []byte) (n int, err error) } پارامتر p: یک Byte Slice است که داده‌ها در آن قرار می‌گیرند.\nبرگشتی n: تعداد بایت‌هایی که خوانده شده.\nبرگشتی err: اگر خطایی رخ دهد برگردانده می‌شود، که ممکن است io.EOF باشد تا پایان داده را نشان دهد.\nهر نوعی که این متد را پیاده‌سازی کند، می‌تواند به عنوان یک Reader استفاده شود. این منبع داده می‌تواند یک فایل، شبکه، حافظه یا هر چیز دیگری باشد.\nمثال ساده خواندن از یک رشته:\nr := strings.NewReader(\u0026quot;Hello IO\u0026quot;) buf := make([]byte, 4) for { n, err := r.Read(buf) fmt.Printf(\u0026quot;Read: %s\\n\u0026quot;, buf[:n]) if err == io.EOF { break } } یک مثال کامل:\npackage main import ( \"fmt\" \"io\" \"strings\" ) func main() { r := strings.NewReader(\"Hello IO\") buf := make([]byte, 4) for { n, err := r.Read(buf) if n \u003e 0 { fmt.Printf(\"Read: %s\\n\", buf[:n]) } if err == io.EOF { break } if err != nil { fmt.Println(\"Error:\", err) break } } } ▶ اجرای کد کپی ✖ بستن خروجی 4.27.2.2 io.Writer و متد Write # io.Writer مکمل io.Reader است:\ntype Writer interface { Write(p []byte) (n int, err error) } پارامتر p: داده‌هایی که باید نوشته شوند. برگشتی n: تعداد بایت‌هایی که نوشته شده‌اند. برگشتی err: خطا هنگام نوشتن (مثلاً فضای ناکافی یا قطع ارتباط). هر چیزی که متد Write را داشته باشد، می‌تواند مقصد داده باشد، چه این مقصد یک فایل باشد، چه یک اتصال شبکه یا حتی یک بافر حافظه.\nمثال ساده نوشتن روی خروجی استاندارد:\nmsg := []byte(\u0026quot;Hello Writer\\n\u0026quot;) os.Stdout.Write(msg) مثال کامل: package main import ( \"os\" ) func main() { msg := []byte(\"Hello Writer\\n\") _, err := os.Stdout.Write(msg) if err != nil { panic(err) } } ▶ اجرای کد کپی ✖ بستن خروجی 4.27.2.3 ترکیب اینترفیس‌ها # در پکیج io، اینترفیس‌ها می‌توانند با هم ترکیب شوند تا قابلیت‌های بیشتری ارائه دهند:\nio.ReadWriter: ترکیب Reader و Writer. io.ReadCloser: ترکیب Reader و Closer . io.WriteCloser: ترکیب Writer و Closer. io.ReadWriteCloser: ترکیب Reader، Writer و Closer. این ترکیب‌ها باعث می‌شوند بتوانید منابع داده‌ای داشته باشید که چندین قابلیت را همزمان ارائه می‌دهند، مثل یک فایل که هم قابل خواندن است، هم نوشتن و هم بستن.\nبه عنوان مثال: package main import ( \"fmt\" \"os\" ) func main() { // os.File هم Reader است، هم Writer، هم Closer file, err := os.Create(\"example.txt\") if err != nil { panic(err) } defer file.Close() _, err = file.Write([]byte(\"Hello File\\n\")) if err != nil { panic(err) } fmt.Println(\"Data written to example.txt successfully\") } ▶ اجرای کد کپی ✖ بستن خروجی 4.27.2.4 io.Seeker و جابه‌جایی در داده‌ها # io.Seeker امکان حرکت در یک منبع داده را فراهم می‌کند:\ntype Seeker interface { Seek(offset int64, whence int) (int64, error) } offset: تعداد بایت‌هایی که باید جابه‌جا شود. whence: نقطه مرجع برای جابه‌جایی (io.SeekStart, io.SeekCurrent, io.SeekEnd). مثال تغییر مکان در یک فایل:\nfile, _ := os.Open(\u0026quot;data.txt\u0026quot;) file.Seek(10, io.SeekStart) // حرکت به بایت دهم از ابتدای فایل io.Seeker معمولاً همراه Reader یا Writer استفاده می‌شود و برای کار با داده‌هایی که نیاز به دسترسی تصادفی دارند (مثل پایگاه داده یا فرمت‌های باینری خاص) ضروری است.\nبه عنوان مثال: package main import ( \"fmt\" \"io\" \"os\" ) func main() { file, err := os.Create(\"seek.txt\") if err != nil { panic(err) } defer file.Close() // نوشتن داده اولیه file.Write([]byte(\"0123456789\")) // رفتن به بایت پنجم _, err = file.Seek(5, io.SeekStart) if err != nil { panic(err) } // بازنویسی از بایت پنجم به بعد file.Write([]byte(\"XYZ\")) fmt.Println(\"File updated successfully\") } ▶ اجرای کد کپی ✖ بستن خروجی 4.27.3 توابع کمکی کاربردی # پکیج io علاوه بر Interface ‌های پایه، یک سری Helper Functions هم دارد که خیلی از عملیات رایج I/O را ساده‌تر و بهینه‌تر انجام می‌دهند. این توابع باعث می‌شوند دیگر لازم نباشد حلقه‌های دستی برای خواندن و نوشتن بنویسیم و در عین حال از پیاده‌سازی‌های بهینه Go هم استفاده کنیم.\n4.27.3.1 io.Copy و io.CopyN # تابع io.Copy داده را از یک io.Reader به یک io.Writer منتقل می‌کند تا زمانی که منبع به انتها برسد یا خطایی رخ دهد.\npackage main import ( \"fmt\" \"io\" \"os\" \"strings\" ) func main() { src := strings.NewReader(\"Hello io.Copy\\n\") _, err := io.Copy(os.Stdout, src) if err != nil { panic(err) } fmt.Println(\"Copy completed successfully\") } ▶ اجرای کد کپی ✖ بستن خروجی اگر بخواهیم فقط تعداد مشخصی بایت منتقل کنیم، می‌توانیم از io.CopyN استفاده کنیم:\npackage main import ( \"fmt\" \"io\" \"os\" \"strings\" ) func main() { src := strings.NewReader(\"ABCDEFGH\") _, err := io.CopyN(os.Stdout, src, 4) if err != nil { panic(err) } fmt.Println(\"\\nCopyN completed successfully\") } ▶ اجرای کد کپی ✖ بستن خروجی 4.27.3.2 io.MultiReader و io.MultiWriter # io.MultiReader چند Reader را به هم وصل می‌کند تا خروجی‌شان پشت سر هم خوانده شود. package main import ( \"io\" \"os\" \"strings\" ) func main() { r1 := strings.NewReader(\"Hello \") r2 := strings.NewReader(\"World\\n\") mr := io.MultiReader(r1, r2) io.Copy(os.Stdout, mr) } ▶ اجرای کد کپی ✖ بستن خروجی io.MultiWriter داده را همزمان به چند Writer ارسال می‌کند. package main import ( \"io\" \"os\" \"strings\" ) func main() { file, _ := os.Create(\"multi.txt\") defer file.Close() mw := io.MultiWriter(os.Stdout, file) io.Copy(mw, strings.NewReader(\"Hello MultiWriter\\n\")) } ▶ اجرای کد کپی ✖ بستن خروجی 4.27.3.3 io.TeeReader # io.TeeReader داده را از یک Reader می‌خواند و در حین خواندن، همان داده را در یک Writer هم می‌نویسد.\npackage main import ( \"io\" \"os\" \"strings\" ) func main() { src := strings.NewReader(\"Hello TeeReader\\n\") tr := io.TeeReader(src, os.Stdout) // خواندن کامل باعث می‌شود داده هم روی stdout نوشته شود io.ReadAll(tr) } ▶ اجرای کد کپی ✖ بستن خروجی 4.27.3.4 io.LimitReader و io.LimitWriter # این توابع حجم داده را محدود می‌کنند.\npackage main import ( \"io\" \"os\" \"strings\" ) func main() { src := strings.NewReader(\"This is a long text\") limited := io.LimitReader(src, 7) io.Copy(os.Stdout, limited) // فقط ۷ بایت اول چاپ می‌شود } ▶ اجرای کد کپی ✖ بستن خروجی 4.27.3.5 io.ReadAll # io.ReadAll تمام داده را تا پایان منبع (io.EOF) می‌خواند و در حافظه نگه می‌دارد (برای داده‌های بزرگ باید با احتیاط استفاده شود).\npackage main import ( \"fmt\" \"io\" \"strings\" ) func main() { data := strings.NewReader(\"ReadAll example\") all, err := io.ReadAll(data) if err != nil { panic(err) } fmt.Println(string(all)) } ▶ اجرای کد کپی ✖ بستن خروجی 4.27.3.6 io.SectionReader # io.SectionReader اجازه می‌دهد فقط بخشی از یک منبع داده را بخوانیم.\npackage main import ( \"fmt\" \"io\" \"os\" ) func main() { file, _ := os.Open(\"section.txt\") defer file.Close() // فرض می‌کنیم فایل حداقل ۱۰ بایت دارد section := io.NewSectionReader(file, 3, 5) // از بایت سوم، ۵ بایت بخوان buf := make([]byte, 5) _, err := section.Read(buf) if err != nil \u0026\u0026 err != io.EOF { panic(err) } fmt.Printf(\"Section data: %s\\n\", buf) } ▶ اجرای کد کپی ✖ بستن خروجی 4.27.4 کار با io.Pipe و ارتباط بین Goroutines # پکیج io یک ابزار جالب و قدرتمند به اسم io.Pipe داره که برای اتصال مستقیم دو goroutine به هم استفاده میشه. ایده اینه که یک goroutine داده‌ها رو به PipeWriter می‌نویسه و یک goroutine دیگه همون لحظه اون داده‌ها رو از PipeReader می‌خونه؛ یعنی بینشون یک کانال داده با API شبیه io.Reader/io.Writer ایجاد میشه.\nبرخلاف فایل یا بافر، io.Pipe داده رو جایی ذخیره نمی‌کنه؛ بلکه هر چیزی که نوشته میشه، باید همون لحظه توسط Reader خونده بشه. اگه Reader آماده نباشه، Writer بلاک میشه، و برعکس. این باعث میشه برای streaming real-time یا پردازش خط‌به‌خط داده عالی باشه، بدون اینکه کل داده تو حافظه بارگذاری بشه.\nیک کاربرد مهمش وقتی هست که بخوای داده رو از یک منبع بخونی، قبل از ذخیره یا ارسال، پردازش کنی، و نتیجه رو به مقصد برسونی — و این کار رو با چند goroutine موازی انجام بدی. برای مثال io.Pipe برای اتصال encoder/decoder به ورودی یا خروجی در لحظه عالیه، مثل گرفتن خروجی یک پردازش و ارسال مستقیمش به gzip بدون ذخیره‌ی موقت.\n4.27.4.1 مفاهیم PipeReader و PipeWriter # io.Pipe یه لولهٔ درون‌حافظه‌ای می‌سازه: یه سرش *io.PipeReader و سر دیگه‌ش *io.PipeWriter . هر بایتی که در PipeWriter می‌نویسی، از PipeReader خونده می‌شه—معمولاً توی دو تا goroutine جدا. این برای زمانی عالیه که تولید داده (producer) و مصرف اون (consumer) هم‌زمان و بدون بافر بزرگ کار کنن. Backpressure طبیعی هم داریم: اگه خواننده کند باشه، نویسنده بلاک می‌شه (و برعکس)، پس هر دو سمت باید «زنده» باشن. ایدهٔ پایه و مثال سادهٔ همین الگو توی منابع پیوست هم اومده.\nدو نکتهٔ حیاتی:\nهمیشه انتهای Writer رو وقتی کارت تموم شد Close یا بهتر از اون CloseWithError کن؛ وگرنه خواننده تا ابد منتظر می‌مونه → deadlock. مصرف‌کننده تا EOF بخونه (یا Copy کنه). قواعد خواندن/EOF رو جدی بگیر—خیلی از باگ‌های استریم همین‌جان. مثال ۱: ابتدایی‌ترین اتصال Producer/Consumer با io.Copy # package main import ( \"bytes\" \"fmt\" \"io\" \"os\" ) func main() { // منبع دادهٔ ما: یک بافر درون‌حافظه‌ای src := new(bytes.Buffer) src.WriteString(\"hello pipe\\n\") src.WriteString(\"line 2\\n\") pr, pw := io.Pipe() // Producer: می‌نویسه داخل pw go func() { defer func() { _ = pw.Close() // پایان جریان؛ مهم برای جلوگیری از بن‌بست }() if _, err := io.Copy(pw, src); err != nil { // در صورت خطا بهتره CloseWithError بدیم: // _ = pw.CloseWithError(err) fmt.Println(\"producer copy error:\", err) } }() // Consumer: از pr می‌خونه و می‌ریزه روی Stdout if _, err := io.Copy(os.Stdout, pr); err != nil { fmt.Println(\"consumer copy error:\", err) } } ▶ اجرای کد کپی ✖ بستن خروجی این الگو تقریباً همون چیزیه که در نمونه‌های پیوست هم می‌بینی: Pipe()، یک goroutine برای نوشتن، و io.Copy برای خواندن تا EOF.\n4.27.4.2 استفاده در جریان داده (Streaming) # جذابیت اصلی io.Pipe اینه که می‌تونی پایپ‌لاین‌های استریم بسازی: ورودی از یه جا میاد، وسط راه encode/zip/hash می‌شه، و خروجی همزمان جای دیگه می‌ره—همه بدون اینکه کل داده رو تو حافظه نگه داری. نمونه‌ها و توصیه‌های استریمی در مقالات پیوست زیاد تأکید می‌کنن که به جای ReadAll، جریان بده و تو مسیر پردازش کن.\nمثال ۲: فشرده‌سازی on-the-fly با compress/gzip روی pipe # Producer دادهٔ خام رو می‌خونه و داخل gzip.Writer می‌نویسه که خروجی‌ش PipeWriter ماست. Consumer از PipeReader می‌خونه و مستقیم به فایل می‌نویسه. package main import ( \"compress/gzip\" \"fmt\" \"io\" \"os\" \"strings\" ) func main() { input := strings.NewReader(strings.Repeat(\"Go IO Pipe\\n\", 5)) pr, pw := io.Pipe() // Producer: gzip روی pw go func() { defer func() { _ = pw.Close() // اول gzip.Close، بعد pw.Close }() gzw := gzip.NewWriter(pw) if _, err := io.Copy(gzw, input); err != nil { _ = gzw.Close() _ = pw.CloseWithError(err) return } _ = gzw.Close() }() // Consumer: خروجی gzip شده می‌ره توی فایل out, err := os.Create(\"out.gz\") if err != nil { panic(err) } defer out.Close() if _, err := io.Copy(out, pr); err != nil { fmt.Println(\"copy error:\", err) } fmt.Println(\"done -\u003e out.gz\") } ▶ اجرای کد کپی ✖ بستن خروجی نکتهٔ مهم: ترتیب بستن‌ها: اول gzw.Close() تا footer نوشته بشه، بعد pw.Close() تا EOF به مصرف‌کننده برسد. این دقیقا همان الگوی «اتصال goroutine‌ها با Pipe و Copy»‌ است.\nمثال ۳: محاسبهٔ checksum همزمان با عبور داده (Pipe + TeeReader) # گاهی می‌خوای همزمان که داده رو می‌فرستی، هش/چک‌سام هم بگیری. io.TeeReader همین کارو می‌کنه.\npackage main import ( \"crypto/sha256\" \"fmt\" \"io\" \"os\" \"strings\" ) func main() { src := strings.NewReader(strings.Repeat(\"data...\", 100)) pr, pw := io.Pipe() // Producer: src -\u003e TeeReader(hasher) -\u003e pw go func() { defer pw.Close() hasher := sha256.New() tr := io.TeeReader(src, hasher) if _, err := io.Copy(pw, tr); err != nil { _ = pw.CloseWithError(err) return } sum := hasher.Sum(nil) fmt.Fprintf(os.Stderr, \"sha256: %x\\n\", sum) }() // Consumer: pr -\u003e stdout (یا هر مقصد دیگری) if _, err := io.Copy(os.Stdout, pr); err != nil { fmt.Println(\"copy error:\", err) } } ▶ اجرای کد کپی ✖ بستن خروجی این الگوی «داده رد می‌شه، همزمان پردازش جانبی انجام می‌دیم».\n4.27.4.3 الگوهای همزمانی با io.Pipe # چند الگوی پرکاربرد و Best Practiceها:\nProducer/Consumer با پایان مشخص Writer را حتماً Close/CloseWithError کنید؛ در غیر این صورت خواننده هرگز EOF نمی‌گیره و گیر می‌کنه. نمونهٔ درست توی مثال‌ها و منبع پیوست هست. سمت مصرف‌کننده از io.Copy استفاده کن تا قواعد EOF و شمارش بایت‌ها خودکار رعایت بشه. خطا را propagate کن اگر وسط کار producer خطا خورد، CloseWithError بده تا consumer مطلع شه و سریع‌تر fail کنه. این باور غلط که «همیشه Close ساده کافیه» در استریم‌های طولانی دردسرسازه. (قواعد خطا/EOF در منابع پیوست مرور شده.) بافر جایی دیگه، Pipe اینجا io.Pipe خودش بافر قابل‌توجهی نداره؛ برای throughput بهتر از bufio یا io.CopyBuffer روی مقصد/مبدأ استفاده کن؛ Fan-in/Fan-out با Pipeهای زنجیره‌ای می‌تونی چند مرحلهٔ پردازش (encode → compress → encrypt) رو با چند goroutine و چند Pipe زنجیره کنی. دقت کن هر مرحله خروجی رو تا آخر drain کنه و به‌موقع ببنده، وگرنه مرحلهٔ قبل block می‌شه. از ReadAll پرهیز کن برای دادهٔ بزرگ، به‌جای io.ReadAll استریم کن. نکات Production-Ready خلاصه # همیشه پایان جریان را سیگنال بده: Close() یا CloseWithError(err). سمت مصرف‌کننده تا EOF بخونه؛ ساده‌ترین: io.Copy(dst, pr). قواعد EOF/Read را رعایت کن. در pipelineها ترتیب بستن wrapperها مهمه (مثلاً اول gzip.Close بعد PipeWriter.Close). عملکرد: برای انتقال‌های بزرگ، از io.CopyBuffer یا bufio.Writer/Reader کمک بگیر و سایز بافر رو بسته به سناریو تنظیم کن. اگر مرحله‌ای error داد، سریعاً propagate کن تا همهٔ goroutineها بدونن باید جمع کنن؛ لوپ‌های بی‌پایان مصرف CPU می‌شن. 4.27.5 پیاده‌سازی Reader و Writer سفارشی # ایده‌ی اصلی اینجاست: هر چیزی که متد Read([]byte) (int, error) داشته باشه یک io.Reader و هر چیزی که متد Write([]byte) (int, error) داشته باشه یک io.Writer محسوب می‌شه. این دو رابط پایهٔ تمام ورودی/خروجیِ «جریان‌محور» هستن و باهاشون می‌تونیم اجزای قابل‌اتصال بسازیم.\n4.27.5.1 ساخت یک Custom Reader # بیایید یک Reader بسازیم که حروف را به UpperCase تبدیل می‌کند. این Reader خودش دادهٔ خام را از یک Readerِ زیری می‌خواند و هنگام بازگشت، تبدیل را اعمال می‌کند.\npackage main import ( \"bytes\" \"fmt\" \"io\" \"os\" \"strings\" ) type UpperReader struct { r io.Reader // زیرساخت خواندن } // Read باید تا حد امکان بافر p را پر کند، تعداد بایت‌های نوشته‌شده و خطا را برگرداند. func (u *UpperReader) Read(p []byte) (int, error) { n, err := u.r.Read(p) if n \u003e 0 { // فقط همان تکه‌ای را که پر شده upper کنیم // (تبدیل درجا روی p[:n]) copy(p[:n], bytes.ToUpper(p[:n])) } return n, err } func main() { src := strings.NewReader(\"go io is composable!\\n\") ur := \u0026UpperReader{r: src} if _, err := io.Copy(os.Stdout, ur); err != nil { fmt.Fprintln(os.Stderr, \"copy error:\", err) } } ▶ اجرای کد کپی ✖ بستن خروجی نکات مهم طراحی (طبق توصیه‌های فصل I/O):\nسعی کنید روی p[:n] کار کنید و از ایجاد allocation ‌های اضافی پرهیز کنید. اجازه بدید خطاهای زیری (مثل io.EOF) همون‌طور عبور کنن تا io.Copy رفتار درست داشته باشه. 4.27.5.2 ساخت یک Custom Writer # حالا یک Writer می‌سازیم که به ابتدای هر خط یک پیشوند اضافه کند؛ این یعنی باید مرز خطوط را مدیریت کنیم و ممکن است تکه‌خطوط بین فراخوانی‌های Write بمانند.\npackage main import ( \"bufio\" \"bytes\" \"fmt\" \"io\" \"os\" ) type LinePrefixWriter struct { w io.Writer prefix []byte pending bool // آیا در ابتدای خط جدید هستیم؟ buf []byte // بافر carry برای تکه‌خط‌های بدون \\n } func NewLinePrefixWriter(w io.Writer, prefix string) *LinePrefixWriter { return \u0026LinePrefixWriter{w: w, prefix: []byte(prefix), pending: true} } func (lp *LinePrefixWriter) Write(p []byte) (int, error) { total := 0 // دادهٔ جدید را به بافر داخلی اضافه می‌کنیم lp.buf = append(lp.buf, p...) sc := bufio.NewScanner(bytes.NewReader(lp.buf)) sc.Split(bufio.ScanLines) var out bytes.Buffer for sc.Scan() { line := sc.Bytes() // ScanLines انتهای \\n را حذف می‌کند؛ باید خودمان اضافه کنیم if lp.pending { out.Write(lp.prefix) } out.Write(line) out.WriteByte('\\n') lp.pending = true // بعد از نوشتن \\n ابتدای خط بعدی هستیم total += len(line) + 1 } if err := sc.Err(); err != nil { return 0, err } // تشخیص اینکه آیا ورودی با \\n تمام شده یا تکه‌خط نیمه‌کاره داریم if len(lp.buf) \u003e 0 \u0026\u0026 lp.buf[len(lp.buf)-1] != '\\n' { // آخرین توکن توسط Scanner برگردانده نمی‌شود؛ نگهش می‌داریم // و pending را false می‌کنیم چون وسط خط هستیم. lastNL := bytes.LastIndexByte(lp.buf, '\\n') if lastNL \u003e= 0 { lp.buf = append([]byte{}, lp.buf[lastNL+1:]...) // نگه داشتن دمِ خط } lp.pending = false } else { lp.buf = lp.buf[:0] // همه مصرف شده lp.pending = true } // خروجی بافر را یکجا بنویسیم nw, err := lp.w.Write(out.Bytes()) if err != nil { return nw, err } return len(p), nil // قرارداد Writer: تعداد بایت‌های از ورودیِ p پذیرفته‌شده } func main() { lw := NewLinePrefixWriter(os.Stdout, \"[LOG] \") _, _ = lw.Write([]byte(\"hello\")) _, _ = lw.Write([]byte(\" world\\nnext line\\npartial\")) _, _ = lw.Write([]byte(\" tail\\n\")) } ▶ اجرای کد کپی ✖ بستن خروجی نکات:\nWriter باید تا حد امکان «همهٔ p» را بپذیرد و اگر کمتر نوشت، مقدار برگشتی را دقیق بده (قابل‌استناد برای backpressure ). استفاده از بافر داخلی برای تکه‌خط‌ها یک الگوی رایج است. مراقب رشد بافر باشید. 4.27.5.3 پیاده‌سازی io.ReaderFrom و io.WriterTo برای بهینه‌سازی # تابع io.Copy یک میان‌بُر مهم دارد:\nاگر Reader متد io.WriterTo را پیاده‌سازی کند، io.Copy به‌جای حلقهٔ پیش‌فرض، r.WriteTo(dst) را صدا می‌زند. اگر Writer متد io.ReaderFrom را پیاده‌سازی کند، io.Copy از w.ReadFrom(src) استفاده می‌کند. این مسیرها اجازه می‌دهند پیاده‌سازیِ شما مسیر داده را بهینه کند (مثلاً استفاده از بافرهای بزرگ‌تر، جلوگیری از کپی‌های اضافه، یا بهره‌بردن از توابع سیستم‌عاملی). به الگوهای استاندارد I/O و توضیحات دربارهٔ io.Copy در منابع اشاره‌شده رجوع کنید.\nدر کُد زیر، برای UpperReader، متد WriteTo را اضافه می‌کنیم تا مسیر «Reader → Writer» مستقیم‌تر شود. و برای LinePrefixWriter، متد ReadFrom را می‌گذاریم تا داده را بکشد.\npackage main import ( \"bytes\" \"fmt\" \"io\" \"os\" \"strings\" ) type UpperReader struct{ r io.Reader } func (u *UpperReader) Read(p []byte) (int, error) { n, err := u.r.Read(p) if n \u003e 0 { copy(p[:n], bytes.ToUpper(p[:n])) } return n, err } // WriterTo: به io.Copy اجازه می‌دهد مستقیماً از WriteTo استفاده کند. func (u *UpperReader) WriteTo(w io.Writer) (int64, error) { var total int64 buf := make([]byte, 32*1024) // بافر بزرگ‌تر برای throughput بهتر for { n, err := u.r.Read(buf) if n \u003e 0 { blk := bytes.ToUpper(buf[:n]) m, werr := w.Write(blk) total += int64(m) if werr != nil { return total, werr } if m \u003c n { return total, io.ErrShortWrite } } if err != nil { if err == io.EOF { return total, nil } return total, err } } } type LinePrefixWriter struct { w io.Writer prefix []byte pending bool } // ReaderFrom: به io.Copy اجازه می‌دهد Writer خودش از منبع بخواند. func (lp *LinePrefixWriter) ReadFrom(r io.Reader) (int64, error) { var total int64 buf := make([]byte, 32*1024) var carry []byte writeLine := func(line []byte) error { if lp.pending { if _, err := lp.w.Write(lp.prefix); err != nil { return err } } if _, err := lp.w.Write(line); err != nil { return err } if _, err := lp.w.Write([]byte{'\\n'}); err != nil { return err } lp.pending = true return nil } for { n, err := r.Read(buf) if n \u003e 0 { total += int64(n) chunk := append(carry, buf[:n]...) start := 0 for { i := bytes.IndexByte(chunk[start:], '\\n') if i \u003c 0 { // تکه‌خط ناقص carry = append([]byte{}, chunk[start:]...) lp.pending = false break } end := start + i if err2 := writeLine(chunk[start:end]); err2 != nil { return total, err2 } start = end + 1 } } if err != nil { if err == io.EOF { // هرچه مانده را بدون \\n نهایی، با پیشوند بنویسیم if len(carry) \u003e 0 { if lp.pending { if _, werr := lp.w.Write(lp.prefix); werr != nil { return total, werr } } if _, werr := lp.w.Write(carry); werr != nil { return total, werr } lp.pending = false } return total, nil } return total, err } } } func NewLinePrefixWriter(w io.Writer, prefix string) *LinePrefixWriter { return \u0026LinePrefixWriter{w: w, prefix: []byte(prefix), pending: true} } func main() { // مسیر بهینه‌شده: io.Copy ابتدا WriterTo روی Reader را امتحان می‌کند r := \u0026UpperReader{r: strings.NewReader(\"hello\\nGo io\\n\")} w := NewLinePrefixWriter(os.Stdout, \"[UP] \") if _, err := io.Copy(w, r); err != nil { fmt.Fprintln(os.Stderr, \"copy error:\", err) } } ▶ اجرای کد کپی ✖ بستن خروجی چرا این کار سریع‌تر می‌شود؟\nWriteTo و ReadFrom به شما کنترل بافر و مسیر داده را می‌دهند، پس کپی‌های کمتر و تخصیص‌های کمتر خواهید داشت؛ مطابق توضیحات منابع I/O، io.Copy طبق قرارداد ابتدا WriterTo را روی Reader و بعد ReaderFrom را روی Writer چک می‌کند؛ داشتن یکی از این‌ها کافی‌ست تا حلقهٔ پیش‌فرضِ کپی کنار گذاشته شود. 4.27.6 مدیریت خطا در io # کار با I/O توی Go قشنگه چون همه‌چیز «جریان بایت»‌ه؛ اما همین‌جا اکثر خطاهای ریزه‌میزه هم رخ می‌دن: از برگشتن n\u0026gt;0 همراه با یک err گرفته تا تشخیص پایان داده با io.EOF و هندل کردن عملیات طولانی که باید قابل لغو باشن. این بخش خیلی جمع‌وجور ولی کاربردی می‌گه «چه خطایی عادیه، چی بحرانیه و چطور تولیدی (Production-Ready) هندلش کنیم». بر اساس مقاله‌های پیوست‌شده درباره‌ی I/O استریمی و الگوهای خطا (و چند نکته از اسناد استاندارد)، قواعد مهم Read/Write، تمایز io.EOF، و مدیریت عملیات طولانی با Timeout و Cancellation رو مرور می‌کنیم.\n4.27.6.1 تفاوت io.EOF با خطاهای دیگر # io.EOF خطا نیست؛ علامت پایان جریانه. وقتی منبع داده تموم می‌شه، بعضی Readerها n\u0026gt;0 و err==io.EOF برمی‌گردونن (یعنی «این آخریشه!»). بعضی‌های دیگه ممکنه همون لحظه err==nil بدن و خواندن بعدی io.EOF بده. پس «پایان» همیشه در فراخوانی بعدی قطعی می‌شه. نتیجه؟ حلقه‌ی خواندن باید روی io.EOF از حلقه خارج بشه؛ ولی قبلش هر بایتی که با n\u0026gt;0 اومده رو پردازش کن. این دقیقاً همون «قوانین خواندن»یه که روی Readerها تأکید شده. n\u0026gt;0 همراه با err!=nil: طبق قواعد Reader، ممکنه قبل از وقوع خطا هنوز چند بایت معتبر توی p[:n] داشته باشید (مثلاً سوکت ناگهانی بسته شده). حواستون باشه اون بایت‌ها از دست نرن؛ اول مصرفشون کنید، بعد تصمیم بگیرید ریترای کنید یا قطع. io.ErrUnexpectedEOF با io.EOF فرق داره. io.ErrUnexpectedEOF یعنی «داده زودتر از حد انتظار تموم شد» (مثلاً وسط یک بلاک ساختاریافته). این یکی خطای واقعی است و معمولاً باید به کاربر گزارش بشه یا عملیات رو ریترای/رول‌بک کنید. (نمونه‌های مرسوم هنگام io.CopyN یا io.ReadFull اتفاق می‌افته.) الگوی صحیح حلقه‌ی خواندن: تا وقتی err==nil ادامه بده؛ اگر err==io.EOF بود از حلقه خارج شو؛ اگر err!=nil بود، بسته به سناریو لاگ/بازگشت خطا. (و یادت باشه قبل از خروج هر چیزی در p[:n] رو مصرف کنی. مثال (الگوی درستِ برخورد با EOF و خطاهای جزئی):\npackage main import ( \"fmt\" \"io\" \"os\" \"strings\" ) func main() { // می‌تونی این رو با فایل هم تست کنی: f, _ := os.Open(\"file.txt\"); defer f.Close(); r := f r := strings.NewReader(\"Clear is better than clever\") buf := make([]byte, 4) for { n, err := r.Read(buf) if n \u003e 0 { fmt.Print(string(buf[:n])) // قبل از بررسی خطا، داده‌های دریافت‌شده رو مصرف کن } if err != nil { if err == io.EOF { break // پایان طبیعی جریان } // خطای واقعی (شبکه، دیسک، مجوز و...) fmt.Fprintln(os.Stderr, \"read error:\", err) return } } } ▶ اجرای کد کپی ✖ بستن خروجی این الگو دقیقاً همون چیزیه که در منابع رویش تأکید شده: ممکنه n کمتر از len(p) باشه، ممکنه n\u0026gt;0 همراه با خطا بیاد، و n=0, err=nil به معنی EOF نیست.\nنکات پروداکشنی:\nاز io.Copy برای ساده‌سازی حلقه‌ها استفاده کن؛ خودش شمارش بایت و EOF رو درست مدیریت می‌کنه. موقع Write، n!=len(p) و io.ErrShortWrite رو جدی بگیر. خطاهای Close() رو چک کن؛ مخصوصاً روی فایل/شبکه. (اگرچه مثال‌های این بخش روی Reader تمرکز دارن، اما چک کردن Close توی خروجی هم مهمه.) 4.27.6.2 مدیریت خطا در عملیات طولانی # هدف اینجاست: کد I/O طولانی شما باید قابل لغو باشه، زمان‌بندی داشته باشه، و به‌صورت پیوسته خطا/پیشرفت رو مدیریت کنه—بدون اینکه رم رو بترکونه یا فایل لاک بمونه.\n1) لغو با context.Context (سراسری و ساده):\nخیلی از APIهای خالص io کانتکست نمی‌گیرن، ولی می‌تونیم یک Reader «کانتکست-اگاه» بسازیم که اگر ctx.Done() شد، دیگه نخونه و ctx.Err() برگردونه. این روش برای هر منبعی جواب می‌ده (فایل، حافظه، Pipe، HTTP body و\u0026hellip;).\npackage main import ( \"context\" \"fmt\" \"io\" \"os\" \"strings\" \"time\" ) type ctxReader struct { ctx context.Context r io.Reader } func (c *ctxReader) Read(p []byte) (int, error) { select { case \u003c-c.ctx.Done(): return 0, c.ctx.Err() default: return c.r.Read(p) } } func main() { ctx, cancel := context.WithTimeout(context.Background(), 500*time.Millisecond) defer cancel() // منبع کند (شبیه‌سازی): هر 200ms چند بایت می‌ده src := io.Reader(strings.NewReader(strings.Repeat(\"DATA-\", 1\u003c\u003c14))) r := \u0026ctxReader{ctx: ctx, r: src} // خروجی: استاندارد (می‌تونی فایل هم بذاری) if _, err := io.Copy(os.Stdout, r); err != nil { fmt.Fprintln(os.Stderr, \"copy stopped:\", err) // deadline exceeded یا canceled } } ▶ اجرای کد کپی ✖ بستن خروجی نکته: برای شبکه‌ها (net.Conn) اصلاً لازم نیست دور Reader کُوری بپیچید؛ مستقیماً از SetDeadline/SetReadDeadline استفاده کنید تا Read/Write با Timeout قطع بشه. برای HTTP از http.Client با Timeout یا Context روی Request استفاده کنید. (الگوی خطا همان است: اگر n\u0026gt;0 برگشته، مصرف کن و بعد خطا را مدیریت کن.)\n2) کنترل حافظه و اندازه‌ی داده:\nدر عملیات طولانی، وسوسه نشید io.ReadAll بزنید؛ برای داده‌های بزرگ باعث مصرف رم می‌شه. به‌جایش جریان‌محور (io.Copy، io.CopyBuffer با بافر قابل‌استفاده‌مجدد) کار کنید. اگر باید سقف اندازه را enforce کنید، io.LimitReader یا io.CopyN بگذارید و به io.ErrUnexpectedEOF حساس باشید.\n3) پایش و لاگ خطای مرحله‌ای (Stream-aware):\nاگر هم‌زمان می‌خواید پیشرفت یا checksum بگیرید، از io.TeeReader استفاده کنید تا جریان یکجا هم مصرف شود هم ثبت/هش شود—و هر خطا همان‌جا متوقف کند.\n4) بستن منابع به‌موقع:\nروی هر مسیر خروج (موفق/ناموفق) Close() را چک کنید و در حلقه‌ها defer Close() نگذارید (نشت دسته‌جمعی می‌ده). برای تعداد زیاد فایل‌ها، «باز کن—کار کن—ببند» را سریع انجام بده. مثال (کپیِ قابل-لغو + محدودیت حجم + شمارنده‌ی پیشرفت):\npackage main import ( \"context\" \"crypto/sha256\" \"fmt\" \"io\" \"os\" \"strings\" \"time\" ) type ctxReader struct { ctx context.Context r io.Reader } func (c *ctxReader) Read(p []byte) (int, error) { select { case \u003c-c.ctx.Done(): return 0, c.ctx.Err() default: return c.r.Read(p) } } func main() { // منبع شبیه‌سازی‌شدهٔ بزرگ src := strings.NewReader(strings.Repeat(\"X\", 10\u003c\u003c20)) // 10MB // 1) محدودیت 1MB limited := io.LimitReader(src, 1\u003c\u003c20) // 1 MiB // 2) پیشرفت/هش موازی با TeeReader hasher := sha256.New() tr := io.TeeReader(limited, hasher) // 3) لغو با Timeout ctx, cancel := context.WithTimeout(context.Background(), 300*time.Millisecond) defer cancel() cr := \u0026ctxReader{ctx: ctx, r: tr} dst, err := os.Create(\"out.bin\") if err != nil { fmt.Println(\"create:\", err) return } defer func() { if err := dst.Close(); err != nil { fmt.Println(\"close:\", err) } }() // کپی جریان‌محور written, err := io.Copy(dst, cr) if err != nil { fmt.Println(\"copy error:\", err) // ممکنه context deadline exceeded باشه } else { fmt.Println(\"written bytes:\", written) } fmt.Printf(\"sha256 (partial/complete): %x\\n\", hasher.Sum(nil)) } ▶ اجرای کد کپی ✖ بستن خروجی چند Best Practice کوتاه برای عملیات طولانی:\n«سقف ورودی» بگذار: io.LimitReader روی بدنه‌ی درخواست‌ها (مثلاً آپلود) تا از سوءاستفاده و OOM جلوگیری کنی. «بافر درست» انتخاب کن و اگر حلقه‌ی طولانیه از io.CopyBuffer با یک بافر reuse‌شونده استفاده کن. (افزایش کارایی روی فایل/شبکه) io.Copy خطاها و EOF رو درست مدیریت می‌کنه؛ وقتی خاص‌نویسی لازم نیست، از همون استفاده کن. 4.27.7 Best Practices در استفاده از io # پکیج io قلب عملیات ورودی/خروجی (I/O) در Go است و تقریبا همه کتابخانه‌های استاندارد مربوط به فایل، شبکه، و پردازش داده بر پایه همین abstractionها ساخته شده‌اند. اما استفاده درست از آن می‌تواند تفاوت زیادی در کارایی، مصرف حافظه، و پایداری کد شما ایجاد کند. در ادامه چند بهترین شیوه‌ی مهم برای استفاده از این پکیج را بررسی می‌کنیم.\n4.27.7.1 استفاده از Interface به جای نوع خاص # یکی از فلسفه‌های کلیدی Go این است که به جای تکیه بر نوع خاص (مثل *os.File) از اینترفیس‌های عمومی مثل io.Reader و io.Writer استفاده کنیم.\nاین کار باعث می‌شود که کد ما انعطاف‌پذیر باشد و بتواند با هر منبع یا مقصد داده‌ای کار کند — چه فایل باشد، چه شبکه، چه حافظه.\nمثال:\npackage main import ( \"fmt\" \"io\" \"os\" \"strings\" ) func printData(r io.Reader) { buf := make([]byte, 16) for { n, err := r.Read(buf) if n \u003e 0 { fmt.Print(string(buf[:n])) } if err == io.EOF { break } if err != nil { fmt.Println(\"Error:\", err) break } } } func main() { // خواندن از یک رشته printData(strings.NewReader(\"Hello Go\\n\")) // خواندن از یک فایل file, _ := os.Open(\"test.txt\") defer file.Close() printData(file) } ▶ اجرای کد کپی ✖ بستن خروجی در این مثال، تابع printData با هر چیزی که io.Reader را پیاده‌سازی کند کار می‌کند، بدون وابستگی به نوع خاص.\n4.27.7.2 بهینه‌سازی با bufio # خواندن و نوشتن مستقیم روی منابع I/O می‌تواند منجر به تعداد زیادی فراخوانی سیستم (syscall) و کاهش کارایی شود. برای همین bufio بافرهایی ارائه می‌دهد که باعث کاهش فراخوانی‌های I/O و افزایش سرعت می‌شوند.\nنکته: همیشه وقتی با داده‌های زیاد یا عملیات کوچک و پرتکرار کار می‌کنید، از bufio.Reader یا bufio.Writer استفاده کنید.\nمثال:\npackage main import ( \"bufio\" \"fmt\" \"os\" ) func main() { file, err := os.Open(\"bigfile.txt\") if err != nil { panic(err) } defer file.Close() reader := bufio.NewReader(file) for { line, err := reader.ReadString('\\n') fmt.Print(line) if err != nil { break } } } ▶ اجرای کد کپی ✖ بستن خروجی 4.27.7.3 مدیریت منابع با io.Closer و defer # بسیاری از منابع I/O مثل فایل‌ها و کانکشن‌های شبکه نیاز به بستن (Close) دارند. پیاده‌سازی io.Closer و استفاده از defer تضمین می‌کند که حتی در صورت بروز خطا، منابع آزاد می‌شوند.\nمثال:\npackage main import ( \"fmt\" \"os\" ) func main() { file, err := os.Open(\"data.txt\") if err != nil { panic(err) } defer file.Close() // تضمین آزاد شدن منبع buf := make([]byte, 32) n, _ := file.Read(buf) fmt.Println(string(buf[:n])) } ▶ اجرای کد کپی ✖ بستن خروجی 4.27.7.4 انتخاب اندازه buffer مناسب # اندازه بافر تأثیر مستقیم روی کارایی دارد. بافر کوچک ممکن است باعث افزایش تعداد فراخوانی‌ها و کندی برنامه شود؛ بافر بزرگ هم می‌تواند حافظه را هدر دهد.\nبه‌طور معمول، برای بیشتر کاربردها بافر 4KB تا 32KB مناسب است (همانند اندازه پیش‌فرض در bufio)، اما در عملیات شبکه‌ای یا پردازش فایل‌های بزرگ می‌توانید آزمایش و بهینه‌سازی کنید.\nمثال:\npackage main import ( \"io\" \"os\" ) func main() { src, _ := os.Open(\"large.bin\") defer src.Close() dst, _ := os.Create(\"copy.bin\") defer dst.Close() buf := make([]byte, 64*1024) // 64KB buffer io.CopyBuffer(dst, src, buf) } ▶ اجرای کد کپی ✖ بستن خروجی 4.27.7.5 آپلود استریمیِ فایل بزرگ با ذخیره‌سازی امن (atomic) روی دیسک # اصول # استریم‌کردن: به‌جای نگه‌داشتن کل فایل در حافظه، ورودی را مستقیم به دیسک کپی کنید. حداکثر اندازه: حتماً روی بدنه‌ی درخواست limit بگذارید. فایل موقت + rename اتمی: اول در مسیر مقصد یک فایل موقت (*.part) بسازید، آخر کار که موفق بود، با os.Rename به نام نهایی منتقلش کنید. روی یک فایل‌سیستم، rename اتمی است. پاکسازی مطمئن: هر خطا/لغو باعث حذف فایل موقت شود. Context‑aware: اگر کلاینت آپلود را کنسل کرد، کپی متوقف شود (Go خودش روی r.Context() این را propagate می‌کند). هندلر نمونه (HTTP، multipart/form-data) # این نمونه آپلود تک‌فایله را نشان می‌دهد. برای چند فایل، حلقه روی پارت‌ها بزنید.\npackage upload import ( \u0026quot;bufio\u0026quot; \u0026quot;errors\u0026quot; \u0026quot;fmt\u0026quot; \u0026quot;io\u0026quot; \u0026quot;mime/multipart\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;os\u0026quot; \u0026quot;path/filepath\u0026quot; \u0026quot;strconv\u0026quot; \u0026quot;strings\u0026quot; ) const ( maxUploadSize = 1 \u0026lt;\u0026lt; 30 // 1GiB نمونه؛ بسته به نیاز تغییر دهید uploadDir = \u0026quot;./uploads\u0026quot; ) func UploadHandler(w http.ResponseWriter, r *http.Request) { // 1) محدود کردن اندازه بدنۀ درخواست (حفاظت از حافظه و DoS) r.Body = http.MaxBytesReader(w, r.Body, maxUploadSize) // 2) استریم‌کردن multipart بدون بافرکردن کل فرم mr, err := r.MultipartReader() if err != nil { http.Error(w, \u0026quot;invalid multipart request\u0026quot;, http.StatusBadRequest) return } // 3) اطمینان از وجود مسیر ذخیره if err := os.MkdirAll(uploadDir, 0o755); err != nil { http.Error(w, \u0026quot;cannot create upload dir\u0026quot;, http.StatusInternalServerError) return } // انتظار داریم یک part فایل به نام \u0026quot;file\u0026quot; var savedName string for { part, err := mr.NextPart() if errors.Is(err, io.EOF) { break } if err != nil { http.Error(w, \u0026quot;read part failed\u0026quot;, http.StatusBadRequest) return } if part.FormName() != \u0026quot;file\u0026quot; || part.FileName() == \u0026quot;\u0026quot; { // سایر فیلدهای فرم را رد کنید (مثلاً متن و …) continue } // 4) ساخت فایل موقت در همان دایرکتوری مقصد (برای rename اتمی روی همان FS) tmp, err := os.CreateTemp(uploadDir, \u0026quot;*.part\u0026quot;) if err != nil { http.Error(w, \u0026quot;cannot create temp file\u0026quot;, http.StatusInternalServerError) return } tmpPath := tmp.Name() defer func() { // اگر تا آخر کار rename موفق نشود، فایل موقت پاک می‌شود tmp.Close() // امن است حتی اگر قبلاً بسته شده باشد _ = os.Remove(tmpPath) }() // 5) استریم کپی با بافر معقول (کاهش syscall ها) bufw := bufio.NewWriterSize(tmp, 64*1024) // 64KiB؛ با بنچمارک تنظیم کنید // اگر بخواهید همزمان hash بگیرید: // h := sha256.New() // src := io.TeeReader(part, h) // _, err = io.CopyBuffer(bufw, src, make([]byte, 64*1024)) _, err = io.CopyBuffer(bufw, part, make([]byte, 64*1024)) closeErr := bufw.Flush() if err == nil { err = closeErr } // توجه: اگر کلاینت وسط کار قطع شود، copy با خطا برمی‌گردد. if err != nil { http.Error(w, \u0026quot;upload interrupted/failed\u0026quot;, http.StatusBadRequest) return } // 6) اطمینان از پایداری روی دیسک (اختیاری، برای حساسیت بالا) if err := tmp.Sync(); err != nil { http.Error(w, \u0026quot;fsync failed\u0026quot;, http.StatusInternalServerError) return } if err := tmp.Close(); err != nil { http.Error(w, \u0026quot;close failed\u0026quot;, http.StatusInternalServerError) return } // 7) تولید نام نهایی امن finalName := sanitizeFilename(part.FileName()) finalPath := filepath.Join(uploadDir, finalName) // در صورت وجود فایل همنام، یک suffix یکتا اضافه کنید finalPath = uniquifyPath(finalPath) // 8) جابجایی اتمی if err := os.Rename(tmpPath, finalPath); err != nil { http.Error(w, \u0026quot;atomic move failed\u0026quot;, http.StatusInternalServerError) return } // از اینجا به بعد، فایل موقت را دیگر پاک نکنید savedName = filepath.Base(finalPath) // یک فایل را ذخیره کردیم؛ اگر فقط یک فایل می‌پذیرید، می‌توانید break کنید. break } if savedName == \u0026quot;\u0026quot; { http.Error(w, \u0026quot;no file part found\u0026quot;, http.StatusBadRequest) return } w.WriteHeader(http.StatusCreated) _, _ = fmt.Fprintf(w, \u0026quot;uploaded: %s\\n\u0026quot;, savedName) } func sanitizeFilename(name string) string { // خیلی ساده: مسیرها را حذف و فضای خالی را _ کنیم؛ در عمل سخت‌گیرتر باشید. name = filepath.Base(name) name = strings.ReplaceAll(name, \u0026quot; \u0026quot;, \u0026quot;_\u0026quot;) return name } func uniquifyPath(path string) string { dir := filepath.Dir(path) base := filepath.Base(path) ext := filepath.Ext(base) name := strings.TrimSuffix(base, ext) p := path i := 1 for { if _, err := os.Stat(p); errors.Is(err, os.ErrNotExist) { return p } p = filepath.Join(dir, name+\u0026quot;(\u0026quot;+strconv.Itoa(i)+\u0026quot;)\u0026quot;+ext) i++ } } نکات کلیدی # http.MaxBytesReader جلوی خواندن بیش از حد را می‌گیرد؛ اگر بزرگ‌تر باشد با خطای 4xx برمی‌گردید. به‌جای r.ParseMultipartForm از r.MultipartReader() استفاده کردیم تا کاملاً استریمی باشد. اول روی فایل موقت می‌نویسیم، بعد Sync و Close و در پایان Rename اتمی. اگر هر جا خطا بخورد، defer فایل موقت را پاک می‌کند. اگر حجم‌ها واقعاً بزرگند، بهتر است اندازه بافر را با بنچمارک روی محیط واقعی تنظیم کنید. اگر نیاز دارید checksum/virus‑scan/thumbnail بسازید، از io.TeeReader (یا کانال‌های موازی با errgroup) استفاده کنید تا هنگام نوشتن، داده را همزمان به پردازش ثانویه بدهید. آیا اینجا از io.Pipe استفاده کنیم؟ # برای «کپی ساده‌ی ورودی به دیسک» معمولاً لازم نیست. io.Copy/io.TeeReader ساده‌تر و کم‌ریسک‌ترند.\nio.Pipe وقتی می‌درخشد که:\nتولیدکننده و مصرف‌کننده همزمان دارید و می‌خواهید backpressure طبیعی رخ دهد (تا وقتی مصرف‌کننده نخوانَد، تولیدکننده پیش نرود). نیاز به تبدیل/فشرده‌سازی/اسکن در goroutine جدا دارید که داده را از همون استریم بگیرد. نمونه‌ی کوتاه با io.Pipe همزمان:\npr, pw := io.Pipe() // تولیدکننده: داده‌ی آپلود را در Pipe می‌نویسد go func() { defer pw.Close() _, err := io.Copy(pw, part) // part همان multipart.Part if err != nil { // اگر خراب شد، Pipe را با خطا می‌بندیم تا مصرف‌کننده مطلع شود _ = pw.CloseWithError(err) } }() // مصرف‌کننده: همزمان روی دیسک می‌نویسد و پردازش می‌کند go func() { defer pr.Close() dst, _ := os.CreateTemp(uploadDir, \u0026quot;*.part\u0026quot;) defer dst.Close() // همزمان hash یا AV: // h := sha256.New() // multi := io.TeeReader(pr, h) _, err := io.Copy(dst, pr) // یا multi if err != nil { // خطا را log/propagate کنید و فایل موقت را حذف کنید } // ... Sync/Close/Rename مثل قبل }() احتیاط: با io.Pipe اگر یکی از طرفین خواندن/نوشتن را متوقف کند و دیگری چشم‌انتظار بماند، بن‌بست می‌گیرید. حتماً با مدیریت خطا/بستن و errgroup کنترل کامل جریان را داشته باشید.\n"},{"id":86,"href":"/chapter-6/","title":"فصل ششم: ژنریک ها (Generics)","section":"صفحه اصلی","content":"در این بخش قصد داریم به بحث ژنریک ها بپردازیم که از نسخه go1.18 اضافه شد که تقریبا یکی از اساسی ترین تغییرات در سینتکس زبان گو بود و در قالب یک پروپوزال ارائه شد و سپس از نسخه ۱.۱۸ منتشر شد و تا الان تغییرات و بهبودهای زیادی داشته است.\nژنریک به زبان برنامه‌نویسی امکانات مهمی اضافه می‌کند:\nپارامترهای نوع برای توابع و انواع داده: با ژنریک، می‌توانید توابع و انواع داده‌ای را با پارامترهای نوع مخصوص بسازید. به این ترتیب می‌توانید یک تابع یا یک نوع داده را برای کار با انواع مختلف داده تعریف کنید.\nتعریف انواع رابط به عنوان مجموعه‌ای از انواع: با ژنریک، می‌توانید انواع اینترفیس را به عنوان مجموعه‌هایی از انواع تعریف کنید، حتی انواعی که متدهای خاصی ندارند. این به شما امکان می‌دهد تا انواع داده‌ای را به عنوان پارامترها در تعریف اینترفیس‌ها استفاده کنید.\nاستفاده از استنباط نوع (Type Inference): ژنریک اجازه می‌دهد که در بسیاری از موارد، پارامترهای نوع را در فراخوانی توابع حذف کنید. به این ترتیب کد شما ساده‌تر و خواناتر می‌شود و نیازی به تعیین دقیق نوع در همه جا ندارید.\nنکات کاربردی\nزمانی از ژنریک ها استفاده کنید که کدهای شما فقط با تغییر تایپ در حال تکرار است آنجا شما می توانید از ژنریک ها برای کاهش کد خود کمک بگیرید. از ژنریک ها می توانید برای کاهش Assertion اینترفیس ها استفاده کنید. با اینکه ژنریک یک ویژگی خوب است اما استفاده زیاد باعث پیچیدگی و سربار حافظه خواهد شد. ژنریک چیست؟ # ژنریک یک ویژگی مهم در Go است که به شما این امکان را می‌دهد تا کدهای کلی و قابل استفاده مجدد بنویسید بدون اینکه به تایپ‌های خاصی محدود شوید. به عبارت ساده‌تر، با ژنریک می‌توانید توابع و ساختارهای داده را بنویسید که با انواع مختلف داده‌ها کار کنند.\nبه عنوان مثال، فرض کنید یک تابع بخواهید بنویسید که دو عدد را با هم جمع کند. بدون استفاده از ژنریک، شما باید تابع‌های مجزایی برای جمع دو عدد از نوع مختلف (مثلاً عدد صحیح و عدد اعشاری) بنویسید. اما با ژنریک، می‌توانید یک تابع جمع کننده عمومی بنویسید که با هر نوع داده‌ای کار کند.\nدر اصطلاحات Go، از انواع نمادگذاری ژنریک می‌کنیم. این انواع می‌توانند به صورت متغیر باشند و از آن‌ها در تابع‌ها و ساختارهای داده استفاده کنید تا کدی ایجاد کنید که قابل استفاده با انواع مختلف داده‌ها باشد.\nاز مزیت‌های ژنریک در Go می‌توان به کاهش تکرار کد، افزایش قابلیت خوانایی کد و افزایش انعطاف‌پذیری برنامه اشاره کرد. با استفاده از این قابلیت، می‌توانید کدهای بهینه‌تری بنویسید و طراحی بهتری داشته باشید.\nبنابراین، ژنریک در Go به شما این امکان را می‌دهد که کدهای کلی‌تر و کاربردی‌تری بنویسید که با انواع مختلف داده‌ها سازگار باشند و به عنوان یک توسعه‌دهنده جوان، این ابزار قدرتمند را در توسعه نرم‌افزار‌های خود بهره‌بری کنید.\n"},{"id":87,"href":"/chapter-6/go-generics-basic/","title":"6.1 مقدمه و اهمیت ژنریک‌ها","section":"فصل ششم: ژنریک ها (Generics)","content":"ایده ژنریک (Generics) به مفهوم برنامه‌نویسی پارامتری (Parametric Polymorphism) برمی‌گردد؛ یعنی نوشتن توابع، کلاس‌ها یا انواعی که با انواع مختلف داده کار کنند بدون اینکه برای هر نوع داده، پیاده‌سازی مجزایی لازم باشد. این مفهوم در علوم کامپیوتر از دهه ۱۹۷۰ مطرح بود و به تدریج به زبان‌های اصلی برنامه‌نویسی راه یافت.\nنقش کلیدی David R. Musser و Alexander A. Stepanov # دو نفر از پیشگامان و پژوهشگران مهم این حوزه، David R. Musser و Alexander A. Stepanov هستند. آن‌ها در دهه ۸۰ و ۹۰ میلادی پژوهش‌هایی درباره طراحی و پیاده‌سازی الگوریتم‌های ژنریک انجام دادند.\nیکی از مهم‌ترین مقالات آن‌ها:\n“Generic Programming” نوشته شده توسط Alexander Stepanov و David Musser منتشر شده در سال 1988، کتابچه International Seminar on Generic Programming لینک مقاله در Springer در این مقاله، آن‌ها ایده \u0026ldquo;برنامه‌نویسی ژنریک\u0026rdquo; را فراتر از الگوهای تابعی (functional patterns) و شی‌گرا معرفی کردند و تأثیر زیادی بر طراحی استانداردهای زبان‌های بعدی داشتند.\nStepanov بعداً به عنوان طراح اصلی STL (Standard Template Library) در ++C شناخته شد که یکی از اولین پیاده‌سازی‌های موفق و پرکاربرد ژنریک در سطح صنعتی بود.\n۶.۱.۱ چرا ژنریک‌ها؟ (مشکلات توسعه بدون ژنریک) # در برنامه‌نویسی، بارها نیاز پیدا می‌کنیم یک الگوریتم یا ساختار داده را برای انواع مختلف داده بنویسیم؛ مثلاً مرتب‌سازی یک لیست از اعداد صحیح، لیست رشته‌ها یا هر نوع دیگری.\nدر زبان‌هایی که ژنریک (Generic) ندارند یا قبل از اضافه شدن ژنریک به Go، این نیاز به چند روش رفع می‌شد که هر کدام معایب و مشکلات جدی داشتند:\nالف) کپی‌برداری و تکرار کد # برای هر نوع داده یک نسخه جداگانه از کد می‌نوشتیم.\nمثلاً یک تابع برای []int، یکی برای []string و\u0026hellip;\nاین کار باعث می‌شد:\nحجم کد زیاد شود (Boilerplate) نگهداری سخت شود (هر تغییری باید در چند جا انجام شود) احتمال بروز باگ بیشتر شود مثال:\nfunc MaxInt(a, b int) int { if a \u0026gt; b { return a } return b } func MaxFloat64(a, b float64) float64 { if a \u0026gt; b { return a } return b } ب) استفاده از interface{} و بازتاب (Reflect) # راه دوم، استفاده از نوع همه‌کاره‌ی interface{} و بازتاب (reflect) بود:\nfunc Max(a, b interface{}) interface{} { // مقایسه به کمک reflect یا type assertion // کد پیچیده و کند می‌شود } معایب:\nکاهش خوانایی و ایمنی کد (Type Safety) نبود هشدار کامپایلری برای ناسازگاری انواع کندی اجرا به دلیل استفاده از بازتاب ج) مشکل Type Safety و تولید کد ضعیف # کدهای مبتنی بر interface{} می‌توانند در اجرا دچار panic شوند و خطاهای type را فقط در runtime نشان دهند.\nخلاصه مشکلات بدون ژنریک # تکرار و افزونگی کد سختی نگهداری و توسعه کاهش ایمنی نوعی (type safety) افت کارایی (performance) بالا رفتن احتمال بروز باگ ۶.۱.۲ تاریخچه و سیر تکامل ژنریک‌ها در Go # از ابتدای طراحی زبان Go، توسعه‌دهندگان زیادی خواهان قابلیت ژنریک بودند تا بتوانند الگوریتم‌ها و ساختارهای داده را به صورت type-safe و بدون تکرار بنویسند.\nاما تیم توسعه Go به دلایل مختلف (ساده نگه‌داشتن زبان، اجتناب از پیچیدگی‌های اضافی و دغدغه‌های کارایی) این قابلیت را تا مدت‌ها به تعویق انداخت.\nمراحل مهم در مسیر ژنریک در Go: # قبل از Go 1.18:\nهیچ پشتیبانی رسمی از ژنریک وجود نداشت؛ برنامه‌نویسان ناچار به استفاده از راه‌حل‌های غیراستاندارد بودند (تکرار کد، interface{}، بازتاب و \u0026hellip;). پیشنهادهای اولیه:\nاز سال ۲۰۱۰ تا ۲۰۲۰، چندین طرح پیشنهادی برای اضافه‌کردن ژنریک مطرح شد که برخی به‌خاطر پیچیدگی یا ناسازگاری با فلسفه Go رد شدند. Go 1.18 (مارس ۲۰۲۲):\nانقلاب بزرگ!\nپشتیبانی رسمی از ژنریک اضافه شد: معرفی type parameter تعریف constraint و type set امکان تعریف توابع و انواع ژنریک با سینتکس ساده و خوانا حفظ سرعت کامپایل و کارایی اجرایی Go 1.21 (۲۰۲۳):\nاضافه شدن constraintهای جدید مثل cmp.Ordered Go 1.24 (۲۰۲۵):\nاضافه‌شدن Generic Type Alias (امکان alias برای نوع و constraint ژنریک) Go 1.25 (۲۰۲۵):\nحذف مفهوم core type و ساده‌تر شدن قواعد زبان برای genericها (طبق مستندات جدید و Go Blog). ۶.۱.۳ کاربردهای رایج ژنریک‌ها در برنامه‌نویسی مدرن # ژنریک‌ها در عمل، برای حل مسائلی به کار می‌روند که نیاز به بازاستفاده کد و ایمنی نوعی بالا دارند. مهم‌ترین کاربردها:\nالف) ساختارهای داده‌ی عمومی # مثل Stack, Queue, List, Map و\u0026hellip; که باید با انواع مختلف داده کار کنند:\ntype Stack[T any] struct { data []T } func (s *Stack[T]) Push(val T) { s.data = append(s.data, val) } func (s *Stack[T]) Pop() T { /* ... */ } این ساختار را می‌توانید برای هر نوعی (int, string, struct و \u0026hellip;) به کار ببرید:\nvar intStack Stack[int] var strStack Stack[string] ب) الگوریتم‌های عمومی # مانند مرتب‌سازی، جست‌وجو، فیلتر و \u0026hellip;\nfunc Filter[T any](list []T, f func(T) bool) []T { var res []T for _, v := range list { if f(v) { res = append(res, v) } } return res } ج) کتابخانه‌های عمومی و بازمتن # توسعه کتابخانه‌هایی که کاربران مختلف با داده‌های دلخواه‌شان به سادگی از آن استفاده کنند (مانند slices, maps و \u0026hellip; در استاندارد Go).\nد) ساخت abstraction و معماری ماژولار # امکان پیاده‌سازی اینترفیس‌ها و abstractionهای سطح بالا به صورت type-safe و قابل استفاده برای انواع مختلف.\nه) افزایش خوانایی و نگهداری کد # ژنریک‌ها باعث می‌شوند کد کوتاه‌تر، خواناتر و تغییرپذیرتر شود و توسعه‌دهنده فقط یکبار کد را پیاده‌سازی و همه‌جا استفاده کند.\nنمونه واقعی از کتابخانه استاندارد Go:\nکتابخانه slices (از Go 1.21) دارای توابع ژنریک برای کار با انواع slice:\nimport \u0026quot;slices\u0026quot; ints := []int{1, 2, 3} slices.Reverse(ints) // بدون نیاز به کپی کد ۶.۱.4 مرور تغییرات عملکردی ژنریک‌ها در Go # از نسخه‌ی Go 1.18 تا نسخه‌ی کنونی، چند تغییر کلیدی در عملکرد (Performance) ژنریک‌ها رخ داده که در ادامه بررسی دقیق و مستند آن‌ها را ارائه می‌دهم:\n🔹 Go 1.18 – ورود ژنریک؛ اثر بر سرعت کامپایل و اجرا # کند شدن کامپایل تا 15٪ نسبت به Go 1.17 به دلیل اضافه‌شدن چک‌های نوعی ژنریک و type checker جدید (tip.golang.org, InfoQ). عملکرد اجرا (runtime) بدون تغییر محسوسی باقی ماند، چون کد ژنریک از نوع monomorphization جزئی (dictionary-based) است و روی runtime overhead تاثیری نمی‌گذارد (InfoQ). 🔹 Go 1.19 – بهبود عملکرد ژنریک‌ها # بروزرسانی‌های ابزار کامپایل، runtime و حافظه بهینه‌سازی شده. تا 20٪ بهبود در سرعت برخی برنامه‌های ژنریک گزارش شده است . تیم Go تغییراتی در memory model انجام داد تا کارایی GC نیز بهبود یابد، که به‌ویژه در ترکیب با ژنریک‌ها مفید بود . 🔹 Go 1.20 – بهبود سرعت کامپایل و اجرا # رفع regressions قبلی: سرعت build به سطح Go 1.17 بازگشت (تا 10٪ سریع‌تر نسبت به 1.19) (tip.golang.org). بهبود جزئی در \u0026ldquo;generated code performance\u0026rdquo; نسبت به 1.19 (tip.golang.org). امکان فعال‌سازی Profile-Guided Optimization (PGO) برای بهینه‌سازی‌های inline در call-sites ارائه شد، که می‌تواند به اجرای سریع‌تر ژنریک‌ها منجر شود (tip.golang.org). بررسی جنبه‌های تاثیرگذار بر عملکرد # ۱. قواعد Dictionary-based مونومورفی‌سازی # Go از تکنیک جزئی مونومورفی‌سازی به وسیله ‌GCShape و دیکشنری استفاده می‌کند. این روش مقداری overhead در سربار lookup برای methodها ایجاد می‌کند، به ویژه اگر پارامتر نوع، interface باشد .\n۲. تأخیر در lookup برای methodهای اینترفیسی # مقایسه benchmarking‌ نشان داد:\nBenchmarkFooIFace: 5.38 ns/op BenchmarkFooGeneric: 14.33 ns/op یعنی استفاده از ژنریک ~2.6 برابر کندتر از فراخوانی مستقیم interface است (deepsource.com).\n۳. تأثیر بر توسعه‌دهی و بهبودهای آینده # توسعه کامپایلر Go در نسخه‌های بعدی احتمالاً نرخ مونومورفی‌سازی و inlining را بهبود می‌دهد . به‌روزرسانی‌ها در Go 1.21+ و αισوب esperanza تعریف generic interfaces نیز چنین پیشرفت‌هایی را تسهیل می‌کنند. "},{"id":88,"href":"/chapter-6/go-generics-fundamentals/","title":"6.2 مبانی ژنریک‌ها در Go","section":"فصل ششم: ژنریک ها (Generics)","content":" ۶.۲.۱ تعریف ژنریک (Generic) چیست؟ # ژنریک (Generic) به معنی \u0026ldquo;کلی\u0026rdquo;، \u0026ldquo;عام\u0026rdquo; یا \u0026ldquo;نوع‌پذیر\u0026rdquo; است؛ مفهومی که به شما امکان می‌دهد یک تابع، نوع داده یا ساختار را به گونه‌ای بنویسید که با انواع مختلف داده‌ها کار کند، بدون اینکه برای هر نوع، پیاده‌سازی جداگانه لازم باشد.\nبه بیان دیگر، ژنریک‌ها قابلیتی برای بازاستفاده امن و بهینه از کد در سطح زبان برنامه‌نویسی هستند.\nیه جمله ای از Ian lancer tailor هست:\nزمانی باید از جنریک استفاده کرد که کد شما بواسطه تغییر تایپ تکرار می شود یا اینکه برای کاهش assertion از جنریک استفاده کنیم.\nکاربرد ژنریک: # فرض کنید می‌خواهید یک تابع برای پیدا کردن مقدار بیشینه در یک آرایه بنویسید.\nدر حالت عادی باید برای هر نوع داده (int، float64، string و \u0026hellip;) یک نسخه بنویسید یا از interface{} استفاده کنید که معایب زیادی دارد.\nژنریک‌ها این محدودیت را برطرف می‌کنند و به شما اجازه می‌دهند که فقط یک بار منطق را بنویسید و برای هر نوع داده‌ای از آن استفاده کنید.\nنمونه ساده:\n// یک تابع ژنریک برای بازگرداندن بیشینه دو مقدار از هر نوع مرتب‌شونده func Max[T cmp.Ordered](a, b T) T { if a \u0026gt; b { return a } return b } اینجا [T cmp.Ordered] می‌گوید T می‌تواند هر نوعی باشد که قابلیت مقایسه داشته باشد (int، float64، string و \u0026hellip;).\nویژگی اصلی ژنریک: # تعریف توابع و ساختارهای عمومی (generic) که به صورت type-safe با انواع مختلف کار می‌کنند. کاهش چشمگیر تکرار کد (DRY) ارتقاء خوانایی و نگهداری کد بهبود کارایی نسبت به روش‌های مبتنی بر interface{} و بازتاب (reflect) ۶.۲.۲ واژگان کلیدی ژنریک در Go # درک مفاهیم کلیدی ژنریک در Go برای استفاده صحیح و حرفه‌ای ضروری است:\n۱. Type Parameter (پارامتر نوع) # متغیری است که نوع داده را به صورت پارامتریک مشخص می‌کند. در تعریف تابع یا نوع ژنریک درون کروشه قرار می‌گیرد. مثال:\nfunc Print[T any](item T) { fmt.Println(item) } ۲. Constraint (قید/محدودیت) # محدودیتی که مشخص می‌کند پارامتر نوع (T) باید چه ویژگی‌هایی داشته باشد. معمولاً یک اینترفیس است که نوع موردنظر باید آن را پیاده‌سازی کند یا عضو مجموعه‌ای از انواع باشد. مثال:\nfunc Sum[T Number](a, b T) T { ... } type Number interface { int | int64 | float64 } ۳. Type Set (مجموعه نوع) # مجموعه‌ای از انواع که یک constraint آن‌ها را مجاز می‌داند.\nدر Go، type set معمولاً به صورت union تعریف می‌شود (مثلاً int | float64)\nدر constraintهای مبتنی بر اینترفیس می‌توانید ترکیبی از method و type را تعیین کنید:\ntype Stringer interface { String() string } type Numeric interface { int | int64 | float64 } ۴. Type Inference (استنتاج نوع) # فرآیندی که در آن کامپایلر Go می‌تواند پارامتر نوع را به صورت خودکار از روی ورودی‌های تابع یا نوع، حدس بزند. مثال:\nMax(10, 20) // T به طور خودکار int فرض می‌شود Max(2.5, 3.8) // T به طور خودکار float64 فرض می‌شود ۵. Constraint Interface (اینترفیس محدودکننده) # اینترفیس‌هایی که هم می‌توانند method داشته باشند هم مجموعه‌ای از انواع را مشخص کنند. مثال:\ntype Constraint interface { ~[]byte | ~string Hash() uint64 } ۶. any و comparable # any: معادل interface{}، یعنی هر نوعی را مجاز می‌داند. comparable: فقط نوع‌هایی که قابل مقایسه با == و != هستند را می‌پذیرد (برای map key و غیره). ۶.۲.۳ تفاوت ژنریک‌های Go با سایر زبان‌ها (Java، C#، Rust و \u0026hellip;) # ژنریک‌ها مفهومی جهانی هستند، اما نحوه پیاده‌سازی و امکانات آن‌ها در زبان‌های مختلف متفاوت است. در اینجا برخی تفاوت‌های کلیدی آورده شده است:\nالف) سینتکس و سادگی # ژنریک‌های Go به صورت پارامتر نوع در کروشه [] تعریف می‌شوند:\nfunc Swap[T any](a, b T) (T, T) در Java و C#: پارامتر نوع با \u0026lt;\u0026gt; تعریف می‌شود:\npublic \u0026lt;T\u0026gt; void swap(T a, T b) ب) Type Constraint # Go امکان تعریف محدودیت (constraint) به شکل بسیار قوی و صریح با اینترفیس یا مجموعه نوع دارد. در Java، فقط می‌توانید یک superclass یا interface به عنوان محدودیت تعریف کنید. در Rust، با trait bounds، و در C# با constraints (مثل where T: struct). ج) Type Erasure vs. Monomorphization # در Java، پیاده‌سازی ژنریک‌ها با Type Erasure است؛ یعنی اطلاعات نوع ژنریک در زمان اجرا حذف می‌شود و فقط در زمان کامپایل کنترل می‌شود. در Go (و Rust و ++C)، ژنریک‌ها با Monomorphization پیاده‌سازی می‌شوند؛ یعنی برای هر نوع داده، کد جداگانه‌ای در زمان کامپایل تولید می‌شود (به معنای ایمنی و کارایی بالاتر). C# هم از رویکرد متفاوتی بهره می‌برد که در برخی موارد closer به monomorphization است. د) پشتیبانی از عملیات # در Go می‌توانید union type تعریف کنید (مثلاً int | float64) در Java این امکان وجود ندارد و باید فقط به یک superclass یا interface محدود کنید. ه) Specialization و Reflection # Go ژنریک‌ها را به صورت type-safe و بدون بازتاب (reflect) اجرا می‌کند، در حالی که در زبان‌هایی مثل Python و حتی Java، بخشی از قدرت ژنریک‌ها وابسته به بازتاب است. Rust و ++C هم مانند Go، اجرا را type-safe و بدون reflect انجام می‌دهند. و) تفاوت در قابلیت‌ها # در Go، ژنریک‌ها روی function, struct و interface قابل اعمال هستند. در Rust و ++C حتی macroها و traitهای پیچیده‌تر و specializationهای سطح پایین‌تر ممکن است. در Java و C#، برخی ویژگی‌ها مانند generic constructor یا wildcard support متفاوت‌اند. "},{"id":89,"href":"/chapter-6/go-generics-syntax-and-structure/","title":"6.3 سینتکس و ساختار ژنریک‌ها در Go","section":"فصل ششم: ژنریک ها (Generics)","content":" ۶.۳.۱ تعریف تابع ژنریک (Generic Functions) # در Go از نسخه ۱.۱۸، می‌توانید توابعی بنویسید که به‌جای نوع خاص، با نوع پارامتری کار می‌کنند. پارامترهای نوعی (type parameters) در کروشه [] بعد از نام تابع قرار می‌گیرند.\nنمونه سینتکس: # func Swap[T any](a, b T) (T, T) { return b, a } T پارامتر نوعی است که می‌تواند هر نوعی را بپذیرد (در اینجا با constraint any).\nتابع بالا می‌تواند برای هر نوعی (int، string، ساختار دلخواه و \u0026hellip;) فراخوانی شود:\na, b := Swap[int](1, 2) // خروجی: 2, 1 x, y := Swap[string](\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;) // خروجی: \u0026quot;b\u0026quot;, \u0026quot;a\u0026quot; Type Inference: معمولاً Go نوع را به طور خودکار تشخیص می‌دهد و نیازی به ذکر [int] نیست:\ns, t := Swap(\u0026quot;hello\u0026quot;, \u0026quot;world\u0026quot;) با constraint (محدودیت نوع): # func Max[T cmp.Ordered](a, b T) T { if a \u0026gt; b { return a } return b } در اینجا فقط انواع مرتب‌شونده (int, float64, string, \u0026hellip;) مجاز هستند.\n۶.۳.۲ تعریف نوع (Type) ژنریک (Generic Types) # شما می‌توانید struct، slice، map یا هر نوع داده دلخواه را به صورت ژنریک تعریف کنید تا برای انواع مختلف قابل استفاده باشد.\nمثال Struct ژنریک: # type Box[T any] struct { Value T } اکنون می‌توانید Box را برای هر نوعی استفاده کنید:\nvar intBox Box[int] intBox.Value = 42 var strBox Box[string] strBox.Value = \u0026quot;Go!\u0026quot; مثال عملی – Stack ژنریک: # type Stack[T any] struct { items []T } func (s *Stack[T]) Push(item T) { s.items = append(s.items, item) } func (s *Stack[T]) Pop() (T, bool) { if len(s.items) == 0 { var zero T return zero, false } idx := len(s.items) - 1 item := s.items[idx] s.items = s.items[:idx] return item, true } این ساختار را می‌توانید برای int، string، struct دلخواه و \u0026hellip; به کار ببرید.\n۶.۳.۳ تعریف اینترفیس ژنریک (Generic Interfaces) # از Go 1.18+، می‌توانید interfaceهایی با پارامتر نوع بنویسید. این امکان بسیار قدرتمند است و اجازه abstraction و تعریف constraintهای پیچیده را می‌دهد.\nنمونه سینتکس: # type Equaler[T any] interface { Equal(T) bool } هر نوعی که متد Equal(T) bool داشته باشد می‌تواند پیاده‌ساز این اینترفیس باشد. مثال – Set ژنریک: # type Set[E any] interface { Insert(E) Delete(E) Has(E) bool } اکنون می‌توانید انواع مختلف Set برای انواع داده متفاوت پیاده‌سازی کنید. Constraint ژنریک مبتنی بر متد: # type Comparer[T any] interface { Compare(T) int } این الگو به شما اجازه می‌دهد فقط با انواعی کار کنید که متد Compare دارند. نکته کاربردی: تعریف constraintها و abstractionهای پیشرفته با استفاده از generic interface در نسخه‌های جدید Go (به ویژه Go 1.21+ و Go 1.24) بسیار ساده و قدرتمند شده است.\n۶.۳.۴ استفاده همزمان از چند پارامتر نوع (Multiple Type Parameters) # گاهی لازم است تابع یا نوعی بنویسید که با چند نوع مختلف سر و کار دارد.\nنمونه سینتکس: # func CopyMap[K comparable, V any](m map[K]V) map[K]V { newMap := make(map[K]V) for k, v := range m { newMap[k] = v } return newMap } اینجا K کلیدهایی است که باید قابل مقایسه باشند (comparable)، و V می‌تواند هر نوعی باشد. مثال Struct با چند پارامتر نوع: # type Pair[A, B any] struct { First A Second B } می‌توانید انواع مختلف را جفت کنید:\np := Pair[int, string]{First: 1, Second: \u0026quot;Go\u0026quot;} ۶.۳.۵ معرفی و کاربرد Generic Type Alias (جدید در Go 1.24) # در نسخه ۱.۲۴ Go، امکان تعریف type alias برای انواع ژنریک اضافه شد که نقش بسیار مهمی در خوانایی، بازاستفاده و ماژولار کردن کد دارد.\n۶.۳.۵.۱ تفاوت Type Alias معمولی و ژنریک # تا قبل از Go 1.24، فقط می‌توانستید برای انواع غیرژنریک alias تعریف کنید:\ntype MyInt = int از Go 1.24، می‌توانید برای انواع ژنریک هم alias بسازید:\ntype Box[T any] struct{ Value T } type IntBox = Box[int] // نوع IntBox معادل Box[int] است ۶.۳.۵.۲ کاربردهای عملی Generic Type Alias # کاهش تکرار کد و ساده‌تر شدن refactoring\nتعریف alias برای توابع ژنریک، constraintها، و حتی mapها و channelهای ژنریک:\ntype StringMap[V any] = map[string]V type UserChan = chan User تمیز و خواناتر شدن APIها و لایه abstraction:\ntype ConfigMap = map[string]string ۶.۳.۵.۳ بهترین شیوه‌های نام‌گذاری و ضدالگوها # نام‌های گویا و معنادار انتخاب کنید؛\n❌ بد:\ntype X = Box[int] ✅ خوب:\ntype UserIDBox = Box[int] از aliasهای تو در تو و بیش از حد بپرهیزید؛ فقط برای کدهایی که واقعاً تکرار می‌شوند و نیاز به abstraction دارند استفاده کنید. ۶.۳.۶ حذف Core Type در Go 1.25 و تأثیر آن بر ژنریک‌ها # در نسخه‌های اولیه ژنریک Go، مفهومی به نام core type وجود داشت که تعیین می‌کرد یک type parameter در زمان compile-time به چه underlying type‌ای ارجاع داده می‌شود. این مفهوم باعث پیچیدگی و محدودیت در برخی عملیات‌ها (مانند index، slice و \u0026hellip;) شده بود.\nاز Go 1.25 به بعد:\ncore type از استاندارد حذف شد و قواعد هر عملیات به صورت واضح‌تر و مستقل بیان شد. خوانایی و سادگی زبان افزایش یافت و پیام‌های خطا شفاف‌تر شدند. حالا فقط کافی است برای عملیات مورد نظر constraint درست تعریف شود (مثلاً اگر با map کار می‌کنید باید comparable باشد). "},{"id":90,"href":"/chapter-6/go-generics-type-sets-and-constraints/","title":"6.4 Constraints و Type Sets","section":"فصل ششم: ژنریک ها (Generics)","content":" ۶.۴.۱ مفهوم constraint و نقش آن در ژنریک‌ها # Constraint (قید یا محدودیت) در ژنریک‌های Go ابزاری است برای کنترل اینکه یک پارامتر نوعی (type parameter) باید چه ویژگی‌هایی داشته باشد.\nبدون constraint، هر نوعی می‌تواند جایگزین شود، اما با تعریف constraint، دایره‌ی مجاز را محدود می‌کنیم تا هم ایمنی نوعی بالا رود و هم امکانات بیشتری برای پیاده‌سازی داشته باشیم.\nنقش constraint: # جلوگیری از استفاده نادرست از ژنریک‌ها (مثلاً استفاده از عملیات غیرمجاز روی نوع پارامتری) افزایش قابلیت تشخیص خطا در زمان کامپایل امکان تعریف abstractionهای قوی‌تر مثال ساده:\nfunc Sum[T Number](a, b T) T { return a + b } type Number interface { int | float64 } در این مثال، فقط انواعی که در constraint Number تعریف شده‌اند، مجاز هستند.\n۶.۴.۲ interface constraint و مثال‌های کاربردی # در Go، constraint معمولاً به صورت یک interface بیان می‌شود؛ این interface می‌تواند شامل متدها یا ترکیبی از انواع (type sets) باشد.\nمثال: constraint مبتنی بر متد # type Stringer interface { String() string } func PrintString[T Stringer](v T) { fmt.Println(v.String()) } هر نوعی که متد String() string را داشته باشد (مثلاً time.Time یا type خودتان)، می‌تواند برای این تابع استفاده شود.\nمثال: constraint مبتنی بر type set (union) # type Numeric interface { int | int64 | float64 } func Max[T Numeric](a, b T) T { if a \u0026gt; b { return a } return b } فقط انواع عددی مجاز به استفاده از Max هستند.\nمثال: ترکیبی # type ByteString interface { ~[]byte | ~string } func FirstChar[T ByteString](s T) byte { return s[0] } هر نوعی که underlying آن []byte یا string باشد، مجاز است.\n۶.۴.۳ استفاده از کلیدواژه‌های any، comparable و Ordered # Go چندین constraint از پیش تعریف‌شده دارد:\nany # معادل interface{}، یعنی هیچ محدودیتی وجود ندارد:\nfunc Identity[T any](v T) T { return v } comparable # فقط نوع‌هایی که می‌توان با == یا != مقایسه کرد (برای map key یا مجموعه‌ها):\nfunc Contains[T comparable](slice []T, v T) bool { for _, item := range slice { if item == v { return true } } return false } Ordered (از پکیج cmp، Go 1.21+) # برای انواعی که می‌توان از \u0026lt;, \u0026gt;, \u0026lt;=, \u0026gt;= استفاده کرد (int, float, string):\nimport \u0026quot;cmp\u0026quot; func Min[T cmp.Ordered](a, b T) T { if a \u0026lt; b { return a } return b } ۶.۴.۴ ساخت constraint سفارشی و ترکیبی (union constraints) # شما می‌توانید constraint دلخواه بسازید و انواع مختلف را در یک مجموعه (type set) قرار دهید:\nمثال: # type IDType interface { int | int64 | string } func ParseID[T IDType](v T) string { return fmt.Sprintf(\u0026quot;%v\u0026quot;, v) } می‌توانید متد هم به آن اضافه کنید:\ntype ToStringer interface { ~string | ~[]byte ToString() string } نکته مهم: # علامت ~ در Go به این معنی است که نوع مورد نظر باید underlying type مشخص‌شده را داشته باشد (مثلاً نوع تعریف‌شده‌ای که underlying آن string باشد).\nدر Go 1.24 به بعد می‌توانید حتی constraint alias تعریف کنید:\ntype Num = interface{ int | float64 } ۶.۴.۵ Generic Interfaces و قابلیت‌های جدید (بر اساس Go 1.21+ و 1.24) # ژنتریک اینترفیس‌ها (Generic Interfaces) از Go 1.18 امکان‌پذیر شد و در نسخه‌های جدید، قابلیت‌های قوی‌تری یافته است.\n۶.۴.۵.۱ پیاده‌سازی الگوهای abstraction با interface ژنریک # می‌توانید abstractionهایی بسازید که به طور کلی روی انواع مختلف اعمال شوند:\ntype Comparer[T any] interface { Compare(T) int } type Sortable[T Comparer[T]] []T func (s Sortable[T]) Sort() { sort.Slice(s, func(i, j int) bool { return s[i].Compare(s[j]) \u0026lt; 0 }) } هر نوعی که متد Compare(T) int را داشته باشد، قابل استفاده است. این قابلیت قدرت abstraction و توسعه کتابخانه‌های عمومی را به شدت افزایش داده است. ۶.۴.۵.۲ نکات و چالش‌های پیشرفته (مثلاً مسأله pointer receivers و type inference) # الف) pointer receivers:\nگاهی constraint روی اینترفیس باید به نوع pointer باشد تا متدهای دریافت‌کننده (receiver) به درستی کار کند.\nاگر متدها روی pointer تعریف شده باشند، باید pointer به عنوان نوع پارامتر بدهید:\ntype Setter[T any] interface { Set(T) } func Update[T any, S Setter[T]](s S, v T) { s.Set(v) } ب) type inference در چند پارامتر:\nدر برخی موارد که چندین type parameter وجود دارد (مثلاً برای abstractionهای پیچیده یا ترکیب چند constraint)، ممکن است inference نوع پیچیده شود و لازم باشد type parameters را به صراحت مشخص کنید.\nج) مقایسه با زبان‌های دیگر:\nدر Go سعی شده تا حد امکان inference ساده و شفاف باشد، اما در abstractionهای خیلی پیچیده (مانند ژنریک تو در تو، pointer receivers یا interface embedding) ممکن است خوانایی امضاها (signature) کمی سخت شود، به خصوص برای توسعه‌دهندگان تازه‌کار.\nد) نکته تولیدی:\nتا حد امکان constraintها را ساده، گویا و خوانا نگه دارید. constraintهای ترکیبی و abstractionهای ژنریک را فقط زمانی به کار ببرید که واقعاً نیاز است و مستندسازی کافی داشته باشید.\n۶.۴.۶ بررسی عمیق constraints در Go # در Go، هرچقدر آزادی در انتخاب نوع پارامتر بیشتر شود، قدرت استفاده از آن کمتر خواهد بود. بنابراین، از محدودیت‌های دقیق برای افزایش قابلیت‌های ژنریک‌ها استفاده می‌کنیم. در واقع، به جای [T any]، باید constraint مناسب انتخاب شود که کامپایلر بداند چه عملیاتی روی T مجاز است.\nقاعده کلی: هرچه interface یا constraint بزرگ‌تر باشد، abstraction ضعیف‌تر است.\n✅ چرا [T any] محدودیت دارد؟ # با تعریف تابع ساده مثل:\nfunc Add[T any](a, b T) T { return a + b } کامپایلر Go خطا می‌دهد چون از T any نمی‌داند آیا T قابلیت عملگر + را دارد یا خیر. بنابراین نمی‌تواند کدی را که معتبر باشد تولید کند. این نشان می‌دهد که آزادی بیش از حد باعث حذف قابلیت‌های مهم می‌شود.\nانواع constraint در Go # ۱. Basic Interface Constraint (محدودیت بر پایه متد) # این نوع constraint شامل متدهایی است که باید توسط نوع پیاده‌سازی شود.\nمثال:\nfunc Stringify[T fmt.Stringer](v T) string { return v.String() } اینجا کامپایلر می‌داند که v متدی به نام String() دارد، بنابراین می‌تواند آن را بدون خطا اجرا کند.\n۲. Type Set Constraint (محدودیت لیستی برای عملگرها) # برای استفاده از عملگرهایی مثل +، باید T را محدود کنیم تا مجموعه‌ای از انواع مشخص باشد:\ntype Numeric interface { int | int64 | float64 } func Add[T Numeric](a, b T) T { return a + b } اکنون کامپایلر تضمین می‌دهد که T حتماً یکی از انواع عددی است و عمل + معتبر خواهد بود.\nهمچنین برای اجازه استفاده از ~ برای پذیرش زیرنوع‌ها:\ntype Intish interface { ~int } ۳. ترکیب محدودیت‌ها # می‌توان constraintهایی ساخت که چند محدودیت را همزمان اعمال کنند، مثلاً متد و عملگر:\ntype ReadStringer interface { fmt.Stringer io.Reader ~[]byte | ~string } این محدودیت بیان می‌کند که T باید هم String() داشته باشد، هم Read() اجرا کند، و نوع underlying آن []byte یا string باشد.\n🔑 اهمیت و پیامدها # خوانایی و اطمینان بالا:\nبا محدود کردن دقیق T تنها به انواعی که عملیات مورد نظر را دارند، از بروز خطا جلوگیری می‌کنید.\nکارایی بدون overhead:\nچون کامپایلر می‌داند دقیقاً چه عملیاتی مجاز است، نیازی به reflect یا بررسی در runtime نیست.\nارتقاء abstraction:\nتعریف سلسله‌مراتبی از constraintها مانند Numeric, Ordered، یا ReadStringer امکان reuse و خوانایی بالاتر کد را فراهم می‌کند.\n"},{"id":91,"href":"/chapter-6/go-generics-examples-and-practical/","title":"6.5 مثال‌ها و کاربردهای عملی ژنریک‌ها","section":"فصل ششم: ژنریک ها (Generics)","content":" ۶.۵.۱ توابع ژنریک متداول (مانند Min, Max, Map, Filter) # تابع Min و Max # import \u0026quot;cmp\u0026quot; // از Go 1.21+ func Min[T cmp.Ordered](a, b T) T { if a \u0026lt; b { return a } return b } func Max[T cmp.Ordered](a, b T) T { if a \u0026gt; b { return a } return b } توضیح:\nاین دو تابع ژنریک به شما اجازه می‌دهند با هر نوع داده‌ای که قابل مقایسه با عملگرهای بزرگ‌تر/کوچک‌تر باشد (مثل int، float64، string و\u0026hellip;) بیشینه یا کمینه دو مقدار را به دست آورید. پارامتر نوعی T باید قید cmp.Ordered را داشته باشد تا عملیات مقایسه مجاز باشد. این ساختار به جای نوشتن نسخه‌های تکراری برای هر نوع داده، یک تابع عمومی و امن ایجاد می‌کند.\nتابع Map (اعمال تابع روی عناصر یک لیست) # func Map[T any, R any](input []T, fn func(T) R) []R { result := make([]R, len(input)) for i, v := range input { result[i] = fn(v) } return result } توضیح:\nاین تابع یک لیست (input) را می‌گیرد و یک تابع (fn) را روی هر عنصر آن اجرا می‌کند و خروجی‌های تابع را به عنوان لیست جدید بازمی‌گرداند. نوع ورودی (T) و خروجی (R) کاملاً ژنریک هستند و می‌توانید هر تبدیل یا پردازشی را با این الگو روی لیست‌های خود انجام دهید، مثلاً مربع اعداد، تبدیل عدد به رشته و غیره.\nتابع Filter (فیلتر کردن عناصر یک لیست) # func Filter[T any](input []T, pred func(T) bool) []T { var result []T for _, v := range input { if pred(v) { result = append(result, v) } } return result } توضیح:\nتابع Filter یک لیست و یک تابع شرطی (predicate) می‌گیرد و تنها عناصر لیست را که شرط روی آن‌ها برقرار است، انتخاب و در یک لیست جدید بازمی‌گرداند. این کار باعث می‌شود بدون تکرار کد برای هر نوع داده، فیلترهای قدرتمند و ایمن داشته باشید (مثلاً استخراج فقط اعداد زوج یا رشته‌هایی با طول خاص).\n۶.۵.۲ ساختارهای داده ژنریک (Stack، Queue، List و \u0026hellip;) # Stack ژنریک # type Stack[T any] struct { data []T } func (s *Stack[T]) Push(val T) { s.data = append(s.data, val) } func (s *Stack[T]) Pop() (T, bool) { if len(s.data) == 0 { var zero T return zero, false } last := len(s.data) - 1 val := s.data[last] s.data = s.data[:last] return val, true } توضیح:\nاین کد یک ساختار داده پشته (Stack) را به صورت ژنریک پیاده‌سازی می‌کند؛ یعنی می‌توانید هر نوع داده‌ای را در پشته ذخیره کنید. متد Push یک مقدار جدید به انتهای پشته اضافه می‌کند و Pop مقدار آخر را حذف و بازمی‌گرداند. اگر پشته خالی باشد، مقدار صفر نوع داده (zero value) برگردانده می‌شود. این پیاده‌سازی قابلیت استفاده برای int، string یا حتی structهای پیچیده را دارد.\nQueue ژنریک # type Queue[T any] struct { data []T } func (q *Queue[T]) Enqueue(val T) { q.data = append(q.data, val) } func (q *Queue[T]) Dequeue() (T, bool) { if len(q.data) == 0 { var zero T return zero, false } val := q.data[0] q.data = q.data[1:] return val, true } توضیح:\nکد بالا یک صف (Queue) ژنریک را پیاده‌سازی می‌کند که برای هر نوع داده‌ای قابل استفاده است. متد Enqueue عنصر جدیدی را به انتهای صف اضافه می‌کند و Dequeue عنصر ابتدای صف را حذف و بازمی‌گرداند. اگر صف خالی باشد، مقدار صفر نوع داده برگردانده می‌شود. این الگو برای مدیریت صف درخواست‌ها یا پیام‌ها با هر نوع داده‌ای بسیار کاربردی است.\nList ژنریک # type List[T any] struct { items []T } func (l *List[T]) Add(val T) { l.items = append(l.items, val) } func (l *List[T]) Get(index int) (T, bool) { if index \u0026lt; 0 || index \u0026gt;= len(l.items) { var zero T return zero, false } return l.items[index], true } توضیح:\nاین ساختار یک لیست ساده ژنریک است که می‌توانید هر نوع داده‌ای را به آن اضافه یا با اندیس بازیابی کنید. متد Add برای افزودن و Get برای دریافت مقدار در اندیس دلخواه (همراه با بررسی بازه ایمن) استفاده می‌شود. این ساختار می‌تواند پایه ساخت کلکسیون‌ها و آرایه‌های سفارشی در پروژه‌های بزرگ‌تر باشد.\n۶.۵.۳ ترکیب ژنریک با سایر ویژگی‌های Go (کانال‌ها، مپ‌ها و اینترفیس‌ها) # Channel ژنریک # type Chan[T any] chan T func Producer[T any](out Chan[T], vals ...T) { for _, v := range vals { out \u0026lt;- v } close(out) } توضیح:\nدر این مثال، نوع کانال (Channel) به صورت ژنریک تعریف شده است، یعنی می‌توانید کانال ارسال/دریافت داده برای هر نوعی بسازید. تابع Producer داده‌های ورودی را به کانال می‌فرستد و در پایان آن را می‌بندد. این الگو برای پردازش موازی و همزمان داده‌ها در معماری‌های concurrent و pipeline بسیار مناسب است.\nMap ژنریک با constraint # func Keys[K comparable, V any](m map[K]V) []K { keys := make([]K, 0, len(m)) for k := range m { keys = append(keys, k) } return keys } توضیح:\nتابع Keys یک map را می‌گیرد و لیستی از کلیدهای آن را بازمی‌گرداند. نوع کلید باید قابل مقایسه باشد (comparable)، چون mapهای Go فقط با کلیدهای قابل مقایسه کار می‌کنند. این تابع برای استخراج سریع و type-safe کلیدهای هر map بسیار مفید است.\nاینترفیس ژنریک و abstraction # type Repository[T any] interface { FindByID(id int) (T, error) Save(entity T) error } type User struct{ Name string } type UserRepo struct{ data map[int]User } func (r *UserRepo) FindByID(id int) (User, error) { u, ok := r.data[id] if !ok { return User{}, errors.New(\u0026quot;not found\u0026quot;) } return u, nil } func (r *UserRepo) Save(entity User) error { r.data[len(r.data)] = entity return nil } توضیح:\nدر این مثال، یک اینترفیس ژنریک برای مخزن داده (Repository) تعریف شده است که می‌تواند برای هر نوع داده (مثلاً User) پیاده‌سازی شود. متدهای FindByID و Save عملیات بازیابی و ذخیره را type-safe انجام می‌دهند. این الگو پایه معماری clean و قابل توسعه برای لایه داده در پروژه‌های تولیدی است.\n۶.۵.۴ نمونه‌های تولیدی و پروژه‌ای (از کدهای واقعی و کاربردی) # سرویس کش ژنریک # type Cache[K comparable, V any] struct { data map[K]V } func NewCache[K comparable, V any]() *Cache[K, V] { return \u0026amp;Cache[K, V]{data: make(map[K]V)} } func (c *Cache[K, V]) Set(key K, value V) { c.data[key] = value } func (c *Cache[K, V]) Get(key K) (V, bool) { v, ok := c.data[key] return v, ok } توضیح:\nدر اینجا یک سرویس کش (Cache) به صورت ژنریک پیاده‌سازی شده که برای هر نوع کلید (comparable) و هر نوع مقدار قابل استفاده است. با استفاده از این ساختار می‌توانید بدون تکرار کد برای انواع مختلف داده، کش‌های بهینه و امن بسازید که در پروژه‌های واقعی (مثلاً کش کاربر، تنظیمات یا داده‌های session) بسیار کاربردی است.\nPipeline ژنریک برای پردازش داده‌ها # func Pipeline[T any](data []T, stages ...func([]T) []T) []T { for _, stage := range stages { data = stage(data) } return data } توضیح:\nتابع Pipeline به شما امکان می‌دهد زنجیره‌ای از مراحل پردازش (stages) را روی لیست داده اجرا کنید. هر مرحله یک تابع است که لیست را می‌گیرد و خروجی پردازش را بازمی‌گرداند. این الگو برای پردازش داده‌های بزرگ، تحلیل داده یا پیاده‌سازی الگوهای data pipeline در سیستم‌های تولیدی بسیار ارزشمند است.\n"},{"id":92,"href":"/chapter-6/comparing-generics/","title":"6.6 مقایسه ژنریک‌ها با راهکارهای قبل از Go 1.18","section":"فصل ششم: ژنریک ها (Generics)","content":" ۶.۶.۱ استفاده از interface{} و reflect قبل از ژنریک‌ها # پیش از Go 1.18، برای پیاده‌سازی توابع یا ساختارهای داده عمومی، معمولاً از نوع interface{} (نوع همه‌کاره) استفاده می‌شد. در موارد نیاز به عملیات خاص یا تبدیل نوع، ناچار به استفاده از reflect یا type assertion بودیم. این روش‌ها معایب و ریسک‌های خاص خود را داشتند.\nمثال: تابع Max با interface{} و reflect # ` import ( \"fmt\" \"reflect\" ) func Max(a, b interface{}) interface{} { av := reflect.ValueOf(a) bv := reflect.ValueOf(b) if av.Kind() == reflect.Int \u0026\u0026 bv.Kind() == reflect.Int { if av.Int() \u003e bv.Int() { return a } return b } // می‌توانید برای انواع دیگر هم کد بنویسید return nil } func main() { fmt.Println(Max(3, 7)) // خروجی: 7 } ▶ اجرای کد کپی ✖ بستن خروجی توضیح: در این مثال تابع Max با هر نوعی که به آن بدهید کار می‌کند، اما باید به کمک reflect نوع مقدار را بررسی و مقایسه کنید. این کار هم کند است و هم ایمنی نوعی ندارد و در زمان اجرا ممکن است باعث panic یا رفتار ناخواسته شود.\n۶.۶.۲ مزایا و معایب هر روش # interface{} و reflect (روش قدیمی) # مزایا:\nقابلیت انعطاف برای پذیرش هر نوع داده (generic ظاهر) قابل استفاده در زبان‌های قبل از Go 1.18 معایب:\nکاهش ایمنی نوعی (Type Safety): خطاهای نوع فقط در زمان اجرا کشف می‌شوند. پیچیدگی و خوانایی پایین: بررسی نوع با reflect یا type assertion باعث طولانی و پیچیده شدن کد می‌شود. افت کارایی: بازتاب (reflect) کند است و فراخوانی‌های زیاد باعث overhead می‌شود. خطر panic: اگر نوع داده اشتباه ارسال شود، احتمال panic بالا می‌رود. عدم هشدار کامپایلری: هیچ هشدار یا خطایی از سمت کامپایلر دریافت نمی‌کنید. تست و نگهداری دشوار: تست و اشکال‌زدایی کدهایی که مبتنی بر interface{} و reflect هستند به مراتب سخت‌تر است. ژِنریک‌های Go (از 1.18 به بعد) # مزایا:\nایمنی نوعی بالا: همه خطاهای نوع در زمان کامپایل مشخص می‌شوند. کد کوتاه‌تر و خواناتر: نیاز به تکرار تابع برای هر نوع داده نیست و بازتاب حذف می‌شود. کارایی بهتر: هیچ overhead ناشی از reflect یا type assertion وجود ندارد و کد تولیدشده شبیه کد دستی است. نگهداری آسان‌تر: refactoring راحت‌تر و تست‌پذیری بالاتر مستندسازی خودکار و بهتر: امضاهای توابع و structها واضح و قابل فهم برای توسعه‌دهندگان و ابزارهاست. معایب:\nنیاز به نسخه جدید Go: فقط در Go 1.18 به بعد قابل استفاده است. درک اولیه برای توسعه‌دهندگان تازه‌کار ممکن است کمی زمان‌بر باشد. در برخی موارد خاص (مانند ژنریک اینترفیس‌های خیلی پیچیده)، امضاها می‌تواند کمی پیچیده شود. ۶.۶.۳ مقایسه کارایی، خوانایی و نگهداشت # ویژگی interface{} و reflect (قدیمی) ژنریک‌های Go (جدید) ایمنی نوع بسیار پایین (خطر panic بالا) بسیار بالا (compile-time checked) خوانایی پایین و پیچیده (reflect و assert) بالا و شفاف (type-safe) کارایی کند (overhead بازتاب) سریع (مانند کد معمولی) نگهداری دشوار و پرخطا آسان و قابل refactor تست‌پذیری سخت (خطاهای run-time) بسیار آسان (خطاهای compile-time) کد تکراری زیاد (اگر برای هر نوع دستی بنویسید) حداقل (یک بار برای همه انواع) "},{"id":93,"href":"/chapter-6/limitations-errors-and-anti-patterns-in-generics/","title":"6.7 محدودیت‌ها، خطاها و ضدالگوها در ژنریک‌ها","section":"فصل ششم: ژنریک ها (Generics)","content":" ۶.۷.۱ محدودیت‌های فعلی ژنریک‌ها در Go (Compile-time \u0026amp; Runtime) # اگرچه ژنریک‌ها قابلیت فوق‌العاده‌ای به Go افزوده‌اند، اما هنوز با برخی محدودیت‌های فنی و زبانی روبه‌رو هستند که باید حتماً در پروژه‌های جدی مدنظر قرار گیرد:\nمحدودیت‌های زمان کامپایل (Compile-time) # عدم پشتیبانی از عملیات ریاضی یا منطقی روی هر نوع دلخواه:\nفقط انواعی که قید مناسب (مانند cmp.Ordered یا union خاص) دارند می‌توانند با عملگرهای مقایسه یا ریاضی استفاده شوند.\nعدم امکان specialization:\nبرخلاف ++C یا Rust، نمی‌توانید نسخه خاصی از تابع یا struct برای نوعی خاص پیاده‌سازی کنید (Specialization).\nمحدودیت روی method set:\nاگر یک type parameter با interface constraint تعریف شود، فقط به متدهای آن constraint دسترسی دارید، حتی اگر نوع واقعی متدهای بیشتری داشته باشد.\nمحدودیت در تعریف type embedding ژنریک:\nهنوز نمی‌توانید یک struct ژنریک را به عنوان فیلد ناشناس (anonymous field) در struct دیگر embed کنید.\nعدم پشتیبانی از const type parameters:\nمثل ++C و Rust، نمی‌توانید مقدار ثابت را به عنوان پارامتر ژنریک تعیین کنید (مثلاً سایز آرایه).\nمحدودیت‌های زمان اجرا (Runtime) # عدم دسترسی به اطلاعات نوع پارامتر در runtime:\nپارامترهای نوع در زمان اجرا قابل شناسایی نیستند و امکان reflection مستقیم روی آن‌ها وجود ندارد.\nخطاهای مرتبط با nil و zero value:\nبازگرداندن مقدار صفر (zero value) برای نوع پارامتریک ممکن است همیشه با منطق کسب‌وکار شما منطبق نباشد.\n۶.۷.۲ خطاها و پیام‌های رایج در استفاده از ژنریک‌ها # در استفاده از ژنریک‌های Go، با برخی پیام‌های خطا و اشکالات رایج مواجه خواهید شد:\nپیام‌های متداول کامپایلر # \u0026ldquo;type T does not satisfy constraint C\u0026rdquo;\nیعنی نوع مورد استفاده تمام ویژگی‌های constraint را ندارد.\n\u0026ldquo;invalid operation: operator X not defined for T\u0026rdquo;\nعملگری روی نوع پارامتریک استفاده شده که constraint اجازه نمی‌دهد.\n\u0026ldquo;cannot use T as type K in map: T does not implement comparable\u0026rdquo;\nبرای map، کلید باید حتماً comparable باشد.\n\u0026ldquo;cannot infer T\u0026rdquo; یا \u0026ldquo;type parameter T cannot be inferred\u0026rdquo;\nکامپایلر قادر به استنتاج نوع پارامتر نیست و باید صراحتاً نوع را تعیین کنید.\n\u0026ldquo;instantiation cycle\u0026rdquo;\nارجاع بازگشتی نادرست یا پیاده‌سازی ضدالگو در constraintها باعث این خطا می‌شود.\nمثال واقعی خطا: # func PrintMapKeys[K comparable, V any](m map[K]V) { for k := range m { fmt.Println(k) } } PrintMapKeys(map[[]int]int{}) // error: []int does not implement comparable ۶.۷.۳ ضدالگوها (Anti-patterns) و اشتباهات متداول # برخی از رفتارها یا کدهای غلط که باید در استفاده از ژنریک‌ها از آن‌ها پرهیز کنید:\n۱. استفاده بیش از حد از any یا constraint بسیار کلی # این کار ایمنی نوعی را کاهش می‌دهد و ژنریک عملاً مانند interface{} عمل می‌کند.\nfunc BadFunc[T any](v T) { /* ... */ } // تقریبا مثل استفاده از interface{} ۲. پیاده‌سازی تابع یا struct ژنریک بدون نیاز واقعی # اگر فقط برای یک نوع خاص استفاده می‌کنید، نیاز به ژنریک ندارید و فقط پیچیدگی ایجاد کرده‌اید.\n۳. بازگرداندن zero value به‌جای error handling # اگر pop روی stack ژنریک خالی انجام شود، صرف بازگرداندن zero value ممکن است باعث بروز باگ پنهان شود؛ بهتر است مقدار بولین یا error نیز بازگردانده شود.\n۴. constraintهای بسیار پیچیده یا ناخوانا # استفاده از چندین interface یا unionهای تو در تو، امضای تابع را گیج‌کننده می‌کند و نگهداری را سخت می‌سازد.\n۵. وابستگی زیاد به type assertion یا reflect # اگر در کد ژنریک زیاد مجبور به type assertion شدید، نشانه این است که abstraction شما صحیح یا idiomatic نیست.\n۶. تعریف و استفاده از type alias بی‌معنا یا بی‌هدف # تعریف alias برای انواع ژنریک بدون هدف مشخص، باعث ابهام و پیچیدگی در پروژه می‌شود.\n۶.۷.۴ نکات مربوط به versionهای جدید (مانند مشکلات Migration و backward compatibility) # مشکلات مهاجرت (Migration) # اگر کتابخانه یا کد قدیمی با interface{} نوشته شده باشد، مهاجرت به ژنریک نیازمند refactoring است. تغییر امضاهای توابع و structها ممکن است باعث شکستن سازگاری با کد قدیمی (backward compatibility) شود. برخی ابزارها و کتابخانه‌های شخص ثالث ممکن است از ژنریک به‌درستی پشتیبانی نکنند یا هنوز به نسخه‌های قدیمی Go محدود باشند. مسائل سازگاری نسخه (Backward Compatibility) # کدی که با ژنریک نوشته شده فقط روی Go 1.18+ اجرا می‌شود. در برخی نسخه‌های جدیدتر Go (مثلاً 1.24 یا 1.25)، امکانات بیشتری مثل generic type alias و بهبود constraintها اضافه شده که استفاده از آن‌ها ممکن است برای پروژه‌های multi-version مشکل‌ساز شود. برخی قابلیت‌ها (مانند حذف core type در Go 1.25) باعث ساده‌تر شدن توسعه ولی تغییر در قواعد قدیمی شده‌اند. نکته های بیلد: # برای حفظ سازگاری نسخه و کاهش ریسک migration:\nامضاهای جدید را با مستندسازی مناسب تغییر دهید. در صورت نیاز از build tag یا نسخه‌بندی ماژول استفاده کنید. همیشه تست‌های unit و integration را قبل و بعد از migration اجرا کنید. "},{"id":94,"href":"/chapter-6/generics-best-practice/","title":"6.8 بهترین شیوه‌های استفاده از ژنریک‌ها (Best Practices)","section":"فصل ششم: ژنریک ها (Generics)","content":"در این بخش، به‌صورت حرفه‌ای، کاربردی و تجربی، بهترین شیوه‌های استفاده از ژنریک‌ها در پروژه‌های Go را همراه با نکات تولیدی و فنی ارائه می‌دهم.\n۶.۸.۱ راهنمای تصمیم‌گیری: چه زمانی ژنریک؟ چه زمانی نه؟ # ژنریک‌ها ابزار قدرتمندی هستند، اما استفاده درست و هوشمندانه از آن‌ها حیاتی است.\nبهتر است ژنریک را فقط زمانی به کار ببرید که:\nیک منطق تکراری برای چندین نوع مختلف وجود دارد و پیاده‌سازی جداگانه برای هر نوع باعث تکرار و دشواری نگهداری می‌شود. نیاز به abstraction و توسعه‌پذیری کد برای آینده وجود دارد، مانند ساختار داده‌ها (Stack, Queue, Map)، یا توابع عمومی (Map, Filter, Reduce). ایمنی نوعی (Type Safety) برایتان مهم است و می‌خواهید خطاها را در زمان کامپایل متوجه شوید. چه زمانی ژنریک استفاده نکنیم؟\nزمانی که فقط برای یک یا دو نوع خاص کد می‌نویسید و abstraction عمومی نیاز ندارید. اگر استفاده از ژنریک خوانایی کد را پایین می‌آورد یا امضای تابع/ساختار بسیار پیچیده می‌شود. اگر abstraction شما منجر به over-engineering یا کد غیرضروری می‌شود. زمانی که عملکرد (performance) بسیار بحرانی است و بنچمارک‌ها نشان می‌دهند که نسخه معمولی سریع‌تر است. نکته:\nهمیشه قبل از ژنریک‌سازی، با کد ساده و معمولی شروع کنید و اگر نیاز به تعمیم و بازاستفاده پیش آمد، refactor به ژنریک انجام دهید.\n۶.۸.۲ نکات خوانایی، نگهداشت‌پذیری و توسعه‌پذیری # نام‌گذاری واضح برای پارامتر نوع:\nاز نام‌های معنادار (مثلاً T برای Type، K برای Key، V برای Value) استفاده کنید و در موارد پیچیده‌تر، نام دقیق‌تر (مثلاً User, IDType) انتخاب کنید.\nconstraintها را تا حد امکان ساده نگه دارید:\nاز any یا constraintهای بیش از حد کلی فقط زمانی استفاده کنید که واقعاً نیاز است.\nتوابع و ساختارهای ژنریک را مستند کنید:\nتوضیح دهید که پارامتر نوع چه ویژگی‌هایی باید داشته باشد.\nامضای تابع/ساختار را پیچیده نکنید:\nسعی کنید از چند پارامتر نوعی زیاد، یا constraintهای تو در تو فقط زمانی استفاده کنید که طراحی شما واقعاً به آن نیاز دارد.\nاز aliasهای ژنریک فقط برای ساده‌سازی و افزایش خوانایی استفاده کنید:\nاز aliasهای نامفهوم و زنجیره‌ای بپرهیزید.\n۶.۸.۳ ترفندهای تولیدی و حرفه‌ای برای پروژه‌های بزرگ و ماژولار # ساخت abstractionهای لایه‌ای:\nابتدا یک interface ژنریک تعریف کنید و سپس پیاده‌سازی‌های مختلف با constraintهای متفاوت بسازید (مثلاً یک interface برای ذخیره‌سازی و چند نوع backend مختلف).\nکتابخانه‌های داخلی و عمومی را ژنریک بنویسید:\nهرجا می‌خواهید reusable library یا utility بسازید، ژنریک ابزار ایده‌آل است.\nژِنریک را با تست و بنچمارک پوشش دهید:\nهمیشه انواع مختلف را تست کنید تا از عدم بروز خطاهای نوعی مطمئن شوید.\nدر پروژه‌های بزرگ از constraint alias استفاده کنید:\nconstraintهای تکراری و ترکیبی را alias کنید تا خوانایی و نگهداری بهبود یابد.\nپشتیبانی از backward compatibility:\nهنگام مهاجرت به ژنریک، بخش‌های پرکاربرد را تدریجی refactor کنید تا کاربران پروژه آسیب نبینند.\n۶.۸.۴ عملکرد (Performance)، Compile-Time و تاثیرات بر روی Debugging # بنچمارک قبل و بعد از ژنریک‌سازی:\nدر بخش‌هایی که performance بحرانی است، حتماً قبل و بعد از استفاده از ژنریک بنچمارک بگیرید. در اکثر موارد، کد ژنریک مثل نسخه دستی اجرا می‌شود، اما در برخی حالات خاص (مانند استفاده از اینترفیس یا constraintهای سنگین)، ممکن است کمی کندتر باشد.\nتاثیر بر زمان کامپایل:\nبا ژنریک، زمان کامپایل ممکن است کمی افزایش یابد (به ویژه در پروژه‌های بزرگ یا با constraintهای پیچیده)، اما با بهینه‌سازی نسخه‌های جدید Go این تاثیر حداقلی است.\nDebugging و پیام‌های خطا:\nپیام‌های خطا در ژنریک‌های پیچیده می‌تواند مبهم باشد. توصیه می‌شود با ساده‌سازی constraint و مستندسازی، کار دیباگ را راحت‌تر کنید.\nدر تست‌ها از انواع مختلف استفاده کنید:\nتست ژنریک با داده‌های متنوع به شما کمک می‌کند از ایمنی کد مطمئن شوید و خطاهای پنهان را بیابید.\n"},{"id":95,"href":"/chapter-6/generics-advanced-examples-and-tips/","title":"6.9 مثال‌های پیشرفته و نکات ویژه","section":"فصل ششم: ژنریک ها (Generics)","content":" ۶.۹.۱ ساخت کتابخانه‌های عمومی و abstractionهای حرفه‌ای با ژنریک‌ها # در پروژه‌های مدرن، معمولاً نیاز به abstraction و لایه‌بندی وجود دارد تا بتوانید کدهای reusable و توسعه‌پذیر بسازید. ژنریک‌ها در Go این کار را بسیار ساده و حرفه‌ای می‌کنند.\nمثال: کتابخانه DataStore ژنریک # type DataStore[T any] interface { Get(id string) (T, error) Save(id string, data T) error } type MemoryStore[T any] struct { data map[string]T } func NewMemoryStore[T any]() *MemoryStore[T] { return \u0026amp;MemoryStore[T]{data: make(map[string]T)} } func (m *MemoryStore[T]) Get(id string) (T, error) { v, ok := m.data[id] if !ok { var zero T return zero, fmt.Errorf(\u0026quot;not found\u0026quot;) } return v, nil } func (m *MemoryStore[T]) Save(id string, data T) error { m.data[id] = data return nil } توضیح:\nدر این مثال یک abstraction برای ذخیره‌سازی داده‌ها پیاده‌سازی شده که می‌تواند برای هر نوع داده‌ای مورد استفاده قرار گیرد (مثلاً User, Order, Product و \u0026hellip;). این ساختار با پیاده‌سازی interface ژنریک، قابلیت توسعه و تست بسیار بالایی دارد و به راحتی می‌توانید MemoryStore را با نسخه DatabaseStore یا CacheStore جایگزین کنید.\n۶.۹.۲ ترکیب ژنریک با error handling و context # ترکیب ژنریک با الگوهای حرفه‌ای مثل مدیریت خطا (error handling) و context در Go باعث ایجاد کدهایی ایمن، تمیز و مقیاس‌پذیر می‌شود.\nمثال: سرویس ژنریک با Context و Error # type Service[T any] interface { FindByID(ctx context.Context, id int) (T, error) } type User struct { Name string } type UserService struct { data map[int]User } func (u *UserService) FindByID(ctx context.Context, id int) (User, error) { select { case \u0026lt;-ctx.Done(): return User{}, ctx.Err() default: user, ok := u.data[id] if !ok { return User{}, fmt.Errorf(\u0026quot;not found\u0026quot;) } return user, nil } } توضیح:\nدر این الگو، abstraction سرویس به صورت ژنریک تعریف شده و متدها از context و error استفاده می‌کنند. این الگو مناسب سرویس‌های REST, gRPC، کار با پایگاه داده و معماری‌های مدرن است.\n۶.۹.۳ نکات بهینه‌سازی و Performance در کد ژنریک # برای کدهای ژنریک، همواره باید کارایی و بهینه‌سازی را در نظر گرفت، مخصوصاً در ساختارهای داده و توابع پرتکرار.\nنکات مهم: # استفاده از constraintهای حداقلی:\nconstraintها را تا جای ممکن ساده نگه دارید تا کامپایلر بتواند بیشترین بهینه‌سازی را انجام دهد.\nاجتناب از reflect و type assertion:\nهرجا می‌توانید منطق را با constraint و متدهای مستقیم حل کنید و از عملیات runtime اضافه بپرهیزید.\nبنچمارک عملی:\nکدهای ژنریک را مثل سایر کدها با بنچمارک مقایسه کنید، به ویژه اگر در مسیر بحرانی اجرا قرار دارند.\nاستفاده از slices و pre-allocation:\nدر ساختارهای داده، اندازه اولیه slice را تعیین کنید تا از افزایش هزینه reallocation جلوگیری شود.\nپروفایلینگ کد ژنریک:\nبا ابزارهایی مثل pprof، عملکرد توابع ژنریک را بررسی کنید تا نقاط bottleneck را شناسایی و رفع کنید.\nمثال بنچمارک ساده: # func BenchmarkMaxInt(b *testing.B) { for i := 0; i \u0026lt; b.N; i++ { _ = Max(123, 456) } } func BenchmarkMaxGeneric(b *testing.B) { for i := 0; i \u0026lt; b.N; i++ { _ = Max[int](123, 456) } } توضیح:\nاین بنچمارک‌ها نشان می‌دهند که در عمل، تفاوت سرعت نسخه ژنریک و نسخه معمولی minimal است، اما باید همیشه در پروژه‌های واقعی تست شوند.\n"},{"id":96,"href":"/chapter-7/","title":"فصل هفتم: تست نویسی","section":"صفحه اصلی","content":"در این فصل به صورت عمیق به مباحث تست‌نویسی در زبان Go پرداخته شده است که شامل عناوین زیر می‌باشد.\n۷.۱ مقدمه‌ای بر تست در Go. ۷.۲ تست واحد Unit Test . ۷.۳ تست جدول‌محور Table-Driven Test . ۷.۴ تست یکپارچه Integration Test . ۷.۵ تست انتها به انتها End-to-End Test . ۷.۶ تست عملکرد Benchmark . ۷.۷ تست فازی Fuzz Testing . ۷.۸ ماک و شبیه‌سازی وابستگی‌ها Mocking . ۷.۹ استفاده از کتابخانه testify برای assertions، mock و ساختاردهی تست‌ها. ۷.۱۰ استفاده از فریم‌ورک ginkgo برای تست‌های سبک BDD. ۷.۱۱ تست‌های همزمانی و تحلیل race conditions. ۷.۱۲ سنجش پوشش کد Code Coverage و گزارش‌گیری. ۷.۱۳ مدیریت و گروه‌بندی تست‌ها با Test Suite. ۷.۱۴ تست‌نویسی حرفه‌ای در پروژه‌های واقعی. "},{"id":97,"href":"/chapter-7/go-introduction-testing/","title":"7.1 مقدمه‌ای بر تست در Go","section":"فصل هفتم: تست نویسی","content":"تست‌نویسی یکی از ارکان حیاتی توسعه نرم‌افزارهای قابل‌اعتماد و نگهدارپذیر است. در دنیای امروز که سرعت توسعه و تغییرات کد روزبه‌روز بیشتر می‌شود، وجود تست‌های دقیق و ساختاریافته تضمین می‌کند که عملکرد نرم‌افزار با تغییرات جدید دچار اختلال نشود. از کشف باگ‌ها گرفته تا مستندسازی رفتار مورد انتظار ماژول‌ها، تست‌ها نقشی فراتر از صرفاً اطمینان‌بخشی دارند. آن‌ها به تیم توسعه جرئت ریفکتور می‌دهند و مرزهای طراحی سیستم را شفاف می‌کنند.\nزبان Go با در نظر گرفتن سادگی و مینیمالیسم به عنوان اصل بنیادین، تست‌نویسی را به عنوان بخشی جدانشدنی از چرخه توسعه درون خود جای داده است. بر خلاف بسیاری از زبان‌ها که برای تست‌نویسی نیاز به نصب ابزارهای اضافی دارند، Go یک ابزار تست‌نویسی داخلی، ساده و قدرتمند به نام testing در کنار دستور go test ارائه می‌دهد که فرآیند اجرا و گزارش‌گیری را بسیار روان و سریع می‌کند. این ابزارها با طراحی سطح پایین و بدون پیچیدگی، توسعه‌دهندگان را تشویق می‌کنند که تست را به بخشی از سبک برنامه‌نویسی خود تبدیل کنند.\nدر Go، تست‌ها همان توابع عادی هستند که با قواعد ساده‌ای مانند TestXxx(t *testing.T) نوشته می‌شوند. خبری از assertionهای پیچیده یا DSLهای سنگین نیست. همین سادگی، آزمون‌ها را خواناتر، نگهدار‌پذیرتر و از همه مهم‌تر، قابل‌درک برای همه اعضای تیم می‌کند. ابزارهای جانبی مانند testify یا ginkgo نیز به عنوان افزونه‌هایی قدرتمند برای پروژه‌های بزرگ‌تر و تست‌های ساختاریافته‌تر به کار گرفته می‌شوند، اما اصل فلسفه Go حفظ مینیمالیسم است.\nدر این فصل، با اصول، ابزارها و الگوهای تست‌نویسی در زبان Go آشنا خواهیم شد؛ از تست واحد، جدول‌محور، یکپارچه و انتها به انتها گرفته تا بنچمارک، تست فازی و تست‌های هم‌زمانی. همچنین به ابزارهایی چون testify, gomock, ginkgo, پوشش تست، ساخت Suite تستی و نحوه تست‌نویسی حرفه‌ای در پروژه‌های واقعی می‌پردازیم. هدف این فصل آن است که مهارت تست‌نویسی شما را در Go از سطح ابتدایی به سطحی قابل‌اعتماد و حرفه‌ای ارتقا دهد.\nبه نقل از ویکی پدیا آزمون نرم‌افزار یا تست نرم‌افزار (به انگلیسی: software testing) به فرایند ارزیابی نرم‌افزار به منظور اطمینان از عملکرد صحیح آن در رویدادهایی مختلفی که ممکن است در دوره استفاده از نرم‌افزار با آن مواجه شود می‌باشد و به عبارت دیگر پیدا کردن خطاهایی احتمالی یک نرم‌افزار برای عملکرد درست، صحیح و بهینه آن در طول استفاده از آن است. هر چقدر نرم‌افزار بتواند با رویدادها مختلف به صورت مطلوب تر و قابل پذیرش تری چه از نظر عملکرد و چه از راحتی کاربر داشته باشد می‌توان انتظار داشت نرم‌افزار دارای عملکرد بهتری می‌باشد. 7.1.1 جایگاه تست در چرخه توسعه نرم‌افزار # در توسعه نرم‌افزار، نوشتن تست فقط یک فعالیت جانبی برای اطمینان از صحت عملکرد نیست، بلکه بخش جدایی‌ناپذیری از طراحی، مستندسازی و حفظ کیفیت سیستم محسوب می‌شود. زمانی که نرم‌افزار رشد می‌کند، تغییر می‌کند و افراد جدید به تیم توسعه می‌پیوندند، تست‌ها نقش ستون‌های قابل اعتماد برای حفظ رفتار صحیح سیستم را ایفا می‌کنند. در این میان، زبان برنامه‌نویسی Go با ساده‌سازی ابزارها و یکپارچه‌سازی امکانات تست‌نویسی، فرآیند توسعه را به‌گونه‌ای طراحی کرده که تست بخشی طبیعی از چرخه توسعه باشد.\n7.1.1.1 تست به عنوان بخشی از طراحی سیستم # در بسیاری از روش‌های توسعه نرم‌افزار، نوشتن تست حتی پیش از پیاده‌سازی کد توصیه می‌شود. در روش‌هایی مانند توسعه مبتنی بر تست یا توسعه مبتنی بر رفتار ، تست‌ها بخش اولیه فرآیند طراحی هستند. در زبان Go، نوشتن تست با استفاده از ساختارهای ساده‌ای مانند TestXxx(t *testing.T) یا استفاده از الگوی تست جدول‌محور باعث می‌شود که طراحی APIها و منطق برنامه به‌صورت طبیعی بر پایه رفتار قابل تست شکل بگیرد. این نوع طراحی نه‌تنها کیفیت را افزایش می‌دهد، بلکه کد را تغییرپذیرتر و خواناتر می‌کند.\n7.1.1.2 تست به عنوان مستند رفتاری سیستم # تست‌ها می‌توانند جایگزینی دقیق، همیشگی و زنده برای مستندسازی باشند. هر تست، سناریویی مشخص از تعاملات سیستم با ورودی‌های مختلف است که خروجی یا رفتار خاصی را انتظار دارد. برخلاف مستندات متنی که به‌مرور زمان منسوخ می‌شوند، تست‌ها در صورت مغایرت با پیاده‌سازی، به‌وضوح شکست خواهند خورد. این ویژگی تست‌ها را به مرجع رفتاری سیستم تبدیل می‌کند. توسعه‌دهندگانی که برای هر ماژول تست می‌نویسند، در واقع رفتار آن ماژول را تعریف و مستند می‌کنند؛ به‌نحوی که برای سایر اعضای تیم یا برای توسعه‌دهندگانی که در آینده با پروژه کار می‌کنند نیز قابل درک است.\nتستی که می‌نویسی، قراردادی زنده با عملکرد سیستم است.\n7.1.1.3 تست به عنوان سپر تغییرات # در پروژه‌هایی که توسعه مداوم دارند، تغییر کد امری اجتناب‌ناپذیر است. اما تغییر بدون پشتوانه تست، خطر ایجاد بازگشت خطا را به همراه دارد. تست‌ها در اینجا به‌عنوان یک سپر دفاعی عمل می‌کنند. پیش از اعمال تغییر، می‌توان با اجرای سریع تست‌ها مطمئن شد که تغییرات، سایر بخش‌های سیستم را تحت تأثیر قرار نداده‌اند. سرعت بالای اجرای تست‌ها در Go باعث می‌شود که این فرآیند به‌صورت مستمر در چرخه توسعه انجام شود. با وجود این تست‌ها، می‌توان با اطمینان بالا اقدام به بازسازی ساختار کد یا اضافه‌کردن ویژگی‌های جدید کرد.\nنمی‌توانی چیزی را بهینه کنی که راستی‌آزمایی‌اش نکرده‌ای.\n7.1.1.4 تست در Go: اولویت یا گزینه؟ # در زبان Go، تست‌نویسی نه‌تنها یک امکان در دسترس، بلکه بخشی از ابزار رسمی توسعه است. برخلاف بسیاری از زبان‌ها که نیازمند نصب ابزارها یا کتابخانه‌های شخص ثالث برای نوشتن تست هستند، Go با فراهم کردن ابزارهایی مانند testing، go test، -cover، -bench و -fuzz از ابتدا زیرساخت تست را فراهم کرده است. این ابزارها سبک توسعه‌ای را ترویج می‌دهند که در آن تست‌نویسی نه بعد از پیاده‌سازی، بلکه در حین توسعه و حتی پیش از آن انجام می‌شود. به همین دلیل، در بسیاری از پروژه‌های حرفه‌ای با زبان Go، تست بخش عادی و ضروری توسعه محسوب می‌شود، نه صرفاً یک انتخاب اختیاری.\n7.1.2 مزایای تست‌نویسی در Go # یکی از نقاط قوت زبان Go، سادگی و یکپارچگی ابزارهای تست‌نویسی است. در حالی که در بسیاری از زبان‌ها، برای شروع تست‌نویسی باید چارچوب‌های خارجی نصب و پیکربندی شوند، در Go هر پروژه به‌صورت پیش‌فرض می‌تواند شامل فایل‌های تست باشد و با استفاده از ابزار رسمی go test به‌سادگی تست‌ها را اجرا کند. این طراحی باعث شده تست‌نویسی در Go نه یک کار جانبی یا پیچیده، بلکه بخشی طبیعی از توسعه روزمره باشد.\n7.1.2.1 ساده‌سازی فرآیند تست‌نویسی # تست‌ها در Go صرفاً توابعی هستند که با الگوی TestXxx(t *testing.T) تعریف می‌شوند. نیازی به ارث‌بری، annotation یا ساختارهای پیچیده نیست. تنها چیزی که لازم است یک تابع ساده و چند شرط منطقی برای بررسی نتایج است. همین سادگی باعث می‌شود افراد تازه‌کار نیز بتوانند به‌راحتی نوشتن تست را آغاز کنند و به مرور، تست‌های پیچیده‌تر بنویسند.\n7.1.2.2 سرعت بالا در اجرا # تست‌های Go به دلیل ساختار ساده و اجرای مستقل، بسیار سریع اجرا می‌شوند. این موضوع در پروژه‌های بزرگ که شامل صدها یا هزاران تست هستند، اهمیت ویژه‌ای دارد. با استفاده از امکانات داخلی مانند -short، -run و -parallel می‌توان تست‌ها را به‌صورت انتخابی، سریع و هم‌زمان اجرا کرد. این ویژگی، بازخورد سریع برای توسعه‌دهنده فراهم می‌کند و مانع از کند شدن چرخه توسعه می‌شود.\n7.1.2.3 پوشش طیف متنوعی از تست‌ها # Go به‌صورت پیش‌فرض از انواع مختلف تست پشتیبانی می‌کند:\nتست واحد unit test تست یکپارچه integration test تست انتها به انتها end-to-end test تست عملکرد benchmark تست فازی fuzz testing بدون نیاز به ابزار خارجی، می‌توان تمامی این انواع تست را در دل پروژه نوشت و اجرا کرد. این تنوع به تیم‌ها کمک می‌کند تا از زوایای مختلف، عملکرد و صحت سیستم را ارزیابی کنند.\n7.1.2.4 پشتیبانی از ابزارهای جانبی و شخص ثالث # در کنار ابزارهای داخلی، اکوسیستم Go شامل کتابخانه‌ها و فریم‌ورک‌های محبوبی برای تست‌نویسی پیشرفته است. کتابخانه‌هایی مانند:\ntestify: برای assertions و mock ginkgo: برای تست‌های ساختاریافته به سبک BDD gomock, moq: برای تولید mock خودکار go-cmp: برای مقایسه دقیق ساختارهای پیچیده این ابزارها امکانات اضافی و قدرتمندی به تست‌نویسی اضافه می‌کنند و در عین حال با ساختار زبان سازگار باقی می‌مانند.\n7.1.2.5 ادغام آسان با CI/CD # از آنجا که اجرای تست در Go از طریق یک دستور ساده انجام می‌شود (go test ./...)، ادغام آن در خط تولید خودکار بسیار ساده است. بیشتر پلتفرم‌های CI مثل GitHub Actions، GitLab CI، CircleCI و TravisCI، بدون نیاز به پیکربندی اضافی، می‌توانند تست‌های Go را اجرا و گزارش کنند. این ویژگی باعث می‌شود که فرهنگ تست‌نویسی در تیم به‌راحتی به یک عادت سازنده تبدیل شود.\n7.1.2.6 پایداری و نگهداری آسان تست‌ها # ساختار تست در Go به‌گونه‌ای است که نگهداری آن در طول زمان ساده و کم‌هزینه است. چون تست‌ها از توابع معمولی تشکیل شده‌اند، به‌راحتی می‌توان آن‌ها را بازنویسی، جدا یا ترکیب کرد. همچنین از آنجا که ابزارهای تست بخشی از هسته زبان هستند، احتمال ناسازگاری نسخه‌ای یا شکستن تست‌ها به دلیل تغییر ابزار بسیار پایین است.\nحتماً، در ادامه نگارش کامل بخش ۷.۱.۳ رویکرد زبان Go به تست‌نویسی با رعایت ساختار مورد نظر، استفاده از کلمات تخصصی به‌صورت tooltip، بدون ارجاع مستقیم به کتاب‌ها و با زبان حرفه‌ای فارسی آورده شده است:\n7.1.3 رویکرد زبان Go به تست‌نویسی # زبان Go از ابتدا با این نگرش طراحی شد که توسعه‌دهنده باید بتواند با ساده‌ترین ابزارها، بیشترین کنترل را روی کیفیت کد داشته باشد. در همین راستا، تست‌نویسی نه‌تنها به عنوان یک ابزار جانبی، بلکه به عنوان بخشی ذاتی از فلسفه زبان گنجانده شده است. رویکرد Go به تست‌نویسی بر پایه‌ی اصولی مانند سادگی، سرعت، قابلیت نگهداری و حداقل وابستگی بنا شده است.\n7.1.3.1 استفاده از ابزارهای رسمی و داخلی # در Go، نیازی به نصب هیچ ابزار اضافی برای تست‌نویسی وجود ندارد. با استفاده از پکیج تستینگ و ابزار گو تست می‌توان تست‌ها را نوشت، اجرا کرد و گزارش گرفت. این ابزارها بخشی از هسته زبان هستند و در کنار دستورات اصلی مانند go build یا go run مورد استفاده قرار می‌گیرند. این یکپارچگی باعث می‌شود تست‌نویسی بخشی کاملاً طبیعی از فرآیند توسعه باشد، نه عملی اختیاری یا پیچیده.\n7.1.3.2 سادگی در تعریف تست‌ها # برخلاف زبان‌هایی که برای نوشتن تست نیاز به استفاده از annotation، ارث‌بری از کلاس‌های خاص یا تعریف ساختارهای پیچیده دارند، در Go یک تست تنها یک تابع معمولی با امضای func TestXxx(t *testing.T) است. این توابع می‌توانند هر منطق دلخواهی را پیاده‌سازی کنند و در صورت مشاهده خطا با فراخوانی t.Errorf() یا t.Fatal() گزارش شکست را صادر نمایند. این رویکرد باعث می‌شود تست‌ها خوانا، مینیمال و قابل فهم برای تمام اعضای تیم باشند.\n7.1.3.3 سبک مینیمال و بدون چارچوب # Go از عمد از اضافه کردن چارچوب‌های تست پیچیده و سیستم‌های assertion سنگین اجتناب کرده است. این تصمیم با هدف حفظ سادگی، شفافیت و کنترل بیشتر توسعه‌دهنده اتخاذ شده است. اگرچه کتابخانه‌های شخص ثالث مانند testify یا ginkgo برای پروژه‌های بزرگ یا تست‌های ساختاریافته‌تر وجود دارند، اما فلسفه Go این است که تست ساده باشد و تا جای ممکن از ابزارهای استاندارد استفاده شود.\n7.1.3.4 پشتیبانی طبیعی از انواع تست # رویکرد Go به تست‌نویسی صرفاً محدود به بررسی صحت نیست. ابزار رسمی go test با فلگ‌هایی مانند -bench, -cover و -fuzz از تست‌های متنوعی پشتیبانی می‌کند، از جمله:\nتست عملکرد benchmark سنجش پوشش کد code coverage تست فازی fuzz testing همه این قابلیت‌ها در ابزارهای داخلی Go گنجانده شده‌اند و برای استفاده از آن‌ها نیازی به نصب افزونه یا وابستگی جدید نیست. این ویژگی Go را از بسیاری از زبان‌ها متمایز می‌کند.\n7.1.3.5 طراحی برای توسعه‌دهنده، نه ابزار # فلسفه طراحی Go این است که توسعه‌دهنده باید به‌جای جنگیدن با ابزارها، مستقیماً روی حل مسئله تمرکز کند. این اصل در تست‌نویسی نیز دیده می‌شود. Go توسعه‌دهنده را تشویق می‌کند به‌جای وابستگی به جادوی فریم‌ورک‌ها، با ابزارهای ساده و قابل درک، منطق تست را به‌صورت شفاف پیاده‌سازی کند. این رویکرد در بلندمدت باعث تسهیل نگهداری پروژه، کاهش پیچیدگی و افزایش اطمینان از صحت سیستم می‌شود.\n7.1.4 اصول و قراردادهای تست در Go # در زبان Go، تست‌نویسی نه‌تنها از نظر ابزار ساده است، بلکه از نظر قراردادها، ساختار پوشه‌ها و نام‌گذاری توابع نیز کاملاً روشن و استاندارد تعریف شده است. این ساختار قراردادی به توسعه‌دهندگان کمک می‌کند تا تست‌ها را به‌راحتی بنویسند، بخوانند، اجرا کنند و در ابزارهای خودکار مانند سی‌آی ادغام نمایند.\n7.1.4.1 ساختار فایل‌های تست # تمام تست‌ها در Go باید در فایل‌هایی با پسوند _test.go قرار بگیرند. این قانون توسط ابزار go test شناسایی می‌شود و فقط این فایل‌ها برای اجرای تست در نظر گرفته می‌شوند. این فایل‌ها معمولاً در کنار فایل‌های اصلی قرار می‌گیرند، مثلاً:\nmath.go math_test.go این ساختار باعث می‌شود تست‌ها به راحتی با کد اصلی مقایسه و توسعه داده شوند، و وابستگی آن‌ها کاملاً واضح باشد.\n7.1.4.2 امضای تابع تست # هر تابع تست باید به شکل زیر تعریف شود:\nfunc TestXxx(t *testing.T) در اینجا Xxx می‌تواند نامی اختیاری و دلخواه باشد، اما باید با حرف بزرگ آغاز شود تا توسط ابزار تست شناسایی شود. آرگومان t از نوع تی تستینگ است و امکاناتی مانند ثبت خطا، توقف تست، یا گزارش وضعیت را فراهم می‌کند.\nبرای مثال:\nfunc TestAdd(t *testing.T) { got := Add(2, 3) if got != 5 { t.Errorf(\u0026quot;expected 5, got %d\u0026quot;, got) } } 7.1.4.3 گروه‌بندی تست‌ها با Subtest # در Go می‌توان تست‌های مرتبط را با استفاده از متد t.Run به‌صورت زیر تست اجرا کرد. این کار باعث دسته‌بندی منطقی تست‌ها و جداسازی گزارش آن‌ها در خروجی می‌شود:\nfunc TestMathOperations(t *testing.T) { t.Run(\u0026quot;Addition\u0026quot;, func(t *testing.T) { // ... }) t.Run(\u0026quot;Multiplication\u0026quot;, func(t *testing.T) { // ... }) } 7.1.4.4 موازی‌سازی تست‌ها # Go به‌صورت بومی از اجرای هم‌زمان تست‌ها پشتیبانی می‌کند. با استفاده از t.Parallel() می‌توان تست‌ها را به‌صورت مستقل و موازی اجرا کرد، به‌ویژه مفید برای تست‌هایی که داده‌ها یا منابع مشترک ندارند:\nfunc TestFastOperation(t *testing.T) { t.Parallel() // اجرای تست } در صورتی که تست‌هایی با منابع مشترک دارید، باید از سینک مانند Mutex یا channel برای کنترل استفاده کنید.\n7.1.4.5 قرارداد نام‌گذاری تست‌ها # تمام تست‌ها باید با Test شروع شوند. تست‌های بنچمارک باید با Benchmark شروع شوند و از *testing.B استفاده کنند. تست‌های فازی باید با Fuzz شروع شوند و از *testing.F استفاده کنند. استفاده از اسم‌های معنادار برای تست‌ها باعث خوانایی بهتر کد و گزارش‌ها می‌شود. مثال‌های معتبر:\nfunc BenchmarkSort(b *testing.B) { ... } func FuzzParseDate(f *testing.F) { ... } 7.1.4.6 تست‌های بدون تست واقعی # گاهی ممکن است نیاز باشد یک تست خالی نوشته شود فقط برای اطمینان از اینکه برنامه کامپایل می‌شود یا فقط هدف خاصی را بررسی کند. در این موارد، می‌توان از t.Skip() استفاده کرد:\nfunc TestStub(t *testing.T) { t.Skip(\u0026quot;implementation pending\u0026quot;) } 7.1.5 مقایسه با زبان‌های دیگر # زبان Go رویکردی ساده، سریع و بی‌واسطه به تست‌نویسی دارد که آن را از بسیاری از زبان‌های رایج توسعه نرم‌افزار متمایز می‌کند. در حالی که برخی زبان‌ها با استفاده از چارچوب‌های سنگین یا ابزارهای جانبی به سراغ تست می‌روند، Go تست را به‌عنوان بخشی از طراحی زبان در نظر گرفته است. در این بخش، نگاهی تطبیقی به روش تست‌نویسی در Go و چند زبان دیگر می‌اندازیم.\n7.1.5.1 مقایسه با Python # در زبان Python، تست‌نویسی اغلب با استفاده از کتابخانه‌هایی مانند unittest, pytest, یا nose انجام می‌شود. اگرچه این ابزارها قدرتمند هستند و ویژگی‌هایی مانند تشخیص خودکار، fixture injection و assert پیشرفته دارند، اما معمولاً نیاز به نصب و پیکربندی اولیه دارند. در مقابل، Go از ابزار داخلی testing استفاده می‌کند که بدون وابستگی و با دستور go test قابل استفاده است.\nویژگی Go Python + pytest ابزار داخلی بله خیر assert پیشرفته خیر (با if) بله سرعت اجرا بسیار بالا معمولی منحنی یادگیری بسیار ساده نسبتاً متوسط 7.1.5.2 مقایسه با Java # در Java، تست‌نویسی معمولاً با استفاده از چارچوب‌هایی مانند JUnit یا TestNG انجام می‌شود. این چارچوب‌ها مبتنی بر annotation و reflection هستند، که در Go وجود ندارد. تعریف یک تست ساده در Java نیازمند کلاس، annotation و ساختار نسبتاً سنگینی است، در حالی که در Go یک تابع ساده کافی است. از طرفی ابزارهای Java برای پروژه‌های پیچیده‌تر امکانات بیشتری دارند، اما این مزیت همراه با پیچیدگی نیز هست.\nویژگی Go Java + JUnit نیاز به annotation خیر بله نوشتار ساده بله خیر یکپارچگی با زبان کامل از طریق چارچوب جداگانه زمان اجرا سریع کندتر 7.1.5.3 مقایسه با JavaScript / TypeScript # در JavaScript یا TypeScript، ابزارهای متنوعی برای تست وجود دارد مانند Jest, Mocha, Chai, Vitest. اگرچه این ابزارها تجربه تست بسیار مدرنی فراهم می‌کنند (مانند snapshot testing و mocking خودکار)، اما پیکربندی آن‌ها در پروژه‌های بزرگ می‌تواند زمان‌بر باشد. از طرف دیگر، وجود اکوسیستم‌های پیچیده باعث می‌شود گاهی فهمیدن منطق تست دشوار شود. Go از این پیچیدگی اجتناب کرده و تجربه‌ای ساده، قابل پیش‌بینی و سریع ارائه می‌دهد.\nویژگی Go JavaScript + Jest نصب ابزار لازم نیست ضروری snapshot testing ندارد بله mocking داخلی ندارد بله خطایابی آسان تست‌ها بله گاهی دشوار 7.1.5.4 مقایسه با Rust # در Rust، تست‌ها معمولاً درون ماژول‌هایی با annotation #[cfg(test)] و ماکروهای #[test] نوشته می‌شوند. مانند Go، تست بخشی از زبان است و اجرای آن با دستور cargo test انجام می‌شود. از این نظر، رویکرد Rust بسیار به Go نزدیک است. با این حال، تعریف ماژول‌ها و ویژگی‌های زبانی Rust ممکن است منحنی یادگیری بالاتری داشته باشد، در حالی که Go از سادگی بیشتری برخوردار است.\nویژگی Go Rust ابزار تست داخلی بله بله تست داخل ماژول اختیاری بله macro و annotation ندارد دارد پیچیدگی یادگیری پایین متوسط به بالا 7.1.5.5 نتیجه‌گیری مقایسه # رویکرد Go به تست‌نویسی کاملاً عمل‌گرا، ساده و بدون وابستگی به ابزارهای جانبی است. این سادگی باعث می‌شود تیم‌های توسعه بتوانند سریع‌تر شروع به نوشتن تست کنند و فرآیند اجرای تست‌ها نیز سبک، سریع و قابل‌اتکا باقی بماند. در حالی که بسیاری از زبان‌ها بر غنای ابزارهای تست تکیه می‌کنند، Go با ارائه یک راهکار ساده اما کارآمد، توسعه‌دهنده را به نوشتن تست تشویق می‌کند بدون اینکه او را از مسیر تولید منحرف کند.\n7.1.6 آزمونگر ایده‌آل گولنگ‌نویس: چرا باید تست بنویسیم؟ # در اکوسیستم Go، تست‌نویسی نه یک مهارت اضافه بلکه بخشی از هویت یک توسعه‌دهنده حرفه‌ای محسوب می‌شود. اگرچه ابزارها و کتابخانه‌ها نوشتن تست را بسیار آسان کرده‌اند، اما نوشتن تست صرفاً به خاطر وجود ابزار انجام نمی‌شود. در واقع، نوشتن تست در Go به دلایل مهم‌تری ضرورت دارد.\n7.1.6.1 تضمین رفتار سیستم # هر خط تست، تضمینی است برای آنکه یک ویژگی مشخص از سیستم در شرایط خاص به درستی عمل می‌کند. وقتی تستی می‌نویسیم، در واقع داریم تعریف می‌کنیم که چه چیزی قابل قبول است و چه چیزی نیست. بدون تست، تغییر دادن یا توسعه کد به یک فعالیت پرریسک تبدیل می‌شود.\n7.1.6.2 مستندسازی زنده # تست‌های خوب، همانند مستندات زنده هستند. آن‌ها نشان می‌دهند که یک تابع یا ماژول در برابر چه ورودی‌هایی چه رفتاری دارد. این نوع مستندسازی برخلاف توضیحات متنی، خود را با تغییرات کد به‌روزرسانی می‌کند و در صورت عدم هماهنگی، با شکست در اجرا هشدار می‌دهد.\n7.1.6.3 کاهش هزینه‌های نگهداری # کد بدون تست، در بلندمدت هزینه‌بر خواهد شد؛ چرا که کوچک‌ترین تغییر در آن نیازمند تحلیل مجدد و اعتماد به حافظه یا شهود توسعه‌دهنده است. در حالی که وجود تست‌های پوششی، هزینه تغییر، اشکال‌زدایی و توسعه‌ی بیشتر را به‌شدت کاهش می‌دهد.\n7.1.6.4 ایجاد فرهنگ توسعه حرفه‌ای # نوشتن تست فقط مهارت نیست، بلکه نشانه‌ی یک طرز فکر است. توسعه‌دهنده‌ای که تست می‌نویسد، به کیفیت، آینده‌پذیری و قابل‌اعتماد بودن سیستم اهمیت می‌دهد. در دنیای Go، این رویکرد از یک توصیه فراتر رفته و به یک عرف تبدیل شده است.\n7.1.7 ابزار go test و نحوه اجرای تست‌ها از خط فرمان # در زبان Go، اجرای تست‌ها از طریق ابزار رسمی go test انجام می‌شود. این ابزار بخشی از زنجیره ابزارهای CLI زبان است و بدون نیاز به نصب هیچ ابزار اضافه‌ای، امکان نوشتن، اجرا و گزارش‌گیری از تست‌ها را فراهم می‌کند. در این بخش به بررسی کامل نحوه استفاده از go test، همراه با فلگ‌ها، گزینه‌ها و حالت‌های مختلف اجرای آن می‌پردازیم.\n7.1.7.1 اجرای ساده تست‌ها # برای اجرای تست‌های موجود در یک بسته (پوشه فعلی)، تنها کافی‌ست در همان مسیر دستور زیر را وارد کنید:\ngo test این دستور تمام فایل‌های _test.go را کامپایل کرده، به صورت خودکار go vet را اجرا می‌کند و سپس تست‌ها را اجرا می‌کند.\nخروجی به‌صورت خلاصه نمایش داده می‌شود:\nok mymodule/mypkg\t0.011s اگر تست‌ها شکست بخورند، خروجی با FAIL نمایش داده می‌شود.\n7.1.7.2 اجرای انتخابی تست‌ها با -run # می‌توان یک یا چند تابع تست خاص را با استفاده از الگوی منظم (regex) و فلگ -run اجرا کرد:\ngo test -run=TestAdd go test -run='Add|Sub' نکته: تابع تست باید دقیقاً با الگوی TestXxx تعریف شده باشد.\n7.1.7.3 تست‌های موازی و مدیریت زمان # برای تنظیم حداکثر تعداد تست‌هایی که می‌توانند هم‌زمان اجرا شوند: go test -parallel=4 برای محدود کردن زمان اجرای هر تست یا کل تست‌ها: go test -timeout=5s در صورت عبور از این زمان، پروسه تست با خطا قطع می‌شود.\n7.1.7.4 سنجش پوشش کد با -cover # برای مشاهده درصد پوشش کد توسط تست‌ها:\ngo test -cover برای تولید فایل پوشش:\ngo test -coverprofile=coverage.out و برای مشاهده پوشش به صورت HTML:\ngo tool cover -html=coverage.out 7.1.7.5 اجرای بنچمارک‌ها با -bench # برای اجرای بنچمارک‌ها از فلگ -bench استفاده می‌شود. برای اجرای همه بنچمارک‌ها:\ngo test -bench=. برای اجرای بنچمارک خاص:\ngo test -bench=BenchmarkSort با فلگ -benchmem می‌توان اطلاعات حافظه مصرفی را نیز دریافت کرد:\ngo test -bench=. -benchmem 7.1.7.6 تست‌های فازی با -fuzz # برای اجرای تست فازی:\ngo test -fuzz=FuzzParse برای محدود کردن زمان اجرای فاز فازی:\ngo test -fuzz=FuzzParse -fuzztime=20s در صورت یافتن نمونه‌ای که باعث شکست تست شود، داده تولیدشده ذخیره می‌شود و در اجرای بعدی بررسی خواهد شد.\n7.1.7.7 ترکیب‌های رایج در پروژه‌های واقعی # در بسیاری از پروژه‌ها از ترکیب چند فلگ استفاده می‌شود. مثال‌هایی از ترکیب‌های رایج:\ngo test -v ./... # اجرای کامل تست‌ها به‌صورت verbose go test -run=TestHandler -cover ./handlers # تست handler خاص با پوشش کد go test -bench=BenchmarkEncode -benchmem # اجرای بنچمارک به همراه مصرف حافظه go test -fuzz=FuzzMyFunc -fuzztime=1m # اجرای تست فازی به مدت یک دقیقه go test -count=1 # غیرفعال‌سازی cache 7.1.7.8 حالت‌های اجرای go test # go test در دو حالت مختلف اجرا می‌شود:\nLocal Directory Mode: بدون آرگومان بسته اجرا می‌شود و فقط پوشه فعلی را تست می‌کند: go test Package List Mode: با مشخص‌کردن مسیر یا پکیج اجرا می‌شود: go test ./... go test mymodule/utils در حالت دوم، سیستم کَش تست فعال می‌شود و تست‌های قبلاً موفق اجرا نشده و نتیجه cache نمایش داده می‌شود (با برچسب (cached)).\n7.1.7.9 بررسی race condition با فلگ -race # در برنامه‌های همزمان، احتمال بروز شرایط مسابقه وجود دارد؛ یعنی دو یا چند goroutine به‌صورت ناهمزمان به یک متغیر مشترک دسترسی پیدا کنند و حداقل یکی از آن‌ها آن را تغییر دهد. این نوع باگ‌ها بسیار خطرناک هستند، زیرا در زمان اجرا قابل پیش‌بینی نیستند و معمولاً فقط در برخی شرایط خاص خود را نشان می‌دهند.\nبرای شناسایی چنین مشکلاتی در Go، می‌توان از فلگ -race هنگام اجرای تست‌ها استفاده کرد. این فلگ باعث می‌شود کامپایلر، برنامه را به‌گونه‌ای کامپایل کند که دسترسی به حافظه در زمان اجرا بررسی شود.\nنحوه استفاده: # go test -race یا برای اجرای تست‌های یک پکیج خاص:\ngo test -race ./pkg/concurrent در صورت وجود race، خروجی‌ای مشابه زیر نمایش داده می‌شود:\n================== WARNING: DATA RACE Read at 0x00c0000b2000 by goroutine 6: main.main.func1() Previous write at 0x00c0000b2000 by goroutine 5: main.main.func2() ================== نکات مهم: # استفاده از -race باعث کند شدن اجرای تست‌ها (معمولاً 2 تا 5 برابر) و مصرف بیشتر حافظه می‌شود. توصیه می‌شود در فرآیند CI، حداقل یک‌بار در روز یا قبل از انتشار نسخه جدید با -race تست کامل انجام شود. تشخیص race توسط این ابزار معمولاً دقیق است، اما به صورت صددرصد تضمینی نیست. "},{"id":98,"href":"/chapter-7/go-unit-testing/","title":"7.2 تست واحد (Unit Test)","section":"فصل هفتم: تست نویسی","content":"تست واحد یکی از مهم‌ترین و بنیادی‌ترین ابزارهایی‌ست که یک توسعه‌دهنده حرفه‌ای در اختیار دارد. این نوع تست، تنها بر یک «واحد» مستقل از منطق برنامه تمرکز می‌کند—معمولاً یک تابع، یک متد، یا یک ساختار کوچک از کد که بدون وابستگی به منابع خارجی قابل بررسی است. هدف اصلی از نوشتن تست واحد، اطمینان از صحت رفتار دقیق و قابل پیش‌بینی کد در مواجهه با ورودی‌های مشخص و شرایط کنترل‌شده است.\nدر زبان Go، فلسفه طراحی بر سادگی، سرعت و ابزارهای داخلی استوار است؛ این رویکرد به‌وضوح در ساختار تست‌نویسی نیز دیده می‌شود. بدون نیاز به هیچ‌گونه چارچوب یا ابزار جانبی، می‌توان تنها با استفاده از فایل‌های _test.go و توابع TestXxx(t *testing.T) تست‌های کاملی برای هر ماژول نوشت. این تست‌ها به‌صورت یکپارچه با ابزار رسمی go test اجرا می‌شوند و خروجی‌ای دقیق، سریع و قابل‌درک ارائه می‌دهند.\nویژگی‌هایی مانند اجرای تست‌های جداگانه با -run، دسته‌بندی تست‌ها با t.Run، پوشش کد با -cover، تست‌های موازی با t.Parallel() و پشتیبانی کامل از ساختارهای ساده Go، باعث شده‌اند که تست واحد نه فقط یک ابزار، بلکه یک عادت طبیعی در سبک توسعه Go محسوب شود. در عمل، یونیت تست‌ها نه‌تنها در کشف باگ‌ها مؤثرند، بلکه مرجعی قابل‌اطمینان برای تعریف رفتار و مستندسازی سیستم نیز به‌شمار می‌آیند.\nدر ادامه این بخش، ابتدا به ساختار پایه تست واحد در Go می‌پردازیم، سپس الگوهای رایج، ضدالگوها، نکات پیشرفته و مثال‌هایی از دنیای واقعی را بررسی خواهیم کرد.\nبه نقل از ویکی پدیا آزمون واحد (به انگلیسی: unit testing) در برنامه‌نویسی رایانه‌ای، نوعی آزمون نرم‌افزار است که در آن «واحدهای منفرد کد منبع» مورد آزمون قرار می‌گیرند تا تعیین شود که آیا برای استفاده سازگار هستند یا نه. در اینجا «واحد منفرد کد منبع» یعنی مجموعه‌ای از یک یا بیشتر پودمان برنامه رایانه‌ای، همراه با داده کنترلی مرتبط، رویه استفاده، و رویه عملیاتی.[۱]\nآزمون‌های واحد معمولاً آزمون‌هایی خودکار هستند که توسط توسعه‌دهنده نرم‌افزار نوشته و اجرا می‌شوند، این آزمون برای آن انجام می‌شود تا اطمینان حاصل شود که بخشی از یک برنامه‌کاربردی (که «واحد» نام دارد) طراحی را برآورده کرده‌است و رفتارش هم براساس انتظار است.[۲]\n7.2.1 اصول نوشتن تست‌های واحد در Go و ساختار آن‌ها # نوشتن تست‌های واحد در زبان Go ساده، شفاف و کاملاً منطبق با فلسفه‌ی طراحی زبان است: حداقل پیچیدگی، حداکثر خوانایی و وابستگی صفر به چارچوب‌های جانبی. در Go، تست‌های واحد در فایل‌هایی با پسوند _test.go تعریف می‌شوند و باید در همان پکیجی باشند که کد اصلی قرار دارد یا در پکیجی مجزا با پسوند _test برای جدا‌سازی وابستگی‌ها.\nهر تست واحد باید با تابعی به فرم زیر آغاز شود:\nfunc TestXxx(t *testing.T) که در آن Xxx می‌تواند هر نام معناداری باشد که با حرف بزرگ آغاز شده است (برای شناسایی توسط ابزار go test) و پارامتر t از نوع تی بوده و برای مدیریت وضعیت تست به‌کار می‌رود.\n7.2.1.1 ساختار پایه تست واحد # package main import ( \"fmt\" \"testing\" ) func Add(a, b int) int { return a + b } func TestAdd(t *testing.T) { got := Add(2, 3) want := 5 if got != want { t.Errorf(\"Add(2,3) = %d; want %d\", got, want) } } ▶ اجرای کد کپی ✖ بستن خروجی در این مثال ساده:\nتابع Add بررسی می‌شود. نتیجه با مقدار مورد انتظار مقایسه شده. در صورت مغایرت، پیامی با t.Errorf ثبت می‌شود که باعث شکست تست می‌گردد. 7.2.1.2 نقش تابع t.Fail, t.Error, و t.Fatal # در تست‌های Go چندین روش برای ثبت خطا وجود دارد:\nتابع توضیح t.Error ثبت خطا و ادامه اجرای تست t.Errorf مانند t.Error اما با فرمت‌دهی رشته t.Fail فقط ثبت خطا بدون پیام t.Fatal ثبت خطا و توقف فوری اجرای تابع تست t.Fatalf مانند t.Fatal با امکان فرمت‌دهی نمونه:\nif err != nil { t.Fatalf(\u0026quot;unexpected error: %v\u0026quot;, err) } 7.2.1.3 الزامات ابزار go test # برای اینکه go test تست‌ها را شناسایی و اجرا کند:\nتابع تست باید با Test شروع شود. آرگومان آن باید دقیقاً t *testing.T باشد. نباید مقدار برگشتی داشته باشد. فایل باید پسوند _test.go داشته باشد. 7.2.1.4 نحوه سازمان‌دهی فایل‌ها و پوشه‌ها # در Go، تست‌ها معمولاً در کنار کد اصلی قرار می‌گیرند:\ncalculator/ ├── add.go └── add_test.go اما برای تست رفتار خارجی بدون دسترسی به توابع یا متغیرهای داخلی، می‌توان از پکیج mypkg_test استفاده کرد که نسخه‌ای مجزا از پکیج اصلی بدون دسترسی داخلی است:\npackage mypkg_test این روش برای نوشتن تست‌های سطح بالاتر یا رفتار مصرف‌کننده بسیار مناسب است.\n7.2.1.5 اجرای تست # اجرای ساده:\ngo test اجرای یک تابع خاص:\ngo test -run=TestAdd اجرا با جزئیات بیشتر (verbose):\ngo test -v 7.2.1.6 چرا این ساختار موفق است؟ # دلایل موفقیت رویکرد Go در تست‌های واحد:\nخوانایی بالا: هر تست به‌راحتی قابل درک و تحلیل است. حداقل boilerplate: بدون نیاز به setup یا framework. اجرای سریع: تست‌ها بلافاصله اجرا می‌شوند. پشتیبانی بومی ابزارها: بدون وابستگی خارجی. 7.2.2 روش‌های مدیریت خطا در تست‌ها # در تست‌های واحد، بررسی رفتار توابع در مواجهه با خطا یکی از حیاتی‌ترین جنبه‌هاست. بسیاری از توابع در Go به‌جای پرتاب استثنا، مقادیر error بازمی‌گردانند، بنابراین انتظار بروز خطا یا نبود خطا بخشی مهم از منطق تست است. تستی که فقط مقدار بازگشتی موفق را بررسی کند، ناقص است. یک تست کامل باید حالت‌های failure را نیز پوشش دهد.\n7.2.2.1 بررسی خطاهای مورد انتظار # در بسیاری از مواقع، یک تابع در شرایط خاص باید خطا بازگرداند. تست صحیح باید این خطا را بررسی کرده و اطمینان حاصل کند که نوع خطا، پیام و زمان وقوع آن دقیقاً مطابق انتظار است.\npackage main import ( \"fmt\" \"testing\" ) func Divide(a, b int) (int, error) { if b == 0 { return 0, fmt.Errorf(\"cannot divide by zero\") } return a / b, nil } func TestDivideByZero(t *testing.T) { _, err := Divide(10, 0) if err == nil { t.Fatal(\"expected error, got nil\") } if err.Error() != \"cannot divide by zero\" { t.Errorf(\"unexpected error message: %v\", err) } } ▶ اجرای کد کپی ✖ بستن خروجی 7.2.2.2 تست موفقیت در غیاب خطا # در طرف دیگر، باید اطمینان حاصل کنیم که در شرایط صحیح، تابع بدون خطا عمل می‌کند:\npackage main import ( \"fmt\" \"testing\" ) func Divide(a, b int) (int, error) { if b == 0 { return 0, fmt.Errorf(\"cannot divide by zero\") } return a / b, nil } func TestDivideSuccess(t *testing.T) { res, err := Divide(10, 2) if err != nil { t.Fatalf(\"unexpected error: %v\", err) } if res != 5 { t.Errorf(\"expected 5, got %d\", res) } } ▶ اجرای کد کپی ✖ بستن خروجی 7.2.2.3 استفاده از errors.Is و errors.As # در شرایط حرفه‌ای، به‌جای بررسی پیام خطا، بهتر است از توابع استاندارد کتابخانه errors برای بررسی نوع خطا استفاده شود، خصوصاً زمانی که خطاها wrap می‌شوند.\npackage main import ( \"fmt\" \"testing\" ) var ErrDivideByZero = errors.New(\"cannot divide by zero\") func Divide(a, b int) (int, error) { if b == 0 { return 0, fmt.Errorf(\"wrap: %w\", ErrDivideByZero) } return a / b, nil } func TestDivideByZeroTypedError(t *testing.T) { _, err := Divide(1, 0) if !errors.Is(err, ErrDivideByZero) { t.Errorf(\"expected ErrDivideByZero, got %v\", err) } } ▶ اجرای کد کپی ✖ بستن خروجی 7.2.2.4 پوشش تمامی مسیرهای منطقی # هر تابعی که دارای چند مسیر شرطی است، باید در تست‌های واحد به‌صورت جداگانه در تمامی مسیرها آزمایش شود. عدم پوشش یکی از مسیرها می‌تواند منجر به بروز باگ‌های پنهان در آینده شود.\nبرای مثال، تابع زیر دو مسیر دارد:\npackage main import ( \"fmt\" \"testing\" ) func Authenticate(token string) error { if token == \"\" { return errors.New(\"token required\") } return nil } func TestAuthenticate(t *testing.T) { tests := []struct { name string input string wantErr bool }{ {\"valid token\", \"abc123\", false}, {\"empty token\", \"\", true}, } for _, tt := range tests { t.Run(tt.name, func(t *testing.T) { err := Authenticate(tt.input) if (err != nil) != tt.wantErr { t.Errorf(\"unexpected error result. got error=%v\", err) } }) } } ▶ اجرای کد کپی ✖ بستن خروجی این تکنیک با نام تست جدول‌محور شناخته می‌شود و در بخش بعدی به‌صورت مفصل بررسی خواهد شد.\n7.2.3 تست توابع غیرصادرشده (Unexported) و کاربرد پکیج _test # در Go، توابع یا انواعی که با حرف کوچک آغاز می‌شوند، تنها در محدوده همان پکیج قابل مشاهده هستند. این ویژگی در راستای اصل کپسوله‌سازی طراحی شده است. اما گاهی لازم است این توابع غیرصادرشده را نیز مورد تست قرار دهیم. برای این کار، چند رویکرد رایج وجود دارد که هرکدام بسته به هدف تست قابل انتخاب هستند.\n7.2.3.1 نوشتن تست در همان پکیج # در ساده‌ترین حالت، فایل تست را در همان پکیجی می‌نویسیم که کد اصلی قرار دارد. این روش به تست دسترسی کامل به توابع، متغیرها و انواع داخلی را می‌دهد.\npackage main import ( \"fmt\" \"testing\" ) func subtract(a, b int) int { return a - b } func TestSubtract(t *testing.T) { if subtract(5, 3) != 2 { t.Errorf(\"expected 2, got %d\", subtract(5, 3)) } } ▶ اجرای کد کپی ✖ بستن خروجی این روش توصیه‌شده و رسمی‌ترین راه برای تست موارد غیرصادرشده است.\n7.2.3.2 استفاده از پکیج تست جداگانه (_test) # اگر بخواهیم تست‌ها کاملاً از رفتار داخلی جدا باشند و فقط از رابط عمومی (public API) استفاده کنند، می‌توانیم از یک پکیج با پسوند _test استفاده کنیم. این روش برای نوشتن تست‌های سطح بالاتر یا رفتاری مناسب است.\n// file: api_test.go package math_test import ( \u0026quot;testing\u0026quot; \u0026quot;mymodule/math\u0026quot; ) func TestAddPublic(t *testing.T) { got := math.Add(1, 2) if got != 3 { t.Errorf(\u0026quot;expected 3, got %d\u0026quot;, got) } } در این حالت:\nتوابع داخلی (مثل subtract) دیگر قابل دسترسی نیستند. تنها توابع صادرشده در دسترس هستند. این یک تست \u0026ldquo;از بیرون\u0026rdquo; یا \u0026ldquo;black-box\u0026rdquo; محسوب می‌شود. 7.2.3.3 تست غیرمستقیم توابع داخلی # اگر تابع غیرصادرشده به‌صورت مستقیم قابل تست نیست ولی از طریق توابع صادرشده فراخوانی می‌شود، بهترین راه تست آن به‌صورت غیرمستقیم و از طریق خروجی تابع صادرشده است. به این ترتیب، تست به ساختار داخلی وابسته نخواهد بود.\nمزیت این روش:\nتست پایدارتر باقی می‌ماند. وابستگی به جزییات پیاده‌سازی کاهش می‌یابد. 7.2.3.4 مزایا و معایب هر رویکرد # روش مزایا معایب پکیج داخلی (package x) دسترسی کامل به کد وابستگی مستقیم به پیاده‌سازی پکیج _test تست رفتاری و بدون وابستگی به داخل عدم امکان تست مستقیم کد داخلی تست غیرمستقیم افزایش انعطاف تست و پایداری طولانی‌مدت پوشش دقیق همه مسیرها ممکن نیست 7.2.3.5 نکات تجربی # تست توابع داخلی اگر رفتار پیچیده‌ای دارند، ضروری است. اگر یک تابع داخلی توسط تابع صادرشده‌ای فراخوانی نمی‌شود، بهتر است به صورت مستقل در همان پکیج تست شود. از پکیج _test در تست‌های انتهایی یا برای نوشتن سناریوهای بلندمدت استفاده کنید. 7.2.4 نکات کاربردی و اشتباهات رایج در تست‌های واحد # یونیت تست‌نویسی در Go به دلیل سادگی و سرعت بالا، بسیار محبوب است؛ اما همین سادگی ممکن است باعث شود برخی نکات ظریف، اما مهم، نادیده گرفته شوند. در این بخش، مجموعه‌ای از توصیه‌های عملی و اشتباهات رایج در یونیت تست‌ها را مرور می‌کنیم که رعایت آن‌ها منجر به تست‌هایی دقیق‌تر، پایدارتر و قابل نگهداری‌تر خواهد شد.\n7.2.4.1 تفاوت بین t.Error و t.Fatal را بشناسید # یکی از اشتباهات رایج، استفاده اشتباه از t.Fatal به‌جای t.Error یا بالعکس است.\nاز t.Error زمانی استفاده کنید که می‌خواهید خطا را ثبت کنید ولی اجازه دهید تست ادامه پیدا کند. از t.Fatal زمانی استفاده کنید که ادامه‌ی تست بی‌معنا است و باید بلافاصله متوقف شود. مثال:\nif err != nil { t.Fatal(\u0026quot;cannot continue test, error:\u0026quot;, err) } if result != expected { t.Error(\u0026quot;wrong result, got\u0026quot;, result) } اگر با یک خطای بحرانی مثل failure در ورودی مواجه شدید، Fatal مناسب‌تر است.\n7.2.4.2 از time.Sleep در یونیت تست استفاده نکنید # استفاده از time.Sleep برای منتظر ماندن در تست باعث ایجاد تست‌های ناپایدار و کند می‌شود. به‌جای آن، از تکنیک‌های مبتنی بر کانال یا تکرارهای سریع (retry) استفاده کنید.\n❌ بد:\ntime.Sleep(100 * time.Millisecond) ✅ بهتر:\nfor i := 0; i \u0026lt; 100; i++ { if ready() { break } time.Sleep(1 * time.Millisecond) } 7.2.4.3 تست‌های وابسته به زمان را کنترل کنید # تست‌هایی که از time.Now() یا time.Since() استفاده می‌کنند باید طوری طراحی شوند که قابل پیش‌بینی باقی بمانند. راهکار:\nتزریق زمان (dependency injection) استفاده از clock mock 7.2.4.4 از t.TempDir() برای ساخت فایل‌ موقت استفاده کنید # اگر تست نیاز به فایل یا پوشه موقتی دارد، به‌جای نوشتن مسیر دستی از t.TempDir() استفاده کنید:\nfunc TestWriteFile(t *testing.T) { dir := t.TempDir() path := filepath.Join(dir, \u0026quot;file.txt\u0026quot;) _ = os.WriteFile(path, []byte(\u0026quot;data\u0026quot;), 0644) // فایل بعد از تست به‌صورت خودکار پاک می‌شود } 7.2.4.5 مراقب caching ناخواسته باشید # هنگام اجرای مکرر تست‌ها، اگر خروجی تست‌ها در حال تغییر باشد، ممکن است به دلیل کش شدن نتیجه، نتیجه قبلی دوباره نمایش داده شود. برای جلوگیری:\ngo test -count=1 یا پاک‌سازی کامل کش:\ngo clean -testcache 7.2.4.6 تست نباید فقط تابع را صدا بزند # یونیت تست‌هایی که تنها تابع را اجرا می‌کنند ولی هیچ بررسی‌ای انجام نمی‌دهند، بی‌فایده‌اند.\n❌ بد:\nfunc TestNoCheck(t *testing.T) { DoSomething() } ✅ درست:\nfunc TestDoSomething(t *testing.T) { result := DoSomething() if result != expected { t.Errorf(\u0026quot;expected %v, got %v\u0026quot;, expected, result) } } 7.2.4.7 گزارش‌دهی دقیق بنویسید # در هنگام ثبت خطا با t.Errorf یا t.Fatalf، حتماً اطلاعات کامل بدهید:\nt.Errorf(\u0026quot;expected %d, got %d\u0026quot;, want, got) این کار در زمان تحلیل خروجی تست‌ها بسیار مفید است.\n7.2.4.8 نام‌گذاری مناسب تست‌ها # نام تست باید گویای هدف تست باشد:\nfunc TestDivideByZeroReturnsError(t *testing.T) { ... } func TestAddPositiveNumbers(t *testing.T) { ... } از نام‌هایی مثل Test1, TestA, TestXYZ اجتناب کنید.\n7.2.5 تست واحد برای ساختارها و متدهای گیرنده # در زبان Go، بسیاری از قابلیت‌های سطح بالا از طریق متدهایی روی ساختارها (structs) پیاده‌سازی می‌شوند. این متدها بسته به نوع گیرنده‌شان (value receiver یا pointer receiver) و میزان وابستگی‌شان به وضعیت داخلی ساختار، نیاز به طراحی تست دقیق‌تری دارند.\nدر این بخش، بررسی می‌کنیم که چگونه می‌توان به صورت مؤثر برای متدهای متصل به ساختارها تست واحد نوشت.\n7.2.5.1 تست متدهای گیرنده مقداری (value receiver) # اگر متدی گیرنده مقداری دارد، معمولاً روی یک نسخه‌ی کپی‌شده از ساختار عمل می‌کند و تغییری در وضعیت اصلی ایجاد نمی‌کند. تست چنین متدهایی بسیار ساده است.\nمثال:\ntype Point struct { X, Y int } func (p Point) IsOrigin() bool { return p.X == 0 \u0026amp;\u0026amp; p.Y == 0 } تست:\nfunc TestPoint_IsOrigin(t *testing.T) { p := Point{X: 0, Y: 0} if !p.IsOrigin() { t.Error(\u0026quot;expected true, got false\u0026quot;) } } 7.2.5.2 تست متدهای گیرنده اشاره‌گری (pointer receiver) # اگر متد وضعیت داخلی ساختار را تغییر می‌دهد یا به صورت اشاره‌گری تعریف شده، در تست باید دقت بیشتری کرد.\nمثال:\nfunc (p *Point) Move(dx, dy int) { p.X += dx p.Y += dy } تست:\nfunc TestPoint_Move(t *testing.T) { p := \u0026amp;Point{X: 1, Y: 2} p.Move(3, 4) if p.X != 4 || p.Y != 6 { t.Errorf(\u0026quot;expected (4,6), got (%d,%d)\u0026quot;, p.X, p.Y) } } توجه: حتماً باید از اشاره‌گر (\u0026amp;Point{...}) استفاده شود، چون متد روی pointer تعریف شده است.\n7.2.5.3 تست چند متد روی یک نمونه # اگر چند متد متوالی روی یک نمونه اعمال می‌شود (تغییر وضعیت گام‌به‌گام)، بهتر است تست در قالب subtest یا جدول تست طراحی شود تا خوانایی حفظ شود.\nfunc TestPoint_Sequence(t *testing.T) { p := \u0026amp;Point{} t.Run(\u0026quot;Move\u0026quot;, func(t *testing.T) { p.Move(2, 2) }) t.Run(\u0026quot;Check\u0026quot;, func(t *testing.T) { if p.X != 2 || p.Y != 2 { t.Errorf(\u0026quot;expected (2,2), got (%d,%d)\u0026quot;, p.X, p.Y) } }) } 7.2.5.4 جداسازی لایه logic از state # در پروژه‌های واقعی، اگر متد ساختار منطق پیچیده دارد، توصیه می‌شود محاسبات را از وضعیت جدا کرده و در توابع مستقل pure قرار دهید تا تست‌پذیرتر شود.\nمثال بهینه‌شده:\nfunc calculateNewPosition(x, y, dx, dy int) (int, int) { return x + dx, y + dy } این تابع را می‌توان به راحتی در یونیت تست مستقل بررسی کرد، بدون نیاز به ساختار.\n7.2.5.5 رفتار پیش‌فرض در مقادیر تهی (zero value) # در Go، مقدار پیش‌فرض (zero value) برای structها معتبر است و معمولاً باید بتوان از آن استفاده کرد. تست این رفتار برای ساختارهایی که متد دارند مهم است.\nfunc TestZeroValueBehavior(t *testing.T) { var p Point if !p.IsOrigin() { t.Error(\u0026quot;expected origin from zero value\u0026quot;) } } 7.2.5.6 ترکیب متد و خطا # در صورتی که متدی روی struct خطا بازمی‌گرداند، حتماً باید شرایط موفق/ناموفق را تست کنید:\npackage main import ( \"fmt\" \"testing\" ) type User struct { Email string } func (u *User) Validate() error { if u.Email == \"\" { return errors.New(\"email required\") } return nil } func TestUser_Validate(t *testing.T) { tests := []struct { email string wantErr bool }{ {\"\", true}, {\"hello@example.com\", false}, } for _, tt := range tests { u := \u0026User{Email: tt.email} err := u.Validate() if (err != nil) != tt.wantErr { t.Errorf(\"unexpected error state for email %q\", tt.email) } } } ▶ اجرای کد کپی ✖ بستن خروجی 7.2.6 تفکیک تست‌های سریع و آهسته با -short # در پروژه‌های واقعی، برخی تست‌ها بسیار سریع هستند و بلافاصله اجرا می‌شوند، اما برخی دیگر—به‌دلایل مختلفی مانند تعامل با فایل، شبکه، زمان‌سنجی، یا دیتابیس—کندتر هستند و ممکن است زمان‌بر یا شکننده (flaky) باشند. ابزار go test راهکاری ساده برای تفکیک این دو نوع تست فراهم کرده است: استفاده از فلگ -short.\nهنگامی که دستور زیر اجرا می‌شود:\ngo test -short آرگومان -short به تمامی توابع تست به‌صورت خودکار ارسال می‌شود. سپس داخل کد می‌توان با استفاده از متد testing.Short() بررسی کرد که آیا این تست باید اجرا شود یا رد شود.\n7.2.6.1 مثال کاربردی # func TestSlowOperation(t *testing.T) { if testing.Short() { t.Skip(\u0026quot;skipping slow test in short mode\u0026quot;) } time.Sleep(5 * time.Second) // تست کند t.Log(\u0026quot;test completed\u0026quot;) } در اجرای معمولی:\ngo test تست اجرا می‌شود. اما در حالت short:\ngo test -short خروجی:\n--- SKIP: TestSlowOperation (0.00s) slow_test.go:4: skipping slow test in short mode PASS 7.2.6.2 مزایا # اجرای سریع‌تر تست‌ها در حالت پیش‌فرض مناسب برای CI pipelines سبک یا اجراهای local حذف تست‌هایی که به منابع خارجی یا شرایط خاص نیاز دارند 7.2.6.3 نکته مهم # بهتر است تست‌های کند را با شرط testing.Short() کنترل کنید نه اینکه به‌طور کلی حذف‌شان کنید یا در فایل جداگانه بگذارید. این کار نگهداری و اجرای تست‌ها را انعطاف‌پذیرتر می‌کند.\n7.2.6.4 ترکیب با ابزارهای دیگر # در سیستم‌های CI/CD، می‌توان دو مرحله اجرای تست داشت:\ngo test -short ./... # فقط تست‌های سریع go test ./... # همه تست‌ها (مثلاً فقط در زمان انتشار نسخه) "},{"id":99,"href":"/chapter-7/go-table-driven-tests/","title":"7.3 تست جدول‌محور (Table-Driven Test)","section":"فصل هفتم: تست نویسی","content":"در زبان Go، یکی از الگوهای محبوب و بسیار قدرتمند برای نوشتن تست‌های واحد و رفتاری، الگوی «تست جدول‌محور» است. این سبک از تست‌نویسی نه‌تنها منجر به حذف تکرارهای زائد در کد تست می‌شود، بلکه ساختاری منسجم برای تعریف سناریوهای مختلف تست، به همراه ورودی و خروجی‌های مورد انتظار، فراهم می‌سازد.\nدر این الگو، مجموعه‌ای از تست‌ها به‌صورت یک جدول از structها تعریف می‌شود که شامل نام تست، ورودی‌ها، خروجی مورد انتظار، و گاهی انتظار وقوع خطا است. سپس با استفاده از یک حلقه و تابع t.Run، هر ردیف از جدول به‌صورت یک تست مستقل (subtest) اجرا می‌شود. این طراحی باعث می‌شود اضافه‌کردن یک تست جدید، تنها با افزودن یک struct به جدول امکان‌پذیر باشد—بدون نیاز به کپی‌کردن منطق کلی تست.\nاین نوع تست‌نویسی به‌طور ویژه برای پوشش کامل مسیرهای مختلف در توابعی با منطق شرطی یا چند حالت ورودی مناسب است. همچنین، به‌کارگیری آن در کنار subtestها موجب می‌شود گزارش شکست‌ها دقیق‌تر، ساخت‌یافته‌تر و خواناتر باشد. در پروژه‌های مقیاس‌پذیر، این سبک نه‌تنها خوانایی تست‌ها را حفظ می‌کند، بلکه روند توسعه و نگهداری آن‌ها را نیز تسهیل می‌کند.\nدر ادامه‌ی این بخش، ابتدا ساختار استاندارد یک تست جدول‌محور را معرفی می‌کنیم، سپس به بررسی تکنیک‌های پیشرفته، اشتباهات رایج، اجرای موازی تست‌ها، طراحی تست‌های نگهدارنده‌ی خطا، و الگوهای پیشنهادی برای پروژه‌های واقعی می‌پردازیم.\n7.3.1 ساختار پایه تست جدول‌محور و مثال ساده # الگوی تست‌های جدول‌محور در Go یکی از کاربردی‌ترین الگوهای تست‌نویسی است که توسط بسیاری از توسعه‌دهندگان و در پروژه‌های رسمی Go نیز به کار می‌رود. این سبک از تست‌نویسی، بر پایه‌ی تعریف یک جدول از سناریوهای تست و اجرای آن‌ها در یک حلقه‌ی ساده بنا شده است. هدف، کاهش تکرار در کد تست، افزایش خوانایی و ساده‌سازی افزودن موارد تست جدید است.\nدر این الگو، هر ردیف جدول معمولاً یک struct است که شامل فیلدهایی مانند نام تست، ورودی‌ها، خروجی مورد انتظار، و گاهی هم انتظار وقوع خطاست. ساختار کلی آن شبیه به کد زیر است:\nfunc TestAdd(t *testing.T) { tests := []struct { name string a, b int expected int }{ {\u0026quot;positive numbers\u0026quot;, 2, 3, 5}, {\u0026quot;negative numbers\u0026quot;, -1, -2, -3}, {\u0026quot;mixed signs\u0026quot;, -1, 2, 1}, } for _, tt := range tests { t.Run(tt.name, func(t *testing.T) { got := Add(tt.a, tt.b) if got != tt.expected { t.Errorf(\u0026quot;expected %d, got %d\u0026quot;, tt.expected, got) } }) } } در این مثال:\nبا استفاده از t.Run برای هر تست یک subtest تعریف شده است. پیام‌های شکست تست شامل tt.name هستند که گزارش خطا را واضح‌تر و دقیق‌تر می‌کنند. اضافه‌کردن یک سناریوی تست جدید بسیار ساده است: فقط کافی‌ست یک struct دیگر به tests اضافه کنید. این سبک به‌عنوان راه‌حل رسمی جامعه‌ی Go برای تست‌های با مسیرهای متنوع در توابع معرفی شده است.\n7.3.1.1 مزایای اصلی این الگو # مزایای اصلی این الگو عبارت‌اند از:\nکاهش قابل‌توجه تکرار کد (DRY) ساده‌سازی تحلیل و نگهداری تست‌ها قابلیت اجرای موازی آسان با t.Parallel() مناسب برای پوشش مسیرهای شرطی و edge cases امکان افزودن متغیرهای اضافی مثل wantErr, errorMessage, expectedStatusCode 7.3.1.2 جایگزینی حلقه ساده با map برای بهبود خوانایی # در مثال قبل از یک slice از struct استفاده شد. اما می‌توان از map[string]testCase] هم استفاده کرد تا به‌طور مستقیم نام تست را به‌عنوان کلید بیاوریم و خوانایی را افزایش دهیم:\nfunc TestMultiply(t *testing.T) { tests := map[string]struct { a, b int expected int }{ \u0026quot;zero\u0026quot;: {0, 5, 0}, \u0026quot;positive\u0026quot;: {2, 3, 6}, \u0026quot;negative\u0026quot;: {-2, 4, -8}, \u0026quot;mixed signs\u0026quot;: {-3, -2, 6}, } for name, tt := range tests { tt := tt t.Run(name, func(t *testing.T) { got := Multiply(tt.a, tt.b) if got != tt.expected { t.Errorf(\u0026quot;expected %d, got %d\u0026quot;, tt.expected, got) } }) } } نکته مهم در این مثال این است که حتماً باید از کپی tt := tt در ابتدای هر subtest استفاده کنیم، تا از مشکل closure جلوگیری شود.\n7.3.1.3 مقایسه با تست‌های کلاسیک # در تست‌های کلاسیک، ممکن است سه یا چهار تابع تست مختلف برای یک تابع ساده نوشته شود، که هم خوانایی را پایین می‌آورد و هم نگهداری را سخت می‌کند. با Table Test، می‌توان همه این تست‌ها را در یک حلقه با ساختار مشترک نگه داشت.\n7.3.1.4 زمانی که Table Test مناسب نیست # گرچه این الگو بسیار مفید است، اما همیشه انتخاب درست نیست. طبق منابع:\nاگر تست فقط یک حالت دارد، استفاده از جدول ممکن است کد را بی‌جهت پیچیده کند. در برخی تست‌های سطح بالا یا تست‌های تعامل‌محور (مثل تست UI یا سرویس‌های REST)، بهتر است تست‌ها به‌صورت مستقل و سناریو محور نوشته شوند، نه جدول‌محور. 7.3.2 تست خطا و ورودی‌های نادرست در Table Tests # یکی از مهم‌ترین مزایای تست‌های جدول‌محور این است که می‌توان به‌راحتی سناریوهای مثبت و منفی را در کنار هم پوشش داد. به‌ویژه زمانی که توابع شما ممکن است خطا بازگردانند یا در برابر ورودی‌های ناسالم رفتاری خاص نشان دهند، این سبک از تست‌نویسی به شکل چشمگیری ساخت‌یافته و مؤثر خواهد بود.\nدر طراحی جدول تست، معمولاً از فیلدی به‌نام wantErr یا expectErr برای تعیین انتظار بروز خطا استفاده می‌شود. این متغیر به تست‌نویس امکان می‌دهد تا به‌صورت واضح اعلام کند آیا در هر سناریو وقوع خطا انتظار می‌رود یا خیر.\n7.3.2.1 ساختار تست شامل انتظار خطا # func Divide(a, b int) (int, error) { if b == 0 { return 0, fmt.Errorf(\u0026quot;division by zero\u0026quot;) } return a / b, nil } تست جدول‌محور برای پوشش رفتار صحیح و خطا:\nfunc TestDivide(t *testing.T) { tests := []struct { name string a, b int want int wantErr bool }{ {\u0026quot;valid division\u0026quot;, 6, 3, 2, false}, {\u0026quot;zero divisor\u0026quot;, 5, 0, 0, true}, } for _, tt := range tests { tt := tt t.Run(tt.name, func(t *testing.T) { got, err := Divide(tt.a, tt.b) if (err != nil) != tt.wantErr { t.Fatalf(\u0026quot;unexpected error state: %v\u0026quot;, err) } if !tt.wantErr \u0026amp;\u0026amp; got != tt.want { t.Errorf(\u0026quot;expected %d, got %d\u0026quot;, tt.want, got) } }) } } در این ساختار:\nتست اول بررسی می‌کند که تقسیم معمولی به درستی انجام شده. تست دوم بررسی می‌کند که در تقسیم بر صفر، خطای مناسب بازگردانده شده. 7.3.2.2 نکاتی در مورد مقایسه خطا # برای تست دقیق‌تر خطا، گاهی لازم است پیام خطا یا نوع خطا بررسی شود. این کار را می‌توان با روش‌های مختلف انجام داد:\nمقایسه پیام خطا # if err != nil \u0026amp;\u0026amp; err.Error() != \u0026quot;division by zero\u0026quot; { t.Errorf(\u0026quot;unexpected error message: %v\u0026quot;, err) } استفاده از errors.Is یا errors.As # اگر خطا wrap شده باشد:\nvar ErrDivideByZero = errors.New(\u0026quot;division by zero\u0026quot;) if !errors.Is(err, ErrDivideByZero) { t.Errorf(\u0026quot;expected ErrDivideByZero, got %v\u0026quot;, err) } 7.3.2.3 ترکیب با subtest برای مدیریت بهتر # حتی در سناریوهای شامل خطا هم می‌توان از t.Parallel() برای اجرای موازی تست‌ها استفاده کرد، به شرطی که مقدار tt را در scope هر subtest کپی کرده باشیم:\nt.Run(tt.name, func(t *testing.T) { t.Parallel() // اجرای تست }) 7.3.2.4 طراحی سناریوهای پیچیده‌تر # در بسیاری از پروژه‌ها ممکن است تست شامل چند فیلد دیگر مثل ورودی‌های پیچیده‌تر، اشیای اولیه‌شده، یا توابع callback باشد. در این صورت هم جدول تست می‌تواند گسترش یابد و همچنان خوانا باقی بماند.\nمثال:\ntests := []struct { name string input Request want Response wantErr bool }{ {\u0026quot;valid input\u0026quot;, Request{ID: 1}, Response{Success: true}, false}, {\u0026quot;invalid input\u0026quot;, Request{}, Response{}, true}, } 7.3.3 اجرای موازی در تست‌های جدول‌محور با t.Parallel # اجرای تست‌ها به‌صورت موازی، یکی از قابلیت‌های مهم زبان Go است که می‌تواند سرعت اجرای تست‌ها را به شکل قابل‌توجهی افزایش دهد—به‌ویژه زمانی که تعداد زیادی تست داریم و هر تست مستقل از دیگری است. این ویژگی در کنار ساختار جدول‌محور، قدرتی ترکیبی می‌سازد که هم خوانایی بالا دارد و هم بازدهی.\nتابع t.Parallel() به Go اعلام می‌کند که تست جاری می‌تواند به‌صورت همزمان با سایر تست‌ها اجرا شود. اما برای استفاده صحیح از این ویژگی در حلقه‌ی تست‌های جدول‌محور، باید نکته‌ای کلیدی را رعایت کرد: متغیر loop (مانند tt) باید داخل scope هر subtest مجدداً shadow شود. در غیر این صورت، همه goroutineها ممکن است به مقدار یکسانی از tt اشاره کنند و باعث بروز نتایج اشتباه شوند.\n7.3.3.1 مثال صحیح استفاده از t.Parallel # func TestMultiply(t *testing.T) { tests := []struct { name string a, b int expected int }{ {\u0026quot;positive\u0026quot;, 2, 3, 6}, {\u0026quot;zero\u0026quot;, 0, 4, 0}, {\u0026quot;negative\u0026quot;, -1, 3, -3}, } for _, tt := range tests { tt := tt // کپی کردن متغیر برای جلوگیری از race t.Run(tt.name, func(t *testing.T) { t.Parallel() got := Multiply(tt.a, tt.b) if got != tt.expected { t.Errorf(\u0026quot;expected %d, got %d\u0026quot;, tt.expected, got) } }) } } در این مثال:\nt.Parallel() در ابتدای هر subtest فراخوانی شده. متغیر tt := tt باعث شده هر goroutine مقدار اختصاصی خود را داشته باشد. 7.3.3.2 چه زمانی نباید از t.Parallel استفاده کنیم # با وجود مزایای بالا، استفاده از اجرای موازی در همه‌ی تست‌ها توصیه نمی‌شود. در موارد زیر باید با احتیاط یا اصلاً از t.Parallel() استفاده نکنید:\nتست‌هایی که به منابع مشترک دسترسی دارند مانند فایل سیستم، دیتابیس، متغیرهای global یا سرویس خارجی. تست‌هایی که به ترتیب اجرا وابسته‌اند تست‌هایی که در زمان اجرا وضعیت را تغییر می‌دهند مثلاً حذف یا ایجاد فایل، تغییر در داده‌های اشتراکی. در این موارد، یا تست‌ها را به صورت ترتیبی اجرا کنید، یا منابع را ایزوله کنید (مثلاً از t.TempDir() برای مسیرهای جداگانه استفاده کنید).\n7.3.3.3 ترکیب تست موازی با زیرساخت CI # اجرای موازی تست‌ها در CI/CD، به‌ویژه برای پروژه‌های بزرگ، مزیت مهمی محسوب می‌شود. اما لازم است:\nتست‌ها ایزوله باشند. از حافظه یا دیسک مشترک استفاده نکنند. تست‌ها به‌صورت مستقل از محیط اجرا شوند. 7.3.4 ساخت تست‌های قابل نگهداری و خوانا در جدول‌ها # یکی از دلایل اصلی محبوبیت تست‌های جدول‌محور، سهولت در نگهداری و خوانایی بالای آن‌هاست. اما اگر این الگو به‌درستی اجرا نشود، می‌تواند به کدی پیچیده، گنگ و به‌سختی قابل گسترش تبدیل شود. در این بخش، تکنیک‌هایی برای نوشتن تست‌های جدول‌محور خوانا، قابل گسترش و با حداقل خطا ارائه می‌شود.\n7.3.4.1 استفاده از نام‌های گویا برای هر تست # در جدول تست، فیلد name باید دقیق، گویا و منعکس‌کننده‌ی هدف هر تست باشد. این نام در گزارش‌های خروجی تست نمایش داده می‌شود و کلید تحلیل سریع‌تر خطاهاست.\nمثال خوب:\n{ name: \u0026quot;returns error when divisor is zero\u0026quot;, a: 10, b: 0, wantErr: true, } اجتناب شود از نام‌هایی مانند:\n\u0026quot;name\u0026quot;: \u0026quot;test1\u0026quot; 7.3.4.2 مرتب‌سازی منطقی تست‌ها # در جدول تست، بهتر است تست‌ها را به ترتیب معنایی یا گروه‌بندی شده قرار دهید:\nتست‌های موفق اول، سپس تست‌های خطا یا تست‌هایی با رفتار مشابه در کنار هم این کار، درک و دیباگ تست را ساده‌تر می‌کند. 7.3.4.3 تعریف type مجزا برای تست‌کیس‌ها (در پروژه‌های بزرگ) # برای جلوگیری از تکرار تعریف struct در چندین تابع تست و ارتقای وضوح کد، می‌توان type اختصاصی برای تست‌کیس‌ها تعریف کرد:\ntype divideTestCase struct { name string a, b int want int wantErr bool } و سپس در جدول تست:\ntests := []divideTestCase{ ... } این کار به‌ویژه در تست‌های پیچیده یا تکراری در چند فایل بسیار مفید است.\n7.3.4.4 تعریف توابع کمکی برای assertions و آماده‌سازی # در صورت نیاز به تکرار منطق‌های بررسی نتیجه، یا ایجاد ورودی‌های خاص، بهتر است توابع کمکی بنویسید تا از تکرار و پراکندگی منطق جلوگیری شود.\nمثال:\nfunc assertEqual(t *testing.T, got, want int) { if got != want { t.Errorf(\u0026quot;expected %d, got %d\u0026quot;, want, got) } } و در تست:\nt.Run(tc.name, func(t *testing.T) { result := Add(tc.a, tc.b) assertEqual(t, result, tc.expected) }) 7.3.4.5 الگوی توصیه‌شده برای تست‌های قابل نگهداری # type mathTest struct { name string a, b int want int wantErr bool } func TestDivide(t *testing.T) { cases := []mathTest{ {\u0026quot;valid input\u0026quot;, 8, 2, 4, false}, {\u0026quot;zero divisor\u0026quot;, 10, 0, 0, true}, } for _, tc := range cases { t.Run(tc.name, func(t *testing.T) { t.Parallel() got, err := Divide(tc.a, tc.b) if (err != nil) != tc.wantErr { t.Errorf(\u0026quot;unexpected error state: %v\u0026quot;, err) } if !tc.wantErr \u0026amp;\u0026amp; got != tc.want { t.Errorf(\u0026quot;expected %d, got %d\u0026quot;, tc.want, got) } }) } } در این الگو:\nt.Parallel() برای سرعت بالا پیام‌های دقیق و واضح struct مشخص و تایپ‌شده برای هر تست 7.3.5 استفاده از تست‌های تو در تو (Subtests) در Table Test # در بسیاری از مواقع، هر سناریوی تست خودش شامل چند حالت بررسی‌شدنی است. به‌جای اینکه این موارد را به تست‌های مجزای بزرگ و تودرتو تبدیل کنیم، می‌توان با استفاده از t.Run برای هر بخش از منطق، تست‌های تو در تو (Subtests) تعریف کرد. این قابلیت که از Go 1.7 به بعد اضافه شده، ابزار قدرتمندی برای سازمان‌دهی بهتر تست‌ها، گزارش‌گیری دقیق‌تر و امکان اجرای هدفمند تست‌ها فراهم می‌کند.\n7.3.5.1 مثال ساده از Subtest در Table Test # فرض کنیم تابعی داریم که عملیات روی کاربر انجام می‌دهد و در هر حالت باید چند ویژگی خروجی را بررسی کنیم. برای هر حالت، چند subtest تعریف می‌کنیم:\nfunc TestUserValidation(t *testing.T) { tests := []struct { name string user User wantErr bool wantRole string }{ {\u0026quot;valid user\u0026quot;, User{Email: \u0026quot;a@b.com\u0026quot;}, false, \u0026quot;user\u0026quot;}, {\u0026quot;missing email\u0026quot;, User{}, true, \u0026quot;\u0026quot;}, } for _, tt := range tests { tt := tt t.Run(tt.name, func(t *testing.T) { t.Run(\u0026quot;validate email\u0026quot;, func(t *testing.T) { err := tt.user.Validate() if (err != nil) != tt.wantErr { t.Errorf(\u0026quot;error mismatch: %v\u0026quot;, err) } }) t.Run(\u0026quot;check role\u0026quot;, func(t *testing.T) { if tt.user.Role() != tt.wantRole { t.Errorf(\u0026quot;expected role %q, got %q\u0026quot;, tt.wantRole, tt.user.Role()) } }) }) } } در این مثال:\nهر tt یک مورد جدول تست است. دو زیرتست برای هر tt اجرا می‌شود: بررسی اعتبار ایمیل بررسی نقش پیش‌فرض خروجی تست‌ها در گزارش نیز به صورت سلسله‌مراتبی نشان داده می‌شود که کمک بزرگی به عیب‌یابی است.\n7.3.5.2 مزایای استفاده از Subtestها در Table Test # دسته‌بندی معنایی تست‌ها: هر مرحله از تست می‌تواند subtest جداگانه داشته باشد. گزارش دقیق‌تر خطا: نام تست‌های تودرتو در گزارش CLI و CI به صورت کامل دیده می‌شود. امکان اجرای selective: می‌توان فقط یک subtest خاص را با flag -run اجرا کرد: go test -run=\u0026quot;TestUserValidation/valid_user/check_role\u0026quot; 7.3.5.3 اجرای موازی Subtestها # در صورتی که هر subtest ایزوله باشد، می‌توان از t.Parallel() نیز داخل آن استفاده کرد:\nt.Run(\u0026quot;parallel section\u0026quot;, func(t *testing.T) { t.Parallel() // عملیات تست }) 7.3.5.4 نمونه‌ای پیشرفته‌تر: Table + Subtest + Parallel # func TestCalculator(t *testing.T) { tests := []struct { name string a, b int }{ {\u0026quot;positive\u0026quot;, 1, 2}, {\u0026quot;negative\u0026quot;, -1, -3}, } for _, tt := range tests { tt := tt t.Run(tt.name, func(t *testing.T) { t.Run(\u0026quot;Add\u0026quot;, func(t *testing.T) { t.Parallel() if Add(tt.a, tt.b) != tt.a+tt.b { t.Fail() } }) t.Run(\u0026quot;Multiply\u0026quot;, func(t *testing.T) { t.Parallel() if Multiply(tt.a, tt.b) != tt.a*tt.b { t.Fail() } }) }) } } 7.3.6 خطاهای رایج در پیاده‌سازی Table Tests # اگرچه تست‌های جدول‌محور در Go بسیار توصیه می‌شوند و ساختار مؤثری برای مدیریت سناریوهای متنوع تست فراهم می‌کنند، اما اگر به‌درستی پیاده‌سازی نشوند، می‌توانند منجر به تست‌هایی شکننده، گمراه‌کننده یا حتی ناکارآمد شوند. در این بخش، به بررسی خطاهای رایج در پیاده‌سازی Table Tests و راه‌های جلوگیری از آن‌ها می‌پردازیم.\n7.3.6.1 استفاده اشتباه از متغیر loop (closure bug) # یکی از خطرناک‌ترین و رایج‌ترین اشتباهات، استفاده مستقیم از متغیر loop (tt) درون تابع t.Run است. به دلیل اینکه tt در هر iteration یک متغیر مشترک است، همه goroutineها ممکن است به آخرین مقدار آن دسترسی داشته باشند.\nاز نسخه 1.22 این مشکل کاملا حل شده است و نیازی به shadowing نیست.\n❌ مثال اشتباه:\nfor _, tt := range tests { t.Run(tt.name, func(t *testing.T) { t.Parallel() doTest(tt) }) } ✅ راه حل صحیح:\nfor _, tt := range tests { tt := tt // shadowing → ایجاد نسخه مجزا از tt t.Run(tt.name, func(t *testing.T) { t.Parallel() doTest(tt) }) } 7.3.6.2 عدم گزارش نام تست در پیام خطا # در گزارش خطاها، اگر از نام تست استفاده نشود، تشخیص خطای رخ‌داده دشوار می‌شود؛ مخصوصاً وقتی چندین تست پشت سر هم fail می‌شوند.\n❌ اشتباه رایج:\nt.Errorf(\u0026quot;expected %d, got %d\u0026quot;, want, got) ✅ شکل بهتر:\nt.Errorf(\u0026quot;%s: expected %d, got %d\u0026quot;, tt.name, want, got) یا با subtestها، نیازی به این کار نیست چون t.Run خودش context لازم را دارد.\n7.3.6.3 بررسی نکردن خطا وقتی wantErr مشخص است # در بسیاری از تست‌ها فیلدی به نام wantErr تعریف می‌شود اما بررسی درستی روی آن انجام نمی‌گیرد یا فقط وجود/عدم وجود err بررسی می‌شود، بدون توجه به نوع خطا.\n✅ پیشنهاد بهتر:\nif (err != nil) != tt.wantErr { t.Fatalf(\u0026quot;unexpected error state: %v\u0026quot;, err) } در صورت نیاز، بررسی نوع خطا با errors.Is یا errors.As نیز می‌تواند اضافه شود.\n7.3.6.4 تست نکردن مقدار خروجی وقتی خطا انتظار نمی‌رود # ❌ اشتباه رایج:\nif err != nil { t.Fatalf(\u0026quot;unexpected error: %v\u0026quot;, err) } // هیچ بررسی‌ای روی خروجی انجام نشده ✅ راه صحیح:\nif err != nil { t.Fatalf(\u0026quot;unexpected error: %v\u0026quot;, err) } if got != tt.want { t.Errorf(\u0026quot;expected %v, got %v\u0026quot;, tt.want, got) } 7.3.6.5 تبدیل جدول تست به پیچیدگی غیرقابل‌خواندن # گاهی‌اوقات، با افزودن منطق اضافی داخل حلقه‌ی تست یا جدول بسیار حجیم، تست‌خوانی به‌شدت افت می‌کند. در چنین شرایطی بهتر است:\nجدول را به فایل جداگانه ببرید. یا توابع assertion و کمکی تعریف کنید. یا حتی آن تست خاص را از Table Test جدا کنید. 7.3.6.6 عدم پوشش شرایط لبه (Edge Cases) # در جدول تست، اغلب فقط شرایط عادی پوشش داده می‌شوند و شرایط خاص یا مرزی نادیده گرفته می‌شوند؛ مثل:\nورودی‌های صفر، نال، یا تهی بزرگ‌ترین یا کوچک‌ترین مقدار مجاز رشته‌های با کاراکترهای خاص پوشش این موارد نه تنها کیفیت تست را بالا می‌برد بلکه از regressionهای خطرناک جلوگیری می‌کند.\n7.3.6.7 وابستگی تست‌ها به یکدیگر # در صورتی که هر iteration تست جدول‌محور، وضعیت مشترکی تغییر دهد (مثل فایل، دیتابیس، متغیر global)، وابستگی بین تست‌ها ایجاد می‌شود و اجرای موازی خطرناک خواهد بود. هر تست باید کاملاً ایزوله باشد.\n7.3.7 جمع‌بندی و توصیه‌های نهایی برای طراحی تست‌های جدول‌محور # تست‌های جدول‌محور یکی از ستون‌های اصلی تست‌نویسی در زبان Go به‌شمار می‌آیند. این الگو، علاوه بر ساده‌سازی نگارش و توسعه تست‌ها، ساختاری منظم، قابل‌گسترش و حرفه‌ای برای پوشش سناریوهای متنوع فراهم می‌کند. اما استفاده درست از این الگو مستلزم رعایت چند اصل کلیدی است.\n7.3.7.1 مزایای کلیدی Table-Driven Tests # کاهش تکرار در کد تست: دیگر نیازی به کپی کردن یک منطق با ورودی‌های مختلف ندارید. خوانایی بالا: تست‌ها در قالب جدول struct به راحتی قابل درک‌اند. افزودن ساده‌ی تست‌های جدید: فقط کافی‌ست یک struct جدید به جدول اضافه شود. قابلیت اجرای موازی و ایزوله: در ترکیب با t.Parallel() امکان تسریع تست‌ها وجود دارد. گزارش‌گیری ساخت‌یافته: با استفاده از t.Run() و نام‌گذاری دقیق هر تست. 7.3.7.2 توصیه‌های نهایی # همیشه از tt := tt در subtest استفاده کن حتی اگر در لحظه از t.Parallel() استفاده نمی‌کنی، برای اطمینان از ایزولاسیون متغیرها این دستور را بنویس. نام تست را معنی‌دار بنویس نام هر سناریوی تست باید هدف آن را به وضوح منتقل کند؛ این موضوع در CI/CD و گزارش‌های ترمینال بسیار مفید است. ورودی‌ها، خروجی‌ها و انتظار خطا را صریح بیان کن حتی اگر ساده به نظر برسد، وجود فیلدهایی مثل wantErr یا expectedCode ساختار تست را واضح‌تر و قابل گسترش می‌کند. برای هر لایه تستی از Subtest استفاده کن اگر درون هر سناریوی تست چند شرط باید بررسی شود، از t.Run() برای ساخت زیرتست استفاده کن. Edge Caseها را فراموش نکن ورودی‌های خاص، تهی، صفر، منفی یا ناصحیح را در جدول لحاظ کن تا تست‌ها فقط “خوش‌بینانه” نباشند. زمانی که الگو پیچیده شد، ساده کن اگر جدول بسیار بزرگ، پر از توابع تو در تو یا منطق شرطی شد، شاید وقت آن است که آن تست را جداگانه بنویسی یا تست را refactor کنی. برای پروژه‌های بزرگ، از type مجزا استفاده کن تعریف type مشخص برای struct تست‌ها خوانایی را بالا می‌برد، به‌ویژه اگر در چند فایل مشترک باشد. مطمئن شو هر تست ایزوله و بدون side effect است جدول تست نباید به یک ترتیب خاص یا shared state وابسته باشد. هر تست باید مستقل و بازتولیدپذیر باشد. 7.3.7.3 نتیجه‌گیری # استفاده صحیح از تست‌های جدول‌محور در Go، نشانه‌ای از بلوغ تست‌نویسی در یک پروژه است. این الگو، در کنار ابزارهایی مانند t.Run, t.Parallel, t.Cleanup, و پکیج‌هایی مثل testify، به شما امکان می‌دهد تست‌هایی با کیفیت تولیدی و قابل اطمینان بنویسید.\n"},{"id":100,"href":"/chapter-7/go-integration-testing/","title":"7.4 تست یکپارچه (Integration Test)","section":"فصل هفتم: تست نویسی","content":"تست‌های یکپارچه نوعی از تست نرم‌افزار هستند که به بررسی تعامل صحیح میان اجزای مختلف سیستم می‌پردازند. برخلاف Unit Tests که یک بخش از کد را به‌صورت ایزوله بررسی می‌کنند، این تست‌ها بر اطمینان از عملکرد هماهنگ چند ماژول، لایه یا سرویس در کنار هم تمرکز دارند. هدف اصلی آن‌ها شبیه‌سازی سناریوهای نزدیک به شرایط واقعی و اطمینان از این است که بخش‌های سیستم در کنار یکدیگر همان‌طور که انتظار می‌رود کار می‌کنند.\nبه نقل از ویکی پدیا تست یکپارچه‌سازی (به انگلیسی: Integration testing) (گاهی اوقات به عنوان یکپارچه سازی و تست به اختصار I \u0026amp; T نامیده می‌شود) یک تست نرم‌افزاری است که در آن ماژول‌های نرم‌افزاری منحصر به فرد به عنوان یک گروه ترکیب و آزمایش می‌شوند. تست یکپارچه سازی برای ارزیابی انطباق یک سیستم یا یک جزء(component) با نیازمندی‌های عملکردی مشخص انجام شده‌است.\nتست یکپارچه سازی، پس از تست واحد(Unit testing) و قبل از تست اعتبار سنجی (Validation testing) انجام می‌شود. تست یکپارچه سازی ماژول‌هایی را که روی آنها تست واحد(Unit testing) انجام شده‌است را به عنوان ورودی می‌گیرد و آنها را در گروه‌های بزرگتری دسته‌بندی می‌کند و تست‌های تعریف شده را روی آن گروه‌ها انجام می‌دهد. خروجی آن، سیستم یکپارچه شده‌است که آماده برای تست سیستم (System testing) است.\nدر زبان Go، نوشتن تست‌های یکپارچه معمولاً شامل سه مرحله کلیدی است: راه‌اندازی منابع مورد نیاز (setup)، اجرای تست، و پاک‌سازی منابع (teardown). این منابع می‌توانند شامل پایگاه‌داده، صف پیام، سرویس‌های HTTP یا حتی برنامه‌های خارجی باشند. برای مدیریت این مراحل، از قابلیت‌هایی مانند TestMain و t.Cleanup استفاده می‌شود تا اطمینان حاصل شود پس از اتمام تست، منابع آزاد شده یا به حالت اولیه بازگردانده می‌شوند. در بسیاری از پروژه‌ها، راه‌اندازی این منابع به کمک Docker یا پکیج هایی مانند testcontainers-go و dockertest انجام می‌شود.\nیکی از مهم‌ترین چالش‌ها در تست‌های یکپارچه، تضمین ایزوله بودن تست‌ها است. هر تست باید مستقل اجرا شود تا نتایج آن قابل تکرار باشد. در تست‌های دیتابیس، این موضوع معمولاً با استفاده از rollback تراکنش‌ها یا ایجاد schema مجزا برای هر تست انجام می‌شود. همچنین باید متغیرهای محیطی، فایل‌های پیکربندی و سرویس‌های خارجی ثابت نگه داشته شوند تا تست‌ها در اجراهای مختلف نتایج یکسانی تولید کنند.\nبا توجه به این که تست‌های یکپارچه نسبت به تست‌های واحد زمان‌برتر هستند، توصیه می‌شود اجرای آن‌ها به‌صورت انتخابی و در شرایط مشخص انجام شود. این کار را می‌توان با استفاده از فلگ‌هایی مانند -short یا متغیرهای محیطی مخصوص تست مدیریت کرد. در ادامه این فصل، ساختار استاندارد تست‌های یکپارچه در Go، تکنیک‌های setup و teardown، مدیریت وابستگی‌ها و نکات بهینه‌سازی اجرای آن‌ها را به‌صورت گام‌به‌گام بررسی خواهیم کرد.\n"},{"id":101,"href":"/chapter-8/","title":"فصل هشتم: پکیج های استاندارد","section":"صفحه اصلی","content":"در این فصل به مباحث پکیج های استاندارد در زبان گو میپردازیم\u0026hellip;\n"},{"id":102,"href":"/chapter-9/","title":"فصل نهم: الگوهای طراحی","section":"صفحه اصلی","content":"در این فصل، به مباحث الگوهای طراحی در زبان گو می‌پردازیم و سعی می‌کنیم به طور کلی و با مثال‌های مناسب، هر الگو را به شما آموزش دهیم و همچنین برخی از کاربردهای الگوها را نام ببریم.\nالگوی طراحی چیست؟ # الگوهای طراحی ، به عنوان راه‌حل‌های معمول برای مسائلی که در طراحی نرم‌افزار به طور متداول رخ می‌دهند، استفاده می‌شوند. آنها دستورالعمل‌هایی پیش‌فرض هستند که می‌توانید برای حل یک مسئله تکراری در کد خود استفاده کنید.\nچرا باید الگوهای طراحی را یاد بگیریم؟ # الگوهای طراحی، به شما کدهای برنامه برای حل یک مسئله ارائه نمی‌دهند. بلکه، آنها یک مفهوم کلی را برای حل یک مسئله در اختیار شما قرار می‌دهند و بر عهده شماست که این مفهوم را چگونه در برنامه خود پیاده‌سازی کنید.\nالگوهای طراحی، یک زبان مشترک را تعریف می‌کنند تا شما بتوانید با سایر توسعه‌دهندگان به طور موثرتری ارتباط برقرار کنید. به عنوان مثال، می‌توانید به هم‌تیمی خود بگویید: \u0026ldquo;می‌توانی این مسئله را با استفاده از الگوی سینگلتون حل کنی.\u0026rdquo; و او همه ایده‌های پشت این الگو را درک خواهد کرد، بدون اینکه نیاز به توضیح اضافی داشته باشید.\nبسیار مهم است، از الگوهای طراحی زمانی استفاده کنید که واقعاً نیاز دارید. این امر دقت و درک دقیق از مسئله و نیازهای طراحی شما را می‌طلبد. این موضوع کمک می‌کند تا شما کد قابل نگهداری ، قابل توسعه و خوانا توسعه دهید و همچنین از تجربه و دانش جمعی الگوها بهره‌برداری کنید. در نتیجه، درست استفاده کردن از الگوهای طراحی می‌تواند بهبود قابل توجهی در کیفیت و عملکرد برنامه شما ایجاد کند. طبقه‌بندی الگوهای طراحی # الگوهای طراحی با توجه به پیچیدگی، سطح جزئیات و مقیاس کاربرد در برنامه، متفاوت هستند.\nالگوهای طراحی سازنده مکانیزم‌های ایجاد شیء را ارائه می‌دهند که انعطاف‌پذیری و استفاده مجدد از کد موجود را افزایش می‌دهند. الگوهای طراحی ساختاری چگونگی ترکیب اشیاء و کلاس‌ها را به ساختارهای بزرگتر توضیح می‌دهد، در حالی که این ساختارها انعطاف‌پذیری و کارآمدی خود را حفظ می‌کنند. الگوهای طراحی رفتاری مراقبت از ارتباطات مؤثر و تخصیص مسئولیت‌ها بین اشیاء را بر عهده دارند. "},{"id":103,"href":"/chapter-9/creational-patterns/","title":"9.1 الگوهای طراحی سازنده","section":"فصل نهم: الگوهای طراحی","content":"الگوهای طراحی سازنده\u0026hellip;\n"},{"id":104,"href":"/chapter-9/structural-patterns/","title":"9.2 الگوهای طراحی ساختاری","section":"فصل نهم: الگوهای طراحی","content":"الگوهای طراحی ساختاری\u0026hellip;\n"},{"id":105,"href":"/chapter-9/behavioral-patterns/","title":"9.3 الگوهای طراحی رفتاری","section":"فصل نهم: الگوهای طراحی","content":"الگوهای طراحی رفتاری\u0026hellip;\n"},{"id":106,"href":"/chapter-9/concurrency-patterns/","title":"9.4 الگوهای همزمانی","section":"فصل نهم: الگوهای طراحی","content":" عنوان توضیحات وضعیت Wait For Result با استفاده از الگو Wait For Result می توانید یک عملیاتی را بصورت همزمانی انجام دهید و سپس منتظر نتیجه عملیات صورت گرفته بمانید. برای اینکار از کانال استفاده می شود. ✅ Fan Out/In الگو Fan Out/In یک تکنیک همزمانی در زبان گو می باشد که به شما اجازه می دهد چندین کار را با گوروتین همزمان انجام دهید و در نتیجه خروجی این کارها را با هم ترکیب کنید و به عنوان نتیجه نهایی دریافت کنید. ✅ Wait For Task الگو wait for task یکی از الگوهای رایج در زبان گو می باشد و انتظار برای تکمیل یک تسک یا فرآیند استفاده می شود. یک تسک با استفاده از گوروتین اجرا می شود و پس اتمامش کار تسک از طریق کانال سیگنال انجام می فرستد. ✅ Drop الگو Drop یک الگو مهم برای انجام خدمات سنگین می باشد. خدماتی که مواقعی باعث می شود حجم درخواست هایش بیش از ظرفیت موجود باشد و این درخواست ها بواسطه این الگو می تواند Drop شود. به عنوان مثال سرویس های DNS باید از این الگو استفاده کنند. ✅ Context Cancellation Pattern الگو cancellation که حرکت تکنیکی هست برای ارسال سینگال به گوروتین ها استفاده می شود که باید اجرای کاری را متوقف کند و ایده اصلی این کار با استفاده بستن کانال صورت میگیرد. ✅ Semaphore الگو Semaphore برای مدیریت کنترل دسترسی به منابع مشترک در همزمانی استفاده می شود. فرض کنید بصورت موازی ۱۰۰ درخواست HTTP سمت سرور میاد و I/O شبکه برای پردازش همزمان این ۱۰۰ درخواست درگیر میشود و به مرور عملکرد کاهش می یابد. حال اگر ما بیایم این ۱۰۰ درخواست موازی را تقسیم کنیم به ۵ دسته ۲۰ تایی که بصورت همزمانی انجام شود باعث می شود I/O شبکه کاهش یابد و عملکرد بهتری را خواهیم داشت. ✅ Worker Pool با استفاده از الگو Bounded Work Pooling امکان محدود سازی تعداد گوروتین ها را براساس کار مشخصی دارید و گوروتین ها را محدود به تعداد دفعات کار مشخص شده محدود می شود. این الگو برای وقت مفید است که شما می خواهید منابع را به یک کار خاص محدود کنید. ✅ Retry Timeout شما از الگو Retry Timeout برای تلاش مجدد یکسری عملیات استفاده کنید. برای اینکار شما می توانید از حلقه و تابع After در پکیج time کمک بگیرید و برای هرتلاش یک timeout مشخص کنید. ✅ Channel Cancellation از کانال ها برای ارتباط بین گوروتین ها و هماهنگ کردن اجرا استفاده می شود. حال گاهی اوقات نیاز است که ما یکسری فرآیند را داخل گوروتین لغو کنیم. در اینجا می توانیم با استفاده از کانال سیگنال لغو کردن بفرستید تا عملیات هایی که گوروتین مورد نظر انجام می داد لغو شود. ✅ Producer-Consumer الگو producer-consumer یکی از کاربردی ترین الگوها در زبان گو می باشد که با استفاده از الگو می توانید بطور همزمان یکسری اطلاعات تولید کنید و بفرستید داخل کانال و این اطلاعات توسط مصرف کننده بواسطه کانال دریافت شود. ✅ Monitor الگوی مانیتور به گروتین‌ ها اجازه می‌دهد هنگام ورود به حالت خواب بدون مسدود کردن اجرا یا مصرف منابع، منتظر شرایط خاصی باشند. ✅ Future در زبان گو الگو Future راهی برای نمایش نتیجه یک عملیات ناهمزمان (asynchronous) است که ممکن است آن عملیات هنوز تکمیل نشده باشد اما این الگو به شما این امکان را می دهد کدی بنویسید که طوری رفتار کند که گویی نتیجه یک عملیات فورا در دسترس است. حتی اگر عملیات در پس زمینه در حال اجرا باشد. ✅ Pipeline الگو خط لوله (Pipeline) یکی از پرکاربردی ترین الگوها در همزمانی می باشد شما با استفاده از این الگو می توانید تسک های بزرگ را به تسک های کوچکتر و مستقل تقسیم کنید که می توانند بطور همزمان کار کنند. هر stage داخل یک گوروتین انجام می شود و بواسطه کانال داده ها بین stage های مختلف منتقل می شود. ✅ Subscription الگو Subscription یکی از الگوهای کاربردی برای پیاده سازی consumer می باشد که به یک آدرسی مشترک شوید و در بازده زمانی مختلف درخواست دهید و یکسری اطلاعات دریافت کنید. ✅ Bridge Channel با استفاده از الگو Bridge Channel می توانید بین ۲ کانال داده ای را منتقل کنید فرض کنید یک داده را به کانال input میفرستید و از دریافت داده آن را می توانید به کانال دیگری منتقل کنید و عملا شما یک پل برای انتقال داده ایجاد کردید. ✅ Queuing الگوی \u0026ldquo;صف\u0026rdquo; در زبان گو الگویی است که در آن از یک گوروتین برای بافر کردن و مدیریت ترتیب مقادیر ارسال شده و دریافت شده از یک کانال استفاده می شود. ✅ Rate limit الگوی Rate Limiting برای کنترل تعداد درخواست‌ها یا وظایف همزمان در یک بازه زمانی مشخص استفاده می‌شود. این الگو با استفاده از یک time.Ticker یا روش‌های مشابه، اجرای گوروتین‌ها یا پردازش داده‌ها را محدود می‌کند. ✅ Deadlock Recovery الگوی بازیابی از بن‌بست (Deadlock Recovery) برای شناسایی و بازیابی از وضعیت‌های بن‌بست استفاده می‌شود، جایی که چندین گوروتین به طور نامحدود منتظر منابعی هستند که توسط یکدیگر نگه داشته شده‌اند. بن‌بست می‌تواند به دلیل همگام‌سازی نادرست یا رقابت برای منابع در برنامه‌های همزمان رخ دهد. ✅ Lock-free synchronization همگام‌سازی بدون قفل (lock-free synchronization) به مجموعه‌ای از تکنیک‌ها و الگوهای برنامه‌نویسی گفته می‌شود که به چندین thread یا goroutine اجازه می‌دهد به طور همزمان و ایمن به داده‌های مشترک دسترسی پیدا کنند، بدون اینکه از primitiveهایی مثل Mutex یا قفل‌های سنتی استفاده شود. هدف اصلی این الگوها افزایش بازدهی (throughput)، کاهش زمان انتظار (latency) و جلوگیری از مشکلات رایج قفل‌گذاری (مثل deadlock، priority inversion و contention) است. الگوریتم‌های lock-free تضمین می‌کنند که حتی اگر برخی از threadها متوقف شوند یا دچار کندی شوند، باقی سیستم همچنان قادر به پیشرفت خواهد بود (progress guarantee). ✅ "},{"id":107,"href":"/chapter-9/cloud-native-patterns/","title":"9.5 الگوهای Cloud Native","section":"فصل نهم: الگوهای طراحی","content":"الگوهای cloud native\u0026hellip;\n"},{"id":108,"href":"/chapter-9/anti-pattern/","title":"9.6 ضد الگوها (Anti-Patterns)","section":"فصل نهم: الگوهای طراحی","content":"ضد الگوها\n"},{"id":109,"href":"/chapter-10/","title":"فصل دهم: الگوریتم و ساختار داده","section":"صفحه اصلی","content":"در این فصل به مباحث الگوریتم و ساختار داده در زبان گو میپردازیم\u0026hellip;\n"},{"id":110,"href":"/chapter-11/","title":"فصل یازدهم: معماری های نرم افزار","section":"صفحه اصلی","content":"در این فصل به مباحث معماری های نرم افزار در زبان گو میپردازیم\u0026hellip;\n"},{"id":111,"href":"/chapter-12/blockchain/","title":"12.1 بلاکچین","section":"فصل دوازدهم: شبکه بلاکچین","content":"در این بخش به بحث بلاکچین با زبان گو می پردازیم\u0026hellip;\n"},{"id":112,"href":"/chapter-12/","title":"فصل دوازدهم: شبکه بلاکچین","section":"صفحه اصلی","content":"بلاکچین یک دفتر دیجیتال توزیع‌شده است که در آن تراکنش‌ها در یک ردیف متوالی بلوک‌ها ذخیره می‌شوند. هر بلوک حاوی مجموعه‌ای از تراکنش‌ها است و هر تراکنش پس از تأیید توسط رایانه‌های متعدد در شبکه، به طور دائمی به بلاکچین اضافه می‌شود. این پروسه تأیید، معمولاً از طریق فرایندی به نام استخراج انجام می‌گیرد که در آن معماهای ریاضی پیچیده‌ای حل می‌شوند. خاصیت مهم بلاکچین نامتمرکز بودن آن است که این امکان را فراهم می‌آورد تا هیچ شخص یا سازمانی به تنهایی نتواند داده‌ها را کنترل و یا تغییر دهد، این امر به افزایش امنیت و شفافیت در سیستم‌های مالی و دیگر بخش‌ها کمک می‌کند.\nعلاوه بر کاربردهای مالی مانند ارز دیجیتال (مثلاً بیت کوین)، بلاکچین می‌تواند در زمینه‌های متعددی به اشتراک‌گذاری اطلاعات مورد استفاده قرار گیرد. به عنوان مثال، در زمینه حفظ حقوق مالکیت معنوی، ردیابی زنجیره تامین و حتی رأی‌گیری‌های الکترونیکی. ویژگی‌های منحصر به فرد آن مانند تغییرناپذیری داده‌ها، شفافیت و امنیت بالا، ظرفیت فراوانی برای ایجاد تحول دیجیتالی و اعتماد در تقریباً هر صنعتی را داراست. این فناوری هنوز در ابتدای راه خود قرار دارد و پتانسیل تغییرات عظیمی در نحوه تعاملات ما در دنیای دیجیتال را دارد.\nبه نقل از ویکی پدیا:\nزنجیرهٔ بلوکی[۱] (به انگلیسی: Blockchain)[۲][۳] یک فناوری برای ثبت و ضبط داده‌ها به حساب می‌آید که به آن پایگاه داده نیز گفته میشود. این داده‌ها می‌توانند برای نمونه تراکنش‌های بانکی باشند یا اسناد مالکیت، قرارها، پیام‌های شخصی یا دیگر اطلاعات. یکی از ویژگی های زنجیرهٔ بلوکی این است که کار ذخیرهٔ این داده‌ها بدون وجود یک مدیر و صاحب‌اختیار مرکزی امکان‌پذیر است و نمی‌توان با تخریب یک نقطهٔ مرکزی داده‌های ذخیره‌شده را تحریف یا نابود کرد که نام این ویژگی شبکه عمومی و غیرمتمرکز نام دارد. معروف‌ترین شبکه عمومی و غیرمتمرکزی که از این ویژگی بلاکچین استفاده میکند، رمز ارز بیت‌کوین، اتریوم و تتر است.\nدر این فصل ما بطور کلی بصورت پایه تا پیشرفته به مباحث بلاکچین میپردازیم و هدف از گذارندن این بخش رسیدن به بازار کار و یادگیری کامل بلاکچین خواهد بود.\nبخش ها # در این فصل ما 4 بخش داریم که به شرح زیر می باشد:\nآموزش صفر تا صد عناوین بلاکچین آموزش درخصوص شبکه بیت کوین آموزش درخصوص شبکه اتریوم آموزش درخصوص شبکه پکتوس "},{"id":113,"href":"/chapter-12/blockchain/blockchain/","title":"12.1.1 بلاکچین چیست","section":"12.1 بلاکچین","content":" بلاکچین (زنجیره بلوک) در واقع یک سیستم توزیع شده همتا به همتا (Peer to Peer) 1 می باشد که هیچ سرور مرکزی وجود ندارد و این شبکه با افزایش تعداد بلوک ها, تراکنش ها و کلاینت ها رشد می کند و در این شبکه تمامی اطلاعات بصورت رمزنگاری شده رد و بدل می شود و از انواع رمزنگاری متقارن و نامتقارن برای افزایش امنیت شبکه استفاده می شود.\nهدف اصلی بلاکچین بوجود آمدن یک سیستم شفاف و غیرمرکزی هست که دولت ها یا شرکت ها هیچ دسترسی مستقیمی برروی اطلاعات موجود در شبکه نداشته باشند و تمامی اطلاعات بصورت رمزنگاری شده داخل شبکه رد و بدل شود, منظور از سیستم غیرمرکزی یعنی کلاینت هایی که به شبکه متصل می شوند یکدیگر را به هیچ عنوان نمی شناسند و ممکن است یکی از کلاینت ها سیستم شخصی شما باشد یا اینکه یک سرور مجازی و\u0026hellip; باشد و این کلاینت ها با متصل شدن به یکدیگر و انتشار اطلاعات برای سایر اعضای مجموعه خود باعث بروز شدن اطلاعات شبکه می باشد.\nبلاکچین عموما توسط کامپیوترهای داخل شبکه همتا به همتا مدیریت می شود و جایی که هر گره (یا همان کلاینت) با استفاده از پروتکل الگوریتم اجماع 2 ایجاد و اعتبارسنجی ایجاد تراکنش و بلوک را انجام می دهد.\n12.1.1.1 ساختار و طراحی # یک بلاکچین یک زنجیره غیرمتمرکز, توزیع شده و اغلب عمومی هست و عنوان یک دفتر کل دیجیتالی که شامل کلی رکورد به نام بلوک هست و داخل این بلوک ها تعداد تراکنش با محدوده مشخصی نگه داری می شود, بلوک ها به هیچ عنوان تغییر پذیر نیستند و همواره با ایجاد شدن یک بلوک جدید فرآیند ادامه پیدا میکند بطوری که ممکن است یک بلوک فقط یک تراکنش داشته باشد و ادامه لیست تراکنش های جدید در بلوک بعدی نگه داری شود.\nدر کل این عمل به مشارکت کنندگان (گره ها) اجازه می دهد تا معاملات را بطور مستقل و نسبتا ارزان بررسی و حسابرسی کنند.\nدر شبکه بلاکچین هر گره دارای یک دیتابیس مستقل می باشد که بواسط شبکه همتا به همتا تمامی اطلاعات (بلوک - تراکنش - اکانت ها و\u0026hellip;) بین گره با یک مهر زمانی توزیع می شود و این اطلاعات داخل دیتابیس محلی هر گره نگه داری می شود. هر گره موظف است به محض دریافت اطلاعات جدید این اطلاعات را احراز هویت کند و در صورت معتبر بودن اطلاعات به دیتابیس خود اضافه و نگهداری کند.\nدر شبکه بلاکچین یک دارایی دیجیتالی (به عنوان مثال کوین - توکن) وجود دارد که به هیچ عنوان کپی نمی شود و بلکه این دارایی بین حساب های داخل شبکه منتقل می شود, این تایید می کند که هر واحد ارزش فقط یک بار منتقل شده است و مشکل دیرینه خرج مضاعف را حل می کند.\nیک بلاکچین به عنوان یک پروتکل تبادل ارزش توصیف می شود چون بلاکچین می تواند حقوق مالکیت را حفظ کند و این ارزش یک بار توصیف می شود.\nبلاکچین را می توان به چندین لایه تقسیم می شود:\nزیر ساخت سخت افزار شبکه (کشف گره, انتشار اطلاعات و تایید اطلاعات) پروتکل الگوریتم اجماع داده ها (بلاک ها و تراکنش ها) نرم افزار (قرارداد های هوشمند - برنامه های غیرمتمرکز) 12.1.1.2 غیرمتمرکز # با ذخیره داده ها در سراسر شبکه همتا به همتا بلاکچین برخی از خطرات ناشی از نگه داری داده را بصورت متمرکز حذف می کند.\nدر شبکه های توزیع شده متمرکز احتمالات حملات و آسیب پذیری بسیار بالاس و ممکن است با یک حمله کل شبکه از بین برود اما در شبکه غیرمتمرکز بلاکچین به لطف پروتکل الگوریتم اجماع جلو حملات و کلاینت های مخرب گرفته می شود و پایداری شبکه چند برابر می شود چون زمانیکه که شبکه بلاکچین بزرگتر می شود و رشد می کند امنیت هم رشد پذیر است و شبکه پایدارتر می شود.\nدر شبکه بلاکچین ممکن است گره هایی با دستکاری کردن کلاینت خود قصد آسیب زدن به شبکه را داشته باشند به همین دلیل شبکه با استفاده از استراتژی های مطرح شده در پروتکل الگوریتم اجماع می تواند جلو این اتفاق را بگیرد یکی از این استراتژی های Byzantine fault tolerance می باشد.\n12.1.1.3 بلاکچین Permissionless # بلاکچین مزایایی دارد باز بودن, permissionless یا عمومی بود شبکه می باشد که این مزیت باعث می شود شبکه خود را در برابر گره متخلف از خود محافظت کند و نیازی به کنترل دسترسی نیست. منظور از این مطلب این است که هر برنامه ای می تواند بدون تایید و اعتماد از لایه انتقال شبکه بلاکچین استفاده کند و عمل ناشیانه ای انجام دهد تاثیری برروی آسیب دیدن شبکه نمی گذارد و شبکه مسیر خود را پیش روی میکند.\nبیت کوین و سایر ارزهای دیجیتال در حال حاضر با الزام انجام اثبات Proof of Work 3 شبکه را ایمن می کند و هر کسی که در این شبکه فعالیت می کند با انجام پازل Hashcash می تواند در شبکه بلاک بسازد و به پایداری شبکه کمک کند و در ازا یک جایزه ای دریافت کند.\n12.1.1.4 زمینه های استفاده از بلاکچین # در زیر لیستی از زمینه های که بلاکچین استفاده شده است را قرار دادیم:\nارزهای دیجیتالی قراردادهای هوشمند سرویس های مالی (بانکداری دیجیتال) بازی های آنلاین زنجیره تامین ثبت اطلاعات، اسناد و مستندات با اثبات و تظمین از دست نرفتن بالا تر از ذخیره در منابع متمرکز و شفافیت و \u0026hellip; ارجاعات # شبکه همتا به همتا (Peer to Peer)\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nپروتکل الگوریتم اجماع \u0026#160;\u0026#x21a9;\u0026#xfe0e;\nالگوریتم اثبات کار\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},{"id":114,"href":"/chapter-12/blockchain/blockchain-history/","title":"12.1.2 تاریخچه بلاکچین","section":"12.1 بلاکچین","content":"تاریخچه بلاکچین\n"},{"id":115,"href":"/chapter-12/blockchain/blockchain-architecture/","title":"12.1.3 معماری بلاکچین","section":"12.1 بلاکچین","content":"معماری بلاکچین\n"},{"id":116,"href":"/chapter-12/blockchain/blockchain-type/","title":"12.1.4 انواع بلاکچین","section":"12.1 بلاکچین","content":"انواع بلاکچین\n"},{"id":117,"href":"/chapter-12/blockchain/blockchain-different-with-centerlized/","title":"12.1.5 تفاوت سیستم متمرکز با غیرمتمرکز","section":"12.1 بلاکچین","content":"تفاوت سیستم متمرکز با غیرمتمرکز\n"},{"id":118,"href":"/chapter-12/blockchain/blockchain-scale/","title":"12.1.6 مقیاس پذیری در بلاکچین","section":"12.1 بلاکچین","content":"مقیاس پذیری در بلاکچین\n"},{"id":119,"href":"/chapter-12/blockchain/blockchain-security/","title":"12.1.7 امنیت در بلاکچین","section":"12.1 بلاکچین","content":"امنیت در بلاکچین\n"},{"id":120,"href":"/chapter-12/blockchain/blockchain-cryptography/","title":"12.1.8 مفاهیم رمزنگاری","section":"12.1 بلاکچین","content":"مفاهیم رمزنگاری\n"},{"id":121,"href":"/chapter-12/blockchain/blockchain-consensus-algorithm/","title":"12.1.10 الگوریتم اجماع (Consensus)","section":"12.1 بلاکچین","content":"الگوریتم اجماع (Consensus)\n"},{"id":122,"href":"/chapter-12/blockchain/blockchain-p2p-network/","title":"12.1.11 ساختار و کاربرد شبکه P2P","section":"12.1 بلاکچین","content":" 2.11.1 معماری P2P چیست؟ # معماری P2P یا همتا به همتا، نوعی ساختار شبکه است که در آن دستگاه ها به طور مثال کامپیوتر ها به طور مستقیم و بدون نیاز به سرور مرکزی به یکدیگر متصل می‌شوند. در این نوع شبکه، هر دستگاهی (که به آن گره یا نود هم می‌گویند) می‌تواند هم به عنوان فرستنده و هم به عنوان گیرنده اطلاعات عمل کند.\n12.11.2 انواع شبکه‌های P2P # شبکه‌های P2P بدون ساختار: در این نوع شبکه‌ها، هیچ نظم و ترتیبی در اتصال گره‌ها به یکدیگر وجود ندارد. گره‌ها به طور تصادفی به یکدیگر متصل می‌شوند و به اشتراک‌گذاری فایل‌ها به صورت تصادفی انجام می‌شود شبکه‌های P2P با ساختار: در این نوع شبکه‌ها، گره‌ها به طور منظم به یکدیگر متصل می‌شوند. به اشتراک‌گذاری فایل‌ها بر اساس قوانین و الگوریتم‌های خاصی انجام می‌شود. 12.11.3 کاربرد های معماری P2P # اشتراک‌گذاری فایل: شبکه‌های P2P برای اشتراک‌گذاری فایل‌ها، مانند موسیقی، فیلم و نرم‌افزار، بسیار محبوب هستند.\nبلاکچین: بلاکچین، فناوری زیربنایی ارزهای دیجیتال، از معماری P2P استفاده می‌کند.\nتماس‌های صوتی و تصویری: برخی از برنامه‌های تماس صوتی و تصویری، مانند Skype، از معماری P2P استفاده می‌کنند.\n12.11.3.1 بلاکچین # توزیع و ذخیره‌سازی داده‌ها: بلاکچین به جای ذخیره‌سازی داده‌ها در یک سرور مرکزی، از شبکه‌ای از کامپیوترها (نودها) برای ذخیره‌سازی اطلاعات استفاده می‌کند. این امر باعث می‌شود که بلاکچین در برابر حملات سایبری و خرابی‌ها مقاوم‌تر باشد. تایید تراکنش‌ها: در شبکه‌های بلاکچین، تراکنش‌ها توسط نودها تایید می‌شوند. این کار به صورت غیرمتمرکز انجام می‌شود و نیازی به واسطه (مانند بانک) وجود ندارد. نودها با استفاده از الگوریتم‌های اجماع، مانند اثبات کار (PoW) یا اثبات سهام (PoS)، تراکنش‌ها را تأیید می‌کنند. اجماع: اجماع در بلاکچین به فرآیندی گفته می‌شود که در آن نودها در مورد وضعیت فعلی بلاکچین به توافق می‌رسند. الگوریتم‌های اجماع مختلفی برای بلاکچین وجود دارد. شبکه‌های P2P برای پیاده‌سازی الگوریتم‌های اجماع ضروری هستند. مقیاس‌پذیری: بلاکچین‌های مبتنی بر P2P به طور ذاتی مقیاس‌پذیر هستند. به این معنی که می‌توانند به راحتی با اضافه شدن نودهای جدید به شبکه، ظرفیت خود را افزایش دهند. امنیت: شبکه‌های P2P می‌توانند در برابر حملات سایبری مقاوم باشند. دلیل این امر این است که هیچ نقطه مرکزی برای حمله وجود ندارد. هکرها برای هک کردن بلاکچین، باید تعداد زیادی از نودها را هک کنند. حاکمیت: شبکه‌های P2P به طور غیرمتمرکز اداره می‌شوند. این امر به معنای آن است که هیچ شخص یا گروهی کنترل کاملی بر شبکه ندارد و باعث می‌شود که بلاکچین شفاف‌تر و قابل اعتمادتر باشد. 12.11.3.2 مثال‌هایی از شبکه‌های P2P # BitTorrent: یک شبکه P2P برای اشتراک‌گذاری فایل است.\nBitcoin: یک شبکه P2P برای تبادل ارز دیجیتال بیت کوین است.\nEthereum: یک شبکه P2P برای تبادل ارز دیجیتال اتریوم است.\n12.11.4 مزایای معماری P2P # عدم تمرکز: در شبکه‌های P2P هیچ نقطه مرکزی برای کنترل و مدیریت شبکه وجود ندارد. این امر باعث می‌شود که شبکه در برابر حملات و خرابی‌ها مقاوم‌تر باشد.\nمقیاس‌پذیری: شبکه‌های P2P به طور ذاتی مقیاس‌پذیر هستند. به این معنی که می‌توانند به راحتی با اضافه شدن گره‌های جدید به شبکه، ظرفیت خود را افزایش دهند.\nکارایی: در شبکه‌های P2P، بار ترافیک بین گره‌های مختلف شبکه توزیع می‌شود. این امر باعث می‌شود که شبکه کارآمدتر باشد و از اتلاف منابع جلوگیری شود.\n12.11.5 معایب معماری P2P # امنیت: شبکه‌های P2P می‌توانند در برابر حملات سایبری آسیب‌پذیر باشند.\nکشف محتوا: پیدا کردن محتوا در شبکه‌های P2P می‌تواند دشوار باشد.\nمدیریت: مدیریت شبکه‌های P2P می‌تواند دشوار باشد.\n"},{"id":123,"href":"/chapter-12/blockchain/blockchain-data-management/","title":"12.1.12 مدیریت داده در بلاکچین","section":"12.1 بلاکچین","content":"مدیریت داده در بلاکچین\n"},{"id":124,"href":"/chapter-12/blockchain/blockchain-network-testing/","title":"12.1.13 تست پذیری شبکه","section":"12.1 بلاکچین","content":"تست پذیری شبکه\n"},{"id":125,"href":"/chapter-12/blockchain/blockchain-analyze-and-optimization/","title":"12.1.14 ارزیابی و بهینه سازی شبکه","section":"12.1 بلاکچین","content":"ارزیابی و بهینه سازی شبکه\n"},{"id":126,"href":"/chapter-12/blockchain/blockchain-monitoring/","title":"12.1.15 مانیتورینگ شبکه","section":"12.1 بلاکچین","content":"مانیتورینگ شبکه\n"},{"id":127,"href":"/chapter-12/blockchain/blockchain-forking/","title":"12.1.16 استراتژی فورک ها","section":"12.1 بلاکچین","content":"استراتژی فورک ها\n"},{"id":128,"href":"/chapter-12/blockchain/blockchain-api-and-sdk/","title":"12.1.17 پیاده سازی انواع API ها و SDK ها","section":"12.1 بلاکچین","content":"پیاده سازی انواع API ها و SDK ها\n"},{"id":129,"href":"/chapter-12/blockchain/blockchain-keys-and-addresses/","title":"12.1.18 کلیدها و آدرس ها","section":"12.1 بلاکچین","content":"کلیدها و آدرس ها\n"},{"id":130,"href":"/chapter-12/blockchain/blockchain-accounts/","title":"12.1.19 اکانت ها","section":"12.1 بلاکچین","content":"اکانت ها\n"},{"id":131,"href":"/chapter-12/blockchain/blockchain-transactions-and-messages/","title":"12.1.20 تراکنش ها و پیام ها","section":"12.1 بلاکچین","content":"تراکنش ها و پیام ها\n"},{"id":132,"href":"/chapter-12/blockchain/blockchain-blocks/","title":"12.1.21 بلوک ها (Blocks)","section":"12.1 بلاکچین","content":"بلوک ها\n"},{"id":133,"href":"/chapter-12/blockchain/blockchain-genesis/","title":"12.1.22 جنسیس (Genesis)","section":"12.1 بلاکچین","content":"جنسیس (Genesis)\n"},{"id":134,"href":"/chapter-12/blockchain/blockchain-smart-contracts/","title":"12.1.23 قراردادهای هوشمند","section":"12.1 بلاکچین","content":"قراردادهای هوشمند\n"},{"id":135,"href":"/chapter-12/blockchain/blockchain-privacy/","title":"12.1.24 حریم خصوصی شبکه","section":"12.1 بلاکچین","content":"حریم خصوصی شبکه\n"},{"id":136,"href":"/chapter-12/bitcoin/","title":"12.2 شبکه بیت کوین","section":"فصل دوازدهم: شبکه بلاکچین","content":"در این بخش به بحث شبکه بیت کوین می پردازیم\u0026hellip;\n"},{"id":137,"href":"/chapter-12/bitcoin/bitcoin/","title":"12.2.1 معرفی بیت کوین","section":"12.2 شبکه بیت کوین","content":"معرفی بیت کوین\n"},{"id":138,"href":"/chapter-12/bitcoin/bitcoin-cryptography/","title":"12.2.2 رمزنگاری در بیت کوین","section":"12.2 شبکه بیت کوین","content":"رمزنگاری در بیت کوین\n"},{"id":139,"href":"/chapter-12/bitcoin/bitcoin-addresses/","title":"12.2.3 آدرس ها","section":"12.2 شبکه بیت کوین","content":"آدرس ها\n"},{"id":140,"href":"/chapter-12/bitcoin/bitcoin-transactions/","title":"12.2.4 تراکنش ها","section":"12.2 شبکه بیت کوین","content":"تراکنش ها\n"},{"id":141,"href":"/chapter-12/bitcoin/bitcoin-structure/","title":"12.2.5 ساختار بلاکچین بیت کوین","section":"12.2 شبکه بیت کوین","content":"ساختار بلاکچین بیت کوین\n"},{"id":142,"href":"/chapter-12/bitcoin/bitcoin-consensus/","title":"12.2.6 الگوریتم اجماع","section":"12.2 شبکه بیت کوین","content":"الگوریتم اجماع\n"},{"id":143,"href":"/chapter-12/bitcoin/bitcoin-miners/","title":"12.2.7 ماینرها","section":"12.2 شبکه بیت کوین","content":"ماینرها\n"},{"id":144,"href":"/chapter-12/bitcoin/bitcoin-network/","title":"12.2.8 شبکه","section":"12.2 شبکه بیت کوین","content":"شبکه\n"},{"id":145,"href":"/chapter-12/bitcoin/bitcoin-wallets/","title":"12.2.9 والت ها","section":"12.2 شبکه بیت کوین","content":"والت ها\n"},{"id":146,"href":"/chapter-12/bitcoin/bitcoin-in-real-world/","title":"12.2.10 بیت کوین در دنیای واقعی","section":"12.2 شبکه بیت کوین","content":"بیت کوین در دنیای واقعی\n"},{"id":147,"href":"/chapter-12/bitcoin/bitcoin-innovation/","title":"12.2.11 نوآوری","section":"12.2 شبکه بیت کوین","content":"نوآوری\n"},{"id":148,"href":"/chapter-12/bitcoin/bitcoin-clients/","title":"12.2.12 کلاینت ها","section":"12.2 شبکه بیت کوین","content":"کلاینت ها\n"},{"id":149,"href":"/chapter-12/bitcoin/bitcoin-programming/","title":"12.2.13 برنامه نویسی در بیت کوین","section":"12.2 شبکه بیت کوین","content":"برنامه نویسی در بیت کوین\n"},{"id":150,"href":"/chapter-12/ethereum/","title":"12.3 شبکه اتریوم","section":"فصل دوازدهم: شبکه بلاکچین","content":"در این بخش به شبکه اتریوم، اسمارت کانترکت ها و ماشین مجازی اتریوم میپردازیم\u0026hellip;\n"},{"id":151,"href":"/chapter-12/ethereum/ethereum/","title":"12.3.1 معرفی اتریوم","section":"12.3 شبکه اتریوم","content":" 12.3.1.1 اتریوم # بعد از حل مشکلاتی که برای ایجاد یک ارز یا سکه دیجیتالی یا مجازی وجود داشت توسط بیتکوین، با استفاده از ایجاد یک دفتر کل غیر متمرکز، دیتا مدل بلاکچین و سیستم غیرمتمرکز آن موقعیتی برای ایجاد و حل مشکلات دیگه فراهم کرد.\nویتالیک بوترین ایده اتریوم و وایت پیپر ان را اولین بار در سال ۲۰۱۳ منتشر کرد. او یک فعال در مجله بیتکوین بود و اعتقاد داشت بیتکوین دارای مشکلاتی است که باید برطرف شود. او در سال ۲۰۱۴ با چند توسعه دهنده دیگر در ماه اوت همان سال برای اجرای ایده خود شروع به جذب سرمایه کرد.\nهمانطور که ایده ها حول و محور یک سکه دیجیتالی پیش از بیتکوین زیاد بود، قبل از اتریوم و حتی بیتکوین هم افرادی فکر استفاده از ماشین ها برای اجرا و مدیریت قرارداد ها داشتند. اما مساله تغییر پذیر بودن کد های ماشینی و همیشه در دسترس بودن آنها کار را دشوار تر میکرد.\nهمانطور که در بخش قبل (معرفی بلاکچین)توضیح دادیم، یک بلاکچین یک دیتابیس توزیع شده کاملا غیر قابل تغییر است. و همینطور همیه چیز در آن شفاش و اعتبار سنجی شده است. در کنار تمام این موارد نسبت به تعداد node ها شبکه همیشه دسترسی پذیر است و میتوان به دسترسی پذیر بودن اطلاعات بر بستر آن هم اعتماد کرد.\nاز طرفی مدل های اجماعی قبلی هم مشکلاتی مثل هزینه بر بودن و ایجاد مشکلات در طبعیت را داشتند. در ادامه به حل این مشکلات در اتریوم میپردازیم.\n12.3.1.1.1 ماشین مجازی اتریوم و قرار داد های هوشنمد # این خصوصیات برای ما این فرصت را ایجاد کرد تا قرارداد های هوشمند را اختراع کنیم و پیشتاز این صنعت ویتالیک بوترین با ایده ماشین مجازی اتریوم بود!\nاتریوم، یک بلاکچین نسل دوم است که اولین بار با مدل اجماع اثبات کار PoW و قابلیت پشتیبانی از قرارداد های هوشمند اراعه شد. طبق بژ پیپر اتریوم (بژ پیپر نسخه ای ساده نویسی شده و خلاصه شده از یلو پیپر است.) هدف اصلی اتریوم ارز اتر نیست. (ارز شبکه اتریوم اتر و مرسوم ترین خرده واحد آن وی می باشد) هدف اصلی اتریوم ماشین مجازی آن است. شبکه اتریوم، مجموعه ای از نود ها هستند که نرم افزار اتریوم (یک پیاده سازی از اتریوم) را اجرا میکنند و با دیتا مدل بلاکچین استیت کلی را نگهداری میکنند. زمانی که یک قرارداد هوشمند روی اتریوم مستقر میشود، تمامی نود های شبکه یک بایت کد از ان را نگهداری میککند.\nپس شما میتوانید به راحتی، با استاندارد های اتریوم قرارداد برای مثال مالی خود را بنویسید، و روی شبکه اتریوم مستقر کنید. این امر باعث میشود که شما بدون واسطه، به دسترسی پذیر بودن، شفاف بودن (تمام بایت کد ها روی شبکه اتریوم قابل استعلام و خواندن است. به نحوی هر قرارداد هوشنمند مجبور است متن باز باشد. قابل ذکر است که سورس کدی که کامپایل نشده در شبکه نگهداری نمیشود اما معمولا اکسپلورر ها یک نسخه اعتبارسنجی شده از سورس کد را اراعه میدهند) ان مطمن باشید.\nامامرحله مهم بعدی، اجرای آن قرار داد بصورت مطمن است. هر نود اتریوم یک ماشین مجازی روی خود دارد که از توانایی اجرا بایت کد های اتریوم برخوردار است. یکی از دلایل اجرا نشدن مستقیم کانترکت ها این است که ما در ازای مقدار ورودی ثابت و اجرای توابع کانترکت روی هر نود توقع خروجی ثابت داریم. همانطور که در بخش های قبل اشاره کردیم در بلاکچین بصورت مستقیم به اطلاعات خارج از زنجیره (off-chain) اعتماد نمی کنیم. پس وضعیت نود اجرا کننده نباید در اجرای قرارداد ما اثر گذار باشد.\nپس هر نود سورس کد قرار داد هوشنمد شما به علاوه یک ماشین مجازی برای اجرا آن را دارد. از طرفی ما نمیتوانیم توان پردازشی را بین تمام شبکه تقسیم کنیم و بگوییم که همه نود ها باهم یک تابع را جرا کنند. پس تغییر نهایی قرارداد را روی استیت کلی شبکه اتریوم اعمال میکنیم. که با یک تراکنش که ان را contract call صدا میزنیم انجام میشود. در نتیجه همه برای اعمال تغییر، خروجی را اعتبار سنجی میکنند.\nتمام کانترکت های اتریوم دسترسی به برخی از اطلاعات شبکه، نوشتن و خواندن از ان را دارند و میتوانند مجوز برداشت اتر از صاحب یک حساب بگیرند یا به حساب های مختلف اتر وایز کنند.\nهر کانترکت در شبکه اتریوم (و عمد بلاکچین های موجود) حکم یک شی در پارادایم برنامه نویسی شی گرا را دارد. برای مثال انها استکی مخصوص خود دارند و یا برای صدا زدن یکدگیر باید یک نسخه (instance) از دیگری بسازند. که در این باره در بخش کانترکت و ماشین مجازی اتریوم بصورت مفصل میپردازیم. از طرفی دیگر تمام کانترکت های اتریوم یک فضای ذخیره سازی کلید و مقداری (key/value)هم دارند.\nاما مساله پر اهمیت بعدی این است که چرا یک نود باید کانترکت هارا نگهداری و اجرا کند؟؟؟ برای نگهداری و اعتبار سنجی بلاک ها بصورت صادقانه، ما یک جایزه مشخص کردیم. در اصل در ازای صادق بودن و کمک کردن به شبکه ما یک تشویق و برای تلاش در نابود کردن شبکه تنبیه تعریف کردیم. با روش های مختلف. راه حل قرارداد های هوشنمد هم همین مساله است. زمانی که شما یک کانترکت کال انجام میدهید، اولا نیاز به پرداخت کارمز تراکنش خود هستید، اما بخش اصلی این است که تمام بایت کد های اتریوم یک مبلغ بدون واحد (unit less) به عنوان هزینه اجرا یا gas دارند.\nبرای مثال زمانی که شما یک تابع در یک کانترکت را صدا میزنید، تابعی که شما صدا زده اید از ۵ اوپریشن کد (operation code) تشکیل شده. که هر اوپریشن کد ۳ gas نیاز دارد. (توضیح و جزییات اوپریشن کد ها در بخش ماشین مجازی اتریوم و اسمارت کانترکت انجام میشود) از ان رو که gas واحدی ندارد پس هزینه gas هر کانترکت کال به gas مشخص و ثابت است. اما قیمت هر gas نسبت به بار شبکه و حجم تراکنش ها متفاوت است برای مثال همین الان که این متن نوشته میشود قیمت هر gas حدود ۲۵ gwei است (گیگا وی) حال اگر شما یک کانترکت کال با هزینه مشخص 100 وی انجهام دهید، نیاز به پرداخت ۲۵۰۰ gwei یا 0.068 دلار به عنوان gas دارید.\nپس نودی که کانترکت شما را اجرا میکند دلیلی منطقی برای اجرا و نگهداری از ان دارد. و علت ایجاد ارز اتر همین پاداش و هزینه اجرا کانترکت ها است.\n12.3.1.1.2 مدل اجماع اثبات سهام (Proof of Stake or PoS) # مدل اجماع اولیه شبکه اتریوم، مدل اثبات کار بود. اما بعد ازمدتی اتریوم از مدل جدیدی به اسم اثبات سهام امنیت و یکپارچی خود را تظمین کرد.\nدر مدل اثبات سهام، مسابقه ای وجود ندارد. بجای ماینر ها هر نود نقش یک شخص که وضیفه اعتبار سنجی بلاک هارا دارد را بازی میکند. اما چطور اعتماد به نود ها صورت میگیرد؟\nهر نود برای اینکه در فرایند اجماع شرکت داده بشود، مبلغی از ارز شبکه را استیک میکند. بعد از استیک شدن قابلیت جابه جایی ان وجود ندارد و به نحوی تحت کنترل شبکه است. این استیک حکم اعتبار ان نود را دارد. زمانی که شما دست به تقلب بزنید، استیک های شما در خطر خواهد بود. پس هرچه شما ارزش بیشتری را استیک کنید، مبلغ بیشتری برای از دست دادن دارید. پس احتمالا کمتر به فکر صادق نبودن هستید و در نتیجه معتبر تر هستید.\nزمانی که ۱۰۰ نود برای مثال با استیک های مختلف وجود دارند، یک شخص بصورت تصادفی برای ثبت بلاک جدید انتخاب میشود و نیازی به هیچگونه مسابقه ای نیست. اما شخص انتخاب شده نیاز دارد که بلاک مورد نظر را اراعه کند و بقیه نود ها ان را تایید کنند. احتمال اینکه شما انتخاب شوید بیشتر است، اما اگر استیک بیشتری داشته باشید.\nحداقل استیک در اتریوم در این موقع حدود ۳۲ اتر است. همچین شما قابلیت unstake کردن نود خود را دارید اما فرایند زمان بری است و بعد از ان نود شما در فرایند اجماع شرکت داده نخواهد شد.\nهر نود بعد از انتخاب شدن، بلاک خود را اراعه میکند و دیگر نود ها رای میدهند. اگر بلاک تایید شود همه انرا به دفتر کل خود اضافه میکنند و جایزه بلاک به نود مورد نظر میرسید. اگر بلاک رد شود و به مرور نود مشکوک برسد، همانطور که گفتیم استیک ها در خطرند.\nدر این مدل اجماع، ما بجای مفهوم ماینر یا استخراج کننده از مفهوم و کلمه ولیدیتور و یا اعتبارسنجی کننده استفاده میکنیم. و بجای ماین یا استخراج از کلمه مینت شدن یا ضرب شدن استفاده میکنیم.\nدر این مدل اجماع ما با قفل کردن دارایی های خود هم اعتبار خود را اثبات میکنیم، و هم مشخص میکنیم که از شبکه ای که در حال فعالیت هستیم سهمی سهامی داریم. پس هر حرکت اسیب زننده ای دارایی مارا به دو نحو در خطر میندازد.\nاین مدل اجماع هزینه منابع کمتری دارد و برای طبیعت به نسبت بیت کوین کم ضرر تر است. (نکته مهم این است که شبکه بیتکوین هزاران بار از وضعیت فعلی طلا و ارز های فیات متمرکز کاغذی وضعیت بهتری دارد و بشدت کم ضرر تر است.)\nدر بخش اجماع بصورت جزیی تر به این مدل اجماع میپردازیم.\n12.3.1.1.2 world state # در شبکه اتریم یک استیت جهانی (شبیه به دفتر کل بیتکوین) وجود دارد. اطلاعاتی که تمامی نود ها بصورت یکپارچه از وضعیت ماشین مجازی اتریوم و حساب ها نگهداری میکنند همان ورلد استیت اتریوم است.\nتغییرت و تراکنش های اعمال شده در اطلاعات یک نود با دیگر نود ها در یک شبکه همتا به همتا صورت میگیرد (در ادامه به جزییات این شبکه بیشتر خواهیم پرداخت).\nگفتنی است که این تغییرات نیاز دارند تا در مرحله اجماع به تایید اکثریت نود ها برسند تا در استیت جهانی اعمال شوند. و پیام های رد و بدل شد در فرایند اجماع در همین شبکه همتا به همتا منتقل میشوند.\nراه ارتباطی کابر با نود های شبکه برای خواندن و نوشتن اطلاعات بر ورلد استیت یک API وب ۳ است.\nشما برای هر مدل از عملیات نوشتن نیاز به ایجاد یک تراکنش دارید که بسته به تراکنش و بار شبکه کارمزدی متفاوت دارد. اما برای خواندن اطلاعات از شبکه مثل اطلاعات یک بلاک یا حافظه یک قرارداد هوشمند کارمزدی در نظر گرفته نمیشود و نیازی به ایجاد تراکنش نیست و RPC هایی جهت اینکار اراعه میشود.\nایجاد تراکنش هم با اراعه تراکنش خام امضا شده به همین RPC صورت میگیرد.\n"},{"id":152,"href":"/chapter-12/ethereum/ethereum-cryptography/","title":"12.3.2 رمزنگاری","section":"12.3 شبکه اتریوم","content":"رمزنگاری\n"},{"id":153,"href":"/chapter-12/ethereum/ethereum-keys-and-addresses/","title":"12.3.3 آدرس ها و کلیدها","section":"12.3 شبکه اتریوم","content":"آدرس ها و کلیدها\n"},{"id":154,"href":"/chapter-12/ethereum/ethereum-accounts/","title":"12.3.4 اکانت ها","section":"12.3 شبکه اتریوم","content":"همانطور که میدانید اتریوم از مدل account based بجای UTXO استفاده میکند. اکانت ها در اتریوم، با شبکه بیتکوین تفاوت هایی اساسی دارند. اکانت های اتریوم بصورت کلی به دو دسته EOA و CA تقسیم میشوند. (external owned account) (contract account)\nدر ادامه به خصوصیات و جزییات هر یک از اکانت های کانترکت و اکانت های مالک خارجی (کنترل شده توسط شخص) میپردازیم.\n12.3.4.1 external owned accounts (EOA) # حساب های کنترل شده توسط افراد خارجی یا کنترل شده توسط شخص، حساب هایی معمولی هستند که توانایی نگهداری ارز اتر و انتقال ان با استفاده از ایجاد تراکنش بر روی شبکه را دارند.\nاین اکانت ها با یک کلید خصوصی کنترل میشوند.\nاین اکانت های دارای دو بخش هستند (هر ادرس یا کلید عمومی به یک فیلد دو بخشی از این اطلاعات در ورلد استیت اتریوم اشاره دارد.)\n12.3.4.1.1 nonce # مقدار اول یا عدد نانس یک شمارنده برای حساب مورد نظر است. در ازای هر تراکنش که حساب شما ایجاد میکند یک واحد به مقدار نانس اضافه میشود. برای مثال اگر نانس حساب شما ۱۳ باشد یعنی شما تا به حال ۱۴ تراکنش ایجاد کرده اید. (شمارش از ۰ شروع میشود) اما گفتنی است که خواندن اطلاعات یا تراکنش هایی که به حساب شما به عنوان مقصد صورت میگیرد تاثیری در نانس حساب شما ندارد.\nاما بحث اصلی خاصیت عدد نانس است. زمانی که حساب شما تراکنشی ایجاد میکند تراکنش مورد نظر شامل عدد نانس حساب مبدا هم میشود. در همین حین نود های اتریوم میتوانند بر اساس نانس تراکنش شما را از روی ترتیب این شمارنده اجرا کنند. (در شبکه اتریوم انتخاب تراکنش توسط نود ها پردازش انها بصورت کلی به ترتیب نیست و بستگی به نود ها و بار شبکه و تراکنش دارد. در بخش تراکنش به جزییات این مساله میپردازیم.) یعنی اگر سه تراکنش متوالی از طرف شما ثبت شود. به انها بر اساس نانس ترتیب بندی میشوند و با اینکه اجرای کل تراکنش ها به ترتیب نیست اما تراکنش های هر شخص باید دقیقا زمانی اجرا شوند که یک واحد به نانس فعلی اضافه کنند. و در این حالت ترتیب تراکنش های شما حفظ خواهد شد.\nاما یکی از کاربرد های اصلی نانس جلوگیری از حمله تکرار است. (reply attack) برای مثال اگر الیس به باب ۱ اتر انتقال دهد. و این تراکنش شامل نانس نشود. باب با پیدا کردن تراکنش امضا شده الیس بر بستر شبکه میتواند انرا تکرار کند و از موجودی حساب الیس کم کند. اما زمانی که در تراکنش امضا شده نانس هم قرار بگیرد هر تراکنش حتی با مقصد و مبدا و مبلغ ثابت هم از هم متمایز هستند. و زمانی که تراکنشی تکراری ثبت شود نانس مورد نظر با نانس حساب مبدا همخوانی ندارد. پس نود ها انرا رد میکنند. و باب نیاز دارد تا یک تراکنش جدید با نانس جدید داشته باشد.\n12.3.4.1.2 balance # مقدار دوم یک بالانس یا موجودی است که بطور خلاصه این بالانس مقدار موجودی یک حساب را به وی (wei) نمایش میدهد و نگهداری میکند.\n12.3.4.2 contract accounts (CA) # نوع دوم اکانت های اتریوم اکانت های قرار داد هوشمند است. این حساب ها قابلیت پردازش تراکنش و ایجاد تغییر در ورلد استیت را دارا هستند. این حساب ها بجای یک کلید خصوصی توسط یک کد EVM کنترل میشوند.\n12.3.4.2.1 nonce # نانس در کانترکت ها با عدد صفر شروع میشد که طی EIP-161 این عدد به یک تغییر کرد. بر خلاف حساب های عادی در حساب های کانترکت تنها زمانی نانس افزایش پیدا میکند که کانترکت یک کانترکت جدید بسازد.\nکانترکت ها میتوانند کانترکت های جدیدی بر روی شبکه مستقر کنند.\nهیچ کانترکتی نمیتواند مالک کانترکت دیگری باشد. اما زمانی که کاربری با یک تراکنش تابعی از یک کانترکت ایجاد میکند که کانترکتی دیگر ایجاد شود. نانس کانترکت افزایش پیدا میکند. و مالک کانترکت حساب ایجاد کننده تراکنش خواهد بود.\nهمچنین خوب است نگاهی به این رشته در وبسایت استک اکسچنج اتریوم بیندازید: https://ethereum.stackexchange.com/questions/764/do-contracts-also-have-a-nonce\n12.3.4.2.2 balance # حساب های کانترکت هم مثل حساب های شخصی یا EOA دارای موجودی هستند. که موجودی انها به واحد wei نگهداری میشود.\n12.3.4.2.3 code hash # همانطور که میدانید حساب های کانترکت شامل یک کد که توسط ماشین مجازی اتریوم قابل اجرا هستند را هم شامل میشوند. خود مقدار بایت کد های کانترکت در دیتابیس نود ها بصورت کلید و مقدار نگهداری میشود. در مقدار خود حساب در استیت جهانی یک هش از حساب نگهداری میشود. دلیل نگهداری شدن هش این است که زمانی که با تغییر نانس یا موجودی نیاز به محاسبه دوباره ریشه هش حساب (درخت مرکل) می باشد این محاسبه ارزان تر از محاسبه کل مقدار کد خواهد بود.\nبا این روش ما کد مربوط به حساب را میتوانیم در دیتابیس نود پیدا کنیم. انرا اعبتار سنجی کنیم که یک کد مربوط به ان حساب اجرا خواهد شد. و در نهایت حین محسابیه ریشه هش درخت مرکل حساب هزینه کمی صرف خواهیم کرد.\n12.3.4.2.4 storage root # همانطور که اشاره کردیم هر کانترکت به یک دیتابیس با مدل مقدار و کلید (key/value) دسترسی دارد. این مقادیر در دیتابیس نود ها نگهداری میشوند. ریشه درخت مرکل این دیتا ها (مربوط به همان کانترکت خاص فقط) در این بخش نگهداری میشود. علت نگهداری این هش مشابه نگهداری هش کد کانترکت است.\nبا این روت هش میتوان فضای ذخیره سازی کانترکت را اعتبار سنجی کرد. تغییر ان را تشخیص داد و همچنین از جایی که یک روت هش از ان داریم محسابه روت هش خود حساب را ارزان نگه میدارد.\n12.3.4.3 address # آدرس های حساب های شخصی و کانترکت تفاوت هایی دارند. در بخش کلید ها و ادرس بصورت جزیی انهارا بررسی کرده ایم. اما در این بخش هم توضیحی خلاصه جهت تکمیل مطلب خواهیم داشت.\n12.3.4.3.1 EOA # ادرس در اکانت های شخصی از هش شدن کلید عمومی بدست می آید. که طول ان ۶۴ کاراکتر بر مبنای ۱۶ است.\n12.3.4.3.2 CA # ادرس حساب های کانترکت از هش ادرس حساب مالک (حساب شخصی که تراکنش استقرار کانترکت را ایجاد میکند.) و عدد نانس همان حساب بدست می اید که طول ان ۴۲ کاراکتر بر مبنای ۱۶ است.\n12.3.4.4 ادرس صفر # آدرس صفر در شبکه اتریوم یک ادرس است که همراه با ایجاد اولین بلاک ایجاد میشود. این آدرس یک حساب شخصی یا کانترکت نیست و هیچ کلید خصوصی و مالکی هم ندارد. همچنین هیچ خروجی یا تراکنشی از این آدرس به بیرون وجود ندارد.\n"},{"id":155,"href":"/chapter-12/ethereum/ethereum-transactions-and-messages/","title":"12.3.5 تراکنش ها و پیام ها","section":"12.3 شبکه اتریوم","content":" 12.3.5.1 تراکنش ها در بلاکچین اتریوم # تراکنش ها در شبکه اتریوم دارای خصوصیاتی متفاوت از تراکنش ها در بیتکوین هستند. علل اصلی این تفاوت ها روش متفاوت اتریوم برای جلوگیری از برخی از حملات و همچنین نیاز به مناسب بودن برای اجرا کانترکت ها در ازای تراکنش ها می باشد.\nدر اتریوم تراکنش ها بصورت اتمیک هستند. یعنی ما نمیتوانیم یک تراکنش را به قسمت های دیگری تقسیم و بصورت جدا اجرا و اراعه کنیم. همچنین وضعیت یک تراکنش در اتریوم تنها دو حالت میتوانند داشته باشند. یا انجام شده اند و تغییری برروی ورلد استیت ایجاد کرده اند یا انجام نشده و اثری بر شبکه ندارند.\nدر شبکه اتریوم تراکنش ها بصورت ترتیبی و اجرا شوند و هیچ دو تراکنشی بصورت همزمان اجرا و پردازش نمیشوند. همچنین تراکنش ها در اتریوم قابلیت همپوشانی ندارند.\n12.3.5.1.1 فیلد های یک تراکنش در اتریوم # اولین مقدار در یک تراکنش اتریومی نانس است. که در بخش حساب ها به ان پرداختیم. نانس یک عدد است که نشان میدهد چندمین تراکنشی است که توسط این حساب ایجاد میشود و تراکنش هایی با اطلاعات یکسان را متمایز میسازد که روشی جایگزین برای مقابله با reply attack.\nهمانطور که میدانید بیتکوین از lock-time برای مقابله از این حمله استفاده میکند.\nدومین مقدار هر تراکنش قیمت gas میباشد. در اصل مبلغی است که ایجاد کننده تراکنش حاضر است در ازای هر gas بپردازد.\nسومین بخش محدودیت تعداد مراحل محساباتی است که برای اجرا تراکنش توسط ارسال کننده مشخص میشود. علت استفاده از این فیلد مدل Anti-DOS اتریوم میباشد. برتی مثال جلوگیری از ایجاد حلقه های بینهایت و یا هدر دادن منابع پردازشی.\nفیلد بعدی نشان دهنده آدرس مقصد تراکنش است. و بعد از آن مبلغ اتری که با این تراکنش جابه جا میشود.\nدر نهایت فیلد دیتا که یک فیلد اختیاری است (در استقرار و صدا زدن قرارداد های هوشمند کاربرد دارد) شامل اطلاعاتی میشود که کانترکت مورد نظر میتواند انهارا بخواند. برای مثال اگر شما بخواهید یک رکورد ENS برای ایپی ادرس خود ثبت کنید در این قسمت از تراکنش خود ایپی و نام ENS خود را در صدا زدن کانترکت ENS قرار میدهید.\nهمچنین تراکنش هایی که برای ایجاد یک قرارداد هوشمند جدید اجرا میشوند هم بایت کد های قرارداد هوشمند در این فیلد قرار میگیرد.\nاضافه کردن دیتا در این بخش مقدار gas را افزایش خواهد داد.\n12.3.5.1.2 انواع تراکنش در اتریوم # تراکنش هادر شبکه اتریوم به دو دسته تقسیم می شوند. دسته اول تراکنش هایی هستند که باعث ایجاد و یا همان استقرار یک قرارداد هوشمند جدید بر روی شبکه میشوند. دربخش های قبل به این مدل از تراکنش ها بصورت خلاصه پرداخته ایم.\nاین تراکنش ها در فیلد دیتا یک بایت کد معتبر EVM ای را شامل میشوند. ارسال کننده یا ادرس مقصد این تراکنش ها همیشه یک EOA میباشد که در نهایت مالک ان قرار داد به شمار می اید.\nمقصد این تراکنش ها ادرس صفر است.\nدسته دوم تراکنش ها در اتریوم تراکنش های message call است.\nدر این تراکنش ها معمولا یا یک تابع در یک قرار داد هوشمند صدا زده میشود و یا یک جابه جایی اتر بین دو حساب شخصی صورت میگیرد.\n12.3.5.1 پیام ها در بلاکچین اتریوم # مثال و درک بهتر # در نهایت برای درک بهتر مفهایم تراکنش و پیام ها در شبکه اتریوم (یا هر مفهوم دیگری در هر شبکه دیگیری) بررسی کردن بلاک اکسپلورر آن شبکه و دیدن این موارد در حالت بصری کمک خیلی خوبی به درک این مساعل میکند. همچنین میتوانید با ایجاد یک حساب اتریوم در تست نت های اتریوم این موارد را بصورت عملی تست کنید. (در بخش های اینده به این مورد خواهیم پرداخت)\nEthereum Block explorer\nارجاعات # 1- Messages and Transactions on Ethereum\n"},{"id":156,"href":"/chapter-12/ethereum/ethereum-virtual-machine/","title":"12.3.6 ماشین مجازی اتریوم","section":"12.3 شبکه اتریوم","content":" 12.3.6.1 ماشین مجازی # قبل از شروع بررسی ماشین مجازی اتریوم به مفهوم ماشین مجازی میپردازیم. همانطور که در قسمت های قبل به ورلد استیت اتریوم اشاره کردیم و فهمیدیم که تمام نود های اتریوم یک حافظه وضعیت و یا حالت کلی دارند که همیشه باهم برابر است و در حالت یکسانی قرار دارد و تغییرات بر ورلد استیت با تراکنش ها اعمال میشوند.\nاما تمام شبکه اتریوم به خودی خود یه ورلد کامپیوتر هم میباشد که باید بتواند تمام تراکنش ها را اجرا کند و تغییرات انها را بر روی ورلد استیت اعمال کند. پس اصلی ترین رکن این ورلد کامپیوتر این است که در هر زمان توسط هر کدام از نود ها که اجرا شد خروجی برابری بدهد. (این مساله یکی از دلایلی است که با عدد نانس ترتیب تراکنش ها حفظ میشود و ماشین مجازی اتریوم قابلیت همزمانی را ندارد.)\nیک ماشین مجازی به زبان ساده یک محیط ایزوله درون یک سیستم عامل در حال اجرا بر روی یک کامپیوتر واقعی است که منابع اختصاصی خود را دارد و بدون گرفتن تاثیر از بقیه نرم افزار ها یا شرایط کامپیوتر اجرا میشود.\nبا این شرایط بهترین انتخاب ما برای اجرای کد ها بر بستر بلاکچین ماشین های مجازی هستند. با استفاده از یک ماشین مجازی قرارداد های هوشمند تنها نیاز دارند به بایت کد های قابل درک برای evm کامپایل شوند نه بایت کد های مربوط به هر معماری پردازشگری که در لحظه نود اتریوم را اجرا میکند. همچنین اطمینان داریم که اگر یک تراکنش توسط دو نود مختلف با شرایط مختلف اجرا شد خروجی ورلد استیت انها یکی خواهد بود.\n12.3.6.2 ماشین مجازی اتریوم # اتریوم یک ماشین مجازی مختص خود دارد که وظیفه اجرا و اعمال تغییرات تراکنش هارا دارد. این ماشین مجازی را میتوان به JVM یا ماشین مجازی جاوا هم تشبیه کرد. که بایت کد های مخصوص خود را دارد و هر محیط که ماشین مجازی مورد نظر را داشته باشد میتواند ان کد را بدون نیاز به بایت کد های متفاوت اجرا کند.\nماشین مجازی اتریوم یک ماشین مجازی استک بیس است.\nحافظه های در دسترسی یک ماشین مجازی اتریوم حین اجرا هر کانترکت به سه دسته تقسیم میشوند. مموری. استک و استورج.\nمموری یک حافظه موقت در حین اجرا کانترکت است. استورج یک حافظه داعمی است که نوشتن اطلاعات در استورج هزینه بالاتری دارد.(استورج بصورت کلید و مقدار است)\nو در نهایت استک یک حافظه موقت استیک بیس است که توسط کامپایلر استفاده میشود.\nبیشتر\n12.3.6.2.1 کد های قابل اجرا # ماشین مجازی اتریوم بایت کد های مربوط به خود را دارد. در بخش های اینده به این بایت کد ها در جزییات میپردازیم. اما بصورت کلی این بایت کد ها همان کد هایی هستند که بر بستر شبکه اتریوم دیپلوی و اجرا میشوند.\nاین بایت کد ها در حالت اسمبلی بصورت مجموعه ای از OP code ها یا اوپریشن کد ها نوشته میشوند که هر اوپریشن کد با یک عدد مشخص میشود. بایت کد های اتریوم شماره اوپریشن کد ها و ورودی انها بصورت هگزادسیمال است. که توسط ماشین مجازی اتریوم قابل درک و اجرا میباشد. در بخش مربوط به بایت کد ها به جزییاتشان خواهیم پرداخت.\nنمونه ای از اوپریشن کد ها یک کانترکت ERC-20:\n‍``` PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH2 0x000f JUMPI PUSH0 0x DUP1 REVERT JUMPDEST POP PUSH1 0x04 CALLDATASIZE LT PUSH2 0x00cd JUMPI PUSH0 0x CALLDATALOAD PUSH1 0xe0\nنمونه بایت کد های همان کانترکت: ‍``` 0x608060405234801561000f575f80fd5b50600436106100cd575f3560e01c806370a082311161008a57806395d89b411161006457806395d89b411461022d578063a9059cbb1461024b578063d505accf1461027b578063dd62ed3e14610297576100cd565b806370a08231146101a95780637ecebe00146101d957806384b0196e14610209576100cd565b806306fdde03146100d1578063095ea7b3146100ef57806318160ddd1461011f57806323b872dd1461013d578063313ce5671461016d5780633644e5151461018b575b5f80fd5b6100d96102c7565b6040516100e691906113de565b60405180910390f35b6101096004803603810190610104919061148f565b610357565b60405161011691906114e7565b60405180910390f35b610127610379565b604051610134919061150f565b60405180910390f35b61015760048036038101906101529190611528565b610382565b60405161016491906114e7565b60405180910390f35b6101756103b0565b6040516101829190611593565b60405180910390f35b6101936103b8565b6040516101a091906115c4565b60405180910390f35b6101c360048036038101906101be91906115dd565b6103c6565b6040516101d0919061150f565b60405180910390f35b6101f360048036038101906101ee91906115dd565b61040b565b604051610200919061150f565b60405180910390f35b61021161041c565b6040516102249796959493929190611708565b60405180910390f35b6102356104c1565b60405161024291906113de565b60405180910390f35b6102656004803603810190610260919061148f565b610551565b60405161027291906114e7565b60405180910390f35b610295600480360381019061029091906117de565b610573565b005b6102b160048036038101906102ac919061187b565b6106b8565b6040516102be919061150f565b60405180910390f35b6060600380546102d6906118e6565b80601f0160208091040260200160405190810160405280929190818152602001828054610302906118e6565b801561034d5780601f106103245761010080835404028352916020019161034d565b820191905f5260205f20905b81548152906001019060200180831161033057829003601f168201915b5050505050905090565b5f8061036161073a565b905061036e818585610741565b600191505092915050565b5f600254905090565b5f8061038c61073a565b9050610399858285610753565b6103a48585856107e5565b60019150509392505050565b5f6012905090565b5f6103c16108d5565b905090565b5f805f8373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f20549050919050565b5f6104158261098b5... 12.3.6.2.2 محیط اجرا # بایت کد های اتریوم توسط ماشین مجازی اتریوم اجرا میشوند که خود بخشی از پیاده سازی نود اتریوم است. نود درحال اجرا هم بصورت مستقیم از منابع یک ماشین غیر مجازی استفاده میکند.\n12.3.6.2.3 پیاده سازی GETH # تمامی عملکرد ماشین مجازی اتریوم در پیاده سازی رسمی اتریوم در این بخش قرار دارد:\nhttps://github.com/ethereum/go-ethereum/blob/master/core/vm\nبرای مثال تعریف اوپریشن کد ها:\nhttps://github.com/ethereum/go-ethereum/blob/master/core/vm/opcodes.go\nساختار ماشین مجازی اتریوم در پیاده سازی گو اتریوم:\n// EVM is the Ethereum Virtual Machine base object and provides // the necessary tools to run a contract on the given state with // the provided context. It should be noted that any error // generated through any of the calls should be considered a // revert-state-and-consume-all-gas operation, no checks on // specific errors should ever be performed. The interpreter makes // sure that any errors generated are to be considered faulty code. // // The EVM should never be reused and is not thread safe. type EVM struct { // Context provides auxiliary blockchain related information Context BlockContext TxContext // StateDB gives access to the underlying state StateDB StateDB // Depth is the current call stack depth int // chainConfig contains information about the current chain chainConfig *params.ChainConfig // chain rules contains the chain rules for the current epoch chainRules params.Rules // virtual machine configuration options used to initialise the // evm. Config Config // global (to this context) ethereum virtual machine // used throughout the execution of the tx. interpreter *EVMInterpreter // abort is used to abort the EVM calling operations abort atomic.Bool // callGasTemp holds the gas available for the current call. This is needed because the // available gas is calculated in gasCall* according to the 63/64 rule and later // applied in opCall*. callGasTemp uint64 } با بررسی پروژه های دیگر متوجه پیاده سازی های مختلفی از ماشین مجازی اتریوم در زبان های جاوااسکریپت راست و \u0026hellip; خواهید شد.\n"},{"id":157,"href":"/chapter-12/ethereum/ethereum-blocks/","title":"12.3.7 بلاک ها","section":"12.3 شبکه اتریوم","content":"بلاک ها\n"},{"id":158,"href":"/chapter-12/ethereum/ethereum-consensus/","title":"12.3.8 الگوریتم اجماع","section":"12.3 شبکه اتریوم","content":"الگوریتم اجماع\n"},{"id":159,"href":"/chapter-12/ethereum/ethereum-nodes-and-miners/","title":"12.3.9 نودها و ماینرها","section":"12.3 شبکه اتریوم","content":"نودها و ماینرها\n"},{"id":160,"href":"/chapter-12/ethereum/ethereum-network/","title":"12.3.10 شبکه","section":"12.3 شبکه اتریوم","content":"شبکه\n"},{"id":161,"href":"/chapter-12/ethereum/ethereum-smart-contracts/","title":"12.3.11 قراردادهای هوشمند","section":"12.3 شبکه اتریوم","content":"قراردادهای هوشمند\n"},{"id":162,"href":"/chapter-12/ethereum/ethereum-wallets-and-clients/","title":"12.3.12 والت ها و کلاینت ها","section":"12.3 شبکه اتریوم","content":"والت ها و کلاینت ها\n"},{"id":163,"href":"/chapter-12/ethereum/go-ethereum/","title":"12.3.13 معرفی go-ethereum","section":"12.3 شبکه اتریوم","content":"معرفی go-ethereum\n"},{"id":164,"href":"/chapter-12/ethereum/work-with-accounts/","title":"12.3.14 کار با اکانت ها","section":"12.3 شبکه اتریوم","content":"کار با اکانت ها\n"},{"id":165,"href":"/chapter-12/ethereum/transactions-on-ethereum/","title":"12.3.15 تراکنش برروی اتریوم","section":"12.3 شبکه اتریوم","content":"تراکنش برروی اتریوم\n"},{"id":166,"href":"/chapter-12/ethereum/read-write-in-smart-contracts/","title":"12.3.16 نوشتن و ارتباط با قراردادهای هوشمند","section":"12.3 شبکه اتریوم","content":"نوشتن و ارتباط با قراردادهای هوشمند\n"},{"id":167,"href":"/chapter-12/ethereum/abi-and-bin-file/","title":"12.3.17 آشنایی با فایل ABI و bytecode","section":"12.3 شبکه اتریوم","content":"آشنایی با فایل ABI و bytecode\n"},{"id":168,"href":"/chapter-12/ethereum/event-logs/","title":"12.3.18 خواندن و دریافت لحظه ای لاگ های کانترکت ها","section":"12.3 شبکه اتریوم","content":"خواندن و دریافت لحظه ای لاگ های کانترکت ها\n"},{"id":169,"href":"/chapter-12/ethereum/signature/","title":"12.3.19 ایجاد و تایید امضا","section":"12.3 شبکه اتریوم","content":"ایجاد و تایید امضا\n"},{"id":170,"href":"/chapter-12/ethereum/geth/","title":"12.3.20 کار با geth","section":"12.3 شبکه اتریوم","content":"کار با geth\n"},{"id":171,"href":"/chapter-12/ethereum/protocol-swarm-and-whisper/","title":"12.3.21 کار با پروتکل whisper و swarm","section":"12.3 شبکه اتریوم","content":"کار با پروتکل whisper و swarm\n"},{"id":172,"href":"/chapter-12/pactus/","title":"12.4 شبکه پکتوس","section":"فصل دوازدهم: شبکه بلاکچین","content":"در این بخش به بحث شبکه پکتوس می پردازیم\u0026hellip;\n"},{"id":173,"href":"/chapter-12/pactus/pactus/","title":"12.4.1 معرفی پکتوس","section":"12.4 شبکه پکتوس","content":"معرفی پکتوس\n"},{"id":174,"href":"/chapter-12/pactus/pactus-roadmap/","title":"12.4.2 نقشه راه و اهداف","section":"12.4 شبکه پکتوس","content":"نقشه راه و اهداف\n"},{"id":175,"href":"/chapter-12/pactus/pactus-cryptography/","title":"12.4.3 رمزنگاری","section":"12.4 شبکه پکتوس","content":"رمزنگاری\n"},{"id":176,"href":"/chapter-12/pactus/pactus-addresses-and-keys/","title":"12.4.4 آدرس ها و کلیدها","section":"12.4 شبکه پکتوس","content":"آدرس ها و کلیدها\n"},{"id":177,"href":"/chapter-12/pactus/pactus-accounts/","title":"12.4.5 اکانت ها","section":"12.4 شبکه پکتوس","content":"اکانت ها\n"},{"id":178,"href":"/chapter-12/pactus/pactus-transactions-and-messages/","title":"12.4.6 تراکنش ها و پیغام ها","section":"12.4 شبکه پکتوس","content":"تراکنش ها و پیغام ها\n"},{"id":179,"href":"/chapter-12/pactus/pactus-consensus/","title":"12.4.7 الگوریتم اجماع","section":"12.4 شبکه پکتوس","content":"الگوریتم اجماع\n"},{"id":180,"href":"/chapter-12/pactus/pactus-client/","title":"12.4.8 کار با کلاینت","section":"12.4 شبکه پکتوس","content":"کار با کلاینت\n"},{"id":181,"href":"/chapter-12/pactus/pactus-smart-contracts/","title":"12.4.9 قراردادهای هوشمند (بزودی)","section":"12.4 شبکه پکتوس","content":"قراردادهای هوشمند (بزودی)\n"},{"id":182,"href":"/chapter-9/creational-patterns/go-singleton-pattern/","title":"9.1.1 الگو Singleton","section":"9.1 الگوهای طراحی سازنده","content":"سینگلتون یک الگوی طراحی سازنده است که به شما این اجازه را می‌دهد، تنها یک شی از ساختار خود را با دسترسی سراسری ایجاد کنید.\nالگوی طراحی سینگلتون:\nاطمینان می‌دهد که تنها یک شی از یک ساختار ایجاد می‌شود. مشابه یک متغیر سراسری، به شما امکان می‌دهد از هر جای برنامه به آن شی دسترسی داشته باشید و از بازنویسی توسط نقاط دیگر برنامه نیز محافظت می‌کند. از الگوی سینگلتون زمانی استفاده کنید که بخواهید تنها یک شی از یک ساختار در دسترس کل برنامه باشد. به عنوان مثال، می‌توانید از الگوی سینگلتون برای ایجاد یک شی واحد از لاگر استفاده کنید که توسط بخش‌های مختلف برنامه به آن دسترسی دارند. مثال مفهومی از الگوی سینگلتون:\npackage main import ( \"fmt\" \"sync\" \"time\" ) type MyLogger struct { } var ( globalLogger *MyLogger mu = \u0026sync.Mutex{} ) func GetMyLoggerInstance(i int) *MyLogger { if globalLogger == nil { mu.Lock() defer mu.Unlock() if globalLogger == nil { fmt.Println(\"creating myLogger instance by\", i) globalLogger = \u0026MyLogger{} } } else { fmt.Println(\"myLogger instance already created.\") } return globalLogger } func main() { for i := 1; i \u003c= 5; i++ { go GetMyLoggerInstance(i) } time.Sleep(time.Second) } ▶ اجرای کد کپی ✖ بستن خروجی روش‌ دیگری نیز برای ایجاد یک شی توسط الگوی سینگلتون در زبان گو وجود دارد:\npackage main import ( \"fmt\" \"sync\" \"time\" ) type MyLogger struct { } var ( globalLogger *MyLogger once sync.Once ) func GetMyLoggerInstance(i int) *MyLogger { if globalLogger == nil { once.Do( func() { fmt.Println(\"creating myLogger instance by\", i) globalLogger = \u0026MyLogger{} }) } else { fmt.Println(\"myLogger instance already created.\") } return globalLogger } func main() { for i := 1; i \u003c= 5; i++ { go GetMyLoggerInstance(i) } time.Sleep(time.Second) } ▶ اجرای کد کپی ✖ بستن خروجی مزایا: ✅ اطمینان می‌دهد که تنها یک شی از ساختار وجود دارد. ✅ دسترسی سراسری به آن شی را فراهم می‌کند. ✅ شی فقط در صورت نیاز به آن ایجاد و مقداردهی می‌شود.\nمعایب: ❌ اصل مسئولیت واحد را نقض می‌کند و ممکن است باعث پیچیدگی در کد شود. ❌ در برنامه‌های ماتی ترد ، پیاده‌سازی الگوی سینگلتون نیاز به رویکردهای خاص دارد و این ممکن است پیچیدگی را افزایش دهد.\n"},{"id":183,"href":"/chapter-9/creational-patterns/go-factory-method-pattern/","title":"9.1.2 الگو Factory Method","section":"9.1 الگوهای طراحی سازنده","content":"الگو Factory Method\u0026hellip;\n"},{"id":184,"href":"/chapter-9/creational-patterns/go-prototype-pattern/","title":"9.1.3 الگو Prototype","section":"9.1 الگوهای طراحی سازنده","content":"الگو Prototype\u0026hellip;\n"},{"id":185,"href":"/chapter-9/creational-patterns/go-abstract-factory-pattern/","title":"9.1.4 الگو Abstract Factory","section":"9.1 الگوهای طراحی سازنده","content":"الگو Abstract Factory\u0026hellip;\n"},{"id":186,"href":"/chapter-9/creational-patterns/go-builder-pattern/","title":"9.1.6 الگو Builder","section":"9.1 الگوهای طراحی سازنده","content":"الگو Builder\u0026hellip;\n"},{"id":187,"href":"/chapter-9/creational-patterns/go-object-pool-pattern/","title":"9.1.7 الگو Object Pool","section":"9.1 الگوهای طراحی سازنده","content":"الگو Object Pool\u0026hellip;\n"},{"id":188,"href":"/chapter-9/structural-patterns/go-adaptor-pattern/","title":"9.2.1 الگو Adaptor","section":"9.2 الگوهای طراحی ساختاری","content":"الگو Adaptor الگوی adapter یک الگوی ساختاری است که برای سازگار کردن موجودیت های مختلف با هم به کار می‌رود.\nداده ها در دنیای دیجیتال به فرمت‌های مختلف ذخیره و پردازش می‌شوند. این تفاوت در لایه‌ها و فرمت‌های مختلف نمایان و آشکار است. نمونه واضح و پرکاربرد آن فرمت‌های مختلفی مانند json و xml و باینری\u0026hellip; است که در پروتکل‌های ارتباطی متفاوت مورد استفاده قرار می‌گیرد و گاها برای ایجاد ارتباط و امکان خوانده شدن این داده‌ها نیازمند یک روش و الگوی قابل گسترش هستیم.\nالگوی adapter در اینجا مورد استفاده قرار می‌گیرد. نحوه پیاده سازی این الگو در زبان گو به اینصورت است که ابتدا یک struct مادر به همراه متد یا متدهای مورد نیاز ما که مابین موجودیت‌های متفاوت مشترک است تعریف می‌شود. همزمان برای هر فرمت داده یک struct جهت سازگار کردن داده‌ها ساخته می شود. متدهای این strcut توسط یک interface فراخوانی شده است. در اینجا کافی است که این interface را به عنوان ورودی متدهای struct مادر درنظر بگیریم. اینکار باعث ایجاد ارتباط میان struct ها و موجودیت های مختلف خواهد شد.\nدر زیر مثالی از پیاده سازی این الگو انجام گرفته است. در این مثال دو دستگاه پرینتر متفاوت وظیفه چاپ بر روی کاغذ با یک ابعاد خاص و مشخص (A4) را دارند در صورتی که هیچکدام بصورت اختصاصی این ابعاد را پشتیبانی نمیکنند بنابراین ما با پیاده سازی الگوی adapter این امکان را ایجاد میکنیم که این تفاوت ابعاد در داخل هر موجودیت مدیریت شود و فقط متد چاپ در ابعاد A4 فراخوانی شود.\npackage main type IPrint interface{ PrintA4() } type Printer struct {} func (p Printer) Print(printer IPrint) { printer.PrintA4() } // HP Printer type HpPrinter struct {} func (h HpPrinter) PrintWithHP() { println(\u0026quot;print with HP printer\u0026quot;) } type HpAdapter struct { printer *HpPrinter } func (ha HpAdapter) PrintA4() { println(\u0026quot;adapting to A4 size for HP printer\u0026quot;) //some adapting functions ha.printer.PrintWithHP() } // Canon Printer type CanonPrinter struct {} func (c CanonPrinter) PrintWithCanon() { println(\u0026quot;print with Canon printer\u0026quot;) } type CanonAdapter struct{ printer *CanonPrinter } func (ca CanonAdapter) PrintA4() { println(\u0026quot;adapting to A4 size for Canon printer\u0026quot;) //some adapting functions ca.printer.PrintWithCanon() } func main() { hpPrinter := \u0026amp;HpPrinter{} hpAdapter := HpAdapter{ printer: hpPrinter, } canonPrinter := \u0026amp;CanonPrinter{} canonAdapter := CanonAdapter{ printer: canonPrinter, } printer := Printer{} printer.Print(hpAdapter) printer.Print(canonAdapter) } adapting to A4 size for HP printer print with HP printer adapting to A4 size for Canon printer print with Canon printer ۱− در مثال بالا ما برای هر پرینتر یک struct به عنوان adapter ایجاد کرده ایم (خطوط 21 و 39) ۲− این struct ها متدی به نام PrintA4 را تعریف می‌کنند‌ که وظیفه تغییر داده ها به فرمت مشترک مورد نظر را دارند (خطوط 25 و 43) ۳− این متد در یک اینترفیس به نام IPrint نیز فراخوانی می‌شود (خط 5) ۴− در این مرحله یک struct به نام Printer ایجاد میکنیم (خط 8) ۵− در مرحله آخر متد اصلی که وظیفه Print کردن کاغذ برای هر پیرنتری را دارد تعریف میکنیم. نکته مهم ورودی این متد است که همان interface تعریف شده در مرحله 3 می باشد. ۶− مرحله آخر تغریف هر پرینتر و printerAdapter در خطوط 52 تا 61 است و درنهایت فراخوانی متد تعریف شده در مرحله 5 برای هر پرینتر در خطوط 64 و 65.\n"},{"id":189,"href":"/chapter-9/structural-patterns/go-bridge-pattern/","title":"9.2.2 الگو Bridge","section":"9.2 الگوهای طراحی ساختاری","content":"الگو Bridge\u0026hellip;\n"},{"id":190,"href":"/chapter-9/structural-patterns/go-composite-pattern/","title":"9.2.3 الگو Composite","section":"9.2 الگوهای طراحی ساختاری","content":"الگو Composite\u0026hellip;\n"},{"id":191,"href":"/chapter-9/structural-patterns/go-decorator-pattern/","title":"9.2.1 الگو Decorator","section":"9.2 الگوهای طراحی ساختاری","content":"الگو Decorator\u0026hellip;\n"},{"id":192,"href":"/chapter-9/structural-patterns/go-facade-pattern/","title":"9.2.5 الگو Facade","section":"9.2 الگوهای طراحی ساختاری","content":"الگو Facade\u0026hellip;\n"},{"id":193,"href":"/chapter-9/structural-patterns/go-flyweight-pattern/","title":"9.2.6 الگو Flyweight","section":"9.2 الگوهای طراحی ساختاری","content":"الگو Flyweight\u0026hellip;\n"},{"id":194,"href":"/chapter-9/structural-patterns/go-proxy-pattern/","title":"9.2.7 الگو Proxy","section":"9.2 الگوهای طراحی ساختاری","content":"الگو Proxy\u0026hellip;\n"},{"id":195,"href":"/chapter-9/behavioral-patterns/go-chain-of-responsibility-pattern/","title":"9.3.1 الگو Chain Of Responsibility","section":"9.3 الگوهای طراحی رفتاری","content":" 9.3.1.1 - الگوی زنجیره مسئولیت (Chain of Responsibility) # الگوی زنجیره مسئولیت (Chain of Responsibility) یک الگوی طراحی رفتاری است که به شما امکان می‌دهد درخواست‌ها را در امتداد زنجیره‌ای از هندلرها (handlers) پاس دهید. هر هندلر پس از دریافت یک درخواست، تصمیم می‌گیرد که درخواست را پردازش کند یا آن را به هندلر بعدی در زنجیره منتقل نماید.\n9.3.1.2 - مشکل # فرض کنید روی یک سیستم سفارش آنلاین کار می‌کنید. می‌خواهید دسترسی به سیستم را محدود کنید تا فقط کاربران احراز هویت شده بتوانند سفارش ایجاد کنند. همچنین، کاربرانی که دارای مجوز مدیریت هستند باید دسترسی کامل به تمام سفارشات داشته باشند.\nبعد از کمی برنامه‌ریزی، متوجه می‌شوید که این بررسی‌ها باید به صورت متوالی انجام شوند. برنامه می‌تواند هر زمان درخواستی را که حاوی اعتبارنامه (credentials) کاربر است دریافت می‌کند، تلاش کند کاربر را در سیستم احراز هویت کند. با این حال، اگر این اعتبارنامه‌ها صحیح نباشند و احراز هویت با شکست مواجه شود، دلیلی برای ادامه سایر بررسی‌ها وجود ندارد.\nدر ماه‌های بعد، چندین مورد دیگر از این بررسی‌های متوالی را پیاده‌سازی کردید.\nیکی از همکاران شما پیشنهاد کرده است که انتقال مستقیم داده‌های خام به سیستم سفارش‌دهی ناامن است. بنابراین، یک مرحله اعتبارسنجی اضافی برای تجزیه وتحلیل کردن داده‌ها در یک درخواست اضافه کردید.\nبعداً، کسی متوجه شد که سیستم در برابر کرک رمز عبور با brute force آسیب‌پذیر است. برای جلوگیری از این، به سرعت یک بررسی برای فیلتر کردن درخواست‌های ناموفق مکرر از یک آدرس IP مشابه اضافه کردید.\nفرد دیگری پیشنهاد کرد که با بازگرداندن نتایج کَش (cache) شده در درخواست‌های تکراری حاوی داده‌های یکسان، می‌توانید سرعت سیستم را افزایش دهید. از این رو، یک بررسی دیگر اضافه کردید که به درخواست اجازه می‌دهد تنها در صورتی که پاسخ کَش شده مناسبی وجود نداشته باشد، به سیستم منتقل شود.\nکد مورد بررسی که از قبل هم آشفته‌تر به نظر می‌رسد، با اضافه شدن هر قابلیت جدید، بیشتر و بیشتر آشفته می‌شود. تغییر یک قسمت گاهی اوقات بر سایر قسمت‌ها تأثیر می‌گذاشت. بدترین حالت این بود که وقتی می‌خواستید از این بررسی‌ها برای محافظت از دیگر اجزای سیستم استفاده‌ی مجدد کنید، مجبور بودید بخشی از کد را تکرار کنید، زیرا آن اجزا به برخی از بررسی‌ها نیاز داشتند، اما نه به همه‌ی آن‌ها. درک و نگهداری این سیستم بسیار دشوار و پرهزینه است. پس مدت زمانی با کد درگیر بودید تا اینکه یک روز تصمیم گرفتید کل سیستم را بازنگری (refactor) کنید.\n9.3.1.3 - راه حل # الگوی زنجیره مسئولیت، مانند بسیاری دیگر از الگوهای طراحی رفتاری، بر تبدیل رفتارهای خاص به اشیاء مستقل به نام هندلر (handler) تکیه دارد. در این مورد، هر بررسی باید به کلاس خود با یک روش واحد که بررسی را انجام می دهد استخراج شود. درخواست، همراه با داده‌های آن، به عنوان آرگومان به این متد منتقل می‌شود.\nاین الگو پیشنهاد می‌کند که این هندلرها را به یک زنجیره متصل کنید. هر هندلر متصل دارای فیلدی برای ذخیره مرجع به هندلر بعدی در زنجیره است. هندلرها علاوه بر پردازش یک درخواست، آن را در امتداد زنجیره به جلو منتقل می کنند. درخواست در امتداد زنجیره حرکت می کند تا زمانی که همه هندلرها فرصت پردازش آن را پیدا کنند.\nبهترین بخش اینجاست: یک هندلر می تواند تصمیم بگیرد که درخواست را بیشتر به پایین زنجیره منتقل نکند و عملاً پردازش بیشتر را متوقف کند.\nدر مثال ما با سیستم‌های سفارش، یک هندلر پردازش را انجام می‌دهد و سپس تصمیم می‌گیرد که آیا درخواست را در امتداد زنجیره به پایین منتقل کند یا خیر. با فرض اینکه درخواست حاوی داده‌های صحیح باشد، همه هندلرها می‌توانند رفتار اصلی خود را اجرا کنند، چه این بررسی مربوط به احراز هویت باشد یا ذخیره‌سازی در کَش.\nبا این حال، رویکرد کمی متفاوت دیگری وجود دارد که در آن، یک هندلر پس از دریافت یک درخواست، تصمیم می‌گیرد که آیا می‌تواند آن را پردازش کند. اگر بتواند پردازش را انجام دهد، دیگر آن را به هیچ وجه به جای دیگر منتقل نمی‌کند. پس فقط یک هندلر درخواست را پردازش می‌کند یا اصلاً هیچ کدام را در نظر نمی‌گیرد. این رویکرد هنگام برخورد با رویدادها در پشته‌های عناصر درون یک رابط کاربری گرافیکی (GUI) بسیار رایج است.\nبرای مثال، هنگامی که کاربر روی یک دکمه کلیک می‌کند، رویداد از طریق زنجیره‌ای از عناصر رابط کاربری منتشر می‌شود که از دکمه شروع می‌شود، در امتداد کانتینرهای(containers) آن (مانند فرم‌ها یا پنل‌ها) حرکت می‌کند و به پنجره اصلی برنامه ختم می‌شود. رویداد توسط اولین عنصر در زنجیره که قادر به رسیدگی به آن است، پردازش می‌شود. این مثال همچنین قابل توجه است زیرا نشان می دهد که همیشه می توان یک زنجیره را از یک درخت شیء (object tree) استخراج کرد.\nبسیار مهم است که همه کلاس‌های هندلر یک رابط مشترک را پیاده‌سازی کنند. هر هندلر مشخص (concrete) فقط باید به وجود داشتن متد execute در هندلر بعدی اهمیت دهد. به این ترتیب، می‌توانید زنجیره‌ها را در زمان اجرا با استفاده از هندلرهای مختلف بدون اتصال کد خود به کلاس‌های مشخص آن‌ها بسازید.\n9.3.1.4 - تشبیه دنیای واقعی # به تازگی سخت افزار جدیدی برای کامپیوتر خود خریداری و نصب کرده‌اید. از آنجایی که به اصطلاح یک «گیک» هستید، سیستم عامل های مختلفی روی کامپیوترتان نصب شده است. برای اینکه ببینید آیا سخت افزار جدید پشتیبانی می شود، سعی می کنید همه آنها را بوت کنید. ویندوز به طور خودکار سخت افزار را شناسایی و فعال می کند. با این حال، لینوکس دوست داشتنی شما از کار با سخت افزار جدید امتناع می‌کند. با جرقه‌ای کوچک از امید، تصمیم می‌گیرید با شماره تلفن پشتیبانی فنی که روی جعبه نوشته شده است تماس بگیرید.\nاولین چیزی که می شنوید صدای رباتیک پاسخگوی خودکار است. این پاسخگو 9 راه حل رایج برای مشکلات مختلف را پیشنهاد می کند که هیچ کدام به مورد شما مرتبط نیستند. پس از مدتی، ربات شما را به یک اپراتور زنده متصل می‌کند.\nافسوس، اپراتور هم نمی‌تواند راه حل خاصی را پیشنهاد کند. او همچنان بخش‌های طولانی از دفترچه راهنما را نقل می‌کند و از گوش دادن به نظرات شما امتناع می‌ورزد. بعد از اینکه برای دهمین بار عبارت «آیا کامپیوتر را خاموش و روشن کرده‌اید؟» را می‌شنوید، درخواست می‌کنید که به یک مهندس واقعی وصل شوید.\nدر نهایت، اپراتور تماس شما را به یکی از مهندسان منتقل می کند که احتمالاً ساعت ها در اتاق سرور تاریک زیرزمین یک ساختمان اداری نشسته و مشتاق یک گفتگوی انسانی زنده بوده است. مهندس به شما می گوید که درایورهای مناسب برای سخت افزار جدید خود را از کجا دانلود کنید و چگونه آنها را روی لینوکس نصب کنید. در نهایت، راه حل پیدا شد! تماس را با شادی تمام قطع می کنید.\n9.3.1.5 - مثال # درک الگوی زنجیره مسئولیت(Chain of Responsibility) با یک مثال بهتر انجام می‌شود. بیایید به یک بیمارستان به عنوان مثال توجه کنیم. یک بیمارستان بخش‌های مختلفی دارد مانند:\nپذیرش (Reception) پزشک (Doctor) داروخانه (Medicine Room) صندوق (Cashier) هر زمان که بیماری وارد می‌شود، ابتدا به پذیرش، سپس به پزشک، سپس به داروخانه و سپس به صندوق و غیره می‌رود. به نوعی، بیمار به زنجیره‌ای از بخش‌ها فرستاده می‌شود که پس از انجام کار، بیمار را به سایر بخش‌ها می‌فرستد. اینجاست که الگوی زنجیره مسئولیت وارد عمل می‌شود.\nچه زمانی از این الگو استفاده کنیم؟\nاین الگو در شرایطی کاربرد دارد که چندین گزینه برای پردازش یک درخواست یکسان وجود داشته باشد. همچنین زمانی که نمی‌خواهید کلاینت (فرستنده درخواست)، گیرنده را انتخاب کند، زیرا چندین شیء می‌توانند درخواست را مدیریت کنند. بعلاوه، می‌خواهید کلاینت را از گیرنده‌ها جدا کنید. کلاینت فقط باید عنصر اول زنجیره را بشناسد. همانطور که در مثال بیمارستان مشاهده کردید، بیمار ابتدا به پذیرش مراجعه می‌کند و سپس پذیرش بر اساس وضعیت فعلی بیمار، او را به نفر بعدی در زنجیره (احتمالا پزشک) می‌فرستد.\nUML Diagram: # handler department.go Concrete Handler 1 account.go Concrete Handler 2 doctor.go Concrete Handler 3 medical.go Concrete Handler 4 cashier.go Client main.go مثال عملی # department.go\npackage main type department interface { execute(*patient) setNext(department) } reception.go\npackage main import \u0026quot;fmt\u0026quot; type reception struct { next department } func (r *reception) execute(p *patient) { if p.registrationDone { fmt.Println(\u0026quot;Patient registration already done\u0026quot;) r.next.execute(p) return } fmt.Println(\u0026quot;Reception registering patient\u0026quot;) p.registrationDone = true r.next.execute(p) } func (r *reception) setNext(next department) { r.next = next } doctor.go\npackage main import \u0026quot;fmt\u0026quot; type doctor struct { next department } func (d *doctor) execute(p *patient) { if p.doctorCheckUpDone { fmt.Println(\u0026quot;Doctor checkup already done\u0026quot;) d.next.execute(p) return } fmt.Println(\u0026quot;Doctor checking patient\u0026quot;) p.doctorCheckUpDone = true d.next.execute(p) } func (d *doctor) setNext(next department) { d.next = next } medical.go\npackage main import \u0026quot;fmt\u0026quot; type medical struct { next department } func (m *medical) execute(p *patient) { if p.medicineDone { fmt.Println(\u0026quot;Medicine already given to patient\u0026quot;) m.next.execute(p) return } fmt.Println(\u0026quot;Medical giving medicine to patient\u0026quot;) p.medicineDone = true m.next.execute(p) } func (m *medical) setNext(next department) { m.next = next } cashier.go\npackage main import \u0026quot;fmt\u0026quot; type cashier struct { next department } func (c *cashier) execute(p *patient) { if p.paymentDone { fmt.Println(\u0026quot;Payment Done\u0026quot;) } fmt.Println(\u0026quot;Cashier getting money from patient patient\u0026quot;) } func (c *cashier) setNext(next department) { c.next = next } patient.go\npackage main type patient struct { name string registrationDone bool doctorCheckUpDone bool medicineDone bool paymentDone bool } main.go\npackage main func main() { cashier := \u0026amp;cashier{} //Set next for medical department medical := \u0026amp;medical{} medical.setNext(cashier) //Set next for doctor department doctor := \u0026amp;doctor{} doctor.setNext(medical) //Set next for reception department reception := \u0026amp;reception{} reception.setNext(doctor) patient := \u0026amp;patient{name: \u0026quot;abc\u0026quot;} //Patient visiting reception.execute(patient) } Output:\nReception registering patient Doctor checking patient Medical giving medicine to patient Cashier getting money from patient patient Full Working Code: # package main import \u0026quot;fmt\u0026quot; type department interface { execute(*patient) setNext(department) } type reception struct { next department } func (r *reception) execute(p *patient) { if p.registrationDone { fmt.Println(\u0026quot;Patient registration already done\u0026quot;) r.next.execute(p) return } fmt.Println(\u0026quot;Reception registering patient\u0026quot;) p.registrationDone = true r.next.execute(p) } func (r *reception) setNext(next department) { r.next = next } type doctor struct { next department } func (d *doctor) execute(p *patient) { if p.doctorCheckUpDone { fmt.Println(\u0026quot;Doctor checkup already done\u0026quot;) d.next.execute(p) return } fmt.Println(\u0026quot;Doctor checking patient\u0026quot;) p.doctorCheckUpDone = true d.next.execute(p) } func (d *doctor) setNext(next department) { d.next = next } type medical struct { next department } func (m *medical) execute(p *patient) { if p.medicineDone { fmt.Println(\u0026quot;Medicine already given to patient\u0026quot;) m.next.execute(p) return } fmt.Println(\u0026quot;Medical giving medicine to patient\u0026quot;) p.medicineDone = true m.next.execute(p) } func (m *medical) setNext(next department) { m.next = next } type cashier struct { next department } func (c *cashier) execute(p *patient) { if p.paymentDone { fmt.Println(\u0026quot;Payment Done\u0026quot;) } fmt.Println(\u0026quot;Cashier getting money from patient patient\u0026quot;) } func (c *cashier) setNext(next department) { c.next = next } type patient struct { name string registrationDone bool doctorCheckUpDone bool medicineDone bool paymentDone bool } func main() { cashier := \u0026amp;cashier{} //Set next for medical department medical := \u0026amp;medical{} medical.setNext(cashier) //Set next for doctor department doctor := \u0026amp;doctor{} doctor.setNext(medical) //Set next for reception department reception := \u0026amp;reception{} reception.setNext(doctor) patient := \u0026amp;patient{name: \u0026quot;abc\u0026quot;} //Patient visiting reception.execute(patient) } Output:\nReception registering patient Doctor checking patient Medical giving medicine to patient Cashier getting money from patient patient "},{"id":196,"href":"/chapter-9/behavioral-patterns/go-command-pattern/","title":"9.3.2 الگو Command","section":"9.3 الگوهای طراحی رفتاری","content":" 9.3.2.1-الگوی طراحی فرمان (Command) # الگوی طراحی Command یک الگوی رفتاری است که یک درخواست را به یک شیء(object) مستقل تبدیل می کند که حاوی تمام اطلاعات مربوط به درخواست است. این تغییر شکل به شما امکان می دهد درخواست‌ها را به عنوان آرگومان متد ارسال کنید و اجرای یک درخواست را به تعویق بیندازید یا در صف قرار دهید و از عملیات قابل لغو پشتیبانی کنید.\n9.3.2.2-مشکل # فرض کنید روی یک برنامه ویرایشگر متن جدید کار می‌کنید. وظیفه فعلی شما ایجاد نوار ابزار با تعدادی دکمه برای عملیات مختلف ویرایشگر است. شما یک کلاس Button بسیار مرتب ایجاد کرده اید که می‌توان از آن برای دکمه های روی نوار ابزار و همچنین برای دکمه های عمومی در گفتگوهای مختلف استفاده کرد.\n9.3.2.3-راه‌حل نادرست و مشکلات آن # در حالی که همه این دکمه ها شبیه به هم به نظر می رسند، همه آنها قرار است کارهای متفاوتی انجام دهند. کد مربوط به هندلرهای کلیک های مختلف این دکمه ها را کجا قرار می دهید؟ ساده ترین راه حل ایجاد انبوهی از زیرمجموعه‌ها برای هر مکانی است که دکمه در آن استفاده می شود. این زیرمجموعه ها حاوی کدهایی هستند که باید در صورت کلیک روی دکمه اجرا شوند.\nچندان طول نمی کشد که متوجه می شوید این رویکرد عمیقا معیوب است. اول اینکه شما تعداد زیادی از زیرمجموعه‌ها دارید و این خوب است، مگر اینکه هر بار که کلاس Button پایه را تغییر می دهید، خطر شکستن کد در این زیرمجموعه‌ها را نداشته باشید. به بیان ساده، کد رابط کاربری گرافیکی شما به طرز نامناسبی به کد ناپایدار منطق تجاری وابسته شده است.\nو حالا بدترین قسمت مربوط به برخی از عملیات‌ها مثل، کپی/پیست کردن متن، باید از چندین مکان فراخوانی شوند. به عنوان مثال، کاربر می تواند روی دکمه \u0026ldquo;کپی\u0026rdquo; کوچک در نوار ابزار کلیک کند یا چیزی را از طریق منوی زمینه کپی کند یا فقط کلیدهای Ctrl+C را روی صفحه کلید فشار دهد.\nدر ابتدا، زمانی که برنامه ما فقط نوار ابزار را داشت، قرار دادن اجرای عملیات مختلف در زیرمجموعه‌های دکمه اشکالی نداشت. به عبارت دیگر، داشتن کد کپی متن داخل زیرمجموعه CopyButton خوب بود. اما پس از آن، زمانی که منوها، میانبرها و سایر موارد را پیاده سازی می کنید، باید کد عملیات را در بسیاری از کلاس ها تکرار کنید یا منوها را به دکمه‌ها وابسته کنید، که این کار گزینه‌ای بدتر است.\n9.3.2.4-راه‌حل # طراحی خوب نرم‌افزار اغلب بر اساس اصل جداسازی دغدغه‌ها (principle of separation of concerns) بنا شده است، که معمولاً منجر به شکستن یک برنامه به لایه‌های مختلفی می‌شود. رایج ترین مثال: یک لایه برای رابط کاربری گرافیکی و یک لایه دیگر برای منطق تجاری. لایه GUI مسئول ارائه یک تصویر زیبا روی صفحه، گرفتن هر ورودی و نشان دادن نتایج کارهایی است که کاربر و برنامه انجام می دهند. با این حال، زمانی که نوبت به انجام کار مهمی مانند محاسبه مسیر ماه یا نوشتن گزارش سالانه می رسد، لایه GUI کار را به لایه زیرین منطق تجاری واگذار می‌کند.\nدر کد ممکن است به این شکل به نظر برسد: یک شیء GUI متدی از یک شیء منطق تجاری را فراخوانی می‌کند و برخی استدلال‌ها را برای آن ارسال می‌کند. این فرآیند معمولاً به عنوان فرستادن یک درخواست از یک شیء به شیء دیگر توصیف می شود.\nالگوی command پیشنهاد می کند که اشیاء GUI نباید این درخواست ها را مستقیماً ارسال کنند. در عوض، شما باید تمام جزئیات درخواست، مانند شیء فراخوانده شده، نام متد و لیست آرگومان‌ها را به یک کلاس فرمان جداگانه با یک متد واحد که این درخواست را فعال می کند را استخراج کنید.\nاشیاء فرمان به عنوان پیوندهایی بین اشیاء مختلف رابط کاربری و منطق تجاری عمل می کنند. از این به بعد، شیء GUI نیازی به دانستن اینکه کدام شیء منطق تجاری درخواست را دریافت خواهد کرد و چگونه پردازش خواهد شد، ندارد. شیء GUI فقط فرمان را فعال می‌کند، که تمام جزئیات را مدیریت می‌کند.\nگام بعدی این است که دستورات خود را برای پیاده سازی همان رابط کاربری وادار کنید. به طور معمول، فقط یک متد اجرایی دارد که هیچ پارامتری را نمی پذیرد. این رابط به شما امکان می دهد از دستورات مختلف با همان فرستنده درخواست استفاده کنید، بدون اینکه آن را به concrete کلاس‌های مشخص دستورات پیوند دهید. به عنوان یک امتیاز، اکنون می توانید اشیاء فرمان مرتبط با فرستنده را جابجا کنید و به طور موثر رفتار فرستنده را در زمان اجرا تغییر دهید.\nشاید به یک قطعه گمشده از پازل که پارامترهای درخواست است توجه کرده باشید. یک شیء GUI ممکن است برخی از پارامترها را به شیء لایه تجاری ارائه کرده باشد. از آنجایی که متد اجرای دستور هیچ پارامتری ندارد، چگونه جزئیات درخواست را به گیرنده منتقل کنیم؟ به نظر می رسد که دستور باید از قبل با این داده ها پیکربندی شده باشد، یا قادر به دریافت آن به تنهایی باشد.\nحالا که الگوی command را اعمال کرده‌ایم، دیگر به تمام آن زیرمجموعه‌های دکمه برای پیاده‌سازی رفتارهای مختلف کلیک نیاز نداریم. کافی است یک فیلد واحد در کلاس پایه Button قرار دهیم که مرجعی به یک شیء فرمان را ذخیره کند و دکمه را وادار کنیم تا آن فرمان را با یک کلیک اجرا کند.\nشما مجموعه‌ای از کلاس‌های فرمان را برای هر عملیاتی که ممکن است، پیاده‌سازی خواهید کرد و آن‌ها را با دکمه‌های خاص، بسته به رفتار مورد نظر دکمه‌ها، مرتبط می‌کنید.\nسایر عناصر رابط کاربری گرافیکی، مانند منوها، میانبرها یا کل کادرهای محاوره‌ای، می‌توانند به همین روش پیاده‌سازی شوند. آنها به یک فرمان مرتبط می شوند که هنگام تعامل کاربر با عنصر رابط کاربری اجرا می‌شود. همانطور که احتمالاً تا به حال حدس زده اید، عناصر مرتبط با عملیات مشابه به دستورات مشابه مرتبط می‌شوند و از تکرار هر گونه کد جلوگیری می‌کنند.\nدر نتیجه، دستورات به یک لایه میانی مناسب تبدیل می شوند که وابستگی بین لایه های رابط کاربری و منطق تجاری را کاهش می‌دهد. و این تنها بخشی از مزایایی است که الگوی فرمان می تواند ارائه دهد!\n9.3.2.5-مثال از دنیای واقعی # بعد از یک پیاده روی طولانی در شهر، به یک رستوران خوب می‌رسید و پشت میز کنار پنجره می‌نشینید. یک پیشخدمت خوش برخورد به سراغ شما می‌آید و به سرعت سفارش شما را می‌گیرد و آن را روی یک تکه کاغذ یادداشت می‌کند. پیشخدمت به آشپزخانه می رود و سفارش را روی دیوار می‌چسباند. پس از مدتی، سفارش به دست سرآشپز می‌رسد، او آن را می‌خواند و غذا را بر اساس آن طبخ می‌دهد. آشپز غذا را به همراه سفارش روی سینی قرار می‌دهد. پیشخدمت سینی را کشف می‌کند، سفارش را بررسی می‌کند تا مطمئن شود همه چیز مطابق میل شماست و همه چیز را سر میز شما می آورد.\nسفارش کاغذی به عنوان یک فرمان عمل می کند. تا زمانی که سرآشپز آماده سرو آن نباشد، در صف باقی می ماند. سفارش حاوی تمام اطلاعات مرتبط مورد نیاز برای پخت غذا است. این به سرآشپز اجازه می‌دهد بدون اینکه به طور مستقیم برای دریافت جزئیات سفارش از شما بپرسد، بلافاصله شروع به پخت و پز کند.\n9.3.2.6- مثال # ####s اجزای اصلی در الگوی طراحی فرمان\nاجزای اصلی که در الگوی طراحی فرمان استفاده می شوند عبارتند از:\nگیرنده (Receiver) - کلاسی است که حاوی منطق تجاری است. شیء فرمان فقط درخواست های خود را به گیرنده به تعویق می اندازد. فرمان (Command) - گیرنده را جاسازی می‌کند و یک عمل خاص از گیرنده را متصل می کند. اجراکننده (Invoker) - فرمان را جاسازی (embed) می‌کند و با فراخوانی متد اجرای فرمان، فرمان را فراخوانی می کند. کاربر (Client) - فرمان را با گیرنده مناسب ایجاد می‌کند و گیرنده را از سازنده فرمان دور می زند. پس از آن، همچنین فرمان حاصل را با یک اجراکننده مرتبط می‌کند. بیایید وضعیتی را درک کنیم که پس از آن مشخص خواهد شد که چرا الگوی فرمان مفید است. حالت یک تلویزیون را در نظر بگیرید. تلویزیون را می توان با موارد زیر روشن کرد:\nدکمه روشن کنترل از راه دور دکمه روشن روی تلویزیون هر دوی این نقاط شروع کار یکسانی انجام می دهند یعنی روشن کردن تلویزیون. برای روشن کردن تلویزیون، می توانیم شیء فرمان روشن را با گیرنده به عنوان تلویزیون پیاده سازی کنیم. هنگامی که متد execute() روی این شیء فرمان روشن فراخوانده می شود، به نوبه خود تابع TV.on() را فراخوانی می کند. بنابراین در این مورد:\nگیرنده تلویزیون است فرمان مورد نظر برابر با command object روشن است که تلویزیون را جاسازی می‌کند. اجراکننده دکمه روشن کنترل از راه دور یا دکمه روشن تلویزیون است. هر دو شیء فرمان روشن را جاسازی می کنند. در اینجا توجه داشته باشید که ما درخواست روشن کردن تلویزیون را در یک شیء فرمان ( command object) روشن که توسط چندین اجراکننده قابل فراخوانی است، بسته بندی کرده‌ایم. این شیء فرمان روشن گیرنده (در اینجا تلویزیون) را جاسازی می‌کند و می‌تواند به طور مستقل اجرا شود.\nبه عنوان مثال دیگری، مورد یک برنامه ادوبی فتوشاپ را در نظر بگیرید. در فتوشاپ، یک عملیات ذخیره را می توان از 3 مکان راه اندازی کرد:\nاز منو از دکمه روی نوار بالا با استفاده از میانبر Ctrl+S هر سه نقطه شروع کار یکسانی انجام می دهند، یعنی ذخیره تصویر فعلی در برنامه. این ذخیره را می توان در یک شیء فرمان ذخیره با تصویر فعلی باز در برنامه به عنوان گیرنده، قرار داد.\nمزایای ایجاد یک شیء فرمان جداگانه در مثالهای بالا چیست:\nمنطق رابط کاربری را از منطق تجاری زیربنایی جدا می‌کند. نیاز به ایجاد هندلرهای مختلف برای هر یک از اجراکننده ها نیست. شیء فرمان حاوی تمام اطلاعات مورد نیاز برای اجرا است. از این رو می توان از آن برای اجرای به تعویق افتاده نیز استفاده کرد. حالا به نمودار UML نگاه کنیم.\nنمودار UML:\nتوجه کنید که چگونه اجراکننده فرمان را جاسازی می‌کند. درخواست به اجراکننده ارسال می شود و آن درخواست را به شیء فرمان کپسوله شده منتقل می کند. تمام اشیاء فرمان Concrete گیرنده را جاسازی می کنند. نگاشت\nجدول زیر نگاشت بازیگران نمودار UML را به بازیگران پیاده سازی واقعی در \u0026ldquo;مثال عملی\u0026rdquo; در زیر نشان می دهد.\nInvoker button.go Command Interface command.go Concrete Command 1 onCommand.go Concrete Command 2 offCommand.go Receiver Interface device.go Concrete Receiver tv.go Client main.go 9.3.2.7-پیاده سازی # button.go\npackage main type button struct { command command } func (b *button) press() { b.command.execute() } command.go\npackage main type command interface { execute() } onCommand.go\npackage main type onCommand struct { device device } func (c *onCommand) execute() { c.device.on() } offCommand.go\npackage main type offCommand struct { device device } func (c *offCommand) execute() { c.device.off() } device.go\npackage main type device interface { on() off() } tv.go\npackage main import \u0026quot;fmt\u0026quot; type tv struct { isRunning bool } func (t *tv) on() { t.isRunning = true fmt.Println(\u0026quot;Turning tv on\u0026quot;) } func (t *tv) off() { t.isRunning = false fmt.Println(\u0026quot;Turning tv off\u0026quot;) } main.go\npackage main func main() { tv := \u0026amp;tv{} onCommand := \u0026amp;onCommand{ device: tv, } offCommand := \u0026amp;offCommand{ device: tv, } onButton := \u0026amp;button{ command: onCommand, } onButton.press() offButton := \u0026amp;button{ command: offCommand, } offButton.press() } Output:\nTurning tv on Turning tv off Full Working Code: # package main import \u0026quot;fmt\u0026quot; type button struct { command command } func (b *button) press() { b.command.execute() } type command interface { execute() } type offCommand struct { device device } func (c *offCommand) execute() { c.device.off() } type onCommand struct { device device } func (c *onCommand) execute() { c.device.on() } type device interface { on() off() } type tv struct { isRunning bool } func (t *tv) on() { t.isRunning = true fmt.Println(\u0026quot;Turning tv on\u0026quot;) } func (t *tv) off() { t.isRunning = false fmt.Println(\u0026quot;Turning tv off\u0026quot;) } func main() { tv := \u0026amp;tv{} onCommand := \u0026amp;onCommand{ device: tv, } offCommand := \u0026amp;offCommand{ device: tv, } onButton := \u0026amp;button{ command: onCommand, } onButton.press() offButton := \u0026amp;button{ command: offCommand, } offButton.press() } Output:\nTurning tv on Turning tv off "},{"id":197,"href":"/chapter-9/behavioral-patterns/go-iterator-pattern/","title":"9.3.3 الگو Iterator","section":"9.3 الگوهای طراحی رفتاری","content":" 9.3.3.1-هدف # الگوي طراحی تکرارکننده (Iterator) یک الگوی رفتاری است که به شما امکان می دهد عناصر یک مجموعه را بدون نمایش ساختار درونی آن (فهرست، پشته، درخت و غیره) پیمایش کنید.\n9.3.3.2-مشکل # مجموعه ها (collections) یکی از پرکاربردترین انواع داده در برنامه نویسی هستند. با این وجود، یک مجموعه فقط یک ظرف برای گروهی از اشیاء است.\n(انواع مختلف از collections)\nاکثر مجموعه ها عناصر خود را در لیست های ساده ذخیره می کنند. با این حال، برخی از آنها بر اساس پشته‌ها، درختان، نمودارها و سایر ساختارهای داده پیچیده ساخته شده‌اند.\nاما مهم نیست که یک مجموعه چگونه ساختار یافته باشد، باید روشی برای دسترسی به عناصر آن ارائه دهد تا کدهای دیگر بتوانند از این عناصر استفاده کنند. باید راهی برای مرور هر عنصر از مجموعه بدون دسترسی مکرر به عناصر مشابه وجود داشته باشد.\nاگر مجموعه ای مبتنی بر لیست دارید، این کار ممکن است آسان به نظر برسد. شما فقط روی تمام عناصر حلقه می زنید. اما چگونه عناصر یک ساختار داده پیچیده مانند درخت را به طور متوالی طی کنید؟ به عنوان مثال، ممکن است یک روز فقط با پیمایش عمق اول (depth-first) یک درخت مشکلی نداشته باشید. اما روز بعد ممکن است به پیمایش عرض اول (breadth-first) نیاز داشته باشید. و هفته بعد، ممکن است به چیز دیگری مانند دسترسی تصادفی به عناصر درخت نیاز داشته باشید.\n(از یک مجموعه می‌توان به چند روش مختلف عبور کرد.)\nافزودن الگوریتم های پیمایش بیشتر و بیشتر به مجموعه به تدریج مسئولیت اصلی آن که ذخیره کارآمد داده است را تحت الشعاع قرار می دهد. علاوه بر این، برخی الگوریتم‌ها ممکن است برای یک برنامه خاص طراحی شده باشند، بنابراین گنجاندن آنها در یک کلاس عمومی مجموعه عجیب خواهد بود.\nاز طرف دیگر، کد کلاینت که قرار است با مجموعه‌های مختلفی کار کند، حتی ممکن است اهمیتی ندهد که آنها عناصر خود را چگونه ذخیره می‌کنند. با این حال، از آنجایی که همه مجموعه‌ها روش‌های مختلفی برای دسترسی به عناصر خود ارائه می‌دهند، شما چاره‌ای جز اتصال کد خود به کلاس‌های مجموعه خاص ندارید.\n9.3.3.3-راه‌حل # ایده اصلی الگوی تکرارکننده (Iterator) این است که رفتار پیمایش یک مجموعه را به یک شیء جداگانه به نام «تکرارکننده» (Iterator) استخراج کند.\n(تکرار کننده ها الگوریتم های پیمایش مختلفی را پیاده سازی می کنند. چندین شی تکرارکننده می‌توانند همزمان از یک مجموعه عبور کنند.)\nیک شیء تکرارکننده علاوه بر پیاده سازی الگوریتم پیمایش، تمام جزئیات پیمایش مانند موقعیت فعلی و تعداد عناصر باقی مانده تا انتها را دربرمی گیرد. به همین دلیل، چندین تکرارکننده می توانند به طور همزمان و مستقل از یکدیگر، یک مجموعه را طی کنند.\nمعمولا تکرارکننده‌ها یک روش اصلی برای دریافت عناصر مجموعه ارائه می دهند. کاربر می تواند این روش را تا زمانی که چیزی برنگردد اجرا کند، به این معنی که تکرارکننده تمام عناصر را پیمایش کرده است.\nهمه تکرارکننده‌ها باید یک رابط مشترک را پیاده سازی کنند. این کار باعث می شود کد کلاینت با هر نوع مجموعه یا هر الگوریتم پیمایشی سازگار باشد، به شرطی که یک تکرارکننده مناسب وجود داشته باشد. اگر به روش خاصی برای پیمایش یک مجموعه نیاز دارید، فقط یک کلاس تکرارکننده جدید بدون نیاز به تغییر مجموعه یا مشتری ایجاد کنید.\n9.3.3.4-نمونه واقعی # تصمیم می‌گیرید برای چند روز به شهر رم در ایتالیا سفر کنید و از تمام مناظر و جاذبه های اصلی آن دیدن کنید. اما هنگامی که به آنجا رسیدید، ممکن است زمان زیادی را برای قدم زدن در مسیرهای پر پیچ و خم تلف کنید، بدون اینکه حتی بتوانید نماد باستانی مثل کولوسئوم را پیدا کنید.\nاز طرف دیگر، می توانید یک اپلیکیشن راهنمای مجازی برای گوشی هوشمند خود بخرید و از آن برای مسیریابی استفاده کنید. این کار هوشمند و ارزان است و می توانید تا هر زمان که بخواهید در مکان‌های جالبی توقف و دیدن کنید.\nیک راه حل دیگر این است که بخشی از بودجه سفر را صرف استخدام یک راهنمای محلی کنید که شهر را مثل کف دستش بشناسد. راهنما می‌تواند تور را مطابق با سلیقه شما تنظیم کند، هر جاذبه‌ای را به شما نشان دهد و داستان‌های هیجان‌انگیزی تعریف کند. این حتی سرگرم‌کننده‌تر خواهد بود، اما افسوس، گران‌تر هم خواهد بود.\nهمه این گزینه‌ها - مسیرهای تصادفی که در ذهن شما به وجود می‌آیند، راهنمای هوشمند گوشی هوشمند یا راهنمای انسانی - به عنوان تکرارکننده‌هایی بر روی مجموعه عظیم مناظر و جاذبه‌های واقع در رم عمل می‌کنند.\n9.3.3.5-مثال # الگوی طراحی تکرارکننده (Iterator) # الگوی طراحی تکرارکننده (Iterator) یک الگوی رفتاری است که به شما امکان می دهد عناصر یک مجموعه را بدون نمایش ساختار درونی آن (فهرست، پشته، درخت و غیره) پیمایش کنید.\nاجزای اصلی:\nرابط تکرارکننده (Iterator Interface): این اینترفیس عملیات اصلی برای پیمایش در یک مجموعه را تعریف می کند، به طور معمول شامل متد (Method) هایی مانند hasNext() برای بررسی وجود عناصر بیشتر و getNext() برای بازیابی عنصر بعدی. رابط مجموعه (Collection Interface): این اینترفیس خود مجموعه را نشان می دهد. ممکن است متدی مانند createIterator() را اعلام کند که یک شیء تکرارکننده خاص برای نوع مجموعه را برمی‌گرداند. تکرارکننده خاص (Concrete Iterator): این کلاسی است که رابط Iterator را برای یک نوع مجموعه خاص پیاده سازی می کند. این حالت تکرار (مانند موقعیت فعلی) را حفظ می کند و متد هایی مانند hasNext() و getNext() را ارائه می دهد که خاص ساختار مجموعه است. مجموعه خاص (Concrete Collection): این کلاسی است که اینترفیس یا رابط Collection را برای یک ساختار داده خاص (مانند لیست، درخت) پیاده سازی می کند. این متد createIterator() را ارائه می دهد که یک شیء تکرارکننده خاص را برای پیمایش عناصر آن برمی گرداند. مزایا:\nجداسازی: منطق تکرار را از خود مجموعه جدا می کند و اتصالات ضعیف را ارتقا می دهد و کد را انعطاف پذیرتر و قابل استفاده مجدد می کند. چندین پیمایش: امکان پیمایش همزمان در یک مجموعه با استفاده از تکرارکننده های مختلف، به طور بالقوه با الگوریتم های پیمایش مختلف را فراهم می کند. اصل بسته-باز: پیاده سازی های جدید تکرارکننده را می توان برای نیازهای مختلف پیمایش بدون تغییر در کلاس های مجموعه اضافه کرد. با استفاده از تکرارکننده‌‌ها، می توانید کدی بنویسید که با مجموعه های مختلف بدون وابستگی به ساختارهای خاص آنها کار می کند. این امر به ترویج کدی تمیزتر و قابل نگهداری تر کمک می کند.\n9.3.3.6-Mapping # جدول زیر نگاشت بین بازیگران نمودار UML و بازیگران پیاده‌سازی واقعی را در \u0026ldquo;مثال\u0026rdquo; زیر نشان می‌دهد:\nCollection collection.go Concrete Collection userCollection.go Iterator mac.go Concrete Iterator 1 userIterator.go Client main.go 9.3.3.7-پیاده سازی # collection.go\npackage main type collection interface { createIterator() iterator } userCollection.go\npackage main type userCollection struct { users []*user } func (u *userCollection) createIterator() iterator { return \u0026amp;userIterator{ users: u.users, } } iterator.go\npackage main type iterator interface { hasNext() bool getNext() *user } userIterator.go\npackage main type userIterator struct { index int users []*user } func (u *userIterator) hasNext() bool { if u.index \u0026lt; len(u.users) { return true } return false } func (u *userIterator) getNext() *user { if u.hasNext() { user := u.users[u.index] u.index++ return user } return nil } user.go\npackage main type user struct { name string age int } main.go\npackage main import \u0026quot;fmt\u0026quot; func main() { user1 := \u0026amp;user{ name: \u0026quot;a\u0026quot;, age: 30, } user2 := \u0026amp;user{ name: \u0026quot;b\u0026quot;, age: 20, } userCollection := \u0026amp;userCollection{ users: []*user{user1, user2}, } iterator := userCollection.createIterator() for iterator.hasNext() { user := iterator.getNext() fmt.Printf(\u0026quot;User is %+v\\n\u0026quot;, user) } } Output:\nUser is \u0026amp;{name:a age:30} User is \u0026amp;{name:b age:20} Full Working Code: # package main import \u0026quot;fmt\u0026quot; type collection interface { createIterator() iterator } type userCollection struct { users []*user } func (u *userCollection) createIterator() iterator { return \u0026amp;userIterator{ users: u.users, } } type iterator interface { hasNext() bool getNext() *user } type userIterator struct { index int users []*user } func (u *userIterator) hasNext() bool { if u.index \u0026lt; len(u.users) { return true } return false } func (u *userIterator) getNext() *user { if u.hasNext() { user := u.users[u.index] u.index++ return user } return nil } type user struct { name string age int } func main() { user1 := \u0026amp;user{ name: \u0026quot;a\u0026quot;, age: 30, } user2 := \u0026amp;user{ name: \u0026quot;b\u0026quot;, age: 20, } userCollection := \u0026amp;userCollection{ users: []*user{user1, user2}, } iterator := userCollection.createIterator() for iterator.hasNext() { user := iterator.getNext() fmt.Printf(\u0026quot;User is %+v\\n\u0026quot;, user) } } Output:\nUser is \u0026amp;{name:a age:30} User is \u0026amp;{name:b age:20} "},{"id":198,"href":"/chapter-9/behavioral-patterns/go-mediator-pattern/","title":"9.3.4 الگو Mediator","section":"9.3 الگوهای طراحی رفتاری","content":" 9.3.4.1-الگوی طراحی Mediator # الگوی طراحی واسطه (Mediator)، یک الگوی رفتاری است که به شما امکان می‌دهد تا وابستگی‌های درهم‌تنیده بین اشیاء را کاهش دهید. این الگو ارتباط مستقیم بین اشیاء را محدود می‌کند و آن‌ها را مجبور می‌سازد تا تنها از طریق یک شیء واسطه با هم همکاری کنند.\n9.3.4.2-مشکل # فرض کنید یک جعبه dialog برای ایجاد و ویرایش پروفایل کاربران دارید. این جعبه dialog شامل کنترل‌های مختلف فرم مانند فیلدهای متنی، کادرهای انتخابی(checkbox)، دکمه‌ها و غیره می‌شود.\nممکن است برخی از عناصر فرم با سایرین تعامل داشته باشند. برای مثال، انتخاب checkbox \u0026ldquo;من یک سگ دارم\u0026rdquo; ممکن است یک فیلد متنی پنهان برای وارد کردن نام سگ را نمایش دهد. مثال دیگر دکمه “ثبت” است که باید قبل از ذخیره اطلاعات، صحت مقادیر همه فیلدها را تایید کند.\nبا پیاده‌سازی مستقیم این منطق درون کد عناصر فرم، باعث می‌شوید استفاده‌ی مجدد از کلاس‌های این عناصر در فرم‌های دیگر برنامه بسیار دشوار شود. برای نمونه، به دلیل وابستگی به فیلد متن سگ، نمی‌توانید از کلاس کادر انتخاب مذکور در فرم دیگری استفاده کنید. در این حالت، مجبور هستید یا از تمام کلاس‌های درگیر در نمایش فرم پروفایل استفاده کنید، یا هیچ‌کدام را به کار نبرید.\n9.3.4.3- راه‌حل # الگوی طراحی Mediator پیشنهاد می‌کند که تمام ارتباط‌های مستقیم بین اجزایی که می‌خواهید مستقل از یکدیگر باشند را متوقف کنید. در عوض، این اجزا باید به صورت غیرمستقیم با هم همکاری کنند، یعنی با فراخوانی یک شیء واسطه‌ی خاص که تماس‌ها را به اجزای مناسب هدایت می‌کند. در نتیجه، اجزا تنها به یک کلاس واسطه وابسته می‌شوند، نه اینکه به ده‌ها جزء همکار دیگرشان وابسته باشند.\nدر مثال فرم ویرایش پروفایل، خود کلاس باکس گفتگو می‌تواند نقش واسطه را ایفا کند. به احتمال زیاد، کلاس جعبه dialog از قبل از تمام زیرمجموعه‌هایش آگاه است، بنابراین حتی نیازی به معرفی وابستگی‌های جدید به این کلاس نخواهید داشت.\nمهم‌ترین تغییر در عناصر واقعی فرم اتفاق می‌افتد. بیایید دکمه‌ی “ثبت” را در نظر بگیریم. پیش از این، هر بار که کاربر روی دکمه کلیک می‌کرد، این دکمه مجبور بود صحت مقادیر تمام عناصر فرم مجزا را تایید کند. حالا تنها وظیفه‌ی دکمه، اطلاع‌رسانی به جعبه dialog در مورد کلیک است. جعبه dialog پس از دریافت این اطلاع‌رسانی، تایید صحت را خودش انجام می‌دهد یا این وظیفه را به عناصر مجزا واگذار می‌کند. بنابراین، به جای وابستگی به ده‌ها عنصر فرم، دکمه تنها به کلاس باکس گفتگو وابسته است.\nمی‌توانید فراتر بروید و وابستگی را حتی سست‌تر کنید، با این کار که یک واسط مشترک برای تمام انواع جعبه‌های dialog تعریف کنید. این واسط، متد اطلاع‌رسانی را معرفی می‌کند که همه عناصر فرم می‌توانند از آن برای اطلاع‌رسانی به باکس گفتگو در مورد رویدادهای رخ‌داده در آن عناصر استفاده کنند. بنابراین، دکمه‌ی «ثبت» ما حالا باید بتواند با هر جعبه dialog که آن واسط را پیاده‌سازی می‌کند، کار کند.\nبه این ترتیب، الگوی طراحی واسطه به شما امکان می‌دهد تا یک شبکه‌ی پیچیده‌ی روابط بین اشیاء مختلف را درون یک شیء واسطه‌ی واحد کپسوله‌سازی کنید. هرچه وابستگی‌های یک کلاس کمتر باشد، اصلاح، توسعه یا استفاده‌ی مجدد از آن کلاس آسان‌تر می‌شود.\n9.3.4.4- تشبیه در دنیای واقعی # خلبانان هواپیماهایی که به منطقه‌ی کنترل فرودگاه نزدیک می‌شوند یا از آن خارج می‌شوند، به طور مستقیم با یکدیگر ارتباط برقرار نمی‌کنند. در عوض، آن‌ها با یک کنترل‌کننده‌ی ترافیک هوایی صحبت می‌کنند که در یک برج بلند، جایی در نزدیکی باند فرودگاه قرار دارد. بدون وجود کنترل‌کننده ترافیک هوایی، خلبانان باید از هر هواپیمایی در حوالی فرودگاه آگاه باشند و با یک کمیته‌ی متشکل از ده‌ها خلبان دیگر در مورد اولویت‌های فرود بحث کنند. این امر احتمالا آمار سقوط هواپیما را به طرز چشمگیری افزایش می‌داد.\nبرج نیازی به کنترل کل پرواز ندارد. برج فقط برای اعمال محدودیت‌ها در منطقه‌ی فرودگاه وجود دارد.\n9.3.4.5- مثال # همانطور که می‌دانیم؛ الگوی طراحی Mediator یک الگوی طراحی رفتاری است. این الگو پیشنهاد می کند برای جلوگیری از ارتباط مستقیم بین اشیاء، یک شیء میانجی ایجاد شود تا وابستگی های مستقیم بین آنها از بین برود.\nیک مثال بسیار خوب از الگوی Mediator، سکوی سیستم راه آهن است. دو قطار هرگز برای در دسترس بودن سکو با یکدیگر ارتباط برقرار نمی‌کنند. مسئول ایستگاه (stationManager) به عنوان میانجی (Mediator) عمل می کند و سکو را فقط برای یکی از قطارها در دسترس قرار می‌دهد. قطار با مسئول ایستگاه (stationManager) ارتباط برقرار می‌کند و بر اساس دستورات آن عمل می‌کند. این الگو صفی از قطارهای در انتظار را مدیریت می کند. در صورت خروج هر قطاری از سکو، به یکی از قطارها اطلاع می دهد که در ادامه به سکو برسد.\nتوجه کنید که چگونه stationManager در کد زیر به عنوان میانجی بین trains و platform عمل می کند.\npassengerTrain و goodsTrain رابط train را پیاده سازی می‌کنند. stationManager رابط mediator را پیاده سازی می‌کند. 9.3.4.6- مثال کاربردی # train.go\npackage main type train interface { requestArrival() departure() permitArrival() } passengerTrain.go\npackage main import \u0026quot;fmt\u0026quot; type passengerTrain struct { mediator mediator } func (g *passengerTrain) requestArrival() { if g.mediator.canLand(g) { fmt.Println(\u0026quot;PassengerTrain: Landing\u0026quot;) } else { fmt.Println(\u0026quot;PassengerTrain: Waiting\u0026quot;) } } func (g *passengerTrain) departure() { fmt.Println(\u0026quot;PassengerTrain: Leaving\u0026quot;) g.mediator.notifyFree() } func (g *passengerTrain) permitArrival() { fmt.Println(\u0026quot;PassengerTrain: Arrival Permitted. Landing\u0026quot;) } goodsTrain.go\npackage main import \u0026quot;fmt\u0026quot; type goodsTrain struct { mediator mediator } func (g *goodsTrain) requestArrival() { if g.mediator.canLand(g) { fmt.Println(\u0026quot;GoodsTrain: Landing\u0026quot;) } else { fmt.Println(\u0026quot;GoodsTrain: Waiting\u0026quot;) } } func (g *goodsTrain) departure() { g.mediator.notifyFree() fmt.Println(\u0026quot;GoodsTrain: Leaving\u0026quot;) } func (g *goodsTrain) permitArrival() { fmt.Println(\u0026quot;GoodsTrain: Arrival Permitted. Landing\u0026quot;) } mediator.go\npackage main type mediator interface { canLand(train) bool notifyFree() } stationManager.go\npackage main import \u0026quot;sync\u0026quot; type stationManager struct { isPlatformFree bool lock *sync.Mutex trainQueue []train } func newStationManger() *stationManager { return \u0026amp;stationManager{ isPlatformFree: true, lock: \u0026amp;sync.Mutex{}, } } func (s *stationManager) canLand(t train) bool { s.lock.Lock() defer s.lock.Unlock() if s.isPlatformFree { s.isPlatformFree = false return true } s.trainQueue = append(s.trainQueue, t) return false } func (s *stationManager) notifyFree() { s.lock.Lock() defer s.lock.Unlock() if !s.isPlatformFree { s.isPlatformFree = true } if len(s.trainQueue) \u0026gt; 0 { firstTrainInQueue := s.trainQueue[0] s.trainQueue = s.trainQueue[1:] firstTrainInQueue.permitArrival() } } main.go\npackage main func main() { stationManager := newStationManger() passengerTrain := \u0026amp;passengerTrain{ mediator: stationManager, } goodsTrain := \u0026amp;goodsTrain{ mediator: stationManager, } passengerTrain.requestArrival() goodsTrain.requestArrival() passengerTrain.departure() } Output:\nPassengerTrain: Landing GoodsTrain: Waiting PassengerTrain: Leaving GoodsTrain: Arrival Permitted. Landing Full Working Code: # package main import ( \u0026quot;fmt\u0026quot; \u0026quot;sync\u0026quot; ) type train interface { requestArrival() departure() permitArrival() } type passengerTrain struct { mediator mediator } func (g *passengerTrain) requestArrival() { if g.mediator.canLand(g) { fmt.Println(\u0026quot;PassengerTrain: Landing\u0026quot;) } else { fmt.Println(\u0026quot;PassengerTrain: Waiting\u0026quot;) } } func (g *passengerTrain) departure() { fmt.Println(\u0026quot;PassengerTrain: Leaving\u0026quot;) g.mediator.notifyFree() } func (g *passengerTrain) permitArrival() { fmt.Println(\u0026quot;PassengerTrain: Arrival Permitted. Landing\u0026quot;) } type goodsTrain struct { mediator mediator } func (g *goodsTrain) requestArrival() { if g.mediator.canLand(g) { fmt.Println(\u0026quot;GoodsTrain: Landing\u0026quot;) } else { fmt.Println(\u0026quot;GoodsTrain: Waiting\u0026quot;) } } func (g *goodsTrain) departure() { g.mediator.notifyFree() fmt.Println(\u0026quot;GoodsTrain: Leaving\u0026quot;) } func (g *goodsTrain) permitArrival() { fmt.Println(\u0026quot;GoodsTrain: Arrival Permitted. Landing\u0026quot;) } type mediator interface { canLand(train) bool notifyFree() } type stationManager struct { isPlatformFree bool lock *sync.Mutex trainQueue []train } func newStationManger() *stationManager { return \u0026amp;stationManager{ isPlatformFree: true, lock: \u0026amp;sync.Mutex{}, } } func (s *stationManager) canLand(t train) bool { s.lock.Lock() defer s.lock.Unlock() if s.isPlatformFree { s.isPlatformFree = false return true } s.trainQueue = append(s.trainQueue, t) return false } func (s *stationManager) notifyFree() { s.lock.Lock() defer s.lock.Unlock() if !s.isPlatformFree { s.isPlatformFree = true } if len(s.trainQueue) \u0026gt; 0 { firstTrainInQueue := s.trainQueue[0] s.trainQueue = s.trainQueue[1:] firstTrainInQueue.permitArrival() } } func main() { stationManager := newStationManger() passengerTrain := \u0026amp;passengerTrain{ mediator: stationManager, } goodsTrain := \u0026amp;goodsTrain{ mediator: stationManager, } passengerTrain.requestArrival() goodsTrain.requestArrival() passengerTrain.departure() } Output:\nPassengerTrain: Landing GoodsTrain: Waiting PassengerTrain: Leaving GoodsTrain: Arrival Permitted. Landing "},{"id":199,"href":"/chapter-9/behavioral-patterns/go-memento-pattern/","title":"9.3.5 الگو Memento","section":"9.3 الگوهای طراحی رفتاری","content":"الگو Memento\u0026hellip;\n"},{"id":200,"href":"/chapter-9/behavioral-patterns/go-observer-pattern/","title":"9.3.6 الگو Observer","section":"9.3 الگوهای طراحی رفتاری","content":"الگو Observer\u0026hellip;\n"},{"id":201,"href":"/chapter-9/behavioral-patterns/go-state-pattern/","title":"9.3.7 الگو State","section":"9.3 الگوهای طراحی رفتاری","content":"الگو State\u0026hellip;\n9.3.7.1 مقدمه: # دیزاین پترن State یک دیزاین پترن behavioral است که مبتنی بر Finite State Machine است. ما دیزاین پترن State را در زمینه نمونه ای از Vending Machine توضیح خواهیم داد. برای سادگی، بیایید فرض کنیم که Vending Machine فقط یک نوع کالا یا محصول دارد. همچنین برای سادگی، فرض می کنیم که یک Vending Machine می تواند در 4 حالت(state) مختلف باشد:\nhasItem noItem itemRequested hasMoney یک Vending Machine خودکار نیز عملکردهای متفاوتی خواهد داشت. دوباره برای سادگی فرض می کنیم که فقط چهار عمل وجود دارد:\nSelect the item Add the item Insert Money Dispense Item 9.3.7.2 چه زمانی از این الگو استفاده کنیم: # از الگوی طراحی State زمانی استفاده کنید که object می تواند در بسیاری از حالت های (states) مختلف باشد. بسته به درخواست فعلی، object باید وضعیت فعلی خود را تغییر دهد. در مثال بالا، Vending Machine می تواند در بسیاری از حالت های مختلف باشد. یک Vending Machine از یک state به حالت دیگر تغییر می کند. فرض کنید Vending Machine در مورد itemRequested است، پس از انجام عمل «hasMoney» به حالت «Insert Money» منتقل می‌شود. از این پترن زمانی استفاده کنید که یک شی بسته به وضعیت فعلی پاسخ‌های متفاوتی به درخواست یکسان داشته باشد. استفاده از الگوی طراحی states در اینجا از بسیاری از عبارات شرطی جلوگیری می کند به عنوان مثال در مورد Vending Machine، اگر کاربری بخواهد کالایی را خریداری کند، اگر آن مورد hasItemState باشد دستگاه ادامه خواهد داد یا اگر در noItemState باشد آن را رد می کند. اگر در اینجا متوجه شدید که Vending Machine خودکار به درخواست خرید یک کالا، بسته به اینکه آیا در hasItemState باشد، دو پاسخ متفاوت می دهد. به فایل vendingMachine.go زیر توجه کنید، هیچ نوع دستور شرطی ندارد. تمام منطق توسط پیاده سازی های concrete state اداره می شود. 9.3.7.3 ## UML Diagram: # 9.3.7.4 ## Mapping: # جدول زیر mapping از نمودار UML به نمونه اجرایی پیاده سازی واقعی در کد را نشان می دهد.\nContext vendingMachine.go State Interface state.go Concrete State 1 noItemState.go Concrete State 2 hasItemState.go Concrete State 3 itemRequestedState.go Concrete State 4 hasMoneyState.go 9.3.7.5 ## توضیحات: # ما یک رابط(interface) از نوع \u0026lsquo;State\u0026rsquo; داریم که signature توابع را تعریف می کند که نشان دهنده عملکرد در زمینه Vending Machine است. در زیر signatureهای توابع عملیاتی وجود دارد addItem(int) error requestItem() error insertMoney(money int) error dispenseItem() error هر یک از پیاده‌سازی‌های concrete state، هر 4 تابع بالا را پیاده‌سازی می‌کنند و روی اقدامات مربوط به هر کدام یا به حالت دیگری می‌روند یا پاسخی تولید می‌کنند.\nهر یک از concrete stateها نیز یک اشاره گر را به object مربوط به Vending Machine فعلی تعبیه(embed) می کند تا انتقال حالت (state transition) در آن object اتفاق بیفتد.\n9.3.7.6 ## مثال کاربردی: # vendingMachine.go\npackage main import \u0026quot;fmt\u0026quot; type vendingMachine struct { hasItem state itemRequested state hasMoney state noItem state currentState state itemCount int itemPrice int } func newVendingMachine(itemCount, itemPrice int) *vendingMachine { v := \u0026amp;vendingMachine{ itemCount: itemCount, itemPrice: itemPrice, } hasItemState := \u0026amp;hasItemState{ vendingMachine: v, } itemRequestedState := \u0026amp;itemRequestedState{ vendingMachine: v, } hasMoneyState := \u0026amp;hasMoneyState{ vendingMachine: v, } noItemState := \u0026amp;noItemState{ vendingMachine: v, } v.setState(hasItemState) v.hasItem = hasItemState v.itemRequested = itemRequestedState v.hasMoney = hasMoneyState v.noItem = noItemState return v } func (v *vendingMachine) requestItem() error { return v.currentState.requestItem() } func (v *vendingMachine) addItem(count int) error { return v.currentState.addItem(count) } func (v *vendingMachine) insertMoney(money int) error { return v.currentState.insertMoney(money) } func (v *vendingMachine) dispenseItem() error { return v.currentState.dispenseItem() } func (v *vendingMachine) setState(s state) { v.currentState = s } func (v *vendingMachine) incrementItemCount(count int) { fmt.Printf(\u0026quot;Adding %d items\\n\u0026quot;, count) v.itemCount = v.itemCount + count } state.go\npackage main type state interface { addItem(int) error requestItem() error insertMoney(money int) error dispenseItem() error } noItemState.go\npackage main import \u0026quot;fmt\u0026quot; type noItemState struct { vendingMachine *vendingMachine } func (i *noItemState) requestItem() error { return fmt.Errorf(\u0026quot;Item out of stock\u0026quot;) } func (i *noItemState) addItem(count int) error { i.vendingMachine.incrementItemCount(count) i.vendingMachine.setState(i.vendingMachine.hasItem) return nil } func (i *noItemState) insertMoney(money int) error { return fmt.Errorf(\u0026quot;Item out of stock\u0026quot;) } func (i *noItemState) dispenseItem() error { return fmt.Errorf(\u0026quot;Item out of stock\u0026quot;) } hasItemState.go\npackage main import \u0026quot;fmt\u0026quot; type hasItemState struct { vendingMachine *vendingMachine } func (i *hasItemState) requestItem() error { if i.vendingMachine.itemCount == 0 { i.vendingMachine.setState(i.vendingMachine.noItem) return fmt.Errorf(\u0026quot;No item present\u0026quot;) } fmt.Printf(\u0026quot;Item requestd\\n\u0026quot;) i.vendingMachine.setState(i.vendingMachine.itemRequested) return nil } func (i *hasItemState) addItem(count int) error { fmt.Printf(\u0026quot;%d items added\\n\u0026quot;, count) i.vendingMachine.incrementItemCount(count) return nil } func (i *hasItemState) insertMoney(money int) error { return fmt.Errorf(\u0026quot;Please select item first\u0026quot;) } func (i *hasItemState) dispenseItem() error { return fmt.Errorf(\u0026quot;Please select item first\u0026quot;) } itemRequestedState.go\npackage main import \u0026quot;fmt\u0026quot; type itemRequestedState struct { vendingMachine *vendingMachine } func (i *itemRequestedState) requestItem() error { return fmt.Errorf(\u0026quot;Item already requested\u0026quot;) } func (i *itemRequestedState) addItem(count int) error { return fmt.Errorf(\u0026quot;Item Dispense in progress\u0026quot;) } func (i *itemRequestedState) insertMoney(money int) error { if money \u0026lt; i.vendingMachine.itemPrice { fmt.Errorf(\u0026quot;Inserted money is less. Please insert %d\u0026quot;, i.vendingMachine.itemPrice) } fmt.Println(\u0026quot;Money entered is ok\u0026quot;) i.vendingMachine.setState(i.vendingMachine.hasMoney) return nil } func (i *itemRequestedState) dispenseItem() error { return fmt.Errorf(\u0026quot;Please insert money first\u0026quot;) } hasMoneyState.go\npackage main import \u0026quot;fmt\u0026quot; type hasMoneyState struct { vendingMachine *vendingMachine } func (i *hasMoneyState) requestItem() error { return fmt.Errorf(\u0026quot;Item dispense in progress\u0026quot;) } func (i *hasMoneyState) addItem(count int) error { return fmt.Errorf(\u0026quot;Item dispense in progress\u0026quot;) } func (i *hasMoneyState) insertMoney(money int) error { return fmt.Errorf(\u0026quot;Item out of stock\u0026quot;) } func (i *hasMoneyState) dispenseItem() error { fmt.Println(\u0026quot;Dispensing Item\u0026quot;) i.vendingMachine.itemCount = i.vendingMachine.itemCount - 1 if i.vendingMachine.itemCount == 0 { i.vendingMachine.setState(i.vendingMachine.noItem) } else { i.vendingMachine.setState(i.vendingMachine.hasItem) } return nil } main.go\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;log\u0026quot; ) func main() { vendingMachine := newVendingMachine(1, 10) err := vendingMachine.requestItem() if err != nil { log.Fatalf(err.Error()) } err = vendingMachine.insertMoney(10) if err != nil { log.Fatalf(err.Error()) } err = vendingMachine.dispenseItem() if err != nil { log.Fatalf(err.Error()) } fmt.Println() err = vendingMachine.addItem(2) if err != nil { log.Fatalf(err.Error()) } fmt.Println() err = vendingMachine.requestItem() if err != nil { log.Fatalf(err.Error()) } err = vendingMachine.insertMoney(10) if err != nil { log.Fatalf(err.Error()) } err = vendingMachine.dispenseItem() if err != nil { log.Fatalf(err.Error()) } } Output:\nItem requestd Money entered is ok Dispensing Item Adding 2 items Item requestd Money entered is ok Dispensing Item "},{"id":202,"href":"/chapter-9/behavioral-patterns/go-strategy-pattern/","title":"9.3.8 الگو Strategy","section":"9.3 الگوهای طراحی رفتاری","content":"الگو Strategy\u0026hellip;\n"},{"id":203,"href":"/chapter-9/behavioral-patterns/go-template-method-pattern/","title":"9.3.9 الگو Template Method","section":"9.3 الگوهای طراحی رفتاری","content":"الگو Template Method\u0026hellip;\n9.3.9.1 مقدمه: # الگوی Template Method یک الگوی طراحی behavioral است که به شما امکان می دهد یک الگو یا الگوریتم برای یک عملیات خاص تعریف کنید. بیایید الگوی Template Method را با یک مثال درک کنیم.\nمثال یک مرز یک بار مصرف (One Time Password) یا OTP را در نظر بگیرید. انواع مختلفی از OTP وجود دارد که می تواند برای مثال اجرا شود. OTP می تواند SMS OTP یا EMAIL OTP باشد. اما صرف نظر از اینکه یک پیامک OTP یا EMAIL OTP باشد، کل مراحل فرآیند OTP یکسان است. مراحل مورد نظر به ترتیب زیر هستند.\nیک عدد n رقمی تصادفی ایجاد کنید. این شماره را برای تأیید بعدی در cache ذخیره کنید. محتوا را آماده کنید notification را ارسال کنید metricsها را Publish کنید حتی در آینده فرض کنید یک push notification OTP معرفی شده است، اما همچنان مراحل بالا را طی خواهد کرد.\nدر چنین سناریوهایی زمانی که مراحل یک عملیات خاص یکسان است اما مراحل عملیات می تواند به روشی متفاوت توسط مجریان مختلف اجرا شود. پس از آن بهترین گزینه برای انتخاب دیزاین پترن مناسب گزینه Template Method می شود. ما یک template یا الگوریتم را تعریف می کنیم که از methodهای fixed number تشکیل شده است. نوشتن برنامه برای حالت جدید باید operation override متدهای template را پیاده سازی کند.\nحالا نمونه کد زیر را بررسی کنید.\niOtp نشان دهنده یک interface است که مجموعه متد هایی را که هر نوع otp باید پیاده سازی کند را تعریف می کند.\nاس ام اس و ایمیل پیاده سازی رابط iOtp هستند\notp ساختاری است که متد template () genAndSendOTP را تعریف می کند. otp رابط iOtp را تعبیه می کند.\nمهم: ترکیب رابط iOtp و ساختار otp قابلیت های Abstract Class را در زبان برنامه نویسی go فراهم می کند. برای اطلعات بیشتر در این مورد مرجع مراجعه کنید.\n9.3.9.2 مثال: # otp.go\npackage main type iOtp interface { genRandomOTP(int) string saveOTPCache(string) getMessage(string) string sendNotification(string) error publishMetric() } type otp struct { iOtp iOtp } func (o *otp) genAndSendOTP(otpLength int) error { otp := o.iOtp.genRandomOTP(otpLength) o.iOtp.saveOTPCache(otp) message := o.iOtp.getMessage(otp) err := o.iOtp.sendNotification(message) if err != nil { return err } o.iOtp.publishMetric() return nil } sms.go\npackage main import \u0026quot;fmt\u0026quot; type sms struct { otp } func (s *sms) genRandomOTP(len int) string { randomOTP := \u0026quot;1234\u0026quot; fmt.Printf(\u0026quot;SMS: generating random otp %s\\n\u0026quot;, randomOTP) return randomOTP } func (s *sms) saveOTPCache(otp string) { fmt.Printf(\u0026quot;SMS: saving otp: %s to cache\\n\u0026quot;, otp) } func (s *sms) getMessage(otp string) string { return \u0026quot;SMS OTP for login is \u0026quot; + otp } func (s *sms) sendNotification(message string) error { fmt.Printf(\u0026quot;SMS: sending sms: %s\\n\u0026quot;, message) return nil } func (s *sms) publishMetric() { fmt.Printf(\u0026quot;SMS: publishing metrics\\n\u0026quot;) } email.go\npackage main import \u0026quot;fmt\u0026quot; type email struct { otp } func (s *email) genRandomOTP(len int) string { randomOTP := \u0026quot;1234\u0026quot; fmt.Printf(\u0026quot;EMAIL: generating random otp %s\\n\u0026quot;, randomOTP) return randomOTP } func (s *email) saveOTPCache(otp string) { fmt.Printf(\u0026quot;EMAIL: saving otp: %s to cache\\n\u0026quot;, otp) } func (s *email) getMessage(otp string) string { return \u0026quot;EMAIL OTP for login is \u0026quot; + otp } func (s *email) sendNotification(message string) error { fmt.Printf(\u0026quot;EMAIL: sending email: %s\\n\u0026quot;, message) return nil } func (s *email) publishMetric() { fmt.Printf(\u0026quot;EMAIL: publishing metrics\\n\u0026quot;) } main.go\npackage main import \u0026quot;fmt\u0026quot; func main() { smsOTP := \u0026amp;sms{} o := otp{ iOtp: smsOTP, } o.genAndSendOTP(4) fmt.Println(\u0026quot;\u0026quot;) emailOTP := \u0026amp;email{} o = otp{ iOtp: emailOTP, } o.genAndSendOTP(4) } Output:\nSMS: generating random otp 1234 SMS: saving otp: 1234 to cache SMS: sending sms: SMS OTP for login is 1234 SMS: publishing metrics EMAIL: generating random otp 1234 EMAIL: saving otp: 1234 to cache EMAIL: sending email: EMAIL OTP for login is 1234 EMAIL: publishing metrics 9.3.9.3 مثال پیاده سازی شده به صورت یکجا: # package main import \u0026quot;fmt\u0026quot; type iOtp interface { genRandomOTP(int) string saveOTPCache(string) getMessage(string) string sendNotification(string) error publishMetric() } type otp struct { iOtp iOtp } func (o *otp) genAndSendOTP(otpLength int) error { otp := o.iOtp.genRandomOTP(otpLength) o.iOtp.saveOTPCache(otp) message := o.iOtp.getMessage(otp) err := o.iOtp.sendNotification(message) if err != nil { return err } o.iOtp.publishMetric() return nil } type sms struct { otp } func (s *sms) genRandomOTP(len int) string { randomOTP := \u0026quot;1234\u0026quot; fmt.Printf(\u0026quot;SMS: generating random otp %s\\n\u0026quot;, randomOTP) return randomOTP } func (s *sms) saveOTPCache(otp string) { fmt.Printf(\u0026quot;SMS: saving otp: %s to cache\\n\u0026quot;, otp) } func (s *sms) getMessage(otp string) string { return \u0026quot;SMS OTP for login is \u0026quot; + otp } func (s *sms) sendNotification(message string) error { fmt.Printf(\u0026quot;SMS: sending sms: %s\\n\u0026quot;, message) return nil } func (s *sms) publishMetric() { fmt.Printf(\u0026quot;SMS: publishing metrics\\n\u0026quot;) } type email struct { otp } func (s *email) genRandomOTP(len int) string { randomOTP := \u0026quot;1234\u0026quot; fmt.Printf(\u0026quot;EMAIL: generating random otp %s\\n\u0026quot;, randomOTP) return randomOTP } func (s *email) saveOTPCache(otp string) { fmt.Printf(\u0026quot;EMAIL: saving otp: %s to cache\\n\u0026quot;, otp) } func (s *email) getMessage(otp string) string { return \u0026quot;EMAIL OTP for login is \u0026quot; + otp } func (s *email) sendNotification(message string) error { fmt.Printf(\u0026quot;EMAIL: sending email: %s\\n\u0026quot;, message) return nil } func (s *email) publishMetric() { fmt.Printf(\u0026quot;EMAIL: publishing metrics\\n\u0026quot;) } func main() { smsOTP := \u0026amp;sms{} o := otp{ iOtp: smsOTP, } o.genAndSendOTP(4) fmt.Println(\u0026quot;\u0026quot;) emailOTP := \u0026amp;email{} o = otp{ iOtp: emailOTP, } o.genAndSendOTP(4) } Output:\nSMS: generating random otp 1234 SMS: saving otp: 1234 to cache SMS: sending sms: SMS OTP for login is 1234 SMS: publishing metrics EMAIL: generating random otp 1234 EMAIL: saving otp: 1234 to cache EMAIL: sending email: EMAIL OTP for login is 1234 EMAIL: publishing metrics "},{"id":204,"href":"/chapter-9/behavioral-patterns/go-visitor-pattern/","title":"9.3.10 الگو Visitor","section":"9.3 الگوهای طراحی رفتاری","content":"الگو Visitor\u0026hellip;\n9.3.10.1 مقدمه: # الگوی طراحی Visitor یک الگوی طراحی Behavioural است که به شما امکان می‌دهد بدون تغییر در ساختار برنامه، رفتاری را به ساختار آن اضافه کنید.\nبیایید الگوی Visitor را با یک مثال درک کنیم. فرض کنید شما نگهدارنده(maintainer) یک lib هستید که ساختارهای با شکل‌های متفاوتی دارد مانند:\nSquare Circle Triangle هر یک از ساختارهای شکل بالا یک شکل رابط مشترک را پیاده سازی می کند. تیم های زیادی در شرکت شما وجود دارند که از lib شما استفاده می کنند. حال فرض کنید یکی از تیم از شما می خواهد که یک رفتار دیگر (getArea()) به ساختارهای Shape اضافه کنید. در نتیجه گزینه های زیادی برای حل این مشکل وجود دارد.\nراه حل اول: # اولین گزینه ای که به ذهن می رسد اضافه کردن متد getArea() در interface مربوط به shape است و سپس هر ساختار shape می تواند متد getArea() را پیاده سازی کند. این به نظر بی اهمیت می رسد اما برخی از مشکلات وجود دارد:\nبه عنوان maintainer کتابخانه، نمی خواهید کد بسیار آزمایش شده کتابخانه خود را با افزودن رفتارهای اضافی تغییر دهید. ممکن است تیم هایی که از کتابخانه شما استفاده می کنند درخواست بیشتری برای رفتارهای بیشتری مانند getNumSides()، getMiddleCoordinates(). سپس، در این مورد، شما نمی خواهید به اصلاح کتابخانه خود ادامه دهید. اما شما می خواهید که تیم های دیگر کتابخانه شما را بدون تغییر واقعی کد گسترش دهند. راه حل دوم: # گزینه دوم این است که تیمی که این ویژگی را درخواست می کند می تواند منطق رفتار را خودش بنویسد. بنابراین بر اساس نوع shape struct آنها کد زیر را در نظر دارند:\nif shape.type == square { //Calculate area for squre } elseif shape.type == circle { //Calculate area of triangle } elseif shape.type == \u0026quot;triangle\u0026quot; { //Calculate area of triangle } else { //Raise error } کد بالا نیز مشکل ساز است زیرا نمی توانید از مزایای کامل interface ها استفاده کنید و به جای آن یک بررسی explicit type که شکننده(fragile) است انجام دهید. دوم، دریافت type در زمان اجرا ممکن است تأثیری بر عملکرد داشته باشد یا حتی در برخی از زبان ها امکان پذیر نباشد.\nراه حل سوم: # گزینه سوم حل مشکل فوق با استفاده از الگوی visitor است. ما یکvisitor interface را مانند زیر تعریف می کنیم.\ntype visitor interface { visitForSquare(square) visitForCircle(circle) visitForTriangle(triangle) } توابع visitforSquare(square)، visitForCircle(circle)، visitForTriangle(triangle) به ما اجازه می دهد تا به ترتیب قابلیت های Square، Circle و Triangle را اضافه کنیم.\nحال سوالی که به ذهن می رسد این است که چرا نمی توانیم یک روش visit**(shape)** واحد در visitor interface داشته باشیم. دلیل اینکه ما این ویژگی را نداریم این است که GO و همچنین برخی از زبان های دیگر از method overloading پشتیبانی می کنند. بنابراین یک method متفاوت برای هر یک از ساختارها مورد نیاز است.\nما یک accept method را با signature زیر به shape interface اضافه می کنیم و هر یک از shape struct باید این متد را تعریف کنند.\nfunc accept(v visitor) اما یک لحظه صبر کنید، ما فقط اشاره کردیم که نمی خواهیم shape structs موجود خود را تغییر دهیم. اما هنگام استفاده از Visitor Pattern باید shape structs خود را تغییر دهیم اما این اصلاح فقط یک بار انجام می شود. در صورت اضافه کردن هر رفتار اضافی مانند getNumSides()، getMiddleCoordinates() از همان تابع accept(v visitor) فوق بدون تغییر بیشتر در shape structs استفاده می کند. اساساً shape structs فقط باید یک بار اصلاح شوند و تمام درخواست‌های آتی رفتارهای اضافی با استفاده از همان تابع پذیرش بررسی می‌شوند. ببینیم چطور! ساختار مربع (square struct) یک accept method مانند زیر را اجرا می کند:\nfunc (obj *squre) accept(v visitor){ v.visitForSquare(obj) } و به طور مشابه، دایره و مثلث نیز accept function را مانند بالا تعریف می کنند.\nاکنون تیمی که رفتار getArea() را درخواست می‌کند، می‌تواند به سادگی concrete implementation را برای visitor interface را تعریف کند و منطق محاسبه ناحیه را در آن concrete implementation بنویسد.\nareaCalculator.go\ntype areaCalculator struct{ area int } func (a *areaCalculator) visitForSquare(s *square){ //Calculate are for square } func (a *areaCalculator) visitForCircle(s *square){ //Calculate are for circle } func (a *areaCalculator) visitForTriangle(s *square){ //Calculate are for triangle برای محاسبه مساحت یک مربع، ابتدا نمونه ای از مربعی که آنها به سادگی می توانند فراخوانی کنند ایجاد می کنیم.\nsq := \u0026amp;square{} ac := \u0026amp;areaCalculator{} sq.accept(ac) به طور مشابه، تیم دیگری که برای رفتار getMiddleCoordinates() درخواست می‌کند، می‌تواند پیاده‌سازی concrete دیگری از visitor interfaceمشابه با بالا تعریف کند.\nmiddleCoordinates.go\ntype middleCoordinates struct { x int y int } func (a *middleCoordinates) visitForSquare(s *square) { //Calculate middle point coordinates for square. After calculating the area assign in to the x and y instance variable. } func (a *middleCoordinates) visitForCircle(c *circle) { //Calculate middle point coordinates for square. After calculating the area assign in to the x and y instance variable. } func (a *middleCoordinates) visitForTriangle(t *triangle) { //Calculate middle point coordinates for square. After calculating the area assign in to the x and y instance variable. } در زیر نمودار mapping UML متناظر با مثال عملی shape struct و areaCalculator که در بالا ارائه کردیم آمده است.\n9.3.10.2 # Mapping: # جدول زیر mapping از اجزای مهم نمودار UML به اجزای واقعی implementation را در \u0026lsquo;مثال\u0026rsquo; زیر نشان می دهد.\nelement shape.go Concrete Element A square.go Concrete Element B circle.go Concrete Element C rectangle.go Visitor visitor.go Concrete Visitor 1 areaCalculator.go Concrete Visitor 2 middleCoordinates.go Client main.go 9.3.10.3 # مثال: # shape.go\npackage main type shape interface { getType() string accept(visitor) } square.go\npackage main type square struct { side int } func (s *square) accept(v visitor) { v.visitForSquare(s) } func (s *square) getType() string { return \u0026quot;Square\u0026quot; } circle.go\npackage main type circle struct { radius int } func (c *circle) accept(v visitor) { v.visitForCircle(c) } func (c *circle) getType() string { return \u0026quot;Circle\u0026quot; } rectangle.go\npackage main type rectangle struct { l int b int } func (t *rectangle) accept(v visitor) { v.visitForrectangle(t) } func (t *rectangle) getType() string { return \u0026quot;rectangle\u0026quot; } visitor.go\npackage main type visitor interface { visitForSquare(*square) visitForCircle(*circle) visitForrectangle(*rectangle) } areaCalculator.go\npackage main import ( \u0026quot;fmt\u0026quot; ) type areaCalculator struct { area int } func (a *areaCalculator) visitForSquare(s *square) { //Calculate area for square. After calculating the area assign in to the area instance variable fmt.Println(\u0026quot;Calculating area for square\u0026quot;) } func (a *areaCalculator) visitForCircle(s *circle) { //Calculate are for circle. After calculating the area assign in to the area instance variable fmt.Println(\u0026quot;Calculating area for circle\u0026quot;) } func (a *areaCalculator) visitForrectangle(s *rectangle) { //Calculate are for rectangle. After calculating the area assign in to the area instance variable fmt.Println(\u0026quot;Calculating area for rectangle\u0026quot;) } middleCoordinates.go\npackage main import \u0026quot;fmt\u0026quot; type middleCoordinates struct { x int y int } func (a *middleCoordinates) visitForSquare(s *square) { //Calculate middle point coordinates for square. After calculating the area assign in to the x and y instance variable. fmt.Println(\u0026quot;Calculating middle point coordinates for square\u0026quot;) } func (a *middleCoordinates) visitForCircle(c *circle) { //Calculate middle point coordinates for square. After calculating the area assign in to the x and y instance variable. fmt.Println(\u0026quot;Calculating middle point coordinates for circle\u0026quot;) } func (a *middleCoordinates) visitForrectangle(t *rectangle) { //Calculate middle point coordinates for square. After calculating the area assign in to the x and y instance variable. fmt.Println(\u0026quot;Calculating middle point coordinates for rectangle\u0026quot;) } main.go\npackage main import \u0026quot;fmt\u0026quot; func main() { square := \u0026amp;square{side: 2} circle := \u0026amp;circle{radius: 3} rectangle := \u0026amp;rectangle{l: 2, b: 3} areaCalculator := \u0026amp;areaCalculator{} square.accept(areaCalculator) circle.accept(areaCalculator) rectangle.accept(areaCalculator) fmt.Println() middleCoordinates := \u0026amp;middleCoordinates{} square.accept(middleCoordinates) circle.accept(middleCoordinates) rectangle.accept(middleCoordinates) } Output:\nCalculating area for square Calculating area for circle Calculating area for rectangle Calculating middle point coordinates for square Calculating middle point coordinates for circle Calculating middle point coordinates for rectangle 9.3.10.3 # پیاده سازی به صورت یک جا: # package main import \u0026quot;fmt\u0026quot; type shape interface { getType() string accept(visitor) } type square struct { side int } func (s *square) accept(v visitor) { v.visitForSquare(s) } func (s *square) getType() string { return \u0026quot;Square\u0026quot; } type circle struct { radius int } func (c *circle) accept(v visitor) { v.visitForCircle(c) } func (c *circle) getType() string { return \u0026quot;Circle\u0026quot; } type rectangle struct { l int b int } func (t *rectangle) accept(v visitor) { v.visitForrectangle(t) } func (t *rectangle) getType() string { return \u0026quot;rectangle\u0026quot; } type visitor interface { visitForSquare(*square) visitForCircle(*circle) visitForrectangle(*rectangle) } type areaCalculator struct { area int } func (a *areaCalculator) visitForSquare(s *square) { //Calculate area for square. After calculating the area assign in to the area instance variable fmt.Println(\u0026quot;Calculating area for square\u0026quot;) } func (a *areaCalculator) visitForCircle(s *circle) { //Calculate are for circle. After calculating the area assign in to the area instance variable fmt.Println(\u0026quot;Calculating area for circle\u0026quot;) } func (a *areaCalculator) visitForrectangle(s *rectangle) { //Calculate are for rectangle. After calculating the area assign in to the area instance variable fmt.Println(\u0026quot;Calculating area for rectangle\u0026quot;) } type middleCoordinates struct { x int y int } func (a *middleCoordinates) visitForSquare(s *square) { //Calculate middle point coordinates for square. After calculating the area assign in to the x and y instance variable. fmt.Println(\u0026quot;Calculating middle point coordinates for square\u0026quot;) } func (a *middleCoordinates) visitForCircle(c *circle) { //Calculate middle point coordinates for square. After calculating the area assign in to the x and y instance variable. fmt.Println(\u0026quot;Calculating middle point coordinates for circle\u0026quot;) } func (a *middleCoordinates) visitForrectangle(t *rectangle) { //Calculate middle point coordinates for square. After calculating the area assign in to the x and y instance variable. fmt.Println(\u0026quot;Calculating middle point coordinates for rectangle\u0026quot;) } func main() { square := \u0026amp;square{side: 2} circle := \u0026amp;circle{radius: 3} rectangle := \u0026amp;rectangle{l: 2, b: 3} areaCalculator := \u0026amp;areaCalculator{} square.accept(areaCalculator) circle.accept(areaCalculator) rectangle.accept(areaCalculator) fmt.Println() middleCoordinates := \u0026amp;middleCoordinates{} square.accept(middleCoordinates) circle.accept(middleCoordinates) rectangle.accept(middleCoordinates) } Output:\nCalculating area for square Calculating area for circle Calculating area for rectangle Calculating middle point coordinates for square Calculating middle point coordinates for circle Calculating middle point coordinates for rectangle "},{"id":205,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-wait-for-result/","title":"9.4.1 الگو Wait For Result","section":"9.4 الگوهای همزمانی","content":" 9.4.1.1 توضیحات # الگوی Wait For Result یکی از پرکاربردترین الگوها در برنامه‌نویسی همزمان با Go است که هدفش اجرای عملیات به صورت goroutine و انتظار برای دریافت نتیجه از طریق channel است. در این الگو، معمولاً یک کانال تعریف می‌شود تا داده یا نتیجه (و حتی خطا) از goroutine به کد اصلی منتقل شود. این کار باعث می‌شود عملیات‌های طولانی یا زمان‌بر (مثل خواندن فایل، تماس با API یا انجام محاسبات سنگین) بدون بلاک کردن کل برنامه اجرا شوند و به محض آماده شدن نتیجه، به صورت ایمن و همزمان، دریافت شوند. ساختار معمول این الگو به این صورت است که یک goroutine کار را انجام می‌دهد و در پایان نتیجه را داخل کانال می‌فرستد؛ در این مدت goroutine اصلی (یا هر مصرف‌کننده دیگر) با دریافت روی کانال منتظر نتیجه می‌ماند.\nاین الگو هم از نظر سادگی و هم از نظر ایمنی، مزیت بالایی دارد و پیاده‌سازی آن با استفاده از کانال‌های Go، باعث می‌شود برنامه دچار race condition یا مشکلات همزمانی نشود. همچنین با اضافه کردن ساختارهایی مثل struct حاوی مقدار و خطا، یا استفاده از context برای مدیریت تایم‌اوت و کنسل کردن، می‌توان این الگو را کاملاً production-ready کرد. به طور خلاصه، Wait For Result راهکاری است که به کمک آن، ضمن استفاده بهینه از منابع و افزایش کارایی، کنترل کاملی بر زمان و نتیجه عملیات‌های همزمان خواهید داشت و به راحتی می‌توانید منطق‌های پیچیده‌تر مثل جمع‌آوری نتایج، مدیریت خطاها، یا پیاده‌سازی تایم‌اوت را نیز به آن اضافه کنید.\n9.4.1.2 دیاگرام # sequenceDiagram participant Main as Main Goroutine participant Chan as Channel participant Worker as Worker Goroutine Main-\u003e\u003eChan: ایجاد channel Main-\u003e\u003eWorker: راه‌اندازی goroutine (با ارجاع به channel) Worker-\u003e\u003eWorker: انجام عملیات (مثلاً I/O) Worker-\u003e\u003eChan: ارسال نتیجه به channel Main-\u003e\u003eChan: منتظر دریافت نتیجه از channel Chan--\u003e\u003eMain: دریافت نتیجه 9.4.1.3 نمونه کد # package main import ( \"fmt\" \"time\" ) func longRunningTask(c chan int) { time.Sleep(3 * time.Second) c \u003c- 42 } func main() { c := make(chan int) go longRunningTask(c) result := \u003c-c fmt.Println(\"Result:\", result) } ▶ اجرای کد کپی ✖ بستن خروجی این کد نمونه، مفهوم الگوی Wait For Result را در Go به شکلی بسیار ساده و شفاف پیاده‌سازی می‌کند. در این برنامه، یک تابع به نام longRunningTask داریم که شبیه‌ساز یک کار زمان‌بر است؛ این تابع پس از سه ثانیه توقف (با استفاده از time.Sleep) عدد ۴۲ را از طریق یک کانال (channel) به بخش اصلی برنامه (main goroutine) ارسال می‌کند. در تابع main، ابتدا یک کانال بدون بافر ساخته شده و سپس با استفاده از goroutine، تابع زمان‌بر به طور موازی اجرا می‌شود. پس از آن، برنامه اصلی منتظر می‌ماند تا مقدار از کانال دریافت شود و به محض دریافت، مقدار دریافت‌شده را چاپ می‌کند.\nکاربرد این الگو در سناریوهایی است که نیاز داریم عملیات زمان‌بر یا همزمان را اجرا کنیم و در عین حال تا زمان آماده شدن نتیجه، سایر بخش‌های برنامه بلاک نشود یا بتوانیم همزمان چندین کار دیگر را انجام دهیم. دریافت مقدار از کانال در اینجا نقش \u0026ldquo;منتظر ماندن برای نتیجه\u0026rdquo; را دارد و هنگامی که goroutine مقدار را ارسال کند، ادامه‌ی برنامه اصلی اجرا می‌شود. این روش به صورت idiomatic و ایمن، همزمانی و انتقال داده بین goroutineها را در Go مدیریت می‌کند و به‌سادگی می‌توان آن را در مسائل واقعی‌تر، مثلاً پردازش موازی درخواست‌ها یا جمع‌آوری نتایج عملیات‌های موازی، استفاده کرد.\n9.4.1.4 کاربردها # Web Scraping: زمانی که عملیات web scraping انجام می‌دهید، معمولاً نیاز است به طور همزمان از چندین آدرس وب داده جمع‌آوری کنید. در این حالت می‌توانید درخواست‌ها را به صورت موازی (با استفاده از goroutine) به چندین سایت ارسال کرده و سپس با استفاده از این الگو منتظر بمانید تا نتایج همه درخواست‌ها دریافت شود؛ این کار باعث افزایش چشمگیر سرعت جمع‌آوری داده می‌شود. API Calls: در معماری میکروسرویس، گاهی لازم است چندین API را به صورت همزمان فراخوانی کنید و پس از دریافت نتایج، نتیجه نهایی را به کلاینت برگردانید. این الگو به شما این امکان را می‌دهد که همزمان درخواست‌ها را ارسال کنید و به صورت منتظر (blocking) روی دریافت پاسخ‌ها بمانید تا همه نتایج آماده شود و در نهایت با کمترین زمان ممکن پاسخ‌دهی انجام دهید. Parallel Computation: در پردازش‌های علمی یا داده‌ای، معمولاً نیاز است محاسبات سنگین را به صورت موازی اجرا کنید. می‌توانید هر بخش از محاسبات را در goroutine جداگانه انجام دهید و با استفاده از این الگو، تا زمانی که تمام نتایج آماده نشده‌اند، منتظر بمانید و پس از دریافت همه پاسخ‌ها، مرحله بعدی پردازش را آغاز کنید. "},{"id":206,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-fan-out-in/","title":"9.4.2 الگو Fan Out/In","section":"9.4 الگوهای همزمانی","content":" 9.4.2.1 توضیحات # الگوی Fan Out/In یکی از مهم‌ترین تکنیک‌های همزمانی در زبان Go است که برای افزایش کارایی و سرعت پردازش در سناریوهایی به‌کار می‌رود که نیاز داریم چندین کار مشابه یا مستقل را به صورت موازی انجام دهیم و در نهایت نتایج همه آن‌ها را جمع‌آوری و تجمیع کنیم. در این الگو، معمولاً یک goroutine اصلی چندین goroutine فرعی را راه‌اندازی می‌کند (Fan Out) تا هر کدام یک وظیفه مستقل را انجام دهند؛ سپس نتایج این goroutineها (که می‌تواند هر نوع داده یا حتی خطا باشد) از طریق کانال‌ها جمع‌آوری شده و پس از اتمام همه کارها، نتیجه نهایی (Fan In) به goroutine اصلی برگردانده می‌شود.\nاین الگو به طور گسترده در جاهایی مانند جمع‌آوری داده از منابع مختلف، پردازش موازی بخش‌های مختلف یک داده بزرگ، یا حتی در معماری‌های میکروسرویس برای جمع‌آوری پاسخ چندین سرویس کاربرد دارد. مزیت اصلی Fan Out/In در Go این است که با استفاده از goroutineها و channelها می‌توان به‌سادگی کارهای موازی را مدیریت کرد، منتظر اتمام تمام کارها ماند و در عین حال، همزمانی ایمن و بدون race condition را حفظ کرد. به عنوان مثال، اگر نیاز باشد صدها درخواست HTTP به طور همزمان ارسال و پاسخ‌ها تجمیع شوند، یا بخش‌های یک فایل بزرگ به صورت موازی پردازش شوند، این الگو بهترین انتخاب است و به سادگی در Go پیاده‌سازی می‌شود.\n9.4.2.2 دیاگرام # graph LR A[InputChannel] --\u003e B1(Add) A --\u003e B2(Add) A --\u003e B3(Add) A --\u003e B4(Add) B1 --\u003e C(Merge) B2 --\u003e C B3 --\u003e C B4 --\u003e C C --\u003e D(Multiply) classDef faded fill:#fff,stroke:#bbb,stroke-width:2px; classDef step fill:#e3ffe3,stroke:#b4eeb4,stroke-width:2px; classDef merge fill:#ffecc7,stroke:#efb64f,stroke-width:2px; class A faded; class B1,B2,B3,B4 step; class C merge; class D step; B1--\u003e|Fan-Out|A C--\u003e|Fan-In|B1 9.4.2.3 نمونه کد # فرض کنید قصد دارید یک برنامه ای بنویسید که چندین فایل بصورت موازی دانلود کنید و در نهایت محتوای این فایل را میخواهید ترکیب کنید و یک خروجی داشته باشید.\nدر زیر یک مثال ساده زدیم :\npackage main import ( \"fmt\" \"sync\" ) // ساختار نتیجه دانلود type DownloadResult struct { URL string Data string Err error } func main() { urls := []string{\"url1\", \"url2\", \"url3\"} var wg sync.WaitGroup results := make(chan DownloadResult, len(urls)) // کانال بافر دار به اندازه تعداد urlها // Fan-Out: اجرای موازی دانلودها for _, url := range urls { wg.Add(1) go func(url string) { defer wg.Done() data, err := downloadFile(url) results \u003c- DownloadResult{ URL: url, Data: data, Err: err, } }(url) } // Fan-In: بستن کانال پس از پایان همه goroutineها go func() { wg.Wait() close(results) }() // جمع‌آوری و نمایش نتایج for result := range results { if result.Err != nil { fmt.Printf(\"خطا در دانلود %s: %v\\n\", result.URL, result.Err) continue } fmt.Printf(\"دانلود %s موفقیت‌آمیز: %s\\n\", result.URL, result.Data) } } // شبیه‌ساز دانلود فایل func downloadFile(url string) (string, error) { // در اینجا می‌توانید کد واقعی دانلود را قرار دهید if url == \"url2\" { return \"\", fmt.Errorf(\"اتصال برقرار نشد\") } return \"file contents of \" + url, nil } ▶ اجرای کد کپی ✖ بستن خروجی در این مثال از الگوی Fan-Out/Fan-In در Go، عملیات دانلود فایل‌ها از چندین آدرس به صورت کاملاً موازی و ایمن انجام می‌شود و مدیریت خطاها، شناسایی منبع داده و خوانایی کد به شکل قابل توجهی ارتقا یافته است. ساختار جدیدی به نام DownloadResult تعریف شده که اطلاعات هر دانلود شامل آدرس منبع (URL)، داده دریافتی (Data) و هرگونه خطا (Err) را در خود نگه می‌دارد. این کار باعث می‌شود در زمان جمع‌آوری نتایج، به‌راحتی بتوان نتیجه‌ی هر عملیات را با منبع آن تطبیق داد و مدیریت خطا را به صورت مجزا و تمیز انجام داد؛ در حالی که در کد اولیه، فقط داده به صورت یک رشته ساده منتقل می‌شد و اگر خطایی رخ می‌داد، امکان تشخیص منبع آن وجود نداشت.\nدر مرحله Fan-Out، با استفاده از یک حلقه، برای هر URL یک goroutine راه‌اندازی می‌شود که وظیفه دانلود داده از آن آدرس را بر عهده دارد. به‌منظور جلوگیری از بلاک شدن ناخواسته goroutineها (به ویژه اگر دریافت روی کانال با تأخیر انجام شود)، یک کانال بافر دار به اندازه تعداد آدرس‌ها تعریف شده است. هر goroutine پس از اتمام کار، نتیجه (اعم از موفق یا ناموفق) را به صورت یک ساختار DownloadResult داخل کانال قرار می‌دهد و با استفاده از wg.Done() پایان کار خود را به WaitGroup اعلام می‌کند. به‌طور همزمان، یک goroutine دیگر وظیفه دارد پس از اتمام همه عملیات‌ها (یعنی وقتی شمارنده WaitGroup به صفر رسید)، کانال نتایج را ببندد تا مصرف‌کننده (main goroutine) از پایان عملیات‌ها مطلع شود.\nدر مرحله Fan-In، کد اصلی با استفاده از حلقه for result := range results همه نتایج را از کانال دریافت می‌کند. اگر برای هر آدرس خطایی رخ داده باشد، پیام خطا به همراه نام منبع نمایش داده می‌شود و در غیر این صورت، پیام موفقیت و محتوای دانلود شده چاپ می‌گردد. به این ترتیب، امکان مدیریت خطاها، ثبت وضعیت هر دانلود و افزایش شفافیت و قابلیت دیباگ کد به دست می‌آید. از این الگو می‌توان به عنوان هسته اصلی جمع‌آوری موازی داده‌ها، پردازش موازی یا کار با چندین سرویس مختلف استفاده کرد؛ در حالی که همچنان کد خوانا، ایمن و توسعه‌پذیر باقی می‌ماند.\nاین نسخه، به خاطر ساختار‌بندی داده‌ها، مدیریت دقیق goroutineها و رعایت نکات idiomatic زبان Go، کاملاً مناسب پروژه‌های جدی و تولیدی است و به راحتی می‌توان قابلیت‌هایی مثل شمارش زمان پاسخ‌دهی، ذخیره خروجی‌ها یا مدیریت خطاهای خاص را به آن اضافه کرد. این رویکرد بهترین تمرین‌های تولیدی (production-ready best practices) برای کار با همزمانی در Go را به نمایش می‌گذارد و برای سناریوهای واقعی مانند Web Scraping، جمع‌آوری داده از میکروسرویس‌ها یا پردازش موازی فایل‌ها کاملاً قابل اتکا است.\n9.4.2.4 کاربردها # پردازش داده (Data Processing): با استفاده از الگوی Fan-Out/Fan-In می‌توانید حجم زیادی از داده‌ها را به طور موازی پردازش کنید. به عنوان مثال، زمانی که یک داده بزرگ دارید و باید روی آن پردازش انجام دهید، می‌توانید آن را به بخش‌های کوچک‌تر تقسیم کرده و هر بخش را به یک goroutine اختصاص دهید تا پردازش موازی انجام شود. در نهایت، با جمع‌آوری خروجی‌ها از طریق channel، نتیجه نهایی ترکیب و آماده می‌شود. این روش برای سناریوهایی مثل پردازش موازی تصاویر، فایل‌های متنی بزرگ یا داده‌های عددی بسیار مناسب است. Web Scraping: الگوی Fan-Out/Fan-In برای پیاده‌سازی عملیات scraping همزمان روی چندین وب‌سایت یا صفحات وب بسیار کاربردی است. به این صورت که چندین goroutine برای استخراج داده از صفحات مختلف راه‌اندازی می‌شوند و هر کدام نتیجه استخراج‌شده را از طریق یک channel بازمی‌گردانند. سپس این نتایج جمع‌آوری و در صورت نیاز پردازش یا ذخیره می‌شوند. این روش هم سرعت scraping را به شدت افزایش می‌دهد و هم مدیریت منابع را آسان می‌کند. محاسبات توزیع‌شده (Distributed Computing): در سناریوهای محاسبات توزیع‌شده می‌توانید با Fan-Out، چندین goroutine ایجاد کنید که هرکدام وظیفه ارسال یک job به node یا ماشین متفاوتی را دارند و پس از دریافت پاسخ (مثلاً از طریق RPC یا REST)، نتیجه را از طریق channel ارسال می‌کنند. سپس goroutine اصلی تمام نتایج را جمع‌آوری و به صورت ترکیبی یا aggregate پردازش می‌کند. این مدل برای اجرای موازی taskها در خوشه‌های محاسباتی یا توزیع workload در زیرساخت distributed بسیار مناسب است. مدیریت شبکه و اتصالات همزمان: با استفاده از Fan-Out می‌توان برای مدیریت چندین کانکشن ورودی (مثلاً در سرورهای TCP یا HTTP) برای هر کانکشن یک goroutine راه‌اندازی کرد. هر goroutine پردازش مربوط به کانکشن خود را انجام می‌دهد و نتیجه را به channel ارسال می‌کند. سپس در مرحله Fan-In، نتایج تمام کانکشن‌ها جمع‌آوری، ترکیب و بر اساس نیاز پردازش نهایی یا پاسخ به کلاینت انجام می‌شود. این معماری به سادگی مقیاس‌پذیر و مناسب برای سرورهای real-time یا سیستم‌های event-driven است. "},{"id":207,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-wait-for-task/","title":"9.4.3 الگو Wait For Task","section":"9.4 الگوهای همزمانی","content":" 9.4.3.1 توضیحات # الگوی Wait For Task یکی از ساده‌ترین و در عین حال پراستفاده‌ترین الگوهای همزمانی در Go است که برای منتظر ماندن تا اتمام یک فرآیند یا تسک معین کاربرد دارد. در این الگو معمولاً یک goroutine برای انجام کاری خاص راه‌اندازی می‌شود و پس از اتمام، از طریق یک channel به goroutine اصلی سیگنال پایان کار یا حتی داده‌ی تولیدشده را منتقل می‌کند. این روش به شما امکان می‌دهد همزمان چند کار مستقل را اجرا کنید و به صورت مجزا منتظر پایان هرکدام باشید، یا دقیقاً در لحظه‌ای مشخص بدانید یک تسک خاص تمام شده است و می‌توانید ادامه برنامه را اجرا کنید.\nدر رایج‌ترین شکل این الگو، یک کانال (معمولاً از نوع chan struct{} یا یک کانال بافر نشده) ایجاد می‌شود تا فقط نقش ارسال سیگنال (بدون دیتا) را بازی کند. برای مثال، یک goroutine عملیات طولانی یا I/O را انجام می‌دهد و پس از اتمام، با ارسال یک مقدار خالی (مثلاً done \u0026lt;- struct{}{}) به channel، پایان کار را اطلاع می‌دهد؛ main goroutine نیز با دریافت از channel (\u0026lt;-done) منتظر می‌ماند تا کار کامل شود. اگر علاوه بر سیگنال، نیاز به انتقال داده نیز باشد، می‌توان کانال را از نوع داده‌ی مورد انتظار ساخت تا خروجی همزمان با سیگنال ارسال شود.\nکاربرد این الگو بسیار وسیع است؛ مثلاً در انجام یک کار زمان‌بر و اطلاع به UI یا سیستم دیگر، هماهنگی بین تسک‌های موازی، یا مدیریت صحیح پایان عملیات‌های async. همچنین اگر بخواهید چندین تسک موازی را اجرا کنید و منتظر اتمام همه آن‌ها بمانید، می‌توانید برای هر تسک یک channel جدا بسازید یا از sync.WaitGroup استفاده کنید (الگویی ترکیبی از Wait For Task و WaitGroup). این شیوه نه تنها باعث خوانایی و سادگی کنترل جریان برنامه می‌شود، بلکه از مشکلات رایج همزمانی (مانند race condition) نیز جلوگیری می‌کند و در عمل، ابزاری سریع و idiomatic برای سینک کردن تسک‌ها در Go به شمار می‌رود.\nدر نهایت، ترکیب این الگو با ساختارهای دیگر (مانند context یا select) امکان مدیریت پیشرفته‌تر، پیاده‌سازی تایم‌اوت، کنسل کردن عملیات و حتی مدیریت خطا را به سادگی فراهم می‌کند. این ویژگی‌ها سبب شده الگوی Wait For Task تقریباً در تمام پروژه‌های تولیدی Go، از پردازش ساده تا سیستم‌های توزیع‌شده، به شکل گسترده‌ای استفاده شود.\n9.4.3.2 دیاگرام # sequenceDiagram participant Main as Main Goroutine participant Task as Task Goroutine participant Chan as Done Channel Main-\u003e\u003eTask: راه‌اندازی goroutine برای اجرای تسک Task-\u003e\u003eTask: انجام عملیات (مثلاً: I/O یا پردازش) Task-\u003e\u003eChan: ارسال سیگنال پایان (done) Main-\u003e\u003eChan: منتظر دریافت سیگنال پایان Chan--\u003e\u003eMain: دریافت سیگنال و ادامه اجرای برنامه 9.4.3.3 نمونه کد # package main import ( \"fmt\" \"time\" ) // تعریف ساختار نتیجه کار type TaskResult struct { Data string Err error } func main() { done := make(chan TaskResult) go task(done) result := \u003c-done if result.Err != nil { fmt.Println(\"Task failed:\", result.Err) return } fmt.Println(\"Task complete!\") fmt.Println(\"Result:\", result.Data) } func task(done chan\u003c- TaskResult) { fmt.Println(\"Task started...\") time.Sleep(2 * time.Second) // شبیه‌سازی کار زمان‌بر // شبیه‌سازی موفقیت/خطا if time.Now().Unix()%2 == 0 { done \u003c- TaskResult{ Data: \"Some useful data\", Err: nil, } } else { done \u003c- TaskResult{ Data: \"\", Err: fmt.Errorf(\"خطا در اجرای تسک\"), } } } ▶ اجرای کد کپی ✖ بستن خروجی در این مثال بهبود‌یافته، یک پیاده‌سازی حرفه‌ای و واقعی‌تر از الگوی Wait For Task در Go را مشاهده می‌کنید. هدف این است که هم‌زمانی، انتقال نتیجه یا خطا، و مدیریت کامل جریان کار به ساده‌ترین و امن‌ترین شکل انجام شود. ابتدا در تابع main یک کانال از نوع TaskResult ایجاد شده که این ساختار می‌تواند هم داده خروجی (در صورت نیاز) و هم خطا را در خود نگه دارد. سپس با اجرای goroutine تابع task، عملیات به صورت موازی شروع می‌شود و در این مدت، main منتظر می‌ماند تا نتیجه‌ای از کانال دریافت کند.\nدر تابع task ابتدا پیامی برای شروع کار چاپ می‌شود و سپس با دستور time.Sleep(2 * time.Second)، انجام یک کار زمان‌بر شبیه‌سازی می‌گردد. پس از آن، با یک شرط ساده، گاهی نتیجه موفقیت‌آمیز با داده خروجی و گاهی هم یک خطا به کانال ارسال می‌شود. این رویکرد نشان می‌دهد که چطور در سناریوهای واقعی، هم نتیجه و هم خطا را می‌توان به راحتی از طریق کانال به goroutine اصلی منتقل کرد تا کنترل کاملی روی مدیریت جریان و واکنش به خطاها داشت.\nدر بخش جمع‌آوری نتیجه، main با دریافت مقدار از کانال، ابتدا بررسی می‌کند که آیا خطایی رخ داده یا خیر؛ اگر خطا وجود داشته باشد، پیام مناسب چاپ شده و اجرای برنامه خاتمه می‌یابد. در غیر این صورت، پیام موفقیت و داده خروجی نمایش داده می‌شود. این ساختار باعث می‌شود کد همزمان کاملاً idiomatic، قابل گسترش و مناسب استفاده در پروژه‌های جدی باشد، چرا که به سادگی می‌توان مدیریت خطا، پردازش نتیجه و سینک شدن با کارهای async را با امنیت و شفافیت کامل انجام داد. این الگو پایه‌ای برای بسیاری از نیازهای تولیدی، مخصوصاً در هماهنگی و کنترل جریان بین goroutineها محسوب می‌شود.\n9.4.3.4 کاربردها # پردازش موازی حجم بالای داده‌ها: این الگو برای زمانی مناسب است که نیاز دارید حجم زیادی از داده‌ها را به بخش‌های کوچک‌تر تقسیم کرده و هر بخش را با یک goroutine مجزا به صورت موازی پردازش کنید. با استفاده از کانال و مکانیزم انتظار (wait)، می‌توانید تا اتمام کامل همه goroutineها منتظر بمانید و سپس مرحله بعدی برنامه را آغاز کنید. این روش، بهره‌وری پردازش را به شدت افزایش می‌دهد و زمان کل عملیات را کاهش می‌دهد. برقراری چندین درخواست API به صورت همزمان: هنگام کار با سرویس‌های خارجی یا معماری‌های میکروسرویس، ممکن است نیاز باشد چندین تماس API را همزمان برقرار کنید و نتایج آن‌ها را جمع‌آوری نمایید. با الگوی Wait For Task می‌توانید هر درخواست را در یک goroutine ارسال کنید و سپس با جمع‌آوری سیگنال یا داده از کانال‌ها، فقط پس از دریافت همه پاسخ‌ها ادامه دهید؛ این کار latency سیستم را کاهش می‌دهد و تجربه کاربری بهتری فراهم می‌کند. مدیریت ورودی کاربر به صورت غیرمسدودکننده: اگر بخواهید برنامه شما همچنان اجرا شود و در پس‌زمینه منتظر دریافت ورودی از کاربر باشید، می‌توانید یک goroutine مخصوص برای دریافت ورودی کاربر ایجاد کنید و پس از دریافت ورودی، سیگنالی از طریق کانال ارسال کنید. این الگو موجب می‌شود برنامه اصلی بلاک نشود و بتواند همزمان کارهای دیگری انجام دهد تا زمانی که ورودی کاربر فراهم شود. منتظر آماده‌سازی منابع حیاتی: گاهی قبل از اجرای منطق اصلی برنامه نیاز است مطمئن شوید منابعی مثل اتصال پایگاه داده، باز شدن فایل یا ارتباط با سرویس خاصی برقرار شده است. با راه‌اندازی یک goroutine برای آماده‌سازی این منابع و ارسال سیگنال پس از آماده شدن، می‌توانید با اطمینان و همزمانی صحیح، اجرای برنامه را کنترل کنید و فقط در زمان آماده بودن منبع به مرحله بعد بروید. مدیریت انجام کارهای پس‌زمینه: می‌توانید از این الگو برای اجرای یک عملیات در پس‌زمینه (مثلاً جمع‌آوری لاگ، بروزرسانی کش یا هر کار زمان‌بری که مستقیم به کاربر نمایش داده نمی‌شود) استفاده کنید و پیش از شروع مراحل بعدی یا خاموش شدن برنامه، مطمئن شوید این تسک به پایان رسیده است. این کار به شما کنترل کامل بر هماهنگی بخش‌های مختلف سیستم می‌دهد. "},{"id":208,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-worker-pool/","title":"9.4.4 الگوی Worker Pool","section":"9.4 الگوهای همزمانی","content":" 9.4.4.1 توضیحات # الگوی Worker Pool یکی از مهم‌ترین الگوهای همزمانی در Go محسوب می‌شود و زمانی به‌کار می‌رود که بخواهید تعداد مشخصی goroutine (معمولاً با نقش کارگر یا worker) داشته باشید که وظایف مختلف را به صورت صف (queue) دریافت و اجرا کنند. این کار باعث کنترل بهتر منابع، جلوگیری از ایجاد goroutine بیش از حد (که ممکن است باعث مصرف بی‌رویه CPU و memory یا حتی crash برنامه شود) و مدیریت صف کارها در سیستم‌های real-world و پرلود می‌شود. در این الگو، یک یا چند کانال برای ارسال وظایف (task queue) و دریافت نتایج بین goroutineهای تولیدکننده (producer) و goroutineهای worker (مصرف‌کننده) استفاده می‌شود.\nمثلاً در یک سیستم وب یا پردازش موازی داده، می‌توانید یک کانال برای صف کردن درخواست‌ها ایجاد کنید و چند goroutine به عنوان worker راه‌اندازی کنید تا هرکدام از این صف وظیفه برداشته و پردازش کنند. پس از اتمام کار، نتیجه را می‌توانند در یک کانال نتایج (result channel) قرار دهند تا main goroutine یا یک جمع‌کننده (collector) نتایج را جمع‌آوری کند. این معماری، بهترین شیوه برای مدیریت connection pool دیتابیس، پردازش موازی queueها، انجام وظایف تکراری (مثل scraping، پردازش تصاویر یا فایل‌ها) و افزایش مقیاس‌پذیری است.\nدر مجموع، Worker Pool با جلوگیری از ایجاد تعداد زیاد goroutine، افزایش کنترل بر مصرف منابع، افزایش throughput و جلوگیری از bottleneck شدن سیستم، یکی از حرفه‌ای‌ترین الگوهای تولیدی در Go محسوب می‌شود. استفاده هوشمندانه از کانال‌ها برای توزیع و جمع‌آوری وظایف و نتایج، کدنویسی را هم ساده‌تر و هم کاملاً idiomatic می‌کند.\n9.4.4.2 دیاگرام # flowchart LR subgraph Producer A1[Job Queuejob_0, job_1, ..., job_N] end subgraph WorkerPool direction TB W0[Worker 0job_0] W1[Worker 1job_1] WD[...] Wn[Worker Njob_N] end subgraph Collector B1[Result Queueres_0, res_1, ..., res_N] end A1 -- \"job_0\" --\u003e W0 A1 -- \"job_1\" --\u003e W1 A1 -- \"job_i ...\" --\u003e WD A1 -- \"job_N\" --\u003e Wn W0 -- \"res_0\" --\u003e B1 W1 -- \"res_1\" --\u003e B1 WD -- \"...\" --\u003e B1 Wn -- \"res_N\" --\u003e B1 MGR((Manager)) MGR --- WorkerPool classDef worker fill:#e3ffe3,stroke:#6bc76b,stroke-width:2px; classDef queue fill:#f2f6fa,stroke:#4c78a8,stroke-width:2px; classDef mgr fill:#ffe9c6,stroke:#a58954,stroke-width:2px; class W0,W1,WD,Wn worker; class A1,B1 queue; class MGR mgr; 9.4.4.3 نمونه کد # package main import ( \"fmt\" \"sync\" ) // ساختار نتیجه خروجی هر کارگر type JobResult struct { JobID int Input int Output int WorkerID int Err error } func main() { const ( numJobs = 5 numWorkers = 3 ) jobs := make(chan int, numJobs) results := make(chan JobResult, numJobs) var wg sync.WaitGroup // راه‌اندازی worker pool for w := 1; w \u003c= numWorkers; w++ { wg.Add(1) go worker(w, jobs, results, \u0026wg) } // ارسال jobها for j := 1; j \u003c= numJobs; j++ { jobs \u003c- j } close(jobs) // انتظار برای اتمام همه workerها و سپس بستن کانال نتایج go func() { wg.Wait() close(results) }() // جمع‌آوری و پردازش نتایج for result := range results { if result.Err != nil { fmt.Printf(\"[Job %d] خطا در Worker %d: %v\\n\", result.JobID, result.WorkerID, result.Err) continue } fmt.Printf(\"[Job %d] Worker %d → input: %d, output: %d\\n\", result.JobID, result.WorkerID, result.Input, result.Output) } } // Worker function func worker(id int, jobs \u003c-chan int, results chan\u003c- JobResult, wg *sync.WaitGroup) { defer wg.Done() for input := range jobs { // شبیه‌سازی کار و احتمال خطا var output int var err error if input == 3 { err = fmt.Errorf(\"مشکل در پردازش داده\") } else { output = input * 2 } result := JobResult{ JobID: input, Input: input, Output: output, WorkerID: id, Err: err, } results \u003c- result } } ▶ اجرای کد کپی ✖ بستن خروجی در این مثال از Worker Pool، سعی شده معماری‌ای تولید شود که هم خوانایی و توسعه‌پذیری بالایی داشته باشد و هم از نظر اطمینان و مدیریت منابع کاملاً production-ready باشد. در ابتدای برنامه، تعداد jobها و workerها به صورت ثابت تعیین شده و دو کانال برای مدیریت ارسال کارها (jobs) و جمع‌آوری نتایج (results) تعریف شده است. با استفاده از یک حلقه، به تعداد workerها goroutine اجرا می‌شود؛ هرکدام با استفاده از یک اشاره‌گر به sync.WaitGroup، اتمام کار خود را اعلام می‌کنند. این باعث می‌شود که بدانیم دقیقاً چه زمانی همه کارگرها کارشان را به اتمام رسانده‌اند.\nبرای هر job که وارد صف می‌شود، اطلاعات آن در کانال jobs قرار می‌گیرد و پس از ارسال تمام jobها، کانال بسته می‌شود تا workerها پس از اتمام کار بتوانند از حلقه خارج شوند. پس از اتمام همه goroutineها (به کمک WaitGroup)، یک goroutine کمکی کانال results را می‌بندد تا حلقه جمع‌آوری نتایج نیز بدون مشکل به پایان برسد. خروجی هر کار به صورت یک ساختار JobResult است که هم شناسه job، هم ورودی و خروجی، هم شماره worker و هم خطای احتمالی را شامل می‌شود. این ساختار هم امکان لاگ‌گیری دقیق، هم مدیریت خطا و هم تحلیل بعدی را به سادگی ممکن می‌کند.\nدر این مثال، برای یکی از jobها به صورت شبیه‌سازی‌شده یک خطا تولید می‌شود تا نشان داده شود چگونه مدیریت خطا باید به صورت ایمن و جداگانه برای هر job انجام گیرد. در حلقه دریافت نتایج، ابتدا خطا بررسی می‌شود و در صورت وجود خطا، پیام مناسب نمایش داده می‌شود؛ در غیر این صورت، ورودی، خروجی و شماره worker برای هر job به صورت فرمت‌بندی‌شده چاپ می‌گردد. این رویکرد علاوه بر رعایت idiomatic بودن کد Go، کنترل کاملی روی منابع و وضعیت اجرایی همه بخش‌ها ایجاد می‌کند و پایه‌ای ایده‌آل برای پروژه‌های واقعی و مقیاس‌پذیر محسوب می‌شود.\nدر نهایت، این معماری به راحتی قابل گسترش برای jobهای پیچیده‌تر، مدیریت صف‌های بزرگ‌تر یا حتی پیاده‌سازی با context و timeout است و از بروز مشکلات رایج مانند goroutine leak یا deadlock جلوگیری می‌کند.\n9.4.4.4 کاربردها # تقسیم کارهای پردازشی (Parallel Data Processing): با استفاده از الگوی Worker Pool می‌توانید حجم زیادی از داده‌ها یا کارهای محاسباتی سنگین را به بخش‌های کوچک‌تر تقسیم کنید و به طور موازی بین چندین goroutine کارگر توزیع نمایید. این رویکرد علاوه بر افزایش سرعت پردازش، باعث استفاده بهینه‌تر از منابع سیستم (CPU و حافظه) می‌شود و از ایجاد goroutineهای بیش از حد یا سربار اضافی جلوگیری می‌کند. در نتیجه، سربار مدیریت همزمانی کاهش یافته و عملکرد نهایی سیستم به طور قابل ملاحظه‌ای بهبود می‌یابد. مدیریت و محدودسازی منابع (Resource Management \u0026amp; Limiting): Worker Pool به شما امکان می‌دهد تعداد ثابتی goroutine برای انجام کارها داشته باشید و از مصرف بیش از حد منابع سیستم، مانند اتصال به دیتابیس یا پردازش همزمان بیش از حد، جلوگیری کنید. این کار برای کنترل بار روی سرویس‌های خارجی (مانند دیتابیس، API یا حتی سخت‌افزار) حیاتی است و جلوی شکست یا کندی سیستم را می‌گیرد. اجرای موازی درخواست‌های خارجی (Parallel External Requests): این الگو برای ارسال همزمان تعداد زیادی درخواست به سرویس‌های خارجی (مانند APIهای وب، ذخیره‌سازی ابری یا دانلود فایل‌ها) بسیار کاربردی است. Worker Pool با محدودسازی تعداد کارگرها، امکان ارسال کنترل‌شده و پایدار درخواست‌ها را فراهم می‌کند. پذیرش و پردازش صف کارها (Job Queue Processing): در معماری‌های صف محور (مانند پردازش پیام یا وظایف پس‌زمینه)، Worker Pool به شما اجازه می‌دهد کارها را از صف بخوانید و توسط کارگرها به شکل کنترل‌شده و موازی اجرا کنید. این الگو پایه بسیاری از سیستم‌های background task، notification و microservice است. پردازش تصاویر، فایل‌ها و داده‌های بزرگ: Worker Pool برای سیستم‌هایی که باید تعداد زیادی تصویر یا فایل را به طور موازی پردازش کنند (مثلاً تغییر سایز عکس، رمزنگاری فایل یا پردازش ویدئو)، ایده‌آل است و بازدهی را به طرز چشمگیری افزایش می‌دهد. مدیریت کانکشن‌های شبکه یا سرور: در سرورهایی که با تعداد زیادی اتصال همزمان مواجه هستند، Worker Pool می‌تواند برای مدیریت همزمان کانکشن‌ها یا درخواست‌های ورودی، و جلوگیری از overload شدن سیستم، استفاده شود. "},{"id":209,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-drop/","title":"9.4.5 الگو Drop","section":"9.4 الگوهای همزمانی","content":" 9.4.5.1 توضیحات # الگوی Drop یا Drop Overflow یکی از الگوهای حیاتی برای سیستم‌هایی است که ممکن است با موجی از درخواست‌ها روبرو شوند که بیش از ظرفیت واقعی سیستم است. در این الگو، زمانی که صف یا ظرفیت پردازش درخواست‌ها (مثلاً یک کانال یا بافر) پر می‌شود، به جای اینکه سیستم را دچار ازدحام، توقف یا crash کند، به سادگی درخواست‌های اضافی (یا جدیدتر یا قدیمی‌تر، بر اساس سیاست) را حذف (Drop) می‌کند. این کار باعث می‌شود سرویس همواره پایدار و قابل اطمینان باقی بماند و منابع اصلی به خاطر یک سناریوی غیرعادی یا حمله دچار مشکل نشود.\nکاربرد این الگو به‌خصوص در سرویس‌های زیرساختی حیاتی مانند DNS، load balancer، یا حتی سیستم‌های realtime که نمی‌خواهند به هیچ قیمتی دچار backlog و تاخیر بالا شوند، بسیار رایج است. به عنوان مثال، در یک سرور DNS وقتی تعداد درخواست‌ها از ظرفیت کانال یا worker pool بیشتر شود، درخواست‌های جدید بلافاصله drop می‌شوند تا latency پایین بماند و سرور همچنان responsive بماند. این الگو به عنوان بخشی از استراتژی کلی Backpressure نیز به کار می‌رود و برای معماری‌هایی که تحمل \u0026ldquo;از دست رفتن بعضی درخواست‌ها\u0026rdquo; بهتر از \u0026ldquo;کُند شدن یا قطع کامل سرویس\u0026rdquo; است، ایده‌آل محسوب می‌شود.\nدر پیاده‌سازی‌های Go معمولاً یک کانال بافر دار تعریف می‌شود و اگر هنگام ارسال داده به کانال، با پر بودن مواجه شویم (مثلاً با select غیر بلوک‌کننده)، درخواست به راحتی Drop می‌شود و کنترل به سرعت به کد اصلی بازمی‌گردد. این تکنیک ساده، موثر و بسیار idiomatic در پروژه‌های تولیدی Go است و به حفظ کیفیت خدمات و جلوگیری از overload شدن سیستم کمک شایانی می‌کند.\n9.4.5.2 دیاگرام # flowchart LR A[درخواست‌های ورودی] --\u003e|درخواست 1| Q((Channel Queue)) A --\u003e|درخواست 2| Q A --\u003e|درخواست 3| Q A --\u003e|درخواست ...| Q Q -- \"در صورت پر بودن\" --\u003e D[Drop Requestرد شدن درخواست] Q -- \"در صورت ظرفیت داشتن\" --\u003e W[Worker] W --\u003e R[نتیجه/پردازش] style Q fill:#ffe9c6,stroke:#efb64f,stroke-width:2px style D fill:#ffeaea,stroke:#ff5b5b,stroke-width:2px style W fill:#e3ffe3,stroke:#6bc76b,stroke-width:2px style R fill:#e0eaff,stroke:#476ebd,stroke-width:2px 9.4.5.3 نمونه کد # package main import ( \"fmt\" \"sync\" \"time\" ) func main() { const bufferSize = 3 const numData = 10 in := make(chan int, bufferSize) out := make(chan int, bufferSize) var wg sync.WaitGroup // تولیدکننده: تولید داده با Drop در صورت پر بودن کانال wg.Add(1) go func() { defer wg.Done() for i := 1; i \u003c= numData; i++ { select { case in \u003c- i: fmt.Printf(\"[Producer] Sent: %d\\n\", i) default: fmt.Printf(\"[Producer] Drop: %d (buffer full)\\n\", i) } time.Sleep(100 * time.Millisecond) } close(in) }() // مصرف‌کننده: مصرف داده با Drop اگر مصرف‌کننده بعدی نتواند داده را بپذیرد wg.Add(1) go func() { defer wg.Done() for data := range in { select { case out \u003c- data: fmt.Printf(\"[Consumer] Forwarded: %d\\n\", data) default: fmt.Printf(\"[Consumer] Drop: %d (output buffer full)\\n\", data) } time.Sleep(150 * time.Millisecond) } close(out) }() // جمع‌آوری خروجی for result := range out { fmt.Printf(\"[Result] Received: %d\\n\", result) } wg.Wait() } ▶ اجرای کد کپی ✖ بستن خروجی در این مثال از الگوی Drop Overflow، یک سناریوی واقعی‌تر برای مدیریت بار بیش از ظرفیت در سیستم‌های concurrent نمایش داده شده است. ابتدا دو کانال بافر‌دار (یکی برای ورودی و دیگری برای خروجی) تعریف شده‌اند تا شبیه‌ساز صف‌هایی با ظرفیت محدود باشند. یک goroutine به عنوان تولیدکننده، داده‌هایی با مقادیر مختلف (از ۱ تا ۱۰) تولید می‌کند و در تلاش است آن‌ها را وارد کانال ورودی کند. اگر ظرفیت کانال ورودی پر باشد، داده جدید بدون معطلی Drop شده و پیام مناسبی در لاگ چاپ می‌شود؛ این رفتار باعث می‌شود که goroutine تولیدکننده هیچگاه بلاک نشود و سیستم دچار اختلال یا توقف نگردد.\nدر طرف مصرف‌کننده، داده‌ها از کانال ورودی خوانده می‌شوند و تلاش می‌شود به کانال خروجی منتقل شوند. اگر خروجی هم در آن لحظه ظرفیت نداشته باشد (یعنی مصرف‌کننده بعدی نتواند داده را دریافت کند)، داده دوباره Drop شده و این اتفاق نیز در لاگ ثبت می‌شود. به این ترتیب، در هر نقطه‌ای از زنجیره پردازش که ظرفیت کافی وجود نداشته باشد، داده بدون انتظار و سربار اضافه حذف خواهد شد. این رفتار بسیار مهم است، چرا که از تجمع داده‌های غیرقابل پردازش جلوگیری می‌کند و جلوی اشغال بیش از حد حافظه یا منابع را می‌گیرد.\nدر انتهای برنامه، خروجی‌ها از کانال خروجی جمع‌آوری و چاپ می‌شوند تا وضعیت مصرف موفق داده‌ها قابل مشاهده باشد. با کمک sync.WaitGroup اطمینان حاصل شده که تمام goroutineها قبل از پایان برنامه به درستی خاتمه پیدا می‌کنند و هیچ goroutine سرگردان یا leak اتفاق نمی‌افتد. با افزودن تأخیرهای زمانی متفاوت در تولید و مصرف داده‌ها، سناریوهای متفاوتی از فشار و ترافیک شبیه‌سازی شده تا نقاط Drop مختلف به خوبی دیده شوند. این مثال نشان‌دهنده کاربرد عملی و idiomatic این الگو در Go است؛ جایی که Drop شدن بخشی از داده‌ها به جای کندی یا Crash سیستم، انتخابی هوشمندانه و تولیدی محسوب می‌شود، به ویژه در سیستم‌های real-time، سرویس‌های زیرساختی یا سناریوهایی با بار متغیر.\n9.4.5.4 کاربردها # محدودسازی نرخ پردازش (Rate Limiting): زمانی که با حجم بالایی از داده‌های ورودی یا درخواست‌ها سروکار دارید، این الگو به شما کمک می‌کند تا تنها تعداد مشخصی داده را در هر لحظه بپذیرید و باقی داده‌های مازاد را Drop کنید؛ به این ترتیب، نرخ پردازش سیستم ثابت و قابل کنترل باقی می‌ماند و از overload یا کندی سیستم جلوگیری می‌شود. ثبت لاگ و مانیتورینگ (Logging/Monitoring): در سیستم‌های لاگ‌گیری یا مانیتورینگ با حجم بالای رویداد، ممکن است توان نوشتن روی دیسک یا ارسال داده به سرور مرکزی محدود باشد. با پیاده‌سازی Drop Pattern می‌توانید پیام‌های اضافی یا کم‌اهمیت را به سادگی حذف کنید تا ضمن حفظ پایداری سرویس، داده‌های کلیدی با کمترین تأخیر ثبت شوند. مدیریت صف و کنترل ازدحام (Queue Management \u0026amp; Congestion Control): هنگام استفاده از صف‌هایی که توسط کانال‌های بافر‌دار مدیریت می‌شوند، به جای مسدود شدن تولیدکننده یا ایجاد backlog زیاد، می‌توانید در صورت پر شدن صف، داده‌های جدید را Drop کنید. این رفتار به ویژه در سناریوهای با بار متغیر، باعث افزایش پایداری سیستم و کاهش سربار مدیریت صف می‌شود. کنترل ترافیک شبکه و ورودی (Traffic Shaping \u0026amp; Throttling): در سرورها یا سرویس‌هایی که با حجم بالای ترافیک یا درخواست همزمان مواجه می‌شوند (مانند API Gateway یا Load Balancer)، Drop Pattern کمک می‌کند که بخشی از ترافیک ورودی در صورت نبود ظرفیت حذف شود و کیفیت خدمات به کاربران باقی‌مانده حفظ شود. این رویکرد، راهکاری مؤثر برای جلوگیری از حملات DoS یا اسپایک‌های ناگهانی است. سیستم‌های بلادرنگ و حساس به تأخیر (Real-time \u0026amp; Low Latency Systems): در سیستم‌های real-time مانند سیستم‌های پردازش صدا، تصویر، یا تحلیل لحظه‌ای داده‌های حسگرها، معمولاً داده‌ها باید در بازه زمانی مشخص پردازش شوند. در صورت پر بودن بافر یا عدم توان مصرف داده، داده‌های جدید Drop می‌شوند تا latency پایین و پاسخ‌دهی سریع سیستم حفظ شود. سرویس‌های زیرساختی حیاتی (مانند DNS و پیام‌رسان‌ها): در زیرساخت‌هایی مثل DNS، صف‌های کاری باید کوتاه و پاسخ‌دهی سریع باشد. اگر صف پر شود، درخواست‌های جدید به سرعت Drop می‌شوند تا سرویس‌دهی پایدار باقی بماند و سیستم دچار اشباع یا توقف نشود. "},{"id":210,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-cancellation/","title":"9.4.6 الگو Context Cancellation Pattern","section":"9.4 الگوهای همزمانی","content":" 9.4.6.1 توضیحات # الگوی Cancellation یا Context Cancellation Pattern یکی از تکنیک‌های کلیدی در Go برای کنترل lifecycle goroutineها و جلوگیری از اجرای ناخواسته یا بی‌پایان آن‌هاست. هدف اصلی این الگو، ارسال سیگنال توقف به goroutineهایی است که به هر دلیلی باید عملیات خود را زودتر از موعد قطع کنند؛ مثلاً کاربر درخواست کنسل می‌دهد، تایم‌اوت رخ می‌دهد یا رویداد خاصی در سیستم اتفاق می‌افتد.\nدر معماری idiomatic Go، برای پیاده‌سازی لغو عملیات، به‌جای بستن کانال‌های اختصاصی، از context.Context استفاده می‌شود که یک سازوکار استاندارد، ساده و thread-safe برای انتشار سیگنال لغو (cancelation) و همچنین مدیریت تایم‌اوت‌ها و مقادیر مرتبط است. معمولاً یک context اصلی با دستور context.WithCancel یا context.WithTimeout ساخته می‌شود و این context به تمامی goroutineها و تابع‌های فرزند پاس داده می‌شود. هر goroutine به طور دوره‌ای وضعیت context را بررسی می‌کند (با \u0026lt;-ctx.Done() یا ctx.Err()) و اگر سیگنال لغو صادر شده باشد، عملیات خود را متوقف می‌کند و منابع را آزاد می‌سازد.\nاستفاده از context علاوه بر خوانایی و سادگی، از مشکلات رایج مانند goroutine leak، deadlock یا بستن اشتباهی کانال‌ها جلوگیری می‌کند و مدیریت همزمانی را ایمن‌تر می‌سازد. در پروژه‌های تولیدی Go، این الگو به عنوان استاندارد طلایی لغو عملیات (چه برای لغو دستی، چه Timeout و چه Propagation سیگنال لغو در عمق کال‌استک) توصیه می‌شود.\n9.4.6.2 دیاگرام # sequenceDiagram participant Main as Main Goroutine participant Ctx as Context (WithCancel/WithTimeout) participant Worker1 as Worker Goroutine 1 participant Worker2 as Worker Goroutine 2 Main-\u003e\u003eCtx: ساخت context با WithCancel یا WithTimeout Main-\u003e\u003eWorker1: ارسال context Main-\u003e\u003eWorker2: ارسال context Note over Worker1, Worker2: انجام عملیات و بررسی\n\u003c-ctx.Done() Main-\u003e\u003eCtx: فراخوانی cancel (یا رخداد timeout) Ctx--\u003e\u003eWorker1: ارسال سیگنال لغو Ctx--\u003e\u003eWorker2: ارسال سیگنال لغو Worker1-\u003e\u003eMain: آزاد کردن منابع و پایان Worker2-\u003e\u003eMain: آزاد کردن منابع و پایان 9.4.6.3 نمونه کد # package main import ( \"context\" \"fmt\" \"time\" ) func main() { // ساخت context قابل لغو ctx, cancel := context.WithCancel(context.Background()) // اجرای goroutine با بررسی لغو go func(ctx context.Context) { for { select { case \u003c-ctx.Done(): fmt.Println(\"Cancelled:\", ctx.Err()) return default: fmt.Println(\"Running\") time.Sleep(time.Second) } } }(ctx) // اجرای goroutine برای ۳ ثانیه time.Sleep(3 * time.Second) // فراخوانی لغو cancel() // انتظار برای خاتمه goroutine time.Sleep(time.Second) } ▶ اجرای کد کپی ✖ بستن خروجی در کد فوق ما یک کانال از نوع ساختار ایجاد کردیم با عنوان cancel و این کانال را داخل یکی از case های select بصورت دریافت قرار دادیم که در ادامه ما یک Sleep ۳ گذاشتیم تا فرآیند انجام شود و Running چاپ شود. پس از آن کانال را close کردیم و سیگنال لغو فرآیند ارسال شد و گوروتین کاملا متوقف شد.\n9.4.6.4 کاربردها # لغو یک کار طولانی‌مدت: عملکردی که عملیات زمان‌بر مانند درخواست شبکه یا محاسبات را انجام می‌دهد، اگر دیگر به آن نیاز نباشد یا از مهلت زمانی فراتر رود، می‌توان آن را لغو کرد. پاکسازی منابع: تابعی که منابعی مانند فایل یا اتصال شبکه را تخصیص می دهد، می تواند لغو شود تا این منابع قبل از اینکه دیگر مورد نیاز نباشند آزاد شوند. خاتمه دادن به یک سرور: سروری که چندین درخواست را مدیریت می‌کند، می‌تواند با لغو تمام عملکردهای در حال اجرا که این درخواست‌ها را انجام می‌دهند، به‌خوبی خاموش شود. لغو یک کار پس زمینه: یک کار پس زمینه که همزمان با برنامه اصلی اجرا می شود را می توان لغو کرد تا از اجرای آن جلوگیری شود. "},{"id":211,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-semaphore/","title":"9.4.7 الگو Semaphore","section":"9.4 الگوهای همزمانی","content":" 9.4.7.1 توضیحات # الگوی Semaphore (سمیفور) یکی از مفاهیم کلیدی در دنیای همزمانی (Concurrency) است و نقش آن مدیریت کنترل دسترسی به منابع محدود (مانند فایل، شبکه، دیتابیس و…) در یک زمان است. این الگو مخصوصاً زمانی کاربرد دارد که چندین goroutine یا درخواست به طور همزمان قصد استفاده از یک منبع یا سرویس را دارند، اما تنها تعداد محدودی مجاز به استفاده همزمان از آن هستند. پیاده‌سازی این الگو در Go بسیار ساده و idiomatic است و معمولاً از کانال بافر دار (buffered channel) به عنوان سمیفور استفاده می‌شود.\nفرض کنید سرور شما قرار است همزمان به ۱۰۰ درخواست HTTP پاسخ دهد؛ اگر همه این درخواست‌ها به طور موازی و بدون کنترل وارد مرحله پردازش شوند، مصرف منابع شبکه (یا سایر منابع اشتراکی) افزایش یافته و به سرعت به نقطه بحرانی می‌رسد که عملکرد سیستم به شدت کاهش پیدا می‌کند و حتی ممکن است به خطا یا اختلال بیانجامد. با استفاده از الگوی سمیفور، می‌توانید تعداد goroutineهای فعال و مشغول به پردازش همزمان را به عددی مشخص (مثلاً ۲۰ یا ۵۰) محدود کنید. این کار موجب می‌شود که منابع با ثبات بیشتری مورد استفاده قرار گیرند و بار اضافی و سربار مدیریت سیستم کاهش یابد.\nدر پیاده‌سازی این الگو در Go، یک کانال بافر دار (مثلاً make(chan struct{}, 20)) به عنوان سمیفور تعریف می‌شود. هر goroutine قبل از شروع پردازش، یک مقدار (مثلاً struct{} یا هر مقدار دلخواه) در کانال قرار می‌دهد. اگر کانال پر باشد، goroutine جدید بلاک می‌شود تا زمانی که جای خالی ایجاد شود. پس از پایان کار، goroutine مقدار خود را از کانال خارج می‌کند تا اجازه فعالیت به goroutine دیگری داده شود. این تکنیک همزمانی ایمن و کنترل‌شده را فراهم می‌کند و به راحتی قابل توسعه و مقیاس‌پذیر است.\nسمیفور برای سناریوهای دیگری مانند مدیریت همزمان دسترسی به پایگاه داده، خواندن/نوشتن فایل‌ها، کنترل اجرای Taskهای سنگین و حتی مدیریت connection poolها نیز استفاده می‌شود و یکی از مهم‌ترین ابزارهای جلوگیری از overload شدن سیستم و حفظ پایداری نرم‌افزارهای concurrent است. استفاده از کانال بافر دار به عنوان سمیفور، یک راه حل idiomatic و ساده برای پیاده‌سازی این کنترل در زبان Go محسوب می‌شود و اغلب در کدهای تولیدی مشاهده می‌شود.\nبه نقل از ویکی پدیا :\nدر علم رایانه نشانبر یا سمافور (به انگلیسی: Semaphore) به متغیری گفته می‌شود که در محیط‌های همروند برای کنترل دسترسی فرایندها به منابع مشترک به کار می‌رود. سمافور می‌تواند به دو صورت دودویی (که تنها دو مقدار صحیح و غلط را دارا است) یا شمارنده اعداد صحیح باشد. از سمافور برای جلوگیری از ایجاد وضعیت رقابتی میان فرایندها استفاده می‌گردد. به این ترتیب، اطمینان حاصل می‌شود که در هر لحظه تنها یک فرایند به منبع مشترک دسترسی دارد و می‌تواند از آن بخواند یا بنویسد (انحصار متقابل)\nسمافورها اولین بار به‌وسیلهٔ دانشمند علوم رایانه هلندی، ادسخر دیکسترا معرفی شدند.[۱] و امروزه به‌طور گسترده‌ای در سیستم عاملها مورد استفاده قرار می‌گیرند.\n9.4.7.2 دیاگرام # 9.4.7.3 نمونه کد # package main import ( \"fmt\" \"sync\" \"time\" ) // Interface optional, usually direct struct is enough type Semaphore struct { semCh chan struct{} } func NewSemaphore(maxConcurrency int) *Semaphore { return \u0026Semaphore{ semCh: make(chan struct{}, maxConcurrency), } } func (s *Semaphore) Acquire() { s.semCh \u003c- struct{}{} } func (s *Semaphore) Release() { \u003c-s.semCh } func main() { maxConcurrent := 3 totProcess := 10 sem := NewSemaphore(maxConcurrent) var wg sync.WaitGroup for i := 1; i \u003c= totProcess; i++ { wg.Add(1) sem.Acquire() go func(taskID int) { defer wg.Done() defer sem.Release() longRunningProcess(taskID) }(i) } wg.Wait() fmt.Println(\"All tasks finished!\") } func longRunningProcess(taskID int) { fmt.Println(time.Now().Format(\"15:04:05\"), \"Running task\", taskID) time.Sleep(2 * time.Second) } ▶ اجرای کد کپی ✖ بستن خروجی در این نسخه بهبود یافته از الگوی Semaphore، هدف کنترل تعداد goroutineهای همزمان و اطمینان از اجرای کامل تمام وظایف (tasks) بدون هیچ‌گونه race condition یا مشکل همزمانی است. در ابتدا با ساخت یک struct ساده به نام Semaphore و تعریف یک کانال بافر دار به اندازه‌ی تعداد مجاز عملیات همزمان (در اینجا ۳)، یک Semaphore سبک اما مؤثر ساخته می‌شود. هر زمان که یک goroutine می‌خواهد اجرا شود، ابتدا باید یک اسلات در این کانال اشغال کند (Acquire). اگر ظرفیت کانال پر باشد، goroutine تا آزاد شدن یک اسلات جدید منتظر می‌ماند. پس از پایان کار، با دستور Release اسلات آزاد می‌شود تا goroutine بعدی بتواند اجرا شود.\nدر تابع main یک حلقه وظیفه راه‌اندازی ۱۰ goroutine را دارد، ولی با کمک Semaphore فقط ۳ کار همزمان می‌توانند در هر لحظه فعال باشند. برای اطمینان از اینکه تمام goroutineها به‌درستی اجرا و پایان یافته‌اند، از sync.WaitGroup استفاده شده است: قبل از راه‌اندازی هر goroutine مقدار WaitGroup افزایش و پس از اتمام آن کاهش می‌یابد. در انتها با دستور wg.Wait() مطمئن می‌شویم که برنامه فقط پس از اتمام همه کارها به پایان می‌رسد. این مکانیزم از خروج زودهنگام main یا رخ دادن goroutine leak جلوگیری می‌کند.\nهر goroutine یک تابع شبیه‌ساز کار سنگین (longRunningProcess) را با شناسه‌ی خود اجرا می‌کند که خروجی اجرای task و زمان شروع آن را در لاگ چاپ می‌کند و با یک توقف (sleep) دو ثانیه‌ای، بار واقعی‌تری ایجاد می‌نماید. این پیاده‌سازی تضمین می‌کند که همزمانی به‌شکلی کنترل‌شده انجام شود، تعداد goroutineها بیش از حد نشود و سرور یا سیستم هیچ‌گاه overloaded نشود. همین الگو در بسیاری از سناریوهای واقعی مثل دانلود فایل، فراخوانی APIهای موازی، پردازش صف داده و مدیریت connection pool استفاده می‌شود و پایه‌ی معماری بسیاری از سرویس‌های مقیاس‌پذیر است. همچنین این روش idiomatic Go است و برای توسعه در پروژه‌های تولیدی کاملاً توصیه می‌شود.\n9.4.7.4 کاربردها # مدیریت دسترسی به منابع مشترک (Shared Resource Management): سمیفور برای محدود کردن تعداد goroutineهایی که همزمان به یک منبع مشترک (مانند فایل، دیتابیس، یا یک سرویس خارجی) دسترسی دارند، استفاده می‌شود. این کنترل از بروز شرایط رقابتی (race conditions) و مصرف بیش از حد منابع جلوگیری می‌کند و پایداری سیستم را تضمین می‌کند. همگام‌سازی و کنترل دسترسی به ساختار داده‌های اشتراکی (Data Structure Synchronization): زمانی که چندین goroutine نیاز دارند به طور همزمان روی یک ساختار داده مانند map، queue یا cache کار کنند، می‌توان با سمیفور تعداد عملیات همزمان روی آن ساختار را محدود کرد تا همزمانی ایمن و مدیریت‌شده داشته باشیم. مدیریت منابع محدود (Limited Resource Allocation): بسیاری از منابع سیستم مانند connection pool دیتابیس، worker pool، پردازشگرهای شبکه یا حتی ظرفیت نوشتن روی دیسک دارای محدودیت فیزیکی یا منطقی هستند. سمیفور تضمین می‌کند که هرگز بیش از تعداد مشخصی از این منابع همزمان اشغال نشوند. پیاده‌سازی Load Balancer یا Rate Limiter: می‌توانید از سمیفور برای کنترل تعداد درخواست‌های همزمان که از طریق یک load balancer یا API gateway به سرویس اصلی ارسال می‌شوند استفاده کنید. این کار کمک می‌کند سرویس پشت‌صحنه هیچ‌وقت overload نشود و کیفیت پاسخ‌دهی به کاربران حفظ شود. همچنین می‌توان با همین الگو، الگوریتم‌های rate limiting پیاده‌سازی کرد. پیاده‌سازی Worker Pool یا Thread Pool: سمیفور هسته‌ی معماری Worker Pool است؛ یعنی تعداد taskهای فعال (یا thread/goroutine) در هر لحظه را محدود می‌کند و باعث می‌شود که هرگز بیش از ظرفیت واقعی سیستم، کار موازی اجرا نشود. این روش در سیستم‌های پردازش موازی، صف‌بندی background jobها، و بهبود performance به شدت کاربردی است. کنترل ترافیک ورودی یا API Throttling: با استفاده از سمیفور می‌توان تعداد پذیرش درخواست‌های همزمان ورودی (مثلاً به یک endpoint حیاتی یا سرویس خاص) را محدود کرد و در شرایط overload، درخواست‌های اضافی را reject یا queue کرد تا سیستم همیشه پاسخگو و پایدار بماند. "},{"id":212,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-retry-timeout/","title":"9.4.8 الگو Retry Timeout","section":"9.4 الگوهای همزمانی","content":" 9.4.8.1 توضیحات # الگوی Retry Timeout یکی از رایج‌ترین و مهم‌ترین الگوها در توسعه سرویس‌های پایدار (resilient) و سیستم‌های توزیع‌شده است. این الگو زمانی کاربرد دارد که عملیاتی مانند تماس با سرویس خارجی (مثلاً API، پایگاه داده، یا هر نوع ارتباط شبکه‌ای) ممکن است به صورت موقت شکست بخورد و لازم باشد با رعایت یک فاصله زمانی معین (timeout) چند بار به طور خودکار تلاش مجدد (retry) صورت بگیرد تا شانس موفقیت افزایش یابد و تجربه کاربری بهبود پیدا کند.\nدر Go، برای پیاده‌سازی این الگو معمولاً از یک حلقه ساده (for) به همراه تابع time.After یا متدهایی مانند time.Sleep استفاده می‌شود. در هر تلاش، ابتدا عملیات مورد نظر (مثلاً ارسال درخواست) اجرا می‌شود. اگر عملیات موفقیت‌آمیز نبود، برنامه برای مدتی مشخص (مثلاً یک ثانیه یا بیشتر) صبر می‌کند و دوباره تلاش می‌کند. این روند تا زمانی ادامه می‌یابد که یا تعداد تلاش‌ها از حد تعیین‌شده عبور کند، یا عملیات با موفقیت انجام شود، یا یک سیگنال کنسل (مانند context) دریافت شود. با استفاده از time.After، به صورت idiomatic و بدون مسدودسازی غیرضروری، می‌توان در هر تکرار مدت زمان انتظار بین تلاش‌ها را پیاده‌سازی کرد.\nمزیت الگوی Retry Timeout در Go این است که هم پیاده‌سازی آن ساده و خوانا است، هم قابلیت ترکیب با context برای پشتیبانی از لغو یا timeout کل عملیات وجود دارد و هم می‌توانید برای هر retry، لاگ، آمار، و حتی سیاست‌هایی مانند افزایش تدریجی تاخیر (exponential backoff) یا محدودیت کل زمان تلاش‌ها را به راحتی پیاده‌سازی کنید. این الگو یکی از ستون‌های اصلی resiliency در معماری میکروسرویس، ارتباطات شبکه‌ای و سامانه‌های distributed به شمار می‌رود و پیروی از آن، کیفیت و پایداری سرویس‌های شما را به طور چشمگیری افزایش می‌دهد.\n9.4.8.2 دیاگرام # flowchart TD Start([Start]) TryOp[Try Operation] Success{Success?} RetryMore{Retries Left?} Wait[Wait for timeout] DoneSuccess([Done: Success]) DoneFail([Done: Fail]) Start --\u003e TryOp TryOp --\u003e Success Success -- Yes --\u003e DoneSuccess Success -- No --\u003e RetryMore RetryMore -- Yes --\u003e Wait Wait --\u003e TryOp RetryMore -- No --\u003e DoneFail 9.4.8.3 نمونه کد # package main import ( \"context\" \"fmt\" \"io\" \"net/http\" \"time\" ) func main() { const ( url = \"http://example.com\" maxRetries = 3 retryTimeout = 2 * time.Second ) var resp *http.Response var err error // Timeout کلی روی کل تلاش‌ها (مثلاً 10 ثانیه) ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second) defer cancel() for i := 1; i \u003c= maxRetries; i++ { req, _ := http.NewRequestWithContext(ctx, http.MethodGet, url, nil) resp, err = http.DefaultClient.Do(req) if err == nil { fmt.Printf(\"Success on attempt %d\\n\", i) break } fmt.Printf(\"Attempt %d failed: %v\\n\", i, err) if i \u003c maxRetries { select { case \u003c-ctx.Done(): fmt.Println(\"Global timeout reached, aborting retries.\") break case \u003c-time.After(retryTimeout): fmt.Println(\"Retrying...\") } } } if err != nil { fmt.Println(\"Final Error:\", err) return } defer resp.Body.Close() // خواندن بخشی از بدنه برای اطمینان از آزاد شدن connection body, _ := io.ReadAll(io.LimitReader(resp.Body, 200)) fmt.Println(\"Status:\", resp.Status) fmt.Printf(\"Body sample: %q\\n\", body) } ▶ اجرای کد کپی ✖ بستن خروجی در این مثال از الگوی Retry Timeout، ما یک عملیات HTTP GET به آدرس مورد نظر را با رویکردی حرفه‌ای و ایمن، همراه با تلاش مجدد (Retry) و کنترل Timeout پیاده‌سازی می‌کنیم. ابتدا تعداد تلاش مجدد (maxRetries)، مدت تأخیر بین هر تلاش (retryTimeout) و یک Timeout کلی برای کل عملیات (۱۰ ثانیه) تعریف شده است تا سیستم هم از نظر مدیریت زمان و هم از نظر مصرف منابع، رفتار پیش‌بینی‌پذیری داشته باشد.\nدر ابتدای حلقه، یک context با Timeout کلی ساخته می‌شود. برای هر تلاش (تا سقف مجاز)، یک درخواست HTTP با همین context ساخته می‌شود تا در صورت لغو کلی یا پایان مهلت، همه retryها به صورت امن و هماهنگ متوقف شوند. اگر درخواست موفقیت‌آمیز باشد، شماره تلاش موفق ثبت می‌شود و حلقه خاتمه پیدا می‌کند. اگر شکست بخورد، پیام مربوط به شماره تلاش و علت خطا چاپ می‌شود. پیش از هر retry (به جز آخرین تلاش)، یک وقفه زمانی برقرار می‌شود. این وقفه با select روی ctx.Done() نیز کنترل می‌شود تا اگر قبل از شروع تلاش بعدی، context لغو شده بود، عملیات فوراً متوقف گردد و پیام مناسبی نمایش داده شود.\nپس از پایان حلقه، اگر همچنان خطا وجود داشته باشد، پیام خطا چاپ و برنامه خاتمه پیدا می‌کند. اگر درخواست موفقیت‌آمیز بوده، بدنه‌ی پاسخ حتماً بسته می‌شود تا از leak شدن منابع جلوگیری شود و connection قابل استفاده مجدد بماند. همچنین برای نمونه، بخشی از پاسخ خوانده و در خروجی چاپ می‌شود تا مطمئن شویم اتصال به سرور کامل برقرار شده است.\nاین معماری باعث می‌شود هم مدیریت خطا و retry کاملاً تحت کنترل باشد، هم منابع شبکه‌ای آزاد باقی بمانند و هم بتوان به سادگی رفتارهای حرفه‌ای‌تر مانند backoff تصاعدی، Circuit Breaker، یا لاگ پیشرفته‌تر را به آن اضافه کرد. چنین رویکردی در سامانه‌های توزیع‌شده و میکروسرویس‌ها استاندارد طلایی محسوب می‌شود و در پروژه‌های production-ready بسیار توصیه می‌شود.\n9.4.8.4 کاربردها # مقابله با خطاهای موقت شبکه و سرور: الگوی Retry Timeout اغلب زمانی به کار می‌رود که عملیات‌هایی مانند تماس با سرورهای HTTP، APIهای خارجی، پایگاه داده یا سایر سرویس‌های وابسته ممکن است به دلیل مشکلات موقتی (مانند قطعی لحظه‌ای شبکه، بار زیاد سرور، یا مشکلات DNS) شکست بخورند. با تکرار خودکار عملیات با فاصله زمانی کنترل‌شده، برنامه می‌تواند از گذرا بودن خطاها عبور کند و احتمال موفقیت را بدون دخالت کاربر بالا ببرد. پایداری و تاب‌آوری (Resilience) سرویس‌ها: در معماری‌های میکروسرویس، توزیع‌شده و ابری، Retry Timeout یک ابزار کلیدی برای افزایش resiliency سامانه است. این الگو کمک می‌کند سامانه به طور خودکار در برابر اختلالات کوتاه‌مدت واکنش نشان دهد و از fail شدن کل عملیات به خاطر یک خطای زودگذر جلوگیری کند. کاهش بار بر کاربر و تجربه کاربری بهتر: با استفاده از Retry Timeout، نیاز به تلاش مجدد دستی توسط کاربر حذف می‌شود و کاربران بدون آگاهی از خطاهای موقت، تجربه‌ای پیوسته و روان خواهند داشت. به‌ویژه در اپلیکیشن‌های موبایل یا تحت وب که اتصال شبکه متغیر است، این موضوع اهمیت بیشتری پیدا می‌کند. پیاده‌سازی Backoff و Circuit Breaker: این الگو پایه‌ای برای پیاده‌سازی استراتژی‌های پیچیده‌تری مانند exponential backoff (افزایش تدریجی فاصله بین تلاش‌ها) و circuit breaker (جلوگیری از retry پیوسته هنگام شکست‌های دائم) نیز هست که بهبود پایداری و هوشمندی retry را به ارمغان می‌آورد. اطمینان از اتمام موفق عملیات بحرانی: در کارهایی مانند ارسال تراکنش‌های بانکی، نوشتن در دیتابیس، یا ارسال پیام‌های حیاتی، Retry Timeout شانس اطمینان از موفقیت عملیات را افزایش می‌دهد و احتمال از دست رفتن داده‌ها را تا حد زیادی کاهش می‌دهد. "},{"id":213,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-producer-consumer/","title":"9.4.9 الگو Producer-Consumer","section":"9.4 الگوهای همزمانی","content":" 9.4.9.1 توضیحات # الگوی Producer-Consumer یکی از الگوهای بنیادی و بسیار پرکاربرد در برنامه‌نویسی همزمان (concurrent) با زبان Go است که امکان تولید و مصرف داده به صورت همزمان و ایمن را فراهم می‌کند. در این الگو، معمولاً یک یا چند goroutine به عنوان تولیدکننده (Producer) وظیفه تولید داده، رویداد یا پیام را بر عهده دارند و داده‌های تولیدی را از طریق یک کانال (channel) به goroutineهای دیگر که نقش مصرف‌کننده (Consumer) را دارند، ارسال می‌کنند. مصرف‌کننده‌ها نیز به صورت موازی داده‌های دریافتی را از کانال خوانده و پردازش می‌کنند. این جداسازی نقش تولید و مصرف، باعث می‌شود بخش‌های مختلف برنامه به صورت مستقل و همزمان عمل کرده و در عین حال از race condition و مشکلات همزمانی جلوگیری شود.\nکانال‌ها در Go نقش پل ارتباطی ایمن و همزمان بین goroutineها را بازی می‌کنند. معمولاً برای این الگو از یک کانال یک‌طرفه (unidirectional) بافر‌دار یا بدون بافر استفاده می‌شود تا داده‌ها به شکل صف (queue) از تولیدکننده به مصرف‌کننده منتقل شوند. هر چند، در معماری‌های پیچیده‌تر گاهی ممکن است از دو کانال (یکی برای داده و دیگری برای ارسال acknowledgment یا سیگنال برگشتی) بهره گرفته شود، اما در اکثر سناریوهای استاندارد کانال یک‌طرفه کفایت می‌کند. کانال‌های Go به‌طور خودکار هماهنگی بین goroutineها را برقرار می‌کنند؛ یعنی اگر کانال پر باشد، تولیدکننده منتظر می‌ماند تا مصرف‌کننده داده را مصرف کند، و اگر کانال خالی باشد، مصرف‌کننده منتظر می‌ماند تا داده جدید برسد.\nاین الگو برای حل بسیاری از مسائل دنیای واقعی ایده‌آل است؛ از صف بندی و پردازش موازی jobها گرفته تا انتقال داده بین بخش‌های مختلف یک سامانه، جمع‌آوری لاگ، پردازش همزمان پیام‌ها و حتی مدیریت صف درخواست‌های ورودی به سرویس‌ها. با استفاده از الگوی Producer-Consumer، نه تنها بهره‌وری و سرعت برنامه افزایش می‌یابد، بلکه کنترل جریان داده، پایداری و مقیاس‌پذیری سیستم نیز به طرز چشمگیری بهبود پیدا می‌کند. پیاده‌سازی صحیح این الگو در Go باعث می‌شود برنامه‌نویس بدون نگرانی از مشکلات همزمانی، بخش‌های مختلف سیستم را به صورت مستقل توسعه داده و بهینه کند.\n9.4.9.2 دیاگرام # flowchart TD subgraph Producers direction TB P1[\"Producer 1\"] P2[\"Producer 2\"] Pn[\"...\"] end subgraph Channel Chan[\"Channel (Buffer/Queue)\"] end subgraph Consumers direction TB C1[\"Consumer 1\"] C2[\"Consumer 2\"] Cn[\"...\"] end P1 -- \"Send Data\" --\u003e Chan P2 -- \"Send Data\" --\u003e Chan Pn -- \"Send Data\" --\u003e Chan Chan -- \"Receive Data\" --\u003e C1 Chan -- \"Receive Data\" --\u003e C2 Chan -- \"Receive Data\" --\u003e Cn 9.4.9.3 نمونه کد # package main import ( \"fmt\" \"math/rand\" \"sync\" \"time\" ) func producer(ch chan\u003c- int, count int, wg *sync.WaitGroup) { defer wg.Done() for i := 0; i \u003c count; i++ { n := rand.Intn(100) ch \u003c- n fmt.Println(\"Produced:\", n) time.Sleep(100 * time.Millisecond) } close(ch) // سیگنال پایان تولید به مصرف‌کننده‌ها } func consumer(id int, ch \u003c-chan int, wg *sync.WaitGroup) { defer wg.Done() for n := range ch { fmt.Printf(\"Consumer %d: Consumed %d\\n\", id, n) time.Sleep(200 * time.Millisecond) } fmt.Printf(\"Consumer %d: Finished\\n\", id) } func main() { rand.Seed(time.Now().UnixNano()) ch := make(chan int, 10) // کانال بافر دار var wg sync.WaitGroup produceCount := 20 wg.Add(1) go producer(ch, produceCount, \u0026wg) consumerCount := 2 for i := 1; i \u003c= consumerCount; i++ { wg.Add(1) go consumer(i, ch, \u0026wg) } wg.Wait() fmt.Println(\"All done.\") } ▶ اجرای کد کپی ✖ بستن خروجی در نسخه بهبود یافته‌ی مثال Producer-Consumer، تلاش شده تمام چالش‌های همزمانی و ضعف‌های مدیریت goroutineها به صورت حرفه‌ای و idiomatic در زبان Go برطرف شود. در این ساختار، یک goroutine به عنوان تولیدکننده (Producer) تعریف شده که به تعداد مشخص (مثلاً ۲۰ عدد) داده تصادفی تولید و وارد یک کانال بافر‌دار (مثلاً با ظرفیت ۱۰) می‌کند. استفاده از کانال بافر دار باعث می‌شود تولید و مصرف داده‌ها تا حدی decoupled باشند، یعنی اگر مصرف‌کننده‌ها لحظه‌ای کند شوند، تولیدکننده تا پر شدن بافر بدون توقف می‌تواند تولید کند.\nپس از تولید همه داده‌ها، producer کانال را می‌بندد. این کار بسیار مهم است؛ چون با بسته شدن کانال، حلقه‌ی for در goroutineهای مصرف‌کننده به صورت تمیز و بدون خطا تمام می‌شود و پیام \u0026ldquo;Finished\u0026rdquo; برای هر مصرف‌کننده چاپ می‌گردد. مصرف‌کننده‌ها به صورت worker pool پیاده‌سازی شده‌اند؛ یعنی هر داده‌ای که از کانال خارج شود به طور تصادفی توسط یکی از مصرف‌کننده‌ها پردازش می‌شود (division of labor) و هرکدام بعد از اتمام کارشان (یعنی زمانی که کانال بسته و همه داده‌ها مصرف شده باشد) خارج می‌شوند.\nبرای جلوگیری از goroutine leak و تضمین پایان تمیز همه goroutineها، از sync.WaitGroup استفاده شده است. با اضافه کردن یک مقدار به WaitGroup قبل از هر goroutine و کم کردن آن هنگام اتمام goroutine (defer wg.Done())، می‌توان مطمئن بود که برنامه فقط زمانی پایان می‌یابد که همه تولید و مصرف‌ها به طور کامل انجام شده‌اند.\nاین معماری، همزمانی ایمن، کنترل شده و مقیاس‌پذیر بین بخش تولید و مصرف داده را فراهم می‌کند. در چنین سیستمی، می‌توانید تعداد تولیدکننده یا مصرف‌کننده را به راحتی افزایش دهید یا منطق هر بخش را تغییر دهید (مثلاً پردازش‌های سنگین‌تر، ارسال درخواست‌های شبکه و\u0026hellip;) بدون اینکه نیاز به تغییر بنیادی در ساختار ارتباط بین آن‌ها باشد. استفاده صحیح از کانال‌ها، WaitGroup و مدیریت پایان graceful باعث می‌شود این الگو به راحتی در پروژه‌های تولیدی، سرویس‌های بلادرنگ، صف‌های پیام و هر نوع معماری concurrent مدرن قابل استفاده باشد.\n9.4.9.4 کاربردها # خط لوله پردازش داده (Data Processing Pipeline): با استفاده از این الگو می‌توانید معماری خط لوله یا pipeline ایجاد کنید که هر مرحله از پردازش به‌عنوان یک producer یا consumer عمل می‌کند. به عنوان مثال، ابتدا داده خام توسط یک goroutine تولید و از طریق کانال به مرحله بعد (مثل پاک‌سازی، تحلیل، تبدیل یا ذخیره‌سازی) ارسال می‌شود و هر مرحله می‌تواند نقش producer برای مرحله بعد و consumer برای مرحله قبل را داشته باشد. این مدل توسعه، تست و مقیاس‌پذیری سیستم‌های داده‌محور را بسیار ساده و حرفه‌ای می‌کند. سیستم‌های Logging و Monitoring: در معماری‌های واقعی، ثبت لاگ یا مانیتورینگ سیستم نیازمند جدا بودن تولید و ذخیره‌سازی لاگ است تا بخش اصلی سیستم کند نشود. با این الگو، برنامه اصلی (یا بخش‌های مختلف آن) به‌عنوان producer لاگ‌ها را روی کانال می‌فرستد و یک یا چند consumer این داده‌ها را از کانال می‌خوانند و آن‌ها را در فایل، پایگاه داده یا سرور مانیتورینگ ثبت می‌کنند. این کار از blocking شدن منطق اصلی و تجمع بی‌مورد داده جلوگیری می‌کند و ثبت لاگ را مقیاس‌پذیر و غیرمسدودکننده می‌کند. استریم داده و Real-time Processing: در سناریوهایی مانند پردازش رویدادهای لحظه‌ای (event streaming)، انتقال داده‌های IoT یا سیستم‌های تحلیل آنلاین (online analytics)، این الگو به شما امکان می‌دهد داده‌های تولیدشده را در لحظه به مصرف‌کنندگان منتقل کنید. این مصرف‌کنندگان می‌توانند انواع عملیات مانند فیلتر، آمار، آلارم، ذخیره‌سازی لحظه‌ای یا پردازش پیشرفته روی داده انجام دهند. Producer-Consumer ستون فقرات معماری بسیاری از سرویس‌های real-time و message queue است. واسطه‌گری بین سیستم‌ها (Integration \u0026amp; Decoupling): این الگو به شما اجازه می‌دهد بخش‌های مختلف یک سیستم یا حتی سرویس‌های جدا را از طریق کانال‌های ارتباطی به هم متصل کنید بدون آنکه وابستگی مستقیم یا coupling بالا داشته باشند. هر producer می‌تواند در یک microservice یا process مجزا باشد و داده را به صف ارسال کند و هر consumer در سوی دیگر مسئول مصرف و پردازش باشد. "},{"id":214,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-monitor/","title":"9.4.10 الگو Monitor","section":"9.4 الگوهای همزمانی","content":" 9.4.10.1 توضیحات # الگوی مانیتور (Monitor Pattern) یکی از مفاهیم کلیدی در طراحی سیستم‌های همزمان است که هدف آن فراهم کردن مکانیزمی برای مدیریت ایمن و هماهنگ دسترسی چندین goroutine به یک منبع یا وضعیت مشترک است. این الگو به گونه‌ای طراحی شده که goroutineها بتوانند زمانی که منتظر وقوع یک شرط خاص (مثلاً آماده شدن داده یا تغییر وضعیت یک منبع) هستند، بدون مصرف بیهوده منابع (مانند CPU) یا بلاک شدن کل برنامه، به حالت خواب بروند و به محض برقرار شدن شرط، از خواب بیدار شوند و ادامه اجرا دهند. این رفتار دقیقاً چیزی است که در زبان Go می‌توان با کمک ساختار sync.Cond پیاده‌سازی کرد.\nساختار sync.Cond در پکیج sync زبان Go، ابزاری قدرتمند برای پیاده‌سازی این الگو است. یک شیء Cond روی یک lock (مانند sync.Mutex یا sync.RWMutex) ساخته می‌شود و سه متد کلیدی دارد:\nWait() که goroutine جاری را به حالت خواب می‌برد تا زمانی که از طریق سیگنال بیدار شود؛ Signal() که یکی از goroutineهای منتظر را بیدار می‌کند؛ Broadcast() که همه‌ی goroutineهای منتظر را بیدار می‌کند. هنگامی که goroutine شرط مورد نظرش برقرار نشده، متد Wait را صدا می‌زند و lock را به طور موقت آزاد می‌کند تا دیگران هم بتوانند منبع مشترک را تغییر دهند. پس از دریافت سیگنال و بیدار شدن، دوباره lock را به دست می‌گیرد و شرط را بررسی می‌کند. این روش بسیار ایمن، سریع و idiomatic است و از busy waiting (حلقه‌ی بی‌پایان با مصرف CPU) جلوگیری می‌کند.\nالگوی مانیتور با استفاده از sync.Cond معمولاً در سناریوهایی مانند صف‌های تولید-مصرف (زمانی که صف خالی است، مصرف‌کننده منتظر تولید داده می‌ماند)، پیاده‌سازی سیستم‌های صف انتظار (Waiting Queue)، کنترل منابع اشتراکی، یا هرجایی که نیاز به هماهنگی و همزمانی پیشرفته بین goroutineها وجود دارد، استفاده می‌شود. این الگو باعث افزایش پایداری و کارایی سیستم‌های concurrent می‌شود و پیاده‌سازی آن در Go هم ساده و هم بسیار قدرتمند است.\nبه نقل از ویکی پدیا :\nدر برنامه‌نویسی همروند (یا همان برنامه‌نویسی موازی)، مانیتور یک ساختار همگام سازی است که به ریسمان ها این امکان را می‌دهد که هم، انحصار متقابل داشته باشند و هم، بتوانند برای یک وضعیت خاص منتظر بمانند (مسدود شوند) تا وضعیت غلط شود. مانیتورها همچنین دارای یک مکانیسم هستند که به ریسمان‌های دیگر، از طریق سیگنال می‌فهمانند که شرایط آنها برآورده شده‌است. یک مانیتور، حاوی یک شئ میوتکس (قفل) و متغیرهای وضعیت است. یک متغیر وضعیت اساساً، ظرفی از ریسمان ها است که منتظر یک وضعیت خاص هستند. مانیتورها برای ریسمان‌ها مکانیسمی را فراهم می‌کنند، تا به‌طور موقت، و با هدف منتظر ماندن برای برآورده شدن شرایط خاص، دسترسی انحصاری را رها کنند، و سپس دسترسی انحصاری را مجدداً به دست آورند و کار خود را از سر گیرند.\n9.4.10.2 دیاگرام # flowchart TD A[Goroutine] --\u003e|Check Condition| B{Condition met?} B -- Yes --\u003e C[Process / Continue] B -- No --\u003e D[Wait sync.Cond] D -. Receive Signal .-\u003e E[Wake Up Goroutine] E --\u003e|Acquire lock| B F[Other Goroutines] --\u003e|Signal/Broadcast| D 9.4.10.3 نمونه کد # package main import ( \"fmt\" \"sync\" ) type Item = int type Queue struct { items []Item closed bool *sync.Cond } // ایجاد صف جدید func NewQueue() *Queue { return \u0026Queue{ Cond: sync.NewCond(\u0026sync.Mutex{}), } } // قرار دادن یک آیتم در صف func (q *Queue) Put(item Item) error { q.L.Lock() defer q.L.Unlock() if q.closed { return fmt.Errorf(\"queue is closed\") } q.items = append(q.items, item) q.Signal() // فقط یکی از منتظرها را بیدار کن (بهینه‌تر) return nil } // گرفتن n آیتم از صف، یا برگشت آیتم‌های موجود در صورت بسته بودن صف func (q *Queue) GetMany(n int) ([]Item, error) { q.L.Lock() defer q.L.Unlock() for len(q.items) \u003c n \u0026\u0026 !q.closed { q.Wait() } if len(q.items) == 0 \u0026\u0026 q.closed { return nil, fmt.Errorf(\"queue closed and empty\") } // اگر صف بسته شده و آیتم‌هایی باقی مانده است، همان‌ها را بازگردان m := n if len(q.items) \u003c n { m = len(q.items) } items := q.items[:m:m] q.items = q.items[m:] return items, nil } // بستن صف و بیدار کردن همه goroutineهای منتظر func (q *Queue) Close() { q.L.Lock() defer q.L.Unlock() q.closed = true q.Broadcast() // همه منتظرها را بیدار کن } func main() { q := NewQueue() var wg sync.WaitGroup // مصرف‌کننده‌ها for n := 10; n \u003e 0; n-- { wg.Add(1) go func(n int) { defer wg.Done() for { items, err := q.GetMany(n) if err != nil { break } fmt.Printf(\"%2d: %v\\n\", n, items) } }(n) } // تولید داده for i := 0; i \u003c 100; i++ { _ = q.Put(i) } q.Close() // صف را پس از تولید داده می‌بندیم wg.Wait() fmt.Println(\"All done!\") } ▶ اجرای کد کپی ✖ بستن خروجی در این مثال، یک صف thread-safe (ایمن برای همزمانی) با استفاده از الگوی مانیتور (Monitor Pattern) و ابزار قدرتمند sync.Cond پیاده‌سازی شده است. این صف، امکان قرار دادن آیتم (توسط تولیدکننده‌ها) و دریافت چند آیتم به صورت همزمان (توسط مصرف‌کننده‌ها) را به‌صورت هماهنگ و ایمن فراهم می‌کند.\nدر این معماری، متد Put برای افزودن آیتم جدید به صف استفاده می‌شود و با هر بار افزودن، یکی از goroutineهای منتظر (مصرف‌کننده‌ها) را با متد Signal() بیدار می‌کند تا در صورت آماده بودن شرط (یعنی تعداد آیتم کافی)، کار خود را ادامه دهد. در سمت مصرف‌کننده، هر goroutine با متد GetMany(n) منتظر می‌ماند تا حداقل n آیتم در صف موجود شود. اگر این شرط برقرار نباشد و صف همچنان باز باشد، مصرف‌کننده با متد Wait() به حالت خواب می‌رود تا زمانی که داده کافی توسط تولیدکننده وارد صف شود یا صف بسته شود.\nنکته کلیدی اینجاست که بعد از اتمام تولید داده (در این مثال پس از افزودن ۱۰۰ آیتم)، با فراخوانی متد Close() صف بسته می‌شود و همه goroutineهای منتظر با Broadcast() بیدار می‌شوند. این کار تضمین می‌کند هیچ مصرف‌کننده‌ای به صورت بی‌نهایت در حالت انتظار نخواهد ماند و همگی graceful و تمیز به کار خود پایان می‌دهند. اگر صف بسته و خالی باشد، مصرف‌کننده‌ها پیام خطا دریافت و خارج می‌شوند.\nدر نهایت با استفاده از یک sync.WaitGroup اطمینان حاصل می‌شود که تمام goroutineها (مصرف‌کننده‌ها) پس از اتمام واقعی پردازش و بدون هیچ‌گونه goroutine leak یا بن‌بست (deadlock) خاتمه می‌یابند. این معماری، هم مقیاس‌پذیر، هم ایمن، و هم idiomatic در دنیای Go است و می‌تواند در سناریوهای تولید-مصرف، صف‌های پردازش موازی، و حتی سیستم‌های real-time به‌سادگی استفاده شود.\n9.4.10.4 کاربردها # پردازش دسته‌ای داده (Batch Processing): زمانی که نیاز دارید تعداد مشخصی داده (مثلاً ۱۰ آیتم) جمع‌آوری و سپس به صورت یکجا پردازش شوند، می‌توانید با استفاده از sync.Cond منتظر بمانید تا شرط \u0026ldquo;تعداد کافی آیتم در صف\u0026rdquo; برقرار شود. سپس با سیگنال به مصرف‌کننده‌ها اطلاع می‌دهید که اکنون دسته داده آماده پردازش است و می‌توانند ادامه دهند. انتظار برای وقوع رویدادهای خارجی: اگر لازم است goroutineها تا وقوع یک رویداد خاص (مثل تکمیل عملیات در سرویس خارجی، رسیدن پیام از سرور، پایان کار background یا حتی فشار یک دکمه توسط کاربر) متوقف بمانند، با Cond می‌توانید آن‌ها را به خواب بفرستید تا زمانی که سیگنال یا Broadcast داده شود و همه با هم یا یکی یکی بیدار شوند. کنترل جریان و هماهنگی اجرای goroutineها (Flow Control \u0026amp; Synchronization): در مواقعی که لازم است فقط تعداد مشخصی از goroutineها همزمان وارد بخش بحرانی شوند یا اجرای بخشی از کد فقط پس از رخداد شرایط خاص آغاز شود، می‌توانید با کمک sync.Cond و شرط‌های سفارشی، کنترل کامل اجرای concurrent را داشته باشید (مثلاً: شروع تمام همزمان، یا توقف گروهی هنگام رسیدن به نقطه sink). همگام‌سازی و کنترل قفل‌های منابع مشترک: اگر دسترسی به یک منبع (مثلاً یک بافر یا شیء مشترک) باید با شرایط خاصی صورت گیرد (مثلاً تا زمانی که منبع خالی/پر نشده، اجازه دسترسی داده نشود)، می‌توانید با Cond گوروتین‌های منتظر را تا زمان آزاد شدن قفل یا فراهم شدن شرط، به خواب ببرید و سپس با Signal/Broadcast آنها را بیدار کنید. همگام‌سازی پایان و شروع عملیات چندگانه (Barrier Synchronization): زمانی که چندین goroutine باید همگی یک مرحله کار را به اتمام برسانند تا مرحله بعدی آغاز شود (مانند الگوی barrier)، می‌توان با Cond به هر goroutine پس از اتمام کار سیگنال داد و منتظر ماند تا همه به نقطه هماهنگ برسند، سپس اجرای مرحله بعدی را شروع کرد. انتظار پویا برای داده یا منبع: در صف‌های message queue، اگر مصرف‌کننده‌ها به داده نیاز دارند اما صف خالی است، به جای busy waiting، می‌توانند تا زمان ورود داده با Wait منتظر بمانند و تولیدکننده با Signal مصرف‌کننده‌ها را بیدار کند. این کار کارایی و مصرف منابع را بهبود می‌دهد. "},{"id":215,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-future/","title":"9.4.11 الگو Future","section":"9.4 الگوهای همزمانی","content":" 9.4.11.1 توضیحات # الگوی Future (یا Promise) یکی از الگوهای مهم و کاربردی در طراحی سیستم‌های ناهمزمان (asynchronous) است که در زبان Go نیز، اگرچه به صورت مستقیم در کتابخانه استاندارد وجود ندارد، اما می‌توان با استفاده از ابزارهای زبان مانند goroutine و channel، به‌سادگی آن را پیاده‌سازی کرد. هدف این الگو این است که یک \u0026ldquo;آبجکت\u0026rdquo; یا واسط به برنامه‌نویس داده شود که نماینده نتیجه یک عملیات (مانند درخواست شبکه یا محاسبه سنگین) است—حتی اگر آن عملیات هنوز به پایان نرسیده باشد.\nدر عمل، وقتی عملیاتی به صورت asynchronous آغاز می‌شود، به جای اینکه فوراً منتظر نتیجه بمانیم (و اجرای برنامه را بلاک کنیم)، یک مقدار از نوع Future دریافت می‌کنیم. این Future به عنوان placeholder یا وعده‌ای برای تحویل نتیجه نهایی به کار می‌رود. در پس‌زمینه، عملیات اصلی (مثلاً دریافت داده از API یا خواندن از دیسک) با یک goroutine انجام می‌شود و زمانی که به پایان رسید، نتیجه در Future ذخیره و آماده دسترسی می‌شود. هر زمان که برنامه به نتیجه نیاز داشته باشد، می‌تواند روی Future فراخوانی انجام دهد (مثلاً با خواندن از یک channel یا متد Get/Result)؛ اگر نتیجه هنوز آماده نشده باشد، برنامه به طور بلاک تا تکمیل عملیات منتظر می‌ماند و بلافاصله پس از آماده‌شدن داده، ادامه اجرا انجام می‌شود.\nمزیت کلیدی الگوی Future در Go، جداسازی منطق اجرای عملیات ناهمزمان از منطق مصرف‌کننده آن است. این کار خوانایی و مدیریت خطا را ساده‌تر، مدیریت منابع را بهینه‌تر و کد را مقیاس‌پذیرتر می‌کند. با استفاده از این الگو می‌توان معماری‌های مدرن با پردازش موازی و کارآمد ساخت، بدون آنکه درگیر callback hell یا کد پیچیده شوید. همچنین Future پایه بسیاری از فریمورک‌ها و ابزارهای concurrent در زبان‌های دیگر (مانند Java, Rust, JavaScript) نیز هست و در Go، idiomatic ترین پیاده‌سازی معمولاً مبتنی بر channel و goroutine است.\n9.4.11.2 دیاگرام # flowchart TD A[Start async operation] --\u003e B[Return Future object] B -- \"Do other work\" --\u003e C[Need result] C --\u003e D[Wait for result from Future] D --\u003e E[Receive final result and continue] A -- \"Run in background\" --\u003e F[Async task completes] F -- \"Set result in Future\" --\u003e D 9.4.11.3 نمونه کد # package main import ( \"errors\" \"fmt\" \"sync\" \"time\" ) type FutureInt struct { once sync.Once result int err error done chan struct{} } // Get با بلاک تا تکمیل شدن عملیات صبر می‌کند و نتیجه و خطا را برمی‌گرداند func (f *FutureInt) Get() (int, error) { \u003c-f.done return f.result, f.err } // GetWithTimeout با تایم‌اوت مشخص منتظر نتیجه می‌ماند func (f *FutureInt) GetWithTimeout(timeout time.Duration) (int, error) { select { case \u003c-f.done: return f.result, f.err case \u003c-time.After(timeout): return 0, errors.New(\"timeout waiting for future\") } } func longRunningTask() *FutureInt { f := \u0026FutureInt{done: make(chan struct{})} go func() { defer close(f.done) // شبیه‌سازی کار زمان‌بر و گاهی بروز خطا time.Sleep(time.Second) if time.Now().Unix()%2 == 0 { f.result = 42 f.err = nil } else { f.result = 0 f.err = errors.New(\"unexpected error\") } }() return f } func main() { f := longRunningTask() fmt.Println(\"Do something else while waiting for result...\") // دریافت نتیجه با مدیریت خطا result, err := f.Get() if err != nil { fmt.Println(\"Future failed:\", err) return } fmt.Println(\"The answer is:\", result) // نمونه با timeout f2 := longRunningTask() result2, err2 := f2.GetWithTimeout(500 * time.Millisecond) if err2 != nil { fmt.Println(\"Timeout error:\", err2) } else { fmt.Println(\"Result with timeout:\", result2) } } ▶ اجرای کد کپی ✖ بستن خروجی در این مثال از الگوی Future در Go، ما یک ساختار کامل و قابل اطمینان برای مدیریت نتیجه‌ی عملیات ناهمزمان (asynchronous) و دریافت امن و حرفه‌ای نتیجه، همراه با مدیریت خطا و قابلیت timeout پیاده‌سازی کرده‌ایم.\nدر ساختار FutureInt، یک کانال از نوع chan struct{} با نام done وجود دارد که سیگنال اتمام عملیات را ارسال می‌کند. مقدار نتیجه (result) و خطا (err) به صورت فیلدهای struct نگهداری می‌شوند. زمانی که عملیات ناهمزمان (در goroutine مربوط به تابع longRunningTask) به پایان می‌رسد، کانال done بسته می‌شود تا هر goroutine منتظر یا فراخوانی کننده‌ی Get یا GetWithTimeout متوجه آماده‌شدن نتیجه شود.\nمتد Get تا زمانی که عملیات کامل نشده منتظر می‌ماند و پس از اتمام، مقدار نهایی و خطا را بازمی‌گرداند. این کار با خواندن از کانال done انجام می‌شود، که هم thread-safe و هم idiomatic است. متد GetWithTimeout علاوه بر انتظار برای تکمیل، این امکان را می‌دهد که اگر نتیجه طی زمان معینی آماده نشد، با پیغام خطای timeout عملیات را مدیریت کنید—این قابلیت در سناریوهای real-time و حساس به تاخیر اهمیت زیادی دارد.\nدر تابع main، ابتدا یک Future ساخته می‌شود و قبل از فراخوانی نتیجه می‌توان هر کار دیگری انجام داد (این همان مزیت کلیدی Future است). سپس با صدا زدن Get، نتیجه و خطا را دریافت و مدیریت می‌کنیم. همچنین نمونه‌ای از دریافت نتیجه با timeout هم آورده شده است تا نحوه‌ی مدیریت عملیات طولانی یا گیر افتاده نیز مشخص باشد.\nاین معماری علاوه بر ایمنی همزمانی، جداسازی وظایف (تولید و مصرف نتیجه)، پشتیبانی از خطا و timeout، به سادگی قابل توسعه و استفاده در پروژه‌های واقعی و تولیدی است و تجربه برنامه‌نویسی concurrent را بسیار حرفه‌ای‌تر و قابل کنترل‌تر می‌کند.\n9.4.11.4 کاربردها # درخواست‌های شبکه (Asynchronous Network Requests): در زمانی که نیاز به ارسال درخواست به یک سرویس خارجی یا API دارید، الگوی Future کمک می‌کند که بتوانید درخواست را به صورت ناهمزمان ارسال و به محض آماده شدن پاسخ، آن را دریافت کنید. این کار باعث می‌شود بتوانید بدون مسدود کردن برنامه، کارهای دیگری انجام دهید تا زمانی که نتیجه آماده شود. این تکنیک برای توسعه کلاینت‌های HTTP، REST، GraphQL و حتی WebSocket بسیار کاربردی است. کوئری‌های پایگاه داده (Async Database Querying): هنگام اجرای کوئری‌های سنگین یا زمان‌بر روی دیتابیس، Future اجازه می‌دهد کوئری را به صورت ناهمزمان آغاز کنید و هر زمان که نتیجه واقعاً لازم بود، آن را دریافت کنید. این رویکرد برای برنامه‌هایی که باید همزمان چند کوئری مختلف را به دیتابیس ارسال کنند (مانند جمع‌آوری داده از چند جدول یا سرور متفاوت) بسیار مفید است و latency کلی برنامه را کاهش می‌دهد. محاسبات سنگین و پردازش موازی: اگر در برنامه نیاز به انجام محاسبات CPU-intensive (مانند تجزیه داده، پردازش تصویر، رمزنگاری و \u0026hellip;) دارید، می‌توانید هر task را در یک Future قرار دهید و نتایج را در صورت نیاز، به صورت همزمان و بدون بلاک شدن منتظر بمانید. این کار باعث بهبود performance و پاسخگویی سیستم خواهد شد. ترکیب و همگام‌سازی عملیات مستقل (Composition and Synchronization): می‌توانید چندین Future ایجاد کنید و به طور موازی آن‌ها را اجرا نمایید، سپس به صورت هماهنگ (مثلاً با WaitGroup یا channel) منتظر دریافت همه نتایج باشید (pattern معروف به Fan-In). این رویکرد برای جمع‌آوری نتایج عملیات‌های موازی (مانند دانلود چند فایل یا جمع‌آوری داده از چند سرویس) ایده‌آل است. پردازش رویداد و message queue: در معماری‌هایی مانند صف پیام یا پردازش رویداد (event-driven)، هر message را می‌توان به عنوان یک Future مدیریت کرد و پس از پایان پردازش، نتیجه یا پاسخ را برای ادامه کار استفاده نمود. "},{"id":216,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-pipeline/","title":"9.4.12 الگو Pipeline","section":"9.4 الگوهای همزمانی","content":" 9.4.12.1 توضیحات # الگوی خط لوله (Pipeline) یکی از حرفه‌ای‌ترین و پرکاربردترین الگوهای همزمانی در زبان Go است که نقش بسیار مهمی در طراحی سیستم‌های مقیاس‌پذیر، قابل نگهداری و با کارایی بالا دارد. هدف این الگو این است که یک کار بزرگ یا پردازش پیچیده را به چند مرحله (stage) کاملاً مستقل تقسیم کند، به طوری که هر مرحله بتواند همزمان با مراحل دیگر اجرا شود. در این ساختار، هر stage مسئولیت انجام یک بخش خاص از فرآیند را بر عهده دارد (مثلاً خواندن داده، پاک‌سازی، پردازش، ذخیره‌سازی و\u0026hellip;) و معمولاً هر stage در یک goroutine مجزا اجرا می‌شود.\nانتقال داده بین این مراحل، به صورت ایمن و concurrent از طریق channel انجام می‌گیرد. هر مرحله داده‌های پردازش‌شده خود را به کانال خروجی ارسال می‌کند و مرحله بعدی آن داده‌ها را از کانال ورودی دریافت می‌کند. این ساختار باعث می‌شود که مراحل مختلف pipeline بتوانند بدون وابستگی مستقیم به یکدیگر، به صورت موازی و کاملاً decoupled کار کنند؛ به عبارتی، هر stage می‌تواند با سرعت خود کار کند و کندی یا شتاب یک مرحله، روی کل پردازش اثر غیرخطی نخواهد داشت.\nاین الگو به طور گسترده در پردازش داده‌های حجیم، تحلیل داده‌های real-time، پیاده‌سازی ETL (استخراج، تبدیل و بارگذاری)، پردازش تصویر و صدا، یا هرجا که داده باید مرحله به مرحله و به شکل stream پردازش شود، کاربرد دارد. با استفاده از Pipeline، کد ساده‌تر، توسعه‌پذیرتر و خطایابی آن آسان‌تر می‌شود و همچنین بهره‌وری سیستم به حداکثر می‌رسد، چرا که همزمانی و توزیع بار به بهترین شکل انجام می‌شود.\n9.4.12.2 دیاگرام # flowchart LR A[Input Data] --\u003e S1[Stage 1: Preprocessing] S1 --\u003e S2[Stage 2: Processing] S2 --\u003e S3[Stage 3: Postprocessing] S3 --\u003e B[Output Data] subgraph Goroutine S1 S2 S3 end style S1 fill:#d9f5f9,stroke:#30b5c8,stroke-width:2px style S2 fill:#e2f7e9,stroke:#46c772,stroke-width:2px style S3 fill:#fdf2e8,stroke:#e8922d,stroke-width:2px 9.4.12.3 نمونه کد # package main import ( \"fmt\" ) // تولید داده اولیه (stage 1) func gen(nums ...int) \u003c-chan int { out := make(chan int, 2) // کانال بافر دار go func() { defer close(out) for _, n := range nums { out \u003c- n } }() return out } // مربع هر عدد (stage 2) func sq(in \u003c-chan int) \u003c-chan int { out := make(chan int, 2) go func() { defer close(out) for n := range in { out \u003c- n * n } }() return out } // افزایش عدد به اندازه ۱۰ (stage 3) func addTen(in \u003c-chan int) \u003c-chan int { out := make(chan int, 2) go func() { defer close(out) for n := range in { out \u003c- n + 10 } }() return out } func main() { // ساخت خط لوله با چندین مرحله stage1 := gen(2, 3, 5, 7) stage2 := sq(stage1) stage3 := addTen(stage2) // مصرف تمام خروجی pipeline for v := range stage3 { fmt.Println(v) } } ▶ اجرای کد کپی ✖ بستن خروجی در این مثال، یک خط لوله (Pipeline) همزمانی واقعی و کاملاً idiomatic در زبان Go پیاده‌سازی شده است که چندین مرحله (stage) پردازشی را به صورت مستقل و موازی اجرا می‌کند. هر مرحله‌ی این pipeline یک تابع جداگانه است که داده‌های دریافتی از مرحله قبلی را از یک کانال (channel) می‌گیرد، عملیات مورد نظر خود را روی هر داده انجام می‌دهد و نتیجه را به کانال خروجی ارسال می‌کند. این مدل باعث می‌شود هر بخش از پردازش بدون وابستگی به سرعت بخش دیگر و به صورت ایمن و concurrent اجرا شود.\nدر کد، ابتدا با تابع gen داده‌های اولیه (در اینجا ۲، ۳، ۵ و ۷) تولید و وارد یک کانال می‌شوند. سپس این داده‌ها به مرحله دوم (sq) ارسال می‌شوند که کار هر goroutine در این مرحله گرفتن عدد و بازگرداندن مربع آن است. خروجی مرحله دوم وارد مرحله سوم (addTen) می‌شود که به هر عدد، مقدار ۱۰ اضافه می‌کند. هر مرحله در یک goroutine مجزا و روی یک کانال بافر‌دار اجرا می‌شود که باعث افزایش performance و decoupling کامل مراحل می‌شود.\nدر انتها، یک حلقه‌ی ساده روی خروجی مرحله آخر (stage3) قرار می‌گیرد و تمام نتایج به ترتیب مصرف و چاپ می‌شوند. استفاده از حلقه و range روی کانال، مصرف امن، بدون بلاک شدن و بدون نگرانی از goroutine leak را تضمین می‌کند، چون با بسته شدن کانال، حلقه به طور خودکار خارج می‌شود. این ساختار بسیار منعطف و قابل توسعه است؛ می‌توان به راحتی مراحل بیشتری به pipeline افزود یا منطق هر مرحله را تغییر داد، بدون اینکه بخش‌های دیگر برنامه نیاز به تغییر داشته باشند. چنین معماری، مناسب سیستم‌های پردازش داده، real-time، ETL و سناریوهای تحلیل موازی و مقیاس‌پذیر است.\nیک مثال کاربردی دیگر\n9.4.12.4 کاربردها # مدیریت ترافیک و پردازش شبکه (Network Stream Processing): الگوی Pipeline به شما اجازه می‌دهد چندین اتصال شبکه (مثلاً درخواست‌های همزمان کاربران یا پیام‌های ورودی) را به صورت مرحله‌ای مدیریت کنید؛ به گونه‌ای که هر بسته یا پیام از مراحل مختلفی مانند خواندن، تجزیه (parse)، فیلتر (filter)، اعتبارسنجی (validation)، مسیریابی (routing)، و حتی رمزنگاری یا فشرده‌سازی عبور کند. این مدل به شدت در سرورهای proxy، load balancer و نرم‌افزارهای firewall کاربرد دارد. محاسبات چند مرحله‌ای و زنجیره‌ای (Multi-stage Computation): Pipeline راهکاری عالی برای تقسیم محاسبات پیچیده به گام‌های ساده‌تر و مستقل است؛ به طوری که هر مرحله روی بخشی از داده یا نتیجه مرحله قبل کار کند. برای مثال: تولید داده خام → پاک‌سازی → تبدیل فرمت → محاسبات عددی یا آماری → تجمیع نهایی. این ساختار کارایی و خوانایی برنامه را افزایش و توسعه آن را آسان‌تر می‌کند. پردازش و تحلیل گزارش‌ها (Log Processing \u0026amp; ETL): در سامانه‌های جمع‌آوری و تحلیل لاگ یا داده‌های گزارش، می‌توان داده‌ها را به صورت جریان پیوسته از مراحل مختلف عبور داد؛ مثلاً ابتدا فیلترکردن داده‌های نامربوط، سپس تجزیه (parse) رکوردها، enrich کردن با داده‌های خارجی (مانند geoip)، و در نهایت ذخیره‌سازی یا index برای جستجو. این روش پایه معماری‌های ETL، سامانه‌های لاگ توزیع‌شده (ELK، Loki، \u0026hellip;)، و data lakeها است. تجزیه و تحلیل داده‌های بزرگ (Big Data \u0026amp; Real-Time Analytics): در پروژه‌های داده‌محور، Pipeline ابزاری کلیدی برای اجرای زنجیره‌ای عملیات روی داده‌های حجیم است؛ مانند فیلترکردن داده‌ها، map/reduce، تبدیل ویژگی‌ها (feature engineering)، استخراج اطلاعات، و ساخت گزارش‌های لحظه‌ای یا ذخیره در بانک داده. این مدل به پردازش موازی، افزایش throughput و مقیاس‌پذیری سامانه کمک می‌کند. پردازش فایل و تصویر: در بسیاری از سرویس‌های backend، فایل‌ها یا تصاویر آپلودشده می‌توانند به صورت pipeline پردازش شوند: خواندن فایل → decode → resize/crop → تبدیل فرمت → اعمال واترمارک → ذخیره‌سازی یا آپلود به سرویس دیگر. "},{"id":217,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-subscription/","title":"9.4.13 الگو Subscription","section":"9.4 الگوهای همزمانی","content":" 9.4.13.1 توضیحات # الگوی Subscription (یا Pub-Sub / Observer Pattern) یکی از پرکاربردترین الگوها در معماری‌های رویداد-محور و همزمان (event-driven \u0026amp; concurrent) است که امکان ثبت‌نام (subscribe) یک یا چند مصرف‌کننده (consumer) را برای دریافت خودکار داده‌های جدید از یک منبع یا سرویس فراهم می‌کند. در این الگو، یک یا چند مصرف‌کننده به یک \u0026ldquo;آدرس\u0026rdquo; یا منبع اشتراک (مثلاً یک topic، کانال یا event source) متصل می‌شوند و هر زمان که داده یا رویداد جدیدی منتشر شد (publish)، اطلاعات به طور خودکار و بی‌نیاز از polling مکرر به همه‌ی مصرف‌کننده‌های عضو ارسال می‌شود.\nدر زبان Go، پیاده‌سازی Subscription اغلب با استفاده از channelها و goroutineها انجام می‌شود: یک goroutine به عنوان publisher وظیفه تولید و ارسال داده‌ها را دارد، و هر consumer می‌تواند با subscribe کردن (ثبت نام) در یک channel مشترک، داده‌های جدید را دریافت کند. این مدل به شما اجازه می‌دهد تا به سادگی چندین consumer را همزمان به یک منبع داده وصل کنید و مدیریت رویدادهای همزمان، صف‌های پیام (message queue)، بروزرسانی‌های لحظه‌ای، یا حتی سیستم‌های نوتیفیکیشن را به صورت concurrent و بدون بلاک شدن یا پیچیدگی زیاد پیاده‌سازی کنید.\nکاربردهای Subscription در Go بسیار گسترده است: از مدیریت پیام‌های real-time (مثل ارسال اعلان در اپلیکیشن‌ها)، اتصال میکروسرویس‌ها، پیاده‌سازی سیستم‌های event sourcing و message broker گرفته تا جمع‌آوری لاگ‌های زنده یا حتی مانیتورینگ سرویس‌های حیاتی. مزیت اصلی این الگو جداسازی کامل بین تولیدکننده و مصرف‌کننده (decoupling)، مقیاس‌پذیری، و سادگی توسعه و تست در معماری‌های concurrent و reactive است.\n9.4.13.2 دیاگرام # flowchart TD Publisher[Publisher / Source] Sub1[Subscriber 1] Sub2[Subscriber 2] SubN[Subscriber N] Topic[Channel / Topic] Publisher -- \"Publish Data\" --\u003e Topic Topic -- \"Push Update\" --\u003e Sub1 Topic -- \"Push Update\" --\u003e Sub2 Topic -- \"Push Update\" --\u003e SubN Sub1 -- \"Subscribe\" --\u003e Topic Sub2 -- \"Subscribe\" --\u003e Topic SubN -- \"Subscribe\" --\u003e Topic style Topic fill:#e2f0fc,stroke:#377dbf,stroke-width:2px style Publisher fill:#f5e8ff,stroke:#b486e5,stroke-width:2px style Sub1,Sub2,SubN fill:#e9fbe7,stroke:#6dc165,stroke-width:2px 9.4.13.3 نمونه کد # package main import ( \"context\" \"encoding/json\" \"fmt\" \"io/ioutil\" \"log\" \"net/http\" \"os\" \"time\" ) const exampleAPIAddress = \"https://random-data-api.com/api/stripe/random_stripe\" type Card struct { Id uint `json:\"id\"` Uid string `json:\"uid\"` ValidCard string `json:\"valid_card\"` Token string `json:\"token\"` InvalidCard string `json:\"invalid_card\"` Month string `json:\"month\"` Year string `json:\"year\"` CCV string `json:\"ccv\"` CCVAmex string `json:\"ccv_amex\"` } type Subscription interface { Updates() \u003c-chan Card } type Fetcher interface { Fetch() (Card, error) } type sub struct { fetcher Fetcher updates chan Card } type fetcher struct { url string } type fetchResult struct { fetchedCard Card err error } // NewSubscription create subscription for fetch data per freq time in second func NewSubscription(ctx context.Context, fetcher Fetcher, freq uint) Subscription { s := \u0026sub{ fetcher: fetcher, updates: make(chan Card), } go s.serve(ctx, freq) return s } func NewFetcher(url string) Fetcher { return \u0026fetcher{ url: url, } } func (f *fetcher) Fetch() (Card, error) { return requestAPI(f.url) } func (s *sub) serve(ctx context.Context, freq uint) { ticker := time.NewTicker(time.Duration(freq) * time.Second) done := make(chan fetchResult, 1) var ( fetchedCard Card fetchResponseStream chan Card pending bool ) for { if pending { fetchResponseStream = s.updates } else { fetchResponseStream = nil } select { case \u003c-ticker.C: if pending { break } go func() { fetched, err := s.fetcher.Fetch() done \u003c- fetchResult{fetched, err} }() case result := \u003c-done: fetchedCard = result.fetchedCard if result.err != nil { log.Printf(\"fetch got error %v\", result.err) break } pending = true case fetchResponseStream \u003c- fetchedCard: pending = false case \u003c-ctx.Done(): return } } } func (s *sub) Updates() \u003c-chan Card { return s.updates } func requestAPI(url string) (Card, error) { card := Card{} req, err := http.NewRequest(http.MethodGet, url, nil) if err != nil { return Card{}, err } res, err := http.DefaultClient.Do(req) if err != nil { return Card{}, err } body, err := ioutil.ReadAll(res.Body) if err != nil { return Card{}, err } if err := json.Unmarshal(body, \u0026card); err != nil { return Card{}, err } return card, nil } func main() { ctx, cancel := context.WithCancel(context.Background()) sub := NewSubscription(ctx, NewFetcher(exampleAPIAddress), 3) time.AfterFunc(1*time.Minute, func() { cancel() log.Println(\"canceled subscription task\") os.Exit(0) }) for card := range sub.Updates() { fmt.Println(card) } } ▶ اجرای کد کپی ✖ بستن خروجی در این مثال، ابتدا یک اینترفیس به نام Subscription تعریف شده است که متدی به نام Updates دارد و کانالی از نوع Card را برمی‌گرداند. این کانال نقش مسیر ارتباطی را بین تولیدکننده و مصرف‌کننده ایفا می‌کند، به طوری که مصرف‌کننده می‌تواند به طور همزمان و غیرمسدود داده‌های جدید را دریافت کند. همچنین اینترفیس Fetcher طراحی شده که وظیفه‌ی فراخوانی API و دریافت داده‌ها را بر عهده دارد و متد Fetch را ارائه می‌دهد. این تفکیک وظایف باعث می‌شود کد قابلیت توسعه و تست بیشتری داشته باشد.\nتابع NewSubscription به عنوان سازنده Subscription عمل می‌کند؛ این تابع یک struct از نوع sub ایجاد می‌کند که حاوی fetcher و یک کانال updates است. سپس متد serve به صورت یک goroutine اجرا می‌شود تا عملیات fetch را در فواصل زمانی مشخص (که با پارامتر freq تعیین می‌شود) تکرار کند. درون این متد از time.Ticker برای زمان‌بندی دقیق استفاده شده است تا به صورت منظم و بدون ایجاد سربار اضافی، داده‌ها را از API فراخوانی کند و در صورت دریافت موفقیت‌آمیز، آن‌ها را در کانال منتشر نماید. همچنین با کمک متغیر pending اطمینان حاصل می‌شود که یک fetch جدید تا قبل از اتمام fetch قبلی آغاز نشود، بنابراین از فشار بیش از حد به سرویس جلوگیری می‌شود.\nمصرف‌کنندگان داده‌ها از طریق متد Updates به کانال updates دسترسی دارند و به محض دریافت داده‌های جدید، می‌توانند پردازش خود را آغاز کنند. استفاده از context.Context در این ساختار اجازه می‌دهد که در هر زمان عملیات fetch به صورت ایمن لغو شود و goroutine مربوطه به سرعت و بدون باقی ماندن در حالت بلاک‌شده خاتمه یابد. این طراحی باعث می‌شود که برنامه همزمانی بهینه‌ای داشته باشد، منابع به خوبی مدیریت شود و کد قابلیت خوانایی، توسعه و تست آسان را حفظ کند.\nدر کل، این الگو ترکیبی از بهترین شیوه‌های Go در مدیریت جریان داده‌های ناهمزمان، کنترل concurrency و ارتباط بین goroutineها است که برای دریافت داده‌های زنده از API یا منابع خارجی بسیار مناسب است. با چنین معماری می‌توان سیستم‌هایی تولید کرد که علاوه بر مقیاس‌پذیری بالا، مقاوم در برابر خطا و قابل کنترل نیز باشند.\n9.4.13.4 کاربردها # دریافت اطلاعات از تولیدکننده‌ها (Publisher) یا سیستم‌های Pub/Sub: الگوی Subscription به شما این امکان را می‌دهد که به سادگی به یک یا چند منبع داده (مانند سرویس‌های پیام‌رسان، سیستم‌های صف پیام، یا هر منبعی که به صورت publish/subscribe کار می‌کند) متصل شوید و داده‌های جدید را به صورت همزمان و غیرمسدود دریافت کنید. این کار باعث می‌شود مصرف‌کننده‌ها به صورت real-time یا نزدیک به real-time اطلاعات را دریافت و پردازش نمایند و از پیچیدگی‌های مدیریت اتصال یا polling مکرر بی‌نیاز شوند. همگام‌سازی داده‌ها از APIهای خارجی: در بسیاری از برنامه‌ها نیاز است داده‌ها یا وضعیت از سرویس‌های خارجی (مانند RESTful APIها، سرویس‌های ابری یا سیستم‌های تحلیلی) به صورت دوره‌ای یا بر اساس رویداد به‌روزرسانی شوند. الگوی Subscription این امکان را فراهم می‌کند که بتوانید با تعریف یک سازوکار هوشمند برای دریافت به‌روزرسانی‌ها، مصرف داده‌ها را ساده، پایدار و بهینه کنید. این الگو به خصوص در سناریوهای real-time dashboards، اطلاع‌رسانی لحظه‌ای و هماهنگ‌سازی داده‌های توزیع‌شده کاربرد فراوان دارد. "},{"id":218,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-brdige-channel/","title":"9.4.14 الگو Bridge Channel","section":"9.4 الگوهای همزمانی","content":" 9.4.14.1 توضیحات # الگوی Bridge Channel یکی از الگوهای ساده اما بسیار مفید در زبان Go است که امکان اتصال و انتقال داده بین دو یا چند کانال مستقل را فراهم می‌کند. این الگو زمانی کاربرد دارد که بخواهید داده‌های تولیدشده در یک goroutine یا زیرسیستم را پس از دریافت، به کانال دیگری هدایت کنید؛ به عبارتی، مانند یک پل (bridge) عمل می‌کنید که داده‌ها را از یک کانال ورودی گرفته و به کانال خروجی منتقل می‌نماید.\nدر عمل، یک goroutine بین دو کانال قرار می‌گیرد: یکی برای دریافت (مثلاً in \u0026lt;-chan T) و دیگری برای ارسال (out chan\u0026lt;- T). این goroutine یک حلقه ساده for با range in اجرا می‌کند و هر مقداری که از کانال ورودی دریافت کند را بلافاصله به کانال خروجی می‌فرستد. این تکنیک برای decoupling بین تولیدکننده و مصرف‌کننده عالی است و در سناریوهایی مانند اتصال چند مرحله pipeline، تغییر مسیر داده‌ها، فیلترینگ داده‌ها یا حتی انتقال بین کانال‌هایی با ویژگی‌های متفاوت (مثلاً بافر متفاوت یا ownership مختلف) بسیار کاربرد دارد.\nاز مزایای این الگو می‌توان به سادگی در پیاده‌سازی، انعطاف‌پذیری بالا، و جداسازی مسئولیت‌ها اشاره کرد. این الگو به خصوص در سیستم‌هایی که نیاز به پردازش یا هدایت جریان‌های داده بین چند بخش یا ماژول دارند، بسیار مؤثر است و به افزایش خوانایی و maintainability کد کمک می‌کند. در صورت نیاز می‌توان عملیات اضافی مثل تبدیل داده، اعتبارسنجی یا لاگ‌گیری را نیز داخل goroutine پل انجام داد تا ساختار تمیزتر باقی بماند.\n9.4.14.2 دیاگرام # flowchart LR A[Producer / Input Source] B[Input Channel] C[Bridge Goroutine] D[Output Channel] E[Consumer / Output Sink] A --\u003e B B --\u003e C C --\u003e D D --\u003e E style B fill:#e2f0fc,stroke:#377dbf,stroke-width:2px style D fill:#e2f0fc,stroke:#377dbf,stroke-width:2px style C fill:#fff0cc,stroke:#e69e00,stroke-width:2px style A fill:#e6ffe6,stroke:#42b983,stroke-width:2px style E fill:#fce4ec,stroke:#e91e63,stroke-width:2px 9.4.17.3 نمونه کد # package main import ( \"fmt\" ) // bridge بین input و output قرار می‌گیرد و داده‌ها را منتقل می‌کند. func bridge(input \u003c-chan int, output chan\u003c- int) { for val := range input { output \u003c- val } close(output) } func main() { input := make(chan int) output := make(chan int) // اجرای پل انتقال داده در یک goroutine جدا go bridge(input, output) // ارسال چند داده به کانال input go func() { for i := 1; i \u003c= 3; i++ { input \u003c- i } close(input) }() // دریافت داده‌ها از کانال output for val := range output { fmt.Println(\"Received:\", val) } } ▶ اجرای کد کپی ✖ بستن خروجی در این مثال، ما پیاده‌سازی بهبودیافته‌ای از الگوی Bridge Channel در زبان Go را مشاهده می‌کنیم؛ الگویی که هدف آن اتصال دو کانال (input و output) از طریق یک goroutine واسط (bridge) است. این واسط به صورت شفاف داده‌ها را از یک کانال می‌خواند و به کانال دیگری منتقل می‌کند، به‌گونه‌ای که بخش‌های تولید (Producer) و مصرف (Consumer) بتوانند بدون وابستگی مستقیم به یکدیگر کار کنند.\nدر ابتدای برنامه، دو کانال input و output تعریف می‌شوند. سپس تابعی به نام bridge ایجاد شده که به عنوان واسطه عمل می‌کند. این تابع در یک goroutine اجرا شده و با استفاده از یک حلقه for val := range input، تا زمانی که کانال input باز است، مقادیر را دریافت می‌کند و آن‌ها را بلافاصله در کانال output می‌نویسد. پس از بسته شدن input، تابع bridge نیز با بستن output خاتمه می‌یابد؛ این یک الگوی بسیار ایمن و idiomatic در Go برای جلوگیری از goroutine leak است.\nدر بخش main، یک goroutine دیگر وظیفه ارسال داده به input را بر عهده دارد. در اینجا، مقادیر ۱ تا ۳ به input ارسال شده و سپس کانال بسته می‌شود. در انتها، از یک حلقه for val := range output استفاده شده تا داده‌های منتقل‌شده به output دریافت و چاپ شوند. این ساختار به گونه‌ای طراحی شده که پس از اتمام پردازش، برنامه به صورت تمیز و بدون بلاک شدن به پایان می‌رسد.\nاین مدل نه‌تنها پایه‌ای برای سیستم‌های streaming و pipeline است، بلکه برای ساختاردهی بهتر به معماری‌های همزمان، decoupling اجزا، و افزایش انعطاف‌پذیری و توسعه‌پذیری کد بسیار مناسب است.\n9.4.18.4 کاربردها # انتقال داده بین مراحل مختلف در خط لوله‌های داده اتصال میان دو زیرسیستم که از لحاظ طراحی جدا شده‌اند بافر کردن بین تولیدکننده سریع و مصرف‌کننده کند (یا بالعکس) تغییر مسیر جریان داده‌ها (مثلاً برای logging یا debug) کنترل جریان بین سرویس‌های مختلف در معماری microservice "},{"id":219,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-queuing/","title":"9.4.15 الگو Queuing","section":"9.4 الگوهای همزمانی","content":" 9.4.15.1 توضیحات # الگوی صف (Queue Pattern) در زبان Go، الگویی است که در آن با استفاده از یک goroutine مرکزی و یک یا چند کانال ورودی و خروجی، داده‌ها را به صورت منظم، به ترتیب ورود (FIFO) مدیریت می‌کند. در این الگو، برخلاف استفاده مستقیم از کانال که ممکن است ترتیب یا بافر محدودی داشته باشد، یک گوروتین به عنوان صف درون‌ساخت (in-memory queue) عمل می‌کند و داده‌های دریافتی از کانال ورودی را در یک ساختار صف مانند (مانند slice) نگه می‌دارد، سپس بر اساس منطق زمان‌بندی یا در دسترس بودن مصرف‌کننده، آن‌ها را به کانال خروجی ارسال می‌کند.\nهدف اصلی این الگو، کنترل جریان (flow control) و جداسازی سرعت تولید و مصرف داده‌ها است. برای مثال، اگر producer داده را با سرعت بالایی ارسال کند ولی consumer نتواند به همان سرعت پردازش کند، صف می‌تواند به عنوان بافر موقت بین این دو عمل کند. این کار از بلاک شدن producer جلوگیری کرده و سیستم را پایدار نگه می‌دارد. همچنین، چون داده‌ها در یک ساختار مشخص ذخیره می‌شوند، می‌توان بر ترتیب دریافت، اولویت‌بندی، یا حتی سیاست‌های پردازش (مثل batch processing) نیز کنترل داشت.\nاین الگو در طراحی سیستم‌های message queue، task queue، buffering systems و job dispatcher بسیار رایج است. به‌ویژه زمانی که لازم باشد چندین درخواست به صف وارد شده و بر اساس اولویت یا نوبت پردازش شوند، یا بین سرعت‌های نامتوازن تولید و مصرف تطابق ایجاد شود. الگوی صف در Go، با کمک ترکیب ساده‌ای از goroutine + channel + slice، یک راهکار سبک، قابل‌اتکا و توسعه‌پذیر برای این سناریوها ارائه می‌دهد.\n9.4.15.2 دیاگرام # flowchart LR Producer1[Producer 1] --\u003e IN[Input Channel] Producer2[Producer 2] --\u003e IN IN --\u003e Q[Queue Goroutine Buffered with slice] Q --\u003e OUT[Output Channel] OUT --\u003e Consumer1[Consumer 1] OUT --\u003e Consumer2[Consumer 2] style IN fill:#d0e8ff,stroke:#2980b9,stroke-width:2px style OUT fill:#d0e8ff,stroke:#2980b9,stroke-width:2px style Q fill:#fff0cc,stroke:#e67e00,stroke-width:2px style Producer1,Producer2 fill:#e6ffe6,stroke:#27ae60,stroke-width:2px style Consumer1,Consumer2 fill:#fde2e2,stroke:#c0392b,stroke-width:2px 9.4.15.3 نمونه کد # package main import ( \"fmt\" \"time\" ) func main() { enqueue := make(chan int) // کانال برای دریافت داده‌های جدید dequeue := make(chan int) // کانال برای ارسال داده به مصرف‌کننده done := make(chan struct{}) // کانال برای پایان اجرای برنامه // Goroutine صف: مسئول بافر و انتقال داده‌ها به ترتیب go func() { var queue []int for { var first int var out chan int if len(queue) \u003e 0 { first = queue[0] out = dequeue } select { case item := \u003c-enqueue: queue = append(queue, item) fmt.Println(\"Enqueued:\", item) case out \u003c- first: queue = queue[1:] case \u003c-done: close(dequeue) return } } }() // Producer: ارسال ۱۰ مقدار به صف go func() { for i := 0; i \u003c 10; i++ { enqueue \u003c- i time.Sleep(100 * time.Millisecond) } // پایان time.Sleep(1 * time.Second) done \u003c- struct{}{} }() // Consumer: دریافت مقادیر به ترتیب for item := range dequeue { fmt.Println(\"Dequeued:\", item) } } ▶ اجرای کد کپی ✖ بستن خروجی در این مثال ما سه کانال داریم: enqueue برای وارد کردن آیتم‌ها به صف، dequeue برای خارج کردن آیتم‌ها از صف، و done برای پایان دادن به اجرای برنامه. این ساختار به ما اجازه می‌دهد یک صف ساده ولی همزمان و thread-safe را با استفاده از ویژگی‌های زبان Go پیاده‌سازی کنیم.\nیک goroutine اصلی مسئول مدیریت صف است. این goroutine یک queue از نوع []int نگه می‌دارد که همان بافر داخلی صف ماست. درون یک حلقه بی‌نهایت، ابتدا بررسی می‌شود که آیا صف خالی نیست. اگر خالی نبود، مقدار اول صف (first = queue[0]) برای ارسال آماده می‌شود و کانال out برابر dequeue قرار می‌گیرد. در غیر این صورت، مقدار out خالی می‌ماند و بنابراین حالت ارسال انجام نخواهد شد.\nسپس با select سه حالت بررسی می‌شود. اگر آیتم جدیدی از طریق enqueue وارد شود، به انتهای صف اضافه می‌شود. اگر صف خالی نباشد و dequeue آمادگی دریافت داشته باشد (out \u0026lt;- first)، مقدار اول صف به مصرف‌کننده ارسال می‌شود و از صف حذف می‌شود (queue = queue[1:]). اگر سیگنالی از done برسد، یعنی برنامه باید پایان یابد؛ در این صورت کانال dequeue بسته می‌شود و goroutine متوقف می‌شود.\nدر بخش Producer، یک goroutine جدید راه‌اندازی می‌شود که در آن با استفاده از یک حلقه for از ۰ تا ۹ مقدار تولید می‌شود و هر مقدار از طریق enqueue وارد صف می‌شود. بعد از پایان تولید داده‌ها، یک ثانیه صبر می‌کند و سپس سیگنال done ارسال می‌شود تا صف به طور مرتب بسته شود.\nدر نهایت، حلقه for item := range dequeue در تابع اصلی (main) نقش Consumer را بازی می‌کند. این حلقه از روی کانال dequeue آیتم‌ها را دریافت می‌کند و چاپ می‌کند. از آنجا که این حلقه تا زمان بسته شدن کانال ادامه دارد، به‌صورت خودکار پس از رسیدن سیگنال done و بسته شدن dequeue، خاتمه می‌یابد.\nدر مجموع، این کد پیاده‌سازی بسیار مناسبی از صف همزمان (synchronized queue) در زبان Go است که از مزیت‌های goroutineها و channelها برای جداسازی concerns و مدیریت همزمانی بهره برده. طراحی آن بسیار ایمن، ساده و مقیاس‌پذیر است و به‌خوبی نشان می‌دهد چگونه می‌توان سیستم‌هایی با تولیدکننده و مصرف‌کننده را بدون نیاز به lock و mutex ساخت.\n9.4.15.4 کاربردها # زمان‌بندی وظایف (Task Scheduling): از کانال به‌عنوان صف وظایف (task queue) استفاده می‌شود تا وظایف تولیدشده از سوی گوروتین‌های مختلف، به گوروتین‌های worker برای اجرا سپرده شوند. این الگو برای پیاده‌سازی worker pool بسیار رایج است و باعث می‌شود وظایف به ترتیبی که وارد کانال می‌شوند پردازش شوند، بدون نیاز به مدیریت پیچیده‌ی همزمانی با mutex. بافر کردن داده‌ها (Buffering Input Data): در مواقعی که نرخ ورود داده‌ها بیشتر از نرخ پردازش است، یک کانال بافر‌دار می‌تواند به‌عنوان صف موقت برای ذخیره‌ی داده‌ها استفاده شود. این کمک می‌کند فشار از روی گوروتینی که داده را مصرف می‌کند برداشته شود و از data loss یا race conditions جلوگیری شود. محدودسازی نرخ (Throttling/Rate Limiting): کانال با ظرفیت مشخص می‌تواند برای کنترل نرخ پردازش به کار رود. اگر گوروتین مصرف‌کننده کند عمل کند و کانال پر شود، گوروتین تولیدکننده تا زمان آزاد شدن بافر مسدود می‌ماند. این یک روش ساده و کارآمد برای جلوگیری از overload شدن سیستم در شرایط پرترافیک است. مدیریت گزارش‌ها (Asynchronous Logging): استفاده از یک کانال به‌عنوان صف برای ثبت گزارش‌ها (logs) باعث می‌شود عملیات نوشتن گزارش (که ممکن است کند باشد) گوروتین‌های دیگر را متوقف نکند. گوروتینی که مسئول نوشتن گزارش است پیام‌ها را به ترتیب از کانال دریافت می‌کند و در فایل یا خروجی شبکه ذخیره می‌کند، بدون اینکه نیاز به قفل یا ساختار همزمانی پیچیده داشته باشد. همزمانی امن بین گوروتین‌ها (Safe Inter-Goroutine Communication): کانال‌ها راهی امن و idiomatic برای تبادل داده بین گوروتین‌ها هستند. استفاده از آن‌ها به‌عنوان صف، امکان پیاده‌سازی سیستم‌هایی مانند pipeline processing، fan-in/fan-out یا load balancing را به سادگی فراهم می‌کند، بدون نیاز به primitives سطح پایین‌تر مثل mutex یا condition variable. "},{"id":220,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-ratelimit/","title":"9.4.16 الگو Rate limit","section":"9.4 الگوهای همزمانی","content":" 9.4.16.1 توضیحات # الگوی Rate Limiting یا \u0026ldquo;محدودسازی نرخ درخواست\u0026rdquo; یکی از الگوهای پرکاربرد برای کنترل ترافیک ورودی یا پردازش عملیات در سیستم‌های نرم‌افزاری است. هدف اصلی این الگو، جلوگیری از اجرای بیش از حد عملیات در یک بازه‌ی زمانی مشخص است تا از بارگذاری بیش از حد سیستم، نقض محدودیت‌های منابع خارجی (مثل APIها)، یا سوءاستفاده از سرویس جلوگیری شود. این الگو در سرویس‌هایی که به منابع محدود یا خارجی متصل‌اند—مثل وب‌سرویس‌ها، میکروسرویس‌ها، API گیت‌وی‌ها یا سیستم‌های صف پردازش—به‌شدت حیاتی است.\nدر زبان Go، یکی از ساده‌ترین روش‌های پیاده‌سازی این الگو استفاده از time.Ticker است. این نوعی تایمر است که در فواصل زمانی منظم سیگنالی را از طریق کانال ارسال می‌کند. با قرار دادن منطق پردازش درون حلقه‌ای که روی این کانال می‌چرخد، می‌توان کاری کرد که اجرای هر عملیات فقط هنگام دریافت سیگنال مجاز باشد. مثلاً اگر یک ticker هر ۲۰۰ میلی‌ثانیه سیگنال بفرستد، در نتیجه فقط ۵ بار در ثانیه عملیات اجرا خواهد شد. به این ترتیب نرخ اجرا به شکل دقیق و منظم کنترل می‌شود.\nمزیت این روش در سادگی و کارآمدی آن است، به‌خصوص برای سناریوهای سبک تا متوسط. اما در شرایط پیچیده‌تر، ممکن است نیاز به الگوهای پیشرفته‌تری مانند Token Bucket یا Leaky Bucket باشد که انعطاف‌پذیری بیشتری برای burstهای ناگهانی، اولویت‌بندی یا بازتوزیع ظرفیت فراهم می‌کنند. همچنین در سیستم‌های توزیع‌شده، برای اعمال محدودیت به صورت مرکزی یا سراسری (distributed rate limiting)، باید از ابزارهایی مثل Redis، Nginx، یا سرویس‌های ابری (مثل Cloudflare یا AWS API Gateway) استفاده کرد.\nدر نهایت، الگوی Rate Limiting به عنوان یک تکنیک دفاعی و پایدارسازی سیستم، باید بخشی جدانشدنی از معماری‌ سیستم‌های تولیدی باشد—چه در قالب محدودسازی ساده در سطح goroutineها، و چه به‌صورت سیاست‌های سازمان‌یافته در کل سیستم.\n9.4.16.2 دیاگرام # graph TD subgraph Client A[ارسال درخواست] end subgraph Rate Limiter Ticker B[دریافت تیک از time.Ticker] C{آیا درخواست جدیدی هست؟} end subgraph Worker D[پردازش درخواست] end A --\u003e|درخواست به صف| C B --\u003e C C --\u003e|بله| D C --\u003e|خیر| B D --\u003e B 9.4.16.3 نمونه کد # package main import ( \"fmt\" \"time\" ) func processRequest(id int) { fmt.Printf(\"✅ Processed request %d at %s\\n\", id, time.Now().Format(\"15:04:05\")) } func main() { const maxRequests = 10 const rateLimit = time.Second // یک درخواست در هر ثانیه ticker := time.NewTicker(rateLimit) defer ticker.Stop() requests := make(chan int) // Producer: ارسال درخواست‌ها با فاصله زمانی (مثلاً هر 300ms) go func() { for i := 1; i \u003c= maxRequests; i++ { requests \u003c- i time.Sleep(300 * time.Millisecond) // simulate incoming traffic } close(requests) }() // Consumer با Rate Limiting for req := range requests { \u003c-ticker.C // اجازه پردازش فقط هر یک ثانیه یکبار processRequest(req) } } ▶ اجرای کد کپی ✖ بستن خروجی در این مثال، پیاده‌سازی ساده‌ای از الگوی Rate Limiting در زبان Go با استفاده از time.Ticker نمایش داده شده است. هدف این کد آن است که اجازه دهد درخواست‌ها (در اینجا اعداد ۱ تا ۱۰) تنها با نرخ یک درخواست در هر ثانیه پردازش شوند. این کار برای جلوگیری از فشار زیاد بر روی سیستم یا رعایت محدودیت‌های خارجی بسیار رایج است.\nابتدا یک ticker با بازه‌ی زمانی یک ثانیه ساخته می‌شود. این ticker در هر ثانیه یک سیگنال روی کانال C خودش ارسال می‌کند. در همین حال، یک goroutine به عنوان تولیدکننده (Producer) تعریف شده که اعداد ۱ تا ۱۰ را بدون تأخیر وارد یک کانال requests می‌کند و سپس آن را می‌بندد. این کانال مانند یک صف عمل می‌کند.\nدر بخش مصرف‌کننده (Consumer)، که در main اجرا می‌شود، یک حلقه از روی requests می‌چرخد. قبل از پردازش هر درخواست، برنامه منتظر سیگنال از ticker.C می‌ماند. به این معنی که هر درخواست دقیقاً با فاصله‌ی زمانی یک ثانیه پردازش می‌شود. این مکانیزم باعث می‌شود اگر درخواست‌ها خیلی سریع وارد صف شوند، باز هم فقط با سرعت مجاز (در این مثال ۱ بر ثانیه) اجرا شوند.\nدر نهایت، تابع processRequest تنها مسئول چاپ شماره‌ی درخواست همراه با زمان اجرای آن است. این پیاده‌سازی اگرچه ساده است، اما پایه‌ای بسیار مناسب برای توسعه‌ی نسخه‌های پیشرفته‌تر مانند کنترل burst، توقف سریع با context، یا پیاده‌سازی توزیع‌شده فراهم می‌کند.\n9.4.16.4 کاربردها # Throttling API Calls: در زمانی که شما نیاز دارید درخواست‌های API را محدود کنید تا از محدودیت‌های تعیین‌شده توسط ارائه‌دهنده API تجاوز نکنید. کنترل بار سیستم: برای جلوگیری از استفاده بیش از حد از منابع سیستم، مانند پردازنده یا پایگاه داده. پردازش داده‌های ورودی: زمانی که داده‌های ورودی بسیار سریع‌تر از ظرفیت پردازش وارد می‌شوند، این الگو می‌تواند سرعت پردازش را مدیریت کند. زمان‌بندی رویدادها: برای انجام عملیات در فواصل زمانی معین مانند ارسال ایمیل‌های گروهی. "},{"id":221,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-deadlock-recovery/","title":"9.4.17 الگو Deadlock Recovery","section":"9.4 الگوهای همزمانی","content":" 9.4.17.1 توضیحات # الگوی بازیابی از بن‌بست (Deadlock Recovery) یکی از الگوهای مهم در طراحی سیستم‌های همزمان (concurrent systems) است که به ما کمک می‌کند از شرایطی خطرناک به نام بن‌بست (deadlock) خارج شویم. در شرایط بن‌بست، دو یا چند گوروتین (یا نخ) در حالتی گیر می‌افتند که هر یک منتظر آزاد شدن منبعی است که توسط دیگری نگه داشته شده؛ در نتیجه هیچ‌کدام نمی‌توانند پیش بروند و کل سیستم در حالت توقف (freeze) باقی می‌ماند.\nدر زبان Go، به دلیل استفاده گسترده از goroutine و channel، احتمال وقوع بن‌بست در اثر طراحی نادرست بالا است. مثلاً اگر گوروتینی منتظر داده روی یک کانال بماند، در حالی که گوروتین ارسال‌کننده هرگز اجرا نشود یا مسدود شده باشد، بن‌بست اتفاق می‌افتد. در سیستم‌های واقعی، تشخیص و بازیابی از این وضعیت حیاتی است تا سیستم به‌صورت پیوسته و قابل اطمینان باقی بماند.\nالگوی Deadlock Recovery معمولاً شامل سه مرحله است: ۱. نظارت (Monitoring): سیستم باید به‌صورت مداوم وضعیت گوروتین‌ها یا منابع مشترک را بررسی کند. این کار می‌تواند با استفاده از تایم‌اوت، لاگ‌گیری، یا ابزارهای profiler مانند pprof انجام شود. ۲. تشخیص (Detection): با تجزیه‌وتحلیل رفتار سیستم، مانند گوروتین‌هایی که برای مدت طولانی در حالت مسدود باقی مانده‌اند، می‌توان بن‌بست‌های احتمالی را شناسایی کرد. ۳. بازیابی (Recovery): پس از تشخیص، می‌توان با یکی از روش‌های زیر اقدام به آزادسازی سیستم کرد:\nتلاش مجدد با backoff (بازگشت نمایی یا تصادفی) بازتنظیم منابع یا صف‌ها خاتمه دادن به گوروتین‌های مسدودشده بازگردانی سیستم به حالت اولیه یا fail-safe این الگو به‌ویژه در برنامه‌های distributed یا دارای state حساس مانند تراکنش‌های مالی، سیستم‌های صف (queue-based systems)، یا پایگاه‌داده‌های درون‌حافظه‌ای اهمیت دارد. اجرای صحیح این الگو باعث حفظ پایداری سیستم در برابر شرایط غیرمنتظره می‌شود، در حالی که غفلت از آن ممکن است به اختلال جدی یا از دست رفتن داده‌ها منجر شود.\n9.4.17.2 دیاگرام # sequenceDiagram participant Main participant G1 as Goroutine 1 participant G2 as Goroutine 2 participant DeadlockChecker as Select with Timeout Main-\u003e\u003eG1: Start Main-\u003e\u003eG2: Start G1-\u003e\u003emu1: Lock(mu1) G2-\u003e\u003emu2: Lock(mu2) G1-\u003e\u003emu2: Try Lock(mu2) ❌ G2-\u003e\u003emu1: Try Lock(mu1) ❌ Note over G1,G2: بن‌بست (Deadlock) ایجاد شد: G1 منتظر mu2، G2 منتظر mu1 DeadlockChecker-\u003e\u003eDeadlockChecker: wait 3s... DeadlockChecker--\u003e\u003eMain: بن‌بست شناسایی شد ✅ 9.4.17.3 نمونه کد # package main import ( \"fmt\" \"sync\" \"time\" ) func deadlockRecoveryExample() { var mu1, mu2 sync.Mutex done := make(chan string, 2) // گوروتین اول: تلاش برای گرفتن mu1 سپس mu2 go func() { mu1.Lock() fmt.Println(\"G1: mu1 locked\") time.Sleep(1 * time.Second) mu2.Lock() fmt.Println(\"G1: mu2 locked\") time.Sleep(500 * time.Millisecond) mu2.Unlock() mu1.Unlock() done \u003c- \"G1: done\" }() // گوروتین دوم: تلاش برای گرفتن mu2 سپس mu1 go func() { mu2.Lock() fmt.Println(\"G2: mu2 locked\") time.Sleep(1 * time.Second) mu1.Lock() fmt.Println(\"G2: mu1 locked\") time.Sleep(500 * time.Millisecond) mu1.Unlock() mu2.Unlock() done \u003c- \"G2: done\" }() // انتظار برای پیام از گوروتین‌ها یا تشخیص بن‌بست select { case msg := \u003c-done: fmt.Println(\"✅ موفقیت:\", msg) case \u003c-time.After(3 * time.Second): fmt.Println(\"❌ بن‌بست شناسایی شد: یکی از گوروتین‌ها قفل شده است\") } } func main() { deadlockRecoveryExample() } ▶ اجرای کد کپی ✖ بستن خروجی در این مثال، یک سناریوی کلاسیک از بن‌بست (Deadlock) در زبان Go شبیه‌سازی شده و با استفاده از مکانیزم select و time.After، وقوع آن تشخیص داده می‌شود. هدف این کد، نشان دادن چگونگی رخ دادن بن‌بست بین دو goroutine است که هر کدام سعی می‌کنند منابع مشترکی را قفل کنند، اما به دلیل ترتیب متفاوت در قفل‌گیری، در حالت انتظار دائمی قرار می‌گیرند.\nدر ابتدا، دو شیء قفل mu1 و mu2 از نوع sync.Mutex تعریف می‌شود. سپس دو goroutine راه‌اندازی می‌شوند. گوروتین اول (G1) ابتدا mu1 را قفل کرده و پس از کمی توقف، سعی می‌کند mu2 را نیز قفل کند. در مقابل، گوروتین دوم (G2) ابتدا mu2 را قفل کرده و پس از کمی توقف، سعی در قفل کردن mu1 دارد. به این ترتیب، هر کدام منتظر آزاد شدن قفلی هستند که در دست دیگری است و هیچ‌کدام نمی‌توانند ادامه دهند، در نتیجه بن‌بست واقعی رخ می‌دهد.\nدر بخش main، یک select برای خواندن پیام از کانال done تعریف شده که انتظار دارد یکی از goroutineها پس از انجام کار، پیامی ارسال کند. اما چون هر دو گوروتین در وضعیت قفل گیر افتاده‌اند و هیچ‌کدام به پایان نمی‌رسند، کانال done خالی می‌ماند. در نتیجه پس از ۳ ثانیه، بخش select وارد مسیر time.After می‌شود و پیام \u0026ldquo;بن‌بست شناسایی شد\u0026rdquo; چاپ می‌گردد.\nاین پیاده‌سازی ساده ولی گویا، نحوه وقوع بن‌بست، اهمیت ترتیب قفل‌گیری منابع، و روش تشخیص آن از طریق time-based watchdog را نشان می‌دهد. چنین مکانیزمی در سیستم‌های حساس به همزمانی بسیار ضروری است، چون بن‌بست می‌تواند کل سیستم را متوقف و ناپایدار کند. برای پیشگیری، طراحی قفل‌گیری منظم، استفاده از تایم‌اوت، context، و حتی الگوریتم‌هایی مانند TryLock یا timeout-based locking توصیه می‌شود.\n9.4.17.4 کاربردها # مدیریت منابع در برنامه‌های همزمان (Concurrent Resource Management): در سیستم‌هایی که گوروتین‌ها یا نخ‌ها به منابع مشترکی مانند فایل‌ها، حافظه، یا کانکشن‌های شبکه دسترسی دارند، استفاده از این الگو برای جلوگیری یا بازیابی از بن‌بست هنگام قفل‌گذاری (locking) منابع حیاتی است. با استفاده از تشخیص زمان‌محور، تلاش مجدد یا اولویت‌بندی دسترسی می‌توان از توقف کامل سیستم جلوگیری کرد. پایگاه‌داده‌های توزیع‌شده و سیستم‌های تراکنشی (Distributed Databases \u0026amp; Transactions): در محیط‌های توزیع‌شده مانند دیتابیس‌های چندگره‌ای یا سیستم‌های ACID، تراکنش‌هایی که منتظر منابع قفل‌شده توسط سایر تراکنش‌ها هستند، ممکن است در حالت بن‌بست باقی بمانند. این الگو با تشخیص بن‌بست‌ها و اعمال سیاست‌هایی مانند abort و retry یا rollback، پایداری و در دسترس بودن سیستم را تضمین می‌کند. سیستم‌های بلادرنگ و حساس به زمان (Real-Time Systems): در سیستم‌های بلادرنگ (مانند سامانه‌های کنترل صنعتی یا رباتیک)، حتی تأخیر جزئی می‌تواند بحرانی باشد. استفاده از الگوی بازیابی از بن‌بست باعث می‌شود سیستم بتواند به‌جای توقف کامل، در زمان محدود وضعیت را تشخیص داده و به روش fail-safe ادامه دهد. اشکال‌زدایی و تحلیل همزمانی (Concurrency Debugging \u0026amp; Analysis): این الگو به توسعه‌دهندگان کمک می‌کند تا طراحی همزمانی برنامه را زیر نظر بگیرند و نقاطی که امکان وقوع بن‌بست دارند را شناسایی کنند. با ابزارهایی مثل pprof, trace و تحلیل کانال‌ها می‌توان مسیرهای اجرای بن‌بست‌زا را شناسایی و بازطراحی کرد. "},{"id":222,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-channel-cancellation/","title":"9.4.18 الگو Channel Cancellation","section":"9.4 الگوهای همزمانی","content":" 9.4.18.1 توضیحات # الگوی Channel Cancellation یا «لغو با کانال» یکی از الگوهای کلیدی در طراحی برنامه‌های همزمان (concurrent) در زبان Go است. این الگو زمانی استفاده می‌شود که نیاز باشد یک یا چند گوروتین را به‌صورت هماهنگ و ایمن متوقف کنیم، به‌ویژه در شرایطی که ادامه اجرای آن‌ها بی‌فایده یا مضر است (مثلاً خطا رخ داده، زمان‌سنج تمام شده یا برنامه در حال خاتمه است). این الگو برخلاف استفاده از context.Context (که در Go برای لغو استاندارد توصیه می‌شود)، از یک channel اختصاصی برای ارسال سیگنال لغو استفاده می‌کند.\nدر این الگو، یک کانال معمولاً از نوع chan struct{} (یا chan bool) تعریف می‌شود که فقط یک بار مقدار می‌گیرد و بعد از آن، تمام گوروتین‌هایی که روی آن منتظر هستند متوجه لغو می‌شوند. گوروتین‌های مصرف‌کننده با استفاده از select بررسی می‌کنند که آیا سیگنال لغو دریافت شده یا نه، و در صورت دریافت آن، بلافاصله متوقف می‌شوند. به این ترتیب، سیستم بدون استفاده از متغیرهای مشترک یا قفل (mutex) می‌تواند گوروتین‌های متعدد را متوقف کند.\nمزیت اصلی Channel Cancellation در سادگی و سازگاری بالا با سایر کانال‌ها و ساختارهای Go است. این الگو به راحتی در ترکیب با select در کنار کانال‌های داده به کار می‌رود، به طوری که هر گوروتین همزمان می‌تواند منتظر داده یا سیگنال لغو باشد. این الگو همچنین مناسب سیستم‌هایی است که به سبک event-driven طراحی شده‌اند یا نیاز دارند از عملیات طولانی یا مسدودکننده (blocking) خارج شوند.\nدر نهایت، گرچه امروزه استفاده از context.Context در اغلب موقعیت‌های لغو توصیه می‌شود، الگوی Channel Cancellation همچنان بسیار مفید، سبک و قابل فهم است—مخصوصاً در کدهایی که ساده‌تر یا فاقد نیاز به توابع context-aware هستند. این الگو پایه‌ای برای پیاده‌سازی shutdown graceful، stop کردن workerها، لغو عملیات IO و کنترل حلقه‌های طولانی‌مدت در برنامه‌های Go محسوب می‌شود.\n9.4.18.2 دیاگرام # sequenceDiagram participant Main participant Worker1 participant Worker2 participant CancelChan as Cancel Channel Main-\u003e\u003eWorker1: start with cancel channel Main-\u003e\u003eWorker2: start with cancel channel Note over Worker1,Worker2: کار ادامه دارد... Main--\u003e\u003eCancelChan: close(cancel) Worker1--\u003e\u003eCancelChan: \u003c- cancel Worker2--\u003e\u003eCancelChan: \u003c- cancel Worker1-\u003e\u003eMain: stopped gracefully Worker2-\u003e\u003eMain: stopped gracefully 9.4.18.3 نمونه کد # package main import ( \"fmt\" \"time\" ) // تابعی که تا زمان دریافت سیگنال لغو کار می‌کند func worker(id int, cancel \u003c-chan struct{}) { for { select { case \u003c-cancel: fmt.Printf(\"⛔️ Worker %d متوقف شد\\n\", id) return default: fmt.Printf(\"⚙️ Worker %d در حال کار...\\n\", id) time.Sleep(500 * time.Millisecond) } } } func main() { cancel := make(chan struct{}) // کانال لغو مشترک // اجرای چند گوروتین worker for i := 1; i \u003c= 3; i++ { go worker(i, cancel) } // اجرای اصلی تا ۲ ثانیه صبر می‌کند time.Sleep(2 * time.Second) // ارسال سیگنال لغو با بستن کانال fmt.Println(\"📢 ارسال سیگنال لغو به همه گوروتین‌ها...\") close(cancel) // صبر برای پایان اجرای گوروتین‌ها time.Sleep(1 * time.Second) fmt.Println(\"🏁 پایان برنامه\") } ▶ اجرای کد کپی ✖ بستن خروجی در این مثال، الگوی Channel Cancellation برای متوقف کردن همزمان چند گوروتین به کار گرفته شده است. هدف این الگو آن است که بدون نیاز به متغیرهای اشتراکی یا قفل (mutex)، چند گوروتین را به‌صورت هماهنگ و ایمن متوقف کنیم، آن‌هم با استفاده از یک کانال ساده که نقش سیگنال لغو (cancel signal) را ایفا می‌کند.\nدر ابتدای برنامه، یک کانال از نوع chan struct{} به نام cancel تعریف می‌شود. این کانال هیچ داده‌ای حمل نمی‌کند و فقط نقش «علامت توقف» دارد. سپس با استفاده از یک حلقه، سه گوروتین worker راه‌اندازی می‌شوند که همگی به این کانال دسترسی دارند. هر گوروتین درون یک حلقه بی‌نهایت اجرا می‌شود و درون select بررسی می‌کند که آیا سیگنال لغو از کانال دریافت شده یا نه. اگر سیگنال لغو دریافت شود (\u0026lt;-cancel)، گوروتین با چاپ یک پیام متوقف می‌شود. در غیر این صورت، کار شبیه‌سازی‌شده‌ای انجام می‌دهد و سپس کمی می‌خوابد.\nدر تابع main، برنامه به مدت ۲ ثانیه منتظر می‌ماند تا گوروتین‌ها چند بار پیام «در حال کار» چاپ کنند. سپس کانال cancel را می‌بندد (close(cancel)) که این عمل به عنوان سیگنال توقف برای تمام گوروتین‌ها عمل می‌کند. در نتیجه، هر گوروتینی که در حالت انتظار روی آن کانال بوده، فعال می‌شود و مسیر لغو را طی می‌کند. پس از آن، main کمی صبر می‌کند تا همه گوروتین‌ها فرصت چاپ پیام «⛔️ متوقف شد» را پیدا کنند.\nاین مثال ساده اما مؤثر نشان می‌دهد که چگونه می‌توان با استفاده از یک کانال مشترک، گوروتین‌های متعدد را به‌صورت هماهنگ متوقف کرد، بدون نیاز به اشتراک‌گذاری متغیر یا وضعیت پیچیده. این الگو در سناریوهای واقعی مانند متوقف‌سازی graceful در سرورها، لغو همزمان چند worker، یا واکنش به خطاهای بحرانی بسیار مفید و پراستفاده است.\n9.4.18.4 کاربردها # خاموش‌سازی گوروتین‌ها: برای متوقف کردن چند گوروتین به‌صورت هماهنگ هنگام اتمام کار یا دریافت سیگنال خروج. مدیریت worker pool: برای لغو همه‌ی workerها در صورت خطای بحرانی یا پایان پردازش. جلوگیری از نشت گوروتین (goroutine leak): برای پایان دادن به گوروتین‌هایی که دیگر نیازی به ادامه کار آن‌ها نیست. کنترل زمان اجرا: برای قطع عملیات‌های طولانی یا مسدود شده پس از یک مدت مشخص. پیاده‌سازی graceful shutdown: برای پایان ایمن و منظم سرویس هنگام خاموش شدن یا دریافت سیگنال SIGINT. "},{"id":223,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-lock-free-synchronization/","title":"9.4.19 الگو Lock-free synchronization","section":"9.4 الگوهای همزمانی","content":" 9.4.19.1 توضیحات # همگام‌سازی بدون قفل (lock-free synchronization) به مجموعه‌ای از تکنیک‌ها و الگوهای برنامه‌نویسی گفته می‌شود که به چندین thread یا goroutine اجازه می‌دهد به طور همزمان و ایمن به داده‌های مشترک دسترسی پیدا کنند، بدون اینکه از primitiveهایی مثل Mutex یا قفل‌های سنتی استفاده شود. هدف اصلی این الگوها افزایش بازدهی (throughput)، کاهش زمان انتظار (latency) و جلوگیری از مشکلات رایج قفل‌گذاری (مثل deadlock، priority inversion و contention) است. الگوریتم‌های lock-free تضمین می‌کنند که حتی اگر برخی از threadها متوقف شوند یا دچار کندی شوند، باقی سیستم همچنان قادر به پیشرفت خواهد بود (progress guarantee).\n9.4.19.1.1 مکانیزم پایه: عملیات اتمیک و Compare-And-Swap (CAS) # قلب تمام الگوریتم‌های lock-free، عملیات اتمیک (atomic operations) است، که توسط سخت‌افزار CPU و در Go توسط پکیج sync/atomic فراهم می‌شود. مهم‌ترین عملیات اتمیک، Compare-And-Swap (CAS) است؛ در این متد، برنامه مقدار فعلی متغیر را با مقدار مورد انتظار مقایسه می‌کند و در صورت برابری، مقدار جدید را جایگزین می‌کند—همه این مراحل به صورت اتمیک انجام می‌شوند. اگر مقدار تغییر نکرده باشد، عملیات موفق است وگرنه دوباره تلاش می‌شود (این رفتار اصطلاحاً به optimistic concurrency مشهور است).\nمثال پایه‌ای از CAS در Go:\nimport \u0026quot;sync/atomic\u0026quot; var counter int64 atomic.AddInt64(\u0026amp;counter, 1) // جمع اتمیک بدون قفل یا:\nif atomic.CompareAndSwapInt32(\u0026amp;x, old, new) { // موفقیت در تعویض مقدار، ادامه بده } 9.4.19.1.2 الگوهای رایج Lock-Free # Lock-Free Counter: پیاده‌سازی شمارنده‌های افزایشی/کاهشی (مثل تعداد درخواست، session فعال و \u0026hellip;) با متدهایی مانند atomic.AddInt64 و atomic.LoadInt64 بدون هیچ قفل یا wait. Lock-Free Stack/Queue: ساختارهایی مانند stack و queue را می‌توان با ترکیب pointer اتمیک و حلقه‌ی CAS پیاده‌سازی کرد؛ هر عملیاتی که نیاز به افزودن/حذف دارد، تا زمانی که مقدار قبلی با مقدار مورد انتظار برابر باشد، مقدار جدید را جایگزین می‌کند. اگر مقدار تغییر کرده باشد (به دلیل دخالت thread دیگر)، عمل دوباره تکرار می‌شود. Flagها و وضعیت‌های اتمیک: استفاده از فلگ‌ها برای signaling یا مدیریت وضعیت‌های بین چند goroutine (مثلاً active/inactive)، بدون race condition و با سرعت بسیار بالا. Reference Swap (atomic.Value): تعویض اتمیک مراجع به object یا ساختار داده کامل (مثلاً عوض کردن reference یک cache در حافظه) با atomic.Value، که خواندن و نوشتن کامل آن اتمیک است. 9.4.19.1.3 مزایا و محدودیت‌ها # مزایا:\nعملکرد بسیار بالا مخصوصاً در سناریوهای multi-core و تعداد بالای thread/goroutine بدون deadlock و starvation: تضمین می‌کند که سیستم به خاطر انتظار برای قفل، هرگز متوقف نمی‌شود مقیاس‌پذیری عالی برای داده‌های ساده و الگوریتم‌های سبک محدودیت‌ها:\nپیچیدگی کدنویسی و تحلیل: الگوریتم‌های lock-free نوشتن و تست سخت‌تری دارند و به دانش عمیق رفتار CPU و حافظه نیاز دارند. مناسب فقط برای داده‌های primitive یا تغییرات ساده: برای داده‌های پیچیده یا ساختارهای بزرگ، مدیریت اتمیک بسیار دشوار و گاهاً غیرممکن است. سازگاری معماری: روی همه CPUها و پلتفرم‌ها باید از لحاظ alignment و atomicity اطمینان حاصل کنید (در Go این موضوع مستند شده اما باید رعایت شود). 9.4.19.2 دیاگرام # flowchart TD subgraph SharedMemory[Shared Variable مثلاً counter] V[Value: X] end G1[Goroutine 1] -- CAS (Compare and Swap) --\u003e V G2[Goroutine 2] -- CAS --\u003e V G3[Goroutine 3] -- CAS --\u003e V V -- \"Success: update committed\" --\u003e Done1[Continue] V -- \"Fail: value changed,\\nretry CAS\" --\u003e G1 V -- \"Fail: value changed,\\nretry CAS\" --\u003e G2 V -- \"Fail: value changed,\\nretry CAS\" --\u003e G3 style SharedMemory fill:#e2f0fc,stroke:#377dbf,stroke-width:2px style G1,G2,G3 fill:#fffbe7,stroke:#eac442,stroke-width:2px style Done1 fill:#d3f5e4,stroke:#11b584,stroke-width:2px 9.4.19.3 نمونه کد # package main import ( \"fmt\" \"sync\" \"sync/atomic\" ) func main() { var counter int64 var wg sync.WaitGroup numGoroutines := 10 incrementsPerGoroutine := 1000 wg.Add(numGoroutines) for i := 0; i \u003c numGoroutines; i++ { go func() { defer wg.Done() for j := 0; j \u003c incrementsPerGoroutine; j++ { atomic.AddInt64(\u0026counter, 1) // افزایش اتمیک بدون قفل } }() } wg.Wait() fmt.Println(\"Final counter value:\", counter) } ▶ اجرای کد کپی ✖ بستن خروجی در این مثال یک شمارنده lock-free (بدون قفل) با استفاده از پکیج sync/atomic در زبان Go پیاده‌سازی شده است. هدف این است که چندین goroutine بتوانند همزمان و بدون نیاز به Mutex یا قفل سنتی، یک متغیر مشترک را افزایش دهند و در نهایت مقدار دقیق، بدون race condition و کاملاً صحیح به دست آید.\nدر ابتدای برنامه یک متغیر از نوع int64 به نام counter تعریف می‌شود که قرار است توسط goroutineها به طور مشترک افزایش یابد. یک sync.WaitGroup نیز به کار گرفته شده تا اطمینان حاصل شود همه goroutineها تا پایان اجرای خود منتظر بمانند و برنامه قبل از تکمیل همه عملیات‌ها خاتمه پیدا نکند.\nدر حلقه اصلی، ۱۰ goroutine ایجاد می‌شود که هر کدام ۱۰۰۰ بار مقدار شمارنده را افزایش می‌دهند. برای این کار به جای استفاده از قفل، از تابع atomic.AddInt64 استفاده می‌شود. این تابع تضمین می‌کند که عملیات افزایش مقدار شمارنده کاملاً اتمیک است؛ یعنی در هر لحظه فقط یک goroutine می‌تواند مقدار متغیر را تغییر دهد و هیچ دو goroutineی به طور همزمان مقدار ناسازگار یا نادرست دریافت نمی‌کنند.\nدر پایان برنامه با استفاده از wg.Wait() اطمینان حاصل می‌شود که همه goroutineها کار خود را به پایان رسانده‌اند، سپس مقدار نهایی شمارنده چاپ می‌شود. با توجه به تعداد goroutineها و تعداد دفعات افزایش، انتظار داریم مقدار نهایی برابر با ۱۰,۰۰۰ باشد که نشان‌دهنده عملکرد صحیح و بدون خطا (race) الگوریتم است.\nاین مثال یکی از ساده‌ترین و کاربردی‌ترین نمونه‌های lock-free synchronization است که می‌تواند در شمارنده‌های آماری، جمع‌آوری لاگ، فلگ‌های اشتراکی و سناریوهای نیازمند سرعت بالا و رقابت زیاد به کار رود—بدون نگرانی از deadlock، overhead قفل یا کاهش performance.\n9.4.19.4 کاربردها # شمارنده‌های آماری با بازده بالا: ثبت تعداد درخواست‌های دریافتی سرور، تعداد پیام‌های ارسال یا دریافت‌شده، تعداد خطاها یا موفقیت‌ها، یا هر نوع شمارش سریع و موازی که نباید موجب گلوگاه (bottleneck) در performance شود. ثبت رخدادهای سریع (event counting): به‌طور مثال، شمارش لحظه‌ای کلیک‌ها یا رویدادهای کاربر در وب‌سرورهای real-time یا برنامه‌های مانیتورینگ. پیاده‌سازی flagهای همگام‌سازی: استفاده از متغیرهای اتمیک برای مدیریت وضعیت بین goroutineها (مثلاً علامت پایان، فعال/غیرفعال شدن یک job، آماده‌بودن یک سرویس، یا لغو شدن یک تسک). ساخت cache یا پیکربندی داینامیک: با استفاده از atomic.Value می‌توانید یک reference به ساختار داده یا تنظیمات (مثل map یا struct تنظیمات) را به صورت لحظه‌ای و اتمیک عوض کنید، بدون نیاز به قفل کردن کل داده برای خواندن و نوشتن. ساخت primitiveهای همگام‌سازی سفارشی: پیاده‌سازی الگوریتم‌هایی مانند spinlock، lock-free queue و stack، و semaphoreهای سبک که نیاز به performance بسیار بالا دارند و استفاده از Mutex می‌تواند گلوگاه ایجاد کند. مدیریت ساده state در concurrent logger یا metrics collector: در لایه‌های جمع‌آوری لاگ یا متریک که چندین goroutine همزمان روی یک متغیر می‌نویسند و می‌خوانند. "},{"id":224,"href":"/chapter-9/solid-principle-in-golang/","title":"9.7 اصول SOLID","section":"فصل نهم: الگوهای طراحی","content":"این مقاله ترجمه ارایه اصول solid در golang توسط Dave Cheneyمی‌‌باشد. در این مبحث به بررسی پیاده سازی solid در زبان Go می‌پردازیم.\nبررسی کد # چه کسی اینجا بررسی کد را به عنوان بخشی از کار خود انجام می‌دهد؟ تمام اتاق دستشان را بالا بردند که تشویق کننده بود. خوب، چرا بررسی کد انجام می‌دهید؟ کسی فریاد زد «برای جلوگیری از کد بد» اگر code review برای شناسایی کد‌های نامناسب است، پس چگونه می‌دانید کدی که بررسی می‌کنید خوب است یا بد؟ حالا خوب است بگوییم «آن کد نامناسب است» یا «آن کد منبع زیبا است»، درست مانند اینکه بگویید «این نقاشی زیبا است» یا «این اتاق زیبا است» اما اینها اصطلاحات ذهنی هستند و من به دنبال راه‌های عینی برای صحبت در مورد خواص کد خوب یا بد هستم. کد بد # برخی از ویژگی‌های کد بد که ممکن است در بررسی کد به آن پی ببرید کدامند؟ سفت و خشک یا در اصطلاح Rigid. آیا کد Rigid است؟ آیا دارای یک محافظ محدود کننده از انواع و پارامترهای غالب است که اصلاح آن را دشوار می‌کند؟ شکننده یا در اصطلاح Fragile. آیا کد Fragile است؟ آیا کوچکترین تغییر در کد باعث ایجاد ویرانی‌های فراوان می‌شود؟ بی‌حرکتی یا Immobile . آیا تغییر در ساختار کد سخت است؟ آیا اضافه کردن یک حلقه ساده در برنامه کار پیچیده‌ای است؟ پیچیده (Complex). آیا کدها به دلیل اینکه فقط کدی نوشته شده باشد بدون آن که به آن نیاز باشد، وجود دارد، آیا چیزها بیش از حد مهندسی (over-engineered) شده‌اند؟ شرح دادن بیش از حد یا Verbose. آیا استفاده و بررسی از کد خسته‌کننده است؟ وقتی به آن نگاه می‌کنید، می‌توانید بگویید این کد چه کاری می‌خواهد انجام دهد؟ آیا این کلمات مثبت هستند؟ آیا از شنیدن این کلمات در بررسی کد خود خوشحال خواهید شد؟ احتمالا نه. طراحی خوب # اما این یک بهبود دادن در سطح کد است، حالا می‌توانیم چیزهایی مثل «من این را دوست ندارم چون خیلی سخت است تغییرش داد» یا «من این را دوست ندارم چون نمی‌توانم بفهمم کد چه کاری می‌خواهد انجام دهد» بگوییم، اما چه می‌شود اگر با مثبت شروع کنیم؟\nآیا خوب نمی‌شد اگر راه‌هایی برای توصیف ویژگی‌های طراحی خوب وجود داشت، نه فقط طراحی بد و بتوانیم این کار را با اصطلاحات عینی انجام دهیم؟\nبررسی SOLID # در سال 2002 رابرت مارتین کتاب توسعه نرم‌افزار چابک، اصول، الگوها و روش‌ها را منتشر کرد. او پنج اصل طراحی نرم‌افزار قابل استفاده مجدد را توصیف کرد که اصول SOLID نامید، بر اساس حروف اول نام‌های آن‌ها. که شامل موارد زیر است:\nSingle Responsibility Principle Open / Closed Principle Liskov Substitution Principle Interface Segregation Principle Dependency Inversion Principle این کتاب کمی قدیمی است، زبان‌هایی که در مورد آن‌ها صحبت می‌کند، زبان‌هایی هستند که بیش از یک دهه پیش استفاده می‌شدند. اما، شاید جنبه‌هایی از اصول SOLID وجود داشته باشد که بتواند به ما سرنخی در مورد نحوه صحبت در مورد برنامه‌های Go با طراحی خوب بدهد.\nبنابراین می‌خواهم مدتی را صرف بحث در مورد این موضوع با شما کنم.\n9.7.1 اصل Single Responsibility # اولین اصل S در SOLID که اصل مسئولیت واحد است.\nیک کلاس باید یک و تنها یک دلیل برای تغییر داشته باشد.\nخب در زبان Go واضح است که چیزی به نام کلاس وجود ندارد - در عوض ما مفهوم بسیار قدرتمندتر composition را داریم - اما اگر بتوانید از استفاده از کلمه کلاس چشم‌پوشی کنید، فکر می‌کنم ارزش آن را دارد.\nچرا مهم است که یک قطعه کد فقط یک دلیل برای تغییر داشته باشد؟ خب، به اندازه اینکه ایده تغییر کد خودتان آزاردهنده است، کشف اینکه کدی که کد شما به آن وابسته است و مبنای آن تغییر می‌کند بسیار آزاردهنده‌تر است و وقتی کد شما باید تغییر کند، باید در پاسخ به یک محرک مستقیم این کار را انجام دهد، نباید قربانی آسیب‌های جانبی شود.\nبنابراین کدی که مسئولیت واحدی دارد، در نتیجه کمترین دلایل برای تغییر را دارد.\n9.7.1.1 بررسی Coupling و Cohesion # کوپلینگ و Cohesion دو کلمه‌ای که توصیف می‌کنند تغییر یک نرم‌افزار چقدر آسان یا سخت است، Coupling و Cohesion هستند.\nکوپلینگ به سادگی کلمه‌ای است که دو چیز را توصیف می‌کند که با هم تغییر می‌کنند - حرکت در یکی باعث حرکت در دیگری می‌شود.\nیک مفهوم مرتبط اما جداگانه، ایده Cohesion است، نیروی جذب متقابل.\nدر زمینه نرم‌افزار، Cohesion خاصیتی است که توصیف می‌کند قطعات کد به طور طبیعی به یکدیگر جذب می‌شوند.\nبرای توصیف واحدهای کوپلینگ و Cohesion در یک برنامه Go، ممکن است در مورد توابع و متدها صحبت کنیم، همانطور که در هنگام بحث در مورد SRP بسیار رایج است، اما من معتقدم که این کار با مدل packageهای Go شروع می‌شود.\n9.7.1.2 نام Package‌ها # در Go، تمام کدها داخل یک Package قرار دارند و یک Package خوب طراحی شده با نام آن شروع می‌شود. نام یک Package هم توصیفی از هدف آن است و هم پیشوند فضای نام. برخی از مثال‌های Package‌های خوب از کتابخانه‌ی استاندارد Go می‌توانند باشند:\n‏net/http که کلاینت‌ها و سرورهای http را فراهم می‌کند. ‏os/exec که دستورات خارجی را اجرا می‌کند. ‏encoding/json،که کدگذاری و رمزگشایی اسناد JSON را پیاده‌سازی می‌کند. وقتی شما از نمادهای Package دیگری در داخل Package خود استفاده می‌کنید، این کار با اعلامیه‌ی import انجام می‌شود که یک کوپلینگ سطح منبع بین دو Package ایجاد می‌کند. آن‌ها حالا یکدیگر را می‌شناسند.\n9.7.1.3 نام‌های بد Package # این تمرکز بر نام‌ها فقط موشکافی نیست. یک Package بدنام فرصت بررسی هدف خود را از دست می‌دهد، اگر اصلا هدفی داشته باشد.\nبسته‌ی server چه چیزی را فراهم می‌کند؟ \u0026hellip; خب، امیدوارم یک سرور، اما با کدام پروتکل؟ بسته‌ی private چه چیزی را فراهم می‌کند؟ چیزهایی که نباید ببینم؟ آیا باید نمادهای public داشته باشد؟ بسته‌ی common، درست مثل همکارش، بسته‌ی utils، اغلب در نزدیکی این متخلفان دیگر پیدا می‌شود. بسته‌های همه کاره‌ی مانند این به یک محل دفن زباله برای چیزهای مختلف تبدیل می‌شوند و چون مسئولیت‌های زیادی دارند، اغلب بدون دلیل تغییر می‌کنند.\n9.7.1.4 فلسفه‌ی یونیکس در Go # به نظر من، هیچ بحثی در مورد طراحی جدا شده بدون ذکر فلسفه‌ی یونیکس Doug McIlroy کامل نمی‌شود؛ ابزارهای کوچک و چابک که برای حل کارهای بزرگ‌تر ترکیب می‌شوند، اغلب کارهایی که توسط نویسندگان اصلی پیش‌بینی نشده بود.\nفکر می‌کنم بسته‌های Go روحیه‌ی فلسفه‌ی یونیکس را تجسم می‌بخشند. در واقع هر بسته‌ی Go خود یک برنامه‌ی کوچک Go است، یک اثرگذاری کوچک با یک مسئولیت واحد.\n9.7.1.5 مثال Single Responsibility # این اصل بیان می‌کند که یک ساختار باید تنها یک دلیل برای تغییر داشته باشد، به این معنی که یک ساختار باید تنها یک مسئولیت داشته باشد. این کمک می کند تا کد را تمیز و قابل نگهداری نگه دارید، زیرا تغییرات در ساختار فقط باید در یک مکان انجام شود.\nفرض کنید من یک کارمند ساختاری دارم که نام، حقوق و آدرس یک کارمند را پیگیری می‌کند:\ntype Employee struct { Name string Salary float64 Address string } طبق SRP، هر ساختار باید تنها یک مسئولیت داشته باشد، بنابراین در این مورد، بهتر است مسئولیت‌های ساختار Employee به دو ساختار جداگانه تقسیم شود: EmployeeInfo و EmployeeAddress.\ntype EmployeeInfo struct { Name string Salary float64 } type EmployeeAddress struct { Address string } اکنون می‌توانیم توابع جداگانه‌ای داشته باشیم که مسئولیت‌های مختلف هر ساختار را بر عهده دارد:\nfunc (e EmployeeInfo) GetSalary() float64 { return e.Salary } func (e EmployeeAddress) GetAddress() string { return e.Address } با پیروی از SRP، من کد را قابل نگهداری تر و درک آن آسان‌تر کرده‌ام، زیرا اکنون هر ساختار مسئولیت مشخص و مشخصی دارد. اگر بخواهم تغییراتی در محاسبه حقوق و دستمزد یا رسیدگی به آدرس ایجاد کنم، دقیقاً می‌دانم به کجا نگاه کنم، بدون اینکه نیازی به کدهای نامرتبط زیادی داشته باشم.\n9.7.2 اصل Open / Closed # اصل دوم، O، اصل بسته باز توسط برتراند مایر است که در سال 1988 نوشت:\nموجودیت‌های نرم‌افزار باید برای توسعه باز باشند، اما برای اصلاح بسته شوند.\n– برتراند مایر، ساخت نرم افزار شی گرا\nاین توصیه چگونه در مورد زبانی که 21 سال بعد نوشته شده است صدق می کند؟\npackage main type A struct { year int } func (a A) Greet() { fmt.Println(\"Hello GolangUK\", a.year) } type B struct { A } func (b B) Greet() { fmt.Println(\"Welcome to GolangUK\", b.year) } func main() { var a A a.year = 2016 var b B b.year = 2016 a.Greet() // Hello GolangUK 2016 b.Greet() // Welcome to GolangUK 2016 } ▶ اجرای کد کپی ✖ بستن خروجی ما یک type به نام A داریم با یک field به نام year و یک متد به نام Greet. یک type دوم به نام B داریم که A را در خود جای می‌دهد، بنابراین فراخواننده‌ها متدهای B را روی متدهای A می‌بینند زیرا A به عنوان یک field در داخل B جاسازی شده است و B می‌تواند متد Greet خود را ارائه دهد و آن را از A پنهان کند.\nاما جاسازی فقط برای متدها نیست، بلکه دسترسی به فیلدهای نوع جاسازی شده را نیز فراهم می‌کند. همانطور که می‌بینید، از آنجایی که هر دو A و B در یک package تعریف شده‌اند، B می‌تواند به فیلد خصوصی year در A دسترسی داشته باشد انگار که در داخل B تعریف شده است.\nبنابراین جاسازی (embedding) یک ابزار قدرتمند است که به تایپ‌های Go اجازه می‌دهد برای گسترش باز باشند.\npackage main type Cat struct { Name string } func (c Cat) Legs() int { return 4 } func (c Cat) PrintLegs() { fmt.Printf(\"I have %d legs\\n\", c.Legs()) } type OctoCat struct { Cat } func (o OctoCat) Legs() int { return 5 } func main() { var octo OctoCat fmt.Println(octo.Legs()) // 5 octo.PrintLegs() // I have 4 legs } ▶ اجرای کد کپی ✖ بستن خروجی در این مثال، ما یک type به نام Cat داریم که می‌تواند تعداد پاهای خود را با متد Legs بشمارد. ما این نوع Cat را در یک نوع جدید به نام OctoCat جاسازی می‌کنیم و اعلام می‌کنیم که Octocatها پنج پا دارند. با این حال، اگرچه OctoCat متد Legs خود را تعریف می‌کند که 5 برمی‌گرداند، اما وقتی متد PrintLegs فراخوانی می‌شود، 4 برمی‌گرداند.\nاین به این دلیل است که PrintLegs روی نوع Cat تعریف شده است. این متد یک Cat را به عنوان گیرنده خود می‌گیرد، بنابراین به متد Legs در Cat ارسال می‌شود. Cat هیچ اطلاعی از نوعی که در آن جاسازی شده است ندارد، بنابراین مجموعه متدهای آن نمی‌تواند با جاسازی تغییر کند.\nبنابراین می‌توانیم بگوییم که انواع Go در حالی که برای گسترش باز هستند، برای تغییر بسته هستند.\nدر واقع، متدها در Go چیزی بیشتر از نوعی syntax در اطراف یک تابع با یک پارامتر از پیش تعریف شده، گیرنده‌ی خود نیستند.\nfunc (c Cat) PrintLegs() { fmt.Printf(\u0026quot;I have %d legs\\n\u0026quot;, c.Legs()) } func PrintLegs(c Cat) { fmt.Printf(\u0026quot;I have %d legs\\n\u0026quot;, c.Legs()) } گیرنده یا receiver دقیقا همان چیزی است که به آن پاس می‌دهید، اولین پارامتر function است و از آنجا که Go از function overloading پشتیبانی نمی‌کند، در نتیجه OctoCatها جایگزین Cats معمولی نمی‌شوند. که من را به اصل بعدی در solid می‌رساند.\n9.7.2.1 مثال Open / Closed # فرض کنید من وظیفه دارم یک سیستم پرداخت بسازم که بتواند پرداخت‌های کارت اعتباری را پردازش کند. همچنین باید به‌اندازه کافی انعطاف‌پذیر باشد تا انواع روش‌های پرداخت را در آینده بپذیرد.\npackage main import \"fmt\" type PaymentMethod interface { Pay() } type Payment struct{} func (p Payment) Process(pm PaymentMethod) { pm.Pay() } type CreditCard struct { amount float64 } func (cc CreditCard) Pay() { fmt.Printf(\"Paid %.2f using CreditCard\", cc.amount) } func main() { p := Payment{} cc := CreditCard{12.23} p.Process(cc) } ▶ اجرای کد کپی ✖ بستن خروجی طبق OCP، ساختار پرداخت من برای توسعه باز و برای اصلاح بسته است. ازآنجایی‌که من از واسط PaymentMethod استفاده می‌کنم، مجبور نیستم رفتار پرداخت را هنگام افزودن روش‌های پرداخت جدید ویرایش کنم. اضافه‌کردن چیزی مانند PayPal به شکل زیر است:\ntype PayPal struct { amount float64 } func (pp PayPal) Pay() { fmt.Printf(\u0026quot;Paid %.2f using PayPal\u0026quot;, pp.amount) } // then in main() pp := PayPal{22.33} p.Process(pp) 9.7.3 اصل Liskov Substitution # این اصل توسط توسط باربارا لیسکوف معرفی شده است، اصل جایگزینی لیسکوف تقریباً بیان می‌کند که دو نوع قابل جایگزینی هستند اگر رفتارهایی را نشان دهند که فراخواننده نتواند تفاوت را تشخیص دهد.\nدر یک زبان مبتنی بر کلاس‌ها، اصل جایگزینی لیسکوف معمولاً به عنوان یک مشخصات برای یک abstract base class با زیرگونه‌های concrete class مختلف تفسیر می‌شود. اما Go کلاس یا وراثت ندارد، بنابراین جایگزینی نمی‌تواند از نظر سلسله مراتب abstract class پیاده‌سازی شود.\n9.7.3.1 بررسی Interface ها # در عوض، پایده سازی اصل جایگزینی (substitution) در این حوزه‌ بر عهده Interfaceها در Go است. در Go، از تایپ‌ها انتظار نمی‌رود که یک Interface خاصی را که پیاده‌سازی می‌کنند را از قبل معرفی کنند، در عوض هر تایپ یک Interface را پیاده‌سازی می‌کند به شرطی که متدهایی داشته باشد که امضای (signature) آن با اعلامیه اینترفیس (interface declaration) مطابقت داشته باشد.\nما می‌گوییم که در Go، رابط‌ها یا Interfaceها به طور ضمنی (implicitly) برآورده می‌شوند، نه صریح یا explicitly و این تأثیر عمیقی بر نحوه استفاده از آن‌ها در این زبان برنامه نویسی دارد.\nاینترفیس‌های طراحی شده خوب در بیشتر موارد احتمال دارد که اینترفیس‌های کوچکی باشند؛ ضرب‌المثل غالب این است که یک Interface فقط یک متد دارد. منطقی است که اینترفیس‌های کوچک منجر به پیاده‌سازی‌های ساده شوند، زیرا انجام خلاف آن دشوار است. که منجر به بسته‌هایی می‌شود که از پیاده‌سازی‌های ساده تشکیل شده‌اند و توسط رفتار مشترک به هم متصل شده‌اند.\n9.7.3.2 بررسی io.Reader # type Reader interface { // Read reads up to len(buf) bytes into buf. Read(buf []byte) (n int, err error) } در ادامه مبحث که من را به io.Reader می‌رساند، به راحتی مورد علاقه من در بین اینترفیس‌ها در Go است.\nاینترفیس io.Reader بسیار ساده است؛ Read داده‌ها را به بافر تأمین شده می‌خواند و تعداد بایت‌های خوانده شده و هر خطایی که در حین خواندن رخ داده است را به فراخواننده برمی‌گرداند. به نظر ساده می‌آید اما بسیار قدرتمند است.\nاز آنجایی که io.Reader با هر چیزی که بتوان آن را به عنوان یک stream از بایت‌ها بیان کرد سر و کار دارد، می‌توانیم خواننده‌ها را روی تقریباً هر چیزی ساختیم؛ یک رشته ثابت، یک آرایه بایت، ورودی استاندارد، یک جریان شبکه، یک فایل فشرده gzip، خروجی استاندارد یک فرمان که از طریق ssh به صورت remote اجرا می‌شود.\nو تمام این پیاده‌سازی‌ها برای یکدیگر قابل جایگزینی هستند زیرا قرارداد ساده یکسانی را برآورده می‌کنند.\nبنابراین اصل جایگزینی لیسکوف، اعمال شده بر روی Go، می‌تواند با این ضرب‌المثل زیبا از Jim Weirich خلاصه شود.\nRequire no more, promise no less.\n–Jim Weirich\nو این یک حرکت عالی در چهارمین اصل SOLID است.\n9.7.3.3 مثال Liskov Substitution # بیایید یک struct Animal را در نظر بگیریم:\ntype Animal struct { Name string } func (a Animal) MakeSound() { fmt.Println(\u0026quot;Animal sound\u0026quot;) } حال، فرض کنید می‌خواهیم یک ساختار جدید Bird بسازیم که نشان دهنده نوع خاصی از حیوانات است:\ntype Bird struct { Animal } func (b Bird) MakeSound() { fmt.Println(\u0026quot;Chirp chirp\u0026quot;) } این اصل بیان می‌کند که اشیاء یک superclass باید با اشیاء یک زیر کلاس بدون تأثیر بر صحت برنامه قابل‌تعویض باشند. این کمک می‌کند تا اطمینان حاصل شود که روابط بین کلاس ها به‌خوبی تعریف شده و قابل حفظ است.\ntype AnimalBehavior interface { MakeSound() } // MakeSound represent a program that works with animals and is expected // to work with base class (Animal) or any subclass (Bird in this case) func MakeSound(ab AnimalBehavior) { ab.MakeSound() } a := Animal{} b := Bird{} MakeSound(a) MakeSound(b) این وراثت در Go و همچنین اصل جایگزینی Liskov را نشان می‌دهد، زیرا اشیاء یک نوع فرعی Bird را می‌توان در هر جایی که اشیایی از نوع پایه Animal انتظار می‌رود استفاده کرد، بدون اینکه بر صحت برنامه تأثیر بگذارد.\n9.7.4 اصل Interface Segregation # چهارمین اصل، اصل جداسازی اینترفیس است که به شرح زیر است:\nکلاینت نباید مجبور شوند که به متدهایی که استفاده نمی‌کنند وابسته باشند.\n-رابرت سی مارتین\n// Save writes the contents of doc to the file f. func Save(f *os.File, doc *Document) error من می‌توانم این تابع را تعریف کنم، بیایید آن را Save بنامیم، که یک *os.File را به عنوان مقصد برای نوشتن Document می‌گیرد. اما این کار چند مشکل دارد.\nامضای یا signature مخصوص Save گزینه نوشتن داده‌ها به یک مکان شبکه‌ای را از بین می‌برد. با فرض اینکه ذخیره‌سازی شبکه احتمالاً بعداً به یک نیاز تبدیل می‌شود، امضای این تابع باید تغییر کند و روی تمام فراخواننده‌های آن تأثیر بگذارد.\nاز آنجایی که Save مستقیماً با فایل‌ها روی دیسک کار می‌کند، تست کردن آن ناخوشایند است. برای تأیید عملکرد آن، تست باید محتوای فایل را بعد از نوشتن بخواند. علاوه بر این، تست باید اطمینان حاصل کند که f به یک مکان موقت نوشته شده است و همیشه بعد از آن حذف می‌شود.\nهمچنین os.File متدهای زیادی را تعریف می‌کند که با Save مرتبط نیستند، مانند خواندن دایرکتوری‌ها و بررسی اینکه آیا یک مسیر یک symlink است. بسیار مفید خواهد بود اگر امضای تابع Save ما بتواند فقط قسمت‌های مرتبط os.File را توصیف کند.\nپس با این مشکلات چه کنیم؟\n// Save writes the contents of doc to the supplied Writer. func Save(w io.Writer, doc *Document) error یک راه حل بهتر این است که Save را دوباره تعریف کنیم تا فقط یک io.Writer بگیرد و مسئولیت انجام هر کاری غیر از نوشتن داده‌ها به یک جریان را کاملاً از آن بگیرد.\nبا اعمال اصل جداسازی interface بر روی تابع Save، نتیجه همزمان یک function است که از نظر نیازهای خود خاص‌ترین است و فقط به چیزی نیاز دارد که قابل نوشتن باشداکنون می‌توانیم از Save برای ذخیره داده‌های خود به هر چیزی که io.Writer را پیاده‌سازی می‌کند، استفاده کنیم.\nیک قانون بزرگ برای Go پذیرش interfaceها در structهای بازگشتی است. Jack Lindamood\n9.7.4.1 مثال Interface Segregation: # فرض کنید یک interface برای چاپگر اسناد داریم:\ngoCopy codetype Printer interface { Print() Scan() Fax() } اگر کلاینت فقط نیاز به چاپ اسناد دارد، نباید آنها را مجبور به پیاده سازی روش های اسکن و فکس کرد. در عوض، می‌توانیم این رابط را به interfaceهای کوچک‌تر و متمرکزتر تقسیم کنیم:\ntype Printer interface { Print() } type Scanner interface { Scan() } type FaxMachine interface { Fax() } 9.7.5 اصل Dependency Inversion # اصل SOLID نهایی، اصل وارونگی وابستگی است که بیان می‌کند:\nماژول های سطح بالا نباید به ماژول های سطح پایین وابسته باشند. هر دو باید به انتزاعات بستگی داشته باشند.\nانتزاع ها نباید به جزئیات بستگی داشته باشند. جزئیات باید به انتزاعات بستگی داشته باشد.\n-رابرت سی مارتین\nاما dependency inversion به طور عملی برای برنامه‌نویسان Go چه معنایی دارد؟\nاگر تمام اصول مورد بحث تا این نقطه را اعمال کرده‌اید، کد شما باید از قبل به packageهای مجزا فاکتور شده باشد، هر کدام با یک مسئولیت یا هدف مشخص و خوب تعریف شده است. کد شما باید وابستگی‌های خود را از نظر اینترفیس‌ها توصیف کند و آن اینترفیس‌ها باید برای توصیف تنها رفتار مورد نیاز آن توابع فاکتور شوند. به عبارت دیگر، کار زیادی برای انجام باقی نمی‌ماند.\nبنابراین فکر می‌کنم مارتین در اینجا در مورد ساختار گراف import کردن packageهای شما صحبت می‌کند که مطمئنا در زمینه Go است.\nدر Go باید import graph شما باید غیر دوره‌ای باشد. عدم رعایت این نیاز غیر دوره‌ای زمینه‌ای برای شکست کامپایل است، اما جدی‌تر نشان‌دهنده یک خطای جدی در طراحی است.\nهمه چیز برابر است، import graph یک برنامه‌ی Go به خوبی طراحی شده باید گسترده و نسبتاً مسطح باشد، نه بلند و باریک. اگر packageهای دارید که توابع آن بدون کمک گرفتن از packageهای‌ دیگری نمی‌توانند کار کنند، این احتمالاً نشانه‌ای است که کد به خوبی در امتداد مرزهای بسته فاکتور نشده است.\nاصل وارونگی وابستگی شما را تشویق می‌کند که مسئولیت جزئیات را تا حد امکان به بالای import graph به packageهای‌ اصلی یا هندلر سطح بالا، منتقل کنید و اجازه دهید کد سطح پایین با انتزاعات - اینترفیس‌‌ها (abstractions–interfaces) سروکار داشته باشد.\n9.7.5.1 مثال # فرض کنید یک struct Worker داریم که نماینده یک Worker در یک شرکت است و یک struct Supervisor که نماینده یک سرپرست یا Supervisor است: ‍‍\ntype Worker struct { ID int Name string } func (w Worker) GetID() int { return w.ID } func (w Worker) GetName() string { return w.Name } type Supervisor struct { ID int Name string } func (s Supervisor) GetID() int { return s.ID } func (s Supervisor) GetName() string { return s.Name } اکنون، برای این حالت ضد الگو، فرض کنید یک بخش ماژول سطح بالا داریم که نشان دهنده یک بخش در یک شرکت است و نیاز به ذخیره اطلاعات در مورد workerها و supervisorها دارد که ماژول‌های سطح پایین در نظر گرفته می‌شوند:\ntype Department struct { Workers []Worker Supervisors []Supervisor } طبق اصل وارونگی وابستگی، ماژول های سطح بالا نباید به ماژول های سطح پایین وابسته باشند. در عوض، هر دو باید به انتزاعات بستگی داشته باشند. برای اصلاح مثال ضد الگوی خود، می توانم یک Interface Employee ایجاد کنم که نماینده هر دو، workerها و supervisorها باشد:\ntype Employee interface { GetID() int GetName() string } اکنون می توانم ساختار Department را به روزرسانی کنم تا دیگر به ماژول‌های سطح پایین وابسته نباشد:\ntype Department struct { Employees []Employee } و حالت نهایی:\npackage main import \"fmt\" type Worker struct { ID int Name string } func (w Worker) GetID() int { return w.ID } func (w Worker) GetName() string { return w.Name } type Supervisor struct { ID int Name string } func (s Supervisor) GetID() int { return s.ID } func (s Supervisor) GetName() string { return s.Name } type Employee interface { GetID() int GetName() string } type Department struct { Employees []Employee } func (d *Department) AddEmployee(e Employee) { d.Employees = append(d.Employees, e) } func (d *Department) GetEmployeeNames() (res []string) { for _, e := range d.Employees { res = append(res, e.GetName()) } return } func (d *Department) GetEmployee(id int) Employee { for _, e := range d.Employees { if e.GetID() == id { return e } } return nil } func main() { dep := \u0026Department{} dep.AddEmployee(Worker{ID: 1, Name: \"John\"}) dep.AddEmployee(Supervisor{ID: 2, Name: \"Jane\"}) fmt.Println(dep.GetEmployeeNames()) e := dep.GetEmployee(1) switch v := e.(type) { case Worker: fmt.Printf(\"found worker %+v\\n\", v) case Supervisor: fmt.Printf(\"found supervisor %+v\\n\", v) default: fmt.Printf(\"could not find an employee by id: %d\\n\", 1) } } ▶ اجرای کد کپی ✖ بستن خروجی این اصل وابستگی وارونگی را نشان می‌دهد، زیرا ساختار Department به‌جای یک پیاده‌سازی خاص (ساختار Worker یا Supervisor) به یک انتزاع (Employee interface) وابستگی دارد. این امر کد را انعطاف‌پذیرتر می‌کند و نگهداری آن را آسان‌تر می‌کند، زیرا تغییرات در اجرای workers و supervisors بر ساختار Department تأثیر نمی‌گذارد.\n9.7.6 طراحی SOLID در Go # برای جمع‌بندی، وقتی هر یک از اصول SOLID را به Go اعمال می‌کنیم، موارد قدرتمندی در مورد طراحی هستند، اما وقتی با هم به کاربرده می‌شوند، می‌توان گفت که یک ایده مرکزی دارند.\nاصل مسئولیت واحد (Single Responsibility) شما را تشویق می‌کند تا توابع، انواع و متدها را در بسته‌هایی ساختار دهید که انسجام طبیعی دارند؛ تایپ‌ها با هم مرتبط هستند، توابع یک هدف واحد دارند.\nاصل باز/بسته (Open / Closed) شما را تشویق می‌کند تا تایپ‌های ساده را با استفاده از جاسازی به انواع پیچیده‌تر ترکیب کنید.\nاصل جایگزینی لیسکوف (Liskov Substitution) شما را تشویق می‌کند تا وابستگی‌ها بین بسته‌های خود را از نظر اینترفیس‌ها بیان کنید و نه فقط تایپ‌های concrete. با تعریف اینترفیس‌های کوچک، می‌توانیم مطمئن‌تر باشیم که پیاده‌سازی‌ها به طور کامل قرارداد خود را برآورده می‌کنند.\nاصل جداسازی اینترفیس (Interface Substitution) این ایده را بیشتر جلو می‌برد و شما را تشویق می‌کند تا توابع و متدهایی را تعریف کنید که فقط به رفتاری که نیاز دارند وابسته هستند. اگر تابع شما فقط به یک پارامتر از نوع Interface با یک متد نیاز دارد، پس احتمال بیشتری دارد که این تابع فقط یک مسئولیت داشته باشد.\nاصل وارونگی وابستگی (Dependency Inversion) شما را تشویق می‌کند که دانش چیزهایی که package شما به آن‌ها وابسته است را از زمان کامپایل - در Go این را با کاهش تعداد عبارات import استفاده شده توسط یک package خاص می‌بینیم - به زمان اجرا منتقل کنید.\nاگر بخواهید این صحبت را خلاصه کنید، احتمالاً این خواهد بود: Interface‌ها به شما اجازه می‌دهند اصول SOLID را به برنامه‌های Go اعمال کنید.\nزیرا Interface‌ها به برنامه‌نویسان Go اجازه می‌دهند تا توصیف کنند که package آن‌ها چه چیزی را فراهم می‌کند - نه اینکه چگونه این کار را انجام می‌دهد. این همه فقط یک روش دیگر برای گفتن \u0026ldquo;decoupling\u0026rdquo; بوده که در واقع هدف اصلی ما است، زیرا نرم‌افزاری که به صورت پیوستگی ضعیف ( loosely coupled) شده است نرم‌افزاری است که تغییر آن آسان‌تر است.\nهمانطور که Sandi Metz می‌گوید:\nطراحی هنر چیدمان کدی است که باید امروز کار کند و برای همیشه آسان تغییر کند.\nزیرا اگر Go قرار است زبانی باشد که شرکت‌ها برای بلندمدت در آن سرمایه‌گذاری کنند، نگهداری برنامه‌های Go، سهولت تغییر آن‌ها، عامل کلیدی در تصمیم آن‌ها خواهد بود.\n9.7.7 در پایان # بیایید به سؤالی که این صحبت را با آن شروع کردم برگردیم؛ چند برنامه‌نویس Go در دنیا وجود دارد؟ این حدس من است:\nتا سال 2020، 500000 توسعه‌دهنده Go وجود خواهد داشت.\nنیم میلیون برنامه‌نویس Go با وقت خود چه خواهند کرد؟ خب، واضح است که آن‌ها مقدار زیادی کد Go خواهند نوشت و اگر صادق باشیم، همه آن خوب نخواهد بود و برخی کاملاً بد خواهند بود.\nلطفا بدانید که من این را برای بی‌رحمی نمی‌گویم، اما هر یک از شما در این اتاق با تجربه توسعه در زبان‌های دیگر - زبان‌هایی که از آن‌ها به Go آمدید - از تجربه خود می‌دانید که این پیش‌بینی تا حدی درست است.\nدرون ++C، یک زبان بسیار کوچکتر و تمیزتر در تلاش برای بیرون آمدن است.\nبیارنه استراوستراپ، طراحی و تکامل ++C فرصت برای همه برنامه‌نویسان Go برای موفقیت زبان ما مستقیماً به توانایی جمعی ما در ایجاد چنین آشفتگی‌ای بستگی دارد که مردم شروع به صحبت کردن درباره Go به همان روشی کنند که امروز درباره ++C شوخی می‌کنند.\nداستانی که زبان‌های دیگر را به دلیل بزرگ، پر حرفی و پیچیده بودن مورد تمسخر قرار می‌دهد، ممکن است روزی به سمت Go برگردد،و من نمی‌خواهم این اتفاق بیفتد، بنابراین درخواستی دارم.\nبرنامه‌نویسان Go باید کمتر در مورد فریمورک‌ها صحبت کنند و بیشتر در مورد طراحی صحبت کنند. باید تمرکز خود را از عملکرد به هر قیمتی متوقف کنیم و در عوض روی استفاده مجدد به هر قیمتی تمرکز کنیم.\nمن می‌خواهم ببینم مردم در مورد نحوه استفاده از زبانی که امروز داریم، صرف نظر از انتخاب‌ها و محدودیت‌های آن، برای طراحی راه‌حل‌ها و حل مشکلات واقعی صحبت می‌کنند.\nمن می‌خواهم بشنوم که مردم در مورد نحوه طراحی برنامه‌های Go به روشی که به خوبی مهندسی شده، جدا شده، قابل استفاده مجدد و از همه مهم‌تر پاسخگو به تغییر است صحبت می‌کنند.\nیک چیز دیگر\u0026hellip;\nحالا، عالی است که بسیاری از شما امروز برای شنیدن از سخنرانان بزرگ اینجا هستید، اما واقعیت این است که صرف نظر از اینکه این کنفرانس چقدر بزرگ می‌شود، در مقایسه با تعداد افرادی که در طول عمر خود از Go استفاده خواهند کرد، ما فقط یک بخش کوچک هستیم.\nبنابراین باید به بقیه دنیا بگوییم که نرم‌افزار خوب چگونه باید نوشته شود. نرم‌افزار خوب، نرم‌افزار قابل ترکیب، نرم‌افزاری که قابل تغییر است و به آن‌ها نشان دهیم که چگونه این کار را با استفاده از Go انجام دهند. و این کار از شما شروع می‌شود.\nمن می‌خواهم شما شروع به صحبت در مورد طراحی کنید، شاید از برخی ایده‌هایی که در اینجا ارائه کردم استفاده کنید، امیدوارم تحقیقات خود را انجام دهید و این ایده‌ها را در پروژه‌های خود اعمال کنید. سپس می‌خواهم شما:\nیک پست وبلاگ در مورد آن بنویسید. یک کارگاه در مورد کاری که انجام دادید تدریس کنید. یک کتاب در مورد آنچه آموخته‌اید بنویسید. و سال آینده به این کنفرانس برگردید و در مورد آنچه به دست آوردید صحبت کنید.\nزیرا با انجام این کارها می‌توانیم فرهنگی از توسعه‌دهندگان Go ایجاد کنیم که به برنامه‌هایی اهمیت می‌دهند که برای ماندگاری طراحی شده‌اند.\n"},{"id":225,"href":"/chapter-9/cloud-native-patterns/go-cloud-native-circuit-breaker-pattern/","title":"9.5.1 الگو Circuit Breaker","section":"9.5 الگوهای Cloud Native","content":"الگو Circuit Breaker\u0026hellip;\n"},{"id":226,"href":"/chapter-9/cloud-native-patterns/go-cloud-native-debounce-pattern/","title":"9.5.2 الگو Debounce","section":"9.5 الگوهای Cloud Native","content":"الگو Debounce\u0026hellip;\n"},{"id":227,"href":"/chapter-9/cloud-native-patterns/go-cloud-native-retry-pattern/","title":"9.5.3 الگو Retry","section":"9.5 الگوهای Cloud Native","content":"الگو Retry\u0026hellip;\n"},{"id":228,"href":"/chapter-9/cloud-native-patterns/go-cloud-native-throttle-pattern/","title":"9.5.4 الگو Throttle","section":"9.5 الگوهای Cloud Native","content":"الگو Throttle\u0026hellip;\n"},{"id":229,"href":"/chapter-9/cloud-native-patterns/go-cloud-native-timeout-pattern/","title":"9.5.5 الگو Timeout","section":"9.5 الگوهای Cloud Native","content":"الگو Timeout\u0026hellip;\n"},{"id":230,"href":"/chapter-9/anti-pattern/go-anti-patterns-in-syntax/","title":"9.6.1 ضد الگو سینتکسی","section":"9.6 ضد الگوها (Anti-Patterns)","content":"ضد الگو سینتکسی\n"},{"id":231,"href":"/chapter-10/10.1--data-structures-queue-stack-lists/","title":"10.1 Data Structures (Queue Stack Lists)","section":"فصل دهم: الگوریتم و ساختار داده","content":"در این قسمت به بررسی مواردی مهم از ساختمان داده در زبان گو می‌پردازیم و این آموزش مناسب افرادی هست که با مباحث ساختمان داده آشنایی داشته باشند.\n10.1.1 Queue in Golang # یک صف (queue) ساده را می توان با استفاده از GO به کمک موارد زیر پیاده سازی کرد:\ncontainer/list package slice یک صف عملیات زیر را انجام می‌دهد:\nEnqueue Dequeue Front Size Empty 10.1.1.1 List Implementation # پیاده سازی صف به کمک لیست‌ها\npackage main import ( \u0026quot;container/list\u0026quot; \u0026quot;fmt\u0026quot; ) type customQueue struct { queue *list.List } func (c *customQueue) Enqueue(value string) { c.queue.PushBack(value) } func (c *customQueue) Dequeue() error { if c.queue.Len() \u0026gt; 0 { ele := c.queue.Front() c.queue.Remove(ele) } return fmt.Errorf(\u0026quot;Pop Error: Queue is empty\u0026quot;) } func (c *customQueue) Front() (string, error) { if c.queue.Len() \u0026gt; 0 { if val, ok := c.queue.Front().Value.(string); ok { return val, nil } return \u0026quot;\u0026quot;, fmt.Errorf(\u0026quot;Peep Error: Queue Datatype is incorrect\u0026quot;) } return \u0026quot;\u0026quot;, fmt.Errorf(\u0026quot;Peep Error: Queue is empty\u0026quot;) } func (c *customQueue) Size() int { return c.queue.Len() } func (c *customQueue) Empty() bool { return c.queue.Len() == 0 } func main() { customQueue := \u0026amp;customQueue{ queue: list.New(), } fmt.Printf(\u0026quot;Enqueue: A\\n\u0026quot;) customQueue.Enqueue(\u0026quot;A\u0026quot;) fmt.Printf(\u0026quot;Enqueue: B\\n\u0026quot;) customQueue.Enqueue(\u0026quot;B\u0026quot;) fmt.Printf(\u0026quot;Size: %d\\n\u0026quot;, customQueue.Size()) for customQueue.Size() \u0026gt; 0 { frontVal, _ := customQueue.Front() fmt.Printf(\u0026quot;Front: %s\\n\u0026quot;, frontVal) fmt.Printf(\u0026quot;Dequeue: %s\\n\u0026quot;, frontVal) customQueue.Dequeue() } fmt.Printf(\u0026quot;Size: %d\\n\u0026quot;, customQueue.Size()) } خروجی برنامه بالا:\nEnqueue: A Enqueue: B Size: 2 Front: A Dequeue: A Front: B Dequeue: B Size: 0 10.1.1.2 Slice Implementation # پیاده سازی صف به کمک slice\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;sync\u0026quot; ) type customQueue struct { queue []string lock sync.RWMutex } func (c *customQueue) Enqueue(name string) { c.lock.Lock() defer c.lock.Unlock() c.queue = append(c.queue, name) } func (c *customQueue) Dequeue() error { if len(c.queue) \u0026gt; 0 { c.lock.Lock() defer c.lock.Unlock() c.queue = c.queue[1:] return nil } return fmt.Errorf(\u0026quot;Pop Error: Queue is empty\u0026quot;) } func (c *customQueue) Front() (string, error) { if len(c.queue) \u0026gt; 0 { c.lock.Lock() defer c.lock.Unlock() return c.queue[0], nil } return \u0026quot;\u0026quot;, fmt.Errorf(\u0026quot;Peep Error: Queue is empty\u0026quot;) } func (c *customQueue) Size() int { return len(c.queue) } func (c *customQueue) Empty() bool { return len(c.queue) == 0 } func main() { customQueue := \u0026amp;customQueue{ queue: make([]string, 0), } fmt.Printf(\u0026quot;Enqueue: A\\n\u0026quot;) customQueue.Enqueue(\u0026quot;A\u0026quot;) fmt.Printf(\u0026quot;Enqueue: B\\n\u0026quot;) customQueue.Enqueue(\u0026quot;B\u0026quot;) fmt.Printf(\u0026quot;Len: %d\\n\u0026quot;, customQueue.Size()) for customQueue.Size() \u0026gt; 0 { frontVal, _ := customQueue.Front() fmt.Printf(\u0026quot;Front: %s\\n\u0026quot;, frontVal) fmt.Printf(\u0026quot;Dequeue: %s\\n\u0026quot;, frontVal) customQueue.Dequeue() } fmt.Printf(\u0026quot;Len: %d\\n\u0026quot;, customQueue.Size()) } خروجی برنامه بالا:\nEnqueue: A Enqueue: B Size: 2 Front: A Dequeue: A Front: B Dequeue: B Size: 0 10.1.2 Stack in Golang # یک پشته (Stack) ساده را می توان با استفاده از GO به کمک موارد زیر پیاده سازی کرد:\ncontainer/list package slice یک stack عملیات زیر را انجام می‌دهد:\nPush Pop Front Size Empty 10.1.2.1 List Implementation # پیاده سازی پشته به کمک لیست‌ها\npackage main import ( \u0026quot;container/list\u0026quot; \u0026quot;fmt\u0026quot; ) type customStack struct { stack *list.List } func (c *customStack) Push(value string) { c.stack.PushFront(value) } func (c *customStack) Pop() error { if c.stack.Len() \u0026gt; 0 { ele := c.stack.Front() c.stack.Remove(ele) } return fmt.Errorf(\u0026quot;Pop Error: Stack is empty\u0026quot;) } func (c *customStack) Front() (string, error) { if c.stack.Len() \u0026gt; 0 { if val, ok := c.stack.Front().Value.(string); ok { return val, nil } return \u0026quot;\u0026quot;, fmt.Errorf(\u0026quot;Peep Error: Stack Datatype is incorrect\u0026quot;) } return \u0026quot;\u0026quot;, fmt.Errorf(\u0026quot;Peep Error: Stack is empty\u0026quot;) } func (c *customStack) Size() int { return c.stack.Len() } func (c *customStack) Empty() bool { return c.stack.Len() == 0 } func main() { customStack := \u0026amp;customStack{ stack: list.New(), } fmt.Printf(\u0026quot;Push: A\\n\u0026quot;) customStack.Push(\u0026quot;A\u0026quot;) fmt.Printf(\u0026quot;Push: B\\n\u0026quot;) customStack.Push(\u0026quot;B\u0026quot;) fmt.Printf(\u0026quot;Size: %d\\n\u0026quot;, customStack.Size()) for customStack.Size() \u0026gt; 0 { frontVal, _ := customStack.Front() fmt.Printf(\u0026quot;Front: %s\\n\u0026quot;, frontVal) fmt.Printf(\u0026quot;Pop: %s\\n\u0026quot;, frontVal) customStack.Pop() } fmt.Printf(\u0026quot;Size: %d\\n\u0026quot;, customStack.Size()) } خروجی برنامه بالا:\nPush: A Push: B Size: 2 Front: B Pop: B Front: A Pop: A Size: 0 10.1.2.2 Slice Implementation # پیاده سازی پشته به کمک slice\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;sync\u0026quot; ) type customStack struct { stack []string lock sync.RWMutex } func (c *customStack) Push(name string) { c.lock.Lock() defer c.lock.Unlock() c.stack = append(c.stack, name) } func (c *customStack) Pop() error { len := len(c.stack) if len \u0026gt; 0 { c.lock.Lock() defer c.lock.Unlock() c.stack = c.stack[:len-1] return nil } return fmt.Errorf(\u0026quot;Pop Error: Stack is empty\u0026quot;) } func (c *customStack) Front() (string, error) { len := len(c.stack) if len \u0026gt; 0 { c.lock.Lock() defer c.lock.Unlock() return c.stack[len-1], nil } return \u0026quot;\u0026quot;, fmt.Errorf(\u0026quot;Peep Error: Stack is empty\u0026quot;) } func (c *customStack) Size() int { return len(c.stack) } func (c *customStack) Empty() bool { return len(c.stack) == 0 } func main() { customStack := \u0026amp;customStack{ stack: make([]string, 0), } fmt.Printf(\u0026quot;Push: A\\n\u0026quot;) customStack.Push(\u0026quot;A\u0026quot;) fmt.Printf(\u0026quot;Push: B\\n\u0026quot;) customStack.Push(\u0026quot;B\u0026quot;) fmt.Printf(\u0026quot;Size: %d\\n\u0026quot;, customStack.Size()) for customStack.Size() \u0026gt; 0 { frontVal, _ := customStack.Front() fmt.Printf(\u0026quot;Front: %s\\n\u0026quot;, frontVal) fmt.Printf(\u0026quot;Pop: %s\\n\u0026quot;, frontVal) customStack.Pop() } fmt.Printf(\u0026quot;Size: %d\\n\u0026quot;, customStack.Size()) } خروجی برنامه بالا:\nPush: A Push: B Size: 2 Front: B Pop: B Front: A Pop: A Size: 0 10.1.3 Set implementation in Golang # مجموعه (set) یک ساختار داده ای است که عناصر را بدون نظم خاصی در خود نگه می دارد. یک عنصر فقط یک بار در یک مجموعه ظاهر می شود.\nSet را می توان با استفاده از map در GO پیاده سازی کرد. ما از map[string]struct{} برای مجموعه استفاده خواهیم کرد زیرا struct{} هیچ حافظه ای اشغال نمی کند، بنابراین از نظر ذخیره سازی کارآمدتر است.\nدر زیر مثال ساده مجموعه (set) که دارای عملیات زیر است را داریم:\nAdd Remove Exists package main import ( \u0026quot;fmt\u0026quot; ) //MakeSet initialize the set func makeSet() *customSet { return \u0026amp;customSet{ container: make(map[string]struct{}), } } type customSet struct { container map[string]struct{} } func (c *customSet) Exists(key string) bool { _, exists := c.container[key] return exists } func (c *customSet) Add(key string) { c.container[key] = struct{}{} } func (c *customSet) Remove(key string) error { _, exists := c.container[key] if !exists { return fmt.Errorf(\u0026quot;Remove Error: Item doesn't exist in set\u0026quot;) } delete(c.container, key) return nil } func (c *customSet) Size() int { return len(c.container) } func main() { customSet := makeSet() fmt.Printf(\u0026quot;Add: B\\n\u0026quot;) customSet.Add(\u0026quot;A\u0026quot;) fmt.Printf(\u0026quot;Add: B\\n\u0026quot;) customSet.Add(\u0026quot;B\u0026quot;) fmt.Printf(\u0026quot;Size: %d\\n\u0026quot;, customSet.Size()) fmt.Printf(\u0026quot;A Exists?: %t\\n\u0026quot;, customSet.Exists(\u0026quot;A\u0026quot;)) fmt.Printf(\u0026quot;B Exists?: %t\\n\u0026quot;, customSet.Exists(\u0026quot;B\u0026quot;)) fmt.Printf(\u0026quot;C Exists?: %t\\n\u0026quot;, customSet.Exists(\u0026quot;C\u0026quot;)) fmt.Printf(\u0026quot;Remove: B\\n\u0026quot;) customSet.Remove(\u0026quot;B\u0026quot;) fmt.Printf(\u0026quot;B Exists?: %t\\n\u0026quot;, customSet.Exists(\u0026quot;B\u0026quot;)) } خروجی برنامه بالا:\nAdd: B Add: B Size: 2 A Exists?: true B Exists?: true C Exists?: false Remove: B B Exists?: false 10.1.4 Linked List in Golang # لیست منفرد یک نوع ساده از لیست پیوندی است که امکان پیمایش در یک جهت یعنی جلو را فراهم می کند. هر گره در لیست پیوندی شامل بخش داده و اشاره گر به گره بعدی در لیست پیوند شده است.\nلیست پیوندی اجرا شده در مثال زیر از عملیات زیر پشتیبانی می کند.\nAddFront AddBack RemoveFront RemoveBack Traverse Front Size package main import \u0026quot;fmt\u0026quot; type ele struct { name string next *ele } type singleList struct { len int head *ele } func initList() *singleList { return \u0026amp;singleList{} } func (s *singleList) AddFront(name string) { ele := \u0026amp;ele{ name: name, } if s.head == nil { s.head = ele } else { ele.next = s.head s.head = ele } s.len++ return } func (s *singleList) AddBack(name string) { ele := \u0026amp;ele{ name: name, } if s.head == nil { s.head = ele } else { current := s.head for current.next != nil { current = current.next } current.next = ele } s.len++ return } func (s *singleList) RemoveFront() error { if s.head == nil { return fmt.Errorf(\u0026quot;List is empty\u0026quot;) } s.head = s.head.next s.len-- return nil } func (s *singleList) RemoveBack() error { if s.head == nil { return fmt.Errorf(\u0026quot;removeBack: List is empty\u0026quot;) } var prev *ele current := s.head for current.next != nil { prev = current current = current.next } if prev != nil { prev.next = nil } else { s.head = nil } s.len-- return nil } func (s *singleList) Front() (string, error) { if s.head == nil { return \u0026quot;\u0026quot;, fmt.Errorf(\u0026quot;Single List is empty\u0026quot;) } return s.head.name, nil } func (s *singleList) Size() int { return s.len } func (s *singleList) Traverse() error { if s.head == nil { return fmt.Errorf(\u0026quot;TranverseError: List is empty\u0026quot;) } current := s.head for current != nil { fmt.Println(current.name) current = current.next } return nil } func main() { singleList := initList() fmt.Printf(\u0026quot;AddFront: A\\n\u0026quot;) singleList.AddFront(\u0026quot;A\u0026quot;) fmt.Printf(\u0026quot;AddFront: B\\n\u0026quot;) singleList.AddFront(\u0026quot;B\u0026quot;) fmt.Printf(\u0026quot;AddBack: C\\n\u0026quot;) singleList.AddBack(\u0026quot;C\u0026quot;) fmt.Printf(\u0026quot;Size: %d\\n\u0026quot;, singleList.Size()) err := singleList.Traverse() if err != nil { fmt.Println(err.Error()) } fmt.Printf(\u0026quot;RemoveFront\\n\u0026quot;) err = singleList.RemoveFront() if err != nil { fmt.Printf(\u0026quot;RemoveFront Error: %s\\n\u0026quot;, err.Error()) } fmt.Printf(\u0026quot;RemoveBack\\n\u0026quot;) err = singleList.RemoveBack() if err != nil { fmt.Printf(\u0026quot;RemoveBack Error: %s\\n\u0026quot;, err.Error()) } fmt.Printf(\u0026quot;RemoveBack\\n\u0026quot;) err = singleList.RemoveBack() if err != nil { fmt.Printf(\u0026quot;RemoveBack Error: %s\\n\u0026quot;, err.Error()) } fmt.Printf(\u0026quot;RemoveBack\\n\u0026quot;) err = singleList.RemoveBack() if err != nil { fmt.Printf(\u0026quot;RemoveBack Error: %s\\n\u0026quot;, err.Error()) } err = singleList.Traverse() if err != nil { fmt.Println(err.Error()) } fmt.Printf(\u0026quot;Size: %d\\n\u0026quot;, singleList.Size()) } خروجی برنامه بالا:\nAddFront: A AddFront: B AddBack: C Size: 3 B A C RemoveFront RemoveBack RemoveBack RemoveBack RemoveBack Error: removeBack: List is empty TranverseError: List is empty Size: 0 10.1.5 Doubly Linked List in Go # یک لیست مضاعف (Doubly Linked) شامل سه قسمت در گره خود است.\nفیلد داده. یک اشاره گر بعدی به گره بعدی در لیست اشاره می کند. یک اشاره گر قبلی که به گره قبلی در لیست اشاره می کند. در اینجا فیلدهای «داده‌ها» و «بعدی» مانند لیست‌های پیوندی منفرد هستند. فیلد اشاره گر «قبلی» ویژگی جدیدی است که لیست پیوندی را به لیست پیوندی دوگانه تبدیل می کند.\nدر زیر نمونه ای از یک لیست با پیوند دوگانه آورده شده است. اشاره گر قبلی گره head (start) به Null اشاره می کند. به طور مشابه، اشاره گر Next آخرین گره به Null اشاره می کند.\nبرای پیاده‌سازی یک doubly linked list در زبان Go، یک ساختار گره با داده‌ها، اشاره‌گر قبلی و اشاره‌گر بعدی، روش‌هایی برای افزودن گره‌ها در doubly linked list (از قسمت جلویی یا از انتهای هر دو) و روش‌هایی برای پیمایش به جلو/عقب ایجاد کنید.\npackage main import \u0026quot;fmt\u0026quot; type node struct { data string prev *node next *node } type doublyLinkedList struct { len int tail *node head *node } func initDoublyList() *doublyLinkedList { return \u0026amp;doublyLinkedList{} } func (d *doublyLinkedList) AddFrontNodeDLL(data string) { newNode := \u0026amp;node{ data: data, } if d.head == nil { d.head = newNode d.tail = newNode } else { newNode.next = d.head d.head.prev = newNode d.head = newNode } d.len++ return } func (d *doublyLinkedList) AddEndNodeDLL(data string) { newNode := \u0026amp;node{ data: data, } if d.head == nil { d.head = newNode d.tail = newNode } else { currentNode := d.head for currentNode.next != nil { currentNode = currentNode.next } newNode.prev = currentNode currentNode.next = newNode d.tail = newNode } d.len++ return } func (d *doublyLinkedList) TraverseForward() error { if d.head == nil { return fmt.Errorf(\u0026quot;TraverseError: List is empty\u0026quot;) } temp := d.head for temp != nil { fmt.Printf(\u0026quot;value = %v, prev = %v, next = %v\\n\u0026quot;, temp.data, temp.prev, temp.next) temp = temp.next } fmt.Println() return nil } func (d *doublyLinkedList) TraverseReverse() error { if d.head == nil { return fmt.Errorf(\u0026quot;TraverseError: List is empty\u0026quot;) } temp := d.tail for temp != nil { fmt.Printf(\u0026quot;value = %v, prev = %v, next = %v\\n\u0026quot;, temp.data, temp.prev, temp.next) temp = temp.prev } fmt.Println() return nil } func (d *doublyLinkedList) Size() int { return d.len } func main() { doublyList := initDoublyList() fmt.Printf(\u0026quot;Add Front Node: C\\n\u0026quot;) doublyList.AddFrontNodeDLL(\u0026quot;C\u0026quot;) fmt.Printf(\u0026quot;Add Front Node: B\\n\u0026quot;) doublyList.AddFrontNodeDLL(\u0026quot;B\u0026quot;) fmt.Printf(\u0026quot;Add Front Node: A\\n\u0026quot;) doublyList.AddFrontNodeDLL(\u0026quot;A\u0026quot;) fmt.Printf(\u0026quot;Add End Node: D\\n\u0026quot;) doublyList.AddEndNodeDLL(\u0026quot;D\u0026quot;) fmt.Printf(\u0026quot;Add End Node: E\\n\u0026quot;) doublyList.AddEndNodeDLL(\u0026quot;E\u0026quot;) fmt.Printf(\u0026quot;Size of doubly linked ist: %d\\n\u0026quot;, doublyList.Size()) err := doublyList.TraverseForward() if err != nil { fmt.Println(err.Error()) } err = doublyList.TraverseReverse() if err != nil { fmt.Println(err.Error()) } } خروجی مورد انتظار برابر حالت زیر است:\nAdd Front Node: C Add Front Node: B Add Front Node: A Add End Node: D Add End Node: E Size of doubly linked ist: 5 value = A, prev = , next = \u0026amp;{B 0xc000070060 0xc000070020} value = B, prev = \u0026amp;{A 0xc000070040}, next = \u0026amp;{C 0xc000070040 0xc000070080} value = C, prev = \u0026amp;{B 0xc000070060 0xc000070020}, next = \u0026amp;{D 0xc000070020 0xc0000700a0} value = D, prev = \u0026amp;{C 0xc000070040 0xc000070080}, next = \u0026amp;{E 0xc000070080 } value = E, prev = \u0026amp;{D 0xc000070020 0xc0000700a0}, next = value = E, prev = \u0026amp;{D 0xc000070020 0xc0000700a0}, next = value = D, prev = \u0026amp;{C 0xc000070040 0xc000070080}, next = \u0026amp;{E 0xc000070080 } value = C, prev = \u0026amp;{B 0xc000070060 0xc000070020}, next = \u0026amp;{D 0xc000070020 0xc0000700a0} value = B, prev = \u0026amp;{A 0xc000070040}, next = \u0026amp;{C 0xc000070040 0xc000070080} value = A, prev = , next = \u0026amp;{B 0xc000070060 0xc000070020} 10.1.6 Tree in Go # درخت به عنوان یک ساختمان داده غیرخطی تعریف می‌شود که از مجموعه‌ای از گره‌ها تشکیل شده است، و این گره‌ها توسط یال‌ها به یکدیگر متصل شده‌اند\nخواص یک درخت:\nدرخت از یک گره ریشه و صفر یا چند درخت فرعی متصل به آن تشکیل شده است گره ریشه بالاترین گره درخت است گره‌های برگ گره‌هایی هستند که هیچ فرزندی ندارند عمق یک گره تعداد یال‌ها بین ریشه و خودش است ارتفاع یک گره تعداد یال‌ها بین خودش و دورترین گره برگ در زیردرخت خود است ‍‍\npackage main import \u0026quot;fmt\u0026quot; // Tree represents a tree structure. type Tree struct { root *TreeNode } // TreeNode represents a node in the tree. type TreeNode struct { data int children []*TreeNode } // insertTree adds a new node with the given data as the root node of the tree. func (tree *Tree) insertTree(data int) { if tree.root == nil { tree.root = \u0026amp;TreeNode{data: data} } } // InsertNode adds a new node with the given data as a child of the specified node. func (node *TreeNode) insertNode(data int) *TreeNode { newNode := \u0026amp;TreeNode{data: data} node.children = append(node.children, newNode) return newNode } // deleteTree removes the specified node, starting from the root of the tree. func (tree *Tree) deleteFromRoot(nodeToDelete *TreeNode) { if tree.root != nil { tree.root = tree.root.deleteNode(nodeToDelete) } } // deleteNode recursively removes the specified node and its descendants from the current node's children. func (node *TreeNode) deleteNode(nodeToDelete *TreeNode) *TreeNode { var updatedChildren []*TreeNode for _, child := range node.children { if child != nodeToDelete { updatedChildren = append(updatedChildren, child.deleteNode(nodeToDelete)) } } node.children = updatedChildren return node } // searchFromRoot searches for a node with the specified data starting from the tree's root. func (tree *Tree) searchFromRoot(data int) *TreeNode { if tree.root != nil { node := tree.root.searchFromNode(data) return node } return nil } // searchFromNode searches for a node with the specified data starting from the current node. func (node *TreeNode) searchFromNode(data int) *TreeNode { if node.data == data { return node } for _, child := range node.children { if foundNode := child.searchFromNode(data); foundNode != nil { return foundNode } } return nil } // traverseFromRoot initiates a traversal of the tree starting from the root node. func (tree *Tree) traverseFromRoot() { if tree.root != nil { tree.root.traverse() } } // traverse performs a recursive traversal starting from the current node. func (node *TreeNode) traverse() { if node == nil { return } fmt.Printf(\u0026quot;%d \u0026quot;, node.data) for _, child := range node.children { child.traverse() } } func main() { // Creating a Tree instance tree := Tree{} // Inserting nodes tree.insertTree(1) tree.root.insertNode(2) node3 := tree.root.insertNode(3) node4 := tree.root.insertNode(4) node3.insertNode(5) node3.insertNode(6) node4.insertNode(7) // Traversing and printing nodes fmt.Println(\u0026quot;Traverse from root:\u0026quot;) tree.root.traverse() // Searching for node fmt.Println(\u0026quot;\\nSearch for node 3:\u0026quot;) node := tree.searchFromRoot(3) if node != nil { fmt.Println(\u0026quot;node found\u0026quot;) } else { fmt.Println(\u0026quot;node not found\u0026quot;) } fmt.Println(\u0026quot;Search for node 8:\u0026quot;) node8 := tree.searchFromRoot(8) if node8 != nil { fmt.Println(\u0026quot;node found\u0026quot;) } else { fmt.Println(\u0026quot;node not found\u0026quot;) } // Deleting a node fmt.Println(\u0026quot;After deleting node 3:\u0026quot;) tree.deleteFromRoot(node3) tree.root.traverse() } خروجی برنامه بالا:\nTraverse from root: 1 2 3 5 6 4 7 Search for node 3 node found Search for node 8 node not found After deleting node 3: 1 2 4 7 10.1.7 Binary Tree in Go # درخت دودویی، نوعی ساختار داده‌ای درخت است که هر گره آن می‌تواند حداکثر دو فرزند (یک فرزند چپ و یک فرزند راست) داشته باشد\npackage main import \u0026quot;fmt\u0026quot; // BinaryTree represents a binary tree. type BinaryTree struct { root *BinaryNode } // BinaryNode represents a node in the binary tree. type BinaryNode struct { data int left *BinaryNode right *BinaryNode } // insertFromRoot inserts a new node with the given data into the tree. func (tree *BinaryTree) insertFromRoot(data int) *BinaryTree { if tree.root != nil { tree.root.insertNode(data) } else { tree.root = \u0026amp;BinaryNode{data: data} } return tree } // insertNode inserts a new node with the given data into the subtree rooted at the current node using level-order traversal. func (node *BinaryNode) insertNode(data int) *BinaryNode { var tempNode *BinaryNode queue := []*BinaryNode{node} for len(queue) \u0026gt; 0 { tempNode, queue = queue[0], queue[1:] if tempNode.left == nil { tempNode.left = \u0026amp;BinaryNode{data: data} break } queue = append(queue, tempNode.left)\tif tempNode.right == nil { tempNode.right = \u0026amp;BinaryNode{data: data} break } queue = append(queue, tempNode.right) } return node } // deleteFromRoot deletes a specific node from the binary tree starting from the root. func (tree *BinaryTree) deleteFromRoot(nodeToDelete *BinaryNode) { if tree.root != nil { tree.root.deleteNode(nodeToDelete) } } // deletetNode attempts to delete a specific node from the subtree rooted at the current node. func (node *BinaryNode) deleteNode(nodeToDelete *BinaryNode) *BinaryNode { var keyNode, lastNode, tempNode *BinaryNode queue := []*BinaryNode{node}\tfor len(queue) \u0026gt; 0 { tempNode, queue = queue[0], queue[1:] if tempNode == nodeToDelete {\tkeyNode = tempNode } if tempNode.left != nil { lastNode, queue = tempNode, append(queue, tempNode.left) } if tempNode.right != nil { lastNode, queue = tempNode, append(queue, tempNode.right) } } if keyNode != nil { keyNode.data = tempNode.data if lastNode.right == tempNode { lastNode.right = nil } else { lastNode.left = nil } } return node } // searchFromRoot searches for a node with the given data in the binary tree starting from the root. func (tree *BinaryTree) searchFromRoot(data int) *BinaryNode { if tree.root != nil { return tree.root.searchFromNode(data) } return nil } // searchFromNode performs a level-order traversal to find a node with the given data func (node *BinaryNode) searchFromNode(data int) *BinaryNode { var tempNode *BinaryNode queue := []*BinaryNode{node} for len(queue) \u0026gt; 0 { tempNode, queue = queue[0], queue[1:] if tempNode.data == data { return tempNode } if tempNode.left != nil { queue = append(queue, tempNode.left) } if tempNode.right != nil { queue = append(queue, tempNode.right) } } return nil } // printTreeInOrder prints the values of nodes in the binary tree starting from root using an in-order traversal. func (tree *BinaryTree) printTreeInOrder() { if tree.root != nil { tree.root.printSubTreeInOrder() } } // printTreePreOrder prints the values of nodes in the binary tree starting from root using a pre-order traversal. func (tree *BinaryTree) printTreePreOrder() { if tree.root != nil { tree.root.printSubTreePreOrder() } } // printTreePostOrder prints the values of nodes in the binary tree starting from root using a post-order traversal. func (tree *BinaryTree) printTreePostOrder() { if tree.root != nil { tree.root.printSubTreePostOrder() } } // printSubTreeInOrder prints the values of nodes in the subtree rooted at the given node using an in-order traversal. func (node *BinaryNode) printSubTreeInOrder() { if node != nil { node.left.printSubTreeInOrder() fmt.Printf(\u0026quot;%d \u0026quot;, node.data) node.right.printSubTreeInOrder() } } // printSubTreePreOrder prints the values of nodes in the subtree rooted at the given node using a pre-order traversal. func (node *BinaryNode) printSubTreePreOrder() { if node != nil { fmt.Printf(\u0026quot;%d \u0026quot;, node.data) node.left.printSubTreePreOrder() node.right.printSubTreePreOrder() } } // printSubTreePostOrder prints the values of nodes in the subtree rooted at the given node using a post-order traversal. func (node *BinaryNode) printSubTreePostOrder() { if node != nil { node.left.printSubTreePostOrder() node.right.printSubTreePostOrder() fmt.Printf(\u0026quot;%d \u0026quot;, node.data) } } func main() { // Create a new binary tree tree := BinaryTree{} // Insert nodes tree.insertFromRoot(1) tree.insertFromRoot(2) tree.insertFromRoot(3) tree.insertFromRoot(4) tree.insertFromRoot(5) tree.insertFromRoot(6) tree.insertFromRoot(7)\tfmt.Println(\u0026quot;In-Order Traversal:\u0026quot;) tree.printTreeInOrder() fmt.Println(\u0026quot;\\nPre-Order Traversal:\u0026quot;) tree.printTreePreOrder() fmt.Println(\u0026quot;\\nPost-Order Traversal:\u0026quot;) tree.printTreePostOrder() // Search for a node fmt.Println(\u0026quot;\\n\\nSearching for node with data 6:\u0026quot;) nodeToSearch := tree.searchFromRoot(6) if nodeToSearch != nil { fmt.Println(\u0026quot;found node with data 6:\u0026quot;, nodeToSearch.data) } else { fmt.Println(\u0026quot;node with data 6 not found.\u0026quot;) } fmt.Println(\u0026quot;\\nSearching for node with data 9:\u0026quot;) nodeToSearch = tree.searchFromRoot(9) if nodeToSearch != nil { fmt.Println(\u0026quot;found node with data 9:\u0026quot;, nodeToSearch.data) } else { fmt.Println(\u0026quot;node with data 9 not found.\u0026quot;) } fmt.Println(\u0026quot;\\nDeleting node with data 4:\u0026quot;) nodeToDelete := tree.searchFromRoot(4) if nodeToDelete != nil { fmt.Println(\u0026quot;deleted node with data 4.\u0026quot;) tree.deleteFromRoot(nodeToDelete) } else { fmt.Println(\u0026quot;node with data 4 not found.\u0026quot;) } fmt.Println(\u0026quot;\\nIn-Order Traversal after deletion:\u0026quot;) tree.printTreeInOrder() } خروجی کد بالا:\nIn-Order Traversal: 4 2 5 1 6 3 7 Pre-Order Traversal: 1 2 4 5 3 6 7 Post-Order Traversal: 4 5 2 6 7 3 1 Searching for node with data 6: found node with data 6: 6 Searching for node with data 9: node with data 9 not found. Deleting node with data 4: deleted node with data 4. In-Order Traversal after deletion: 7 2 5 1 6 3 10.1.8 Binary Search Tree in Go # درخت جستجو دودویی یک نوع از درخت دودویی است که ب هر گره دارای یک مقدار داده و دو زیردرخت (زیردرخت چپ و زیردرخت راست) می‌باشد. در این درخت، داده‌های کوچکتر از مقدار دادهٔ گره مورد نظر در زیردرخت چپ قرار می‌گیرند و داده‌های بزرگتر در زیردرخت راست قرار می‌گیرند . درخت جستجو دودویی به گونه ای طراحی شده است که عملیات جستجو، افزودن و حذف به طور موثر انجام شود\npackage main import \u0026quot;fmt\u0026quot; // BinarySearchTree represents a binary search tree. type BinarySearchTree struct { root *BinarySearchNode } // BinarySearchNode represents a node in the binary search tree. type BinarySearchNode struct { data int left *BinarySearchNode right *BinarySearchNode } // insertFromRoot inserts a new node with the given data into the binary search tree, starting from the root of the tree. func (tree *BinarySearchTree) insertFromRoot(data int) *BinarySearchTree { if tree.root != nil { tree.root.insertNode(data) } else { tree.root = \u0026amp;BinarySearchNode{data: data} } return tree } // insertNode inserts a new node with the given data into the binary search tree rooted at the current node. func (node *BinarySearchNode) insertNode(data int) *BinarySearchNode { if node == nil { return \u0026amp;BinarySearchNode{data: data} } else if data == node.data { return node } else if data \u0026gt; node.data { node.right = node.right.insertNode(data) } else { node.left = node.left.insertNode(data) } return node } // deleteFromRoot deletes a specific node from the binary search tree starting from the root node. func (tree *BinarySearchTree) deleteFromRoot(nodeToDelete *BinarySearchNode) *BinarySearchNode { if tree.root != nil { return tree.root.left.deleteNode(nodeToDelete) } return nil } // deleteNode recursively deletes a specific node from the subtree rooted at the current node. func (node *BinarySearchNode) deleteNode(nodeToDelete *BinarySearchNode) *BinarySearchNode { if node == nil { return nil } if nodeToDelete.data \u0026lt; node.data { node.left = node.left.deleteNode(nodeToDelete) } else if nodeToDelete.data \u0026gt; node.data { node.right = node.right.deleteNode(nodeToDelete) } else { if node.left == nil { return node.right } else if node.right == nil { return node.left } minNode := node.right.findMin() node.data = minNode.data node.right = node.right.deleteNode(nodeToDelete) } return node } // findMin returns the minimum node value in the subtree rooted at the current node. func (node *BinarySearchNode) findMin() *BinarySearchNode { for node.left != nil { node = node.left } return node } // searchFromRoot searches for a node with the specified data in the binary search tree starting from the root node. func (tree *BinarySearchTree) searchFromRoot(data int) *BinarySearchNode { if tree.root != nil { return tree.root.searchNode(data) } return nil } // searchNode recursively searches for a node with the specified data in the subtree rooted at the current node. func (node *BinarySearchNode) searchNode(data int) *BinarySearchNode { if node == nil { return nil } if node.data == data { return node } else if data \u0026gt; node.data { return node.right.searchNode(data) } else if data \u0026lt; node.data { return node.left.searchNode(data) } return nil } // printTreeInOrder prints the values of nodes in the binary search tree starting from root using an in-order traversal. func (tree *BinarySearchTree) printTreeInOrder() { if tree.root != nil { tree.root.printSubTreeInOrder() } } // printTreePreOrder prints the values of nodes in the binary search tree starting from root using a pre-order traversal. func (tree *BinarySearchTree) printTreePreOrder() { if tree.root != nil { tree.root.printSubTreePreOrder() } } // printTreePostOrder prints the values of nodes in the binary search tree starting from root using a post-order traversal. func (tree *BinarySearchTree) printTreePostOrder() { if tree.root != nil { tree.root.printSubTreePostOrder() } } // printSubTreeInOrder prints the values of nodes in the subtree rooted at the given node using an in-order traversal. func (node *BinarySearchNode) printSubTreeInOrder() { if node != nil { node.left.printSubTreeInOrder() fmt.Printf(\u0026quot;%d \u0026quot;, node.data) node.right.printSubTreeInOrder() } } // printSubTreePreOrder prints the values of nodes in the subtree rooted at the given node using a pre-order traversal. func (node *BinarySearchNode) printSubTreePreOrder() { if node != nil { fmt.Printf(\u0026quot;%d \u0026quot;, node.data) node.left.printSubTreePreOrder() node.right.printSubTreePreOrder() } } // printSubTreePostOrder prints the values of nodes in the subtree rooted at the given node using a post-order traversal. func (node *BinarySearchNode) printSubTreePostOrder() { if node != nil { node.left.printSubTreePostOrder() node.right.printSubTreePostOrder() fmt.Printf(\u0026quot;%d \u0026quot;, node.data) } } func main() { // Create a BinarySearchTree bst := \u0026amp;BinarySearchTree{} bst.insertFromRoot(5).insertFromRoot(3).insertFromRoot(7).\tinsertFromRoot(2).insertFromRoot(4) fmt.Println(\u0026quot;In-order traversal:\u0026quot;) bst.printTreeInOrder() fmt.Println(\u0026quot;\\nPre-order traversal:\u0026quot;) bst.printTreePreOrder() fmt.Println(\u0026quot;\\nPost-order traversal:\u0026quot;) bst.printTreePostOrder() // Search for a node fmt.Println(\u0026quot;\\n Searching for node with data 1\u0026quot;) searchNode := bst.searchFromRoot(1) if searchNode != nil { fmt.Printf(\u0026quot;Node %d found.\\n\u0026quot;, searchNode.data) } else { fmt.Println(\u0026quot;Node not found.\u0026quot;) } // Search for a node fmt.Println(\u0026quot;Searching for node with data 3\u0026quot;) searchNode = bst.searchFromRoot(3) if searchNode != nil {\tfmt.Printf(\u0026quot;Node %d found.\\n\u0026quot;, searchNode.data) } else { fmt.Println(\u0026quot;Node not found.\u0026quot;) } // Delete a node bst.deleteFromRoot(searchNode) fmt.Println(\u0026quot;In-order traversal after deleting 3:\u0026quot;) bst.printTreeInOrder() } خروجی کد بالا:\nIn-order traversal: 2 3 4 5 7 Pre-order traversal: 5 3 2 4 7 Post-order traversal: 2 4 3 7 5 Searching for node with data 1 Node not found. Searching for node with data 3 Node 3 found. In-order traversal after deleting 3: 2 4 5 7 "}]