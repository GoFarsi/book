<!doctype html><html lang=fa dir=rtl><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="در این بخش ما یکسری سوالات مصاحبه به زبان فارسی ارائه دادیم که برای یافتن ضعف‌ها کاربردی می‌باشد.
1: چه تایپ‌هایی مقدار zero آن‌ها nil است؟
  
    
interfaces
slices
channels
maps
pointers
functions


  


2: تایپ‌های نوع Reference؟
  
    
Pointers
slices
maps
functions
channels


  


3: تایپ‌های نوع Aggregate؟
  
    
Array
structs


  


4: چه وقت باید از پوینتر استفاده کنیم؟
  
    1- تابعی که یکی از پارامترهای خود را تغییر می‌دهد
-وقتی تابعی را فراخوانی می‌کنیم که یک پوینتر را به عنوان پارامتر می‌گیرد، انتظار داریم که متغیر ما تغییر داده شود. اگر شما متغیر را در تابع خود تغییر نمی‌دهید، پس احتمالا نباید از پوینتر استفاده کنید."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://book.gofarsi.ir/interview/"><meta property="og:site_name" content="زبان گو فارسی"><meta property="og:title" content="نمونه سوالات مصاحبه"><meta property="og:description" content="در این بخش ما یکسری سوالات مصاحبه به زبان فارسی ارائه دادیم که برای یافتن ضعف‌ها کاربردی می‌باشد.
1: چه تایپ‌هایی مقدار zero آن‌ها nil است؟ interfaces slices channels maps pointers functions 2: تایپ‌های نوع Reference؟ Pointers slices maps functions channels 3: تایپ‌های نوع Aggregate؟ Array structs 4: چه وقت باید از پوینتر استفاده کنیم؟ 1- تابعی که یکی از پارامترهای خود را تغییر می‌دهد -وقتی تابعی را فراخوانی می‌کنیم که یک پوینتر را به عنوان پارامتر می‌گیرد، انتظار داریم که متغیر ما تغییر داده شود. اگر شما متغیر را در تابع خود تغییر نمی‌دهید، پس احتمالا نباید از پوینتر استفاده کنید."><meta property="og:locale" content="fa"><meta property="og:type" content="article"><title>نمونه سوالات مصاحبه | زبان گو فارسی</title><link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://book.gofarsi.ir/interview/><link rel=stylesheet href=/book.min.75204a0314de305f8972b34999060b35e65d56ba4ae066d3bb8aa0a07170ea41.css integrity="sha256-dSBKAxTeMF+JcrNJmQYLNeZdVrpK4GbTu4qgoHFw6kE=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/fa.search.min.523aa32ce9be2e0680a503ec0ebe96ea9640888f030b8beba289f8ede64931c3.js integrity="sha256-UjqjLOm+LgaApQPsDr6W6pZAiI8DC4vroon47eZJMcM=" crossorigin=anonymous></script><link rel=preconnect href=https://cdn.jsdelivr.net crossorigin><link rel=stylesheet href=prism.css><meta name=keywords content><link href=https://cdn.jsdelivr.net/gh/rastikerdar/vazir-font@v30.1.0/dist/font-face.css rel=stylesheet type=text/css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.0/css/all.min.css crossorigin=anonymous><link rel=alternate type=application/rss+xml href=https://book.gofarsi.ir//feed.xml title="زبان گو فارسی"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/prism-themes@1.9.0/themes/prism-one-dark.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/line-numbers/prism-line-numbers.min.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZE44Q8PZDW"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZE44Q8PZDW")</script><script>var html=document.documentElement;localStorage.getItem("themeMode")=="dark"&&html.setAttribute("data-theme","dark"),localStorage.getItem("themeMode")=="light"&&html.setAttribute("data-theme","light")</script></head><body dir=rtl><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><img src=/favicon.png alt=Logo class=book-icon><span>زبان گو فارسی</span></a></h2><div class=magic><div class=book-search><input type=text id=book-search-input placeholder=جستجو aria-label=جستجو maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><div class=js-toggle-wrapper><div class=js-toggle><div class=js-toggle-track><div class=js-toggle-track-check><img src="data:image/png;base64,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" role=presentation style=pointer-events:none width=23 height=23></div><div class=js-toggle-track-x><img src=data:image/png;base64,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 role=presentation style=pointer-events:none width=23 height=23></div></div><div class=js-toggle-thumb><img src=data:image/png;base64,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 role=presentation style=pointer-events:none width=46 height=46></div><input class=js-toggle-screenreader-only type=checkbox aria-label="تغییر تم بین روشن و تاریک"></div></div></div><ul><li><a href=/preface/>پیشگفتار</a></li><li><a href=/history/>تاریخچه</a></li><li><a href=/why-go/>چرا زبان Go؟</a></li><li><a href=/installation/>آموزش نصب</a></li><li><a href=/toolchain/>ابزارها, دستورات گو و معرفی IDE</a></li><li><a href=/roadmap/>نقشه یادگیری زبان گو</a></li><li><a href=/interview/ class=active>نمونه سوالات مصاحبه</a></li><li><input type=checkbox id=section-c0c35ea61c635f6152f0c00d6a15569e class=toggle>
<label for=section-c0c35ea61c635f6152f0c00d6a15569e class=flex><a href=/chapter-1/ class=flex-auto>فصل اول: آشنایی با مفاهیم گو</a></label><ul><li><a href=/chapter-1/structure-of-go-code/>1.1 ساختار کد گو</a></li><li><a href=/chapter-1/go-built-in-keywords-identifiers/>1.2 کلید واژه و شناسه‌ها</a></li><li><a href=/chapter-1/go-basic-types/>1.3 تایپ‌های پایه</a></li><li><a href=/chapter-1/go-operators/>1.4 عملگرها</a></li><li><a href=/chapter-1/go-variables-and-consts/>1.5 متغیرها و constant</a></li><li><a href=/chapter-1/go-zero-values/>1.6 مقادیر صفر تایپ‌ها (zero values)</a></li><li><a href=/chapter-1/go-function/>1.7 تابع (function)</a></li><li><a href=/chapter-1/go-array/>1.8 آرایه و slice</a></li><li><a href=/chapter-1/go-for/>1.9 حلقه‌ها (for)</a></li><li><a href=/chapter-1/go-map/>1.10 نقشه map</a></li><li><a href=/chapter-1/go-if-switch/>1.11 شرط (if, switch)</a></li><li><a href=/chapter-1/go-package/>1.12 اضافه کردن پکیج در کد (package)</a></li><li><a href=/chapter-1/go-defer-panic-recovery/>1.13 defer, panic, recovery</a></li><li><a href=/chapter-1/go-builtins/>1.14 لیست تایپ‌ها و توابع Builtin</a></li><li><a href=/chapter-1/go-string-formatting/>1.15 قالب بندی رشته‌ها</a></li></ul></li><li><input type=checkbox id=section-ce9b5b1ec927bacdb2712b9c215a3ca1 class=toggle>
<label for=section-ce9b5b1ec927bacdb2712b9c215a3ca1 class=flex><a href=/chapter-2/ class=flex-auto>فصل دوم: مکانیزم‌های زبان</a></label><ul><li><a href=/chapter-2/pointer/>2.1 اشاره‌گر (Pointer)</a></li><li><a href=/chapter-2/struct/>2.2 ساختار (struct)</a></li><li><a href=/chapter-2/method/>2.3 متد (Method)</a></li><li><a href=/chapter-2/interface/>2.4 اینترفیس (Interface)</a></li><li><a href=/chapter-2/type-embedding/>2.5 جاسازی تایپ (type embedding)</a></li><li><a href=/chapter-2/error-handling/>2.6 مدیریت خطاها</a></li><li><a href=/chapter-2/casting-vs-conversion/>2.7 فرق casting با conversion</a></li></ul></li><li><input type=checkbox id=section-0691270142e95f82c4d2eb637f234afd class=toggle>
<label for=section-0691270142e95f82c4d2eb637f234afd class=flex><a href=/chapter-3/ class=flex-auto>فصل سوم: همزمانی (concurrency)</a></label><ul><li><a href=/chapter-3/go-concurrency/>3.1 آشنایی با همزمانی</a></li><li><a href=/chapter-3/goroutine/>3.2 گوروتین (goroutine)</a></li><li><a href=/chapter-3/go-sync-package/>3.3 پکیج sync</a></li><li><a href=/chapter-3/go-atomic/>3.4 پکیج atomic</a></li><li><a href=/chapter-3/goroutine-data-race/>3.5 آموزش مقابله با data race</a></li><li><a href=/chapter-3/go-channel/>3.6 کانال (channel)</a></li><li><a href=/chapter-3/go-select/>3.7 آموزش استفاده از select</a></li><li><a href=/chapter-3/go-context/>3.8 پکیج context</a></li><li><a href=/chapter-3/go-concurrency-teqniques/>3.9 تکنیک های همزمانی</a></li><li><a href=/chapter-3/go-concurrency-patterns/>3.10 الگو های همزمانی</a></li></ul></li><li><input type=checkbox id=section-59efe912b32b5b1290d5ec2dac84f441 class=toggle>
<label for=section-59efe912b32b5b1290d5ec2dac84f441 class=flex><a href=/chapter-4/ class=flex-auto>فصل چهارم: مباحث پیشرفته</a></label><ul><li><a href=/chapter-4/build-go-file/>4.1 آموزش Build پروژه</a></li><li><a href=/chapter-4/debugging-go-code/>4.2 آموزش کار با Debugging</a></li><li><a href=/chapter-4/go-mod/>4.3 آموزش کار با go mod</a></li><li><a href=/chapter-4/workspace/>4.4 آموزش کار با workspace</a></li><li><a href=/chapter-4/vendor/>4.5 آموزش کار با Vendor</a></li><li><a href=/chapter-4/command-line-go/>4.6 آموزش نوشتن برنامه command line</a></li><li><a href=/chapter-4/work-with-file-in-go/>4.7 آموزش کار با فایل</a></li><li><a href=/chapter-4/work-with-json-file-in-go/>4.8 آموزش کار با json</a></li><li><a href=/chapter-4/work-with-toml-file-in-go/>4.9 آموزش کار با toml</a></li><li><a href=/chapter-4/work-with-yaml-file-in-go/>4.10 آموزش کار با yaml</a></li><li><a href=/chapter-4/work-with-csv-file-in-go/>4.11 آموزش کار با csv</a></li><li><a href=/chapter-4/work-with-ini-file-in-go/>4.12 آموزش کار با ini</a></li><li><a href=/chapter-4/work-with-environment-variable/>4.13 آموزش کار با environment variable</a></li><li><a href=/chapter-4/go-regular-expressions/>4.14 آموزش کار با regexp</a></li><li><a href=/chapter-4/go-reflection/>4.15 آموزش reflection</a></li><li><a href=/chapter-4/go-generator/>4.16 آموزش generator</a></li><li><a href=/chapter-4/go-stringer/>4.17 آموزش stringer</a></li><li><a href=/chapter-4/effective-go/>4.18 تکنیک های کدنویسی زبان گو</a></li><li><a href=/chapter-4/go-commentry/>4.19 اصول کامنت نویسی</a></li><li><a href=/chapter-4/go-code-rules/>4.20 قوانین کدنویسی در گو</a></li><li><a href=/chapter-4/go-garbage-collector/>4.21 زباله جمع کن (garbage collector)</a></li><li><a href=/chapter-4/go-plugin/>4.22 کتابخانه Plugin</a></li><li><input type=checkbox id=section-687c92e06ed3c05242e60a3a1a266aa4 class=toggle>
<label for=section-687c92e06ed3c05242e60a3a1a266aa4 class=flex><a href=/chapter-4/oop/ class=flex-auto>4.23 شی گرایی در زبان گو</a></label><ul><li><a href=/chapter-4/oop/go-encapsulation/>4.23.1 کپسوله سازی (Encapsulation)</a></li><li><a href=/chapter-4/oop/go-inheritance/>4.22.2 ارث بری</a></li><li><a href=/chapter-4/oop/go-polymorphism/>4.23.3 پلی مورفیسم (Polymorphism)</a></li><li><a href=/chapter-4/oop/go-overriding/>4.23.4 overriding</a></li><li><a href=/chapter-4/oop/go-abstraction/>4.23.5 abstraction</a></li></ul></li><li><a href=/chapter-4/tracing/>4.24 آموزش tracing</a></li><li><a href=/chapter-4/profiling/>4.25 آموزش profiling</a></li><li><a href=/chapter-4/go-project-layout/>4.26 ساختار پروژه</a></li><li><a href=/chapter-4/go-io-package/>4.27 آموزش کار با پکیج io</a></li></ul></li><li><input type=checkbox id=section-134502b5358f6cf5c83ad497f832087a class=toggle>
<label for=section-134502b5358f6cf5c83ad497f832087a class=flex><a href=/chapter-5/ class=flex-auto>فصل پنجم: برنامه نویسی شبکه با گو</a></label><ul><li><a href=/chapter-5/network-basic/>5.1 شبکه چیست</a></li><li><a href=/chapter-5/go-tcp-server-begginer/>5.2 سرور tcp مقدماتی</a></li><li><a href=/chapter-5/go-tcp-server-advanced/>5.3 سرور tcp پیشرفته</a></li><li><a href=/chapter-5/go-udp-server-begginer/>5.4 سرور udp مقدماتی</a></li><li><a href=/chapter-5/go-udp-server-advanced/>5.5 سرور udp پیشرفته</a></li><li><a href=/chapter-5/go-http-server-begginer/>5.6 کتابخانه http سمت سرور مقدماتی</a></li><li><a href=/chapter-5/go-http-server-advanced/>5.7 کتابخانه http سمت سرور پیشرفته</a></li><li><a href=/chapter-5/go-http-client-begginer/>5.8 کتابخانه http سمت کلاینت مقدماتی</a></li><li><a href=/chapter-5/go-http-client-advanced/>5.9 کتابخانه http سمت کلاینت پیشرفته</a></li><li><a href=/chapter-5/go-quic-prtoocol/>5.10 پروتکل quic</a></li></ul></li><li><input type=checkbox id=section-6f78676abc6f42fefd423ea7de4e1c4d class=toggle>
<label for=section-6f78676abc6f42fefd423ea7de4e1c4d class=flex><a href=/chapter-6/ class=flex-auto>فصل ششم: ژنریک ها (Generics)</a></label><ul><li><a href=/chapter-6/go-generics-basic/>6.1 مقدمه و اهمیت ژنریک‌ها</a></li><li><a href=/chapter-6/go-generics-fundamentals/>6.2 مبانی ژنریک‌ها در Go</a></li><li><a href=/chapter-6/go-generics-syntax-and-structure/>6.3 سینتکس و ساختار ژنریک‌ها در Go</a></li><li><a href=/chapter-6/go-generics-type-sets-and-constraints/>6.4 Constraints و Type Sets</a></li><li><a href=/chapter-6/go-generics-examples-and-practical/>6.5 مثال‌ها و کاربردهای عملی ژنریک‌ها</a></li><li><a href=/chapter-6/comparing-generics/>6.6 مقایسه ژنریک‌ها با راهکارهای قبل از Go 1.18</a></li><li><a href=/chapter-6/limitations-errors-and-anti-patterns-in-generics/>6.7 محدودیت‌ها، خطاها و ضدالگوها در ژنریک‌ها</a></li><li><a href=/chapter-6/generics-best-practice/>6.8 بهترین شیوه‌های استفاده از ژنریک‌ها (Best Practices)</a></li><li><a href=/chapter-6/generics-advanced-examples-and-tips/>6.9 مثال‌های پیشرفته و نکات ویژه</a></li></ul></li><li><input type=checkbox id=section-8f5df719cb6867058bc4273b800e1879 class=toggle>
<label for=section-8f5df719cb6867058bc4273b800e1879 class=flex><a href=/chapter-7/ class=flex-auto>فصل هفتم: تست نویسی</a></label><ul><li><a href=/chapter-7/go-introduction-testing/>7.1 مقدمه‌ای بر تست در Go</a></li><li><a href=/chapter-7/go-unit-testing/>7.2 تست واحد (Unit Test)</a></li><li><a href=/chapter-7/go-table-driven-tests/>7.3 تست جدول‌محور (Table-Driven Test)</a></li><li><a href=/chapter-7/go-integration-testing/>7.4 تست یکپارچه (Integration Test)</a></li></ul></li><li><input type=checkbox id=section-46582e13a18a41adc7936c360b185ec8 class=toggle>
<label for=section-46582e13a18a41adc7936c360b185ec8 class=flex><a href=/chapter-8/ class=flex-auto>فصل هشتم: پکیج های استاندارد</a></label><ul></ul></li><li><input type=checkbox id=section-7b4fd75e0c8dddcfaf05d2809955458b class=toggle>
<label for=section-7b4fd75e0c8dddcfaf05d2809955458b class=flex><a href=/chapter-9/ class=flex-auto>فصل نهم: الگوهای طراحی</a></label><ul><li><input type=checkbox id=section-91fecfeb90059a6577f742161c3cc416 class=toggle>
<label for=section-91fecfeb90059a6577f742161c3cc416 class=flex><a href=/chapter-9/creational-patterns/ class=flex-auto>9.1 الگوهای طراحی سازنده</a></label><ul><li><a href=/chapter-9/creational-patterns/go-singleton-pattern/>9.1.1 الگو Singleton</a></li><li><a href=/chapter-9/creational-patterns/go-factory-method-pattern/>9.1.2 الگو Factory Method</a></li><li><a href=/chapter-9/creational-patterns/go-prototype-pattern/>9.1.3 الگو Prototype</a></li><li><a href=/chapter-9/creational-patterns/go-abstract-factory-pattern/>9.1.4 الگو Abstract Factory</a></li><li><a href=/chapter-9/creational-patterns/go-builder-pattern/>9.1.6 الگو Builder</a></li><li><a href=/chapter-9/creational-patterns/go-object-pool-pattern/>9.1.7 الگو Object Pool</a></li></ul></li><li><input type=checkbox id=section-0bf1b67244bd7a1b2067d73a9ac05c84 class=toggle>
<label for=section-0bf1b67244bd7a1b2067d73a9ac05c84 class=flex><a href=/chapter-9/structural-patterns/ class=flex-auto>9.2 الگوهای طراحی ساختاری</a></label><ul><li><a href=/chapter-9/structural-patterns/go-adaptor-pattern/>9.2.1 الگو Adaptor</a></li><li><a href=/chapter-9/structural-patterns/go-bridge-pattern/>9.2.2 الگو Bridge</a></li><li><a href=/chapter-9/structural-patterns/go-composite-pattern/>9.2.3 الگو Composite</a></li><li><a href=/chapter-9/structural-patterns/go-decorator-pattern/>9.2.1 الگو Decorator</a></li><li><a href=/chapter-9/structural-patterns/go-facade-pattern/>9.2.5 الگو Facade</a></li><li><a href=/chapter-9/structural-patterns/go-flyweight-pattern/>9.2.6 الگو Flyweight</a></li><li><a href=/chapter-9/structural-patterns/go-proxy-pattern/>9.2.7 الگو Proxy</a></li></ul></li><li><input type=checkbox id=section-67e202f99a50c1e49347339369c874b1 class=toggle>
<label for=section-67e202f99a50c1e49347339369c874b1 class=flex><a href=/chapter-9/behavioral-patterns/ class=flex-auto>9.3 الگوهای طراحی رفتاری</a></label><ul><li><a href=/chapter-9/behavioral-patterns/go-chain-of-responsibility-pattern/>9.3.1 الگو Chain Of Responsibility</a></li><li><a href=/chapter-9/behavioral-patterns/go-command-pattern/>9.3.2 الگو Command</a></li><li><a href=/chapter-9/behavioral-patterns/go-iterator-pattern/>9.3.3 الگو Iterator</a></li><li><a href=/chapter-9/behavioral-patterns/go-mediator-pattern/>9.3.4 الگو Mediator</a></li><li><a href=/chapter-9/behavioral-patterns/go-memento-pattern/>9.3.5 الگو Memento</a></li><li><a href=/chapter-9/behavioral-patterns/go-observer-pattern/>9.3.6 الگو Observer</a></li><li><a href=/chapter-9/behavioral-patterns/go-state-pattern/>9.3.7 الگو State</a></li><li><a href=/chapter-9/behavioral-patterns/go-strategy-pattern/>9.3.8 الگو Strategy</a></li><li><a href=/chapter-9/behavioral-patterns/go-template-method-pattern/>9.3.9 الگو Template Method</a></li><li><a href=/chapter-9/behavioral-patterns/go-visitor-pattern/>9.3.10 الگو Visitor</a></li></ul></li><li><input type=checkbox id=section-a8aa81f62696e9f9c69a81a3318a50eb class=toggle>
<label for=section-a8aa81f62696e9f9c69a81a3318a50eb class=flex><a href=/chapter-9/concurrency-patterns/ class=flex-auto>9.4 الگوهای همزمانی</a></label><ul><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-wait-for-result/>9.4.1 الگو Wait For Result</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-fan-out-in/>9.4.2 الگو Fan Out/In</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-wait-for-task/>9.4.3 الگو Wait For Task</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-worker-pool/>9.4.4 الگوی Worker Pool</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-drop/>9.4.5 الگو Drop</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-cancellation/>9.4.6 الگو Context Cancellation Pattern</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-semaphore/>9.4.7 الگو Semaphore</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-retry-timeout/>9.4.8 الگو Retry Timeout</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-producer-consumer/>9.4.9 الگو Producer-Consumer</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-monitor/>9.4.10 الگو Monitor</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-future/>9.4.11 الگو Future</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-pipeline/>9.4.12 الگو Pipeline</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-subscription/>9.4.13 الگو Subscription</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-brdige-channel/>9.4.14 الگو Bridge Channel</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-queuing/>9.4.15 الگو Queuing</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-ratelimit/>9.4.16 الگو Rate limit</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-deadlock-recovery/>9.4.17 الگو Deadlock Recovery</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-channel-cancellation/>9.4.18 الگو Channel Cancellation</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-lock-free-synchronization/>9.4.19 الگو Lock-free synchronization</a></li></ul></li><li><input type=checkbox id=section-d4428d0313ccb2e3380b00740324e064 class=toggle>
<label for=section-d4428d0313ccb2e3380b00740324e064 class=flex><a href=/chapter-9/cloud-native-patterns/ class=flex-auto>9.5 الگوهای Cloud Native</a></label><ul><li><a href=/chapter-9/cloud-native-patterns/go-cloud-native-circuit-breaker-pattern/>9.5.1 الگو Circuit Breaker</a></li><li><a href=/chapter-9/cloud-native-patterns/go-cloud-native-debounce-pattern/>9.5.2 الگو Debounce</a></li><li><a href=/chapter-9/cloud-native-patterns/go-cloud-native-retry-pattern/>9.5.3 الگو Retry</a></li><li><a href=/chapter-9/cloud-native-patterns/go-cloud-native-throttle-pattern/>9.5.4 الگو Throttle</a></li><li><a href=/chapter-9/cloud-native-patterns/go-cloud-native-timeout-pattern/>9.5.5 الگو Timeout</a></li></ul></li><li><input type=checkbox id=section-d2db70ad636838c12fc76435099656ac class=toggle>
<label for=section-d2db70ad636838c12fc76435099656ac class=flex><a href=/chapter-9/anti-pattern/ class=flex-auto>9.6 ضد الگوها (Anti-Patterns)</a></label><ul><li><a href=/chapter-9/anti-pattern/go-anti-patterns-in-syntax/>9.6.1 ضد الگو سینتکسی</a></li></ul></li><li><a href=/chapter-9/solid-principle-in-golang/>9.7 اصول SOLID</a></li></ul></li><li><input type=checkbox id=section-109a423730eebb4b9e804ab6e8dc6af0 class=toggle>
<label for=section-109a423730eebb4b9e804ab6e8dc6af0 class=flex><a href=/chapter-10/ class=flex-auto>فصل دهم: الگوریتم و ساختار داده</a></label><ul><li><a href=/chapter-10/10.1--data-structures-queue-stack-lists/>10.1 Data Structures (Queue Stack Lists)</a></li></ul></li><li><input type=checkbox id=section-0736842d303fef477d0a09e8de4a0d85 class=toggle>
<label for=section-0736842d303fef477d0a09e8de4a0d85 class=flex><a href=/chapter-11/ class=flex-auto>فصل یازدهم: معماری های نرم افزار</a></label><ul></ul></li><li><input type=checkbox id=section-efb5b19050ead65a76618516db266d2d class=toggle>
<label for=section-efb5b19050ead65a76618516db266d2d class=flex><a href=/chapter-12/ class=flex-auto>فصل دوازدهم: شبکه بلاکچین</a></label><ul><li><input type=checkbox id=section-ee81a41ef810f317eba2e67d447c0ec4 class=toggle>
<label for=section-ee81a41ef810f317eba2e67d447c0ec4 class=flex><a href=/chapter-12/blockchain/ class=flex-auto>12.1 بلاکچین</a></label><ul><li><a href=/chapter-12/blockchain/blockchain/>12.1.1 بلاکچین چیست</a></li><li><a href=/chapter-12/blockchain/blockchain-history/>12.1.2 تاریخچه بلاکچین</a></li><li><a href=/chapter-12/blockchain/blockchain-architecture/>12.1.3 معماری بلاکچین</a></li><li><a href=/chapter-12/blockchain/blockchain-type/>12.1.4 انواع بلاکچین</a></li><li><a href=/chapter-12/blockchain/blockchain-different-with-centerlized/>12.1.5 تفاوت سیستم متمرکز با غیرمتمرکز</a></li><li><a href=/chapter-12/blockchain/blockchain-scale/>12.1.6 مقیاس پذیری در بلاکچین</a></li><li><a href=/chapter-12/blockchain/blockchain-security/>12.1.7 امنیت در بلاکچین</a></li><li><a href=/chapter-12/blockchain/blockchain-cryptography/>12.1.8 مفاهیم رمزنگاری</a></li><li><a href=/chapter-12/blockchain/blockchain-consensus-algorithm/>12.1.10 الگوریتم اجماع (Consensus)</a></li><li><a href=/chapter-12/blockchain/blockchain-p2p-network/>12.1.11 ساختار و کاربرد شبکه P2P</a></li><li><a href=/chapter-12/blockchain/blockchain-data-management/>12.1.12 مدیریت داده در بلاکچین</a></li><li><a href=/chapter-12/blockchain/blockchain-network-testing/>12.1.13 تست پذیری شبکه</a></li><li><a href=/chapter-12/blockchain/blockchain-analyze-and-optimization/>12.1.14 ارزیابی و بهینه سازی شبکه</a></li><li><a href=/chapter-12/blockchain/blockchain-monitoring/>12.1.15 مانیتورینگ شبکه</a></li><li><a href=/chapter-12/blockchain/blockchain-forking/>12.1.16 استراتژی فورک ها</a></li><li><a href=/chapter-12/blockchain/blockchain-api-and-sdk/>12.1.17 پیاده سازی انواع API ها و SDK ها</a></li><li><a href=/chapter-12/blockchain/blockchain-keys-and-addresses/>12.1.18 کلیدها و آدرس ها</a></li><li><a href=/chapter-12/blockchain/blockchain-accounts/>12.1.19 اکانت ها</a></li><li><a href=/chapter-12/blockchain/blockchain-transactions-and-messages/>12.1.20 تراکنش ها و پیام ها</a></li><li><a href=/chapter-12/blockchain/blockchain-blocks/>12.1.21 بلوک ها (Blocks)</a></li><li><a href=/chapter-12/blockchain/blockchain-genesis/>12.1.22 جنسیس (Genesis)</a></li><li><a href=/chapter-12/blockchain/blockchain-smart-contracts/>12.1.23 قراردادهای هوشمند</a></li><li><a href=/chapter-12/blockchain/blockchain-privacy/>12.1.24 حریم خصوصی شبکه</a></li></ul></li><li><input type=checkbox id=section-3a22b13c7bb1ba964a59c01435868bd6 class=toggle>
<label for=section-3a22b13c7bb1ba964a59c01435868bd6 class=flex><a href=/chapter-12/bitcoin/ class=flex-auto>12.2 شبکه بیت کوین</a></label><ul><li><a href=/chapter-12/bitcoin/bitcoin/>12.2.1 معرفی بیت کوین</a></li><li><a href=/chapter-12/bitcoin/bitcoin-cryptography/>12.2.2 رمزنگاری در بیت کوین</a></li><li><a href=/chapter-12/bitcoin/bitcoin-addresses/>12.2.3 آدرس ها</a></li><li><a href=/chapter-12/bitcoin/bitcoin-transactions/>12.2.4 تراکنش ها</a></li><li><a href=/chapter-12/bitcoin/bitcoin-structure/>12.2.5 ساختار بلاکچین بیت کوین</a></li><li><a href=/chapter-12/bitcoin/bitcoin-consensus/>12.2.6 الگوریتم اجماع</a></li><li><a href=/chapter-12/bitcoin/bitcoin-miners/>12.2.7 ماینرها</a></li><li><a href=/chapter-12/bitcoin/bitcoin-network/>12.2.8 شبکه</a></li><li><a href=/chapter-12/bitcoin/bitcoin-wallets/>12.2.9 والت ها</a></li><li><a href=/chapter-12/bitcoin/bitcoin-in-real-world/>12.2.10 بیت کوین در دنیای واقعی</a></li><li><a href=/chapter-12/bitcoin/bitcoin-innovation/>12.2.11 نوآوری</a></li><li><a href=/chapter-12/bitcoin/bitcoin-clients/>12.2.12 کلاینت ها</a></li><li><a href=/chapter-12/bitcoin/bitcoin-programming/>12.2.13 برنامه نویسی در بیت کوین</a></li></ul></li><li><input type=checkbox id=section-b9f4acac44a727569ffab43028a36441 class=toggle>
<label for=section-b9f4acac44a727569ffab43028a36441 class=flex><a href=/chapter-12/ethereum/ class=flex-auto>12.3 شبکه اتریوم</a></label><ul><li><a href=/chapter-12/ethereum/ethereum/>12.3.1 معرفی اتریوم</a></li><li><a href=/chapter-12/ethereum/ethereum-cryptography/>12.3.2 رمزنگاری</a></li><li><a href=/chapter-12/ethereum/ethereum-keys-and-addresses/>12.3.3 آدرس ها و کلیدها</a></li><li><a href=/chapter-12/ethereum/ethereum-accounts/>12.3.4 اکانت ها</a></li><li><a href=/chapter-12/ethereum/ethereum-transactions-and-messages/>12.3.5 تراکنش ها و پیام ها</a></li><li><a href=/chapter-12/ethereum/ethereum-virtual-machine/>12.3.6 ماشین مجازی اتریوم</a></li><li><a href=/chapter-12/ethereum/ethereum-blocks/>12.3.7 بلاک ها</a></li><li><a href=/chapter-12/ethereum/ethereum-consensus/>12.3.8 الگوریتم اجماع</a></li><li><a href=/chapter-12/ethereum/ethereum-nodes-and-miners/>12.3.9 نودها و ماینرها</a></li><li><a href=/chapter-12/ethereum/ethereum-network/>12.3.10 شبکه</a></li><li><a href=/chapter-12/ethereum/ethereum-smart-contracts/>12.3.11 قراردادهای هوشمند</a></li><li><a href=/chapter-12/ethereum/ethereum-wallets-and-clients/>12.3.12 والت ها و کلاینت ها</a></li><li><a href=/chapter-12/ethereum/go-ethereum/>12.3.13 معرفی go-ethereum</a></li><li><a href=/chapter-12/ethereum/work-with-accounts/>12.3.14 کار با اکانت ها</a></li><li><a href=/chapter-12/ethereum/transactions-on-ethereum/>12.3.15 تراکنش برروی اتریوم</a></li><li><a href=/chapter-12/ethereum/read-write-in-smart-contracts/>12.3.16 نوشتن و ارتباط با قراردادهای هوشمند</a></li><li><a href=/chapter-12/ethereum/abi-and-bin-file/>12.3.17 آشنایی با فایل ABI و bytecode</a></li><li><a href=/chapter-12/ethereum/event-logs/>12.3.18 خواندن و دریافت لحظه ای لاگ های کانترکت ها</a></li><li><a href=/chapter-12/ethereum/signature/>12.3.19 ایجاد و تایید امضا</a></li><li><a href=/chapter-12/ethereum/geth/>12.3.20 کار با geth</a></li><li><a href=/chapter-12/ethereum/protocol-swarm-and-whisper/>12.3.21 کار با پروتکل whisper و swarm</a></li></ul></li><li><input type=checkbox id=section-71c1e946dcbe629ce566392c9ba8a5bd class=toggle>
<label for=section-71c1e946dcbe629ce566392c9ba8a5bd class=flex><a href=/chapter-12/pactus/ class=flex-auto>12.4 شبکه پکتوس</a></label><ul><li><a href=/chapter-12/pactus/pactus/>12.4.1 معرفی پکتوس</a></li><li><a href=/chapter-12/pactus/pactus-roadmap/>12.4.2 نقشه راه و اهداف</a></li><li><a href=/chapter-12/pactus/pactus-cryptography/>12.4.3 رمزنگاری</a></li><li><a href=/chapter-12/pactus/pactus-addresses-and-keys/>12.4.4 آدرس ها و کلیدها</a></li><li><a href=/chapter-12/pactus/pactus-accounts/>12.4.5 اکانت ها</a></li><li><a href=/chapter-12/pactus/pactus-transactions-and-messages/>12.4.6 تراکنش ها و پیغام ها</a></li><li><a href=/chapter-12/pactus/pactus-consensus/>12.4.7 الگوریتم اجماع</a></li><li><a href=/chapter-12/pactus/pactus-client/>12.4.8 کار با کلاینت</a></li><li><a href=/chapter-12/pactus/pactus-smart-contracts/>12.4.9 قراردادهای هوشمند (بزودی)</a></li></ul></li></ul></li></ul><a class="book-btn gray" href=https://github.com/GoFarsi/book>مخزن کتاب</a>
<a class=book-btn href=https://github.com/GoFarsi/book/blob/main/COUNTRIBUTING.md>مشارکت در کتاب زبان گو</a><center><p><img alt="GitHub Repo stars" src=https://img.shields.io/github/stars/GoFarsi/book> <img alt=GitHub src=https://img.shields.io/github/license/gofarsi/book> <img alt="GitHub contributors" src=https://img.shields.io/github/contributors/gofarsi/book></p></center></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>نمونه سوالات مصاحبه</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"></br><main><div class=wrapper><a href=https://t.me/GolangEngineers class="icon telegram" target=_blank><div class=tooltip>گروه تلگرامی مهندسین گولنگ</div><span><i class="fab fa-telegram"></i></span>
</a><a href=https://linkedin.com/in/Ja7ad class="icon linkedin" target=_blank><div class=tooltip>لینکدین نویسنده</div><span><i class="fab fa-linkedin"></i></span>
</a><a href=https://twitter.com/Ja7adR class="icon twitter" target=_blank><div class=tooltip>توییتر نویسنده</div><span><i class="fab fa-twitter"></i></span></a></div></main></br></br><nav id=TableOfContents></nav></aside></header><h1>نمونه سوالات مصاحبه</h1><article class="markdown book-article"><p>در این بخش ما یکسری سوالات مصاحبه به زبان فارسی ارائه دادیم که برای یافتن ضعف‌ها کاربردی می‌باشد.</p><details><summary>1: چه تایپ‌هایی مقدار zero آن‌ها nil است؟</summary><div class=markdown-inner><ul><li>interfaces</li><li>slices</li><li>channels</li><li>maps</li><li>pointers</li><li>functions</li></ul></div></details><details><summary>2: تایپ‌های نوع Reference؟</summary><div class=markdown-inner><ul><li>Pointers</li><li>slices</li><li>maps</li><li>functions</li><li>channels</li></ul></div></details><details><summary>3: تایپ‌های نوع Aggregate؟</summary><div class=markdown-inner><ul><li>Array</li><li>structs</li></ul></div></details><details><summary>4: چه وقت باید از پوینتر استفاده کنیم؟</summary><div class=markdown-inner><p><strong>1- تابعی که یکی از پارامترهای خود را تغییر می‌دهد</strong>
-وقتی تابعی را فراخوانی می‌کنیم که یک پوینتر را به عنوان پارامتر می‌گیرد، انتظار داریم که متغیر ما تغییر داده شود. اگر شما متغیر را در تابع خود تغییر نمی‌دهید، پس احتمالا نباید از پوینتر استفاده کنید.</p><p><strong>2- عملکرد بهتر</strong>
-اگر رشته‌ای داشته باشید که شامل یک رمان کامل در حافظه باشد، کپی کردن این متغیر هر بار که به یک تابع جدید ارسال می‌شود، کاری بسیار گران است. ممکن است ارزشمند باشد که به جای این کار یک پوینتر را ارسال کنید، که باعث صرفه‌جویی در پردازنده و حافظه می‌شود. با این حال انجام این کار به قیمت خوانا بودن است، بنابراین فقط در صورت لزوم این بهینه‌سازی را انجام دهید.</p><p><strong>3- به گزینه nil نیاز دارید</strong>
-گاهی اوقات یک تابع باید بداند که مقدار یک چیزی چیست، همچنین باید وجود یا عدم وجود آن را بداند. معمولا هنگام خواندن JSON از این استفاده می‌کنیم تا بدانیم فیلدی وجود دارد یا خیر.</p></div></details><details><summary>5: زبان گولنگ از چه قابلیت های معروف در زبان های دیگر پشتیبانی نمی‌کند؟</summary><div class=markdown-inner><ul><li>type inheritance</li><li>operator overloading</li><li>method overloading</li><li>pointer arithmetic</li><li>struct type in consts</li></ul></div></details><details><summary>6: برای گوروتین ها چه مواقعی از channel و چه مواقعی از mutex استفاده می شود؟</summary><div class=markdown-inner>معمولاً در مواقعی که گوروتین ها نیاز به برقراری ارتباط با یکدیگر دارند، از channels استفاده می کنیم. درصورتی که قسمتی از کد ما(برای مثال مقدار متغیری را تغییر می دهیم) که در آن واحد فقط باید یک گوروتین به آن دسترسی داشته باشد، از یک قفل مانند mutex استفاده می کنیم.</div></details><details><summary>7: تفاوت بین goroutine و thread را توضیح دهید.</summary><div class=markdown-inner>Goroutines سبک وزن هستند و دارای یک استک اولیه کوچک‌تر که به صورت پویا گسترش می‌یابد هستند همچنین مدیریت آنها توسط Go runtime و در سطح کاربر رخ میدهد ، این در حالی است که threads استک ثابت دارند و مدیریت آنها در سطح کرنل و توسط سیستم عامل صورت میگیرد .
Goroutines هم‌زمانی را در سطح زبان با استفاده از channelها مدیریت می‌کنند، در حالی که threads ممکن است نیاز به lockهای صریح داشته باشند. همچنین، سوئیچینگ بین goroutines کارایی بیشتری نسبت به thread switching دارد.</div></details><details><summary>8: توضیح دهید که interface در Golang چیست و چگونه می‌تواند مورد استفاده قرار گیرد.</summary><div class=markdown-inner>یک interface در Go یک نوع خاص است که مجموعه‌ای از method signatures را تعریف می‌کند. هر نوع داده‌ای که این متدها را پیاده‌سازی کند، می‌تواند به عنوان آن interface مورد استفاده قرار گیرد. این بدون نیاز به ارث بری صورت می‌گیرد و امکان داکتایپینگ را فراهم می‌کند.</div></details><details><summary>9: چطور می‌توانید memory leak در برنامه‌های نوشته شده به وسیله Golang را شناسایی و مدیریت کنید؟</summary><div class=markdown-inner>برای شناسایی memory leaks در Golang، می‌توان از ابزارهایی مانند pprof به همراه نمودارهای ساخته شده بر اساس heap dumps استفاده کرد. برای پیشگیری از memory leaks، باید دقت کرد که از داده‌ها به درستی استفاده شود، حافظه رزرو شده آزاد گردد و منابع بسته شوند هنگامی که دیگر نیازی به آنها نیست.</div></details><details><summary>10: در Golang چگونه می‌توانیم dependency management را انجام دهیم؟</summary><div class=markdown-inner>Golang از Go Modules برای مدیریت وابستگی‌ها استفاده می‌کند که به توسعه دهندگان امکان می‌دهد پروژه‌ها را به صورت مستقل از GOPATH راحت‌تر مدیریت کنند.
با استفاده از دستوراتی مانند <code>go mod init</code>, <code>go mod tidy</code> , <code>go mod vendor</code> می‌توان وابستگی‌های لازم برای پروژه را مدیریت کرد.</div></details><details><summary>11: چه زمانی یک channel در Golang باید با buffer مورد استفاده قرار گیرد؟</summary><div class=markdown-inner>یک channel با buffer زمانی مورد استفاده قرار گیرد که شما می‌خواهید ارتباطات بین goroutines را بدون ایجاد blocking فوری داشته باشید. این امر می‌تواند بازده کدها را در مواقعی که عملیات‌ها از لحاظ عملکرد اندکی نابرابر هستند، بهبود بخشد.</div></details><details><summary>12: توضیح دهید که defer statement چیست و چرا ممکن است از آن استفاده کنیم.</summary><div class=markdown-inner>Defer statement برای تضمین اجرای یک تابع مشخص، درست قبل از خارج شدن از تابع فعلی استفاده می‌شود. این برای راحتی در مدیریت منابع مثل بستن فایل‌ها و ارتباطات شبکه استفاده می‌شود که می‌خواهیم اطمینان حاصل کنیم که به‌درستی بسته خواهند شد.</div></details><details><summary>13: در Golang چگونه می‌توانید اطمینان حاصل کنید که یک goroutine نتیجه‌ای تولید می‌کند قبل از اینکه برنامه کار خود را به طور کامل متوقف کند؟</summary><div class=markdown-inner>برای اطمینان از اینکه یک goroutine کار خود را به اتمام برساند، معمولا از sync.WaitGroup برای همچین مدیریتی استفاده می‌کنیم. ساختار WaitGroup اجازه می‌دهد تا اصلی‌ترین goroutine صبر کند تا یک یا چند goroutines دیگر کار خود را تمام کنند.</div></details><details><summary>14: توضیح دهید که واحد ایزوله برای کد نویسی در Golang چیست (table-driven tests) و چرا مفید است.</summary><div class=markdown-inner>Table-driven tests شیوه‌ای برای نوشتن تست‌ها است که از جداول داده برای تعریف چندین case تست بهره می‌برد. این شیوه مفید است زیرا کد تست را می‌توان برای بسیاری از داده‌ها به راحتی توسعه داد و به خوبی سازماندهی می‌شود.</div></details><details><summary>15: چرا Go از ارث بری (inheritance) پشتیبانی نمی‌کند و از composition به عنوان جایگزین استفاده می‌کند؟</summary><div class=markdown-inner>Go ارث بری را پیاده‌سازی نمی‌کند زیرا می‌تواند پیچیده شود و معماری نرم‌افزار را سخت‌تر مدیریت کند. در عوض، از composition استفاده می‌کند که می‌تواند code reuse را تشویق کند و طراحی سیستم را ساده‌تر و ماژولارتر می‌کند.</div></details><details><summary>16: آیا در Golang می‌توان از polymorphism استفاده کرد؟ اگر بله، چگونه؟</summary><div class=markdown-inner>بله، در Go می‌توان از polymorphism استفاده کرد از طریق استفاده از interfaces. یک interface می‌تواند برای تعریف یک مجموعه از روش‌ها به کار رود و هر نوع که این روش‌ها را پیاده‌سازی کند به عنوان آن نوع interface شناخته شود.</div></details><details><summary>17: چه تفاوتی میان make و new در Golang وجود دارد؟</summary><div class=markdown-inner><code>make</code> در Go برای ایجاد sliceها، maps و channels استفاده می‌شود و یک ابجکت از نوع مورد نظر را با مقدار اولیه مشخصی برمی‌گرداند. از طرفی <code>new</code> یک pointer به یک ابجکت از یک نوع داده‌ای تعریف شده توسط کاربر را برمی‌گرداند که صفر اولیه شده است.</div></details><details><summary>18: متود (method) receivers در Golang چگونه کار می‌کند و تفاوت بین استفاده از pointer receiver و value receiver چیست؟</summary><div class=markdown-inner>Method receivers در Go اجازه می‌دهند تا روی نوع معینی از مقادیر عملیات انجام دهیم. استفاده از pointer receiver به ما اجازه می‌دهد تا تغییراتی که در method روی receiver اعمال می‌شوند را بر روی خود آبجکت اصلی اعمال کنیم، در حالیکه استفاده از value receiver یک کپی از مقدار را می‌گیرد و تغییرات او روی کپی صورت می‌گیرد و بر آبجکت اصلی اثر نمی‌گذارد.</div></details><details><summary>19: چگونه می‌توان در Golang یک پکیج اختصاصی ایجاد کرد و چگونه می‌توان آن را در دیگر فایل‌های Go مورد استفاده قرار داد؟</summary><div class=markdown-inner>برای ایجاد پکیج اختصاصی در Go، کد مربوطه باید در یک دایرکتوری قرار داده شود و بالای فایل‌های Go باید <code>package mypackage</code> تعریف شود. برای استفاده از پکیج، <code>import "path/to/mypackage"</code> باید در دیگر فایل‌ها قرار داده شود.</div></details><details><summary>20: در Golang، چگونه می‌توانید error handling را اجرا کنید و چه روش‌هایی برای پیاده‌سازی custom error types وجود دارد؟</summary><div class=markdown-inner>Error handling در Go اغلب از طریق بازگرداندن ارور از توابع و بررسی آنها انجام می‌شود. برای ایجاد custom error types، می‌توانید از <code>errors.New()</code> برای ایجاد یک ارور ساده استفاده کنید یا یک تایپ که ارور را پیاده‌سازی می‌کند با متدهای اضافی برای داده‌های اضافی مرتبط با ارور ایجاد کرد.</div></details><details><summary>21: کامپایلر گولنگ از نوع AOT است یا JIT؟ تفاوت بین AOT و JIT را بگو.</summary><div class=markdown-inner>کامپایلر گو یک Ahead Of Time compilation است. تفاوت AOT با JIT در این است که کامپایلر های AOT مستقیم کد ما را تبدیل به machine code می کنند اما در کامپایتر های JIT کد ما تبدیل به یک کد میانی Bytecode می شود و در زمان اجرا توسط runtime engine هر قسمت از برنامه که مورد استفاده قرار می گیرد، تفسیر می شود و تبدیل به machine code می شود.</div></details><details><summary>22: تفاوت بین nil و مقدار صفر در انواع داده چیست؟</summary><div class=markdown-inner>در Go مقدار <strong>nil</strong> مخصوص انواع reference است (مانند slice, map, channel, function, pointer, interface) و به معنای عدم وجود داده یا ارجاع است.
مقدار صفر (zero value) برای انواع مقداری مانند int، bool، struct و غیره تعریف می‌شود (مثلاً 0 برای int یا false برای bool) و همیشه یک مقدار معتبر است.</div></details><details><summary>23: تفاوت بین close(channel) و خواندن از یک کانال بسته چیست؟</summary><div class=markdown-inner><ul><li><code>close(channel)</code> تنها برای ارسال‌کننده استفاده می‌شود تا به دریافت‌کننده‌ها اطلاع دهد داده‌ای دیگر ارسال نخواهد شد.</li><li>خواندن از یک کانال بسته مقدار صفر نوع داده را برمی‌گرداند بدون این که بلاک شود.</li><li>ارسال روی کانال بسته <strong>panic</strong> ایجاد می‌کند.</li></ul></div></details><details><summary>24: چه زمانی باید از context استفاده کنیم؟</summary><div class=markdown-inner>زمانی که نیاز داریم پردازش‌ها یا درخواست‌های طولانی را لغو کنیم یا timeout بگذاریم، از <code>context.Context</code> استفاده می‌کنیم. این ابزار برای همگام‌سازی لغو عملیات بین goroutineها و جلوگیری از resource leak بسیار مهم است.</div></details><details><summary>25: تفاوت sync.Mutex و sync.RWMutex چیست؟</summary><div class=markdown-inner><ul><li><code>sync.Mutex</code> قفل ساده‌ای است که در یک زمان فقط اجازه دسترسی به یک goroutine را می‌دهد.</li><li><code>sync.RWMutex</code> دو حالت دارد: قفل خواندن (می‌تواند همزمان توسط چند goroutine گرفته شود) و قفل نوشتن (انحصاری). این باعث بهبود عملکرد در سناریوهایی با خواندن زیاد و نوشتن کم می‌شود.</li></ul></div></details><details><summary>26: data race چیست و چگونه می‌توان از آن جلوگیری کرد؟</summary><div class=markdown-inner><strong>Data race</strong> زمانی رخ می‌دهد که چند goroutine همزمان به یک متغیر مشترک دسترسی پیدا کرده و حداقل یکی از آنها عملیات نوشتن انجام دهد، بدون هماهنگ‌سازی مناسب.
جلوگیری: استفاده از <code>sync.Mutex</code>، <code>sync.RWMutex</code>، channelها یا اجتناب از اشتراک داده‌ها. ابزار <code>go run -race</code> می‌تواند این مشکلات را پیدا کند.</div></details><details><summary>27: در چه شرایطی slice باعث memory leak می‌شود؟</summary><div class=markdown-inner>زمانی که slice‌ای کوچک ایجاد می‌کنیم ولی همچنان به یک آرایه بزرگ‌تر در حافظه اشاره دارد، GC نمی‌تواند آرایه اصلی را آزاد کند. راه‌حل: ایجاد یک کپی slice جدید با <code>copy</code> یا ساختن slice از ابتدا.</div></details><details><summary>28: تفاوت len و cap در slice چیست؟</summary><div class=markdown-inner><ul><li><code>len</code> تعداد عناصر موجود در slice را برمی‌گرداند.</li><li><code>cap</code> ظرفیت slice را برمی‌گرداند، یعنی تعداد عناصر از اندیس صفر تا انتهای آرایه زیرین که می‌توان بدون تخصیص حافظه جدید استفاده کرد.</li></ul></div></details><details><summary>29: آیا map در Go thread-safe است؟</summary><div class=markdown-inner>خیر. map به صورت پیش‌فرض thread-safe نیست و دسترسی همزمان بدون قفل یا sync.Map باعث panic می‌شود. برای ایمنی، باید از <code>sync.Mutex</code>، <code>sync.RWMutex</code> یا <code>sync.Map</code> استفاده کرد.</div></details><details><summary>30: چگونه می‌توان یک panic را مدیریت کرد بدون اینکه برنامه متوقف شود؟</summary><div class=markdown-inner><p>با استفاده از <code>recover</code> در داخل یک defer می‌توان panic را گرفتن و از توقف کامل برنامه جلوگیری کرد:</p><pre><code class=language-go>defer func() {
    if r := recover(); r != nil {
        fmt.Println(&quot;Recovered:&quot;, r)
    }
}()
</code></pre></div></details><details><summary>31: تفاوت بین unbuffered و buffered channel چیست؟</summary><div class=markdown-inner><ul><li><strong>Unbuffered channel</strong>: ارسال‌کننده تا زمانی که دریافت‌کننده آماده نباشد بلاک می‌شود.</li><li><strong>Buffered channel</strong>: ارسال‌کننده می‌تواند تا ظرفیت کانال داده بفرستد بدون بلاک شدن. دریافت‌کننده فقط زمانی بلاک می‌شود که کانال خالی باشد.</li></ul></div></details><details><summary>32: چرا نباید از pointer به متغیر loop variable در goroutine استفاده کرد؟</summary><div class=markdown-inner>چون همه goroutineها به همان آدرس حافظه اشاره می‌کنند که مقدار آن در هر iteration تغییر می‌کند و باعث نتایج غیرمنتظره می‌شود. باید از یک متغیر محلی کپی‌شده استفاده کرد.</div></details><details><summary>33: تفاوت := و var در تعریف متغیر چیست؟</summary><div class=markdown-inner><ul><li><code>:=</code> فقط در داخل توابع و برای تعریف و مقداردهی اولیه استفاده می‌شود.</li><li><code>var</code> در هر جایی (داخل یا بیرون تابع) می‌تواند استفاده شود و امکان تعریف بدون مقدار اولیه (با مقدار صفر) را می‌دهد.</li></ul></div></details><details><summary>34: چه زمانی باید از sync.Once استفاده کنیم؟</summary><div class=markdown-inner>زمانی که می‌خواهیم یک قطعه کد فقط یک‌بار در کل طول عمر برنامه اجرا شود (مثل بارگذاری تنظیمات یا ایجاد اتصال اولیه).</div></details><details><summary>35: تفاوت nil interface و interface حاوی nil چیست؟</summary><div class=markdown-inner><ul><li><strong>nil interface</strong>: مقدار و نوع هر دو nil هستند.</li><li><strong>interface حاوی nil</strong>: نوع مشخص شده است ولی مقدار nil است. این تفاوت باعث می‌شود مقایسه مستقیم با nil نتیجه متفاوتی بدهد.</li></ul></div></details><details><summary>36: آیا گوروتین‌ها به صورت موازی اجرا می‌شوند یا همزمانی (Concurrency) دارند؟</summary><div class=markdown-inner>گوروتین‌ها ذاتاً همزمانی دارند و Go scheduler آنها را روی چندین thread اجرا می‌کند. اگر سیستم چند هسته‌ای باشد و <code>GOMAXPROCS</code> متناسب تنظیم شده باشد، گوروتین‌ها می‌توانند موازی اجرا شوند.</div></details><details><summary>37: تفاوت rune و byte چیست؟</summary><div class=markdown-inner><ul><li><code>byte</code> معادل <code>uint8</code> است و برای نمایش داده‌های خام یا کاراکترهای ASCII استفاده می‌شود.</li><li><code>rune</code> معادل <code>int32</code> است و برای نمایش یک کاراکتر یونیکد استفاده می‌شود.</li></ul></div></details><details><summary>38: چرا استفاده بیش از حد از defer می‌تواند بر عملکرد تأثیر بگذارد؟</summary><div class=markdown-inner>هر <code>defer</code> یک فراخوانی اضافه ایجاد می‌کند که در خروج از تابع اجرا می‌شود. در مسیرهای پر فراخوانی (hot path)، این می‌تواند باعث افت کارایی شود. در این موارد بهتر است منابع را به صورت دستی آزاد کرد.</div></details><details><summary>39: garbage collector در Go چه زمانی اجرا می‌شود؟</summary><div class=markdown-inner>GC در Go به صورت خودکار و همزمان با اجرای برنامه، بر اساس تخصیص حافظه و فشار heap اجرا می‌شود. این فرآیند stop-the-world بسیار کوتاهی دارد تا حافظه غیرقابل دسترسی را آزاد کند.</div></details><details><summary>40: آیا slice به صورت مقادیر (value) پاس داده می‌شود یا ارجاع (reference)؟</summary><div class=markdown-inner>Slice خود یک ساختار کوچک است (pointer به آرایه، طول و ظرفیت) که به صورت value پاس داده می‌شود، ولی اشاره‌گر داخل آن باعث می‌شود به آرایه زیرین ارجاع دهد.</div></details><details><summary>41: چه زمانی استفاده از map به جای slice بهینه‌تر است؟</summary><div class=markdown-inner>وقتی که نیاز به دسترسی سریع بر اساس کلیدهای غیر ترتیبی داریم یا جستجوی O(1) می‌خواهیم. در مقابل، slice برای داده‌های ترتیبی کوچک و قابل پیمایش سریع‌تر است.</div></details><details><summary>42: چگونه می‌توان ظرفیت اولیه یک map را تعیین کرد و چرا این کار مهم است؟</summary><div class=markdown-inner>با استفاده از <code>make(map[KeyType]ValueType, initialCapacity)</code> می‌توان ظرفیت اولیه تعیین کرد. این باعث کاهش عملیات rehash و بهبود عملکرد می‌شود.</div></details><details><summary>43: تفاوت select بدون case و select با default چیست؟</summary><div class=markdown-inner><ul><li><code>select {}</code> بدون case باعث بلاک شدن دائمی گوروتین می‌شود.</li><li><code>select { default: ... }</code> بلافاصله default را اجرا می‌کند اگر هیچ کانالی آماده نباشد.</li></ul></div></details><details><summary>44: چرا باید منابع مانند فایل یا connection را در defer بلافاصله بعد از ایجاد آن ببندیم؟</summary><div class=markdown-inner>این کار تضمین می‌کند که حتی در صورت بروز خطا یا panic، منبع به درستی آزاد شود و از resource leak جلوگیری شود.</div></details><details><summary>45: تفاوت channel جهت‌دار (send-only/receive-only) با channel دوطرفه چیست؟</summary><div class=markdown-inner><ul><li>Send-only: <code>chan&lt;- T</code> فقط اجازه ارسال دارد.</li><li>Receive-only: <code>&lt;-chan T</code> فقط اجازه دریافت دارد.</li><li>دوطرفه: <code>chan T</code> می‌تواند هم ارسال و هم دریافت انجام دهد.</li></ul></div></details><details><summary>46: چگونه می‌توان benchmark در Go نوشت و اجرا کرد؟</summary><div class=markdown-inner>با نوشتن تابع‌هایی با امضای <code>func BenchmarkXxx(b *testing.B)</code> و اجرای <code>go test -bench=.</code> می‌توان benchmark گرفت. مقدار <code>b.N</code> مشخص می‌کند چند بار تست اجرا می‌شود.</div></details><details><summary>47: sync.Pool چیست و چه کاربردی دارد؟</summary><div class=markdown-inner><code>sync.Pool</code> یک ساختار برای ذخیره و بازیابی موقت اشیاء قابل استفاده مجدد است که فشار روی GC را کاهش می‌دهد. برای داده‌های موقتی که ایجادشان هزینه‌بر است استفاده می‌شود.</div></details><details><summary>48: تفاوت testing.T و testing.B در پکیج testing چیست؟</summary><div class=markdown-inner><ul><li><code>testing.T</code> برای تست‌های معمولی و مدیریت خطاها استفاده می‌شود.</li><li><code>testing.B</code> برای benchmark استفاده می‌شود و شامل حلقه اجرای تکرارها (<code>b.N</code>) است.</li></ul></div></details><details><summary>49: آیا Go از tail call optimization پشتیبانی می‌کند؟</summary><div class=markdown-inner>خیر، Go به صورت رسمی tail call optimization ندارد. بنابراین توابع بازگشتی عمیق می‌توانند منجر به مصرف زیاد stack شوند.</div></details><details><summary>50: چه تفاوتی بین make و append برای ایجاد slice وجود دارد؟</summary><div class=markdown-inner><ul><li><code>make</code> یک slice با طول و ظرفیت مشخص ایجاد می‌کند.</li><li><code>append</code> برای افزودن عناصر به slice موجود استفاده می‌شود و در صورت پر بودن ظرفیت، یک آرایه جدید ایجاد می‌کند.</li></ul></div></details><details><summary>51: تفاوت بین زمان‌بندی گوروتین‌ها در Go و threadها در سیستم‌عامل چیست؟</summary><div class=markdown-inner>Scheduler گوروتین‌ها در Go به صورت <strong>M:N</strong> کار می‌کند، یعنی تعداد زیادی گوروتین (M) روی تعداد محدودی thread سیستم‌عامل (N) نگاشت می‌شوند. این مدل سبک‌تر از زمان‌بندی مستقیم threadها توسط سیستم‌عامل است.</div></details><details><summary>52: آیا استفاده از global variable در Go توصیه می‌شود؟ چرا؟</summary><div class=markdown-inner>به طور کلی خیر، چون باعث کاهش تست‌پذیری، افزایش coupling و خطر data race می‌شود. در صورت نیاز، باید با قفل یا سایر روش‌های همگام‌سازی محافظت شود.</div></details><details><summary>53: چرا تغییر دادن slice در یک goroutine می‌تواند روی goroutineهای دیگر تأثیر بگذارد؟</summary><div class=markdown-inner>چون همه sliceها به یک آرایه زیرین اشاره می‌کنند. تغییر عناصر باعث تغییر در آرایه مشترک و در نتیجه مشاهده تغییرات توسط سایر goroutineها می‌شود.</div></details><details><summary>54: تفاوت string و []byte در Go چیست؟</summary><div class=markdown-inner><code>string</code> غیرقابل تغییر (immutable) است و تغییر مستقیم آن ممکن نیست. <code>[]byte</code> قابل تغییر است و برای عملیات پردازشی روی داده‌ها بهینه‌تر است.</div></details><details><summary>55: چرا map در Go iteration order ثابت ندارد؟</summary><div class=markdown-inner>برای جلوگیری از وابستگی برنامه‌ها به ترتیب کلیدها و بهبود کارایی، Go عمداً ترتیب پیمایش map را تصادفی می‌کند.</div></details><details><summary>56: چه زمانی باید از atomic operations استفاده کرد؟</summary><div class=markdown-inner>زمانی که نیاز به عملیات خواندن/نوشتن thread-safe روی انواع عددی یا آدرس حافظه داریم، بدون استفاده از قفل‌های سنگین مانند Mutex. پکیج <code>sync/atomic</code> برای این منظور استفاده می‌شود.</div></details><details><summary>57: تفاوت nil slice با empty slice چیست؟</summary><div class=markdown-inner><ul><li>Nil slice: <code>nil</code> است، طول و ظرفیت صفر دارد.</li><li>Empty slice: مقدار غیر nil با طول صفر است، ولی به یک آرایه صفر‌ظرفیت اشاره می‌کند.</li></ul></div></details><details><summary>58: چرا استفاده از pointer receiver برای struct بزرگ بهینه‌تر است؟</summary><div class=markdown-inner>چون از کپی شدن struct بزرگ جلوگیری می‌کند و تغییرات در method روی نمونه اصلی اعمال می‌شود.</div></details><details><summary>59: تفاوت fallthrough در switch چیست؟</summary><div class=markdown-inner>در Go، caseها به طور پیش‌فرض break می‌شوند. استفاده از <code>fallthrough</code> باعث می‌شود اجرای case بعدی بدون بررسی شرط ادامه یابد.</div></details><details><summary>60: چرا باید بعد از استفاده از ticker آن را متوقف کنیم؟</summary><div class=markdown-inner>عدم توقف (<code>ticker.Stop()</code>) باعث نشت منابع و ادامه کار goroutine داخلی آن می‌شود.</div></details><details><summary>61: تفاوت new و literal برای struct چیست؟</summary><div class=markdown-inner><ul><li><code>new(T)</code> یک pointer به مقدار صفر نوع T برمی‌گرداند.</li><li><code>&amp;T{}</code> نیز یک pointer می‌سازد ولی می‌توان فیلدها را مقداردهی کرد.</li></ul></div></details><details><summary>62: چرا حلقه for range روی map ممکن است نتیجه متفاوتی در هر اجرا بدهد؟</summary><div class=markdown-inner>چون ترتیب پیمایش map در Go عمداً تصادفی است تا از وابستگی برنامه به ترتیب کلیدها جلوگیری شود.</div></details><details><summary>63: تفاوت deep copy و shallow copy در Go چیست؟</summary><div class=markdown-inner><ul><li>Shallow copy فقط مقادیر سطح اول را کپی می‌کند و referenceها همچنان مشترک می‌مانند.</li><li>Deep copy تمام داده‌ها را بازگشتی کپی می‌کند تا هیچ اشتراک حافظه وجود نداشته باشد.</li></ul></div></details><details><summary>64: چه زمانی باید از select با context.Done استفاده کنیم؟</summary><div class=markdown-inner>وقتی که می‌خواهیم عملیات منتظر روی channel را در صورت لغو context یا timeout متوقف کنیم.</div></details><details><summary>65: تفاوت بین runtime.GOMAXPROCS و تعداد گوروتین‌ها چیست؟</summary><div class=markdown-inner><code>GOMAXPROCS</code> حداکثر تعداد threadهای همزمانی که می‌توانند کد Go اجرا کنند را مشخص می‌کند، ولی تعداد گوروتین‌ها می‌تواند بسیار بیشتر باشد و توسط scheduler مدیریت می‌شود.</div></details><details><summary>66: چرا string در Go غیرقابل تغییر است؟</summary><div class=markdown-inner>برای بهینه‌سازی عملکرد و امنیت، string به داده‌های فقط خواندنی اشاره می‌کند. این طراحی اجازه می‌دهد رشته‌ها را به‌طور ایمن بین goroutineها به اشتراک گذاشت بدون نیاز به قفل.</div></details><details><summary>67: تفاوت بین time.Sleep و استفاده از time.After چیست؟</summary><div class=markdown-inner><ul><li><code>time.Sleep</code> اجرای گوروتین را برای مدت مشخص متوقف می‌کند.</li><li><code>time.After</code> یک channel برمی‌گرداند که بعد از گذشت مدت زمان مشخص سیگنال ارسال می‌کند و می‌تواند در <code>select</code> استفاده شود.</li></ul></div></details><details><summary>68: چرا نباید از panic برای کنترل جریان عادی برنامه استفاده کرد؟</summary><div class=markdown-inner>panic برای شرایط غیرمنتظره و خطاهای بحرانی طراحی شده است. استفاده از آن در منطق عادی باعث سختی در خواندن کد، مشکلات تست و مدیریت منابع می‌شود.</div></details><details><summary>69: sync.Cond چیست و چه زمانی استفاده می‌شود؟</summary><div class=markdown-inner><code>sync.Cond</code> ابزاری برای هماهنگ‌سازی پیشرفته است که به goroutineها اجازه می‌دهد تا تا زمان برآورده شدن یک شرط منتظر بمانند و توسط دیگر goroutineها بیدار شوند.</div></details><details><summary>70: تفاوت بین context.Background و context.TODO چیست؟</summary><div class=markdown-inner><ul><li><code>context.Background</code> برای شروع زنجیره context در برنامه‌های سطح بالا استفاده می‌شود.</li><li><code>context.TODO</code> زمانی استفاده می‌شود که هنوز مشخص نیست چه contextی باید استفاده شود یا در حال توسعه هستیم.</li></ul></div></details><details><summary>71: چرا mapهای بزرگ می‌توانند باعث فشار روی GC شوند؟</summary><div class=markdown-inner>چون map ممکن است مقادیر زیادی حافظه تخصیص دهد و GC باید همه کلیدها و مقادیر را بررسی کند. حذف مقادیر غیرضروری یا بازسازی map می‌تواند فشار را کاهش دهد.</div></details><details><summary>72: تفاوت بین کانال بسته و nil channel چیست؟</summary><div class=markdown-inner><ul><li>کانال بسته: خواندن از آن مقدار صفر و وضعیت بسته بودن را برمی‌گرداند. ارسال روی آن panic ایجاد می‌کند.</li><li>nil channel: هر عملیات ارسال یا دریافت روی آن برای همیشه بلاک می‌شود.</li></ul></div></details><details><summary>73: چرا استفاده از range روی string با کاراکترهای یونیکد خاص می‌تواند کند باشد؟</summary><div class=markdown-inner>زیرا Go هر بار کاراکترها را به صورت rune دیکد می‌کند که شامل تبدیل UTF-8 به int32 است. برای داده‌های ASCII این تبدیل سریع‌تر است.</div></details><details><summary>74: چه زمانی باید از copy برای slice استفاده کنیم؟</summary><div class=markdown-inner>وقتی که می‌خواهیم داده‌ها را از یک slice به دیگری منتقل کنیم بدون اینکه به آرایه زیرین مشترک اشاره کنند، مخصوصاً برای جلوگیری از مشکلات memory leak یا تغییرات ناخواسته.</div></details><details><summary>75: تفاوت بین defer با تابع معمولی در مدیریت منابع چیست؟</summary><div class=markdown-inner><code>defer</code> تضمین می‌کند که تابع در پایان محدوده اجرا شود، حتی در صورت panic یا بازگشت زودهنگام، ولی تابع معمولی بلافاصله اجرا می‌شود.</div></details><details><summary>76: چرا نباید روی کانال nil عملیات انجام داد؟</summary><div class=markdown-inner>هر ارسال یا دریافت روی کانال nil باعث بلاک شدن بی‌پایان goroutine می‌شود، که معمولاً به صورت ناخواسته deadlock ایجاد می‌کند.</div></details><details><summary>77: تفاوت بین append به slice و append به nil slice چیست؟</summary><div class=markdown-inner>هر دو معتبر هستند. append به nil slice باعث ایجاد slice جدید با ظرفیت مورد نیاز می‌شود.</div></details><details><summary>78: چرا حلقه‌های for بدون شرط در Go می‌توانند مشکل‌ساز شوند؟</summary><div class=markdown-inner>یک حلقه <code>for {}</code> بدون شرط توقف می‌تواند CPU را ۱۰۰٪ مشغول کند مگر اینکه شامل عملیات بلاک‌کننده یا sleep باشد.</div></details><details><summary>79: sync.Map چه مزیتی نسبت به map با Mutex دارد؟</summary><div class=markdown-inner><code>sync.Map</code> برای سناریوهایی با خواندن زیاد و نوشتن کم بهینه‌سازی شده و نیازی به قفل دستی ندارد، ولی در همه موارد سریع‌تر از map+Mutex نیست.</div></details><details><summary>80: چرا تبدیل بین []byte و string در Go معمولاً باعث کپی می‌شود؟</summary><div class=markdown-inner>برای جلوگیری از تغییر داده‌های string (که immutable است)، Go معمولاً داده‌ها را کپی می‌کند. این رفتار هزینه زمانی و حافظه دارد.</div></details><details><summary>81: چرا استفاده از time.Tick بدون توقف می‌تواند memory leak ایجاد کند؟</summary><div class=markdown-inner><code>time.Tick</code> یک channel بازگشتی ایجاد می‌کند که هرگز متوقف نمی‌شود. برای جلوگیری از نشت منابع، بهتر است از <code>time.NewTicker</code> استفاده کرده و در زمان مناسب <code>Stop()</code> را فراخوانی کنید.</div></details><details><summary>82: تفاوت بین interface خالی و interface با متد چیست؟</summary><div class=markdown-inner><ul><li>Interface خالی (<code>interface{}</code>) می‌تواند هر نوعی را نگه دارد.</li><li>Interface با متدها فقط می‌تواند نوع‌هایی را نگه دارد که تمام متدهای تعریف‌شده را پیاده‌سازی کرده باشند.</li></ul></div></details><details><summary>83: چرا استفاده از goroutine در حلقه for بدون همگام‌سازی می‌تواند مشکل‌ساز باشد؟</summary><div class=markdown-inner>چون متغیرهای حلقه بین goroutineها به اشتراک گذاشته می‌شوند و مقدارشان در زمان اجرا ممکن است تغییر کند. باید متغیر را به صورت محلی کپی یا با آرگومان به goroutine پاس داد.</div></details><details><summary>84: تفاوت بین make برای map و literal map چیست؟</summary><div class=markdown-inner><ul><li><code>make(map[Key]Value, cap)</code> ظرفیت اولیه را مشخص می‌کند.</li><li>Literal map (<code>map[Key]Value{...}</code>) بلافاصله داده‌ها را مقداردهی می‌کند.</li></ul></div></details><details><summary>85: چرا نباید روی کانالی که چند تولیدکننده دارد بدون هماهنگی close انجام داد؟</summary><div class=markdown-inner>چون ممکن است چند goroutine همزمان تلاش به بستن کانال کنند که باعث panic می‌شود. معمولاً فقط یک تولیدکننده مسئول close است.</div></details><details><summary>86: تفاوت بین string literal با backtick و با quote چیست؟</summary><div class=markdown-inner><ul><li>با quote (<code>"..."</code>): رشته escape می‌شود و می‌توان از <code>\n</code> و غیره استفاده کرد.</li><li>با backtick (<code>`...`</code>): رشته raw است و escape interpretation انجام نمی‌شود.</li></ul></div></details><details><summary>87: چرا garbage collector نمی‌تواند فایل‌های باز را ببندد؟</summary><div class=markdown-inner>GC فقط حافظه را آزاد می‌کند، ولی منابع سیستم‌عاملی مثل فایل‌ها یا socketها را باید به صورت صریح با <code>Close()</code> آزاد کرد.</div></details><details><summary>88: تفاوت بین untyped constant و typed constant چیست؟</summary><div class=markdown-inner><ul><li>Untyped constant می‌تواند با هر نوع سازگار استفاده شود تا زمانی که مقدارش در محدوده باشد.</li><li>Typed constant نوع مشخص دارد و فقط با همان نوع یا نوع‌های سازگار استفاده می‌شود.</li></ul></div></details><details><summary>89: چرا استفاده از recover خارج از defer بی‌اثر است؟</summary><div class=markdown-inner>چون <code>recover</code> فقط زمانی panic را می‌گیرد که درون یک defer اجرا شود که در همان گوروتین panic اتفاق افتاده باشد.</div></details><details><summary>90: تفاوت بین range روی slice و روی array چیست؟</summary><div class=markdown-inner><ul><li>روی slice: مقدار و اندیس عناصر slice را برمی‌گرداند.</li><li>روی array: مشابه slice، ولی آرایه به صورت کامل پاس داده می‌شود که می‌تواند هزینه‌بر باشد مگر اینکه با reference پاس شود.</li></ul></div></details><details><summary>91: چرا capacity slice بعد از append ممکن است چند برابر شود؟</summary><div class=markdown-inner>برای بهینه‌سازی تخصیص حافظه، Go هنگام نیاز به افزایش ظرفیت معمولاً آن را به صورت نمایی (دو برابر یا بیشتر) افزایش می‌دهد.</div></details><details><summary>92: تفاوت بین runtime.Gosched و time.Sleep چیست؟</summary><div class=markdown-inner><ul><li><code>runtime.Gosched</code> به scheduler اجازه می‌دهد گوروتین‌های دیگر را اجرا کند بدون توقف زمان مشخص.</li><li><code>time.Sleep</code> گوروتین را برای مدت مشخص متوقف می‌کند.</li></ul></div></details><details><summary>93: چرا nil pointer در method receiver ممکن است باعث panic نشود؟</summary><div class=markdown-inner>اگر متد به فیلد یا داده‌ای از struct دسترسی نداشته باشد، حتی اگر receiver nil باشد، panic ایجاد نمی‌شود.</div></details><details><summary>94: تفاوت بین map[string]struct{} و map[string]bool چیست؟</summary><div class=markdown-inner><ul><li><code>map[string]struct{}</code> حافظه کمتری مصرف می‌کند چون struct خالی صفر بایت است.</li><li><code>map[string]bool</code> نیاز به یک بایت برای مقدار دارد.</li></ul></div></details><details><summary>95: چرا استفاده از for-select بدون default می‌تواند کارایی را کاهش دهد؟</summary><div class=markdown-inner>چون گوروتین بلاک می‌ماند تا یکی از caseها آماده شود، که ممکن است باعث استفاده ناکارآمد از CPU شود.</div></details><details><summary>96: تفاوت بین var x = y و x := y چیست؟</summary><div class=markdown-inner><ul><li><code>var x = y</code> می‌تواند در سطح package یا تابع استفاده شود.</li><li><code>x := y</code> فقط در داخل توابع مجاز است و همیشه تعریف جدید انجام می‌دهد.</li></ul></div></details><details><summary>97: چرا استفاده از init function باید محدود باشد؟</summary><div class=markdown-inner>چون باعث اجرای مخفیانه کد در هنگام بارگذاری پکیج می‌شود و می‌تواند تست و اشکال‌زدایی را سخت کند. بهتر است منطق راه‌اندازی به صراحت در main یا سازنده‌ها باشد.</div></details><details><summary>98: تفاوت بین context.WithCancel و context.WithTimeout چیست؟</summary><div class=markdown-inner><ul><li><code>WithCancel</code> فقط با فراخوانی تابع cancel لغو می‌شود.</li><li><code>WithTimeout</code> به صورت خودکار بعد از زمان مشخص لغو می‌شود.</li></ul></div></details><details><summary>99: چرا حلقه‌های بازگشتی بدون شرط توقف می‌توانند باعث stack overflow شوند؟</summary><div class=markdown-inner>چون Go tail call optimization ندارد و هر فراخوانی بازگشتی stack را افزایش می‌دهد.</div></details><details><summary>100: تفاوت بین log.Fatal و panic چیست؟</summary><div class=markdown-inner><ul><li><code>log.Fatal</code> پیام را چاپ کرده و برنامه را بلافاصله با <code>os.Exit</code> متوقف می‌کند.</li><li><code>panic</code> اجرای عادی را متوقف کرده و chain فراخوانی deferها را اجرا می‌کند قبل از توقف.</li></ul></div></details><details><summary>101: تفاوت بین unsafe.Pointer و uintptr چیست؟</summary><div class=markdown-inner><ul><li><code>unsafe.Pointer</code> برای تبدیل بین انواع اشاره‌گر استفاده می‌شود.</li><li><code>uintptr</code> یک نوع عددی است که آدرس را به عنوان یک عدد ذخیره می‌کند. تبدیل بین آنها باید با احتیاط انجام شود چون ممکن است GC آدرس را جابجا کند.</li></ul></div></details><details><summary>102: چرا استفاده از reflect می‌تواند کارایی را کاهش دهد؟</summary><div class=markdown-inner>پکیج <code>reflect</code> باعث عملیات‌های زمان اجرا و type checking پویا می‌شود که نسبت به کد معمولی کندتر است.</div></details><details><summary>103: تفاوت بین constant expression و runtime value چیست؟</summary><div class=markdown-inner>Constant expression در زمان کامپایل مشخص می‌شود و می‌تواند در تعریف ثابت‌ها استفاده شود. Runtime value فقط در زمان اجرای برنامه مشخص می‌شود.</div></details><details><summary>104: چرا nil channel برای همگام‌سازی گاهی مفید است؟</summary><div class=markdown-inner>با nil کردن یک channel می‌توانیم آن را از انتخاب در <code>select</code> حذف کنیم و رفتار برنامه را به صورت پویا کنترل کنیم.</div></details><details><summary>105: تفاوت بین stack و heap allocation در Go چیست؟</summary><div class=markdown-inner>Stack سریع‌تر و برای داده‌های کوتاه‌مدت استفاده می‌شود. Heap برای داده‌هایی که طول عمر نامعلوم دارند و بین goroutineها به اشتراک گذاشته می‌شوند.</div></details><details><summary>106: چرا slicing از یک array بزرگ می‌تواند باعث نگه‌داشتن حافظه اضافی شود؟</summary><div class=markdown-inner>چون slice به آرایه زیرین اشاره می‌کند و GC نمی‌تواند آرایه بزرگ را آزاد کند تا زمانی که slice زنده باشد.</div></details><details><summary>107: تفاوت بین break و continue در حلقه چیست؟</summary><div class=markdown-inner><ul><li><code>break</code> حلقه را کامل متوقف می‌کند.</li><li><code>continue</code> فقط iteration جاری را رد کرده و iteration بعدی را شروع می‌کند.</li></ul></div></details><details><summary>108: چرا append ممکن است باعث تغییر آدرس حافظه slice شود؟</summary><div class=markdown-inner>وقتی ظرفیت پر شود، append یک آرایه جدید می‌سازد و داده‌ها را کپی می‌کند که آدرس حافظه متفاوت خواهد داشت.</div></details><details><summary>109: تفاوت بین go vet و go fmt چیست؟</summary><div class=markdown-inner><ul><li><code>go fmt</code> کد را قالب‌بندی می‌کند.</li><li><code>go vet</code> مشکلات احتمالی کد را شناسایی می‌کند ولی تغییرات ظاهری ایجاد نمی‌کند.</li></ul></div></details><details><summary>110: چرا باید از io.Reader و io.Writer در طراحی API استفاده کنیم؟</summary><div class=markdown-inner>برای انعطاف‌پذیری بیشتر و امکان استفاده از منابع مختلف (فایل، شبکه، حافظه) بدون تغییر کد.</div></details><details><summary>111: تفاوت بین os.Exit و return در main چیست؟</summary><div class=markdown-inner><code>os.Exit</code> فوراً برنامه را متوقف می‌کند و deferها اجرا نمی‌شوند، ولی <code>return</code> اجازه اجرای deferها را می‌دهد.</div></details><details><summary>112: چرا map نمی‌تواند به عنوان کلید slice داشته باشد؟</summary><div class=markdown-inner>چون slice قابل مقایسه نیست و hash آن ثابت نیست. فقط انواع قابل مقایسه (comparable) می‌توانند کلید باشند.</div></details><details><summary>113: تفاوت بین io.Pipe و channel چیست؟</summary><div class=markdown-inner><code>io.Pipe</code> برای اتصال مستقیم بین io.Reader و io.Writer استفاده می‌شود، ولی channel برای ارسال هر نوع داده بین goroutineها استفاده می‌شود.</div></details><details><summary>114: چرا نباید از pointer به local variable بعد از پایان تابع استفاده کنیم؟</summary><div class=markdown-inner>چون متغیر ممکن است از بین برود یا آدرسش تغییر کند، که باعث رفتار غیرقابل پیش‌بینی می‌شود.</div></details><details><summary>115: تفاوت بین testing.Short و تست‌های عادی چیست؟</summary><div class=markdown-inner><code>testing.Short()</code> می‌تواند در تست‌ها استفاده شود تا تست‌های طولانی در حالت کوتاه اجرا نشوند.</div></details><details><summary>116: چرا باید برای عملیات‌های سنگین I/O از buffered channel استفاده کرد؟</summary><div class=markdown-inner>برای جلوگیری از بلاک شدن تولیدکننده یا مصرف‌کننده و افزایش throughput.</div></details><details><summary>117: تفاوت بین go build و go install چیست؟</summary><div class=markdown-inner><ul><li><code>go build</code> فایل اجرایی را در دایرکتوری جاری می‌سازد.</li><li><code>go install</code> آن را در مسیر bin در <code>$GOPATH</code> یا <code>$GOBIN</code> نصب می‌کند.</li></ul></div></details><details><summary>118: چرا استفاده از strings.Builder به جای + برای رشته‌ها بهتر است؟</summary><div class=markdown-inner>چون از تخصیص‌های متعدد جلوگیری می‌کند و حافظه را بهینه‌تر مدیریت می‌کند.</div></details><details><summary>119: تفاوت بین cap و len در array چیست؟</summary><div class=markdown-inner>برای array هر دو برابر طول آرایه هستند، ولی برای slice ممکن است متفاوت باشند.</div></details><details><summary>120: چرا باید بعد از استفاده از bufio.Writer حتماً Flush کرد؟</summary><div class=markdown-inner>چون داده‌ها در بافر ذخیره می‌شوند و تا زمانی که Flush نشوند به مقصد نهایی ارسال نمی‌شوند.</div></details><details><summary>121: تفاوت بین import _ و import alias چیست؟</summary><div class=markdown-inner><ul><li><code>import _</code> فقط برای اجرای init پکیج است.</li><li>Import alias برای استفاده از نام متفاوت جهت ارجاع به پکیج.</li></ul></div></details><details><summary>122: چرا باید از context در عملیات‌های شبکه استفاده کنیم؟</summary><div class=markdown-inner>برای امکان لغو یا timeout در صورت طولانی شدن عملیات.</div></details><details><summary>123: تفاوت بین interface value و concrete value چیست؟</summary><div class=markdown-inner>Interface value شامل نوع و مقدار واقعی است، concrete value فقط مقدار واقعی است.</div></details><details><summary>124: چرا استفاده از constant برای magic number بهتر است؟</summary><div class=markdown-inner>باعث خوانایی بهتر، کاهش خطا و امکان تغییر راحت در آینده می‌شود.</div></details><details><summary>125: تفاوت بین log.Println و fmt.Println چیست؟</summary><div class=markdown-inner><code>log.Println</code> علاوه بر چاپ پیام، timestamp هم اضافه می‌کند.</div></details><details><summary>126: چرا sync.WaitGroup باید با Add قبل از اجرای goroutine استفاده شود؟</summary><div class=markdown-inner>برای جلوگیری از شرایطی که goroutine قبل از افزایش شمارنده شروع شود و WaitGroup صفر بماند.</div></details><details><summary>127: تفاوت بین path و filepath در Go چیست؟</summary><div class=markdown-inner><ul><li><code>path</code> برای مسیرهای URL و forward slash استفاده می‌شود.</li><li><code>filepath</code> برای مسیرهای سیستم فایل وابسته به سیستم‌عامل استفاده می‌شود.</li></ul></div></details><details><summary>128: چرا استفاده از http.Client پیش‌فرض می‌تواند مشکل‌ساز باشد؟</summary><div class=markdown-inner>چون connectionها را cache نمی‌کند و ممکن است باعث نشت اتصال شود مگر اینکه timeout یا Transport سفارشی تعریف شود.</div></details><details><summary>129: تفاوت بین sync.Mutex و sync.RWMutex در خواندن زیاد چیست؟</summary><div class=markdown-inner><code>sync.RWMutex</code> اجازه می‌دهد چندین خواننده همزمان کار کنند، ولی Mutex فقط یک قفل کلی می‌دهد.</div></details><details><summary>130: چرا panic در گوروتین جداگانه باید به صورت جداگانه recover شود؟</summary><div class=markdown-inner>چون recover فقط panic در همان goroutine را می‌گیرد.</div></details><details><summary>131: تفاوت بین os.Create و os.OpenFile چیست؟</summary><div class=markdown-inner><ul><li><code>os.Create</code> فایل را با truncate ایجاد یا باز می‌کند.</li><li><code>os.OpenFile</code> کنترل کامل روی mode و flagها می‌دهد.</li></ul></div></details><details><summary>132: چرا context باید به صورت اولین آرگومان به توابع پاس داده شود؟</summary><div class=markdown-inner>این یک قرارداد استاندارد Go است که خوانایی و یکپارچگی API را بهبود می‌دهد.</div></details><details><summary>133: تفاوت بین errors.Is و errors.As چیست؟</summary><div class=markdown-inner><ul><li><code>errors.Is</code> برای بررسی تطابق با یک خطای خاص استفاده می‌شود.</li><li><code>errors.As</code> برای استخراج و استفاده از نوع خاص خطا.</li></ul></div></details><details><summary>134: چرا نباید از defer در حلقه‌های شدیداً پرتکرار استفاده کرد؟</summary><div class=markdown-inner>چون هر defer تا پایان تابع ذخیره می‌شود و باعث سربار می‌شود.</div></details><details><summary>135: تفاوت بین nil slice و empty slice در JSON چیست؟</summary><div class=markdown-inner>Nil slice به <code>null</code> سریالایز می‌شود، ولی empty slice به <code>[]</code>.</div></details><details><summary>136: چرا map در Go به صورت داخلی rehash انجام می‌دهد؟</summary><div class=markdown-inner>برای حفظ کارایی O(1) در دسترسی و جلوگیری از افزایش بیش از حد load factor.</div></details><details><summary>137: تفاوت بین encoding/json و jsoniter چیست؟</summary><div class=markdown-inner><code>jsoniter</code> سریع‌تر و انعطاف‌پذیرتر است ولی encoding/json رسمی و پایدار است.</div></details><details><summary>138: چرا باید کانال را فقط توسط ارسال‌کننده ببندیم؟</summary><div class=markdown-inner>برای جلوگیری از panic ناشی از ارسال به کانال بسته.</div></details><details><summary>139: تفاوت بین context.WithValue و متغیر global چیست؟</summary><div class=markdown-inner>Context برای داده‌های کوتاه‌مدت مرتبط با درخواست استفاده می‌شود، global برای داده‌های بلندمدت.</div></details><details><summary>140: چرا time.AfterFunc می‌تواند به جای time.Sleep مفید باشد؟</summary><div class=markdown-inner>چون به صورت asynchronous عمل می‌کند و callback مشخصی را بعد از مدت معین اجرا می‌کند.</div></details><details><summary>141: تفاوت بین select با یک case و استفاده مستقیم از channel چیست؟</summary><div class=markdown-inner><code>select</code> حتی با یک case هم امکان اضافه کردن default یا caseهای دیگر را در آینده می‌دهد و ساختار کد را منعطف‌تر می‌کند، ولی دریافت مستقیم ساده‌تر است.</div></details><details><summary>142: چرا استفاده از buffer بزرگ‌تر در bufio.Reader می‌تواند کارایی را بهبود دهد؟</summary><div class=markdown-inner>چون تعداد فراخوانی‌های سیستم‌عاملی (syscall) را کاهش می‌دهد و داده‌ها را یک‌جا می‌خواند.</div></details><details><summary>143: تفاوت بین defer با anonymous function و با نام تابع چیست؟</summary><div class=markdown-inner>در defer با anonymous function می‌توان پارامترها را در زمان اجرای defer ارزیابی کرد، ولی در تابع نام‌دار پارامترها در لحظه تعریف defer ارزیابی می‌شوند.</div></details><details><summary>144: چرا از sync/atomic برای شمارنده‌ها استفاده می‌شود؟</summary><div class=markdown-inner>چون عملیات‌های اتمیک بدون نیاز به Mutex انجام می‌شوند و سرعت بیشتری دارند.</div></details><details><summary>145: تفاوت بین byte buffer و byte slice چیست؟</summary><div class=markdown-inner>Byte buffer (مثل bytes.Buffer) امکانات بیشتری مثل نوشتن و خواندن با رشد خودکار دارد، ولی byte slice ساده‌تر است و امکانات اضافی ندارد.</div></details><details><summary>146: چرا استفاده از fallthrough باید محدود باشد؟</summary><div class=markdown-inner>چون می‌تواند باعث اجرای غیرمنتظره caseها شود و خوانایی کد را کاهش دهد.</div></details><details><summary>147: تفاوت بین log.Fatal و os.Exit چیست؟</summary><div class=markdown-inner><code>log.Fatal</code> قبل از توقف پیام خطا را چاپ می‌کند، ولی <code>os.Exit</code> فقط برنامه را متوقف می‌کند.</div></details><details><summary>148: چرا map در Go به‌صورت همزمان توسط چند goroutine قابل استفاده نیست؟</summary><div class=markdown-inner>چون پیاده‌سازی داخلی map thread-safe نیست و همزمانی بدون قفل باعث panic می‌شود.</div></details><details><summary>149: تفاوت بین os.Getenv و os.LookupEnv چیست؟</summary><div class=markdown-inner><ul><li><code>os.Getenv</code> رشته را برمی‌گرداند و اگر وجود نداشته باشد مقدار خالی می‌دهد.</li><li><code>os.LookupEnv</code> مقدار و وضعیت وجود داشتن را برمی‌گرداند.</li></ul></div></details><details><summary>150: چرا range روی channel تا زمان بسته شدن ادامه دارد؟</summary><div class=markdown-inner>چون range از channel تا زمانی که همه مقادیر خوانده و کانال بسته نشود، بلاک می‌ماند.</div></details></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/GoFarsi/book/edit/main/content/interview.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt>
<span>این صفحه را ویرایش کنید</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script><div class="text-left page-navigation"><a href=/chapter-1/>فصل اول: آشنایی با مفاهیم گو ◀︎</a></div><script>function toggleTooltip(e){e.classList.toggle("active")}</script><div id=graphcomment></div><script type=text/javascript>var __semio__params={graphcommentId:"book",behaviour:{}};function __semio__onload(){__semio__gc_graphlogin(__semio__params)}(function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.onload=__semio__onload,e.defer=!0,e.src="https://integration.graphcomment.com/gc_graphlogin.js?"+Date.now(),(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content></br><main><div class=wrapper><a href=https://t.me/GolangEngineers class="icon telegram" target=_blank><div class=tooltip>گروه تلگرامی مهندسین گولنگ</div><span><i class="fab fa-telegram"></i></span>
</a><a href=https://linkedin.com/in/Ja7ad class="icon linkedin" target=_blank><div class=tooltip>لینکدین نویسنده</div><span><i class="fab fa-linkedin"></i></span>
</a><a href=https://twitter.com/Ja7adR class="icon twitter" target=_blank><div class=tooltip>توییتر نویسنده</div><span><i class="fab fa-twitter"></i></span></a></div></main></br></br><nav id=TableOfContents></nav></div></aside></main><button onclick=topFunction() id=myBtn title="رفتن به بالا" class="fas fa-solid fa-arrow-up"></button>
<script src=prism.js defer></script><script>document.getElementById("currentsv").innerHTML=window.location.href</script><script async>var html=document.documentElement,switcher=document.getElementsByClassName("js-toggle")[0];typeof Storage!="undefined"&&((localStorage.getItem("themeMode")=="dark"||document.documentElement.getAttribute("data-theme")=="dark")&&switcher.classList.add("js-toggle--checked"),switcher.classList.add("js-toggle--focus")),switcher.addEventListener("click",function(){this.classList.toggle("js-toggle--checked"),this.classList.add("js-toggle--focus"),this.classList.contains("js-toggle--checked")?(html.setAttribute("data-theme","dark"),localStorage.setItem("themeMode","dark")):(html.setAttribute("data-theme","light"),localStorage.setItem("themeMode","light"))})</script><script>let mybutton=document.getElementById("myBtn");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?mybutton.style.display="block":mybutton.style.display="none"}function topFunction(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script src=/js/playground.js defer></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js defer></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-go.min.js defer></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/line-numbers/prism-line-numbers.min.js defer></script><script>"serviceWorker"in navigator&&window.addEventListener("DOMContentLoaded",function(){navigator.serviceWorker.register("/sw.js")})</script></body></html>