<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>9.4 الگوهای همزمانی on زبان گو فارسی</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/</link><description>Recent content in 9.4 الگوهای همزمانی on زبان گو فارسی</description><generator>Hugo -- gohugo.io</generator><language>fa-IR</language><atom:link href="https://book.gofarsi.ir/chapter-9/concurrency-patterns/index.xml" rel="self" type="application/rss+xml"/><item><title>9.4.1 الگو Wait For Result</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-wait-for-result/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-wait-for-result/</guid><description>9.4.1.1 توضیحات # با استفاده از الگو Wait For Result می توانید یک عملیاتی را بصورت همزمانی انجام دهید و سپس منتظر نتیجه عملیات صورت گرفته بمانید. برای اینکار از کانال استفاده می شود.
9.4.1.2 دیاگرام # 9.4.1.3 نمونه کد # 1package main 2 3import ( 4 &amp;#34;fmt&amp;#34; 5 &amp;#34;time&amp;#34; 6) 7 8func longRunningTask(c chan int) { 9 time.Sleep(3 * time.Second) 10 c &amp;lt;- 42 11} 12 13func main() { 14 c := make(chan int) 15 go longRunningTask(c) 16 17 result := &amp;lt;-c 18 fmt.</description></item><item><title>9.4.2 الگو Fan Out/In</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-fan-out-in/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-fan-out-in/</guid><description>9.4.2.1 توضیحات # الگو Fan Out/In یک تکنیک همزمانی در زبان گو می باشد که به شما اجازه می دهد چندین کار را با گوروتین همزمان انجام دهید و در نتیجه خروجی این کارها را با هم ترکیب کنید و به عنوان نتیجه نهایی دریافت کنید.
9.4.2.2 دیاگرام # 9.4.2.3 نمونه کد # فرض کنید قصد دارید یک برنامه ای بنویسید که چندین فایل بصورت موازی دانلود کنید و در نهایت محتوای این فایل را میخواهید ترکیب کنید و یک خروجی داشته باشید.</description></item><item><title>9.4.3 الگو Wait For Task</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-wait-for-task/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-wait-for-task/</guid><description>9.4.3.1 توضیحات # الگو wait for task یکی از الگوهای رایج در زبان گو می باشد و انتظار برای تکمیل یک تسک یا فرآیند استفاده می شود. یک تسک با استفاده از گوروتین اجرا می شود و پس اتمامش کار تسک از طریق کانال سیگنال انجام می فرستد.
همچنین می توانید شما یک کانال ایجاد کنید منتظر بمانید تسک انجام شود و دیتا مورد نظر را از طریق کانال بگیرید.</description></item><item><title>9.4.4 الگو Pooling</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-pooling/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-pooling/</guid><description>9.4.4.1 توضیحات # شما با استفاده از الگو pooling می توانید برای استفاده مجدد یا مدیریت تعداد ثابتی از منابع مانند : کانکشن های دیتابیس یا مجموعه ای از گوروتین های کارگر استفاده کنید. از کانال برای برقراری ارتباط بین مجموع منابع استفاده می شود.
9.4.4.2 دیاگرام # 9.4.4.3 نمونه کد # 1package main 2 3import ( 4 &amp;#34;fmt&amp;#34; 5) 6 7func main() { 8 jobs := make(chan int, 100) 9 results := make(chan int, 100) 10 11 // Start 3 worker goroutines 12 for w := 1; w &amp;lt;= 3; w++ { 13 go worker(w, jobs, results) 14 } 15 16 // Send 5 jobs to the worker pool 17 for j := 1; j &amp;lt;= 5; j++ { 18 jobs &amp;lt;- j 19 } 20 close(jobs) 21 22 // Collect the results 23 for a := 1; a &amp;lt;= 5; a++ { 24 fmt.</description></item><item><title>9.4.5 الگو Drop</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-drop/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-drop/</guid><description>9.4.5.1 توضیحات # الگو Drop یک الگو مهم برای انجام خدمات سنگین می باشد. خدماتی که مواقعی باعث می شود حجم درخواست هایش بیش از ظرفیت موجود باشد و این درخواست ها بواسطه این الگو می تواند Drop شود. به عنوان مثال سرویس های DNS باید از این الگو استفاده کنند.
9.4.5.2 دیاگرام # 9.4.5.3 نمونه کد # 1package main 2 3import ( 4 &amp;#34;fmt&amp;#34; 5) 6 7func main() { 8 in := make(chan int, 5) 9 out := make(chan int, 5) 10 11 go func() { 12 for { 13 select { 14 case in &amp;lt;- 1: 15 default: 16 fmt.</description></item><item><title>9.4.6 الگو Cancellation</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-cancellation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-cancellation/</guid><description>9.4.6.1 توضیحات # الگو cancellation که حرکت تکنیکی هست برای ارسال سینگال به گوروتین ها استفاده می شود که باید اجرای کاری را متوقف کند و ایده اصلی این کار با استفاده بستن کانال صورت میگیرد.
9.4.6.2 دیاگرام # 9.4.6.3 نمونه کد # 1package main 2 3import ( 4 &amp;#34;fmt&amp;#34; 5 &amp;#34;time&amp;#34; 6) 7 8func main() { 9 // create cancel channel 10 cancel := make(chan struct{}) 11 12 // start goroutine 13 go func() { 14 for { 15 select { 16 case &amp;lt;-cancel: 17 fmt.</description></item><item><title>9.4.7 الگو Semaphore</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-semaphore/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-semaphore/</guid><description>9.4.7.1 توضیحات # الگو Semaphore برای مدیریت کنترل دسترسی به منابع مشترک در همزمانی استفاده می شود. فرض کنید بصورت موازی ۱۰۰ درخواست HTTP سمت سرور میاد و I/O شبکه برای پردازش همزمان این ۱۰۰ درخواست درگیر میشود و به مرور عملکرد کاهش می یابد. حال اگر ما بیایم این ۱۰۰ درخواست موازی را تقسیم کنیم به ۵ دسته ۲۰ تایی که بصورت همزمانی انجام شود باعث می شود I/O شبکه کاهش یابد و عملکرد بهتری را خواهیم داشت.</description></item><item><title>9.4.8 الگو Bounded Work Pooling</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-bounded-work-pooling/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-bounded-work-pooling/</guid><description>9.4.8.1 توضیحات # با استفاده از الگو Bounded Work Pooling امکان محدود سازی تعداد گوروتین ها را براساس کار مشخصی دارید و گوروتین ها را محدود به تعداد دفعات کار مشخص شده محدود می شود. این الگو برای وقت مفید است که شما می خواهید منابع را به یک کار خاص محدود کنید.
9.4.8.2 دیاگرام # 9.4.8.3 نمونه کد # 1package main 2 3import ( 4 &amp;#34;fmt&amp;#34; 5 &amp;#34;sync&amp;#34; 6) 7 8func main() { 9 // Create a channel to hold the tasks 10 tasks := make(chan int, 100) 11 12 // Create a WaitGroup to track the goroutines 13 var wg sync.</description></item><item><title>9.4.9 الگو Retry Timeout</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-retry-timeout/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-retry-timeout/</guid><description>9.4.9.1 توضیحات # شما از الگو Retry Timeout برای تلاش مجدد یکسری عملیات استفاده کنید. برای اینکار شما می توانید از حلقه و تابع After در پکیج time کمک بگیرید و برای هرتلاش یک timeout مشخص کنید.
9.4.9.2 دیاگرام # 9.4.9.3 نمونه کد # 1package main 2 3import ( 4 &amp;#34;fmt&amp;#34; 5 &amp;#34;net/http&amp;#34; 6 &amp;#34;time&amp;#34; 7) 8 9func main() { 10 var resp *http.Response 11 var err error 12 timeout := time.</description></item><item><title>9.4.10 الگو Channel Cancellation</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-channel-cancellation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-channel-cancellation/</guid><description>9.4.10.1 توضیحات # از کانال ها برای ارتباط بین گوروتین ها و هماهنگ کردن اجرا استفاده می شود. حال گاهی اوقات نیاز است که ما یکسری فرآیند را داخل گوروتین لغو کنیم. در اینجا می توانیم با استفاده از کانال سیگنال لغو کردن بفرستید تا عملیات هایی که گوروتین مورد نظر انجام می داد لغو شود.
9.4.10.2 دیاگرام # 9.4.10.3 نمونه کد # 1package main 2 3import ( 4 &amp;#34;fmt&amp;#34; 5) 6 7func doWork(cancel chan bool) { 8 fmt.</description></item><item><title>9.4.11 الگو Producer-Consumer</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-producer-consumer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-producer-consumer/</guid><description>9.4.11.1 توضیحات # الگو producer-consumer یکی از کاربردی ترین الگوها در زبان گو می باشد که با استفاده از الگو می توانید بطور همزمان یکسری اطلاعات تولید کنید و بفرستید داخل کانال و این اطلاعات توسط مصرف کننده بواسطه کانال دریافت شود.
معمولا برای این الگو از یک کانال دو طرفه استفاده می شود.
9.4.11.2 دیاگرام # 9.4.11.3 نمونه کد # 1package main 2 3import ( 4 &amp;#34;fmt&amp;#34; 5 &amp;#34;math/rand&amp;#34; 6 &amp;#34;time&amp;#34; 7) 8 9func producer(ch chan&amp;lt;- int, d time.</description></item><item><title>9.4.12 الگو Monitor</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-monitor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-monitor/</guid><description>9.4.12.1 توضیحات # الگوی مانیتور به گروتین‌ ها اجازه می‌دهد هنگام ورود به حالت خواب بدون مسدود کردن اجرا یا مصرف منابع، منتظر شرایط خاصی باشند.
حال برای پیاده سازی این الگو ما از ساختاری به نام Cond در پکیج sync کمک میگیریم.
به نقل از ویکی پدیا :
در برنامه‌نویسی همروند (یا همان برنامه‌نویسی موازی)، مانیتور یک ساختار همگام سازی است که به ریسمان ها این امکان را می‌دهد که هم، انحصار متقابل داشته باشند و هم، بتوانند برای یک وضعیت خاص منتظر بمانند (مسدود شوند) تا وضعیت غلط شود.</description></item><item><title>9.4.13 الگو Future</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-future/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-future/</guid><description>9.4.13.1 توضیحات # در زبان گو الگو Future راهی برای نمایش نتیجه یک عملیات ناهمزمان (asynchronous) است که ممکن است آن عملیات هنوز تکمیل نشده باشد اما این الگو به شما این امکان را می دهد کدی بنویسید که طوری رفتار کند که گویی نتیجه یک عملیات فورا در دسترس است. حتی اگر عملیات در پس زمینه در حال اجرا باشد.
9.4.13.2 دیاگرام # 9.4.13.3 نمونه کد # 1package main 2 3import ( 4 &amp;#34;fmt&amp;#34; 5 &amp;#34;time&amp;#34; 6) 7 8type FutureInt struct { 9 result chan int 10} 11 12func (f *FutureInt) Get() int { 13 return &amp;lt;-f.</description></item><item><title>9.4.14 الگو Pipeline</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-pipeline/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-pipeline/</guid><description>9.4.14.1 توضیحات # الگو خط لوله (Pipeline) یکی از پرکاربردی ترین الگوها در همزمانی می باشد شما با استفاده از این الگو می توانید تسک های بزرگ را به تسک های کوچکتر و مستقل تقسیم کنید که می توانند بطور همزمان کار کنند. هر stage داخل یک گوروتین انجام می شود و بواسطه کانال داده ها بین stage های مختلف منتقل می شود.
9.4.14.2 دیاگرام # 9.4.14.3 نمونه کد # 1package main 2 3import &amp;#34;fmt&amp;#34; 4 5func gen(nums .</description></item><item><title>9.4.15 الگو Subscription</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-subscription/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-subscription/</guid><description>9.4.15.1 توضیحات # الگو Subscription یکی از الگوهای کاربردی برای پیاده سازی consumer می باشد که به یک آدرسی مشترک شوید و در بازده زمانی مختلف درخواست دهید و یکسری اطلاعات دریافت کنید.
9.4.15.2 دیاگرام # 9.4.15.3 نمونه کد # 1package main 2 3import ( 4 &amp;#34;context&amp;#34; 5 &amp;#34;encoding/json&amp;#34; 6 &amp;#34;fmt&amp;#34; 7 &amp;#34;io/ioutil&amp;#34; 8 &amp;#34;log&amp;#34; 9 &amp;#34;net/http&amp;#34; 10 &amp;#34;os&amp;#34; 11 &amp;#34;time&amp;#34; 12) 13 14const exampleAPIAddress = &amp;#34;https://random-data-api.com/api/stripe/random_stripe&amp;#34; 15 16type Card struct { 17 Id uint `json:&amp;#34;id&amp;#34;` 18 Uid string `json:&amp;#34;uid&amp;#34;` 19 ValidCard string `json:&amp;#34;valid_card&amp;#34;` 20 Token string `json:&amp;#34;token&amp;#34;` 21 InvalidCard string `json:&amp;#34;invalid_card&amp;#34;` 22 Month string `json:&amp;#34;month&amp;#34;` 23 Year string `json:&amp;#34;year&amp;#34;` 24 CCV string `json:&amp;#34;ccv&amp;#34;` 25 CCVAmex string `json:&amp;#34;ccv_amex&amp;#34;` 26} 27 28type Subscription interface { 29 Updates() &amp;lt;-chan Card 30} 31 32type Fetcher interface { 33 Fetch() (Card, error) 34} 35 36type sub struct { 37 fetcher Fetcher 38 updates chan Card 39} 40 41type fetcher struct { 42 url string 43} 44 45type fetchResult struct { 46 fetchedCard Card 47 err error 48} 49 50// NewSubscription create subscription for fetch data per freq time in second 51func NewSubscription(ctx context.</description></item><item><title>9.4.16 الگو Bridge Channel</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-brdige-channel/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-brdige-channel/</guid><description>9.4.16.1 توضیحات # با استفاده از الگو Bridge Channel می توانید بین ۲ کانال داده ای را منتقل کنید فرض کنید یک داده را به کانال input میفرستید و از دریافت داده آن را می توانید به کانال دیگری منتقل کنید و عملا شما یک پل برای انتقال داده ایجاد کردید.
9.4.16.2 دیاگرام # 9.4.17.3 نمونه کد # 1package main 2 3import &amp;#34;fmt&amp;#34; 4 5func main() { 6 // Declare input and output channels 7 input := make(chan int) 8 output := make(chan int) 9 10 // Launch goroutine to act as bridge between channels 11 go func() { 12 for { 13 // Wait for value on input channel 14 value := &amp;lt;-input 15 16 // Forward value to output channel 17 output &amp;lt;- value 18 } 19 }() 20 21 // Send a value to the input channel 22 input &amp;lt;- 1 23 24 // Receive the value from the output channel 25 fmt.</description></item><item><title>9.4.17 الگو Queuing</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-queuing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-queuing/</guid><description>9.4.17.1 توضیحات # الگوی &amp;ldquo;صف&amp;rdquo; در زبان گو الگویی است که در آن از یک گوروتین برای بافر کردن و مدیریت ترتیب مقادیر ارسال شده و دریافت شده از یک کانال استفاده می شود.
9.4.17.2 دیاگرام # 9.4.17.3 نمونه کد # 1package main 2 3import &amp;#34;fmt&amp;#34; 4 5func main() { 6 // Declare the queue channel with a buffer size of 5 7 queue := make(chan int, 5) 8 9 // Send values to the queue 10 go func() { 11 for i := 0; i &amp;lt; 10; i++ { 12 queue &amp;lt;- i 13 fmt.</description></item></channel></rss>