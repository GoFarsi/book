<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><author/><title>9.4 الگوهای همزمانی on زبان گو فارسی</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/</link><description>Recent content in 9.4 الگوهای همزمانی on زبان گو فارسی</description><generator>Hugo -- gohugo.io</generator><language>fa</language><copyright>2023 GoFarsi All rights reserved</copyright><atom:link href="https://book.gofarsi.ir/chapter-9/concurrency-patterns/rss.xml" rel="self" type="application/rss+xml"/><item><author/><title>9.4.1 الگو Wait For Result</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-wait-for-result/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-wait-for-result/</guid><description>&lt;h2 id="9411-توضیحات"&gt;
9.4.1.1 توضیحات
&lt;a class="anchor" href="#9411-%d8%aa%d9%88%d8%b6%db%8c%d8%ad%d8%a7%d8%aa"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;الگوی &lt;strong&gt;Wait For Result&lt;/strong&gt; یکی از پرکاربردترین الگوها در برنامه‌نویسی همزمان با Go است که هدفش اجرای عملیات به صورت goroutine و انتظار برای دریافت نتیجه از طریق channel است. در این الگو، معمولاً یک کانال تعریف می‌شود تا داده یا نتیجه (و حتی خطا) از goroutine به کد اصلی منتقل شود. این کار باعث می‌شود عملیات‌های طولانی یا زمان‌بر (مثل خواندن فایل، تماس با API یا انجام محاسبات سنگین) بدون بلاک کردن کل برنامه اجرا شوند و به محض آماده شدن نتیجه، به صورت ایمن و همزمان، دریافت شوند. ساختار معمول این الگو به این صورت است که یک goroutine کار را انجام می‌دهد و در پایان نتیجه را داخل کانال می‌فرستد؛ در این مدت goroutine اصلی (یا هر مصرف‌کننده دیگر) با دریافت روی کانال منتظر نتیجه می‌ماند.&lt;/p&gt;</description></item><item><author/><title>9.4.2 الگو Fan Out/In</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-fan-out-in/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-fan-out-in/</guid><description>&lt;h2 id="9421-توضیحات"&gt;
9.4.2.1 توضیحات
&lt;a class="anchor" href="#9421-%d8%aa%d9%88%d8%b6%db%8c%d8%ad%d8%a7%d8%aa"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;الگوی &lt;strong&gt;Fan Out/In&lt;/strong&gt; یکی از مهم‌ترین تکنیک‌های همزمانی در زبان Go است که برای افزایش کارایی و سرعت پردازش در سناریوهایی به‌کار می‌رود که نیاز داریم چندین کار مشابه یا مستقل را به صورت موازی انجام دهیم و در نهایت نتایج همه آن‌ها را جمع‌آوری و تجمیع کنیم. در این الگو، معمولاً یک goroutine اصلی چندین goroutine فرعی را راه‌اندازی می‌کند (Fan Out) تا هر کدام یک وظیفه مستقل را انجام دهند؛ سپس نتایج این goroutineها (که می‌تواند هر نوع داده یا حتی خطا باشد) از طریق کانال‌ها جمع‌آوری شده و پس از اتمام همه کارها، نتیجه نهایی (Fan In) به goroutine اصلی برگردانده می‌شود.&lt;/p&gt;</description></item><item><author/><title>9.4.3 الگو Wait For Task</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-wait-for-task/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-wait-for-task/</guid><description>&lt;h2 id="9431-توضیحات"&gt;
9.4.3.1 توضیحات
&lt;a class="anchor" href="#9431-%d8%aa%d9%88%d8%b6%db%8c%d8%ad%d8%a7%d8%aa"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;الگوی &lt;strong&gt;Wait For Task&lt;/strong&gt; یکی از ساده‌ترین و در عین حال پراستفاده‌ترین الگوهای همزمانی در Go است که برای &lt;strong&gt;منتظر ماندن تا اتمام یک فرآیند یا تسک معین&lt;/strong&gt; کاربرد دارد. در این الگو معمولاً یک goroutine برای انجام کاری خاص راه‌اندازی می‌شود و پس از اتمام، از طریق یک channel به goroutine اصلی سیگنال پایان کار یا حتی داده‌ی تولیدشده را منتقل می‌کند. این روش به شما امکان می‌دهد همزمان چند کار مستقل را اجرا کنید و به صورت مجزا منتظر پایان هرکدام باشید، یا دقیقاً در لحظه‌ای مشخص بدانید یک تسک خاص تمام شده است و می‌توانید ادامه برنامه را اجرا کنید.&lt;/p&gt;</description></item><item><author/><title>9.4.4 الگوی Worker Pool</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-worker-pool/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-worker-pool/</guid><description>&lt;h2 id="9441-توضیحات"&gt;
9.4.4.1 توضیحات
&lt;a class="anchor" href="#9441-%d8%aa%d9%88%d8%b6%db%8c%d8%ad%d8%a7%d8%aa"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;الگوی &lt;strong&gt;Worker Pool&lt;/strong&gt; یکی از مهم‌ترین الگوهای همزمانی در Go محسوب می‌شود و زمانی به‌کار می‌رود که بخواهید تعداد مشخصی goroutine (معمولاً با نقش کارگر یا worker) داشته باشید که وظایف مختلف را به صورت صف (queue) دریافت و اجرا کنند. این کار باعث کنترل بهتر منابع، جلوگیری از ایجاد goroutine بیش از حد (که ممکن است باعث مصرف بی‌رویه CPU و memory یا حتی crash برنامه شود) و مدیریت صف کارها در سیستم‌های real-world و پرلود می‌شود. در این الگو، یک یا چند کانال برای ارسال وظایف (task queue) و دریافت نتایج بین goroutineهای تولیدکننده (producer) و goroutineهای worker (مصرف‌کننده) استفاده می‌شود.&lt;/p&gt;</description></item><item><author/><title>9.4.5 الگو Drop</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-drop/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-drop/</guid><description>&lt;h2 id="9451-توضیحات"&gt;
9.4.5.1 توضیحات
&lt;a class="anchor" href="#9451-%d8%aa%d9%88%d8%b6%db%8c%d8%ad%d8%a7%d8%aa"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;الگوی &lt;strong&gt;Drop&lt;/strong&gt; یا &lt;strong&gt;Drop Overflow&lt;/strong&gt; یکی از الگوهای حیاتی برای سیستم‌هایی است که ممکن است با موجی از درخواست‌ها روبرو شوند که بیش از ظرفیت واقعی سیستم است. در این الگو، زمانی که صف یا ظرفیت پردازش درخواست‌ها (مثلاً یک کانال یا بافر) پر می‌شود، به جای اینکه سیستم را دچار ازدحام، توقف یا crash کند، به سادگی درخواست‌های اضافی (یا جدیدتر یا قدیمی‌تر، بر اساس سیاست) را حذف (Drop) می‌کند. این کار باعث می‌شود سرویس همواره پایدار و قابل اطمینان باقی بماند و منابع اصلی به خاطر یک سناریوی غیرعادی یا حمله دچار مشکل نشود.&lt;/p&gt;</description></item><item><author/><title>9.4.6 الگو Context Cancellation Pattern</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-cancellation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-cancellation/</guid><description>&lt;h2 id="9461-توضیحات"&gt;
9.4.6.1 توضیحات
&lt;a class="anchor" href="#9461-%d8%aa%d9%88%d8%b6%db%8c%d8%ad%d8%a7%d8%aa"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;الگوی &lt;strong&gt;Cancellation&lt;/strong&gt; یا &lt;strong&gt;Context Cancellation Pattern&lt;/strong&gt; یکی از تکنیک‌های کلیدی در Go برای کنترل lifecycle goroutineها و جلوگیری از اجرای ناخواسته یا بی‌پایان آن‌هاست. هدف اصلی این الگو، ارسال سیگنال توقف به goroutineهایی است که به هر دلیلی باید عملیات خود را زودتر از موعد قطع کنند؛ مثلاً کاربر درخواست کنسل می‌دهد، تایم‌اوت رخ می‌دهد یا رویداد خاصی در سیستم اتفاق می‌افتد.&lt;/p&gt;
&lt;p&gt;در معماری idiomatic Go، برای پیاده‌سازی لغو عملیات، به‌جای بستن کانال‌های اختصاصی، از &lt;strong&gt;context.Context&lt;/strong&gt; استفاده می‌شود که یک سازوکار استاندارد، ساده و thread-safe برای انتشار سیگنال لغو (cancelation) و همچنین مدیریت تایم‌اوت‌ها و مقادیر مرتبط است. معمولاً یک context اصلی با دستور &lt;code&gt;context.WithCancel&lt;/code&gt; یا &lt;code&gt;context.WithTimeout&lt;/code&gt; ساخته می‌شود و این context به تمامی goroutineها و تابع‌های فرزند پاس داده می‌شود. هر goroutine به طور دوره‌ای وضعیت context را بررسی می‌کند (با &lt;code&gt;&amp;lt;-ctx.Done()&lt;/code&gt; یا &lt;code&gt;ctx.Err()&lt;/code&gt;) و اگر سیگنال لغو صادر شده باشد، عملیات خود را متوقف می‌کند و منابع را آزاد می‌سازد.&lt;/p&gt;</description></item><item><author/><title>9.4.7 الگو Semaphore</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-semaphore/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-semaphore/</guid><description>&lt;h2 id="9471-توضیحات"&gt;
9.4.7.1 توضیحات
&lt;a class="anchor" href="#9471-%d8%aa%d9%88%d8%b6%db%8c%d8%ad%d8%a7%d8%aa"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;الگوی &lt;strong&gt;Semaphore&lt;/strong&gt; (سمیفور) یکی از مفاهیم کلیدی در دنیای همزمانی (Concurrency) است و نقش آن مدیریت کنترل دسترسی به منابع محدود (مانند فایل، شبکه، دیتابیس و…) در یک زمان است. این الگو مخصوصاً زمانی کاربرد دارد که چندین goroutine یا درخواست به طور همزمان قصد استفاده از یک منبع یا سرویس را دارند، اما تنها تعداد محدودی مجاز به استفاده همزمان از آن هستند. پیاده‌سازی این الگو در Go بسیار ساده و idiomatic است و معمولاً از &lt;strong&gt;کانال بافر دار&lt;/strong&gt; (buffered channel) به عنوان سمیفور استفاده می‌شود.&lt;/p&gt;</description></item><item><author/><title>9.4.8 الگو Retry Timeout</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-retry-timeout/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-retry-timeout/</guid><description>&lt;h2 id="9481-توضیحات"&gt;
9.4.8.1 توضیحات
&lt;a class="anchor" href="#9481-%d8%aa%d9%88%d8%b6%db%8c%d8%ad%d8%a7%d8%aa"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;الگوی &lt;strong&gt;Retry Timeout&lt;/strong&gt; یکی از رایج‌ترین و مهم‌ترین الگوها در توسعه سرویس‌های پایدار (resilient) و سیستم‌های توزیع‌شده است. این الگو زمانی کاربرد دارد که عملیاتی مانند تماس با سرویس خارجی (مثلاً API، پایگاه داده، یا هر نوع ارتباط شبکه‌ای) ممکن است به صورت موقت شکست بخورد و لازم باشد با رعایت یک فاصله زمانی معین (timeout) چند بار به طور خودکار تلاش مجدد (retry) صورت بگیرد تا شانس موفقیت افزایش یابد و تجربه کاربری بهبود پیدا کند.&lt;/p&gt;</description></item><item><author/><title>9.4.9 الگو Producer-Consumer</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-producer-consumer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-producer-consumer/</guid><description>&lt;h2 id="9491-توضیحات"&gt;
9.4.9.1 توضیحات
&lt;a class="anchor" href="#9491-%d8%aa%d9%88%d8%b6%db%8c%d8%ad%d8%a7%d8%aa"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;الگوی &lt;strong&gt;Producer-Consumer&lt;/strong&gt; یکی از الگوهای بنیادی و بسیار پرکاربرد در برنامه‌نویسی همزمان (concurrent) با زبان Go است که امکان تولید و مصرف داده به صورت همزمان و ایمن را فراهم می‌کند. در این الگو، معمولاً یک یا چند goroutine به عنوان &lt;strong&gt;تولیدکننده (Producer)&lt;/strong&gt; وظیفه تولید داده، رویداد یا پیام را بر عهده دارند و داده‌های تولیدی را از طریق یک &lt;strong&gt;کانال (channel)&lt;/strong&gt; به goroutineهای دیگر که نقش &lt;strong&gt;مصرف‌کننده (Consumer)&lt;/strong&gt; را دارند، ارسال می‌کنند. مصرف‌کننده‌ها نیز به صورت موازی داده‌های دریافتی را از کانال خوانده و پردازش می‌کنند. این جداسازی نقش تولید و مصرف، باعث می‌شود بخش‌های مختلف برنامه به صورت مستقل و همزمان عمل کرده و در عین حال از race condition و مشکلات همزمانی جلوگیری شود.&lt;/p&gt;</description></item><item><author/><title>9.4.10 الگو Monitor</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-monitor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-monitor/</guid><description>&lt;h2 id="94101-توضیحات"&gt;
9.4.10.1 توضیحات
&lt;a class="anchor" href="#94101-%d8%aa%d9%88%d8%b6%db%8c%d8%ad%d8%a7%d8%aa"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;الگوی &lt;strong&gt;مانیتور (Monitor Pattern)&lt;/strong&gt; یکی از مفاهیم کلیدی در طراحی سیستم‌های همزمان است که هدف آن فراهم کردن مکانیزمی برای مدیریت ایمن و هماهنگ دسترسی چندین goroutine به یک منبع یا وضعیت مشترک است. این الگو به گونه‌ای طراحی شده که goroutineها بتوانند زمانی که منتظر وقوع یک شرط خاص (مثلاً آماده شدن داده یا تغییر وضعیت یک منبع) هستند، بدون مصرف بیهوده منابع (مانند CPU) یا بلاک شدن کل برنامه، به حالت خواب بروند و به محض برقرار شدن شرط، از خواب بیدار شوند و ادامه اجرا دهند. این رفتار دقیقاً چیزی است که در زبان Go می‌توان با کمک ساختار &lt;strong&gt;sync.Cond&lt;/strong&gt; پیاده‌سازی کرد.&lt;/p&gt;</description></item><item><author/><title>9.4.11 الگو Future</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-future/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-future/</guid><description>&lt;h2 id="94111-توضیحات"&gt;
9.4.11.1 توضیحات
&lt;a class="anchor" href="#94111-%d8%aa%d9%88%d8%b6%db%8c%d8%ad%d8%a7%d8%aa"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;الگوی &lt;strong&gt;Future&lt;/strong&gt; (یا &lt;strong&gt;Promise&lt;/strong&gt;) یکی از الگوهای مهم و کاربردی در طراحی سیستم‌های ناهمزمان (asynchronous) است که در زبان Go نیز، اگرچه به صورت مستقیم در کتابخانه استاندارد وجود ندارد، اما می‌توان با استفاده از ابزارهای زبان مانند goroutine و channel، به‌سادگی آن را پیاده‌سازی کرد. هدف این الگو این است که یک &amp;ldquo;آبجکت&amp;rdquo; یا واسط به برنامه‌نویس داده شود که نماینده نتیجه یک عملیات (مانند درخواست شبکه یا محاسبه سنگین) است—حتی اگر آن عملیات هنوز به پایان نرسیده باشد.&lt;/p&gt;</description></item><item><author/><title>9.4.12 الگو Pipeline</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-pipeline/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-pipeline/</guid><description>&lt;h2 id="94121-توضیحات"&gt;
9.4.12.1 توضیحات
&lt;a class="anchor" href="#94121-%d8%aa%d9%88%d8%b6%db%8c%d8%ad%d8%a7%d8%aa"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;الگوی &lt;strong&gt;خط لوله (Pipeline)&lt;/strong&gt; یکی از حرفه‌ای‌ترین و پرکاربردترین الگوهای همزمانی در زبان Go است که نقش بسیار مهمی در طراحی سیستم‌های مقیاس‌پذیر، قابل نگهداری و با کارایی بالا دارد. هدف این الگو این است که یک کار بزرگ یا پردازش پیچیده را به چند مرحله (stage) کاملاً مستقل تقسیم کند، به طوری که هر مرحله بتواند همزمان با مراحل دیگر اجرا شود. در این ساختار، هر stage مسئولیت انجام یک بخش خاص از فرآیند را بر عهده دارد (مثلاً خواندن داده، پاک‌سازی، پردازش، ذخیره‌سازی و&amp;hellip;) و معمولاً هر stage در یک goroutine مجزا اجرا می‌شود.&lt;/p&gt;</description></item><item><author/><title>9.4.13 الگو Subscription</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-subscription/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-subscription/</guid><description>&lt;h2 id="94131-توضیحات"&gt;
9.4.13.1 توضیحات
&lt;a class="anchor" href="#94131-%d8%aa%d9%88%d8%b6%db%8c%d8%ad%d8%a7%d8%aa"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;الگوی &lt;strong&gt;Subscription&lt;/strong&gt; (یا Pub-Sub / Observer Pattern) یکی از پرکاربردترین الگوها در معماری‌های رویداد-محور و همزمان (event-driven &amp;amp; concurrent) است که امکان &lt;strong&gt;ثبت‌نام (subscribe) یک یا چند مصرف‌کننده (consumer)&lt;/strong&gt; را برای دریافت خودکار داده‌های جدید از یک منبع یا سرویس فراهم می‌کند. در این الگو، یک یا چند &lt;strong&gt;مصرف‌کننده&lt;/strong&gt; به یک &amp;ldquo;آدرس&amp;rdquo; یا منبع اشتراک (مثلاً یک topic، کانال یا event source) متصل می‌شوند و هر زمان که داده یا رویداد جدیدی منتشر شد (publish)، اطلاعات به طور خودکار و بی‌نیاز از polling مکرر به همه‌ی مصرف‌کننده‌های عضو ارسال می‌شود.&lt;/p&gt;</description></item><item><author/><title>9.4.14 الگو Bridge Channel</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-brdige-channel/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-brdige-channel/</guid><description>&lt;h2 id="94141-توضیحات"&gt;
9.4.14.1 توضیحات
&lt;a class="anchor" href="#94141-%d8%aa%d9%88%d8%b6%db%8c%d8%ad%d8%a7%d8%aa"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;الگوی &lt;strong&gt;Bridge Channel&lt;/strong&gt; یکی از الگوهای ساده اما بسیار مفید در زبان Go است که امکان &lt;strong&gt;اتصال و انتقال داده بین دو یا چند کانال مستقل&lt;/strong&gt; را فراهم می‌کند. این الگو زمانی کاربرد دارد که بخواهید داده‌های تولیدشده در یک goroutine یا زیرسیستم را پس از دریافت، به کانال دیگری هدایت کنید؛ به عبارتی، مانند یک &lt;strong&gt;پل (bridge)&lt;/strong&gt; عمل می‌کنید که داده‌ها را از یک کانال ورودی گرفته و به کانال خروجی منتقل می‌نماید.&lt;/p&gt;</description></item><item><author/><title>9.4.15 الگو Queuing</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-queuing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-queuing/</guid><description>&lt;h2 id="94151-توضیحات"&gt;
9.4.15.1 توضیحات
&lt;a class="anchor" href="#94151-%d8%aa%d9%88%d8%b6%db%8c%d8%ad%d8%a7%d8%aa"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;الگوی &lt;strong&gt;صف (Queue Pattern)&lt;/strong&gt; در زبان Go، الگویی است که در آن با استفاده از یک goroutine مرکزی و یک یا چند &lt;strong&gt;کانال ورودی و خروجی&lt;/strong&gt;، داده‌ها را به صورت منظم، &lt;strong&gt;به ترتیب ورود (FIFO)&lt;/strong&gt; مدیریت می‌کند. در این الگو، برخلاف استفاده مستقیم از کانال که ممکن است ترتیب یا بافر محدودی داشته باشد، یک گوروتین به عنوان &lt;strong&gt;صف درون‌ساخت (in-memory queue)&lt;/strong&gt; عمل می‌کند و داده‌های دریافتی از کانال ورودی را در یک &lt;strong&gt;ساختار صف مانند (مانند slice)&lt;/strong&gt; نگه می‌دارد، سپس بر اساس منطق زمان‌بندی یا در دسترس بودن مصرف‌کننده، آن‌ها را به کانال خروجی ارسال می‌کند.&lt;/p&gt;</description></item><item><author/><title>9.4.16 الگو Rate limit</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-ratelimit/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-ratelimit/</guid><description>&lt;h2 id="94161-توضیحات"&gt;
9.4.16.1 توضیحات
&lt;a class="anchor" href="#94161-%d8%aa%d9%88%d8%b6%db%8c%d8%ad%d8%a7%d8%aa"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;الگوی &lt;strong&gt;Rate Limiting&lt;/strong&gt; یا &amp;ldquo;محدودسازی نرخ درخواست&amp;rdquo; یکی از الگوهای پرکاربرد برای کنترل ترافیک ورودی یا پردازش عملیات در سیستم‌های نرم‌افزاری است. هدف اصلی این الگو، جلوگیری از اجرای بیش از حد عملیات در یک بازه‌ی زمانی مشخص است تا از بارگذاری بیش از حد سیستم، نقض محدودیت‌های منابع خارجی (مثل APIها)، یا سوءاستفاده از سرویس جلوگیری شود. این الگو در سرویس‌هایی که به منابع محدود یا خارجی متصل‌اند—مثل وب‌سرویس‌ها، میکروسرویس‌ها، API گیت‌وی‌ها یا سیستم‌های صف پردازش—به‌شدت حیاتی است.&lt;/p&gt;</description></item><item><author/><title>9.4.17 الگو Deadlock Recovery</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-deadlock-recovery/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-deadlock-recovery/</guid><description>&lt;h2 id="94171-توضیحات"&gt;
9.4.17.1 توضیحات
&lt;a class="anchor" href="#94171-%d8%aa%d9%88%d8%b6%db%8c%d8%ad%d8%a7%d8%aa"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;الگوی &lt;strong&gt;بازیابی از بن‌بست (Deadlock Recovery)&lt;/strong&gt; یکی از الگوهای مهم در طراحی سیستم‌های همزمان (concurrent systems) است که به ما کمک می‌کند از شرایطی خطرناک به نام &lt;em&gt;بن‌بست&lt;/em&gt; (deadlock) خارج شویم. در شرایط بن‌بست، دو یا چند گوروتین (یا نخ) در حالتی گیر می‌افتند که هر یک منتظر آزاد شدن منبعی است که توسط دیگری نگه داشته شده؛ در نتیجه هیچ‌کدام نمی‌توانند پیش بروند و کل سیستم در حالت توقف (freeze) باقی می‌ماند.&lt;/p&gt;</description></item><item><author/><title>9.4.18 الگو Channel Cancellation</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-channel-cancellation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-channel-cancellation/</guid><description>&lt;h2 id="94181-توضیحات"&gt;
9.4.18.1 توضیحات
&lt;a class="anchor" href="#94181-%d8%aa%d9%88%d8%b6%db%8c%d8%ad%d8%a7%d8%aa"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;الگوی &lt;strong&gt;Channel Cancellation&lt;/strong&gt; یا «لغو با کانال» یکی از الگوهای کلیدی در طراحی برنامه‌های همزمان (concurrent) در زبان Go است. این الگو زمانی استفاده می‌شود که نیاز باشد یک یا چند گوروتین را به‌صورت هماهنگ و ایمن متوقف کنیم، به‌ویژه در شرایطی که ادامه اجرای آن‌ها بی‌فایده یا مضر است (مثلاً خطا رخ داده، زمان‌سنج تمام شده یا برنامه در حال خاتمه است). این الگو برخلاف استفاده از &lt;code&gt;context.Context&lt;/code&gt; (که در Go برای لغو استاندارد توصیه می‌شود)، از یک &lt;code&gt;channel&lt;/code&gt; اختصاصی برای ارسال سیگنال لغو استفاده می‌کند.&lt;/p&gt;</description></item><item><author/><title>9.4.19 الگو Lock-free synchronization</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-lock-free-synchronization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-lock-free-synchronization/</guid><description>&lt;h2 id="94191-توضیحات"&gt;
9.4.19.1 توضیحات
&lt;a class="anchor" href="#94191-%d8%aa%d9%88%d8%b6%db%8c%d8%ad%d8%a7%d8%aa"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;همگام‌سازی بدون قفل (lock-free synchronization)&lt;/strong&gt; به مجموعه‌ای از تکنیک‌ها و الگوهای برنامه‌نویسی گفته می‌شود که به چندین thread یا goroutine اجازه می‌دهد به طور همزمان و ایمن به داده‌های مشترک دسترسی پیدا کنند، بدون اینکه از primitiveهایی مثل Mutex یا قفل‌های سنتی استفاده شود. هدف اصلی این الگوها افزایش &lt;strong&gt;بازدهی (throughput)&lt;/strong&gt;، کاهش &lt;strong&gt;زمان انتظار (latency)&lt;/strong&gt; و جلوگیری از مشکلات رایج قفل‌گذاری (مثل deadlock، priority inversion و contention) است. الگوریتم‌های lock-free تضمین می‌کنند که حتی اگر برخی از threadها متوقف شوند یا دچار کندی شوند، باقی سیستم همچنان قادر به پیشرفت خواهد بود (&lt;strong&gt;progress guarantee&lt;/strong&gt;).&lt;/p&gt;</description></item></channel></rss>