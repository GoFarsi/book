<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><author/><title>9.3 الگوهای طراحی رفتاری on زبان گو فارسی</title><link>https://book.gofarsi.ir/chapter-9/behavioral-patterns/</link><description>Recent content in 9.3 الگوهای طراحی رفتاری on زبان گو فارسی</description><generator>Hugo -- gohugo.io</generator><language>fa</language><copyright>2023 GoFarsi All rights reserved</copyright><atom:link href="https://book.gofarsi.ir/chapter-9/behavioral-patterns/feed.xml" rel="self" type="application/rss+xml"/><item><author/><title>9.3.1 الگو Chain Of Responsibility</title><link>https://book.gofarsi.ir/chapter-9/behavioral-patterns/go-chain-of-responsibility-pattern/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/behavioral-patterns/go-chain-of-responsibility-pattern/</guid><description>&lt;h2 id="9311---الگوی-زنجیره-مسئولیت-chain-of-responsibility">
9.3.1.1 - الگوی زنجیره مسئولیت (Chain of Responsibility)
&lt;a class="anchor" href="#9311---%d8%a7%d9%84%da%af%d9%88%db%8c-%d8%b2%d9%86%d8%ac%db%8c%d8%b1%d9%87-%d9%85%d8%b3%d8%a6%d9%88%d9%84%db%8c%d8%aa-chain-of-responsibility">#&lt;/a>
&lt;/h2>
&lt;p>الگوی زنجیره مسئولیت (Chain of Responsibility) یک الگوی طراحی رفتاری است که به شما امکان می‌دهد درخواست‌ها را در امتداد زنجیره‌ای از هندلرها (handlers) پاس دهید. هر هندلر پس از دریافت یک درخواست، تصمیم می‌گیرد که درخواست را پردازش کند یا آن را به هندلر بعدی در زنجیره منتقل نماید.&lt;/p>
&lt;h3 id="9312----مشکل">
9.3.1.2 - مشکل
&lt;a class="anchor" href="#9312----%d9%85%d8%b4%da%a9%d9%84">#&lt;/a>
&lt;/h3>
&lt;p>فرض کنید روی یک سیستم سفارش آنلاین کار می‌کنید. می‌خواهید دسترسی به سیستم را محدود کنید تا فقط کاربران احراز هویت شده بتوانند سفارش ایجاد کنند. همچنین، کاربرانی که دارای مجوز مدیریت هستند باید دسترسی کامل به تمام سفارشات داشته باشند.&lt;/p>
&lt;p>بعد از کمی برنامه‌ریزی، متوجه می‌شوید که این بررسی‌ها باید به صورت متوالی انجام شوند. برنامه می‌تواند هر زمان درخواستی را که حاوی اعتبارنامه (credentials) کاربر است دریافت می‌کند، تلاش کند کاربر را در سیستم احراز هویت کند. با این حال، اگر این اعتبارنامه‌ها صحیح نباشند و احراز هویت با شکست مواجه شود، دلیلی برای ادامه سایر بررسی‌ها وجود ندارد.&lt;/p>
&lt;p>&lt;img src="../../../assets/img/content/chapter9/designPatterns/problem1-en.png" alt="chain-problem1-en" />
در ماه‌های بعد، چندین مورد دیگر از این بررسی‌های متوالی را پیاده‌سازی کردید.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>یکی از همکاران شما پیشنهاد کرده است که انتقال مستقیم داده‌های خام به سیستم سفارش‌دهی ناامن است. بنابراین، یک مرحله اعتبارسنجی اضافی برای تجزیه وتحلیل کردن داده‌ها در یک درخواست اضافه کردید.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>بعداً، کسی متوجه شد که سیستم در برابر کرک رمز عبور با brute force آسیب‌پذیر است. برای جلوگیری از این، به سرعت یک بررسی برای فیلتر کردن درخواست‌های ناموفق مکرر از یک آدرس IP مشابه اضافه کردید.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>فرد دیگری پیشنهاد کرد که با بازگرداندن نتایج کَش (cache) شده در درخواست‌های تکراری حاوی داده‌های یکسان، می‌توانید سرعت سیستم را افزایش دهید. از این رو، یک بررسی دیگر اضافه کردید که به درخواست اجازه می‌دهد تنها در صورتی که پاسخ کَش شده مناسبی وجود نداشته باشد، به سیستم منتقل شود.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="../../../assets/img/content/chapter9/designPatterns/problem2-en.png" alt="chain-problem2-en" />&lt;/p>
&lt;p>کد مورد بررسی که از قبل هم آشفته‌تر به نظر می‌رسد، با اضافه شدن هر قابلیت جدید، بیشتر و بیشتر آشفته می‌شود. تغییر یک قسمت گاهی اوقات بر سایر قسمت‌ها تأثیر می‌گذاشت. بدترین حالت این بود که وقتی می‌خواستید از این بررسی‌ها برای محافظت از دیگر اجزای سیستم استفاده‌ی مجدد کنید، مجبور بودید بخشی از کد را تکرار کنید، زیرا آن اجزا به برخی از بررسی‌ها نیاز داشتند، اما نه به همه‌ی آن‌ها. درک و نگهداری این سیستم بسیار دشوار و پرهزینه است. پس مدت زمانی با کد درگیر بودید تا اینکه یک روز تصمیم گرفتید کل سیستم را بازنگری (refactor) کنید.&lt;/p>
&lt;h3 id="9313---راه-حل">
9.3.1.3 - راه حل
&lt;a class="anchor" href="#9313---%d8%b1%d8%a7%d9%87-%d8%ad%d9%84">#&lt;/a>
&lt;/h3>
&lt;p>الگوی زنجیره مسئولیت، مانند بسیاری دیگر از الگوهای طراحی رفتاری، بر تبدیل رفتارهای خاص به اشیاء مستقل به نام هندلر (handler) تکیه دارد. در این مورد، هر بررسی باید به کلاس خود با یک روش واحد که بررسی را انجام می دهد استخراج شود. درخواست، همراه با داده‌های آن، به عنوان آرگومان به این متد منتقل می‌شود.&lt;/p>
&lt;p>این الگو پیشنهاد می‌کند که این هندلرها را به یک زنجیره متصل کنید. هر هندلر متصل دارای فیلدی برای ذخیره مرجع به هندلر بعدی در زنجیره است. هندلرها علاوه بر پردازش یک درخواست، آن را در امتداد زنجیره به جلو منتقل می کنند. درخواست در امتداد زنجیره حرکت می کند تا زمانی که همه هندلرها فرصت پردازش آن را پیدا کنند.&lt;/p>
&lt;p>بهترین بخش اینجاست: یک هندلر می تواند تصمیم بگیرد که درخواست را بیشتر به پایین زنجیره منتقل نکند و عملاً پردازش بیشتر را متوقف کند.&lt;/p>
&lt;p>در مثال ما با سیستم‌های سفارش، یک هندلر پردازش را انجام می‌دهد و سپس تصمیم می‌گیرد که آیا درخواست را در امتداد زنجیره به پایین منتقل کند یا خیر. با فرض اینکه درخواست حاوی داده‌های صحیح باشد، همه هندلرها می‌توانند رفتار اصلی خود را اجرا کنند، چه این بررسی مربوط به احراز هویت باشد یا ذخیره‌سازی در کَش.&lt;/p>
&lt;p>&lt;img src="../../../assets/img/content/chapter9/designPatterns/solution1-en.png" alt="chain-solution1-en" />&lt;/p>
&lt;p>با این حال، رویکرد کمی متفاوت دیگری وجود دارد که در آن، یک هندلر پس از دریافت یک درخواست، تصمیم می‌گیرد که آیا می‌تواند آن را پردازش کند. اگر بتواند پردازش را انجام دهد، دیگر آن را به هیچ وجه به جای دیگر منتقل نمی‌کند. پس فقط یک هندلر درخواست را پردازش می‌کند یا اصلاً هیچ کدام را در نظر نمی‌گیرد. این رویکرد هنگام برخورد با رویدادها در پشته‌های عناصر درون یک رابط کاربری گرافیکی (GUI) بسیار رایج است.&lt;/p>
&lt;p>برای مثال، هنگامی که کاربر روی یک دکمه کلیک می‌کند، رویداد از طریق زنجیره‌ای از عناصر رابط کاربری منتشر می‌شود که از دکمه شروع می‌شود، در امتداد کانتینرهای(containers) آن (مانند فرم‌ها یا پنل‌ها) حرکت می‌کند و به پنجره اصلی برنامه ختم می‌شود. رویداد توسط اولین عنصر در زنجیره که قادر به رسیدگی به آن است، پردازش می‌شود. این مثال همچنین قابل توجه است زیرا نشان می دهد که همیشه می توان یک زنجیره را از یک درخت شیء (object tree) استخراج کرد.&lt;/p>
&lt;p>&lt;img src="../../../assets/img/content/chapter9/designPatterns/solution2-en.png" alt="chain-solution2-en" />&lt;/p>
&lt;p>بسیار مهم است که همه کلاس‌های هندلر یک رابط مشترک را پیاده‌سازی کنند. هر هندلر مشخص (concrete) فقط باید به وجود داشتن متد &lt;code>execute&lt;/code> در هندلر بعدی اهمیت دهد. به این ترتیب، می‌توانید زنجیره‌ها را در زمان اجرا با استفاده از هندلرهای مختلف بدون اتصال کد خود به کلاس‌های مشخص آن‌ها بسازید.&lt;/p>
&lt;h3 id="9314----تشبیه-دنیای-واقعی">
9.3.1.4 - تشبیه دنیای واقعی
&lt;a class="anchor" href="#9314----%d8%aa%d8%b4%d8%a8%db%8c%d9%87-%d8%af%d9%86%db%8c%d8%a7%db%8c-%d9%88%d8%a7%d9%82%d8%b9%db%8c">#&lt;/a>
&lt;/h3>
&lt;p>&lt;img src="../../../assets/img/content/chapter9/designPatterns/chain-of-responsibility-comic-1-en.png" alt="chain-chain-of-responsibility-comic-1-en" />&lt;/p>
&lt;p>به تازگی سخت افزار جدیدی برای کامپیوتر خود خریداری و نصب کرده‌اید. از آنجایی که به اصطلاح یک «گیک» هستید، سیستم عامل های مختلفی روی کامپیوترتان نصب شده است. برای اینکه ببینید آیا سخت افزار جدید پشتیبانی می شود، سعی می کنید همه آنها را بوت کنید. ویندوز به طور خودکار سخت افزار را شناسایی و فعال می کند. با این حال، لینوکس دوست داشتنی شما از کار با سخت افزار جدید امتناع می‌کند. با جرقه‌ای کوچک از امید، تصمیم می‌گیرید با شماره تلفن پشتیبانی فنی که روی جعبه نوشته شده است تماس بگیرید.&lt;/p>
&lt;p>اولین چیزی که می شنوید صدای رباتیک پاسخگوی خودکار است. این پاسخگو 9 راه حل رایج برای مشکلات مختلف را پیشنهاد می کند که هیچ کدام به مورد شما مرتبط نیستند. پس از مدتی، ربات شما را به یک اپراتور زنده متصل می‌کند.&lt;/p>
&lt;p>افسوس، اپراتور هم نمی‌تواند راه حل خاصی را پیشنهاد کند. او همچنان بخش‌های طولانی از دفترچه راهنما را نقل می‌کند و از گوش دادن به نظرات شما امتناع می‌ورزد. بعد از اینکه برای دهمین بار عبارت «آیا کامپیوتر را خاموش و روشن کرده‌اید؟» را می‌شنوید، درخواست می‌کنید که به یک مهندس واقعی وصل شوید.&lt;/p>
&lt;p>در نهایت، اپراتور تماس شما را به یکی از مهندسان منتقل می کند که احتمالاً ساعت ها در اتاق سرور تاریک زیرزمین یک ساختمان اداری نشسته و مشتاق یک گفتگوی انسانی زنده بوده است. مهندس به شما می گوید که درایورهای مناسب برای سخت افزار جدید خود را از کجا دانلود کنید و چگونه آنها را روی لینوکس نصب کنید. در نهایت، راه حل پیدا شد! تماس را با شادی تمام قطع می کنید.&lt;/p>
&lt;h3 id="9315---مثال">
9.3.1.5 - مثال
&lt;a class="anchor" href="#9315---%d9%85%d8%ab%d8%a7%d9%84">#&lt;/a>
&lt;/h3>
&lt;p>درک الگوی زنجیره مسئولیت(Chain of Responsibility) با یک مثال بهتر انجام می‌شود. بیایید به یک بیمارستان به عنوان مثال توجه کنیم. یک بیمارستان بخش‌های مختلفی دارد مانند:&lt;/p>
&lt;ul>
&lt;li>پذیرش (Reception)&lt;/li>
&lt;li>پزشک (Doctor)&lt;/li>
&lt;li>داروخانه (Medicine Room)&lt;/li>
&lt;li>صندوق (Cashier)&lt;/li>
&lt;/ul>
&lt;p>هر زمان که بیماری وارد می‌شود، ابتدا به پذیرش، سپس به پزشک، سپس به داروخانه و سپس به صندوق و غیره می‌رود. به نوعی، بیمار به زنجیره‌ای از بخش‌ها فرستاده می‌شود که پس از انجام کار، بیمار را به سایر بخش‌ها می‌فرستد. اینجاست که الگوی زنجیره مسئولیت وارد عمل می‌شود.&lt;/p>
&lt;p>&lt;strong>چه زمانی از این الگو استفاده کنیم؟&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>این الگو در شرایطی کاربرد دارد که چندین گزینه برای پردازش یک درخواست یکسان وجود داشته باشد.&lt;/li>
&lt;li>همچنین زمانی که نمی‌خواهید کلاینت (فرستنده درخواست)، گیرنده را انتخاب کند، زیرا چندین شیء می‌توانند درخواست را مدیریت کنند. بعلاوه، می‌خواهید کلاینت را از گیرنده‌ها جدا کنید. کلاینت فقط باید عنصر اول زنجیره را بشناسد.&lt;/li>
&lt;/ul>
&lt;p>همانطور که در مثال بیمارستان مشاهده کردید، بیمار ابتدا به پذیرش مراجعه می‌کند و سپس پذیرش بر اساس وضعیت فعلی بیمار، او را به نفر بعدی در زنجیره (احتمالا پزشک) می‌فرستد.&lt;/p>
&lt;h2 id="uml-diagram">
&lt;strong>UML Diagram:&lt;/strong>
&lt;a class="anchor" href="#uml-diagram">#&lt;/a>
&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>handler&lt;/td>
&lt;td>department.go&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Concrete Handler 1&lt;/td>
&lt;td>account.go&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Concrete Handler 2&lt;/td>
&lt;td>doctor.go&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Concrete Handler 3&lt;/td>
&lt;td>medical.go&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Concrete Handler 4&lt;/td>
&lt;td>cashier.go&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Client&lt;/td>
&lt;td>main.go&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="مثال-عملی">
مثال عملی
&lt;a class="anchor" href="#%d9%85%d8%ab%d8%a7%d9%84-%d8%b9%d9%85%d9%84%db%8c">#&lt;/a>
&lt;/h3>
&lt;p>&lt;strong>department.go&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">package main
type department interface {
execute(*patient)
setNext(department)
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>reception.go&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import &amp;quot;fmt&amp;quot;
type reception struct {
next department
}
func (r *reception) execute(p *patient) {
if p.registrationDone {
fmt.Println(&amp;quot;Patient registration already done&amp;quot;)
r.next.execute(p)
return
}
fmt.Println(&amp;quot;Reception registering patient&amp;quot;)
p.registrationDone = true
r.next.execute(p)
}
func (r *reception) setNext(next department) {
r.next = next
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>doctor.go&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import &amp;quot;fmt&amp;quot;
type doctor struct {
next department
}
func (d *doctor) execute(p *patient) {
if p.doctorCheckUpDone {
fmt.Println(&amp;quot;Doctor checkup already done&amp;quot;)
d.next.execute(p)
return
}
fmt.Println(&amp;quot;Doctor checking patient&amp;quot;)
p.doctorCheckUpDone = true
d.next.execute(p)
}
func (d *doctor) setNext(next department) {
d.next = next
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>medical.go&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import &amp;quot;fmt&amp;quot;
type medical struct {
next department
}
func (m *medical) execute(p *patient) {
if p.medicineDone {
fmt.Println(&amp;quot;Medicine already given to patient&amp;quot;)
m.next.execute(p)
return
}
fmt.Println(&amp;quot;Medical giving medicine to patient&amp;quot;)
p.medicineDone = true
m.next.execute(p)
}
func (m *medical) setNext(next department) {
m.next = next
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>cashier.go&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import &amp;quot;fmt&amp;quot;
type cashier struct {
next department
}
func (c *cashier) execute(p *patient) {
if p.paymentDone {
fmt.Println(&amp;quot;Payment Done&amp;quot;)
}
fmt.Println(&amp;quot;Cashier getting money from patient patient&amp;quot;)
}
func (c *cashier) setNext(next department) {
c.next = next
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>patient.go&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">package main
type patient struct {
name string
registrationDone bool
doctorCheckUpDone bool
medicineDone bool
paymentDone bool
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>main.go&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">package main
func main() {
cashier := &amp;amp;cashier{}
//Set next for medical department
medical := &amp;amp;medical{}
medical.setNext(cashier)
//Set next for doctor department
doctor := &amp;amp;doctor{}
doctor.setNext(medical)
//Set next for reception department
reception := &amp;amp;reception{}
reception.setNext(doctor)
patient := &amp;amp;patient{name: &amp;quot;abc&amp;quot;}
//Patient visiting
reception.execute(patient)
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>Output:&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">Reception registering patient
Doctor checking patient
Medical giving medicine to patient
Cashier getting money from patient patient
&lt;/code>&lt;/pre>
&lt;h2 id="full-working-code">
&lt;strong>Full Working Code:&lt;/strong>
&lt;a class="anchor" href="#full-working-code">#&lt;/a>
&lt;/h2>
&lt;pre>&lt;code class="language-go">package main
import &amp;quot;fmt&amp;quot;
type department interface {
execute(*patient)
setNext(department)
}
type reception struct {
next department
}
func (r *reception) execute(p *patient) {
if p.registrationDone {
fmt.Println(&amp;quot;Patient registration already done&amp;quot;)
r.next.execute(p)
return
}
fmt.Println(&amp;quot;Reception registering patient&amp;quot;)
p.registrationDone = true
r.next.execute(p)
}
func (r *reception) setNext(next department) {
r.next = next
}
type doctor struct {
next department
}
func (d *doctor) execute(p *patient) {
if p.doctorCheckUpDone {
fmt.Println(&amp;quot;Doctor checkup already done&amp;quot;)
d.next.execute(p)
return
}
fmt.Println(&amp;quot;Doctor checking patient&amp;quot;)
p.doctorCheckUpDone = true
d.next.execute(p)
}
func (d *doctor) setNext(next department) {
d.next = next
}
type medical struct {
next department
}
func (m *medical) execute(p *patient) {
if p.medicineDone {
fmt.Println(&amp;quot;Medicine already given to patient&amp;quot;)
m.next.execute(p)
return
}
fmt.Println(&amp;quot;Medical giving medicine to patient&amp;quot;)
p.medicineDone = true
m.next.execute(p)
}
func (m *medical) setNext(next department) {
m.next = next
}
type cashier struct {
next department
}
func (c *cashier) execute(p *patient) {
if p.paymentDone {
fmt.Println(&amp;quot;Payment Done&amp;quot;)
}
fmt.Println(&amp;quot;Cashier getting money from patient patient&amp;quot;)
}
func (c *cashier) setNext(next department) {
c.next = next
}
type patient struct {
name string
registrationDone bool
doctorCheckUpDone bool
medicineDone bool
paymentDone bool
}
func main() {
cashier := &amp;amp;cashier{}
//Set next for medical department
medical := &amp;amp;medical{}
medical.setNext(cashier)
//Set next for doctor department
doctor := &amp;amp;doctor{}
doctor.setNext(medical)
//Set next for reception department
reception := &amp;amp;reception{}
reception.setNext(doctor)
patient := &amp;amp;patient{name: &amp;quot;abc&amp;quot;}
//Patient visiting
reception.execute(patient)
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>Output:&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">Reception registering patient
Doctor checking patient
Medical giving medicine to patient
Cashier getting money from patient patient
&lt;/code>&lt;/pre></description></item><item><author/><title>9.3.2 الگو Command</title><link>https://book.gofarsi.ir/chapter-9/behavioral-patterns/go-command-pattern/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/behavioral-patterns/go-command-pattern/</guid><description>&lt;h2 id="9321-الگوی-طراحی-فرمان-command">
9.3.2.1-الگوی طراحی فرمان (Command)
&lt;a class="anchor" href="#9321-%d8%a7%d9%84%da%af%d9%88%db%8c-%d8%b7%d8%b1%d8%a7%d8%ad%db%8c-%d9%81%d8%b1%d9%85%d8%a7%d9%86-command">#&lt;/a>
&lt;/h2>
&lt;p>الگوی طراحی Command یک الگوی رفتاری است که یک درخواست را به یک شیء(object) مستقل تبدیل می کند که حاوی تمام اطلاعات مربوط به درخواست است. این تغییر شکل به شما امکان می دهد درخواست‌ها را به عنوان آرگومان متد ارسال کنید و اجرای یک درخواست را به تعویق بیندازید یا در صف قرار دهید و از عملیات قابل لغو پشتیبانی کنید.&lt;/p>
&lt;h2 id="9322-مشکل">
9.3.2.2-مشکل
&lt;a class="anchor" href="#9322-%d9%85%d8%b4%da%a9%d9%84">#&lt;/a>
&lt;/h2>
&lt;p>فرض کنید روی یک برنامه ویرایشگر متن جدید کار می‌کنید. وظیفه فعلی شما ایجاد نوار ابزار با تعدادی دکمه برای عملیات مختلف ویرایشگر است. شما یک کلاس Button بسیار مرتب ایجاد کرده اید که می‌توان از آن برای دکمه های روی نوار ابزار و همچنین برای دکمه های عمومی در گفتگوهای مختلف استفاده کرد.&lt;/p>
&lt;p>&lt;img src="../../../assets/img/content/chapter9/designPatterns/command-problem1.png" alt="command-problem1" />&lt;/p>
&lt;h2 id="9323-راهحل-نادرست-و-مشکلات-آن">
9.3.2.3-راه‌حل نادرست و مشکلات آن
&lt;a class="anchor" href="#9323-%d8%b1%d8%a7%d9%87%d8%ad%d9%84-%d9%86%d8%a7%d8%af%d8%b1%d8%b3%d8%aa-%d9%88-%d9%85%d8%b4%da%a9%d9%84%d8%a7%d8%aa-%d8%a2%d9%86">#&lt;/a>
&lt;/h2>
&lt;p>در حالی که همه این دکمه ها شبیه به هم به نظر می رسند، همه آنها قرار است کارهای متفاوتی انجام دهند. کد مربوط به هندلرهای کلیک های مختلف این دکمه ها را کجا قرار می دهید؟ ساده ترین راه حل ایجاد انبوهی از زیرمجموعه‌ها برای هر مکانی است که دکمه در آن استفاده می شود. این زیرمجموعه ها حاوی کدهایی هستند که باید در صورت کلیک روی دکمه اجرا شوند.&lt;/p>
&lt;p>&lt;img src="../../../assets/img/content/chapter9/designPatterns/command-problem2.png" alt="command-problem2" />&lt;/p>
&lt;p>چندان طول نمی کشد که متوجه می شوید این رویکرد عمیقا معیوب است. اول اینکه شما تعداد زیادی از زیرمجموعه‌ها دارید و این خوب است، مگر اینکه هر بار که کلاس Button پایه را تغییر می دهید، خطر شکستن کد در این زیرمجموعه‌ها را نداشته باشید. به بیان ساده، کد رابط کاربری گرافیکی شما به طرز نامناسبی به کد ناپایدار منطق تجاری وابسته شده است.&lt;/p>
&lt;p>&lt;img src="../../../assets/img/content/chapter9/designPatterns/command-problem3-en.png" alt="command-problem3" />&lt;/p>
&lt;p>و حالا بدترین قسمت مربوط به برخی از عملیات‌ها مثل، کپی/پیست کردن متن، باید از چندین مکان فراخوانی شوند. به عنوان مثال، کاربر می تواند روی دکمه &amp;ldquo;کپی&amp;rdquo; کوچک در نوار ابزار کلیک کند یا چیزی را از طریق منوی زمینه کپی کند یا فقط کلیدهای &lt;code>Ctrl+C&lt;/code> را روی صفحه کلید فشار دهد.&lt;/p>
&lt;p>در ابتدا، زمانی که برنامه ما فقط نوار ابزار را داشت، قرار دادن اجرای عملیات مختلف در زیرمجموعه‌های دکمه اشکالی نداشت. به عبارت دیگر، داشتن کد کپی متن داخل زیرمجموعه &lt;code>CopyButton&lt;/code> خوب بود. اما پس از آن، زمانی که منوها، میانبرها و سایر موارد را پیاده سازی می کنید، باید کد عملیات را در بسیاری از کلاس ها تکرار کنید یا منوها را به دکمه‌ها وابسته کنید، که این کار گزینه‌ای بدتر است.&lt;/p>
&lt;h2 id="9324-راهحل">
9.3.2.4-راه‌حل
&lt;a class="anchor" href="#9324-%d8%b1%d8%a7%d9%87%d8%ad%d9%84">#&lt;/a>
&lt;/h2>
&lt;p>طراحی خوب نرم‌افزار اغلب بر اساس اصل جداسازی دغدغه‌ها (&lt;em>principle of separation of concerns&lt;/em>) بنا شده است، که معمولاً منجر به شکستن یک برنامه به لایه‌های مختلفی می‌شود. رایج ترین مثال: یک لایه برای رابط کاربری گرافیکی و یک لایه دیگر برای منطق تجاری. لایه GUI مسئول ارائه یک تصویر زیبا روی صفحه، گرفتن هر ورودی و نشان دادن نتایج کارهایی است که کاربر و برنامه انجام می دهند. با این حال، زمانی که نوبت به انجام کار مهمی مانند محاسبه مسیر ماه یا نوشتن گزارش سالانه می رسد، لایه GUI کار را به لایه زیرین منطق تجاری واگذار می‌کند.&lt;/p>
&lt;p>&lt;img src="../../../assets/img/content/chapter9/designPatterns/command-solution1-en.png" alt="command-solution1-en" />&lt;/p>
&lt;p>در کد ممکن است به این شکل به نظر برسد: یک شیء GUI متدی از یک شیء منطق تجاری را فراخوانی می‌کند و برخی استدلال‌ها را برای آن ارسال می‌کند. این فرآیند معمولاً به عنوان فرستادن یک درخواست از یک شیء به شیء دیگر توصیف می شود.&lt;/p>
&lt;p>الگوی command پیشنهاد می کند که اشیاء GUI نباید این درخواست ها را مستقیماً ارسال کنند. در عوض، شما باید تمام جزئیات درخواست، مانند شیء فراخوانده شده، نام متد و لیست آرگومان‌ها را به یک کلاس فرمان جداگانه با یک متد واحد که این درخواست را فعال می کند را استخراج کنید.&lt;/p>
&lt;p>اشیاء فرمان به عنوان پیوندهایی بین اشیاء مختلف رابط کاربری و منطق تجاری عمل می کنند. از این به بعد، شیء GUI نیازی به دانستن اینکه کدام شیء منطق تجاری درخواست را دریافت خواهد کرد و چگونه پردازش خواهد شد، ندارد. شیء GUI فقط فرمان را فعال می‌کند، که تمام جزئیات را مدیریت می‌کند.&lt;/p>
&lt;p>&lt;img src="../../../assets/img/content/chapter9/designPatterns/command-solution2-en.png" alt="command-solution2-en" />&lt;/p>
&lt;p>گام بعدی این است که دستورات خود را برای پیاده سازی همان رابط کاربری وادار کنید. به طور معمول، فقط یک متد اجرایی دارد که هیچ پارامتری را نمی پذیرد. این رابط به شما امکان می دهد از دستورات مختلف با همان فرستنده درخواست استفاده کنید، بدون اینکه آن را به concrete کلاس‌های مشخص دستورات پیوند دهید. به عنوان یک امتیاز، اکنون می توانید اشیاء فرمان مرتبط با فرستنده را جابجا کنید و به طور موثر رفتار فرستنده را در زمان اجرا تغییر دهید.&lt;/p>
&lt;p>شاید به یک قطعه گمشده از پازل که پارامترهای درخواست است توجه کرده باشید. یک شیء GUI ممکن است برخی از پارامترها را به شیء لایه تجاری ارائه کرده باشد. از آنجایی که متد اجرای دستور هیچ پارامتری ندارد، چگونه جزئیات درخواست را به گیرنده منتقل کنیم؟ به نظر می رسد که دستور باید از قبل با این داده ها پیکربندی شده باشد، یا قادر به دریافت آن به تنهایی باشد.&lt;/p>
&lt;p>&lt;img src="../../../assets/img/content/chapter9/designPatterns/command-solution3-en.png" alt="command-solution3-en" />&lt;/p>
&lt;p>حالا که الگوی command را اعمال کرده‌ایم، دیگر به تمام آن زیرمجموعه‌های دکمه برای پیاده‌سازی رفتارهای مختلف کلیک نیاز نداریم. کافی است یک فیلد واحد در کلاس پایه &lt;code>Button&lt;/code> قرار دهیم که مرجعی به یک شیء فرمان را ذخیره کند و دکمه را وادار کنیم تا آن فرمان را با یک کلیک اجرا کند.&lt;/p>
&lt;p>شما مجموعه‌ای از کلاس‌های فرمان را برای هر عملیاتی که ممکن است، پیاده‌سازی خواهید کرد و آن‌ها را با دکمه‌های خاص، بسته به رفتار مورد نظر دکمه‌ها، مرتبط می‌کنید.&lt;/p>
&lt;p>سایر عناصر رابط کاربری گرافیکی، مانند منوها، میانبرها یا کل کادرهای محاوره‌ای، می‌توانند به همین روش پیاده‌سازی شوند. آنها به یک فرمان مرتبط می شوند که هنگام تعامل کاربر با عنصر رابط کاربری اجرا می‌شود. همانطور که احتمالاً تا به حال حدس زده اید، عناصر مرتبط با عملیات مشابه به دستورات مشابه مرتبط می‌شوند و از تکرار هر گونه کد جلوگیری می‌کنند.&lt;/p>
&lt;p>در نتیجه، دستورات به یک لایه میانی مناسب تبدیل می شوند که وابستگی بین لایه های رابط کاربری و منطق تجاری را کاهش می‌دهد. و این تنها بخشی از مزایایی است که الگوی فرمان می تواند ارائه دهد!&lt;/p>
&lt;h2 id="9325-مثال-از-دنیای-واقعی">
9.3.2.5-مثال از دنیای واقعی
&lt;a class="anchor" href="#9325-%d9%85%d8%ab%d8%a7%d9%84-%d8%a7%d8%b2-%d8%af%d9%86%db%8c%d8%a7%db%8c-%d9%88%d8%a7%d9%82%d8%b9%db%8c">#&lt;/a>
&lt;/h2>
&lt;p>&lt;img src="../../../assets/img/content/chapter9/designPatterns/command-comic-1.png" alt="command-comic-1" />&lt;/p>
&lt;p>بعد از یک پیاده روی طولانی در شهر، به یک رستوران خوب می‌رسید و پشت میز کنار پنجره می‌نشینید. یک پیشخدمت خوش برخورد به سراغ شما می‌آید و به سرعت سفارش شما را می‌گیرد و آن را روی یک تکه کاغذ یادداشت می‌کند. پیشخدمت به آشپزخانه می رود و سفارش را روی دیوار می‌چسباند. پس از مدتی، سفارش به دست سرآشپز می‌رسد، او آن را می‌خواند و غذا را بر اساس آن طبخ می‌دهد. آشپز غذا را به همراه سفارش روی سینی قرار می‌دهد. پیشخدمت سینی را کشف می‌کند، سفارش را بررسی می‌کند تا مطمئن شود همه چیز مطابق میل شماست و همه چیز را سر میز شما می آورد.&lt;/p>
&lt;p>سفارش کاغذی به عنوان یک فرمان عمل می کند. تا زمانی که سرآشپز آماده سرو آن نباشد، در صف باقی می ماند. سفارش حاوی تمام اطلاعات مرتبط مورد نیاز برای پخت غذا است. این به سرآشپز اجازه می‌دهد بدون اینکه به طور مستقیم برای دریافت جزئیات سفارش از شما بپرسد، بلافاصله شروع به پخت و پز کند.&lt;/p>
&lt;h2 id="9326--مثال">
9.3.2.6- مثال
&lt;a class="anchor" href="#9326--%d9%85%d8%ab%d8%a7%d9%84">#&lt;/a>
&lt;/h2>
&lt;p>####s اجزای اصلی در الگوی طراحی فرمان&lt;/p>
&lt;p>اجزای اصلی که در الگوی طراحی فرمان استفاده می شوند عبارتند از:&lt;/p>
&lt;ul>
&lt;li>گیرنده (Receiver) - کلاسی است که حاوی منطق تجاری است. شیء فرمان فقط درخواست های خود را به گیرنده به تعویق می اندازد.&lt;/li>
&lt;li>فرمان (Command) - گیرنده را جاسازی می‌کند و یک عمل خاص از گیرنده را متصل می کند.&lt;/li>
&lt;li>اجراکننده (Invoker) - فرمان را جاسازی (embed) می‌کند و با فراخوانی متد اجرای فرمان، فرمان را فراخوانی می کند.&lt;/li>
&lt;li>کاربر (Client) - فرمان را با گیرنده مناسب ایجاد می‌کند و گیرنده را از سازنده فرمان دور می زند. پس از آن، همچنین فرمان حاصل را با یک اجراکننده مرتبط می‌کند.&lt;/li>
&lt;/ul>
&lt;p>بیایید وضعیتی را درک کنیم که پس از آن مشخص خواهد شد که چرا الگوی فرمان مفید است.
حالت یک تلویزیون را در نظر بگیرید. تلویزیون را می توان با موارد زیر روشن کرد:&lt;/p>
&lt;ul>
&lt;li>دکمه روشن کنترل از راه دور&lt;/li>
&lt;li>دکمه روشن روی تلویزیون&lt;/li>
&lt;/ul>
&lt;p>هر دوی این نقاط شروع کار یکسانی انجام می دهند یعنی روشن کردن تلویزیون. برای روشن کردن تلویزیون، می توانیم شیء فرمان روشن را با گیرنده به عنوان تلویزیون پیاده سازی کنیم. هنگامی که متد &lt;code>execute()&lt;/code> روی این شیء فرمان روشن فراخوانده می شود، به نوبه خود تابع &lt;code>TV.on()&lt;/code> را فراخوانی می کند. بنابراین در این مورد:&lt;/p>
&lt;ul>
&lt;li>گیرنده تلویزیون است&lt;/li>
&lt;li>فرمان مورد نظر برابر با &lt;strong>command object&lt;/strong> روشن است که تلویزیون را جاسازی می‌کند.&lt;/li>
&lt;li>اجراکننده دکمه روشن کنترل از راه دور یا دکمه روشن تلویزیون است. هر دو شیء فرمان روشن را جاسازی می کنند.&lt;/li>
&lt;/ul>
&lt;p>در اینجا توجه داشته باشید که ما درخواست روشن کردن تلویزیون را در یک شیء فرمان ( &lt;strong>command object&lt;/strong>) روشن که توسط چندین اجراکننده قابل فراخوانی است، بسته بندی کرده‌ایم. این شیء فرمان روشن گیرنده (در اینجا تلویزیون) را جاسازی می‌کند و می‌تواند به طور مستقل اجرا شود.&lt;/p>
&lt;p>به عنوان مثال دیگری، مورد یک برنامه ادوبی فتوشاپ را در نظر بگیرید. در فتوشاپ، یک عملیات ذخیره را می توان از 3 مکان راه اندازی کرد:&lt;/p>
&lt;ul>
&lt;li>از منو&lt;/li>
&lt;li>از دکمه روی نوار بالا&lt;/li>
&lt;li>با استفاده از میانبر Ctrl+S&lt;/li>
&lt;/ul>
&lt;p>هر سه نقطه شروع کار یکسانی انجام می دهند، یعنی ذخیره تصویر فعلی در برنامه. این ذخیره را می توان در یک شیء فرمان ذخیره با تصویر فعلی باز در برنامه به عنوان گیرنده، قرار داد.&lt;/p>
&lt;p>مزایای ایجاد یک شیء فرمان جداگانه در مثالهای بالا چیست:&lt;/p>
&lt;ul>
&lt;li>منطق رابط کاربری را از منطق تجاری زیربنایی جدا می‌کند.&lt;/li>
&lt;li>نیاز به ایجاد هندلرهای مختلف برای هر یک از اجراکننده ها نیست.&lt;/li>
&lt;li>شیء فرمان حاوی تمام اطلاعات مورد نیاز برای اجرا است. از این رو می توان از آن برای اجرای به تعویق افتاده نیز استفاده کرد.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>حالا به نمودار UML نگاه کنیم.&lt;/strong>&lt;/p>
&lt;p>&lt;strong>نمودار UML:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>توجه کنید که چگونه اجراکننده فرمان را جاسازی می‌کند. درخواست به اجراکننده ارسال می شود و آن درخواست را به شیء فرمان کپسوله شده منتقل می کند.&lt;/li>
&lt;li>تمام اشیاء فرمان Concrete گیرنده را جاسازی می کنند.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>نگاشت&lt;/strong>&lt;/p>
&lt;p>جدول زیر نگاشت بازیگران نمودار UML را به بازیگران پیاده سازی واقعی در &amp;ldquo;مثال عملی&amp;rdquo; در زیر نشان می دهد.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Invoker&lt;/td>
&lt;td>button.go&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Command Interface&lt;/td>
&lt;td>command.go&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Concrete Command 1&lt;/td>
&lt;td>onCommand.go&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Concrete Command 2&lt;/td>
&lt;td>offCommand.go&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Receiver Interface&lt;/td>
&lt;td>device.go&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Concrete Receiver&lt;/td>
&lt;td>tv.go&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Client&lt;/td>
&lt;td>main.go&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="9327-پیاده-سازی">
9.3.2.7-پیاده سازی
&lt;a class="anchor" href="#9327-%d9%be%db%8c%d8%a7%d8%af%d9%87-%d8%b3%d8%a7%d8%b2%db%8c">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>button.go&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">package main
type button struct {
command command
}
func (b *button) press() {
b.command.execute()
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>command.go&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">package main
type command interface {
execute()
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>onCommand.go&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">package main
type onCommand struct {
device device
}
func (c *onCommand) execute() {
c.device.on()
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>offCommand.go&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">package main
type offCommand struct {
device device
}
func (c *offCommand) execute() {
c.device.off()
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>device.go&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">package main
type device interface {
on()
off()
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>tv.go&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import &amp;quot;fmt&amp;quot;
type tv struct {
isRunning bool
}
func (t *tv) on() {
t.isRunning = true
fmt.Println(&amp;quot;Turning tv on&amp;quot;)
}
func (t *tv) off() {
t.isRunning = false
fmt.Println(&amp;quot;Turning tv off&amp;quot;)
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>main.go&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">package main
func main() {
tv := &amp;amp;tv{}
onCommand := &amp;amp;onCommand{
device: tv,
}
offCommand := &amp;amp;offCommand{
device: tv,
}
onButton := &amp;amp;button{
command: onCommand,
}
onButton.press()
offButton := &amp;amp;button{
command: offCommand,
}
offButton.press()
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>Output:&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">Turning tv on
Turning tv off
&lt;/code>&lt;/pre>
&lt;h2 id="full-working-code">
&lt;strong>Full Working Code:&lt;/strong>
&lt;a class="anchor" href="#full-working-code">#&lt;/a>
&lt;/h2>
&lt;pre>&lt;code class="language-go">package main
import &amp;quot;fmt&amp;quot;
type button struct {
command command
}
func (b *button) press() {
b.command.execute()
}
type command interface {
execute()
}
type offCommand struct {
device device
}
func (c *offCommand) execute() {
c.device.off()
}
type onCommand struct {
device device
}
func (c *onCommand) execute() {
c.device.on()
}
type device interface {
on()
off()
}
type tv struct {
isRunning bool
}
func (t *tv) on() {
t.isRunning = true
fmt.Println(&amp;quot;Turning tv on&amp;quot;)
}
func (t *tv) off() {
t.isRunning = false
fmt.Println(&amp;quot;Turning tv off&amp;quot;)
}
func main() {
tv := &amp;amp;tv{}
onCommand := &amp;amp;onCommand{
device: tv,
}
offCommand := &amp;amp;offCommand{
device: tv,
}
onButton := &amp;amp;button{
command: onCommand,
}
onButton.press()
offButton := &amp;amp;button{
command: offCommand,
}
offButton.press()
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>Output:&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">Turning tv on
Turning tv off
&lt;/code>&lt;/pre></description></item><item><author/><title>9.3.3 الگو Iterator</title><link>https://book.gofarsi.ir/chapter-9/behavioral-patterns/go-iterator-pattern/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/behavioral-patterns/go-iterator-pattern/</guid><description>&lt;h2 id="9331-هدف">
9.3.3.1-هدف
&lt;a class="anchor" href="#9331-%d9%87%d8%af%d9%81">#&lt;/a>
&lt;/h2>
&lt;p>الگوي طراحی تکرارکننده (Iterator) یک الگوی رفتاری است که به شما امکان می دهد عناصر یک مجموعه را بدون نمایش ساختار درونی آن (فهرست، پشته، درخت و غیره) پیمایش کنید.&lt;/p>
&lt;h2 id="9332-مشکل">
9.3.3.2-مشکل
&lt;a class="anchor" href="#9332-%d9%85%d8%b4%da%a9%d9%84">#&lt;/a>
&lt;/h2>
&lt;p>مجموعه ها (collections) یکی از پرکاربردترین انواع داده در برنامه نویسی هستند. با این وجود، یک مجموعه فقط یک ظرف برای گروهی از اشیاء است.&lt;/p>
&lt;p>&lt;img src="../../../assets/img/content/chapter9/designPatterns/iterator-problem1.png" alt="iterator-problem1" />
(انواع مختلف از collections)&lt;/p>
&lt;p>اکثر مجموعه ها عناصر خود را در لیست های ساده ذخیره می کنند. با این حال، برخی از آنها بر اساس پشته‌ها، درختان، نمودارها و سایر ساختارهای داده پیچیده ساخته شده‌اند.&lt;/p>
&lt;p>اما مهم نیست که یک مجموعه چگونه ساختار یافته باشد، باید روشی برای دسترسی به عناصر آن ارائه دهد تا کدهای دیگر بتوانند از این عناصر استفاده کنند. باید راهی برای مرور هر عنصر از مجموعه بدون دسترسی مکرر به عناصر مشابه وجود داشته باشد.&lt;/p>
&lt;p>اگر مجموعه ای مبتنی بر لیست دارید، این کار ممکن است آسان به نظر برسد. شما فقط روی تمام عناصر حلقه می زنید. اما چگونه عناصر یک ساختار داده پیچیده مانند درخت را به طور متوالی طی کنید؟ به عنوان مثال، ممکن است یک روز فقط با پیمایش عمق اول (depth-first) یک درخت مشکلی نداشته باشید. اما روز بعد ممکن است به پیمایش عرض اول (breadth-first) نیاز داشته باشید. و هفته بعد، ممکن است به چیز دیگری مانند دسترسی تصادفی به عناصر درخت نیاز داشته باشید.&lt;/p>
&lt;p>&lt;img src="../../../assets/img/content/chapter9/designPatterns/iterator-problem2.png" alt="iterator-problem2" />
(از یک مجموعه می‌توان به چند روش مختلف عبور کرد.)&lt;/p>
&lt;p>افزودن الگوریتم های پیمایش بیشتر و بیشتر به مجموعه به تدریج مسئولیت اصلی آن که ذخیره کارآمد داده است را تحت الشعاع قرار می دهد. علاوه بر این، برخی الگوریتم‌ها ممکن است برای یک برنامه خاص طراحی شده باشند، بنابراین گنجاندن آنها در یک کلاس عمومی مجموعه عجیب خواهد بود.&lt;/p>
&lt;p>از طرف دیگر، کد کلاینت که قرار است با مجموعه‌های مختلفی کار کند، حتی ممکن است اهمیتی ندهد که آنها عناصر خود را چگونه ذخیره می‌کنند. با این حال، از آنجایی که همه مجموعه‌ها روش‌های مختلفی برای دسترسی به عناصر خود ارائه می‌دهند، شما چاره‌ای جز اتصال کد خود به کلاس‌های مجموعه خاص ندارید.&lt;/p>
&lt;h2 id="9333-راهحل">
9.3.3.3-راه‌حل
&lt;a class="anchor" href="#9333-%d8%b1%d8%a7%d9%87%d8%ad%d9%84">#&lt;/a>
&lt;/h2>
&lt;p>ایده اصلی الگوی تکرارکننده (Iterator) این است که رفتار پیمایش یک مجموعه را به یک شیء جداگانه به نام «تکرارکننده» (Iterator) استخراج کند.&lt;/p>
&lt;p>&lt;img src="../../../assets/img/content/chapter9/designPatterns/iterator-solution1.png" alt="iterator-solution1" />
(تکرار کننده ها الگوریتم های پیمایش مختلفی را پیاده سازی می کنند. چندین شی تکرارکننده می‌توانند همزمان از یک مجموعه عبور کنند.)&lt;/p>
&lt;p>یک شیء تکرارکننده علاوه بر پیاده سازی الگوریتم پیمایش، تمام جزئیات پیمایش مانند موقعیت فعلی و تعداد عناصر باقی مانده تا انتها را دربرمی گیرد. به همین دلیل، چندین تکرارکننده می توانند به طور همزمان و مستقل از یکدیگر، یک مجموعه را طی کنند.&lt;/p>
&lt;p>معمولا تکرارکننده‌ها یک روش اصلی برای دریافت عناصر مجموعه ارائه می دهند. کاربر می تواند این روش را تا زمانی که چیزی برنگردد اجرا کند، به این معنی که تکرارکننده تمام عناصر را پیمایش کرده است.&lt;/p>
&lt;p>همه تکرارکننده‌ها باید یک رابط مشترک را پیاده سازی کنند. این کار باعث می شود کد کلاینت با هر نوع مجموعه یا هر الگوریتم پیمایشی سازگار باشد، به شرطی که یک تکرارکننده مناسب وجود داشته باشد. اگر به روش خاصی برای پیمایش یک مجموعه نیاز دارید، فقط یک کلاس تکرارکننده جدید بدون نیاز به تغییر مجموعه یا مشتری ایجاد کنید.&lt;/p>
&lt;h2 id="9334-نمونه-واقعی">
9.3.3.4-نمونه واقعی
&lt;a class="anchor" href="#9334-%d9%86%d9%85%d9%88%d9%86%d9%87-%d9%88%d8%a7%d9%82%d8%b9%db%8c">#&lt;/a>
&lt;/h2>
&lt;p>&lt;img src="../../../assets/img/content/chapter9/designPatterns/iterator-iterator-comic-1-en.png" alt="iterator-comic-1-en" />&lt;/p>
&lt;p>تصمیم می‌گیرید برای چند روز به شهر رم در ایتالیا سفر کنید و از تمام مناظر و جاذبه های اصلی آن دیدن کنید. اما هنگامی که به آنجا رسیدید، ممکن است زمان زیادی را برای قدم زدن در مسیرهای پر پیچ و خم تلف کنید، بدون اینکه حتی بتوانید نماد باستانی مثل کولوسئوم را پیدا کنید.&lt;/p>
&lt;p>از طرف دیگر، می توانید یک اپلیکیشن راهنمای مجازی برای گوشی هوشمند خود بخرید و از آن برای مسیریابی استفاده کنید. این کار هوشمند و ارزان است و می توانید تا هر زمان که بخواهید در مکان‌های جالبی توقف و دیدن کنید.&lt;/p>
&lt;p>یک راه حل دیگر این است که بخشی از بودجه سفر را صرف استخدام یک راهنمای محلی کنید که شهر را مثل کف دستش بشناسد. راهنما می‌تواند تور را مطابق با سلیقه شما تنظیم کند، هر جاذبه‌ای را به شما نشان دهد و داستان‌های هیجان‌انگیزی تعریف کند. این حتی سرگرم‌کننده‌تر خواهد بود، اما افسوس، گران‌تر هم خواهد بود.&lt;/p>
&lt;p>همه این گزینه‌ها - مسیرهای تصادفی که در ذهن شما به وجود می‌آیند، راهنمای هوشمند گوشی هوشمند یا راهنمای انسانی - به عنوان تکرارکننده‌هایی بر روی مجموعه عظیم مناظر و جاذبه‌های واقع در رم عمل می‌کنند.&lt;/p>
&lt;h2 id="9335-مثال">
9.3.3.5-مثال
&lt;a class="anchor" href="#9335-%d9%85%d8%ab%d8%a7%d9%84">#&lt;/a>
&lt;/h2>
&lt;h2 id="الگوی-طراحی-تکرارکننده-iterator">
الگوی طراحی تکرارکننده (Iterator)
&lt;a class="anchor" href="#%d8%a7%d9%84%da%af%d9%88%db%8c-%d8%b7%d8%b1%d8%a7%d8%ad%db%8c-%d8%aa%da%a9%d8%b1%d8%a7%d8%b1%da%a9%d9%86%d9%86%d8%af%d9%87-iterator">#&lt;/a>
&lt;/h2>
&lt;p>الگوی طراحی تکرارکننده (Iterator) یک الگوی رفتاری است که به شما امکان می دهد عناصر یک مجموعه را بدون نمایش ساختار درونی آن (فهرست، پشته، درخت و غیره) پیمایش کنید.&lt;/p>
&lt;p>&lt;strong>اجزای اصلی:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>رابط تکرارکننده (Iterator Interface):&lt;/strong> این اینترفیس عملیات اصلی برای پیمایش در یک مجموعه را تعریف می کند، به طور معمول شامل متد (Method) هایی مانند &lt;code>hasNext()&lt;/code> برای بررسی وجود عناصر بیشتر و &lt;code>getNext()&lt;/code> برای بازیابی عنصر بعدی.&lt;/li>
&lt;li>&lt;strong>رابط مجموعه (Collection Interface):&lt;/strong> این اینترفیس خود مجموعه را نشان می دهد. ممکن است متدی مانند &lt;code>createIterator()&lt;/code> را اعلام کند که یک شیء تکرارکننده خاص برای نوع مجموعه را برمی‌گرداند.&lt;/li>
&lt;li>&lt;strong>تکرارکننده خاص (Concrete Iterator):&lt;/strong> این کلاسی است که رابط &lt;code>Iterator&lt;/code> را برای یک نوع مجموعه خاص پیاده سازی می کند. این حالت تکرار (مانند موقعیت فعلی) را حفظ می کند و متد هایی مانند &lt;code>hasNext()&lt;/code> و &lt;code>getNext()&lt;/code> را ارائه می دهد که خاص ساختار مجموعه است.&lt;/li>
&lt;li>&lt;strong>مجموعه خاص (Concrete Collection):&lt;/strong> این کلاسی است که اینترفیس یا رابط &lt;code>Collection&lt;/code> را برای یک ساختار داده خاص (مانند لیست، درخت) پیاده سازی می کند. این متد &lt;code>createIterator()&lt;/code> را ارائه می دهد که یک شیء تکرارکننده خاص را برای پیمایش عناصر آن برمی گرداند.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>مزایا:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>جداسازی:&lt;/strong> منطق تکرار را از خود مجموعه جدا می کند و اتصالات ضعیف را ارتقا می دهد و کد را انعطاف پذیرتر و قابل استفاده مجدد می کند.&lt;/li>
&lt;li>&lt;strong>چندین پیمایش:&lt;/strong> امکان پیمایش همزمان در یک مجموعه با استفاده از تکرارکننده های مختلف، به طور بالقوه با الگوریتم های پیمایش مختلف را فراهم می کند.&lt;/li>
&lt;li>&lt;strong>اصل بسته-باز:&lt;/strong> پیاده سازی های جدید تکرارکننده را می توان برای نیازهای مختلف پیمایش بدون تغییر در کلاس های مجموعه اضافه کرد.&lt;/li>
&lt;/ul>
&lt;p>با استفاده از تکرارکننده‌‌ها، می توانید کدی بنویسید که با مجموعه های مختلف بدون وابستگی به ساختارهای خاص آنها کار می کند. این امر به ترویج کدی تمیزتر و قابل نگهداری تر کمک می کند.&lt;/p>
&lt;h2 id="9336-mapping">
9.3.3.6-&lt;strong>Mapping&lt;/strong>
&lt;a class="anchor" href="#9336-mapping">#&lt;/a>
&lt;/h2>
&lt;p>جدول زیر نگاشت بین بازیگران نمودار UML و بازیگران پیاده‌سازی واقعی را در &amp;ldquo;مثال&amp;rdquo; زیر نشان می‌دهد:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Collection&lt;/td>
&lt;td>collection.go&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Concrete Collection&lt;/td>
&lt;td>userCollection.go&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Iterator&lt;/td>
&lt;td>mac.go&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Concrete Iterator 1&lt;/td>
&lt;td>userIterator.go&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Client&lt;/td>
&lt;td>main.go&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="9337-پیاده-سازی">
9.3.3.7-پیاده سازی
&lt;a class="anchor" href="#9337-%d9%be%db%8c%d8%a7%d8%af%d9%87-%d8%b3%d8%a7%d8%b2%db%8c">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>collection.go&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">package main
type collection interface {
createIterator() iterator
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>userCollection.go&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">package main
type userCollection struct {
users []*user
}
func (u *userCollection) createIterator() iterator {
return &amp;amp;userIterator{
users: u.users,
}
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>iterator.go&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">package main
type iterator interface {
hasNext() bool
getNext() *user
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>userIterator.go&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">package main
type userIterator struct {
index int
users []*user
}
func (u *userIterator) hasNext() bool {
if u.index &amp;lt; len(u.users) {
return true
}
return false
}
func (u *userIterator) getNext() *user {
if u.hasNext() {
user := u.users[u.index]
u.index++
return user
}
return nil
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>user.go&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">package main
type user struct {
name string
age int
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>main.go&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import &amp;quot;fmt&amp;quot;
func main() {
user1 := &amp;amp;user{
name: &amp;quot;a&amp;quot;,
age: 30,
}
user2 := &amp;amp;user{
name: &amp;quot;b&amp;quot;,
age: 20,
}
userCollection := &amp;amp;userCollection{
users: []*user{user1, user2},
}
iterator := userCollection.createIterator()
for iterator.hasNext() {
user := iterator.getNext()
fmt.Printf(&amp;quot;User is %+v\n&amp;quot;, user)
}
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>Output:&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">User is &amp;amp;{name:a age:30}
User is &amp;amp;{name:b age:20}
&lt;/code>&lt;/pre>
&lt;h1 id="full-working-code">
&lt;strong>Full Working Code:&lt;/strong>
&lt;a class="anchor" href="#full-working-code">#&lt;/a>
&lt;/h1>
&lt;pre>&lt;code class="language-go">package main
import &amp;quot;fmt&amp;quot;
type collection interface {
createIterator() iterator
}
type userCollection struct {
users []*user
}
func (u *userCollection) createIterator() iterator {
return &amp;amp;userIterator{
users: u.users,
}
}
type iterator interface {
hasNext() bool
getNext() *user
}
type userIterator struct {
index int
users []*user
}
func (u *userIterator) hasNext() bool {
if u.index &amp;lt; len(u.users) {
return true
}
return false
}
func (u *userIterator) getNext() *user {
if u.hasNext() {
user := u.users[u.index]
u.index++
return user
}
return nil
}
type user struct {
name string
age int
}
func main() {
user1 := &amp;amp;user{
name: &amp;quot;a&amp;quot;,
age: 30,
}
user2 := &amp;amp;user{
name: &amp;quot;b&amp;quot;,
age: 20,
}
userCollection := &amp;amp;userCollection{
users: []*user{user1, user2},
}
iterator := userCollection.createIterator()
for iterator.hasNext() {
user := iterator.getNext()
fmt.Printf(&amp;quot;User is %+v\n&amp;quot;, user)
}
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>Output:&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">User is &amp;amp;{name:a age:30}
User is &amp;amp;{name:b age:20}
&lt;/code>&lt;/pre></description></item><item><author/><title>9.3.4 الگو Mediator</title><link>https://book.gofarsi.ir/chapter-9/behavioral-patterns/go-mediator-pattern/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/behavioral-patterns/go-mediator-pattern/</guid><description>&lt;h2 id="9341-الگوی-طراحی-mediator">
9.3.4.1-&lt;strong>الگوی طراحی Mediator&lt;/strong>
&lt;a class="anchor" href="#9341-%d8%a7%d9%84%da%af%d9%88%db%8c-%d8%b7%d8%b1%d8%a7%d8%ad%db%8c-mediator">#&lt;/a>
&lt;/h2>
&lt;p>الگوی طراحی واسطه (&lt;strong>Mediator&lt;/strong>)، یک الگوی رفتاری است که به شما امکان می‌دهد تا وابستگی‌های درهم‌تنیده بین اشیاء را کاهش دهید. این الگو ارتباط مستقیم بین اشیاء را محدود می‌کند و آن‌ها را مجبور می‌سازد تا تنها از طریق یک شیء واسطه با هم همکاری کنند.&lt;/p>
&lt;h3 id="9342-مشکل">
9.3.4.2-&lt;strong>مشکل&lt;/strong>
&lt;a class="anchor" href="#9342-%d9%85%d8%b4%da%a9%d9%84">#&lt;/a>
&lt;/h3>
&lt;p>فرض کنید یک جعبه dialog برای ایجاد و ویرایش پروفایل کاربران دارید. این جعبه dialog شامل کنترل‌های مختلف فرم مانند فیلدهای متنی، کادرهای انتخابی(checkbox)، دکمه‌ها و غیره می‌شود.&lt;/p>
&lt;p>&lt;img src="../../../assets/img/content/chapter9/designPatterns/mediator-problem1-en.png" alt="mediator-problem1" />&lt;/p>
&lt;p>ممکن است برخی از عناصر فرم با سایرین تعامل داشته باشند. برای مثال، انتخاب checkbox &amp;ldquo;من یک سگ دارم&amp;rdquo; ممکن است یک فیلد متنی پنهان برای وارد کردن نام سگ را نمایش دهد. مثال دیگر دکمه “ثبت” است که باید قبل از ذخیره اطلاعات، صحت مقادیر همه فیلدها را تایید کند.&lt;/p>
&lt;p>&lt;img src="../../../assets/img/content/chapter9/designPatterns/mediator-problem2.png" alt="mediator-problem2" />&lt;/p>
&lt;p>با پیاده‌سازی مستقیم این منطق درون کد عناصر فرم، باعث می‌شوید استفاده‌ی مجدد از کلاس‌های این عناصر در فرم‌های دیگر برنامه بسیار دشوار شود. برای نمونه، به دلیل وابستگی به فیلد متن سگ، نمی‌توانید از کلاس کادر انتخاب مذکور در فرم دیگری استفاده کنید. در این حالت، مجبور هستید یا از تمام کلاس‌های درگیر در نمایش فرم پروفایل استفاده کنید، یا هیچ‌کدام را به کار نبرید.&lt;/p>
&lt;h3 id="9343--راهحل">
9.3.4.3- &lt;strong>راه‌حل&lt;/strong>
&lt;a class="anchor" href="#9343--%d8%b1%d8%a7%d9%87%d8%ad%d9%84">#&lt;/a>
&lt;/h3>
&lt;p>الگوی طراحی Mediator پیشنهاد می‌کند که تمام ارتباط‌های مستقیم بین اجزایی که می‌خواهید مستقل از یکدیگر باشند را متوقف کنید. در عوض، این اجزا باید به صورت غیرمستقیم با هم همکاری کنند، یعنی با فراخوانی یک شیء واسطه‌ی خاص که تماس‌ها را به اجزای مناسب هدایت می‌کند. در نتیجه، اجزا تنها به یک کلاس واسطه وابسته می‌شوند، نه اینکه به ده‌ها جزء همکار دیگرشان وابسته باشند.&lt;/p>
&lt;p>در مثال فرم ویرایش پروفایل، خود کلاس باکس گفتگو می‌تواند نقش واسطه را ایفا کند. به احتمال زیاد، کلاس جعبه dialog از قبل از تمام زیرمجموعه‌هایش آگاه است، بنابراین حتی نیازی به معرفی وابستگی‌های جدید به این کلاس نخواهید داشت.&lt;/p>
&lt;p>&lt;img src="../../../assets/img/content/chapter9/designPatterns/mediator-solution1-en.png" alt="mediator-solution1-en" />&lt;/p>
&lt;p>مهم‌ترین تغییر در عناصر واقعی فرم اتفاق می‌افتد. بیایید دکمه‌ی “ثبت” را در نظر بگیریم. پیش از این، هر بار که کاربر روی دکمه کلیک می‌کرد، این دکمه مجبور بود صحت مقادیر تمام عناصر فرم مجزا را تایید کند. حالا تنها وظیفه‌ی دکمه، اطلاع‌رسانی به جعبه dialog در مورد کلیک است. جعبه dialog پس از دریافت این اطلاع‌رسانی، تایید صحت را خودش انجام می‌دهد یا این وظیفه را به عناصر مجزا واگذار می‌کند. بنابراین، به جای وابستگی به ده‌ها عنصر فرم، دکمه تنها به کلاس باکس گفتگو وابسته است.&lt;/p>
&lt;p>می‌توانید فراتر بروید و وابستگی را حتی سست‌تر کنید، با این کار که یک واسط مشترک برای تمام انواع جعبه‌های dialog تعریف کنید. این واسط، متد اطلاع‌رسانی را معرفی می‌کند که همه عناصر فرم می‌توانند از آن برای اطلاع‌رسانی به باکس گفتگو در مورد رویدادهای رخ‌داده در آن عناصر استفاده کنند. بنابراین، دکمه‌ی «ثبت» ما حالا باید بتواند با هر جعبه dialog که آن واسط را پیاده‌سازی می‌کند، کار کند.&lt;/p>
&lt;p>به این ترتیب، الگوی طراحی واسطه به شما امکان می‌دهد تا یک شبکه‌ی پیچیده‌ی روابط بین اشیاء مختلف را درون یک شیء واسطه‌ی واحد کپسوله‌سازی کنید. هرچه وابستگی‌های یک کلاس کمتر باشد، اصلاح، توسعه یا استفاده‌ی مجدد از آن کلاس آسان‌تر می‌شود.&lt;/p>
&lt;h3 id="9344--تشبیه-در-دنیای-واقعی">
9.3.4.4- &lt;strong>تشبیه در دنیای واقعی&lt;/strong>
&lt;a class="anchor" href="#9344--%d8%aa%d8%b4%d8%a8%db%8c%d9%87-%d8%af%d8%b1-%d8%af%d9%86%db%8c%d8%a7%db%8c-%d9%88%d8%a7%d9%82%d8%b9%db%8c">#&lt;/a>
&lt;/h3>
&lt;p>&lt;img src="../../../assets/img/content/chapter9/designPatterns/mediator-live-example.png" alt="mediator-live-example" />&lt;/p>
&lt;p>خلبانان هواپیماهایی که به منطقه‌ی کنترل فرودگاه نزدیک می‌شوند یا از آن خارج می‌شوند، به طور مستقیم با یکدیگر ارتباط برقرار نمی‌کنند. در عوض، آن‌ها با یک کنترل‌کننده‌ی ترافیک هوایی صحبت می‌کنند که در یک برج بلند، جایی در نزدیکی باند فرودگاه قرار دارد. بدون وجود کنترل‌کننده ترافیک هوایی، خلبانان باید از هر هواپیمایی در حوالی فرودگاه آگاه باشند و با یک کمیته‌ی متشکل از ده‌ها خلبان دیگر در مورد اولویت‌های فرود بحث کنند. این امر احتمالا آمار سقوط هواپیما را به طرز چشمگیری افزایش می‌داد.&lt;/p>
&lt;p>برج نیازی به کنترل کل پرواز ندارد. برج فقط برای اعمال محدودیت‌ها در منطقه‌ی فرودگاه وجود دارد.&lt;/p>
&lt;h3 id="9345--مثال">
9.3.4.5- مثال
&lt;a class="anchor" href="#9345--%d9%85%d8%ab%d8%a7%d9%84">#&lt;/a>
&lt;/h3>
&lt;p>همانطور که می‌دانیم؛ الگوی طراحی Mediator یک الگوی طراحی رفتاری است. این الگو پیشنهاد می کند برای جلوگیری از ارتباط مستقیم بین اشیاء، یک شیء میانجی ایجاد شود تا وابستگی های مستقیم بین آنها از بین برود.&lt;/p>
&lt;p>یک مثال بسیار خوب از الگوی Mediator، سکوی سیستم راه آهن است. دو قطار هرگز برای در دسترس بودن سکو با یکدیگر ارتباط برقرار نمی‌کنند. مسئول ایستگاه (stationManager) به عنوان میانجی (Mediator) عمل می کند و سکو را فقط برای یکی از قطارها در دسترس قرار می‌دهد. قطار با مسئول ایستگاه (&lt;strong>stationManager&lt;/strong>) ارتباط برقرار می‌کند و بر اساس دستورات آن عمل می‌کند. این الگو صفی از قطارهای در انتظار را مدیریت می کند. در صورت خروج هر قطاری از سکو، به یکی از قطارها اطلاع می دهد که در ادامه به سکو برسد.&lt;/p>
&lt;p>توجه کنید که چگونه stationManager در کد زیر به عنوان میانجی بین trains و platform عمل می کند.&lt;/p>
&lt;ul>
&lt;li>&lt;code>passengerTrain&lt;/code> و &lt;code>goodsTrain&lt;/code> رابط train را پیاده سازی می‌کنند.&lt;/li>
&lt;li>&lt;code>stationManager&lt;/code> رابط mediator را پیاده سازی می‌کند.&lt;/li>
&lt;/ul>
&lt;h3 id="9346--مثال-کاربردی">
9.3.4.6- مثال کاربردی
&lt;a class="anchor" href="#9346--%d9%85%d8%ab%d8%a7%d9%84-%da%a9%d8%a7%d8%b1%d8%a8%d8%b1%d8%af%db%8c">#&lt;/a>
&lt;/h3>
&lt;p>&lt;strong>train.go&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">package main
type train interface {
requestArrival()
departure()
permitArrival()
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>passengerTrain.go&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import &amp;quot;fmt&amp;quot;
type passengerTrain struct {
mediator mediator
}
func (g *passengerTrain) requestArrival() {
if g.mediator.canLand(g) {
fmt.Println(&amp;quot;PassengerTrain: Landing&amp;quot;)
} else {
fmt.Println(&amp;quot;PassengerTrain: Waiting&amp;quot;)
}
}
func (g *passengerTrain) departure() {
fmt.Println(&amp;quot;PassengerTrain: Leaving&amp;quot;)
g.mediator.notifyFree()
}
func (g *passengerTrain) permitArrival() {
fmt.Println(&amp;quot;PassengerTrain: Arrival Permitted. Landing&amp;quot;)
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>goodsTrain.go&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import &amp;quot;fmt&amp;quot;
type goodsTrain struct {
mediator mediator
}
func (g *goodsTrain) requestArrival() {
if g.mediator.canLand(g) {
fmt.Println(&amp;quot;GoodsTrain: Landing&amp;quot;)
} else {
fmt.Println(&amp;quot;GoodsTrain: Waiting&amp;quot;)
}
}
func (g *goodsTrain) departure() {
g.mediator.notifyFree()
fmt.Println(&amp;quot;GoodsTrain: Leaving&amp;quot;)
}
func (g *goodsTrain) permitArrival() {
fmt.Println(&amp;quot;GoodsTrain: Arrival Permitted. Landing&amp;quot;)
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>mediator.go&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">package main
type mediator interface {
canLand(train) bool
notifyFree()
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>stationManager.go&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import &amp;quot;sync&amp;quot;
type stationManager struct {
isPlatformFree bool
lock *sync.Mutex
trainQueue []train
}
func newStationManger() *stationManager {
return &amp;amp;stationManager{
isPlatformFree: true,
lock: &amp;amp;sync.Mutex{},
}
}
func (s *stationManager) canLand(t train) bool {
s.lock.Lock()
defer s.lock.Unlock()
if s.isPlatformFree {
s.isPlatformFree = false
return true
}
s.trainQueue = append(s.trainQueue, t)
return false
}
func (s *stationManager) notifyFree() {
s.lock.Lock()
defer s.lock.Unlock()
if !s.isPlatformFree {
s.isPlatformFree = true
}
if len(s.trainQueue) &amp;gt; 0 {
firstTrainInQueue := s.trainQueue[0]
s.trainQueue = s.trainQueue[1:]
firstTrainInQueue.permitArrival()
}
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>main.go&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">package main
func main() {
stationManager := newStationManger()
passengerTrain := &amp;amp;passengerTrain{
mediator: stationManager,
}
goodsTrain := &amp;amp;goodsTrain{
mediator: stationManager,
}
passengerTrain.requestArrival()
goodsTrain.requestArrival()
passengerTrain.departure()
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>Output:&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">PassengerTrain: Landing
GoodsTrain: Waiting
PassengerTrain: Leaving
GoodsTrain: Arrival Permitted. Landing
&lt;/code>&lt;/pre>
&lt;h2 id="full-working-code">
&lt;strong>Full Working Code:&lt;/strong>
&lt;a class="anchor" href="#full-working-code">#&lt;/a>
&lt;/h2>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;fmt&amp;quot;
&amp;quot;sync&amp;quot;
)
type train interface {
requestArrival()
departure()
permitArrival()
}
type passengerTrain struct {
mediator mediator
}
func (g *passengerTrain) requestArrival() {
if g.mediator.canLand(g) {
fmt.Println(&amp;quot;PassengerTrain: Landing&amp;quot;)
} else {
fmt.Println(&amp;quot;PassengerTrain: Waiting&amp;quot;)
}
}
func (g *passengerTrain) departure() {
fmt.Println(&amp;quot;PassengerTrain: Leaving&amp;quot;)
g.mediator.notifyFree()
}
func (g *passengerTrain) permitArrival() {
fmt.Println(&amp;quot;PassengerTrain: Arrival Permitted. Landing&amp;quot;)
}
type goodsTrain struct {
mediator mediator
}
func (g *goodsTrain) requestArrival() {
if g.mediator.canLand(g) {
fmt.Println(&amp;quot;GoodsTrain: Landing&amp;quot;)
} else {
fmt.Println(&amp;quot;GoodsTrain: Waiting&amp;quot;)
}
}
func (g *goodsTrain) departure() {
g.mediator.notifyFree()
fmt.Println(&amp;quot;GoodsTrain: Leaving&amp;quot;)
}
func (g *goodsTrain) permitArrival() {
fmt.Println(&amp;quot;GoodsTrain: Arrival Permitted. Landing&amp;quot;)
}
type mediator interface {
canLand(train) bool
notifyFree()
}
type stationManager struct {
isPlatformFree bool
lock *sync.Mutex
trainQueue []train
}
func newStationManger() *stationManager {
return &amp;amp;stationManager{
isPlatformFree: true,
lock: &amp;amp;sync.Mutex{},
}
}
func (s *stationManager) canLand(t train) bool {
s.lock.Lock()
defer s.lock.Unlock()
if s.isPlatformFree {
s.isPlatformFree = false
return true
}
s.trainQueue = append(s.trainQueue, t)
return false
}
func (s *stationManager) notifyFree() {
s.lock.Lock()
defer s.lock.Unlock()
if !s.isPlatformFree {
s.isPlatformFree = true
}
if len(s.trainQueue) &amp;gt; 0 {
firstTrainInQueue := s.trainQueue[0]
s.trainQueue = s.trainQueue[1:]
firstTrainInQueue.permitArrival()
}
}
func main() {
stationManager := newStationManger()
passengerTrain := &amp;amp;passengerTrain{
mediator: stationManager,
}
goodsTrain := &amp;amp;goodsTrain{
mediator: stationManager,
}
passengerTrain.requestArrival()
goodsTrain.requestArrival()
passengerTrain.departure()
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>Output:&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">PassengerTrain: Landing
GoodsTrain: Waiting
PassengerTrain: Leaving
GoodsTrain: Arrival Permitted. Landing
&lt;/code>&lt;/pre></description></item><item><author/><title>9.3.5 الگو Memento</title><link>https://book.gofarsi.ir/chapter-9/behavioral-patterns/go-memento-pattern/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/behavioral-patterns/go-memento-pattern/</guid><description>&lt;p>الگو Memento&amp;hellip;&lt;/p></description></item><item><author/><title>9.3.6 الگو Observer</title><link>https://book.gofarsi.ir/chapter-9/behavioral-patterns/go-observer-pattern/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/behavioral-patterns/go-observer-pattern/</guid><description>&lt;p>الگو Observer&amp;hellip;&lt;/p></description></item><item><author/><title>9.3.7 الگو State</title><link>https://book.gofarsi.ir/chapter-9/behavioral-patterns/go-state-pattern/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/behavioral-patterns/go-state-pattern/</guid><description>&lt;p>الگو State&amp;hellip;&lt;/p>
&lt;h2 id="9371-مقدمه">
9.3.7.1 مقدمه:
&lt;a class="anchor" href="#9371-%d9%85%d9%82%d8%af%d9%85%d9%87">#&lt;/a>
&lt;/h2>
&lt;p>دیزاین پترن State یک دیزاین پترن behavioral است که مبتنی بر Finite State Machine است. ما دیزاین پترن State را در زمینه نمونه ای از &lt;a href="https://en.wikipedia.org/wiki/Vending_machine">Vending Machine&lt;/a> توضیح خواهیم داد. برای سادگی، بیایید فرض کنیم که Vending Machine فقط یک نوع کالا یا محصول دارد. همچنین برای سادگی، فرض می کنیم که یک Vending Machine می تواند در 4 حالت(state) مختلف باشد:&lt;/p>
&lt;ol>
&lt;li>&lt;strong>hasItem&lt;/strong>&lt;/li>
&lt;li>&lt;strong>noItem&lt;/strong>&lt;/li>
&lt;li>&lt;strong>itemRequested&lt;/strong>&lt;/li>
&lt;li>&lt;strong>hasMoney&lt;/strong>&lt;/li>
&lt;/ol>
&lt;p>یک Vending Machine خودکار نیز عملکردهای متفاوتی خواهد داشت. دوباره برای سادگی فرض می کنیم که فقط چهار عمل وجود دارد:&lt;/p>
&lt;ol>
&lt;li>&lt;strong>Select the item&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Add the item&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Insert Money&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Dispense Item&lt;/strong>&lt;/li>
&lt;/ol>
&lt;h2 id="9372-چه-زمانی-از-این-الگو-استفاده-کنیم">
9.3.7.2 چه زمانی از این الگو استفاده کنیم:
&lt;a class="anchor" href="#9372-%da%86%d9%87-%d8%b2%d9%85%d8%a7%d9%86%db%8c-%d8%a7%d8%b2-%d8%a7%db%8c%d9%86-%d8%a7%d9%84%da%af%d9%88-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%da%a9%d9%86%db%8c%d9%85">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>از الگوی طراحی State زمانی استفاده کنید که &lt;strong>object&lt;/strong> می تواند در بسیاری از حالت های (&lt;strong>states&lt;/strong>) مختلف باشد. بسته به درخواست فعلی، &lt;strong>object&lt;/strong> باید وضعیت فعلی خود را تغییر دهد.
&lt;ul>
&lt;li>در مثال بالا، Vending Machine می تواند در بسیاری از حالت های مختلف باشد. یک Vending Machine از یک state به حالت دیگر تغییر می کند. فرض کنید Vending Machine در مورد &lt;strong>itemRequested&lt;/strong> است، پس از انجام عمل «&lt;strong>hasMoney&lt;/strong>» به حالت «&lt;strong>Insert Money&lt;/strong>» منتقل می‌شود.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>از این پترن زمانی استفاده کنید که یک شی بسته به وضعیت فعلی پاسخ‌های متفاوتی به درخواست یکسان داشته باشد. استفاده از الگوی طراحی states در اینجا از بسیاری از عبارات شرطی جلوگیری می کند
&lt;ul>
&lt;li>به عنوان مثال در مورد Vending Machine، اگر کاربری بخواهد کالایی را خریداری کند، اگر آن مورد hasItemState باشد دستگاه ادامه خواهد داد یا اگر در noItemState باشد آن را رد می کند. اگر در اینجا متوجه شدید که Vending Machine خودکار به درخواست خرید یک کالا، بسته به اینکه آیا در hasItemState باشد، دو پاسخ متفاوت می دهد. به فایل vendingMachine.go زیر توجه کنید، هیچ نوع دستور شرطی ندارد. تمام منطق توسط پیاده سازی های concrete state اداره می شود.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="9373--uml-diagram">
9.3.7.3 ## &lt;strong>UML Diagram&lt;/strong>:
&lt;a class="anchor" href="#9373--uml-diagram">#&lt;/a>
&lt;/h2>
&lt;p>&lt;img src="../../../static/assets/img/content/chapter9/designPatterns/states1.png" alt="UMLDiagram" />&lt;/p>
&lt;h2 id="9374---mapping">
9.3.7.4 ## &lt;strong>Mapping&lt;/strong>:
&lt;a class="anchor" href="#9374---mapping">#&lt;/a>
&lt;/h2>
&lt;p>جدول زیر mapping از نمودار UML به نمونه اجرایی پیاده سازی واقعی در کد را نشان می دهد.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Context&lt;/td>
&lt;td>vendingMachine.go&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>State Interface&lt;/td>
&lt;td>state.go&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Concrete State 1&lt;/td>
&lt;td>noItemState.go&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Concrete State 2&lt;/td>
&lt;td>hasItemState.go&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Concrete State 3&lt;/td>
&lt;td>itemRequestedState.go&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Concrete State 4&lt;/td>
&lt;td>hasMoneyState.go&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="9375---توضیحات">
9.3.7.5 ## &lt;strong>توضیحات&lt;/strong>:
&lt;a class="anchor" href="#9375---%d8%aa%d9%88%d8%b6%db%8c%d8%ad%d8%a7%d8%aa">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>ما یک رابط(interface) از نوع &amp;lsquo;State&amp;rsquo; داریم که signature توابع را تعریف می کند که نشان دهنده عملکرد در زمینه Vending Machine است. در زیر signatureهای توابع عملیاتی وجود دارد&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>addItem(int) error&lt;/li>
&lt;li>requestItem() error&lt;/li>
&lt;li>insertMoney(money int) error&lt;/li>
&lt;li>dispenseItem() error&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>
&lt;p>هر یک از پیاده‌سازی‌های concrete state، هر 4 تابع بالا را پیاده‌سازی می‌کنند و روی اقدامات مربوط به هر کدام یا به حالت دیگری می‌روند یا پاسخی تولید می‌کنند.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>هر یک از concrete stateها نیز یک اشاره گر را به object مربوط به Vending Machine فعلی تعبیه(embed) می کند تا انتقال حالت (state transition) در آن object اتفاق بیفتد.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="9376---مثال-کاربردی">
9.3.7.6 ## &lt;strong>مثال کاربردی&lt;/strong>:
&lt;a class="anchor" href="#9376---%d9%85%d8%ab%d8%a7%d9%84-%da%a9%d8%a7%d8%b1%d8%a8%d8%b1%d8%af%db%8c">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>vendingMachine.go&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import &amp;quot;fmt&amp;quot;
type vendingMachine struct {
hasItem state
itemRequested state
hasMoney state
noItem state
currentState state
itemCount int
itemPrice int
}
func newVendingMachine(itemCount, itemPrice int) *vendingMachine {
v := &amp;amp;vendingMachine{
itemCount: itemCount,
itemPrice: itemPrice,
}
hasItemState := &amp;amp;hasItemState{
vendingMachine: v,
}
itemRequestedState := &amp;amp;itemRequestedState{
vendingMachine: v,
}
hasMoneyState := &amp;amp;hasMoneyState{
vendingMachine: v,
}
noItemState := &amp;amp;noItemState{
vendingMachine: v,
}
v.setState(hasItemState)
v.hasItem = hasItemState
v.itemRequested = itemRequestedState
v.hasMoney = hasMoneyState
v.noItem = noItemState
return v
}
func (v *vendingMachine) requestItem() error {
return v.currentState.requestItem()
}
func (v *vendingMachine) addItem(count int) error {
return v.currentState.addItem(count)
}
func (v *vendingMachine) insertMoney(money int) error {
return v.currentState.insertMoney(money)
}
func (v *vendingMachine) dispenseItem() error {
return v.currentState.dispenseItem()
}
func (v *vendingMachine) setState(s state) {
v.currentState = s
}
func (v *vendingMachine) incrementItemCount(count int) {
fmt.Printf(&amp;quot;Adding %d items\n&amp;quot;, count)
v.itemCount = v.itemCount + count
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>state.go&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">package main
type state interface {
addItem(int) error
requestItem() error
insertMoney(money int) error
dispenseItem() error
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>noItemState.go&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import &amp;quot;fmt&amp;quot;
type noItemState struct {
vendingMachine *vendingMachine
}
func (i *noItemState) requestItem() error {
return fmt.Errorf(&amp;quot;Item out of stock&amp;quot;)
}
func (i *noItemState) addItem(count int) error {
i.vendingMachine.incrementItemCount(count)
i.vendingMachine.setState(i.vendingMachine.hasItem)
return nil
}
func (i *noItemState) insertMoney(money int) error {
return fmt.Errorf(&amp;quot;Item out of stock&amp;quot;)
}
func (i *noItemState) dispenseItem() error {
return fmt.Errorf(&amp;quot;Item out of stock&amp;quot;)
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>hasItemState.go&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import &amp;quot;fmt&amp;quot;
type hasItemState struct {
vendingMachine *vendingMachine
}
func (i *hasItemState) requestItem() error {
if i.vendingMachine.itemCount == 0 {
i.vendingMachine.setState(i.vendingMachine.noItem)
return fmt.Errorf(&amp;quot;No item present&amp;quot;)
}
fmt.Printf(&amp;quot;Item requestd\n&amp;quot;)
i.vendingMachine.setState(i.vendingMachine.itemRequested)
return nil
}
func (i *hasItemState) addItem(count int) error {
fmt.Printf(&amp;quot;%d items added\n&amp;quot;, count)
i.vendingMachine.incrementItemCount(count)
return nil
}
func (i *hasItemState) insertMoney(money int) error {
return fmt.Errorf(&amp;quot;Please select item first&amp;quot;)
}
func (i *hasItemState) dispenseItem() error {
return fmt.Errorf(&amp;quot;Please select item first&amp;quot;)
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>itemRequestedState.go&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import &amp;quot;fmt&amp;quot;
type itemRequestedState struct {
vendingMachine *vendingMachine
}
func (i *itemRequestedState) requestItem() error {
return fmt.Errorf(&amp;quot;Item already requested&amp;quot;)
}
func (i *itemRequestedState) addItem(count int) error {
return fmt.Errorf(&amp;quot;Item Dispense in progress&amp;quot;)
}
func (i *itemRequestedState) insertMoney(money int) error {
if money &amp;lt; i.vendingMachine.itemPrice {
fmt.Errorf(&amp;quot;Inserted money is less. Please insert %d&amp;quot;, i.vendingMachine.itemPrice)
}
fmt.Println(&amp;quot;Money entered is ok&amp;quot;)
i.vendingMachine.setState(i.vendingMachine.hasMoney)
return nil
}
func (i *itemRequestedState) dispenseItem() error {
return fmt.Errorf(&amp;quot;Please insert money first&amp;quot;)
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>hasMoneyState.go&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import &amp;quot;fmt&amp;quot;
type hasMoneyState struct {
vendingMachine *vendingMachine
}
func (i *hasMoneyState) requestItem() error {
return fmt.Errorf(&amp;quot;Item dispense in progress&amp;quot;)
}
func (i *hasMoneyState) addItem(count int) error {
return fmt.Errorf(&amp;quot;Item dispense in progress&amp;quot;)
}
func (i *hasMoneyState) insertMoney(money int) error {
return fmt.Errorf(&amp;quot;Item out of stock&amp;quot;)
}
func (i *hasMoneyState) dispenseItem() error {
fmt.Println(&amp;quot;Dispensing Item&amp;quot;)
i.vendingMachine.itemCount = i.vendingMachine.itemCount - 1
if i.vendingMachine.itemCount == 0 {
i.vendingMachine.setState(i.vendingMachine.noItem)
} else {
i.vendingMachine.setState(i.vendingMachine.hasItem)
}
return nil
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>main.go&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;fmt&amp;quot;
&amp;quot;log&amp;quot;
)
func main() {
vendingMachine := newVendingMachine(1, 10)
err := vendingMachine.requestItem()
if err != nil {
log.Fatalf(err.Error())
}
err = vendingMachine.insertMoney(10)
if err != nil {
log.Fatalf(err.Error())
}
err = vendingMachine.dispenseItem()
if err != nil {
log.Fatalf(err.Error())
}
fmt.Println()
err = vendingMachine.addItem(2)
if err != nil {
log.Fatalf(err.Error())
}
fmt.Println()
err = vendingMachine.requestItem()
if err != nil {
log.Fatalf(err.Error())
}
err = vendingMachine.insertMoney(10)
if err != nil {
log.Fatalf(err.Error())
}
err = vendingMachine.dispenseItem()
if err != nil {
log.Fatalf(err.Error())
}
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>Output:&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">Item requestd
Money entered is ok
Dispensing Item
Adding 2 items
Item requestd
Money entered is ok
Dispensing Item
&lt;/code>&lt;/pre></description></item><item><author/><title>9.3.8 الگو Strategy</title><link>https://book.gofarsi.ir/chapter-9/behavioral-patterns/go-strategy-pattern/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/behavioral-patterns/go-strategy-pattern/</guid><description>&lt;p>الگو Strategy&amp;hellip;&lt;/p></description></item><item><author/><title>9.3.9 الگو Template Method</title><link>https://book.gofarsi.ir/chapter-9/behavioral-patterns/go-template-method-pattern/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/behavioral-patterns/go-template-method-pattern/</guid><description>&lt;p>الگو Template Method&amp;hellip;&lt;/p>
&lt;h2 id="9391-مقدمه">
9.3.9.1 مقدمه:
&lt;a class="anchor" href="#9391-%d9%85%d9%82%d8%af%d9%85%d9%87">#&lt;/a>
&lt;/h2>
&lt;p>الگوی Template Method یک الگوی طراحی behavioral است که به شما امکان می دهد یک الگو یا الگوریتم برای یک عملیات خاص تعریف کنید. بیایید الگوی Template Method را با یک مثال درک کنیم.&lt;/p>
&lt;p>مثال یک مرز یک بار مصرف (One Time Password) یا OTP را در نظر بگیرید. انواع مختلفی از OTP وجود دارد که می تواند برای مثال اجرا شود. OTP می تواند SMS OTP یا EMAIL OTP باشد. اما صرف نظر از اینکه یک پیامک OTP یا EMAIL OTP باشد، کل مراحل فرآیند OTP یکسان است. مراحل مورد نظر به ترتیب زیر هستند.&lt;/p>
&lt;ul>
&lt;li>یک عدد n رقمی تصادفی ایجاد کنید.&lt;/li>
&lt;li>این شماره را برای تأیید بعدی در cache ذخیره کنید.&lt;/li>
&lt;li>محتوا را آماده کنید&lt;/li>
&lt;li>notification را ارسال کنید&lt;/li>
&lt;li>metricsها را Publish کنید&lt;/li>
&lt;/ul>
&lt;p>حتی در آینده فرض کنید یک push notification &lt;strong>OTP&lt;/strong> معرفی شده است، اما همچنان مراحل بالا را طی خواهد کرد.&lt;/p>
&lt;p>در چنین سناریوهایی زمانی که مراحل یک عملیات خاص یکسان است اما مراحل عملیات می تواند به روشی متفاوت توسط مجریان مختلف اجرا شود. پس از آن بهترین گزینه برای انتخاب دیزاین پترن مناسب گزینه Template Method می شود. ما یک template یا الگوریتم را تعریف می کنیم که از methodهای fixed number تشکیل شده است. نوشتن برنامه برای حالت جدید باید operation override متدهای template را پیاده سازی کند.&lt;/p>
&lt;p>حالا نمونه کد زیر را بررسی کنید.&lt;/p>
&lt;p>iOtp نشان دهنده یک interface است که مجموعه متد هایی را که هر نوع otp باید پیاده سازی کند را تعریف می کند.&lt;/p>
&lt;p>اس ام اس و ایمیل پیاده سازی رابط iOtp هستند&lt;/p>
&lt;p>otp ساختاری است که متد template () genAndSendOTP را تعریف می کند. otp رابط iOtp را تعبیه می کند.&lt;/p>
&lt;p>مهم: ترکیب رابط iOtp و ساختار otp قابلیت های Abstract Class را در زبان برنامه نویسی go فراهم می کند. برای اطلعات بیشتر در این مورد &lt;strong>&lt;a href="https://golangbyexample.com/go-abstract-class/">مرجع&lt;/a>&lt;/strong> مراجعه کنید.&lt;/p>
&lt;h2 id="9392-مثال">
9.3.9.2 مثال:
&lt;a class="anchor" href="#9392-%d9%85%d8%ab%d8%a7%d9%84">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>otp.go&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">package main
type iOtp interface {
genRandomOTP(int) string
saveOTPCache(string)
getMessage(string) string
sendNotification(string) error
publishMetric()
}
type otp struct {
iOtp iOtp
}
func (o *otp) genAndSendOTP(otpLength int) error {
otp := o.iOtp.genRandomOTP(otpLength)
o.iOtp.saveOTPCache(otp)
message := o.iOtp.getMessage(otp)
err := o.iOtp.sendNotification(message)
if err != nil {
return err
}
o.iOtp.publishMetric()
return nil
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>sms.go&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import &amp;quot;fmt&amp;quot;
type sms struct {
otp
}
func (s *sms) genRandomOTP(len int) string {
randomOTP := &amp;quot;1234&amp;quot;
fmt.Printf(&amp;quot;SMS: generating random otp %s\n&amp;quot;, randomOTP)
return randomOTP
}
func (s *sms) saveOTPCache(otp string) {
fmt.Printf(&amp;quot;SMS: saving otp: %s to cache\n&amp;quot;, otp)
}
func (s *sms) getMessage(otp string) string {
return &amp;quot;SMS OTP for login is &amp;quot; + otp
}
func (s *sms) sendNotification(message string) error {
fmt.Printf(&amp;quot;SMS: sending sms: %s\n&amp;quot;, message)
return nil
}
func (s *sms) publishMetric() {
fmt.Printf(&amp;quot;SMS: publishing metrics\n&amp;quot;)
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>email.go&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import &amp;quot;fmt&amp;quot;
type email struct {
otp
}
func (s *email) genRandomOTP(len int) string {
randomOTP := &amp;quot;1234&amp;quot;
fmt.Printf(&amp;quot;EMAIL: generating random otp %s\n&amp;quot;, randomOTP)
return randomOTP
}
func (s *email) saveOTPCache(otp string) {
fmt.Printf(&amp;quot;EMAIL: saving otp: %s to cache\n&amp;quot;, otp)
}
func (s *email) getMessage(otp string) string {
return &amp;quot;EMAIL OTP for login is &amp;quot; + otp
}
func (s *email) sendNotification(message string) error {
fmt.Printf(&amp;quot;EMAIL: sending email: %s\n&amp;quot;, message)
return nil
}
func (s *email) publishMetric() {
fmt.Printf(&amp;quot;EMAIL: publishing metrics\n&amp;quot;)
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>main.go&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import &amp;quot;fmt&amp;quot;
func main() {
smsOTP := &amp;amp;sms{}
o := otp{
iOtp: smsOTP,
}
o.genAndSendOTP(4)
fmt.Println(&amp;quot;&amp;quot;)
emailOTP := &amp;amp;email{}
o = otp{
iOtp: emailOTP,
}
o.genAndSendOTP(4)
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>Output:&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">SMS: generating random otp 1234
SMS: saving otp: 1234 to cache
SMS: sending sms: SMS OTP for login is 1234
SMS: publishing metrics
EMAIL: generating random otp 1234
EMAIL: saving otp: 1234 to cache
EMAIL: sending email: EMAIL OTP for login is 1234
EMAIL: publishing metrics
&lt;/code>&lt;/pre>
&lt;h2 id="9393-مثال-پیاده-سازی-شده-به-صورت-یکجا">
9.3.9.3 مثال پیاده سازی شده به صورت یکجا:
&lt;a class="anchor" href="#9393-%d9%85%d8%ab%d8%a7%d9%84-%d9%be%db%8c%d8%a7%d8%af%d9%87-%d8%b3%d8%a7%d8%b2%db%8c-%d8%b4%d8%af%d9%87-%d8%a8%d9%87-%d8%b5%d9%88%d8%b1%d8%aa-%db%8c%da%a9%d8%ac%d8%a7">#&lt;/a>
&lt;/h2>
&lt;pre>&lt;code class="language-go">package main
import &amp;quot;fmt&amp;quot;
type iOtp interface {
genRandomOTP(int) string
saveOTPCache(string)
getMessage(string) string
sendNotification(string) error
publishMetric()
}
type otp struct {
iOtp iOtp
}
func (o *otp) genAndSendOTP(otpLength int) error {
otp := o.iOtp.genRandomOTP(otpLength)
o.iOtp.saveOTPCache(otp)
message := o.iOtp.getMessage(otp)
err := o.iOtp.sendNotification(message)
if err != nil {
return err
}
o.iOtp.publishMetric()
return nil
}
type sms struct {
otp
}
func (s *sms) genRandomOTP(len int) string {
randomOTP := &amp;quot;1234&amp;quot;
fmt.Printf(&amp;quot;SMS: generating random otp %s\n&amp;quot;, randomOTP)
return randomOTP
}
func (s *sms) saveOTPCache(otp string) {
fmt.Printf(&amp;quot;SMS: saving otp: %s to cache\n&amp;quot;, otp)
}
func (s *sms) getMessage(otp string) string {
return &amp;quot;SMS OTP for login is &amp;quot; + otp
}
func (s *sms) sendNotification(message string) error {
fmt.Printf(&amp;quot;SMS: sending sms: %s\n&amp;quot;, message)
return nil
}
func (s *sms) publishMetric() {
fmt.Printf(&amp;quot;SMS: publishing metrics\n&amp;quot;)
}
type email struct {
otp
}
func (s *email) genRandomOTP(len int) string {
randomOTP := &amp;quot;1234&amp;quot;
fmt.Printf(&amp;quot;EMAIL: generating random otp %s\n&amp;quot;, randomOTP)
return randomOTP
}
func (s *email) saveOTPCache(otp string) {
fmt.Printf(&amp;quot;EMAIL: saving otp: %s to cache\n&amp;quot;, otp)
}
func (s *email) getMessage(otp string) string {
return &amp;quot;EMAIL OTP for login is &amp;quot; + otp
}
func (s *email) sendNotification(message string) error {
fmt.Printf(&amp;quot;EMAIL: sending email: %s\n&amp;quot;, message)
return nil
}
func (s *email) publishMetric() {
fmt.Printf(&amp;quot;EMAIL: publishing metrics\n&amp;quot;)
}
func main() {
smsOTP := &amp;amp;sms{}
o := otp{
iOtp: smsOTP,
}
o.genAndSendOTP(4)
fmt.Println(&amp;quot;&amp;quot;)
emailOTP := &amp;amp;email{}
o = otp{
iOtp: emailOTP,
}
o.genAndSendOTP(4)
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>Output:&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-none">SMS: generating random otp 1234
SMS: saving otp: 1234 to cache
SMS: sending sms: SMS OTP for login is 1234
SMS: publishing metrics
EMAIL: generating random otp 1234
EMAIL: saving otp: 1234 to cache
EMAIL: sending email: EMAIL OTP for login is 1234
EMAIL: publishing metrics
&lt;/code>&lt;/pre></description></item><item><author/><title>9.3.10 الگو Visitor</title><link>https://book.gofarsi.ir/chapter-9/behavioral-patterns/go-visitor-pattern/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/behavioral-patterns/go-visitor-pattern/</guid><description>&lt;p>الگو Visitor&amp;hellip;&lt;/p>
&lt;h2 id="93101-مقدمه">
9.3.10.1 مقدمه:
&lt;a class="anchor" href="#93101-%d9%85%d9%82%d8%af%d9%85%d9%87">#&lt;/a>
&lt;/h2>
&lt;p>الگوی طراحی Visitor یک الگوی طراحی Behavioural است که به شما امکان می‌دهد بدون تغییر در ساختار برنامه، رفتاری را به ساختار آن اضافه کنید.&lt;br>
بیایید الگوی Visitor را با یک مثال درک کنیم. فرض کنید شما نگهدارنده(maintainer) یک lib هستید که ساختارهای با شکل‌های متفاوتی دارد مانند:&lt;/p>
&lt;ol>
&lt;li>Square&lt;/li>
&lt;li>Circle&lt;/li>
&lt;li>Triangle&lt;/li>
&lt;/ol>
&lt;p>هر یک از ساختارهای شکل بالا یک شکل رابط مشترک را پیاده سازی می کند. تیم های زیادی در شرکت شما وجود دارند که از lib شما استفاده می کنند. حال فرض کنید یکی از تیم از شما می خواهد که یک رفتار دیگر (getArea()) به ساختارهای Shape اضافه کنید. در نتیجه گزینه های زیادی برای حل این مشکل وجود دارد.&lt;/p>
&lt;h4 id="راه-حل-اول">
راه حل اول:
&lt;a class="anchor" href="#%d8%b1%d8%a7%d9%87-%d8%ad%d9%84-%d8%a7%d9%88%d9%84">#&lt;/a>
&lt;/h4>
&lt;p>اولین گزینه ای که به ذهن می رسد اضافه کردن متد getArea() در interface مربوط به &lt;strong>shape&lt;/strong> است و سپس هر ساختار &lt;strong>shape&lt;/strong> می تواند متد getArea() را پیاده سازی کند. این به نظر بی اهمیت می رسد اما برخی از مشکلات وجود دارد:&lt;/p>
&lt;ul>
&lt;li>به عنوان maintainer کتابخانه، نمی خواهید کد بسیار آزمایش شده کتابخانه خود را با افزودن رفتارهای اضافی تغییر دهید.&lt;/li>
&lt;li>ممکن است تیم هایی که از کتابخانه شما استفاده می کنند درخواست بیشتری برای رفتارهای بیشتری مانند getNumSides()، getMiddleCoordinates(). سپس، در این مورد، شما نمی خواهید به اصلاح کتابخانه خود ادامه دهید. اما شما می خواهید که تیم های دیگر کتابخانه شما را بدون تغییر واقعی کد گسترش دهند.&lt;/li>
&lt;/ul>
&lt;h4 id="راه-حل-دوم">
راه حل دوم:
&lt;a class="anchor" href="#%d8%b1%d8%a7%d9%87-%d8%ad%d9%84-%d8%af%d9%88%d9%85">#&lt;/a>
&lt;/h4>
&lt;p>گزینه دوم این است که تیمی که این ویژگی را درخواست می کند می تواند منطق رفتار را خودش بنویسد. بنابراین بر اساس نوع shape struct آنها کد زیر را در نظر دارند:&lt;/p>
&lt;pre>&lt;code class="language-go">if shape.type == square {
//Calculate area for squre
} elseif shape.type == circle {
//Calculate area of triangle
} elseif shape.type == &amp;quot;triangle&amp;quot; {
//Calculate area of triangle
} else {
//Raise error
}
&lt;/code>&lt;/pre>
&lt;p>کد بالا نیز مشکل ساز است زیرا نمی توانید از مزایای کامل interface ها استفاده کنید و به جای آن یک بررسی explicit type که شکننده(fragile) است انجام دهید. دوم، دریافت type در زمان اجرا ممکن است تأثیری بر عملکرد داشته باشد یا حتی در برخی از زبان ها امکان پذیر نباشد.&lt;/p>
&lt;h4 id="راه-حل-سوم">
راه حل سوم:
&lt;a class="anchor" href="#%d8%b1%d8%a7%d9%87-%d8%ad%d9%84-%d8%b3%d9%88%d9%85">#&lt;/a>
&lt;/h4>
&lt;p>گزینه سوم حل مشکل فوق با استفاده از الگوی visitor است. ما یکvisitor interface را مانند زیر تعریف می کنیم.&lt;/p>
&lt;pre>&lt;code class="language-go">type visitor interface {
visitForSquare(square)
visitForCircle(circle)
visitForTriangle(triangle)
}
&lt;/code>&lt;/pre>
&lt;p>توابع visitforSquare(&lt;strong>square&lt;/strong>)، visitForCircle(&lt;strong>circle&lt;/strong>)، visitForTriangle(&lt;strong>triangle&lt;/strong>) به ما اجازه می دهد تا به ترتیب قابلیت های Square، Circle و Triangle را اضافه کنیم.&lt;/p>
&lt;p>حال سوالی که به ذهن می رسد این است که چرا نمی توانیم یک روش visit**(shape)** واحد در visitor interface داشته باشیم. دلیل اینکه ما این ویژگی را نداریم این است که GO و همچنین برخی از زبان های دیگر از method overloading پشتیبانی می کنند. بنابراین یک method متفاوت برای هر یک از ساختارها مورد نیاز است.&lt;/p>
&lt;p>ما یک &lt;strong>accept&lt;/strong> method را با signature زیر به shape interface اضافه می کنیم و هر یک از shape struct باید این متد را تعریف کنند.&lt;/p>
&lt;pre>&lt;code class="language-go">func accept(v visitor)
&lt;/code>&lt;/pre>
&lt;p>اما یک لحظه صبر کنید، ما فقط اشاره کردیم که نمی خواهیم shape structs موجود خود را تغییر دهیم. اما هنگام استفاده از Visitor Pattern باید shape structs خود را تغییر دهیم اما این اصلاح فقط یک بار انجام می شود. در صورت اضافه کردن هر رفتار اضافی مانند getNumSides()، getMiddleCoordinates() از همان تابع accept(v visitor) فوق بدون تغییر بیشتر در shape structs استفاده می کند. اساساً shape structs فقط باید یک بار اصلاح شوند و تمام درخواست‌های آتی رفتارهای اضافی با استفاده از همان تابع پذیرش بررسی می‌شوند. ببینیم چطور!
ساختار مربع (square struct) یک accept method مانند زیر را اجرا می کند:&lt;/p>
&lt;pre>&lt;code class="language-go">func (obj *squre) accept(v visitor){
v.visitForSquare(obj)
}
&lt;/code>&lt;/pre>
&lt;p>و به طور مشابه، دایره و مثلث نیز accept function را مانند بالا تعریف می کنند.&lt;/p>
&lt;p>اکنون تیمی که رفتار getArea() را درخواست می‌کند، می‌تواند به سادگی concrete implementation را برای visitor interface را تعریف کند و منطق محاسبه ناحیه را در آن concrete implementation بنویسد.&lt;/p>
&lt;p>&lt;strong>areaCalculator.go&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">type areaCalculator struct{
area int
}
func (a *areaCalculator) visitForSquare(s *square){
//Calculate are for square
}
func (a *areaCalculator) visitForCircle(s *square){
//Calculate are for circle
}
func (a *areaCalculator) visitForTriangle(s *square){
//Calculate are for triangle
&lt;/code>&lt;/pre>
&lt;p>برای محاسبه مساحت یک مربع، ابتدا نمونه ای از مربعی که آنها به سادگی می توانند فراخوانی کنند ایجاد می کنیم.&lt;/p>
&lt;pre>&lt;code class="language-go">sq := &amp;amp;square{}
ac := &amp;amp;areaCalculator{}
sq.accept(ac)
&lt;/code>&lt;/pre>
&lt;p>به طور مشابه، تیم دیگری که برای رفتار getMiddleCoordinates() درخواست می‌کند، می‌تواند پیاده‌سازی concrete دیگری از  visitor interfaceمشابه با بالا تعریف کند.&lt;/p>
&lt;p>&lt;strong>middleCoordinates.go&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">type middleCoordinates struct {
x int
y int
}
func (a *middleCoordinates) visitForSquare(s *square) {
//Calculate middle point coordinates for square. After calculating the area assign in to the x and y instance variable.
}
func (a *middleCoordinates) visitForCircle(c *circle) {
//Calculate middle point coordinates for square. After calculating the area assign in to the x and y instance variable.
}
func (a *middleCoordinates) visitForTriangle(t *triangle) {
//Calculate middle point coordinates for square. After calculating the area assign in to the x and y instance variable.
}
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="../../../static/assets/img/content/chapter9/designPatterns/uml_visitor1.jpg" alt="UMLDiagram" />&lt;/p>
&lt;p>در زیر نمودار mapping UML متناظر با مثال عملی shape struct و areaCalculator که در بالا ارائه کردیم آمده است.&lt;/p>
&lt;p>&lt;img src="../../../static/assets/img/content/chapter9/designPatterns/visitor2.jpg" alt="UMLDiagram" />&lt;/p>
&lt;h2 id="93102--mapping">
9.3.10.2 # &lt;strong>Mapping&lt;/strong>:
&lt;a class="anchor" href="#93102--mapping">#&lt;/a>
&lt;/h2>
&lt;p>جدول زیر mapping از اجزای مهم نمودار UML به اجزای واقعی implementation را در &amp;lsquo;مثال&amp;rsquo; زیر نشان می دهد.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>element&lt;/td>
&lt;td>shape.go&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Concrete Element A&lt;/td>
&lt;td>square.go&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Concrete Element B&lt;/td>
&lt;td>circle.go&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Concrete Element C&lt;/td>
&lt;td>rectangle.go&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Visitor&lt;/td>
&lt;td>visitor.go&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Concrete Visitor 1&lt;/td>
&lt;td>areaCalculator.go&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Concrete Visitor 2&lt;/td>
&lt;td>middleCoordinates.go&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Client&lt;/td>
&lt;td>main.go&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="93103--مثال">
9.3.10.3 # &lt;strong>مثال&lt;/strong>:
&lt;a class="anchor" href="#93103--%d9%85%d8%ab%d8%a7%d9%84">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>shape.go&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">package main
type shape interface {
getType() string
accept(visitor)
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>square.go&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">package main
type square struct {
side int
}
func (s *square) accept(v visitor) {
v.visitForSquare(s)
}
func (s *square) getType() string {
return &amp;quot;Square&amp;quot;
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>circle.go&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">package main
type circle struct {
radius int
}
func (c *circle) accept(v visitor) {
v.visitForCircle(c)
}
func (c *circle) getType() string {
return &amp;quot;Circle&amp;quot;
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>rectangle.go&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">package main
type rectangle struct {
l int
b int
}
func (t *rectangle) accept(v visitor) {
v.visitForrectangle(t)
}
func (t *rectangle) getType() string {
return &amp;quot;rectangle&amp;quot;
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>visitor.go&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">package main
type visitor interface {
visitForSquare(*square)
visitForCircle(*circle)
visitForrectangle(*rectangle)
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>areaCalculator.go&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;fmt&amp;quot;
)
type areaCalculator struct {
area int
}
func (a *areaCalculator) visitForSquare(s *square) {
//Calculate area for square. After calculating the area assign in to the area instance variable
fmt.Println(&amp;quot;Calculating area for square&amp;quot;)
}
func (a *areaCalculator) visitForCircle(s *circle) {
//Calculate are for circle. After calculating the area assign in to the area instance variable
fmt.Println(&amp;quot;Calculating area for circle&amp;quot;)
}
func (a *areaCalculator) visitForrectangle(s *rectangle) {
//Calculate are for rectangle. After calculating the area assign in to the area instance variable
fmt.Println(&amp;quot;Calculating area for rectangle&amp;quot;)
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>middleCoordinates.go&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import &amp;quot;fmt&amp;quot;
type middleCoordinates struct {
x int
y int
}
func (a *middleCoordinates) visitForSquare(s *square) {
//Calculate middle point coordinates for square. After calculating the area assign in to the x and y instance variable.
fmt.Println(&amp;quot;Calculating middle point coordinates for square&amp;quot;)
}
func (a *middleCoordinates) visitForCircle(c *circle) {
//Calculate middle point coordinates for square. After calculating the area assign in to the x and y instance variable.
fmt.Println(&amp;quot;Calculating middle point coordinates for circle&amp;quot;)
}
func (a *middleCoordinates) visitForrectangle(t *rectangle) {
//Calculate middle point coordinates for square. After calculating the area assign in to the x and y instance variable.
fmt.Println(&amp;quot;Calculating middle point coordinates for rectangle&amp;quot;)
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>main.go&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import &amp;quot;fmt&amp;quot;
func main() {
square := &amp;amp;square{side: 2}
circle := &amp;amp;circle{radius: 3}
rectangle := &amp;amp;rectangle{l: 2, b: 3}
areaCalculator := &amp;amp;areaCalculator{}
square.accept(areaCalculator)
circle.accept(areaCalculator)
rectangle.accept(areaCalculator)
fmt.Println()
middleCoordinates := &amp;amp;middleCoordinates{}
square.accept(middleCoordinates)
circle.accept(middleCoordinates)
rectangle.accept(middleCoordinates)
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>Output:&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">Calculating area for square
Calculating area for circle
Calculating area for rectangle
Calculating middle point coordinates for square
Calculating middle point coordinates for circle
Calculating middle point coordinates for rectangle
&lt;/code>&lt;/pre>
&lt;h2 id="93103--پیاده-سازی-به-صورت-یک-جا">
9.3.10.3 # &lt;strong>پیاده سازی به صورت یک جا&lt;/strong>:
&lt;a class="anchor" href="#93103--%d9%be%db%8c%d8%a7%d8%af%d9%87-%d8%b3%d8%a7%d8%b2%db%8c-%d8%a8%d9%87-%d8%b5%d9%88%d8%b1%d8%aa-%db%8c%da%a9-%d8%ac%d8%a7">#&lt;/a>
&lt;/h2>
&lt;pre>&lt;code class="language-go">package main
import &amp;quot;fmt&amp;quot;
type shape interface {
getType() string
accept(visitor)
}
type square struct {
side int
}
func (s *square) accept(v visitor) {
v.visitForSquare(s)
}
func (s *square) getType() string {
return &amp;quot;Square&amp;quot;
}
type circle struct {
radius int
}
func (c *circle) accept(v visitor) {
v.visitForCircle(c)
}
func (c *circle) getType() string {
return &amp;quot;Circle&amp;quot;
}
type rectangle struct {
l int
b int
}
func (t *rectangle) accept(v visitor) {
v.visitForrectangle(t)
}
func (t *rectangle) getType() string {
return &amp;quot;rectangle&amp;quot;
}
type visitor interface {
visitForSquare(*square)
visitForCircle(*circle)
visitForrectangle(*rectangle)
}
type areaCalculator struct {
area int
}
func (a *areaCalculator) visitForSquare(s *square) {
//Calculate area for square. After calculating the area assign in to the area instance variable
fmt.Println(&amp;quot;Calculating area for square&amp;quot;)
}
func (a *areaCalculator) visitForCircle(s *circle) {
//Calculate are for circle. After calculating the area assign in to the area instance variable
fmt.Println(&amp;quot;Calculating area for circle&amp;quot;)
}
func (a *areaCalculator) visitForrectangle(s *rectangle) {
//Calculate are for rectangle. After calculating the area assign in to the area instance variable
fmt.Println(&amp;quot;Calculating area for rectangle&amp;quot;)
}
type middleCoordinates struct {
x int
y int
}
func (a *middleCoordinates) visitForSquare(s *square) {
//Calculate middle point coordinates for square. After calculating the area assign in to the x and y instance variable.
fmt.Println(&amp;quot;Calculating middle point coordinates for square&amp;quot;)
}
func (a *middleCoordinates) visitForCircle(c *circle) {
//Calculate middle point coordinates for square. After calculating the area assign in to the x and y instance variable.
fmt.Println(&amp;quot;Calculating middle point coordinates for circle&amp;quot;)
}
func (a *middleCoordinates) visitForrectangle(t *rectangle) {
//Calculate middle point coordinates for square. After calculating the area assign in to the x and y instance variable.
fmt.Println(&amp;quot;Calculating middle point coordinates for rectangle&amp;quot;)
}
func main() {
square := &amp;amp;square{side: 2}
circle := &amp;amp;circle{radius: 3}
rectangle := &amp;amp;rectangle{l: 2, b: 3}
areaCalculator := &amp;amp;areaCalculator{}
square.accept(areaCalculator)
circle.accept(areaCalculator)
rectangle.accept(areaCalculator)
fmt.Println()
middleCoordinates := &amp;amp;middleCoordinates{}
square.accept(middleCoordinates)
circle.accept(middleCoordinates)
rectangle.accept(middleCoordinates)
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>Output:&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">Calculating area for square
Calculating area for circle
Calculating area for rectangle
Calculating middle point coordinates for square
Calculating middle point coordinates for circle
Calculating middle point coordinates for rectangle
&lt;/code>&lt;/pre></description></item></channel></rss>