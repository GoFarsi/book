<!doctype html><html lang=fa dir=rtl><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  9.7.1 مقدمه
  #

این مقاله ترجمه ارایه اصول solid در golang توسط  Dave Cheneyمی‌‌باشد.
در این مبحث به بررسی پیاده سازی solid در زبان Go  می‌پردازیم.
بررسی کد

چه کسی اینجا بررسی کد را به عنوان بخشی از کار خود انجام می‌دهد؟ تمام اتاق دستشان را بالا بردند که تشویق کننده بود. خوب، چرا بررسی کد انجام می‌دهید؟ کسی فریاد زد «برای جلوگیری از کد بد»
اگر code review برای شناسایی کد‌های نامناسب است، پس چگونه می‌دانید کدی که بررسی می‌کنید خوب است یا بد؟
حالا خوب است بگوییم «آن کد نامناسب است» یا «آن کد منبع زیبا است»، درست مانند اینکه بگویید «این نقاشی زیبا است» یا «این اتاق زیبا است» اما اینها اصطلاحات ذهنی هستند و من به دنبال راه‌های عینی برای صحبت در مورد خواص کد خوب یا بد هستم.


  کد بد
  #


برخی از ویژگی‌های کد بد که ممکن است در بررسی کد به آن پی ببرید کدامند؟
سفت و خشک یا در اصطلاح Rigid. آیا کد Rigid است؟ آیا دارای یک  محافظ محدود کننده از انواع و پارامترهای غالب است که اصلاح آن را دشوار می‌کند؟
شکننده یا در اصطلاح Fragile. آیا کد Fragile است؟ آیا کوچکترین تغییر در کد باعث ایجاد ویرانی‌های فراوان می‌شود؟
بی‌حرکتی یا Immobile . آیا تغییر در ساختار کد سخت است؟ آیا اضافه کردن یک حلقه ساده در برنامه کار پیچیده‌ای است؟
پیچیده (Complex). آیا کدها به دلیل اینکه فقط کدی نوشته شده باشد بدون آن که به آن نیاز باشد، وجود دارد، آیا چیزها بیش از حد مهندسی (over-engineered) شده‌اند؟
شرح دادن بیش از حد یا Verbose. آیا استفاده و بررسی از کد خسته‌کننده است؟ وقتی به آن نگاه می‌کنید، می‌توانید بگویید این کد چه کاری می‌خواهد انجام دهد؟
آیا این کلمات مثبت هستند؟ آیا از شنیدن این کلمات در بررسی کد خود خوشحال خواهید شد؟
احتمالا نه.


  طراحی خوب
  #

اما این یک بهبود دادن در سطح کد است، حالا می‌توانیم چیزهایی مثل «من این را دوست ندارم چون خیلی سخت است تغییرش داد» یا «من این را دوست ندارم چون نمی‌توانم بفهمم کد چه کاری می‌خواهد انجام دهد» بگوییم، اما چه می‌شود اگر با مثبت شروع کنیم؟"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://book.gofarsi.ir/chapter-9/solid-principle-in-golang/"><meta property="og:site_name" content="زبان گو فارسی"><meta property="og:title" content="9.7 اصول SOLID"><meta property="og:description" content="9.7.1 مقدمه # این مقاله ترجمه ارایه اصول solid در golang توسط Dave Cheneyمی‌‌باشد.
در این مبحث به بررسی پیاده سازی solid در زبان Go می‌پردازیم.
بررسی کد
چه کسی اینجا بررسی کد را به عنوان بخشی از کار خود انجام می‌دهد؟ تمام اتاق دستشان را بالا بردند که تشویق کننده بود. خوب، چرا بررسی کد انجام می‌دهید؟ کسی فریاد زد «برای جلوگیری از کد بد» اگر code review برای شناسایی کد‌های نامناسب است، پس چگونه می‌دانید کدی که بررسی می‌کنید خوب است یا بد؟ حالا خوب است بگوییم «آن کد نامناسب است» یا «آن کد منبع زیبا است»، درست مانند اینکه بگویید «این نقاشی زیبا است» یا «این اتاق زیبا است» اما اینها اصطلاحات ذهنی هستند و من به دنبال راه‌های عینی برای صحبت در مورد خواص کد خوب یا بد هستم. کد بد # برخی از ویژگی‌های کد بد که ممکن است در بررسی کد به آن پی ببرید کدامند؟ سفت و خشک یا در اصطلاح Rigid. آیا کد Rigid است؟ آیا دارای یک محافظ محدود کننده از انواع و پارامترهای غالب است که اصلاح آن را دشوار می‌کند؟ شکننده یا در اصطلاح Fragile. آیا کد Fragile است؟ آیا کوچکترین تغییر در کد باعث ایجاد ویرانی‌های فراوان می‌شود؟ بی‌حرکتی یا Immobile . آیا تغییر در ساختار کد سخت است؟ آیا اضافه کردن یک حلقه ساده در برنامه کار پیچیده‌ای است؟ پیچیده (Complex). آیا کدها به دلیل اینکه فقط کدی نوشته شده باشد بدون آن که به آن نیاز باشد، وجود دارد، آیا چیزها بیش از حد مهندسی (over-engineered) شده‌اند؟ شرح دادن بیش از حد یا Verbose. آیا استفاده و بررسی از کد خسته‌کننده است؟ وقتی به آن نگاه می‌کنید، می‌توانید بگویید این کد چه کاری می‌خواهد انجام دهد؟ آیا این کلمات مثبت هستند؟ آیا از شنیدن این کلمات در بررسی کد خود خوشحال خواهید شد؟ احتمالا نه. طراحی خوب # اما این یک بهبود دادن در سطح کد است، حالا می‌توانیم چیزهایی مثل «من این را دوست ندارم چون خیلی سخت است تغییرش داد» یا «من این را دوست ندارم چون نمی‌توانم بفهمم کد چه کاری می‌خواهد انجام دهد» بگوییم، اما چه می‌شود اگر با مثبت شروع کنیم؟"><meta property="og:locale" content="fa"><meta property="og:type" content="article"><meta property="article:section" content="chapter-9"><title>9.7 اصول SOLID | زبان گو فارسی</title><link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://book.gofarsi.ir/chapter-9/solid-principle-in-golang/><link rel=stylesheet href=/book.min.c2f5390a8db8d6e8a1f34ca78b37beea11b3040c8e6f418e46422051f3aa7136.css integrity="sha256-wvU5Co241uih80ynize+6hGzBAyOb0GORkIgUfOqcTY=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/fa.search.min.f40c72fbc2318356d68cfba924815a040c55acc8e53cf7d969728b00f48bbae7.js integrity="sha256-9Axy+8Ixg1bWjPupJIFaBAxVrMjlPPfZaXKLAPSLuuc=" crossorigin=anonymous></script><link rel=stylesheet href=prism.css><meta name=keywords content><link href=https://cdn.jsdelivr.net/gh/rastikerdar/vazir-font@v30.1.0/dist/font-face.css rel=stylesheet type=text/css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.0/css/all.min.css crossorigin=anonymous><link rel=alternate type=application/rss+xml href=https://book.gofarsi.ir//feed.xml title="زبان گو فارسی"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/prism-themes@1.9.0/themes/prism-one-dark.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/line-numbers/prism-line-numbers.min.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZE44Q8PZDW"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZE44Q8PZDW")</script><script>var html=document.documentElement;localStorage.getItem("themeMode")=="dark"&&html.setAttribute("data-theme","dark"),localStorage.getItem("themeMode")=="light"&&html.setAttribute("data-theme","light")</script></head><body dir=rtl><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><img src=/favicon.png alt=Logo class=book-icon><span>زبان گو فارسی</span></a></h2><div class=magic><div class=book-search><input type=text id=book-search-input placeholder=جستجو aria-label=جستجو maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><div class=js-toggle-wrapper><div class=js-toggle><div class=js-toggle-track><div class=js-toggle-track-check><img src="data:image/png;base64,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" role=presentation style=pointer-events:none width=23 height=23></div><div class=js-toggle-track-x><img src=data:image/png;base64,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 role=presentation style=pointer-events:none width=23 height=23></div></div><div class=js-toggle-thumb><img src=data:image/png;base64,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 role=presentation style=pointer-events:none width=46 height=46></div><input class=js-toggle-screenreader-only type=checkbox aria-label="تغییر تم بین روشن و تاریک"></div></div></div><ul><li><a href=/preface/>پیشگفتار</a></li><li><a href=/history/>تاریخچه</a></li><li><a href=/why-go/>چرا زبان Go؟</a></li><li><a href=/installation/>آموزش نصب</a></li><li><a href=/toolchain/>ابزارها, دستورات گو و معرفی IDE</a></li><li><a href=/roadmap/>نقشه یادگیری زبان گو</a></li><li><a href=/interview/>نمونه سوالات مصاحبه</a></li><li><input type=checkbox id=section-c0c35ea61c635f6152f0c00d6a15569e class=toggle>
<label for=section-c0c35ea61c635f6152f0c00d6a15569e class=flex><a href=/chapter-1/ class=flex-auto>فصل اول: آشنایی با مفاهیم گو</a></label><ul><li><a href=/chapter-1/structure-of-go-code/>1.1 ساختار کد گو</a></li><li><a href=/chapter-1/go-built-in-keywords-identifiers/>1.2 کلید واژه و شناسه‌ها</a></li><li><a href=/chapter-1/go-basic-types/>1.3 تایپ‌های پایه</a></li><li><a href=/chapter-1/go-operators/>1.4 عملگرها</a></li><li><a href=/chapter-1/go-variables-and-consts/>1.5 متغیرها و constant</a></li><li><a href=/chapter-1/go-zero-values/>1.6 مقادیر صفر تایپ‌ها (zero values)</a></li><li><a href=/chapter-1/go-function/>1.7 تابع (function)</a></li><li><a href=/chapter-1/go-array/>1.8 آرایه و slice</a></li><li><a href=/chapter-1/go-for/>1.9 حلقه‌ها (for)</a></li><li><a href=/chapter-1/go-map/>1.10 نقشه map</a></li><li><a href=/chapter-1/go-if-switch/>1.11 شرط (if, switch)</a></li><li><a href=/chapter-1/go-package/>1.12 اضافه کردن پکیج در کد (package)</a></li><li><a href=/chapter-1/go-defer-panic-recovery/>1.13 defer, panic, recovery</a></li><li><a href=/chapter-1/go-builtins/>1.14 لیست تایپ‌ها و توابع Builtin</a></li><li><a href=/chapter-1/go-string-formatting/>1.15 قالب بندی رشته‌ها</a></li></ul></li><li><input type=checkbox id=section-ce9b5b1ec927bacdb2712b9c215a3ca1 class=toggle>
<label for=section-ce9b5b1ec927bacdb2712b9c215a3ca1 class=flex><a href=/chapter-2/ class=flex-auto>فصل دوم: مکانیزم‌های زبان</a></label><ul><li><a href=/chapter-2/pointer/>2.1 اشاره‌گر (Pointer)</a></li><li><a href=/chapter-2/struct/>2.2 ساختار (struct)</a></li><li><a href=/chapter-2/method/>2.3 متد (Method)</a></li><li><a href=/chapter-2/interface/>2.4 اینترفیس (Interface)</a></li><li><a href=/chapter-2/type-embedding/>2.5 جاسازی تایپ (type embedding)</a></li><li><a href=/chapter-2/error-handling/>2.6 مدیریت خطاها</a></li><li><a href=/chapter-2/casting-vs-conversion/>2.7 فرق casting با conversion</a></li></ul></li><li><input type=checkbox id=section-0691270142e95f82c4d2eb637f234afd class=toggle>
<label for=section-0691270142e95f82c4d2eb637f234afd class=flex><a href=/chapter-3/ class=flex-auto>فصل سوم: همزمانی (concurrency)</a></label><ul><li><a href=/chapter-3/go-concurrency/>3.1 آشنایی با همزمانی</a></li><li><a href=/chapter-3/goroutine/>3.2 گوروتین (goroutine)</a></li><li><a href=/chapter-3/go-sync-package/>3.3 پکیج sync</a></li><li><a href=/chapter-3/go-atomic/>3.4 پکیج atomic</a></li><li><a href=/chapter-3/goroutine-data-race/>3.5 آموزش مقابله با data race</a></li><li><a href=/chapter-3/go-channel/>3.6 کانال (channel)</a></li><li><a href=/chapter-3/go-select/>3.7 آموزش استفاده از select</a></li><li><a href=/chapter-3/go-context/>3.8 پکیج context</a></li><li><a href=/chapter-3/go-concurrency-teqniques/>3.9 تکنیک های همزمانی</a></li><li><a href=/chapter-3/go-concurrency-patterns/>3.10 الگو های همزمانی</a></li></ul></li><li><input type=checkbox id=section-59efe912b32b5b1290d5ec2dac84f441 class=toggle>
<label for=section-59efe912b32b5b1290d5ec2dac84f441 class=flex><a href=/chapter-4/ class=flex-auto>فصل چهارم: مباحث پیشرفته</a></label><ul><li><a href=/chapter-4/build-go-file/>4.1 آموزش Build پروژه</a></li><li><a href=/chapter-4/debugging-go-code/>4.2 آموزش کار با Debugging</a></li><li><a href=/chapter-4/go-mod/>4.3 آموزش کار با go mod</a></li><li><a href=/chapter-4/workspace/>4.4 آموزش کار با workspace</a></li><li><a href=/chapter-4/vendor/>4.5 آموزش کار با Vendor</a></li><li><a href=/chapter-4/command-line-go/>4.6 آموزش نوشتن برنامه command line</a></li><li><a href=/chapter-4/work-with-file-in-go/>4.7 آموزش کار با فایل</a></li><li><a href=/chapter-4/work-with-json-file-in-go/>4.8 آموزش کار با json</a></li><li><a href=/chapter-4/work-with-toml-file-in-go/>4.9 آموزش کار با toml</a></li><li><a href=/chapter-4/work-with-yaml-file-in-go/>4.10 آموزش کار با yaml</a></li><li><a href=/chapter-4/work-with-csv-file-in-go/>4.11 آموزش کار با csv</a></li><li><a href=/chapter-4/work-with-ini-file-in-go/>4.12 آموزش کار با ini</a></li><li><a href=/chapter-4/work-with-environment-variable/>4.13 آموزش کار با environment variable</a></li><li><a href=/chapter-4/go-regular-expressions/>4.14 آموزش کار با regexp</a></li><li><a href=/chapter-4/go-reflection/>4.15 آموزش reflection</a></li><li><a href=/chapter-4/go-generator/>4.16 آموزش generator</a></li><li><a href=/chapter-4/go-stringer/>4.17 آموزش stringer</a></li><li><a href=/chapter-4/effective-go/>4.18 تکنیک های کدنویسی زبان گو</a></li><li><a href=/chapter-4/go-commentry/>4.19 اصول کامنت نویسی</a></li><li><a href=/chapter-4/go-code-rules/>4.20 قوانین کدنویسی در گو</a></li><li><a href=/chapter-4/go-garbage-collector/>4.21 زباله جمع کن (garbage collector)</a></li><li><a href=/chapter-4/go-plugin/>4.22 کتابخانه Plugin</a></li><li><input type=checkbox id=section-687c92e06ed3c05242e60a3a1a266aa4 class=toggle>
<label for=section-687c92e06ed3c05242e60a3a1a266aa4 class=flex><a href=/chapter-4/oop/ class=flex-auto>4.23 شی گرایی در زبان گو</a></label><ul><li><a href=/chapter-4/oop/go-encapsulation/>4.23.1 کپسوله سازی (Encapsulation)</a></li><li><a href=/chapter-4/oop/go-inheritance/>4.22.2 ارث بری</a></li><li><a href=/chapter-4/oop/go-polymorphism/>4.23.3 پلی مورفیسم (Polymorphism)</a></li><li><a href=/chapter-4/oop/go-overriding/>4.23.4 overriding</a></li><li><a href=/chapter-4/oop/go-abstraction/>4.23.5 abstraction</a></li></ul></li><li><a href=/chapter-4/tracing/>4.24 آموزش tracing</a></li><li><a href=/chapter-4/profiling/>4.25 آموزش profiling</a></li><li><a href=/chapter-4/go-project-layout/>4.26 ساختار پروژه</a></li></ul></li><li><input type=checkbox id=section-134502b5358f6cf5c83ad497f832087a class=toggle>
<label for=section-134502b5358f6cf5c83ad497f832087a class=flex><a href=/chapter-5/ class=flex-auto>فصل پنجم: برنامه نویسی شبکه با گو</a></label><ul><li><a href=/chapter-5/network-basic/>5.1 شبکه چیست</a></li><li><a href=/chapter-5/go-tcp-server-begginer/>5.2 سرور tcp مقدماتی</a></li><li><a href=/chapter-5/go-tcp-server-advanced/>5.3 سرور tcp پیشرفته</a></li><li><a href=/chapter-5/go-udp-server-begginer/>5.4 سرور udp مقدماتی</a></li><li><a href=/chapter-5/go-udp-server-advanced/>5.5 سرور udp پیشرفته</a></li><li><a href=/chapter-5/go-http-server-begginer/>5.6 کتابخانه http سمت سرور مقدماتی</a></li><li><a href=/chapter-5/go-http-server-advanced/>5.7 کتابخانه http سمت سرور پیشرفته</a></li><li><a href=/chapter-5/go-http-client-begginer/>5.8 کتابخانه http سمت کلاینت مقدماتی</a></li><li><a href=/chapter-5/go-http-client-advanced/>5.9 کتابخانه http سمت کلاینت پیشرفته</a></li><li><a href=/chapter-5/go-quic-prtoocol/>5.10 پروتکل quic</a></li></ul></li><li><input type=checkbox id=section-6f78676abc6f42fefd423ea7de4e1c4d class=toggle>
<label for=section-6f78676abc6f42fefd423ea7de4e1c4d class=flex><a href=/chapter-6/ class=flex-auto>فصل ششم: ژنریک ها (Generics)</a></label><ul><li><a href=/chapter-6/go-generics-basic/>6.1 مقدمه و اهمیت ژنریک‌ها</a></li><li><a href=/chapter-6/go-generics-fundamentals/>6.2 مبانی ژنریک‌ها در Go</a></li><li><a href=/chapter-6/go-generics-syntax-and-structure/>6.3 سینتکس و ساختار ژنریک‌ها در Go</a></li><li><a href=/chapter-6/go-generics-type-sets-and-constraints/>6.4 Constraints و Type Sets</a></li><li><a href=/chapter-6/go-generics-examples-and-practical/>6.5 مثال‌ها و کاربردهای عملی ژنریک‌ها</a></li><li><a href=/chapter-6/comparing-generics/>6.6 مقایسه ژنریک‌ها با راهکارهای قبل از Go 1.18</a></li><li><a href=/chapter-6/limitations-errors-and-anti-patterns-in-generics/>6.7 محدودیت‌ها، خطاها و ضدالگوها در ژنریک‌ها</a></li><li><a href=/chapter-6/generics-best-practice/>6.8 بهترین شیوه‌های استفاده از ژنریک‌ها (Best Practices)</a></li><li><a href=/chapter-6/generics-advanced-examples-and-tips/>6.9 مثال‌های پیشرفته و نکات ویژه</a></li></ul></li><li><input type=checkbox id=section-8f5df719cb6867058bc4273b800e1879 class=toggle>
<label for=section-8f5df719cb6867058bc4273b800e1879 class=flex><a href=/chapter-7/ class=flex-auto>فصل هفتم: تست نویسی</a></label><ul><li><a href=/chapter-7/go-introduction-testing/>7.1 مقدمه‌ای بر تست در Go</a></li><li><a href=/chapter-7/go-unit-testing/>7.2 تست واحد (Unit Test)</a></li><li><a href=/chapter-7/go-table-driven-tests/>7.3 تست جدول‌محور (Table-Driven Test)</a></li></ul></li><li><input type=checkbox id=section-46582e13a18a41adc7936c360b185ec8 class=toggle>
<label for=section-46582e13a18a41adc7936c360b185ec8 class=flex><a href=/chapter-8/ class=flex-auto>فصل هشتم: پکیج های استاندارد</a></label><ul></ul></li><li><input type=checkbox id=section-7b4fd75e0c8dddcfaf05d2809955458b class=toggle checked>
<label for=section-7b4fd75e0c8dddcfaf05d2809955458b class=flex><a href=/chapter-9/ class=flex-auto>فصل نهم: الگوهای طراحی</a></label><ul><li><input type=checkbox id=section-91fecfeb90059a6577f742161c3cc416 class=toggle>
<label for=section-91fecfeb90059a6577f742161c3cc416 class=flex><a href=/chapter-9/creational-patterns/ class=flex-auto>9.1 الگوهای طراحی سازنده</a></label><ul><li><a href=/chapter-9/creational-patterns/go-singleton-pattern/>9.1.1 الگو Singleton</a></li><li><a href=/chapter-9/creational-patterns/go-factory-method-pattern/>9.1.2 الگو Factory Method</a></li><li><a href=/chapter-9/creational-patterns/go-prototype-pattern/>9.1.3 الگو Prototype</a></li><li><a href=/chapter-9/creational-patterns/go-abstract-factory-pattern/>9.1.4 الگو Abstract Factory</a></li><li><a href=/chapter-9/creational-patterns/go-builder-pattern/>9.1.6 الگو Builder</a></li><li><a href=/chapter-9/creational-patterns/go-object-pool-pattern/>9.1.7 الگو Object Pool</a></li></ul></li><li><input type=checkbox id=section-0bf1b67244bd7a1b2067d73a9ac05c84 class=toggle>
<label for=section-0bf1b67244bd7a1b2067d73a9ac05c84 class=flex><a href=/chapter-9/structural-patterns/ class=flex-auto>9.2 الگوهای طراحی ساختاری</a></label><ul><li><a href=/chapter-9/structural-patterns/go-adaptor-pattern/>9.2.1 الگو Adaptor</a></li><li><a href=/chapter-9/structural-patterns/go-bridge-pattern/>9.2.2 الگو Bridge</a></li><li><a href=/chapter-9/structural-patterns/go-composite-pattern/>9.2.3 الگو Composite</a></li><li><a href=/chapter-9/structural-patterns/go-decorator-pattern/>9.2.1 الگو Decorator</a></li><li><a href=/chapter-9/structural-patterns/go-facade-pattern/>9.2.5 الگو Facade</a></li><li><a href=/chapter-9/structural-patterns/go-flyweight-pattern/>9.2.6 الگو Flyweight</a></li><li><a href=/chapter-9/structural-patterns/go-proxy-pattern/>9.2.7 الگو Proxy</a></li></ul></li><li><input type=checkbox id=section-67e202f99a50c1e49347339369c874b1 class=toggle>
<label for=section-67e202f99a50c1e49347339369c874b1 class=flex><a href=/chapter-9/behavioral-patterns/ class=flex-auto>9.3 الگوهای طراحی رفتاری</a></label><ul><li><a href=/chapter-9/behavioral-patterns/go-chain-of-responsibility-pattern/>9.3.1 الگو Chain Of Responsibility</a></li><li><a href=/chapter-9/behavioral-patterns/go-command-pattern/>9.3.2 الگو Command</a></li><li><a href=/chapter-9/behavioral-patterns/go-iterator-pattern/>9.3.3 الگو Iterator</a></li><li><a href=/chapter-9/behavioral-patterns/go-mediator-pattern/>9.3.4 الگو Mediator</a></li><li><a href=/chapter-9/behavioral-patterns/go-memento-pattern/>9.3.5 الگو Memento</a></li><li><a href=/chapter-9/behavioral-patterns/go-observer-pattern/>9.3.6 الگو Observer</a></li><li><a href=/chapter-9/behavioral-patterns/go-state-pattern/>9.3.7 الگو State</a></li><li><a href=/chapter-9/behavioral-patterns/go-strategy-pattern/>9.3.8 الگو Strategy</a></li><li><a href=/chapter-9/behavioral-patterns/go-template-method-pattern/>9.3.9 الگو Template Method</a></li><li><a href=/chapter-9/behavioral-patterns/go-visitor-pattern/>9.3.10 الگو Visitor</a></li></ul></li><li><input type=checkbox id=section-a8aa81f62696e9f9c69a81a3318a50eb class=toggle>
<label for=section-a8aa81f62696e9f9c69a81a3318a50eb class=flex><a href=/chapter-9/concurrency-patterns/ class=flex-auto>9.4 الگوهای همزمانی</a></label><ul><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-wait-for-result/>9.4.1 الگو Wait For Result</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-fan-out-in/>9.4.2 الگو Fan Out/In</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-wait-for-task/>9.4.3 الگو Wait For Task</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-worker-pool/>9.4.4 الگوی Worker Pool</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-drop/>9.4.5 الگو Drop</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-cancellation/>9.4.6 الگو Context Cancellation Pattern</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-semaphore/>9.4.7 الگو Semaphore</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-retry-timeout/>9.4.8 الگو Retry Timeout</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-producer-consumer/>9.4.9 الگو Producer-Consumer</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-monitor/>9.4.10 الگو Monitor</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-future/>9.4.11 الگو Future</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-pipeline/>9.4.12 الگو Pipeline</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-subscription/>9.4.13 الگو Subscription</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-brdige-channel/>9.4.14 الگو Bridge Channel</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-queuing/>9.4.15 الگو Queuing</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-ratelimit/>9.4.16 الگو Rate limit</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-deadlock-recovery/>9.4.17 الگو Deadlock Recovery</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-channel-cancellation/>9.4.18 الگو Channel Cancellation</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-lock-free-synchronization/>9.4.19 الگو Lock-free synchronization</a></li></ul></li><li><input type=checkbox id=section-d4428d0313ccb2e3380b00740324e064 class=toggle>
<label for=section-d4428d0313ccb2e3380b00740324e064 class=flex><a href=/chapter-9/cloud-native-patterns/ class=flex-auto>9.5 الگوهای Cloud Native</a></label><ul><li><a href=/chapter-9/cloud-native-patterns/go-cloud-native-circuit-breaker-pattern/>9.5.1 الگو Circuit Breaker</a></li><li><a href=/chapter-9/cloud-native-patterns/go-cloud-native-debounce-pattern/>9.5.2 الگو Debounce</a></li><li><a href=/chapter-9/cloud-native-patterns/go-cloud-native-retry-pattern/>9.5.3 الگو Retry</a></li><li><a href=/chapter-9/cloud-native-patterns/go-cloud-native-throttle-pattern/>9.5.4 الگو Throttle</a></li><li><a href=/chapter-9/cloud-native-patterns/go-cloud-native-timeout-pattern/>9.5.5 الگو Timeout</a></li></ul></li><li><input type=checkbox id=section-d2db70ad636838c12fc76435099656ac class=toggle>
<label for=section-d2db70ad636838c12fc76435099656ac class=flex><a href=/chapter-9/anti-pattern/ class=flex-auto>9.6 ضد الگوها (Anti-Patterns)</a></label><ul><li><a href=/chapter-9/anti-pattern/go-anti-patterns-in-syntax/>9.6.1 ضد الگو سینتکسی</a></li></ul></li><li><a href=/chapter-9/solid-principle-in-golang/ class=active>9.7 اصول SOLID</a></li></ul></li><li><input type=checkbox id=section-109a423730eebb4b9e804ab6e8dc6af0 class=toggle>
<label for=section-109a423730eebb4b9e804ab6e8dc6af0 class=flex><a href=/chapter-10/ class=flex-auto>فصل دهم: الگوریتم و ساختار داده</a></label><ul><li><a href=/chapter-10/10.1--data-structures-queue-stack-lists/>10.1 Data Structures (Queue Stack Lists)</a></li></ul></li><li><input type=checkbox id=section-0736842d303fef477d0a09e8de4a0d85 class=toggle>
<label for=section-0736842d303fef477d0a09e8de4a0d85 class=flex><a href=/chapter-11/ class=flex-auto>فصل یازدهم: معماری های نرم افزار</a></label><ul></ul></li><li><input type=checkbox id=section-efb5b19050ead65a76618516db266d2d class=toggle>
<label for=section-efb5b19050ead65a76618516db266d2d class=flex><a href=/chapter-12/ class=flex-auto>فصل دوازدهم: شبکه بلاکچین</a></label><ul><li><input type=checkbox id=section-ee81a41ef810f317eba2e67d447c0ec4 class=toggle>
<label for=section-ee81a41ef810f317eba2e67d447c0ec4 class=flex><a href=/chapter-12/blockchain/ class=flex-auto>12.1 بلاکچین</a></label><ul><li><a href=/chapter-12/blockchain/blockchain/>12.1.1 بلاکچین چیست</a></li><li><a href=/chapter-12/blockchain/blockchain-history/>12.1.2 تاریخچه بلاکچین</a></li><li><a href=/chapter-12/blockchain/blockchain-architecture/>12.1.3 معماری بلاکچین</a></li><li><a href=/chapter-12/blockchain/blockchain-type/>12.1.4 انواع بلاکچین</a></li><li><a href=/chapter-12/blockchain/blockchain-different-with-centerlized/>12.1.5 تفاوت سیستم متمرکز با غیرمتمرکز</a></li><li><a href=/chapter-12/blockchain/blockchain-scale/>12.1.6 مقیاس پذیری در بلاکچین</a></li><li><a href=/chapter-12/blockchain/blockchain-security/>12.1.7 امنیت در بلاکچین</a></li><li><a href=/chapter-12/blockchain/blockchain-cryptography/>12.1.8 مفاهیم رمزنگاری</a></li><li><a href=/chapter-12/blockchain/blockchain-consensus-algorithm/>12.1.10 الگوریتم اجماع (Consensus)</a></li><li><a href=/chapter-12/blockchain/blockchain-p2p-network/>12.1.11 ساختار و کاربرد شبکه P2P</a></li><li><a href=/chapter-12/blockchain/blockchain-data-management/>12.1.12 مدیریت داده در بلاکچین</a></li><li><a href=/chapter-12/blockchain/blockchain-network-testing/>12.1.13 تست پذیری شبکه</a></li><li><a href=/chapter-12/blockchain/blockchain-analyze-and-optimization/>12.1.14 ارزیابی و بهینه سازی شبکه</a></li><li><a href=/chapter-12/blockchain/blockchain-monitoring/>12.1.15 مانیتورینگ شبکه</a></li><li><a href=/chapter-12/blockchain/blockchain-forking/>12.1.16 استراتژی فورک ها</a></li><li><a href=/chapter-12/blockchain/blockchain-api-and-sdk/>12.1.17 پیاده سازی انواع API ها و SDK ها</a></li><li><a href=/chapter-12/blockchain/blockchain-keys-and-addresses/>12.1.18 کلیدها و آدرس ها</a></li><li><a href=/chapter-12/blockchain/blockchain-accounts/>12.1.19 اکانت ها</a></li><li><a href=/chapter-12/blockchain/blockchain-transactions-and-messages/>12.1.20 تراکنش ها و پیام ها</a></li><li><a href=/chapter-12/blockchain/blockchain-blocks/>12.1.21 بلوک ها (Blocks)</a></li><li><a href=/chapter-12/blockchain/blockchain-genesis/>12.1.22 جنسیس (Genesis)</a></li><li><a href=/chapter-12/blockchain/blockchain-smart-contracts/>12.1.23 قراردادهای هوشمند</a></li><li><a href=/chapter-12/blockchain/blockchain-privacy/>12.1.24 حریم خصوصی شبکه</a></li></ul></li><li><input type=checkbox id=section-3a22b13c7bb1ba964a59c01435868bd6 class=toggle>
<label for=section-3a22b13c7bb1ba964a59c01435868bd6 class=flex><a href=/chapter-12/bitcoin/ class=flex-auto>12.2 شبکه بیت کوین</a></label><ul><li><a href=/chapter-12/bitcoin/bitcoin/>12.2.1 معرفی بیت کوین</a></li><li><a href=/chapter-12/bitcoin/bitcoin-cryptography/>12.2.2 رمزنگاری در بیت کوین</a></li><li><a href=/chapter-12/bitcoin/bitcoin-addresses/>12.2.3 آدرس ها</a></li><li><a href=/chapter-12/bitcoin/bitcoin-transactions/>12.2.4 تراکنش ها</a></li><li><a href=/chapter-12/bitcoin/bitcoin-structure/>12.2.5 ساختار بلاکچین بیت کوین</a></li><li><a href=/chapter-12/bitcoin/bitcoin-consensus/>12.2.6 الگوریتم اجماع</a></li><li><a href=/chapter-12/bitcoin/bitcoin-miners/>12.2.7 ماینرها</a></li><li><a href=/chapter-12/bitcoin/bitcoin-network/>12.2.8 شبکه</a></li><li><a href=/chapter-12/bitcoin/bitcoin-wallets/>12.2.9 والت ها</a></li><li><a href=/chapter-12/bitcoin/bitcoin-in-real-world/>12.2.10 بیت کوین در دنیای واقعی</a></li><li><a href=/chapter-12/bitcoin/bitcoin-innovation/>12.2.11 نوآوری</a></li><li><a href=/chapter-12/bitcoin/bitcoin-clients/>12.2.12 کلاینت ها</a></li><li><a href=/chapter-12/bitcoin/bitcoin-programming/>12.2.13 برنامه نویسی در بیت کوین</a></li></ul></li><li><input type=checkbox id=section-b9f4acac44a727569ffab43028a36441 class=toggle>
<label for=section-b9f4acac44a727569ffab43028a36441 class=flex><a href=/chapter-12/ethereum/ class=flex-auto>12.3 شبکه اتریوم</a></label><ul><li><a href=/chapter-12/ethereum/ethereum/>12.3.1 معرفی اتریوم</a></li><li><a href=/chapter-12/ethereum/ethereum-cryptography/>12.3.2 رمزنگاری</a></li><li><a href=/chapter-12/ethereum/ethereum-keys-and-addresses/>12.3.3 آدرس ها و کلیدها</a></li><li><a href=/chapter-12/ethereum/ethereum-accounts/>12.3.4 اکانت ها</a></li><li><a href=/chapter-12/ethereum/ethereum-transactions-and-messages/>12.3.5 تراکنش ها و پیام ها</a></li><li><a href=/chapter-12/ethereum/ethereum-virtual-machine/>12.3.6 ماشین مجازی اتریوم</a></li><li><a href=/chapter-12/ethereum/ethereum-blocks/>12.3.7 بلاک ها</a></li><li><a href=/chapter-12/ethereum/ethereum-consensus/>12.3.8 الگوریتم اجماع</a></li><li><a href=/chapter-12/ethereum/ethereum-nodes-and-miners/>12.3.9 نودها و ماینرها</a></li><li><a href=/chapter-12/ethereum/ethereum-network/>12.3.10 شبکه</a></li><li><a href=/chapter-12/ethereum/ethereum-smart-contracts/>12.3.11 قراردادهای هوشمند</a></li><li><a href=/chapter-12/ethereum/ethereum-wallets-and-clients/>12.3.12 والت ها و کلاینت ها</a></li><li><a href=/chapter-12/ethereum/go-ethereum/>12.3.13 معرفی go-ethereum</a></li><li><a href=/chapter-12/ethereum/work-with-accounts/>12.3.14 کار با اکانت ها</a></li><li><a href=/chapter-12/ethereum/transactions-on-ethereum/>12.3.15 تراکنش برروی اتریوم</a></li><li><a href=/chapter-12/ethereum/read-write-in-smart-contracts/>12.3.16 نوشتن و ارتباط با قراردادهای هوشمند</a></li><li><a href=/chapter-12/ethereum/abi-and-bin-file/>12.3.17 آشنایی با فایل ABI و bytecode</a></li><li><a href=/chapter-12/ethereum/event-logs/>12.3.18 خواندن و دریافت لحظه ای لاگ های کانترکت ها</a></li><li><a href=/chapter-12/ethereum/signature/>12.3.19 ایجاد و تایید امضا</a></li><li><a href=/chapter-12/ethereum/geth/>12.3.20 کار با geth</a></li><li><a href=/chapter-12/ethereum/protocol-swarm-and-whisper/>12.3.21 کار با پروتکل whisper و swarm</a></li></ul></li><li><input type=checkbox id=section-71c1e946dcbe629ce566392c9ba8a5bd class=toggle>
<label for=section-71c1e946dcbe629ce566392c9ba8a5bd class=flex><a href=/chapter-12/pactus/ class=flex-auto>12.4 شبکه پکتوس</a></label><ul><li><a href=/chapter-12/pactus/pactus/>12.4.1 معرفی پکتوس</a></li><li><a href=/chapter-12/pactus/pactus-roadmap/>12.4.2 نقشه راه و اهداف</a></li><li><a href=/chapter-12/pactus/pactus-cryptography/>12.4.3 رمزنگاری</a></li><li><a href=/chapter-12/pactus/pactus-addresses-and-keys/>12.4.4 آدرس ها و کلیدها</a></li><li><a href=/chapter-12/pactus/pactus-accounts/>12.4.5 اکانت ها</a></li><li><a href=/chapter-12/pactus/pactus-transactions-and-messages/>12.4.6 تراکنش ها و پیغام ها</a></li><li><a href=/chapter-12/pactus/pactus-consensus/>12.4.7 الگوریتم اجماع</a></li><li><a href=/chapter-12/pactus/pactus-client/>12.4.8 کار با کلاینت</a></li><li><a href=/chapter-12/pactus/pactus-smart-contracts/>12.4.9 قراردادهای هوشمند (بزودی)</a></li></ul></li></ul></li></ul><a class="book-btn gray" href=https://github.com/GoFarsi/book>مخزن کتاب</a>
<a class=book-btn href=https://github.com/GoFarsi/book/blob/main/COUNTRIBUTING.md>مشارکت در کتاب زبان گو</a><center><p><img alt="GitHub Repo stars" src=https://img.shields.io/github/stars/GoFarsi/book> <img alt=GitHub src=https://img.shields.io/github/license/gofarsi/book> <img alt="GitHub contributors" src=https://img.shields.io/github/contributors/gofarsi/book></p></center></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>9.7 اصول SOLID</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"></br><main><div class=wrapper><a href=https://t.me/GolangEngineers class="icon telegram" target=_blank><div class=tooltip>گروه تلگرامی مهندسین گولنگ</div><span><i class="fab fa-telegram"></i></span>
</a><a href=https://linkedin.com/in/Ja7ad class="icon linkedin" target=_blank><div class=tooltip>لینکدین نویسنده</div><span><i class="fab fa-linkedin"></i></span>
</a><a href=https://twitter.com/Ja7adR class="icon twitter" target=_blank><div class=tooltip>توییتر نویسنده</div><span><i class="fab fa-twitter"></i></span></a></div></main></br></br><nav id=TableOfContents><ul><li><ul><li><a href=#971-مقدمه>9.7.1 مقدمه</a><ul><li></li></ul></li><li><a href=#972--اصل-single-responsibility>9.7.2 اصل Single Responsibility</a><ul><li><a href=#9721-بررسی-coupling-و-cohesion>9.7.2.1 بررسی Coupling و Cohesion</a></li><li><a href=#9722-نام--packageها>9.7.2.2 نام Package‌ها</a></li><li><a href=#9723-نامهای-بد-package>9.7.2.3 نام‌های بد Package</a></li><li><a href=#9724-فلسفهی-یونیکس-در-go>9.7.2.4 فلسفه‌ی یونیکس در Go</a></li><li><a href=#9725-مثال-single-responsibility>9.7.2.5 مثال Single Responsibility</a></li></ul></li><li><a href=#973-اصل-open--closed>9.7.3 اصل Open / Closed</a><ul><li><a href=#9731-مثال--open--closed>9.7.3.1 مثال Open / Closed</a></li></ul></li><li><a href=#974-اصل--liskov-substitution>9.7.4 اصل Liskov Substitution</a><ul><li><a href=#9741-بررسی-interface-ها>9.7.4.1 بررسی Interface ها</a></li><li><a href=#9742--بررسی-ioreader>9.7.4.2 بررسی io.Reader</a></li><li><a href=#9743-مثال--liskov-substitution>9.7.4.3 مثال Liskov Substitution</a></li></ul></li><li><a href=#975-اصل--interface-segregation>9.7.5 اصل Interface Segregation</a><ul><li><a href=#9751-مثال-interface-segregation>9.7.5.1 مثال Interface Segregation:</a></li></ul></li><li><a href=#976-اصل-dependency-inversion>9.7.6 اصل Dependency Inversion</a><ul><li><a href=#9761-مثال>9.7.6.1 مثال</a></li><li><a href=#977-طراحی-solid-در-go>9.7.7 طراحی SOLID در Go</a></li></ul></li><li><a href=#978-در-پایان>9.7.8 <strong>در پایان</strong></a></li></ul></li></ul></nav></aside></header><h1>9.7 اصول SOLID</h1><article class="markdown book-article"><h2 id=971-مقدمه>9.7.1 مقدمه
<a class=anchor href=#971-%d9%85%d9%82%d8%af%d9%85%d9%87>#</a></h2><p>این مقاله ترجمه ارایه اصول solid در golang توسط <a href=https://dave.cheney.net/>Dave Cheney</a>می‌‌باشد.</p><p>در این مبحث به بررسی پیاده سازی solid در زبان Go می‌پردازیم.</p><p>بررسی کد</p><ul><li>چه کسی اینجا بررسی کد را به عنوان بخشی از کار خود انجام می‌دهد؟ تمام اتاق دستشان را بالا بردند که تشویق کننده بود. خوب، چرا بررسی کد انجام می‌دهید؟ کسی فریاد زد «برای جلوگیری از کد بد»</li><li>اگر code review برای شناسایی کد‌های نامناسب است، پس چگونه می‌دانید کدی که بررسی می‌کنید خوب است یا بد؟</li><li>حالا خوب است بگوییم «آن کد نامناسب است» یا «آن کد منبع زیبا است»، درست مانند اینکه بگویید «این نقاشی زیبا است» یا «این اتاق زیبا است» اما اینها اصطلاحات ذهنی هستند و من به دنبال راه‌های عینی برای صحبت در مورد خواص کد خوب یا بد هستم.</li></ul><h4 id=کد-بد>کد بد
<a class=anchor href=#%da%a9%d8%af-%d8%a8%d8%af>#</a></h4><ul><li>برخی از ویژگی‌های کد بد که ممکن است در بررسی کد به آن پی ببرید کدامند؟</li><li>سفت و خشک یا در اصطلاح Rigid. آیا کد Rigid است؟ آیا دارای یک محافظ محدود کننده از انواع و پارامترهای غالب است که اصلاح آن را دشوار می‌کند؟</li><li>شکننده یا در اصطلاح Fragile. آیا کد Fragile است؟ آیا کوچکترین تغییر در کد باعث ایجاد ویرانی‌های فراوان می‌شود؟</li><li>بی‌حرکتی یا Immobile . آیا تغییر در ساختار کد سخت است؟ آیا اضافه کردن یک حلقه ساده در برنامه کار پیچیده‌ای است؟</li><li>پیچیده (Complex). آیا کدها به دلیل اینکه فقط کدی نوشته شده باشد بدون آن که به آن نیاز باشد، وجود دارد، آیا چیزها بیش از حد مهندسی (over-engineered) شده‌اند؟</li><li>شرح دادن بیش از حد یا Verbose. آیا استفاده و بررسی از کد خسته‌کننده است؟ وقتی به آن نگاه می‌کنید، می‌توانید بگویید این کد چه کاری می‌خواهد انجام دهد؟</li><li>آیا این کلمات مثبت هستند؟ آیا از شنیدن این کلمات در بررسی کد خود خوشحال خواهید شد؟</li><li>احتمالا نه.</li></ul><h4 id=طراحی-خوب>طراحی خوب
<a class=anchor href=#%d8%b7%d8%b1%d8%a7%d8%ad%db%8c-%d8%ae%d9%88%d8%a8>#</a></h4><p>اما این یک بهبود دادن در سطح کد است، حالا می‌توانیم چیزهایی مثل «من این را دوست ندارم چون خیلی سخت است تغییرش داد» یا «من این را دوست ندارم چون نمی‌توانم بفهمم کد چه کاری می‌خواهد انجام دهد» بگوییم، اما چه می‌شود اگر با مثبت شروع کنیم؟</p><p>آیا خوب نمی‌شد اگر راه‌هایی برای توصیف ویژگی‌های طراحی خوب وجود داشت، نه فقط طراحی بد و بتوانیم این کار را با اصطلاحات عینی انجام دهیم؟</p><h4 id=بررسی-solid>بررسی SOLID
<a class=anchor href=#%d8%a8%d8%b1%d8%b1%d8%b3%db%8c-solid>#</a></h4><p>در سال 2002 رابرت مارتین کتاب<a href="https://www.amazon.co.uk/dp/0135974445/ref=pd_lpo_sbs_dp_ss_2/253-1946330-6751666?pf_rd_m=A3P5ROKL5A1OLE&amp;pf_rd_s=lpo-top-stripe&amp;pf_rd_r=23C4AHYV7EXGYHKD6G8Q&amp;pf_rd_t=201&amp;pf_rd_p=569136327&amp;pf_rd_i=0132760584"> توسعه نرم‌افزار چابک</a>، <a href="https://www.amazon.co.uk/dp/0135974445/ref=pd_lpo_sbs_dp_ss_2/253-1946330-6751666?pf_rd_m=A3P5ROKL5A1OLE&amp;pf_rd_s=lpo-top-stripe&amp;pf_rd_r=23C4AHYV7EXGYHKD6G8Q&amp;pf_rd_t=201&amp;pf_rd_p=569136327&amp;pf_rd_i=0132760584">اصول، الگوها و روش‌ها</a> را منتشر کرد. او پنج اصل طراحی نرم‌افزار قابل استفاده مجدد را توصیف کرد که اصول SOLID نامید، بر اساس حروف اول نام‌های آن‌ها. که شامل موارد زیر است:</p><ul><li>Single Responsibility Principle</li><li>Open / Closed Principle</li><li>Liskov Substitution Principle</li><li>Interface Segregation Principle</li><li>Dependency Inversion Principle</li></ul><p>این کتاب کمی قدیمی است، زبان‌هایی که در مورد آن‌ها صحبت می‌کند، زبان‌هایی هستند که بیش از یک دهه پیش استفاده می‌شدند. اما، شاید جنبه‌هایی از اصول SOLID وجود داشته باشد که بتواند به ما سرنخی در مورد نحوه صحبت در مورد برنامه‌های Go با طراحی خوب بدهد.</p><p>بنابراین می‌خواهم مدتی را صرف بحث در مورد این موضوع با شما کنم.</p><h2 id=972--اصل-single-responsibility>9.7.2 اصل Single Responsibility
<a class=anchor href=#972--%d8%a7%d8%b5%d9%84-single-responsibility>#</a></h2><p>اولین اصل S در SOLID که اصل مسئولیت واحد است.</p><blockquote><p>یک کلاس باید یک و تنها یک دلیل برای تغییر داشته باشد.</p></blockquote><p>خب در زبان Go واضح است که چیزی به نام کلاس وجود ندارد - در عوض ما مفهوم بسیار قدرتمندتر composition را داریم - اما اگر بتوانید از استفاده از کلمه کلاس چشم‌پوشی کنید، فکر می‌کنم ارزش آن را دارد.</p><p>چرا مهم است که یک قطعه کد فقط یک دلیل برای تغییر داشته باشد؟ خب، به اندازه اینکه ایده تغییر کد خودتان آزاردهنده است، کشف اینکه کدی که کد شما به آن وابسته است و مبنای آن تغییر می‌کند بسیار آزاردهنده‌تر است و وقتی کد شما باید تغییر کند، باید در پاسخ به یک محرک مستقیم این کار را انجام دهد، نباید قربانی آسیب‌های جانبی شود.</p><p>بنابراین کدی که مسئولیت واحدی دارد، در نتیجه کمترین دلایل برای تغییر را دارد.</p><h3 id=9721-بررسی-coupling-و-cohesion>9.7.2.1 بررسی Coupling و Cohesion
<a class=anchor href=#9721-%d8%a8%d8%b1%d8%b1%d8%b3%db%8c-coupling-%d9%88-cohesion>#</a></h3><p>کوپلینگ و Cohesion دو کلمه‌ای که توصیف می‌کنند تغییر یک نرم‌افزار چقدر آسان یا سخت است، Coupling و Cohesion هستند.</p><p>کوپلینگ به سادگی کلمه‌ای است که دو چیز را توصیف می‌کند که با هم تغییر می‌کنند - حرکت در یکی باعث حرکت در دیگری می‌شود.</p><p>یک مفهوم مرتبط اما جداگانه، ایده Cohesion است، نیروی جذب متقابل.</p><p>در زمینه نرم‌افزار، Cohesion خاصیتی است که توصیف می‌کند قطعات کد به طور طبیعی به یکدیگر جذب می‌شوند.</p><p>برای توصیف واحدهای کوپلینگ و Cohesion در یک برنامه Go، ممکن است در مورد توابع و متدها صحبت کنیم، همانطور که در هنگام بحث در مورد SRP بسیار رایج است، اما من معتقدم که این کار با مدل packageهای Go شروع می‌شود.</p><h3 id=9722-نام--packageها>9.7.2.2 نام Package‌ها
<a class=anchor href=#9722-%d9%86%d8%a7%d9%85--package%d9%87%d8%a7>#</a></h3><p>در Go، تمام کدها داخل یک Package قرار دارند و یک Package خوب طراحی شده با نام آن شروع می‌شود. نام یک Package هم توصیفی از هدف آن است و هم پیشوند فضای نام. برخی از مثال‌های Package‌های خوب از کتابخانه‌ی استاندارد Go می‌توانند باشند:</p><ul><li>‏net/http که کلاینت‌ها و سرورهای http را فراهم می‌کند.</li><li>‏os/exec که دستورات خارجی را اجرا می‌کند.</li><li>‏encoding/json،که کدگذاری و رمزگشایی اسناد JSON را پیاده‌سازی می‌کند.</li></ul><p>وقتی شما از نمادهای Package دیگری در داخل Package خود استفاده می‌کنید، این کار با اعلامیه‌ی <code>import</code> انجام می‌شود که یک کوپلینگ سطح منبع بین دو Package ایجاد می‌کند. آن‌ها حالا یکدیگر را می‌شناسند.</p><h3 id=9723-نامهای-بد-package>9.7.2.3 نام‌های بد Package
<a class=anchor href=#9723-%d9%86%d8%a7%d9%85%d9%87%d8%a7%db%8c-%d8%a8%d8%af-package>#</a></h3><p>این تمرکز بر نام‌ها فقط موشکافی نیست. یک Package بدنام فرصت بررسی هدف خود را از دست می‌دهد، اگر اصلا هدفی داشته باشد.</p><p>بسته‌ی server چه چیزی را فراهم می‌کند؟ &mldr; خب، امیدوارم یک سرور، اما با کدام پروتکل؟</p><p>بسته‌ی private چه چیزی را فراهم می‌کند؟ چیزهایی که نباید ببینم؟ آیا باید نمادهای public داشته باشد؟</p><p>و بسته‌ی common، درست مثل همکارش، بسته‌ی utils، اغلب در نزدیکی این متخلفان دیگر پیدا می‌شود.</p><p>بسته‌های همه کاره‌ی مانند این به یک محل دفن زباله برای چیزهای مختلف تبدیل می‌شوند و چون مسئولیت‌های زیادی دارند، اغلب بدون دلیل تغییر می‌کنند.</p><h3 id=9724-فلسفهی-یونیکس-در-go>9.7.2.4 فلسفه‌ی یونیکس در Go
<a class=anchor href=#9724-%d9%81%d9%84%d8%b3%d9%81%d9%87%db%8c-%db%8c%d9%88%d9%86%db%8c%da%a9%d8%b3-%d8%af%d8%b1-go>#</a></h3><p>به نظر من، هیچ بحثی در مورد طراحی جدا شده بدون ذکر فلسفه‌ی یونیکس  Doug McIlroy کامل نمی‌شود؛ ابزارهای کوچک و چابک که برای حل کارهای بزرگ‌تر ترکیب می‌شوند، اغلب کارهایی که توسط نویسندگان اصلی پیش‌بینی نشده بود.</p><p>فکر می‌کنم بسته‌های Go روحیه‌ی فلسفه‌ی یونیکس را تجسم می‌بخشند. در واقع هر بسته‌ی Go خود یک برنامه‌ی کوچک Go است، یک اثرگذاری کوچک با یک مسئولیت واحد.</p><h3 id=9725-مثال-single-responsibility>9.7.2.5 مثال Single Responsibility
<a class=anchor href=#9725-%d9%85%d8%ab%d8%a7%d9%84-single-responsibility>#</a></h3><p>این اصل بیان می‌کند که یک ساختار باید تنها یک دلیل برای تغییر داشته باشد، به این معنی که یک ساختار باید تنها یک مسئولیت داشته باشد. این کمک می کند تا کد را تمیز و قابل نگهداری نگه دارید، زیرا تغییرات در ساختار فقط باید در یک مکان انجام شود.</p><p>فرض کنید من یک کارمند ساختاری دارم که نام، حقوق و آدرس یک کارمند را پیگیری می‌کند:</p><pre><code class=language-go>type Employee struct {
	Name string 
	Salary float64 
	Address string 
}
</code></pre><p>طبق SRP، هر ساختار باید تنها یک مسئولیت داشته باشد، بنابراین در این مورد، بهتر است مسئولیت‌های ساختار <code>Employee</code> به دو ساختار جداگانه تقسیم شود: <code>EmployeeInfo</code> و <code>EmployeeAddress</code>.</p><pre><code class=language-go>type EmployeeInfo struct {
    Name   string
    Salary float64
}

type EmployeeAddress struct {
    Address string
}
</code></pre><p>اکنون می‌توانیم توابع جداگانه‌ای داشته باشیم که مسئولیت‌های مختلف هر ساختار را بر عهده دارد:</p><pre><code class=language-go>func (e EmployeeInfo) GetSalary() float64 {
    return e.Salary
}

func (e EmployeeAddress) GetAddress() string {
    return e.Address
}
</code></pre><p>با پیروی از SRP، من کد را قابل نگهداری تر و درک آن آسان‌تر کرده‌ام، زیرا اکنون هر ساختار مسئولیت مشخص و مشخصی دارد. اگر بخواهم تغییراتی در محاسبه حقوق و دستمزد یا رسیدگی به آدرس ایجاد کنم، دقیقاً می‌دانم به کجا نگاه کنم، بدون اینکه نیازی به کدهای نامرتبط زیادی داشته باشم.</p><h2 id=973-اصل-open--closed>9.7.3 اصل Open / Closed
<a class=anchor href=#973-%d8%a7%d8%b5%d9%84-open--closed>#</a></h2><p>اصل دوم، O، اصل بسته باز توسط برتراند مایر است که در سال 1988 نوشت:</p><blockquote><p>موجودیت‌های نرم‌افزار باید برای توسعه باز باشند، اما برای اصلاح بسته شوند.<br>– برتراند مایر، ساخت نرم افزار شی گرا</p></blockquote><p>این توصیه چگونه در مورد زبانی که 21 سال بعد نوشته شده است صدق می کند؟</p><pre><code class=language-go>package main

type A struct {
        year int
}

func (a A) Greet() { fmt.Println(&quot;Hello GolangUK&quot;, a.year) }

type B struct {
        A
}

func (b B) Greet() { fmt.Println(&quot;Welcome to GolangUK&quot;, b.year) }

func main() {
        var a A
        a.year = 2016
        var b B
        b.year = 2016
        a.Greet() // Hello GolangUK 2016
        b.Greet() // Welcome to GolangUK 2016
}
</code></pre><p>ما یک type به نام A داریم با یک field به نام year و یک متد به نام Greet. یک type دوم به نام B داریم که A را در خود جای می‌دهد، بنابراین فراخواننده‌ها متدهای B را روی متدهای A می‌بینند زیرا A به عنوان یک field در داخل B جاسازی شده است و B می‌تواند متد Greet خود را ارائه دهد و آن را از A پنهان کند.</p><p>اما جاسازی فقط برای متدها نیست، بلکه دسترسی به فیلدهای نوع جاسازی شده را نیز فراهم می‌کند. همانطور که می‌بینید، از آنجایی که هر دو A و B در یک package تعریف شده‌اند، B می‌تواند به فیلد خصوصی year در A دسترسی داشته باشد انگار که در داخل B تعریف شده است.</p><p>بنابراین جاسازی (embedding) یک ابزار قدرتمند است که به تایپ‌های Go اجازه می‌دهد برای گسترش باز باشند.</p><pre><code class=language-go>package main

type Cat struct {
        Name string
}

func (c Cat) Legs() int { return 4 }

func (c Cat) PrintLegs() {
        fmt.Printf(&quot;I have %d legs\n&quot;, c.Legs())
}

type OctoCat struct {
        Cat
}

func (o OctoCat) Legs() int { return 5 }

func main() {
        var octo OctoCat
        fmt.Println(octo.Legs()) // 5
        octo.PrintLegs()         // I have 4 legs
}
</code></pre><p>در این مثال، ما یک type به نام Cat داریم که می‌تواند تعداد پاهای خود را با متد Legs بشمارد. ما این نوع Cat را در یک نوع جدید به نام OctoCat جاسازی می‌کنیم و اعلام می‌کنیم که Octocatها پنج پا دارند. با این حال، اگرچه OctoCat متد Legs خود را تعریف می‌کند که 5 برمی‌گرداند، اما وقتی متد PrintLegs فراخوانی می‌شود، 4 برمی‌گرداند.</p><p>این به این دلیل است که PrintLegs روی نوع Cat تعریف شده است. این متد یک Cat را به عنوان گیرنده خود می‌گیرد، بنابراین به متد Legs در Cat ارسال می‌شود. Cat هیچ اطلاعی از نوعی که در آن جاسازی شده است ندارد، بنابراین مجموعه متدهای آن نمی‌تواند با جاسازی تغییر کند.</p><p>بنابراین می‌توانیم بگوییم که انواع Go در حالی که برای گسترش باز هستند، برای تغییر بسته هستند.</p><p>در واقع، متدها در Go چیزی بیشتر از نوعی syntax در اطراف یک تابع با یک پارامتر از پیش تعریف شده، گیرنده‌ی خود نیستند.</p><pre><code class=language-go>func (c Cat) PrintLegs() {
        fmt.Printf(&quot;I have %d legs\n&quot;, c.Legs())
}

func PrintLegs(c Cat) {
        fmt.Printf(&quot;I have %d legs\n&quot;, c.Legs())
}
</code></pre><p>گیرنده یا receiver دقیقا همان چیزی است که به آن پاس می‌دهید، اولین پارامتر function است و از آنجا که Go از  function overloading پشتیبانی نمی‌کند، در نتیجه OctoCatها جایگزین Cats معمولی نمی‌شوند. که من را به اصل بعدی در solid می‌رساند.</p><h3 id=9731-مثال--open--closed>9.7.3.1 مثال Open / Closed
<a class=anchor href=#9731-%d9%85%d8%ab%d8%a7%d9%84--open--closed>#</a></h3><p>فرض کنید من وظیفه دارم یک سیستم پرداخت بسازم که بتواند پرداخت‌های کارت اعتباری را پردازش کند. همچنین باید به‌اندازه کافی انعطاف‌پذیر باشد تا انواع روش‌های پرداخت را در آینده بپذیرد.</p><pre><code class=language-go>package main

import &quot;fmt&quot;

type PaymentMethod interface {
  Pay()
}

type Payment struct{}

func (p Payment) Process(pm PaymentMethod) {
  pm.Pay()
}

type CreditCard struct {
  amount float64
}

func (cc CreditCard) Pay() {
  fmt.Printf(&quot;Paid %.2f using CreditCard&quot;, cc.amount)
}

func main() {
  p := Payment{}
  cc := CreditCard{12.23}
  p.Process(cc)
}
</code></pre><p>طبق OCP، ساختار پرداخت من برای توسعه باز و برای اصلاح بسته است. ازآنجایی‌که من از واسط PaymentMethod استفاده می‌کنم، مجبور نیستم رفتار پرداخت را هنگام افزودن روش‌های پرداخت جدید ویرایش کنم. اضافه‌کردن چیزی مانند PayPal به شکل زیر است:</p><pre><code class=language-go>type PayPal struct {
  amount float64
}

func (pp PayPal) Pay() {
  fmt.Printf(&quot;Paid %.2f using PayPal&quot;, pp.amount)
}

// then in main()
pp := PayPal{22.33}
p.Process(pp)
</code></pre><h2 id=974-اصل--liskov-substitution>9.7.4 اصل Liskov Substitution
<a class=anchor href=#974-%d8%a7%d8%b5%d9%84--liskov-substitution>#</a></h2><p>این اصل توسط توسط باربارا لیسکوف معرفی شده است، اصل جایگزینی لیسکوف تقریباً بیان می‌کند که دو نوع قابل جایگزینی هستند اگر رفتارهایی را نشان دهند که فراخواننده نتواند تفاوت را تشخیص دهد.</p><p>در یک زبان مبتنی بر کلاس‌ها، اصل جایگزینی لیسکوف معمولاً به عنوان یک مشخصات برای یک abstract base class با زیرگونه‌های concrete class مختلف تفسیر می‌شود. اما Go کلاس یا وراثت ندارد، بنابراین جایگزینی نمی‌تواند از نظر سلسله مراتب abstract class پیاده‌سازی شود.</p><h3 id=9741-بررسی-interface-ها>9.7.4.1 بررسی Interface ها
<a class=anchor href=#9741-%d8%a8%d8%b1%d8%b1%d8%b3%db%8c-interface-%d9%87%d8%a7>#</a></h3><p>در عوض، پایده سازی اصل جایگزینی (substitution) در این حوزه‌ بر عهده Interfaceها در Go است. در Go، از تایپ‌ها انتظار نمی‌رود که یک Interface خاصی را که پیاده‌سازی می‌کنند را از قبل معرفی کنند، در عوض هر تایپ یک Interface را پیاده‌سازی می‌کند به شرطی که متدهایی داشته باشد که امضای (signature) آن با اعلامیه اینترفیس (interface declaration) مطابقت داشته باشد.</p><p>ما می‌گوییم که در Go، رابط‌ها یا Interfaceها به طور ضمنی (implicitly) برآورده می‌شوند، نه صریح یا explicitly و این تأثیر عمیقی بر نحوه استفاده از آن‌ها در این زبان برنامه نویسی دارد.</p><p>اینترفیس‌های طراحی شده خوب در بیشتر موارد احتمال دارد که اینترفیس‌های کوچکی باشند؛ ضرب‌المثل غالب این است که یک Interface فقط یک متد دارد. منطقی است که اینترفیس‌های کوچک منجر به پیاده‌سازی‌های ساده شوند، زیرا انجام خلاف آن دشوار است. که منجر به بسته‌هایی می‌شود که از پیاده‌سازی‌های ساده تشکیل شده‌اند و توسط رفتار مشترک به هم متصل شده‌اند.</p><h3 id=9742--بررسی-ioreader>9.7.4.2 بررسی io.Reader
<a class=anchor href=#9742--%d8%a8%d8%b1%d8%b1%d8%b3%db%8c-ioreader>#</a></h3><pre><code class=language-go>type Reader interface {
        // Read reads up to len(buf) bytes into buf.
        Read(buf []byte) (n int, err error)
}
</code></pre><p>در ادامه مبحث که من را به io.Reader می‌رساند، به راحتی مورد علاقه من در بین اینترفیس‌ها در Go است.</p><p>اینترفیس io.Reader بسیار ساده است؛ Read داده‌ها را به بافر تأمین شده می‌خواند و تعداد بایت‌های خوانده شده و هر خطایی که در حین خواندن رخ داده است را به فراخواننده برمی‌گرداند. به نظر ساده می‌آید اما بسیار قدرتمند است.</p><p>از آنجایی که io.Reader با هر چیزی که بتوان آن را به عنوان یک stream از بایت‌ها بیان کرد سر و کار دارد، می‌توانیم خواننده‌ها را روی تقریباً هر چیزی ساختیم؛ یک رشته ثابت، یک آرایه بایت، ورودی استاندارد، یک جریان شبکه، یک فایل فشرده gzip، خروجی استاندارد یک فرمان که از طریق ssh به صورت remote اجرا می‌شود.</p><p>و تمام این پیاده‌سازی‌ها برای یکدیگر قابل جایگزینی هستند زیرا قرارداد ساده یکسانی را برآورده می‌کنند.</p><p>بنابراین اصل جایگزینی لیسکوف، اعمال شده بر روی Go، می‌تواند با این ضرب‌المثل زیبا از Jim Weirich خلاصه شود.</p><blockquote><p>Require no more, promise no less.<br>–Jim Weirich</p></blockquote><p>و این یک حرکت عالی در چهارمین اصل SOLID است.</p><h3 id=9743-مثال--liskov-substitution>9.7.4.3 مثال Liskov Substitution
<a class=anchor href=#9743-%d9%85%d8%ab%d8%a7%d9%84--liskov-substitution>#</a></h3><p>بیایید یک struct Animal را در نظر بگیریم:</p><pre><code class=language-go>type Animal struct {
  Name string
}

func (a Animal) MakeSound() {
  fmt.Println(&quot;Animal sound&quot;)
}
</code></pre><p>حال، فرض کنید می‌خواهیم یک ساختار جدید Bird بسازیم که نشان دهنده نوع خاصی از حیوانات است:</p><pre><code class=language-go>type Bird struct {
  Animal
}

func (b Bird) MakeSound() {
  fmt.Println(&quot;Chirp chirp&quot;)
}
</code></pre><p>این اصل بیان می‌کند که اشیاء یک superclass باید با اشیاء یک زیر کلاس بدون تأثیر بر صحت برنامه قابل‌تعویض باشند. این کمک می‌کند تا اطمینان حاصل شود که روابط بین کلاس ها به‌خوبی تعریف شده و قابل حفظ است.</p><pre><code class=language-go>type AnimalBehavior interface {
  MakeSound()
}

// MakeSound represent a program that works with animals and is expected
// to work with base class (Animal) or any subclass (Bird in this case)
func MakeSound(ab AnimalBehavior) {
  ab.MakeSound()
}

a := Animal{}
b := Bird{}
MakeSound(a)
MakeSound(b)
</code></pre><p>این وراثت در Go و همچنین اصل جایگزینی Liskov را نشان می‌دهد، زیرا اشیاء یک نوع فرعی Bird را می‌توان در هر جایی که اشیایی از نوع پایه Animal انتظار می‌رود استفاده کرد، بدون اینکه بر صحت برنامه تأثیر بگذارد.</p><h2 id=975-اصل--interface-segregation>9.7.5 اصل Interface Segregation
<a class=anchor href=#975-%d8%a7%d8%b5%d9%84--interface-segregation>#</a></h2><p>چهارمین اصل، اصل جداسازی اینترفیس است که به شرح زیر است:</p><blockquote><p>کلاینت نباید مجبور شوند که به متدهایی که استفاده نمی‌کنند وابسته باشند.<br>-رابرت سی مارتین</p></blockquote><pre><code class=language-go>// Save writes the contents of doc to the file f.
func Save(f *os.File, doc *Document) error
</code></pre><p>من می‌توانم این تابع را تعریف کنم، بیایید آن را Save بنامیم، که یک <code>*os.File</code> را به عنوان مقصد برای نوشتن  <code>Document</code> می‌گیرد. اما این کار چند مشکل دارد.</p><p>امضای یا signature مخصوص <code>Save</code> گزینه نوشتن داده‌ها به یک مکان شبکه‌ای را از بین می‌برد. با فرض اینکه ذخیره‌سازی شبکه احتمالاً بعداً به یک نیاز تبدیل می‌شود، امضای این تابع باید تغییر کند و روی تمام فراخواننده‌های آن تأثیر بگذارد.</p><p>از آنجایی که <code>Save</code> مستقیماً با فایل‌ها روی دیسک کار می‌کند، تست کردن آن ناخوشایند است. برای تأیید عملکرد آن، تست باید محتوای فایل را بعد از نوشتن بخواند. علاوه بر این، تست باید اطمینان حاصل کند که <code>f</code> به یک مکان موقت نوشته شده است و همیشه بعد از آن حذف می‌شود.</p><p>همچنین <code>os.File</code> متدهای زیادی را تعریف می‌کند که با <code>Save</code> مرتبط نیستند، مانند خواندن دایرکتوری‌ها و بررسی اینکه آیا یک مسیر یک symlink است. بسیار مفید خواهد بود اگر امضای تابع Save ما بتواند فقط قسمت‌های مرتبط <code>os.File</code> را توصیف کند.</p><p>پس با این مشکلات چه کنیم؟</p><pre><code class=language-go>// Save writes the contents of doc to the supplied Writer.
func Save(w io.Writer, doc *Document) error
</code></pre><p>یک راه حل بهتر این است که <code>Save</code> را دوباره تعریف کنیم تا فقط یک <code>io.Writer</code> بگیرد و مسئولیت انجام هر کاری غیر از نوشتن داده‌ها به یک جریان را کاملاً از آن بگیرد.</p><p>با اعمال اصل جداسازی interface بر روی تابع <code>Save</code>، نتیجه همزمان یک function است که از نظر نیازهای خود خاص‌ترین است و فقط به چیزی نیاز دارد که قابل نوشتن باشداکنون می‌توانیم از Save برای ذخیره داده‌های خود به هر چیزی که <code>io.Writer</code> را پیاده‌سازی می‌کند، استفاده کنیم.</p><blockquote><p>یک قانون بزرگ برای Go پذیرش interfaceها در structهای بازگشتی است.
Jack Lindamood</p></blockquote><h3 id=9751-مثال-interface-segregation>9.7.5.1 مثال Interface Segregation:
<a class=anchor href=#9751-%d9%85%d8%ab%d8%a7%d9%84-interface-segregation>#</a></h3><p>فرض کنید یک interface برای چاپگر اسناد داریم:</p><pre><code class=language-go>goCopy codetype Printer interface {
    Print()
    Scan()
    Fax()
}
</code></pre><p>اگر کلاینت فقط نیاز به چاپ اسناد دارد، نباید آنها را مجبور به پیاده سازی روش های اسکن و فکس کرد. در عوض، می‌توانیم این رابط را به interfaceهای کوچک‌تر و متمرکزتر تقسیم کنیم:</p><pre><code class=language-go>type Printer interface {
    Print()
}

type Scanner interface {
    Scan()
}

type FaxMachine interface {
    Fax()
}

</code></pre><h2 id=976-اصل-dependency-inversion>9.7.6 اصل Dependency Inversion
<a class=anchor href=#976-%d8%a7%d8%b5%d9%84-dependency-inversion>#</a></h2><p>اصل SOLID نهایی، اصل وارونگی وابستگی است که بیان می‌کند:</p><blockquote><p>ماژول های سطح بالا نباید به ماژول های سطح پایین وابسته باشند. هر دو باید به انتزاعات بستگی داشته باشند.<br>انتزاع ها نباید به جزئیات بستگی داشته باشند. جزئیات باید به انتزاعات بستگی داشته باشد.<br>-رابرت سی مارتین</p></blockquote><p>اما dependency inversion به طور عملی برای برنامه‌نویسان Go چه معنایی دارد؟</p><p>اگر تمام اصول مورد بحث تا این نقطه را اعمال کرده‌اید، کد شما باید از قبل به packageهای مجزا فاکتور شده باشد، هر کدام با یک مسئولیت یا هدف مشخص و خوب تعریف شده است. کد شما باید وابستگی‌های خود را از نظر اینترفیس‌ها توصیف کند و آن اینترفیس‌ها باید برای توصیف تنها رفتار مورد نیاز آن توابع فاکتور شوند. به عبارت دیگر، کار زیادی برای انجام باقی نمی‌ماند.</p><p>بنابراین فکر می‌کنم مارتین در اینجا در مورد ساختار گراف import کردن packageهای شما صحبت می‌کند که مطمئنا در زمینه Go است.</p><p>در Go باید import graph شما باید غیر دوره‌ای باشد. عدم رعایت این نیاز غیر دوره‌ای زمینه‌ای برای شکست کامپایل است، اما جدی‌تر نشان‌دهنده یک خطای جدی در طراحی است.</p><p>همه چیز برابر است، import graph یک برنامه‌ی Go به خوبی طراحی شده باید گسترده و نسبتاً مسطح باشد، نه بلند و باریک. اگر packageهای دارید که توابع آن بدون کمک گرفتن از packageهای‌ دیگری نمی‌توانند کار کنند، این احتمالاً نشانه‌ای است که کد به خوبی در امتداد مرزهای بسته فاکتور نشده است.</p><p>اصل وارونگی وابستگی شما را تشویق می‌کند که مسئولیت جزئیات را تا حد امکان به بالای import graph به packageهای‌ اصلی یا هندلر سطح بالا، منتقل کنید و اجازه دهید کد سطح پایین با انتزاعات - اینترفیس‌‌ها (abstractions–interfaces) سروکار داشته باشد.</p><h3 id=9761-مثال>9.7.6.1 مثال
<a class=anchor href=#9761-%d9%85%d8%ab%d8%a7%d9%84>#</a></h3><p>فرض کنید یک struct Worker داریم که نماینده یک <code>Worker</code> در یک شرکت است و یک struct <code>Supervisor</code> که نماینده یک سرپرست یا Supervisor است:
‍‍</p><pre><code class=language-go> type Worker struct {
  ID int
  Name string
}

func (w Worker) GetID() int {
  return w.ID
}

func (w Worker) GetName() string {
  return w.Name
}

type Supervisor struct {
  ID int
  Name string
}

func (s Supervisor) GetID() int {
  return s.ID
}

func (s Supervisor) GetName() string {
  return s.Name
}
</code></pre><p>اکنون، برای این حالت ضد الگو، فرض کنید یک بخش ماژول سطح بالا داریم که نشان دهنده یک بخش در یک شرکت است و نیاز به ذخیره اطلاعات در مورد workerها و supervisorها دارد که ماژول‌های سطح پایین در نظر گرفته می‌شوند:</p><pre><code class=language-go>type Department struct {
  Workers []Worker
  Supervisors []Supervisor
}
</code></pre><p>طبق اصل وارونگی وابستگی، ماژول های سطح بالا نباید به ماژول های سطح پایین وابسته باشند. در عوض، هر دو باید به انتزاعات بستگی داشته باشند. برای اصلاح مثال ضد الگوی خود، می توانم یک Interface Employee ایجاد کنم که نماینده هر دو، workerها و supervisorها باشد:</p><pre><code class=language-go>type Employee interface {
  GetID() int
  GetName() string
}
</code></pre><p>اکنون می توانم ساختار <code>Department</code> را به روزرسانی کنم تا دیگر به ماژول‌های سطح پایین وابسته نباشد:</p><pre><code class=language-go>type Department struct {
  Employees []Employee
}
</code></pre><p>و حالت نهایی:</p><pre><code class=language-go>package main

import &quot;fmt&quot;

type Worker struct {
  ID   int
  Name string
}

func (w Worker) GetID() int {
  return w.ID
}

func (w Worker) GetName() string {
  return w.Name
}

type Supervisor struct {
  ID   int
  Name string
}

func (s Supervisor) GetID() int {
  return s.ID
}

func (s Supervisor) GetName() string {
  return s.Name
}

type Employee interface {
  GetID() int
  GetName() string
}

type Department struct {
  Employees []Employee
}

func (d *Department) AddEmployee(e Employee) {
  d.Employees = append(d.Employees, e)
}

func (d *Department) GetEmployeeNames() (res []string) {
  for _, e := range d.Employees {
    res = append(res, e.GetName())
  }
  return
}

func (d *Department) GetEmployee(id int) Employee {
  for _, e := range d.Employees {
    if e.GetID() == id {
      return e
    }
  }
  return nil
}

func main() {
  dep := &amp;Department{}
  dep.AddEmployee(Worker{ID: 1, Name: &quot;John&quot;})
  dep.AddEmployee(Supervisor{ID: 2, Name: &quot;Jane&quot;})

  fmt.Println(dep.GetEmployeeNames())

  e := dep.GetEmployee(1)
  switch v := e.(type) {
  case Worker:
    fmt.Printf(&quot;found worker %+v\n&quot;, v)
  case Supervisor:
    fmt.Printf(&quot;found supervisor %+v\n&quot;, v)
  default:
    fmt.Printf(&quot;could not find an employee by id: %d\n&quot;, 1)
  }
}
</code></pre><p>این اصل وابستگی وارونگی را نشان می‌دهد، زیرا ساختار <code>Department</code> به‌جای یک پیاده‌سازی خاص (ساختار <code>Worker</code> یا <code>Supervisor</code>) به یک انتزاع (<code>Employee</code> interface) وابستگی دارد. این امر کد را انعطاف‌پذیرتر می‌کند و نگهداری آن را آسان‌تر می‌کند، زیرا تغییرات در اجرای workers و supervisors بر ساختار <code>Department</code> تأثیر نمی‌گذارد.</p><h3 id=977-طراحی-solid-در-go>9.7.7 طراحی SOLID در Go
<a class=anchor href=#977-%d8%b7%d8%b1%d8%a7%d8%ad%db%8c-solid-%d8%af%d8%b1-go>#</a></h3><p>برای جمع‌بندی، وقتی هر یک از اصول SOLID را به Go اعمال می‌کنیم، موارد قدرتمندی در مورد طراحی هستند، اما وقتی با هم به کاربرده می‌شوند، می‌توان گفت که یک ایده مرکزی دارند.</p><p>اصل مسئولیت واحد (Single Responsibility) شما را تشویق می‌کند تا توابع، انواع و متدها را در بسته‌هایی ساختار دهید که انسجام طبیعی دارند؛ تایپ‌ها با هم مرتبط هستند، توابع یک هدف واحد دارند.</p><p>اصل باز/بسته (Open / Closed) شما را تشویق می‌کند تا تایپ‌های ساده را با استفاده از جاسازی به انواع پیچیده‌تر ترکیب کنید.</p><p>اصل جایگزینی لیسکوف (Liskov Substitution) شما را تشویق می‌کند تا وابستگی‌ها بین بسته‌های خود را از نظر اینترفیس‌ها بیان کنید و نه فقط تایپ‌های concrete. با تعریف اینترفیس‌های کوچک، می‌توانیم مطمئن‌تر باشیم که پیاده‌سازی‌ها به طور کامل قرارداد خود را برآورده می‌کنند.</p><p>اصل جداسازی اینترفیس (Interface Substitution) این ایده را بیشتر جلو می‌برد و شما را تشویق می‌کند تا توابع و متدهایی را تعریف کنید که فقط به رفتاری که نیاز دارند وابسته هستند. اگر تابع شما فقط به یک پارامتر از نوع Interface با یک متد نیاز دارد، پس احتمال بیشتری دارد که این تابع فقط یک مسئولیت داشته باشد.</p><p>اصل وارونگی وابستگی (Dependency Inversion) شما را تشویق می‌کند که دانش چیزهایی که package شما به آن‌ها وابسته است را از زمان کامپایل - در Go این را با کاهش تعداد عبارات import استفاده شده توسط یک package خاص می‌بینیم - به زمان اجرا منتقل کنید.</p><p>اگر بخواهید این صحبت را خلاصه کنید، احتمالاً این خواهد بود: Interface‌ها به شما اجازه می‌دهند اصول SOLID را به برنامه‌های Go اعمال کنید.</p><p>زیرا Interface‌ها به برنامه‌نویسان Go اجازه می‌دهند تا توصیف کنند که package آن‌ها چه چیزی را فراهم می‌کند - نه اینکه چگونه این کار را انجام می‌دهد. این همه فقط یک روش دیگر برای گفتن &ldquo;decoupling&rdquo; بوده که در واقع هدف اصلی ما است، زیرا نرم‌افزاری که به صورت پیوستگی ضعیف ( loosely coupled) شده است نرم‌افزاری است که تغییر آن آسان‌تر است.</p><p>همانطور که Sandi Metz می‌گوید:</p><blockquote><p>طراحی هنر چیدمان کدی است که باید امروز کار کند و برای همیشه آسان تغییر کند.</p></blockquote><p>زیرا اگر Go قرار است زبانی باشد که شرکت‌ها برای بلندمدت در آن سرمایه‌گذاری کنند، نگهداری برنامه‌های Go، سهولت تغییر آن‌ها، عامل کلیدی در تصمیم آن‌ها خواهد بود.</p><h2 id=978-در-پایان>9.7.8 <strong>در پایان</strong>
<a class=anchor href=#978-%d8%af%d8%b1-%d9%be%d8%a7%db%8c%d8%a7%d9%86>#</a></h2><p>بیایید به سؤالی که این صحبت را با آن شروع کردم برگردیم؛ چند برنامه‌نویس Go در دنیا وجود دارد؟ این حدس من است:</p><p>تا سال 2020، 500000 توسعه‌دهنده Go وجود خواهد داشت.</p><ul><li>من</li></ul><p>نیم میلیون برنامه‌نویس Go با وقت خود چه خواهند کرد؟ خب، واضح است که آن‌ها مقدار زیادی کد Go خواهند نوشت و اگر صادق باشیم، همه آن خوب نخواهد بود و برخی کاملاً بد خواهند بود.</p><p>لطفا بدانید که من این را برای بی‌رحمی نمی‌گویم، اما هر یک از شما در این اتاق با تجربه توسعه در زبان‌های دیگر - زبان‌هایی که از آن‌ها به Go آمدید - از تجربه خود می‌دانید که این پیش‌بینی تا حدی درست است.</p><blockquote><p>درون ++C، یک زبان بسیار کوچکتر و تمیزتر در تلاش برای بیرون آمدن است.</p><ul><li>بیارنه استراوستراپ، طراحی و تکامل ++C</li></ul></blockquote><p>فرصت برای همه برنامه‌نویسان Go برای موفقیت زبان ما مستقیماً به توانایی جمعی ما در ایجاد چنین آشفتگی‌ای بستگی دارد که مردم شروع به صحبت کردن درباره Go به همان روشی کنند که امروز درباره ++C شوخی می‌کنند.</p><p>داستانی که زبان‌های دیگر را به دلیل بزرگ، پر حرفی و پیچیده بودن مورد تمسخر قرار می‌دهد، ممکن است روزی به سمت Go برگردد،و من نمی‌خواهم این اتفاق بیفتد، بنابراین درخواستی دارم.</p><p>برنامه‌نویسان Go باید کمتر در مورد فریمورک‌ها صحبت کنند و بیشتر در مورد طراحی صحبت کنند. باید تمرکز خود را از عملکرد به هر قیمتی متوقف کنیم و در عوض روی استفاده مجدد به هر قیمتی تمرکز کنیم.</p><p>من می‌خواهم ببینم مردم در مورد نحوه استفاده از زبانی که امروز داریم، صرف نظر از انتخاب‌ها و محدودیت‌های آن، برای طراحی راه‌حل‌ها و حل مشکلات واقعی صحبت می‌کنند.</p><p>من می‌خواهم بشنوم که مردم در مورد نحوه طراحی برنامه‌های Go به روشی که به خوبی مهندسی شده، جدا شده، قابل استفاده مجدد و از همه مهم‌تر پاسخگو به تغییر است صحبت می‌کنند.</p><p>&mldr; یک چیز دیگر</p><p>حالا، عالی است که بسیاری از شما امروز برای شنیدن از سخنرانان بزرگ اینجا هستید، اما واقعیت این است که صرف نظر از اینکه این کنفرانس چقدر بزرگ می‌شود، در مقایسه با تعداد افرادی که در طول عمر خود از Go استفاده خواهند کرد، ما فقط یک بخش کوچک هستیم.</p><p>بنابراین باید به بقیه دنیا بگوییم که نرم‌افزار خوب چگونه باید نوشته شود. نرم‌افزار خوب، نرم‌افزار قابل ترکیب، نرم‌افزاری که قابل تغییر است و به آن‌ها نشان دهیم که چگونه این کار را با استفاده از Go انجام دهند. و این کار از شما شروع می‌شود.</p><p>من می‌خواهم شما شروع به صحبت در مورد طراحی کنید، شاید از برخی ایده‌هایی که در اینجا ارائه کردم استفاده کنید، امیدوارم تحقیقات خود را انجام دهید و این ایده‌ها را در پروژه‌های خود اعمال کنید. سپس می‌خواهم شما:</p><p>یک پست وبلاگ در مورد آن بنویسید. یک کارگاه در مورد کاری که انجام دادید تدریس کنید. یک کتاب در مورد آنچه آموخته‌اید بنویسید. و سال آینده به این کنفرانس برگردید و در مورد آنچه به دست آوردید صحبت کنید.</p><p>زیرا با انجام این کارها می‌توانیم فرهنگی از توسعه‌دهندگان Go ایجاد کنیم که به برنامه‌هایی اهمیت می‌دهند که برای ماندگاری طراحی شده‌اند.</p><p>متشکرم.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/GoFarsi/book/edit/main/content/chapter%209/9.7-SOLID-principle.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt>
<span>این صفحه را ویرایش کنید</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script><div class="text-left page-navigation"><a href=/chapter-9/cloud-native-patterns/go-cloud-native-circuit-breaker-pattern/>9.5.1 الگو Circuit Breaker ◀︎</a></div><script>function toggleTooltip(e){e.classList.toggle("active")}</script><div id=graphcomment></div><script type=text/javascript>var __semio__params={graphcommentId:"book",behaviour:{}};function __semio__onload(){__semio__gc_graphlogin(__semio__params)}(function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.onload=__semio__onload,e.defer=!0,e.src="https://integration.graphcomment.com/gc_graphlogin.js?"+Date.now(),(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content></br><main><div class=wrapper><a href=https://t.me/GolangEngineers class="icon telegram" target=_blank><div class=tooltip>گروه تلگرامی مهندسین گولنگ</div><span><i class="fab fa-telegram"></i></span>
</a><a href=https://linkedin.com/in/Ja7ad class="icon linkedin" target=_blank><div class=tooltip>لینکدین نویسنده</div><span><i class="fab fa-linkedin"></i></span>
</a><a href=https://twitter.com/Ja7adR class="icon twitter" target=_blank><div class=tooltip>توییتر نویسنده</div><span><i class="fab fa-twitter"></i></span></a></div></main></br></br><nav id=TableOfContents><ul><li><ul><li><a href=#971-مقدمه>9.7.1 مقدمه</a><ul><li></li></ul></li><li><a href=#972--اصل-single-responsibility>9.7.2 اصل Single Responsibility</a><ul><li><a href=#9721-بررسی-coupling-و-cohesion>9.7.2.1 بررسی Coupling و Cohesion</a></li><li><a href=#9722-نام--packageها>9.7.2.2 نام Package‌ها</a></li><li><a href=#9723-نامهای-بد-package>9.7.2.3 نام‌های بد Package</a></li><li><a href=#9724-فلسفهی-یونیکس-در-go>9.7.2.4 فلسفه‌ی یونیکس در Go</a></li><li><a href=#9725-مثال-single-responsibility>9.7.2.5 مثال Single Responsibility</a></li></ul></li><li><a href=#973-اصل-open--closed>9.7.3 اصل Open / Closed</a><ul><li><a href=#9731-مثال--open--closed>9.7.3.1 مثال Open / Closed</a></li></ul></li><li><a href=#974-اصل--liskov-substitution>9.7.4 اصل Liskov Substitution</a><ul><li><a href=#9741-بررسی-interface-ها>9.7.4.1 بررسی Interface ها</a></li><li><a href=#9742--بررسی-ioreader>9.7.4.2 بررسی io.Reader</a></li><li><a href=#9743-مثال--liskov-substitution>9.7.4.3 مثال Liskov Substitution</a></li></ul></li><li><a href=#975-اصل--interface-segregation>9.7.5 اصل Interface Segregation</a><ul><li><a href=#9751-مثال-interface-segregation>9.7.5.1 مثال Interface Segregation:</a></li></ul></li><li><a href=#976-اصل-dependency-inversion>9.7.6 اصل Dependency Inversion</a><ul><li><a href=#9761-مثال>9.7.6.1 مثال</a></li><li><a href=#977-طراحی-solid-در-go>9.7.7 طراحی SOLID در Go</a></li></ul></li><li><a href=#978-در-پایان>9.7.8 <strong>در پایان</strong></a></li></ul></li></ul></nav></div></aside></main><button onclick=topFunction() id=myBtn title="رفتن به بالا" class="fas fa-solid fa-arrow-up"></button>
<script src=prism.js></script><script>document.getElementById("currentsv").innerHTML=window.location.href</script><script async>var html=document.documentElement,switcher=document.getElementsByClassName("js-toggle")[0];typeof Storage!="undefined"&&((localStorage.getItem("themeMode")=="dark"||document.documentElement.getAttribute("data-theme")=="dark")&&switcher.classList.add("js-toggle--checked"),switcher.classList.add("js-toggle--focus")),switcher.addEventListener("click",function(){this.classList.toggle("js-toggle--checked"),this.classList.add("js-toggle--focus"),this.classList.contains("js-toggle--checked")?(html.setAttribute("data-theme","dark"),localStorage.setItem("themeMode","dark")):(html.setAttribute("data-theme","light"),localStorage.setItem("themeMode","light"))})</script><script>let mybutton=document.getElementById("myBtn");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?mybutton.style.display="block":mybutton.style.display="none"}function topFunction(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script src=/js/playground.js defer></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-go.min.js></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/line-numbers/prism-line-numbers.min.js></script><script>"serviceWorker"in navigator&&window.addEventListener("DOMContentLoaded",function(){navigator.serviceWorker.register("/sw.js")})</script></body></html>