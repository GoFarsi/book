<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><author/><title>فصل پنجم: برنامه نویسی شبکه با گو on زبان گو فارسی</title><link>https://book.gofarsi.ir/chapter-5/</link><description>Recent content in فصل پنجم: برنامه نویسی شبکه با گو on زبان گو فارسی</description><generator>Hugo -- gohugo.io</generator><language>fa</language><copyright>2023 GoFarsi All rights reserved</copyright><atom:link href="https://book.gofarsi.ir/chapter-5/feed.xml" rel="self" type="application/rss+xml"/><item><author/><title>5.1 شبکه چیست</title><link>https://book.gofarsi.ir/chapter-5/network-basic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-5/network-basic/</guid><description>&lt;p>به تجهیزات متصل یکدیگر شبکه گفته می‌شود. مکانیزم‌های اتصال ممکن است از طریق سیم مسی، اترنت، فیبر نوری یا بی‌سیم. اندازه ی شبکه می تواند به اندازه ی اینترنت بزرگ یا به اندازه ی یک شبکه خانگی کوچک باشد. یک شبکه محلی (LAN) کامپیوترهایی را که در نزدیکی یکدیگر هستند، معمولاً تعلق به یک خانه، سازمان کوچک یا قسمتی از یک سازمان بزرگ دارند، به هم متصل می‌کند.&lt;/p>
&lt;p>یک شبکه گسترده (WAN) کامپیوترها را در یک منطقه فیزیکی بزرگتر، مانند بین شهرها متصل می‌کند. انواع دیگری هم وجود دارند، مانند MANs (شبکه‌های منطقه شهری)، PANs (شبکه‌های منطقه شخصی) و حتی BANs (شبکه‌های منطقه بدن).&lt;/p>
&lt;p>تفاوت‌های قابل توجهی بین یک اینترنت و یک اینترانت وجود دارد. معمولاً، یک اینترانت تحت کنترل مدیریت واحد قرار خواهد گرفت و یک مجموعه یکپارچه از سیاست‌ها را اعمال خواهد کرد. از طرفی، یک اینترنت تحت کنترل یک بدنه یکپارچه نخواهد بود و کنترل‌های انجام شده بر روی بخش‌های مختلف حتی سازگاری نخواهد داشت.&lt;/p>
&lt;h2 id="511-چند-تعریف-و-مفهوم-کلی-در-شبکه">
5.1.1 چند تعریف و مفهوم کلی در شبکه
&lt;a class="anchor" href="#511-%da%86%d9%86%d8%af-%d8%aa%d8%b9%d8%b1%db%8c%d9%81-%d9%88-%d9%85%d9%81%d9%87%d9%88%d9%85-%da%a9%d9%84%db%8c-%d8%af%d8%b1-%d8%b4%d8%a8%da%a9%d9%87">#&lt;/a>
&lt;/h2>
&lt;h3 id="5111-پروتکل">
5.1.1.1 پروتکل
&lt;a class="anchor" href="#5111-%d9%be%d8%b1%d9%88%d8%aa%da%a9%d9%84">#&lt;/a>
&lt;/h3>
&lt;p>پروتکل های شبکه مجموعه قواعد و روش هایی از پیش تعریف شده برای ارتباط دو کامپیوتر در یک شبکه هستند&lt;/p>
&lt;h3 id="5112-هسته-node">
5.1.1.2 هسته (node)
&lt;a class="anchor" href="#5112-%d9%87%d8%b3%d8%aa%d9%87-node">#&lt;/a>
&lt;/h3>
&lt;p>هر دستگاه متصل به شبکه یک نود به حساب می آید.&lt;/p>
&lt;h3 id="5113-پروتکل-اینترنت-ip">
5.1.1.3 پروتکل اینترنت IP
&lt;a class="anchor" href="#5113-%d9%be%d8%b1%d9%88%d8%aa%da%a9%d9%84-%d8%a7%db%8c%d9%86%d8%aa%d8%b1%d9%86%d8%aa-ip">#&lt;/a>
&lt;/h3>
&lt;p>پروتکل اینترنت یا (internet protocol) یک ادرس منحصر بفرد برای هر دستگاه متصل به اینترنت است
هر ایپی (v4) شامل چهار بخش یا octet است که هر بخش را عددی بین ۰ تا ۲۵۵ تشکیل می دهد&lt;/p>
&lt;h4 id="51131-ایپی-ورژن-۶">
5.1.1.3.1 ایپی ورژن ۶
&lt;a class="anchor" href="#51131-%d8%a7%db%8c%d9%be%db%8c-%d9%88%d8%b1%da%98%d9%86-%db%b6">#&lt;/a>
&lt;/h4>
&lt;p>زمان شروع و توسعه پروتکل اینترنت هر دستگاه در شبکه نیاز به یک شناسه منحصر به فرد داشت.
ایپی ورژن ۴ تنها قابلیت ایجاد 4 بیلیون شناسه یونیک را داشتند (که بنظر برای تمام دستگاه های موجود کافی و مناسب بود)
بعد از رشد چشم گیر اینترنت و دستگاه های متصل به اینترنت تعداد IP موجود حدودا کافی نبود
ایپی ورژن ۶ جدید ترین نسخه ایپی است که شمال 8 octet است و از hexadecimal استفاده میکند.
در نتیجه حدود 340 undecillion ایپی ورژن ۶ منحصر به فرد میتوان تولید کرد که برای عدد قابل توجهی دستگاه متصل به شبکه کافی است.
مثال ایپی ورژن ۶: ‍‍&lt;code>2001:0db8:85a3:0000:0000:8a2e:0370:7334&lt;/code>&lt;/p>
&lt;h4 id="51132-تفاوت-ها">
5.1.1.3.2 تفاوت ها
&lt;a class="anchor" href="#51132-%d8%aa%d9%81%d8%a7%d9%88%d8%aa-%d9%87%d8%a7">#&lt;/a>
&lt;/h4>
&lt;p>تفاوت های IPv4 and IPv6&lt;/p>
&lt;p>حافظه:&lt;/p>
&lt;ul>
&lt;li>ورژن ۴: ‍‍&lt;code>32bit&lt;/code>&lt;/li>
&lt;li>ورژن ۶:‍‍ ‍‍&lt;code>128bit&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>نوع ایپی:&lt;/p>
&lt;ul>
&lt;li>ورژن ۴ : ‍‍&lt;code>numeric dot-decimal&lt;/code>&lt;/li>
&lt;li>ورژن ۶ : &lt;code>alphanumeric hexadecimal&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>در نهایت گفتنی است که ورژن ۶ ایپی با استفاده از موارد امنیتی از جمله رمزنگاری و احراز هویت امنیت این پروتوکول را گسترش داده است.&lt;/p>
&lt;p>&lt;img src="https://upload.wikimedia.org/wikipedia/commons/3/39/Network_packet.jpg">&lt;/img>&lt;/p>
&lt;h2 id="512-لایه-های-پروتکل">
5.1.2 لایه های پروتکل
&lt;a class="anchor" href="#512-%d9%84%d8%a7%db%8c%d9%87-%d9%87%d8%a7%db%8c-%d9%be%d8%b1%d9%88%d8%aa%da%a9%d9%84">#&lt;/a>
&lt;/h2>
&lt;p>سیستم‌های توزیع شده دشوار هستند. چندین کامپیوتر درگیر هستند که باید به یکدیگر متصل شوند. برنامه‌ها برای اجرا بر روی هر کامپیوتر در سیستم باید نوشته شوند و همه باید با همکاری یک وظیفه توزیع شده را انجام دهند. روش رایج برای مقابله با پیچیدگی، تجزیه آن به بخش‌های کوچکتر و ساده‌تر است. این بخش‌ها ساختار خود را دارند، اما همچنین وسایل مشخصی برای ارتباط با بخش‌های مرتبط دیگر دارند. در سیستم‌های توزیع شده، بخش‌ها لایه پروتکل نامیده می‌شوند و وظایف دقیقی دارند. آن‌ها یک پشته را تشکیل می‌دهند، هر لایه با لایه بالایی و پایینی خود ارتباط برقرار می‌کند. ارتباط بین لایه‌ها توسط پروتکل‌ها تعریف می‌شود. ارتباطات شبکه نیازمند پروتکل‌هایی برای پوشش ارتباطات بالارونده بین برنامه‌های کاربردی تا ارتباطات سیم و پیچیدگی‌های پروتکلی در لایه‌های پروتکلی است.&lt;/p>
&lt;h3 id="5121-پروتکل-iso-osi">
5.1.2.1 پروتکل ISO OSI
&lt;a class="anchor" href="#5121-%d9%be%d8%b1%d9%88%d8%aa%da%a9%d9%84-iso-osi">#&lt;/a>
&lt;/h3>
&lt;p>اگرچه هرگز به درستی پیاده‌سازی نشده است، پروتکل‌های OSI (اتصالات باز سیستم‌ها) تأثیر بزرگی در روش‌های گفتگو و طراحی سیستم‌های توزیع شده داشته‌اند. معمولاً آن‌ها به شکلی نشان داده می‌شوند که در شکل زیر نشان داده شده است.&lt;/p>
&lt;center>&lt;a href="#">
&lt;img src="../../assets/img/content/chapter5/network/1.png" alt="Protocol ISO OSI">
&lt;/a>&lt;/center>
&lt;p>وظیفه هر لایه از پایین به بالا به شرح زیر است:&lt;/p>
&lt;ol>
&lt;li>لایه فیزیکی با استفاده از فناوری‌های الکتریکی، نوری یا رادیویی جریان بیت را منتقل می‌کند.&lt;/li>
&lt;li>لایه اتصال داده‌ها، بسته‌های اطلاعاتی را به فریم‌های شبکه تبدیل کرده و آن‌ها را برای انتقال از طریق لایه فیزیکی و بازگشت به بسته‌های اطلاعاتی آماده می‌کند.&lt;/li>
&lt;li>لایه شبکه فناوری‌های سوئیچینگ و روتینگ را فراهم می‌کند.&lt;/li>
&lt;li>لایه حمل و نقل انتقال شفاف داده بین سیستم‌های پایانی را فراهم می‌کند و مسئول بازیابی خطا در سراسر انتها به انتها و کنترل پایین است.&lt;/li>
&lt;li>لایه جلسه، ارتباطات بین برنامه‌ها را برقرار، مدیریت و پایان می‌دهد.&lt;/li>
&lt;li>لایه ارائه، استقلال را از تفاوت‌های در نمایش داده‌ها (مانند رمزگذاری) فراهم می‌کند.&lt;/li>
&lt;li>لایه برنامه، پردازش‌های برنامه و کاربران پایانی را پشتیبانی می‌کند.&lt;/li>
&lt;/ol>
&lt;p>یک لایه در مدل OSI معمولاً با یک پروتکل مدرن نقش مشابهی دارد؛ به عنوان مثال، پروتکل IP از TCP/IP با لایه شبکه، همچنین شناخته شده به عنوان لایه 3 (لایه فیزیکی لایه 1) مرتبط است. لایه برنامه، یعنی لایه 7، با HTTP مرتبط است. برخی از پروتکل‌ها مانند HTTPS به نظر می‌رسد لایه‌ها را با هم تلفیق می‌کنند، 5 (جلسه) و 6 (ارائه). هیچ مدلی کامل نیست؛ جایگزین‌هایی برای مدل OSI وجود دارد که به واقعیت مشخصی نزدیکتر هستند، مانند مدل پروتکل TCP/IP.&lt;/p>
&lt;h3 id="5122-پروتکل-tcpip">
5.1.2.2 پروتکل TCP/IP
&lt;a class="anchor" href="#5122-%d9%be%d8%b1%d9%88%d8%aa%da%a9%d9%84-tcpip">#&lt;/a>
&lt;/h3>
&lt;p>در حالی که مدل OSI در حال بحث و جدل، پیاده‌سازی جزئی، و جنگیدن بود، پروژه تحقیقاتی DARPA در اینترنت مشغول ساخت پروتکل‌های TCP/IP بود. این پروتکل‌ها بسیار موفق بوده و منجر به ایجاد اینترنت (با حروف بزرگ) شده است. این پشته بسیار ساده‌تر است، همانطور که در شکل زیر نشان داده شده است.&lt;/p>
&lt;center>&lt;a href="#">
&lt;img src="../../assets/img/content/chapter5/network/2.png" alt="The TCP/IP protocols">
&lt;/a>&lt;/center>
&lt;h3 id="5123-پروتکل-http">
5.1.2.3 پروتکل http
&lt;a class="anchor" href="#5123-%d9%be%d8%b1%d9%88%d8%aa%da%a9%d9%84-http">#&lt;/a>
&lt;/h3>
&lt;p>پروتکل http یکی از پرکابردترین و در دسترس ترین پروتکل های دنیا است.
تا حدی که شما با یک کلیک و باز کردن مروگر خود به آن درسترسی دارید.&lt;/p>
&lt;p>Http مخفف عبارت Hyper Text Transfer Protocol است که به معنی پروتکلی برای انتقال ابرمتن‌ها می‌باشد&lt;/p>
&lt;p>این پروتکل به منظور ایجاد صفحات وب انتقال ابر متن ها توسط تیم برنزلی طراحی و پیاده سازی شد.&lt;/p>
&lt;p>پروتکل Http از Handshaking به منظور ارسال و دریافت اطلاعات استفاده می‌کند. در این روش برای شروع و پایان عملیات تبادل اطلاعات بین سرور و کاربر چندین درخواست و پاسخ جابه جا میشود.&lt;/p>
&lt;h2 id="513-دروازه-gateways">
5.1.3 دروازه (Gateways)
&lt;a class="anchor" href="#513-%d8%af%d8%b1%d9%88%d8%a7%d8%b2%d9%87-gateways">#&lt;/a>
&lt;/h2>
&lt;p>یک دروازه (Gateway) یک عبارت کلی برای یک جسم است که برای اتصال دو یا چند شبکه استفاده می‌شود. یک تکرار کننده (Repeater) در سطح فیزیکی عمل کرده و اطلاعات را از یک زیرشبکه به دیگری کپی می‌کند. یک پل (Bridge) در سطح لایه داده‌ای عمل می‌کند و فریم‌ها را بین شبکه‌ها کپی می‌کند. یک مسیریاب (Router) در سطح شبکه عمل می‌کند و نه تنها اطلاعات را بین شبکه‌ها منتقل می‌کند، بلکه بر روی مسیر تصمیم می‌گیرد.&lt;/p>
&lt;p>دروازه یک نقطه واسط برای ارتباط بین دو شبکه است و معمولاً دروازه‌ها برای ارتباط بین شبکه‌های مختلفی با ساختار‌های مختلف استفاده می‌شوند. تکرار کننده اطلاعات را در سطح فیزیکی از یک شبکه به شبکه دیگر منتقل می‌کند. پل از طریق بررسی آدرس MAC در هر فریم، فریم‌ها را بین شبکه‌های مختلف انتقال می‌دهد. مسیریاب به عنوان یک دروازه هوشمند عمل می‌کند و برای انتقال بسته‌های داده بین شبکه‌های مختلف از پروتکل‌های مسیریابی مانند RIP، OSPF و BGP استفاده می‌کند. همچنین، مسیریاب‌ها مسیر بهینه برای انتقال بسته‌های داده را انتخاب می‌کنند و مسیریابی برای کنترل ترافیک شبکه مورد استفاده قرار می‌گیرد.&lt;/p>
&lt;h2 id="514-host-level-networking">
5.1.4 Host-Level Networking
&lt;a class="anchor" href="#514-host-level-networking">#&lt;/a>
&lt;/h2>
&lt;p>در شبکه مبتنی بر یک میزبان، ما دارای نگرانی‌های اضافی هستیم که در طراحی، اشکال زدایی و پیاده‌سازی نرم‌افزار مبتنی بر شبکه مورد استفاده قرار می‌گیرند. برخی از این موارد عبارتند از:&lt;/p>
&lt;ul>
&lt;li>DNS (نظام نام دامنه، به عنوان نام‌گذاری سازگار با انسان)&lt;/li>
&lt;li>Firewalls (مانند مسدود کردن ترافیک ورودی یا خروجی)&lt;/li>
&lt;li>Routing (به عنوان مثال، فهمیدن کدام شبکه برای قرار دادن یک بسته مناسب است)&lt;/li>
&lt;li>مدیریت هویت میزبان (به عنوان مثال، آدرس IP)&lt;/li>
&lt;li>کنترل عملکرد (به عنوان مثال، شکل دهی و یا تلاش مجدد برای ترافیک)&lt;/li>
&lt;li>مسائل اتصال (به عنوان مثال، عدم وجود آداپتور شبکه، ارتباطات داخلی پردازش درون‌ساختمانی)&lt;/li>
&lt;/ul>
&lt;p>در کل، طراحی، پیاده‌سازی و مدیریت شبکه در سطح میزبان به دلیل وجود این نگرانی‌های اضافی، بسیار پیچیده تر از طراحی، پیاده‌سازی و مدیریت شبکه در سطح شبکه به شمار می‌آید.&lt;/p>
&lt;h2 id="515-کپسوله-سازی-packet">
5.1.5 کپسوله سازی Packet
&lt;a class="anchor" href="#515-%da%a9%d9%be%d8%b3%d9%88%d9%84%d9%87-%d8%b3%d8%a7%d8%b2%db%8c-packet">#&lt;/a>
&lt;/h2>
&lt;p>در هرکدام از مدل OSI یا TCP/IP، ارتباط بین لایه‌ها با ارسال بسته‌های داده از یک لایه به لایه بعدی و در نهایت از طریق شبکه انجام می‌شود. هر لایه اطلاعات مدیریتی دارد که باید درباره لایه خود نگه داشته شود. برای این کار، هر لایه با اضافه کردن اطلاعات هدر به بسته‌ای که از لایه بالایی دریافت می‌کند، همانند یک لایه زیر، بسته را به لایه بعدی منتقل می‌کند. در سمت دریافت کننده، هدرهای این بسته‌ها با حرکت بسته به سمت لایه بالاتر حذف می‌شوند.&lt;br>
به عنوان مثال، پروتکل انتقال پرونده‌های ساده (TFTP) فایل‌ها را از یک کامپیوتر به کامپیوتر دیگری منتقل می‌کند. این پروتکل از پروتکل UDP روی پروتکل IP استفاده می‌کند که ممکن است از طریق اترنت ارسال شود. این به صورتی است که در شکل زیر نشان داده شده است.&lt;/p>
&lt;center>&lt;a href="#">
&lt;img src="../../assets/img/content/chapter5/network/3.png" alt="The TFTP (Trivial File Transfer Protocol)">
&lt;/a>&lt;/center>
&lt;h2 id="516-مدل-های-ارتباط">
5.1.6 مدل های ارتباط
&lt;a class="anchor" href="#516-%d9%85%d8%af%d9%84-%d9%87%d8%a7%db%8c-%d8%a7%d8%b1%d8%aa%d8%a8%d8%a7%d8%b7">#&lt;/a>
&lt;/h2>
&lt;p>برای دو کامپیوتر برای ارتباط با یکدیگر، آن‌ها باید یک مسیر راه‌اندازی کنند که امکان ارسال حداقل یک پیام در یک جلسه را برای آن‌ها فراهم کند. دو مدل اصلی برای این کار وجود دارد:&lt;/p>
&lt;h3 id="5161-مدل-مبتنی-بر-اتصال-connection-oriented">
5.1.6.1 مدل مبتنی بر اتصال (Connection Oriented)
&lt;a class="anchor" href="#5161-%d9%85%d8%af%d9%84-%d9%85%d8%a8%d8%aa%d9%86%db%8c-%d8%a8%d8%b1-%d8%a7%d8%aa%d8%b5%d8%a7%d9%84-connection-oriented">#&lt;/a>
&lt;/h3>
&lt;p>در این مدل، ابتدا یک اتصال بین دو کامپیوتر برقرار می‌شود و سپس داده‌ها در قالب یک جلسه انتقال می‌یابند. این مدل برای انتقال داده‌هایی که نیاز به اطمینان بالا و کیفیت خدمات دارند مفید است، به عنوان مثال، ارسال فایل‌های بزرگ، ارتباطات صوتی و تصویری، اتصال به اینترنت و غیره. پروتکل TCP مثالی از یک مدل مبتنی بر اتصال است.&lt;/p>
&lt;h3 id="5162-مدل-بدون-اتصال-connectionless">
5.1.6.2 مدل بدون اتصال (Connectionless)
&lt;a class="anchor" href="#5162-%d9%85%d8%af%d9%84-%d8%a8%d8%af%d9%88%d9%86-%d8%a7%d8%aa%d8%b5%d8%a7%d9%84-connectionless">#&lt;/a>
&lt;/h3>
&lt;p>در این مدل، هیچ اتصالی بین دو کامپیوتر برقرار نمی‌شود و هر بسته به صورت مستقل از دیگر بسته‌ها ارسال می‌شود. این مدل برای انتقال داده‌هایی که نیاز به سرعت بالا و حجم کمتری از اطلاعات دارند مفید است، به عنوان مثال، ارسال پیام‌های کوتاه، سرور های بازی، درخواست اطلاعات از یک سرور و غیره. پروتکل UDP مثالی از یک مدل بدون اتصال است.&lt;/p>
&lt;h2 id="517-مدل-های-ارتباطات">
5.1.7 مدل های ارتباطات
&lt;a class="anchor" href="#517-%d9%85%d8%af%d9%84-%d9%87%d8%a7%db%8c-%d8%a7%d8%b1%d8%aa%d8%a8%d8%a7%d8%b7%d8%a7%d8%aa">#&lt;/a>
&lt;/h2>
&lt;p>در یک سیستم توزیع‌شده، بسیاری از اجزا (یعنی فرآیندها) در حال اجرا هستند که باید با یکدیگر ارتباط برقرار کنند. دو مدل اصلی برای این کار وجود دارند: ارسال پیام و فراخوانی رویه‌های از راه دور (Remote Procedure Call).&lt;/p>
&lt;p>در زمینه شبکه‌ها، این مدل‌ها اجازه ارتباط بین فرآیندها (و/یا رشته‌ها) با هدف فراخوانی رفتار روی فرآیند از راه دور را می‌دهند.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>در مدل ارسال پیام، فرآیندها با یکدیگر به صورت غیرمستقیم و از طریق ارسال پیام‌هایی که شامل داده‌های خاصی هستند، ارتباط برقرار می‌کنند. این پیام‌ها ممکن است برای انتقال داده‌ها، درخواست خدمات، یا هر نوع ارتباطی بین فرآیندها استفاده شوند. این مدل برای سیستم‌هایی که ارتباطات غیرهمزمان، توزیع شده و یا برای ارتباطاتی که نیاز به پیچیدگی بیشتری دارند، مفید است.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>در مدل فراخوانی رویه‌های از راه دور، فرآیند فراخواننده یک رویه محلی را فراخوانی می‌کند که در فرآیند دیگری اجرا می‌شود. در این مدل، فرآیند فراخواننده به عنوان مشتری عمل می‌کند و فرآیند دیگر به عنوان سرور. درخواست‌های مشتری به صورت پیام‌هایی به سرور فرستاده می‌شود و سرور درخواست‌ها را پردازش می‌کند و نتیجه را به مشتری می‌فرستد. این مدل برای سیستم‌هایی که نیاز به ارتباطات همزمان و یا درخواست‌هایی که نیاز به پردازش پیچیده دارند، مفید است.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="5171-message-passing">
5.1.7.1 Message Passing
&lt;a class="anchor" href="#5171-message-passing">#&lt;/a>
&lt;/h3>
&lt;p>بعضی زبان‌ها بر اساس اصل ارسال پیام ساخته شده‌اند. زبان‌ها و ابزارهای همزمان از این مکانیزم استفاده می‌کنند و مثال شناخته شده‌ترین آن ممکن است خط لوله UNIX باشد. خط لوله UNIX یک خط لوله از بایت‌هاست، اما این یک محدودیت ذاتی نیست: PowerShell شرکت مایکروسافت می‌تواند اشیاء را از طریق خطوط لوله خود ارسال کند و زبان‌های همزمان مانند Parlog می‌توانند ساختارهای داده منطقی دلخواه را در پیام‌های بین فرآیندهای همزمان ارسال کنند. زبان‌های جدید مانند Go دارای مکانیزم‌هایی برای ارسال پیام (بین تردها) هستند.&lt;/p>
&lt;p>ارسال پیام یک مکانیزم اولیه برای سیستم‌های توزیع‌شده است. یک اتصال راه‌اندازی کرده و برخی از داده‌ها را از آن پمپ کنید. در سمت دیگر، پیام را تشخیص دهید و به آن پاسخ دهید، با احتمال ارسال پیام‌های بازگشتی. این در شکل زیر نشان داده شده است.&lt;/p>
&lt;center>&lt;a href="#">
&lt;img src="../../assets/img/content/chapter5/network/4.png" alt="The message passing communications model">
&lt;/a>&lt;/center>
&lt;p>سیستم‌های مبتنی بر رویداد نیز به همین شکل عمل می‌کنند. در سطح پایین، زبان برنامه‌نویسی Node.js یک حلقه رویداد اجرا می‌کند که منتظر رویدادهای ورود/خروج است، برای این رویدادها شیء‌های اجرایی را فراخوانی کرده و به آن‌ها پاسخ می‌دهد. در سطح بالاتر، اکثر سیستم‌های رابط کاربری از یک حلقه رویداد برای انتظار ورودی کاربر استفاده می‌کنند، در حالی که در دنیای شبکه، Ajax از &lt;strong>XMLHttpRequest&lt;/strong> برای ارسال و دریافت درخواست‌ها استفاده می‌کند.&lt;/p>
&lt;h3 id="5172-remote-procedure-call">
5.1.7.2 Remote Procedure Call
&lt;a class="anchor" href="#5172-remote-procedure-call">#&lt;/a>
&lt;/h3>
&lt;p>در هر سیستمی، انتقال اطلاعات و کنترل کم از یک بخش از سیستم به بخش دیگری اتفاق می‌افتد. در زبان‌های رویه‌ای، این ممکن است شامل فراخوانی رویه باشد، که در آن اطلاعات بر روی یک پشته فراخوانی قرار داده می‌شود و سپس کنترل به بخش دیگری از برنامه منتقل می‌شود. حتی با فراخوانی رویه، تفاوت‌هایی وجود دارد. کد ممکن است به طور استاتیک متصل شود تا کنترل از قسمتی از کد اجرایی برنامه به بخش دیگری از آن منتقل شود. به دلیل استفاده روزافزون از روتین‌های کتابخانه، معمول شده است کد را در شیء‌های به اشتراک گذاشته شده (.so) یا کتابخانه‌های پیوندی پویای (.dll) داشته باشیم، که کنترل به یک قطعه کد مستقل منتقل می‌شود.&lt;/p>
&lt;p>کتابخانه‌ها در همان ماشینی که کد فراخواننده در آن اجرا می‌شود، اجرا می‌شوند. این یک مرحله ساده (مفهومی) برای انتقال کنترل به یک رویه اجرا شده در ماشین دیگر (یعنی کتابخانه از راه دور) است. اما مکانیک این کار به این سادگی نیست! با این حال، این مدل کنترل باعث بروز فراخوانی رویه از راه دور (RPC) شده است که در یک فصل بعدی به طور جزئیات بیشتری بحث می‌شود. این در شکل زیر نشان داده شده است.&lt;/p>
&lt;center>&lt;a href="#">
&lt;img src="../../assets/img/content/chapter5/network/5.png" alt="The remote procedure call communications model">
&lt;/a>&lt;/center>
&lt;p>همانطور که گفته شد، بسیاری از مثال‌هایی که وجود دارد، بر اساس زبان‌های برنامه‌نویسی خاصی مانند بسته rpc Go یا سیستم‌های RPC پوشش دهی چندین زبان مانند SOAP و gRPC شرکت گوگل است.&lt;/p>
&lt;p>ممکن است مبهم باشد که چگونه ارسال پیام و RPC از هم متفاوت هستند. در یک سطح، هردو با فراخوانی رفتار &amp;ldquo;جای دیگری&amp;rdquo; مرتبط هستند. به طور کلی، RPC در مقایسه با ارسال پیام کمتر انتزاعی است (یعنی به نظر می‌رسد و به احساس فراخوانی روتین‌های معمولی شبیه است)، در حالی که در ارسال پیام ممکن است به سیستم صف‌های از راه دور فراخوانی شده باشیم. با این حال، در پشت صحنه، RPC نیز پیام‌ها را ارسال می‌کند.&lt;/p>
&lt;h3 id="5173-مدل-محاسبات-توزیع-شده-distributed-computing">
5.1.7.3 مدل محاسبات توزیع شده (Distributed Computing)
&lt;a class="anchor" href="#5173-%d9%85%d8%af%d9%84-%d9%85%d8%ad%d8%a7%d8%b3%d8%a8%d8%a7%d8%aa-%d8%aa%d9%88%d8%b2%db%8c%d8%b9-%d8%b4%d8%af%d9%87-distributed-computing">#&lt;/a>
&lt;/h3>
&lt;p>در سطح بالاتر، می‌توانیم معادل بودن یا عدم معادل بودن اجزای یک سیستم توزیع شده را مورد بررسی قرار دهیم. شاید رایج‌ترین حالت یک حالت نامتقارن باشد: یک مشتری درخواست‌های خود را به یک سرور ارسال می‌کند و سرور پاسخ می‌دهد. این یک سیستم client-server است.&lt;/p>
&lt;p>اگر هر دو اجزای سیستم معادل باشند، قادر به شروع کردن و پاسخ دادن به پیام‌ها باشند، آنگاه یک سیستم همتا به همتا داریم. توجه کنید که این یک طبقه‌بندی منطقی است: یک همتا ممکن است یک ابرکامپیوتر با ۱۶۰۰۰ هسته باشد؛ دیگری ممکن است یک تلفن همراه باشد. اما اگر هر دو می‌توانند به طور مشابه عمل کنند، آنگاه آن‌ها همتای یکدیگر هستند.&lt;/p>
&lt;center>&lt;a href="#">
&lt;img src="../../assets/img/content/chapter5/network/6.png" alt="Client-server vs. peer-to-peer systems">
&lt;/a>&lt;/center>
&lt;p>در مثال سیستم client-server، مرورگری که با یک سرور وب صحبت می‌کند، یک مثال است. مثالی از یک سیستم همتا به همتا، سیستم پایگاه داده است که داده‌ها در آن تکثیر می‌شوند و در هر دو همتا در دسترس هستند.&lt;/p>
&lt;p>ترکیب این سیستم‌ها باعث بوجود آمدن معماری‌های چند لایه می‌شود، که یکی از رایج‌ترین آن‌ها سه لایه است (یعنی ارائه -&amp;gt; برنامه -&amp;gt; داده یا مرورگر -&amp;gt; سرور وب -&amp;gt; پایگاه داده).&lt;/p>
&lt;h4 id="51731-سیستم-client-server">
5.1.7.3.1 سیستم client-server
&lt;a class="anchor" href="#51731-%d8%b3%db%8c%d8%b3%d8%aa%d9%85-client-server">#&lt;/a>
&lt;/h4>
&lt;p>به عکس زیر توجه کنید:&lt;/p>
&lt;center>&lt;a href="#">
&lt;img src="../../assets/img/content/chapter5/network/7.png" alt="The client-server system">
&lt;/a>&lt;/center>
&lt;p>در سیستم فوق ممکن است توسط یک توسعه‌دهنده که نیاز به شناخت اجزای یک سیستم دارد، داشته باشد. همچنین، کاربری که از یک مرورگر استفاده می‌کند، می‌داند که مرورگر در سیستمش اجرا می‌شود، اما با سرورهای دیگری در جای دیگری ارتباط برقرار می‌کند.&lt;/p>
&lt;p>نمودار قبلی شبیه به مدل OSI است که در ابتدای کتاب بحث شد. لایه‌های موجود در شکل فوق نیز اختیاری هستند؛ به عنوان مثال، می‌توانیم هم مشتری و هم سرور را روی یک پاره‌ای از سخت افزار نصب کنیم. قرار گرفتن روی همان ماشین به این معنی است که ما می‌توانیم برخی از لایه‌های مدل OSI را از جمله لایه ۱ (فیزیکی)، لایه ۲ (پیوند داده) و لایه ۳ (شبکه) را حذف کنیم. ما می‌گوییم &amp;ldquo;احتمالا&amp;rdquo;، زیرا این لایه‌ها هنوز ممکن است برای دلایل مختلفی از جمله همگنی ابزارها یا امنیت، مورد نیاز باشند.&lt;/p>
&lt;h4 id="51732-اپلیکیشن-client-server">
5.1.7.3.2 اپلیکیشن Client-Server
&lt;a class="anchor" href="#51732-%d8%a7%d9%be%d9%84%db%8c%da%a9%db%8c%d8%b4%d9%86-client-server">#&lt;/a>
&lt;/h4>
&lt;p>برخی از برنامه‌ها ممکن است به طور شفاف توزیع شده باشند، به طوری که کاربر نمی‌داند که آن توزیع شده است. کاربران دید خود را از سیستم خود مشاهده می‌کنند، همانطور که در شکل زیر نشان داده شده است.&lt;/p>
&lt;center>&lt;a href="#">
&lt;img src="../../assets/img/content/chapter5/network/8.png" alt="The user’s view of the system">
&lt;/a>&lt;/center>
&lt;p>برای عملکرد، هر دو اجزا باید نصب شده باشند. چقدر پیچیدگی برنامه باید شفاف باشد، به برنامه و استفاده آن بستگی دارد.&lt;/p>
&lt;h4 id="51733-سرور-توزیع-شده">
5.1.7.3.3 سرور توزیع شده
&lt;a class="anchor" href="#51733-%d8%b3%d8%b1%d9%88%d8%b1-%d8%aa%d9%88%d8%b2%db%8c%d8%b9-%d8%b4%d8%af%d9%87">#&lt;/a>
&lt;/h4>
&lt;p>یک سیستم client-server نیازمند پیچیدگی نیست. مدل ابتدایی، یک سیستم مشتری-سرور تکی است که در شکل زیر نشان داده شده است.&lt;/p>
&lt;center>&lt;a href="#">
&lt;img src="../../assets/img/content/chapter5/network/9.png" alt="The single-client, single-server system">
&lt;/a>&lt;/center>
&lt;p>اما می‌توانید چندین مشتری و یک سرور داشته باشید، همانطور که در شکل زیر نشان داده شده است.&lt;/p>
&lt;center>&lt;a href="#">
&lt;img src="../../assets/img/content/chapter5/network/10.png" alt="The multiple-clients, single-server system">
&lt;/a>&lt;/center>
&lt;p>در این سیستم، مستر درخواست‌ها را دریافت کرده و به جای اینکه خودش آن‌ها را یکی یکی پردازش کند، آن‌ها را به سرورهای دیگر برای پردازش ارسال می‌کند. این یک مدل رایج است زمانی که مشتریان همزمان ممکن است وجود داشته باشند.&lt;/p>
&lt;p>همچنین، می‌توانید یک مشتری و چندین سرور داشته باشید، همانطور که در شکل زیر نشان داده شده است.&lt;/p>
&lt;center>&lt;a href="#">
&lt;img src="../../assets/img/content/chapter5/network/11.png" alt="The single-client, multiple-servers system">
&lt;/a>&lt;/center>
&lt;p>این نوع سیستم بسیار رایج است زمانی که یک سرور باید به عنوان مشتری به سرورهای دیگر عمل کند، مانند یک سرور منطق تجاری که اطلاعات را از سرور پایگاه داده دریافت می‌کند. و البته، می‌تواند چندین مشتری با چندین سرور باشد.&lt;/p>
&lt;p>دوباره، این اجزا ممکن است روی یک سخت‌افزار فیزیکی قرار نگرفته باشند.&lt;/p></description></item><item><author/><title>5.2 سرور tcp مقدماتی</title><link>https://book.gofarsi.ir/chapter-5/go-tcp-server-begginer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-5/go-tcp-server-begginer/</guid><description>&lt;p>ما میتوانیم در گو با استفاده از کتابخانه net یک سرور &lt;a href="https://fa.wikipedia.org/wiki/%D9%BE%D8%B1%D9%88%D8%AA%DA%A9%D9%84_%D9%87%D8%AF%D8%A7%DB%8C%D8%AA_%D8%A7%D9%86%D8%AA%D9%82%D8%A7%D9%84">tcp&lt;/a> ایجاد کنیم
بعد از تکمیل شدن سرور با استفاده از دستور &lt;code>telnet&lt;/code> به آن متصل میشویم&lt;/p>
&lt;p>در قطعه کد زیر
با تابع &lt;code>acceptLoop()&lt;/code> درخواست های اتصال را مپذیریم
و با تابع &lt;code>readLoop()&lt;/code> پیام های اتصال را میخوانیم&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;fmt&amp;quot;
&amp;quot;log&amp;quot;
&amp;quot;net&amp;quot;
)
// ساختار هر پیام در سرور
type Message struct {
// ادرس ip ارسال کننده پیام
from string
// متن و محتوای پیام
payload []byte
}
// ساختار سرور
type Server struct {
// ادرس و یا پورت سرور
listenAddr string
// listener
ln net.Listener
// چنل پیام برای انتقال پیام های دریافتی از اتصال ها بین گوروتین ها
msgch chan Message
}
// ایجاد یک سرور جدید
func newServer(listenAddr string) *Server {
return &amp;amp;Server{
listenAddr: listenAddr,
msgch: make(chan Message, 10),
}
}
// شروع سرور و دریافت اتصال های جدید
func (s *Server) start() error {
// شروع سرور
ln, err := net.Listen(&amp;quot;tcp&amp;quot;, s.listenAddr)
if err != nil {
return err
}
// مقدار دهی listener
s.ln = ln
// با تابع acceptLoop اتصال های جدید به سرور را مدیریت میکنیم
// با استفاده از go هر اتصال را روی یک گوروتین مجزا مدیریت میکنیم
go s.acceptLoop()
return nil
}
// اینجا برای استاپ کردن سرور یک متد جدید تعریف میکنیم
func (s *Server) stop() {
if s.ln != nil {
s.ln.Close()
}
}
func (s *Server) acceptLoop() {
for {
// اتصال های موجود را تایید میکنیم متغییر conn را با اتصال مورد نظر مقدار دهی میکنیم
conn, err := s.ln.Accept()
if err != nil {
fmt.Println(&amp;quot;accept error:&amp;quot;, err)
continue
}
// با استفاده از این تابع مقادیر ارسال شده توسط اتصال را به چنل message میدهیم
go s.readLoop(conn)
}
}
func (s *Server) readLoop(conn net.Conn) {
defer conn.Close()
buf := make([]byte, 2048)
for {
// پیام ارسال شده توسط هر اتصال را به متغییر buf میدهیم
n, err := conn.Read(buf)
if err != nil {
fmt.Println(&amp;quot;read error:&amp;quot;, err)
continue
}
s.msgch &amp;lt;- Message{
// ادرس ip ارسال کننده پیام از نوع net.IP
from: conn.RemoteAddr().String(),
// متن پیام
payload: buf[:n],
}
// بعد از دریافت هر پیام یک پیام به عنوان پاسخ ارسال میکنیم
conn.Write([]byte(&amp;quot;your message recived!\n&amp;quot;))
}
}
func main() {
// ساخت سرور
server := newServer(&amp;quot;:3000&amp;quot;)
//start the server
if err := server.start(); err != nil {
log.Fetal(err)
}
go func() {
// در ازای هر پیام مقادیر آن را چاپ میکنیم
for msg := range server.msgch {
fmt.Printf(&amp;quot;recived new from connection(%s): %s\n&amp;quot;, msg.from, msg.payload)
}
}()
// Run an infinite loop to keep the program running
select {}
}
&lt;/code>&lt;/pre>
&lt;p>بعد از پایان پیاده سازی سرور tcp
با دستور زیر سرور خود را اجرا میکنیم:
&lt;code>go run main.go&lt;/code>&lt;/p>
&lt;p>و با دستور زیر در یک ترمینال مجزا به سرور متصل میشویم:
&lt;code>telnet localhost 3000&lt;/code>&lt;/p>
&lt;p>حال با نوشتن پیام و ارسال آن در ترمینال &lt;code>telnet&lt;/code> متن پیام و ادرس اتصال در ترمینال سرور قابل مشاهده است.&lt;/p>
&lt;p>توجه داشته باشید که دستور ‍&lt;code>telnet&lt;/code> در ویندوز نیاز به فعال سازی دارد.&lt;/p></description></item><item><author/><title>5.3 سرور tcp پیشرفته</title><link>https://book.gofarsi.ir/chapter-5/go-tcp-server-advanced/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-5/go-tcp-server-advanced/</guid><description>&lt;p>در این قسمت به طراحی و ساخت یک سرور tcp بصورت پیشرفته میپردازیم.
در قسمت قبل بعد از ایجاد سرور TCP ساده با استفاده از کلاینت telnet به آن متصل شدیم و دیتایی را انتقال دادیم.&lt;/p>
&lt;p>در این قسمت یک سرور tcp را با هدف انتقال فایل های &lt;span class="tooltip" data-tooltip="large file" ontouchend="toggleTooltip(this)">حجیم&lt;/span>
بصورت &lt;span class="tooltip" data-tooltip="stream" ontouchend="toggleTooltip(this)">جریان&lt;/span>
ایجاد میکنم.&lt;/p>
&lt;p>قبل از شروع ایجاد سرور خود به دلیل اینکه چرا فایل های حجیم را استریم میکنیم و یا اصلا استریم چیست میپردازیم.
زمانی که شما فایل های کم حجم را مستقیما انتقال میدهید با تاخیر کم و بصورت مطلوب انجام میشود.
اما روایت برای فایل های سنگین تر متفاوت است، اگر این عمل بصورت مستقیم و یکجا انجام شود باعث ایجاد تاخیر و مصرف منابع بیش از حد روی سرور میشود.
اما ما با استفاده از روش استریم، داده و فایل خود را بصورت &lt;span class="tooltip" data-tooltip="chunk file" ontouchend="toggleTooltip(this)">قطعه&lt;/span>
های کم حجم و پشت سر هم ارسال میکنیم.&lt;/p>
&lt;p>در ادامه به پیاده سازی سرور خود با استفاده از پروتکل tcp میپردازیم:&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;bytes&amp;quot;
&amp;quot;crypto/rand&amp;quot;
&amp;quot;encoding/binary&amp;quot;
&amp;quot;fmt&amp;quot;
&amp;quot;io&amp;quot;
&amp;quot;log&amp;quot;
&amp;quot;net&amp;quot;
&amp;quot;time&amp;quot;
)
type FileServer struct { }
func (fs *FileServer) start() {
ln, err := net.Listen(&amp;quot;tcp&amp;quot;, &amp;quot;0.0.0.0:3000&amp;quot;)
if err != nil {
panic(err)
}
for {
conn, err := ln.Accept()
if err != nil {
log.Fatal(err)
continue
}
fmt.Printf(&amp;quot;new connection: %s\n&amp;quot;, conn.RemoteAddr().String())
// read data from accepted connections
go fs.readLoop(conn)
}
}
func (fs *FileServer) readLoop(conn net.Conn) {
// make a new buffer
buf := new(bytes.Buffer)
for {
var size int64
// get the size from connection
binary.Read(conn, binary.LittleEndian, &amp;amp;size)
// copy from connection until the end of file
n, err := io.CopyN(buf, conn, size)
if err != nil {
log.Fatal(err)
continue
}
fmt.Println(buf.Bytes())
fmt.Printf(&amp;quot;received %d bytes over the network\n&amp;quot;, n)
}
}
func main() {
go func () {
time.Sleep(4 * time.Second)
// set your file szie
sendFile(2000000)
}()
s := &amp;amp;FileServer{}
s.start()
}
// client example that send a large file to server!
func sendFile(size int) error {
file := make([]byte, size)
// make a random file from the size provided
_, err := io.ReadFull(rand.Reader, file)
if err != nil {
return err
}
// dial with the tcp server (you can do this is an other file)
conn, err := net.Dial(&amp;quot;tcp&amp;quot;, &amp;quot;:3000&amp;quot;)
if err != nil {
return err
}
// send the size of file
binary.Write(conn, binary.LittleEndian, int64(size))
// copy file over the network until the end of file
n, err := io.CopyN(conn, bytes.NewReader(file), int64(size))
if err != nil {
return err
}
fmt.Printf(&amp;quot;written %d byte over the network\n&amp;quot;, n)
return nil
}
&lt;/code>&lt;/pre>
&lt;p>بعد از پایان نوشتن کد شما میتوانید با اجرا کردن کد خود (ترجیحا انتخاب یک عدد بزرگ برای حجم فایل یا همان ورودی تابع sendFile) میتوانید استریم شدن بایت هارا بصورت چانک چانک در لاگ های سمت سرور ببینید.&lt;/p></description></item><item><author/><title>5.4 سرور udp مقدماتی</title><link>https://book.gofarsi.ir/chapter-5/go-udp-server-begginer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-5/go-udp-server-begginer/</guid><description>&lt;p>در این قسمت به طراحی و ساخت یک سرور UDP مقدماتی با گولنگ می پردازیم.&lt;/p>
&lt;h2 id="541-معرفی-udp">
5.4.1 معرفی UDP
&lt;a class="anchor" href="#541-%d9%85%d8%b9%d8%b1%d9%81%db%8c-udp">#&lt;/a>
&lt;/h2>
&lt;p>پروتکل(User Datagram Protocol)
یک پروتکل &lt;span class="tooltip" data-tooltip="connectionless" ontouchend="toggleTooltip(this)">فاقد اتصال&lt;/span>
است.
به این معنا که &lt;span class="tooltip" data-tooltip="packet" ontouchend="toggleTooltip(this)">بسته&lt;/span>
های این پروتکل بدون اتصال قبلی و بررسی اینکه ایا همه بسته ها به درستی ارسال شده اند به دستگاه مورد نظر ارسال میشود.
به همین دلیل سرعت در این پروتکل از پروتکل tcp پایین تر است اما تظمین ارسال کامل و سالم داده وجود ندارد.
از موارد استفاده این پروتکل میتوان سرور بازی های انلاین را مثال زد.&lt;/p>
&lt;h2 id="542-پیاده-سازی">
5.4.2 پیاده سازی
&lt;a class="anchor" href="#542-%d9%be%db%8c%d8%a7%d8%af%d9%87-%d8%b3%d8%a7%d8%b2%db%8c">#&lt;/a>
&lt;/h2>
&lt;p>برای پیاده سازی یک سرور udp در گولنگ و اتصال به آن همچنان از کتابخانه net استفاده میکنیم.&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;fmt&amp;quot;
&amp;quot;net&amp;quot;
&amp;quot;strings&amp;quot;
)
func main() {
// ادرس IP و پورت مورد نظر را برای گوش سپردن به پکت های UDP مشخص میکنیم (مقدار بازگشتی این تابع اتصال ما است که قابلیت نوشتن و خواندن آن را داریم)
conn, err := net.ListenUDP(&amp;quot;udp&amp;quot;, &amp;amp;net.UDPAddr{
Port: 3000,
IP: net.ParseIP(&amp;quot;0.0.0.0&amp;quot;),
})
if err != nil {
panic(err)
}
defer conn.Close()
fmt.Printf(&amp;quot;server listening %s\n&amp;quot;, conn.LocalAddr().String())
for {
message := make([]byte, 20)
// تمام پیام های نوشته شده (ارسال شده) را میخوانیم
// متغییر message را با مقدار ارسال شده پر میکنیم (مقدار های بازگشتی این تابع طول پیام و آدرس ریموت ارسال کننده است)
readLen, remote, err := conn.ReadFromUDP(message[:])
if err != nil {
panic(err)
}
// متن پیام را تا قسمت خوانده شده به string تبدیل میکنیم
data := strings.TrimSpace(string(message[:readLen]))
// داده خروجی را چاپ میکنیم
fmt.Printf(&amp;quot;received: %s from %s\n&amp;quot;, data, remote)
}
}
&lt;/code>&lt;/pre>
&lt;p>بعد از انجام مراحل بالا با دستور ‍&lt;code>go run main.go&lt;/code> کد خود را اجرا میکنیم.&lt;/p>
&lt;h2 id="543-کد-کلاینت-برای-اتصال-به-سرور-ساخته-شده">
5.4.3 کد کلاینت برای اتصال به سرور ساخته شده
&lt;a class="anchor" href="#543-%da%a9%d8%af-%da%a9%d9%84%d8%a7%db%8c%d9%86%d8%aa-%d8%a8%d8%b1%d8%a7%db%8c-%d8%a7%d8%aa%d8%b5%d8%a7%d9%84-%d8%a8%d9%87-%d8%b3%d8%b1%d9%88%d8%b1-%d8%b3%d8%a7%d8%ae%d8%aa%d9%87-%d8%b4%d8%af%d9%87">#&lt;/a>
&lt;/h2>
&lt;p>اکنون با چند خط کد در زبان گولنگ به سرور خود متصل میشویم پیامی را به آن ارسال میکنیم&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import &amp;quot;net&amp;quot;
func main() {
// یک اتصال به سرور ایجاد میکنیم
Conn, _ := net.DialUDP(&amp;quot;udp&amp;quot;, nil, &amp;amp;net.UDPAddr{IP:[]byte{127,0,0,1},Port:3000,Zone:&amp;quot;&amp;quot;})
defer Conn.Close()
// متن زیر را به سرور ارسال میکنیم
Conn.Write([]byte(&amp;quot;hello, gofarsi!&amp;quot;))
}
&lt;/code>&lt;/pre>
&lt;p>اکنون همزمان با اجرا بودن کد سرور این قطعه کد را با دستور
‍‍&lt;code>go run client.go&lt;/code>
اجرا میکنیم (بسته به اسمی که برای فایل انتخاب کرده اید)&lt;/p>
&lt;p>خروجی در کنسول کد سرور به این صورت خواهد بود:
&lt;code>received: hello, gofarsi! from 127.0.0.1:54960&lt;/code>&lt;/p></description></item><item><author/><title>5.5 سرور udp پیشرفته</title><link>https://book.gofarsi.ir/chapter-5/go-udp-server-advanced/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-5/go-udp-server-advanced/</guid><description>&lt;p>در قسمت قبل به ایجاد یک سرور udp ساده و ارسال پکت به آن پرداختیم.
در این قسمت با استفاده از یک سرور و کلاینت udp یک پیام رسان بصورت feed میسازیم.
عملکرد سرور و کلاینت:
یک سرور udp ایجاد میکنیم که تمام کانکشن های موجود را ذخیره میکند و به محض دریافت پیام از هر یک از کانکشن ها پیام را برای تمام کانکشن های دیگر بجر کانکشن ارسال کننده پیام ارسال میکند.&lt;/p>
&lt;p>در مرحله اول سروری که کانکشن ها و ارسال پیام را مدیریت میکنید مینویسیم:&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;fmt&amp;quot;
&amp;quot;net&amp;quot;
)
func main() {
// Set up the server
addr := net.UDPAddr{
Port: 8000,
IP: net.ParseIP(&amp;quot;0.0.0.0&amp;quot;),
}
conn, err := net.ListenUDP(&amp;quot;udp&amp;quot;, &amp;amp;addr)
if err != nil {
fmt.Println(&amp;quot;Error listening:&amp;quot;, err)
return
}
defer conn.Close()
fmt.Println(&amp;quot;Server started on port&amp;quot;, addr.Port)
// Listen for incoming messages
buffer := make([]byte, 1024)
clients := make(map[string]*net.UDPAddr)
for {
n, clientAddr, err := conn.ReadFromUDP(buffer)
if err != nil {
fmt.Println(&amp;quot;Error reading:&amp;quot;, err)
continue
}
// Add new client
if _, ok := clients[clientAddr.String()]; !ok {
clients[clientAddr.String()] = clientAddr
fmt.Println(&amp;quot;New client joined:&amp;quot;, clientAddr.String())
}
// Broadcast message to all clients
message := buffer[:n]
for _, addr := range clients {
if addr.String() != clientAddr.String() {
_, err = conn.WriteToUDP(message, addr)
if err != nil {
fmt.Println(&amp;quot;Error broadcasting message:&amp;quot;, err)
}
}
}
}
}
&lt;/code>&lt;/pre>
&lt;p>در این قسمت یک سرور udp ایجاد کرده ایم و هر کانکشن جدید را به لیست کانکشن های خود اضافه میکنیم.
همچنین در ازای هر پیام دریافتی از سمت کانکشن ها آن را برای کانکشن های دیگر ارسال میکنیم.&lt;/p>
&lt;p>در ادامه یک کلاینت ساده برای سرور خود مینویسیم که پیام هارا نمایش دهد و متن ورودی در ترمینال را به سرور ارسال کند.&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;bufio&amp;quot;
&amp;quot;fmt&amp;quot;
&amp;quot;net&amp;quot;
&amp;quot;os&amp;quot;
)
func main() {
// Set up connection to the server
conn, err := net.Dial(&amp;quot;udp&amp;quot;, &amp;quot;localhost:8000&amp;quot;)
if err != nil {
fmt.Println(&amp;quot;Error connecting:&amp;quot;, err)
return
}
defer conn.Close()
go func() {
for {
buf := make([]byte, 1024) // buffer for incoming message
n, err := conn.Read(buf)
if err != nil {
fmt.Println(&amp;quot;Error receiving message:&amp;quot;, err)
continue
}
fmt.Printf(&amp;quot;Received message: %s\n&amp;quot;, string(buf[:n]))
}
}()
// Read input from terminal and send to server
scanner := bufio.NewScanner(os.Stdin)
for {
// send messages to server
fmt.Print(&amp;quot;Enter message: &amp;quot;)
if !scanner.Scan() {
break
}
message := scanner.Text()
_, err = conn.Write([]byte(message))
if err != nil {
fmt.Println(&amp;quot;Error sending message:&amp;quot;, err)
continue
}
}
}
&lt;/code>&lt;/pre>
&lt;p>در این کد ما تمام پیام های دریافتی از سرور را چاپ میکنیم و هر پیامی که کاربر در ترمینال وارد کند را به سرور ارسال میکنیم.&lt;/p>
&lt;p>بعد از اتمام کار برای تست کد خود سه ترمینال مجزا بار میکنیم.
و در یکی از سرور ها فایل &lt;code>server.go&lt;/code> و در دو ترمینال دیگر فایل &lt;code>client.go&lt;/code> را اجرا میکنیم.&lt;/p>
&lt;p>هر پیامی که توسط هر کلاینتی ارسال شود برای دیگر کلاینت ها قابل مشاهده است.&lt;/p>
&lt;p>توجه کنید اسم فایل ها بر اساس اسم انتخابی شما است.
همچنین توجه داشته باشید که شما میتوانید هر تعداد دلخواهی کلاینت را اجرا کنید.&lt;/p></description></item><item><author/><title>5.6 کتابخانه http سمت سرور مقدماتی</title><link>https://book.gofarsi.ir/chapter-5/go-http-server-begginer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-5/go-http-server-begginer/</guid><description>&lt;p>یکی از قابلیت های زبان گو این است که می توان با استفاده از کتابخانه http داخلی گو استفاده کرده و وب سرور پیاده سازی کرد.&lt;/p>
&lt;p>برای پیاده سازی یک وب سرور حداقل به 3 چیز نیاز داریم: 1) مسیر 2) درگاه وب سرور 3) مقدار برگشتی&lt;/p>
&lt;p>مسیر: عبارت است از URL منحصر به فرد برای ارسال و دریافت اطلاعات ورودی&lt;/p>
&lt;p>درگاه وب سرور: هر وب سرور نیاز دارد که درگاه (Port) خاصی را در اختیار داشته باشد و همواره به آن درگاه گوش بسپارد.&lt;/p>
&lt;p>مقدار برگشتی: هرگاه کاربر به مسیری وارد میشود یا اطلاعاتی را برای وب سرور ارسال میکند، مقداری از سمت سرور برای کاربر ارسال میشود.&lt;/p>
&lt;p>یک نمونه وب سرور در گو&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;fmt&amp;quot;
&amp;quot;net/http&amp;quot;
)
func main() {
// مسیر / یا root را برای این تابع انتخاب میکنیم (کد این تابع با صدا شدن مسیر localhost:3000 اجرا می شود)
http.HandleFunc(&amp;quot;/&amp;quot;, func(writer http.ResponseWriter, request *http.Request) {
// مقدار hello world را در مسیر مشخص شده برمیگردانیم
_, err := fmt.Fprint(writer, &amp;quot;&amp;lt;h1&amp;gt;Hellow World!&amp;lt;/h1&amp;gt;&amp;quot;)
if err != nil {
return
}
})
fmt.Println(&amp;quot;Starting The Server on :3000...&amp;quot;)
// به درخواست های ارسال شده به پورت 3000 با پروتوکول http گوش میکنیم (سرور در انتظار درخواست از سمت کاربر یا client) می ماند
err := http.ListenAndServe(&amp;quot;:3000&amp;quot;, nil)
if err != nil {
return
}
}
&lt;/code>&lt;/pre>
&lt;p>با وارد شدن به آدرس &lt;code>localhost:3000&lt;/code> مقدار برگشته شده در ‍&lt;code>handleFunc&lt;/code> را مشاهده خواهید کرد.&lt;/p></description></item><item><author/><title>5.7 کتابخانه http سمت سرور پیشرفته</title><link>https://book.gofarsi.ir/chapter-5/go-http-server-advanced/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-5/go-http-server-advanced/</guid><description>&lt;p>در قسمت قبل با استفاده از کتابخانه &lt;code>net/http&lt;/code> یک api ساده ایجاد کردیم.&lt;/p>
&lt;p>در این قسمت به پیاده سازی یک سرور http برای مدیریت لیست TODO های خود میپردازیم و از چهار متد GET, POST, DELET and PATCH استفاده میکنیم.&lt;/p>
&lt;p>در این پروژه از دیتابیس استفاده نمیشود. روش ذخیره سازی اطلاعات درون متغییر هاست دلیل استفاده نکردن از یک دیتابیس تمرکز این قسمت روی کتابخانه و پروتکل http است.&lt;/p>
&lt;p>در ادامه به ایجاد سرور خود میپردازیم.&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;encoding/json&amp;quot;
&amp;quot;fmt&amp;quot;
&amp;quot;log&amp;quot;
&amp;quot;net/http&amp;quot;
)
// todo struct with json tags
type Todo struct {
ID int `json:&amp;quot;id&amp;quot;`
Title string `json:&amp;quot;title&amp;quot;`
Status bool `json:&amp;quot;status&amp;quot;`
}
// just work as a DB for us!
var todos []Todo
// get all the items in the Todo list and write it. GET
func getTodos(w http.ResponseWriter, r *http.Request) {
w.Header().Set(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json&amp;quot;)
json.NewEncoder(w).Encode(todos)
}
// append a new data in array. POST
func addTodo(w http.ResponseWriter, r *http.Request) {
w.Header().Set(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json&amp;quot;)
var todo Todo
json.NewDecoder(r.Body).Decode(&amp;amp;todo)
// NOTE: this isn't a good way to set ids in production!
todo.ID = len(todos) + 1
todos = append(todos, todo)
json.NewEncoder(w).Encode(todo)
}
// change the todo status. PATCH
func updateTodo(w http.ResponseWriter, r *http.Request) {
w.Header().Set(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json&amp;quot;)
var todo Todo
json.NewDecoder(r.Body).Decode(&amp;amp;todo)
for i, t := range todos {
if t.ID == todo.ID {
todos[i].Status = todo.Status
json.NewEncoder(w).Encode(todos[i])
return
}
}
w.WriteHeader(http.StatusNotFound)
json.NewEncoder(w).Encode(map[string]string{&amp;quot;message&amp;quot;: &amp;quot;TODO not found&amp;quot;})
}
// remove the TODO from array. DELETE
func deleteTodo(w http.ResponseWriter, r *http.Request) {
w.Header().Set(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json&amp;quot;)
var todo Todo
json.NewDecoder(r.Body).Decode(&amp;amp;todo)
for i, t := range todos {
if t.ID == todo.ID {
todos = append(todos[:i], todos[i+1:]...)
json.NewEncoder(w).Encode(map[string]string{&amp;quot;message&amp;quot;: &amp;quot;TODO deleted&amp;quot;})
return
}
}
w.WriteHeader(http.StatusNotFound)
json.NewEncoder(w).Encode(map[string]string{&amp;quot;message&amp;quot;: &amp;quot;TODO not found&amp;quot;})
}
func main() {
// set routes
http.HandleFunc(&amp;quot;/todos&amp;quot;, getTodos)
http.HandleFunc(&amp;quot;/todos/add&amp;quot;, addTodo)
http.HandleFunc(&amp;quot;/todos/update&amp;quot;, updateTodo)
http.HandleFunc(&amp;quot;/todos/delete&amp;quot;, deleteTodo)
// start server
fmt.Println(&amp;quot;Server starting at port 8080&amp;quot;)
log.Fatal(http.ListenAndServe(&amp;quot;:8080&amp;quot;, nil))
}
&lt;/code>&lt;/pre>
&lt;p>بعد از اتمام نوشتن سرور با استفاده از یک کلاینت &lt;code>http&lt;/code> مثل postman سرور خود را به روش زیر تست میکنیم:&lt;/p>
&lt;p>نکته: شما می توانید کلاینت خود را خودتان با استفاده از اموزش کلاینت http در قسمت های دیگر بنویسید!&lt;/p>
&lt;h3 id="add-todo">
add todo
&lt;a class="anchor" href="#add-todo">#&lt;/a>
&lt;/h3>
&lt;p>endpoint: &lt;code>localhost:8080/todos/add&lt;/code>&lt;/p>
&lt;p>method:&lt;code>POST&lt;/code>&lt;/p>
&lt;p>request:&lt;/p>
&lt;pre>&lt;code class="language-json">{
&amp;quot;title&amp;quot;:&amp;quot;todo1 test&amp;quot;
}
&lt;/code>&lt;/pre>
&lt;p>response:&lt;/p>
&lt;pre>&lt;code class="language-json">{
&amp;quot;id&amp;quot;: 1,
&amp;quot;title&amp;quot;: &amp;quot;todo1 test&amp;quot;,
&amp;quot;status&amp;quot;: false
}
&lt;/code>&lt;/pre>
&lt;h3 id="get-todos">
get todo&amp;rsquo;s
&lt;a class="anchor" href="#get-todos">#&lt;/a>
&lt;/h3>
&lt;p>endpoint: &lt;code>localhost:8080/todos&lt;/code>&lt;/p>
&lt;p>method:&lt;code>GET&lt;/code>&lt;/p>
&lt;p>request:&lt;/p>
&lt;pre>&lt;code class="language-json">&lt;/code>&lt;/pre>
&lt;p>response:&lt;/p>
&lt;pre>&lt;code class="language-json">[
{
&amp;quot;id&amp;quot;: 1,
&amp;quot;title&amp;quot;: &amp;quot;todo1 test&amp;quot;,
&amp;quot;status&amp;quot;: false
},
//...
]
&lt;/code>&lt;/pre>
&lt;h3 id="update-todo">
update todo
&lt;a class="anchor" href="#update-todo">#&lt;/a>
&lt;/h3>
&lt;p>endpoint: &lt;code>localhost:8080/todos/update&lt;/code>&lt;/p>
&lt;p>method:&lt;code>PATCH&lt;/code>&lt;/p>
&lt;p>request:&lt;/p>
&lt;pre>&lt;code class="language-json">{
&amp;quot;id&amp;quot;:1,
&amp;quot;status&amp;quot;:true
}
&lt;/code>&lt;/pre>
&lt;p>response:&lt;/p>
&lt;pre>&lt;code class="language-json">{
&amp;quot;id&amp;quot;: 1,
&amp;quot;title&amp;quot;: &amp;quot;todo1 test&amp;quot;,
&amp;quot;status&amp;quot;: true
}
&lt;/code>&lt;/pre>
&lt;h3 id="delete-todo">
delete todo
&lt;a class="anchor" href="#delete-todo">#&lt;/a>
&lt;/h3>
&lt;p>endpoint: &lt;code>localhost:8080/todos/delete&lt;/code>&lt;/p>
&lt;p>method:&lt;code>DELETE&lt;/code>&lt;/p>
&lt;p>request:&lt;/p>
&lt;pre>&lt;code class="language-json">{
&amp;quot;id&amp;quot;:1
}
&lt;/code>&lt;/pre>
&lt;p>response:&lt;/p>
&lt;pre>&lt;code class="language-json">{
&amp;quot;message&amp;quot;: &amp;quot;TODO deleted&amp;quot;
}
&lt;/code>&lt;/pre></description></item><item><author/><title>5.8 کتابخانه http سمت کلاینت مقدماتی</title><link>https://book.gofarsi.ir/chapter-5/go-http-client-begginer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-5/go-http-client-begginer/</guid><description>&lt;p>برای ایجاد کلاینت http در گولنگ نیاز به کتابخانه &lt;code>net/http&lt;/code> داریم.
قبل از شروع به نوشتن کلاینت خود چند مفهوم کلی راه بررسی میکنیم.&lt;/p>
&lt;h2 id="581-سرور">
5.8.1 سرور
&lt;a class="anchor" href="#581-%d8%b3%d8%b1%d9%88%d8%b1">#&lt;/a>
&lt;/h2>
&lt;p>همانطور که میدانیم سرور های http برای تعریف مسیر ها منطق سرور و دریافت درخواست ها طراحی و ساخته میشوند.
(در قسمت های قبل ایجاد سرور http بصورت کامل یادگرفتیم)&lt;/p>
&lt;h2 id="582-کلاینت">
5.8.2 کلاینت
&lt;a class="anchor" href="#582-%da%a9%d9%84%d8%a7%db%8c%d9%86%d8%aa">#&lt;/a>
&lt;/h2>
&lt;p>کلاینت های در پروتوکول http برای صدا کردن (call) و ارسال درخواست به سرور ها طراحی و ساخته میشوند.
در ادامه یک کلاینت مقدماتی و ساده را در زبان گولنگ ایجاد میکنیم.&lt;/p>
&lt;p>‍‍&lt;/p>
&lt;pre>&lt;code class="language-go">
package main
import (
&amp;quot;fmt&amp;quot;
&amp;quot;io/ioutil&amp;quot;
&amp;quot;net/http&amp;quot;
&amp;quot;time&amp;quot;
)
func main() {
// کلاینت خود را با استفاده از ماژول http ایجاد میکنیم
c := http.Client{Timeout: time.Duration(1) * time.Second}
// از طریق کلاینت ایجاد شده یک درخواست با متد GET به آدرس example.com ارسال میکنیم
// دقیقا سروری مشابه به سرور هایی که در قسمت های قبل ایجاد کردیم در آدرسی که الان به آن درخوایت ارسال میکنیم درحال گوش سپردن به درخواست ها میباشد.
resp, err := c.Get(&amp;quot;https://www.example.com&amp;quot;)
if err != nil {
fmt.Printf(&amp;quot;Error %s&amp;quot;, err)
return
}
defer resp.Body.Close()
// مقادیر دریافت شده از سرور را میخوانیم و چاپ میکنیم
body, err := ioutil.ReadAll(resp.Body)
fmt.Printf(&amp;quot;Body : %s&amp;quot;, body)
}
&lt;/code>&lt;/pre>
&lt;p>در نهایت با اجرای قطعه کد بالا خروجی ما پاسخی است که از سرور دریافت کرده ایم:&lt;/p>
&lt;pre>&lt;code class="language-html">Body : &amp;lt;!doctype html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;title&amp;gt;Example Domain&amp;lt;/title&amp;gt;
&amp;lt;meta charset=&amp;quot;utf-8&amp;quot; /&amp;gt;
&amp;lt;meta http-equiv=&amp;quot;Content-type&amp;quot; content=&amp;quot;text/html; charset=utf-8&amp;quot; /&amp;gt;
&amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1&amp;quot; /&amp;gt;
&amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;
body {
background-color: #f0f0f2;
margin: 0;
padding: 0;
font-family: -apple-system, system-ui, BlinkMacSystemFont, &amp;quot;Segoe UI&amp;quot;, &amp;quot;Open Sans&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Helvetica, Arial, sans-serif;
}
div {
width: 600px;
margin: 5em auto;
padding: 2em;
background-color: #fdfdff;
border-radius: 0.5em;
box-shadow: 2px 3px 7px 2px rgba(0,0,0,0.02);
}
a:link, a:visited {
color: #38488f;
text-decoration: none;
}
@media (max-width: 700px) {
div {
margin: 0 auto;
width: auto;
}
}
&amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div&amp;gt;
&amp;lt;h1&amp;gt;Example Domain&amp;lt;/h1&amp;gt;
&amp;lt;p&amp;gt;This domain is for use in illustrative examples in documents. You may use this
domain in literature without prior coordination or asking for permission.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;a href=&amp;quot;https://www.iana.org/domains/example&amp;quot;&amp;gt;More information...&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code>&lt;/pre></description></item><item><author/><title>5.9 کتابخانه http سمت کلاینت پیشرفته</title><link>https://book.gofarsi.ir/chapter-5/go-http-client-advanced/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-5/go-http-client-advanced/</guid><description>&lt;p>در قسمت قبل به ایجاد یک کلاینت http ساده و ارسال یک درخواست با متد get پرداختیم.&lt;/p>
&lt;p>در این قسمت به موارد کامل تر و جزیی تر کلاینت http میپردازیم.&lt;/p>
&lt;p>برای انجام تمرین های این قسمت از یک api تستی که جهت یادگیری ساخته شده است استفاده میکنیم (شما میتوانید از هر api یا سروری استفاده کنید حتی سرور http که خودتان نوشته باشید.)&lt;/p>
&lt;p>در این آموزش ما از api زیر استفاده میکنیم:
&lt;a href="https://fakestoreapi.com/docs">api docs&lt;/a>&lt;/p>
&lt;h2 id="591-نوع-درخواست-های-یک-سرور-http">
5.9.1 نوع درخواست های یک سرور http
&lt;a class="anchor" href="#591-%d9%86%d9%88%d8%b9-%d8%af%d8%b1%d8%ae%d9%88%d8%a7%d8%b3%d8%aa-%d9%87%d8%a7%db%8c-%db%8c%da%a9-%d8%b3%d8%b1%d9%88%d8%b1-http">#&lt;/a>
&lt;/h2>
&lt;p>یکی از مواردی که حین اتصال به یک سرور http باید مورد توجه قرار بگیرد متد یا نوع درخواست است.&lt;/p>
&lt;p>انواع متد ها:
GET : پیام هایی که در این روش ارسال می‌شوند تنها برای دریافت اطلاعات از سرور میباشد.&lt;/p>
&lt;p>POST : در این نوع پیام ها اطلاعاتی برای ثبت شدن در سرور به سمت سرور http ارسال میشود&lt;/p>
&lt;p>PUT : در این روش برای جایگزاری مقداری در سرور اطلاعاتی ارسال میشود.&lt;/p>
&lt;p>DELETE : از این روش برای حذف مقداری از روی سرور استفاده میشود&lt;/p>
&lt;p>PATCH : این روش برای ویرایش جزیی استفاده میشود.&lt;/p>
&lt;p>این موارد ۵ تا از پرکابرد ترین نوع درخواست های http هستند.&lt;/p>
&lt;h2 id="592-نوع-پاسخ-های-یک-سرور-http">
5.9.2 نوع پاسخ های یک سرور http
&lt;a class="anchor" href="#592-%d9%86%d9%88%d8%b9-%d9%be%d8%a7%d8%b3%d8%ae-%d9%87%d8%a7%db%8c-%db%8c%da%a9-%d8%b3%d8%b1%d9%88%d8%b1-http">#&lt;/a>
&lt;/h2>
&lt;p>در پاسخ یک سرور http یکی از موارد پر اهمیت کد وضعیت یا status code است.
این کد ها اعدادی بین ۱۰۰ تا ۵۹۹ هستند که نشان دهنده وضعیت درخوایت از سمت سرور میباشند.&lt;/p>
&lt;p>انواع کد وضعیت:
1XX: این دسته از کد های وضعیت نمایانگر اطلاعات درخواست هستند&lt;/p>
&lt;p>2XX: این دسته از کد های وضعیت نمایانگر موفقیت درخواست در ارسال ثبت یا ویرایش اطلاعات میباشد&lt;/p>
&lt;p>3xx: این دسته از کد های نشانگر ریدایرکت میباشد&lt;/p>
&lt;p>4xx: این دسته از کد ها نشانگر ارور از سمت کلاینت میباشند&lt;/p>
&lt;p>5xx: این دسته از کد های نشانگر ارور از سمت سرور میباشند&lt;/p>
&lt;p>در قسمت های بعد به پیاده سازی کلاینت و سرور HTTP خواهیم پرداخت و شاهد این موارد در عمل خواهید بود.&lt;/p>
&lt;p>در قسمت زیر فهرست تعدادی از کد های وضعیت پرکاربرد را میبینیم:&lt;/p>
&lt;ol>
&lt;li>200 ok : این کد وضعیت نشانگر موفقیت در پاسخ به متد GET است&lt;/li>
&lt;li>404 NotFound : این کد وضعیت نشانگر پیدا نشدن مقدار درخواستی کاربر در سرور است که یکی از معروف ترین کد های وضعیت است&lt;/li>
&lt;li>500 InternalServerError: این کد وضعیت نشانگر خطای فنی از سمت سرور است&lt;/li>
&lt;li>401 Unauthorized : این کد وضعیت نشانگر این است که درخواست ارسال شده نیاز به احراز هویت دارد&lt;/li>
&lt;li>403 Forbidden : این کد وضعیت نشانگر این است که دسترسی به URL مورد نظر نیازمند سطح دسترسی متفاوتی است(این مورد با ۴۰۱ متفاوت است)&lt;/li>
&lt;/ol>
&lt;h2 id="593-get-request">
5.9.3 GET request
&lt;a class="anchor" href="#593-get-request">#&lt;/a>
&lt;/h2>
&lt;p>در مرحله اول به ایجاد یک درخواست GET به سرور میپردازیم.&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;fmt&amp;quot;
&amp;quot;io/ioutil&amp;quot;
&amp;quot;net/http&amp;quot;
)
func main() {
// به url مورد نظر برای دریافت لیست محصولات موجود یک درخوایت با متد GET ایجاد میکنیم
resp, err := http.Get(&amp;quot;https://fakestoreapi.com/products&amp;quot;)
if err != nil {
fmt.Println(&amp;quot;Error:&amp;quot;, err)
return
}
defer resp.Body.Close()
// کد وضعیت پاسخ سرور را چاپ میکنیم
fmt.Println(resp.StatusCode)
// خروجی را در یک اسلایس ذخیره میکنیم
body, err := ioutil.ReadAll(resp.Body)
if err != nil {
fmt.Println(&amp;quot;Error:&amp;quot;, err)
return
}
// خروجی را چاپ میکنیم
fmt.Println(string(body))
}
&lt;/code>&lt;/pre>
&lt;p>خروجی:&lt;/p>
&lt;pre>&lt;code class="language-json">
[
{
&amp;quot;id&amp;quot;:1,
&amp;quot;title&amp;quot;:&amp;quot;Fjallraven - Foldsack No. 1 Backpack, Fits 15 Laptops&amp;quot;,&amp;quot;price&amp;quot;:109.95,&amp;quot;description&amp;quot;:&amp;quot;Your perfect pack for everyday use and walks in the forest. Stash your laptop (up to 15 inches) in the padded sleeve, your everyday&amp;quot;,
&amp;quot;category&amp;quot;:&amp;quot;men's clothing&amp;quot;,
&amp;quot;image&amp;quot;:&amp;quot;https://fakestoreapi.com/img/81fPKd-2AYL._AC_SL1500_.jpg&amp;quot;,
&amp;quot;rating&amp;quot;:{&amp;quot;rate&amp;quot;:3.9,&amp;quot;count&amp;quot;:120}
},
// .....
]
&lt;/code>&lt;/pre>
&lt;h2 id="594-post-request">
5.9.4 POST request
&lt;a class="anchor" href="#594-post-request">#&lt;/a>
&lt;/h2>
&lt;p>در مرحله بعد با استفاده از متد POST یک محصول جدید به سرور اضافه میکنیم.&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;bytes&amp;quot;
&amp;quot;fmt&amp;quot;
&amp;quot;net/http&amp;quot;
)
func main() {
url := &amp;quot;https://fakestoreapi.com/products&amp;quot;
// جیسان مورد نظر برای ارسال و ثبت در سرور را ایجاد میکنیم (مقادیر مورد نیاز در مستندات api ذکر میشود)
jsonStr := []byte(`
{
title: 'test product',
price: 13.5,
description: 'lorem ipsum set',
image: 'https://i.pravatar.cc',
category: 'electronic'
}
`)
// یک درخواست یه ادرس سرور میسازیم
req, err := http.NewRequest(&amp;quot;POST&amp;quot;, url, bytes.NewBuffer(jsonStr))
if err != nil {
fmt.Println(err)
}
client := &amp;amp;http.Client{}
// درخواست را انجام میدهیم
resp, err := client.Do(req)
if err != nil {
fmt.Println(err)
}
defer resp.Body.Close()
// کد وضعیت و پاسخ سرور را چاپ میکنیم
fmt.Println(&amp;quot;Status:&amp;quot;, resp.Status)
fmt.Println(&amp;quot;Response:&amp;quot;, resp)
}
&lt;/code>&lt;/pre>
&lt;p>در صورت برابر بودن کد وضعیت با ۲۰۰ محصول ایجاد شده توسط شما با موفقیت ثبت شده است.&lt;/p>
&lt;h2 id="595-delete-request">
5.9.5 DELETE request
&lt;a class="anchor" href="#595-delete-request">#&lt;/a>
&lt;/h2>
&lt;p>در مرحله بعد به ایجاد یک درخواست DELETE و پاک کردن یک محصول از سرور میپردازیم:&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;fmt&amp;quot;
&amp;quot;net/http&amp;quot;
)
func main() {
// شماره محصول مورد نظر را در انتهای url اضافه میکنیم (طبق مستندات)
url := &amp;quot;https://fakestoreapi.com/products/1&amp;quot;
// یک درخواست با متد DELETE ایجاد میکنیم
req, err := http.NewRequest(&amp;quot;DELETE&amp;quot;, url, nil)
if err != nil {
fmt.Println(err)
}
client := &amp;amp;http.Client{}
// درخواست را به سرور ارسال میکنیم
resp, err := client.Do(req)
if err != nil {
fmt.Println(err)
}
defer resp.Body.Close()
// درصورت موفقیت آمیز بودن درخواست خروجی عدد 200 است
fmt.Println(&amp;quot;Status:&amp;quot;, resp.Status)
}
&lt;/code>&lt;/pre>
&lt;h2 id="596-put-request">
5.9.6 PUT request
&lt;a class="anchor" href="#596-put-request">#&lt;/a>
&lt;/h2>
&lt;p>در مرحله بعد به ایجاد یک درخواست PUT و اپدیت کردن اطلاعات یک محصول میپردازیم:&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;bytes&amp;quot;
&amp;quot;fmt&amp;quot;
&amp;quot;net/http&amp;quot;
)
func main() {
// ایدی محول مورد نظر را به انتهای url اضافه میکنیم
url := &amp;quot;https://fakestoreapi.com/products/7&amp;quot;
// مقدار های جدید را برای اپدیت شدن وارد میکنیم
requestBody := []byte(`
{
title: 'test product',
price: 13.5,
description: 'lorem ipsum set',
image: 'https://i.pravatar.cc',
category: 'electronic'
}
`)
‍‍ // درخواست را ایجاد میکنیم
req, err := http.NewRequest(&amp;quot;PUT&amp;quot;, url, bytes.NewBuffer(requestBody))
if err != nil {
fmt.Println(err)
return
}
client := &amp;amp;http.Client{}
// درخواست را به سرور ارسال میکنیم
resp, err := client.Do(req)
if err != nil {
fmt.Println(err)
return
}
defer resp.Body.Close()
// درصورت 200 بودن کد وضعیت اپدیت با موفقیت انجام شده.
fmt.Println(resp.StatusCode)
}
&lt;/code>&lt;/pre></description></item><item><author/><title>5.10 پروتکل quic</title><link>https://book.gofarsi.ir/chapter-5/go-quic-prtoocol/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-5/go-quic-prtoocol/</guid><description>&lt;p>پروتکل quic یک پروتکل توسعه یافته توسط google است. این پروتکل برای امنیت و سرعت بیشتر توسعه داده شده است.&lt;/p>
&lt;p>پروتکل quic از UDP استفاده میکند و در لایه transport قرار میگیرد.&lt;/p>
&lt;p>این پروتکل اجازه ایجاد چند کانکشن بصورت همزمان را فراهم میکنید و همچنین http/3 بر اساس این پروتکل طراحی و ایجاد شده است.&lt;/p>
&lt;p>چند مورد از ویژگی های کلیدی quic :
۱. ایجاد کانکشن سریع تر به دلیل اسفاده از udp.
۲. نیازی به دست دادن سه مرحله مثل tcp ندارد.
۳. بصورت پیش فرص از رمزنگاری استفاده میکند.&lt;/p>
&lt;p>در ادامه با استفاده از یک پکیج خارجی به نام &lt;code>quic-go&lt;/code> یک سرور ساده با این پروتکل ایجاد میکنیم و یک پیام به آن ارسال میکنیم (عملکرد سرور ما تنها برگرداندن همان متن یا به اصطلاحی echo کردن آن است)&lt;/p>
&lt;p>برای شروع کار ابتدا نیاز داریم پکیج مورد نظر خود را نصب کنیم&lt;/p>
&lt;p>با استفاده از دستور زیر:
&lt;code>go get github.com/quic-go/quic-go&lt;/code>&lt;/p>
&lt;p>بعد از اتمام مرحله نصب شروع به نوشتن کد سرور و کلاینت خود میکنیم.&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;context&amp;quot;
&amp;quot;crypto/rand&amp;quot;
&amp;quot;crypto/rsa&amp;quot;
&amp;quot;crypto/tls&amp;quot;
&amp;quot;crypto/x509&amp;quot;
&amp;quot;encoding/pem&amp;quot;
&amp;quot;fmt&amp;quot;
&amp;quot;io&amp;quot;
&amp;quot;log&amp;quot;
&amp;quot;math/big&amp;quot;
&amp;quot;github.com/quic-go/quic-go&amp;quot;
)
const addr = &amp;quot;localhost:4242&amp;quot;
// the message we sent to server you can also change it!
const message = &amp;quot;hello gifarsi!&amp;quot;
// starting the server and call the client function.
func main() {
go func() { log.Fatal(echoServer()) }()
err := clientMain()
if err != nil {
panic(err)
}
}
// this function start our echo server
func echoServer() error {
// make a new listner with quic
listener, err := quic.ListenAddr(addr, generateTLSConfig(), nil)
if err != nil {
return err
}
// accept incoming connections
conn, err := listener.Accept(context.Background())
if err != nil {
return err
}
// accept incoming streams
stream, err := conn.AcceptStream(context.Background())
if err != nil {
panic(err)
}
// Echo using the loggingWriter
_, err = io.Copy(loggingWriter{stream}, stream)
return err
}
// client function thah send the message to our server
func clientMain() error {
// set up a tls config
tlsConf := &amp;amp;tls.Config{
InsecureSkipVerify: true,
NextProtos: []string{&amp;quot;quic-echo-example&amp;quot;},
}
// dial with our udp server
conn, err := quic.DialAddr(context.Background(), addr, tlsConf, nil)
if err != nil {
return err
}
// opening a new stream from our connection
stream, err := conn.OpenStreamSync(context.Background())
if err != nil {
return err
}
// write the message over the stream
fmt.Printf(&amp;quot;Client: Sending '%s'\n&amp;quot;, message)
_, err = stream.Write([]byte(message))
if err != nil {
return err
}
// read and print incoming answer from server
buf := make([]byte, len(message))
_, err = io.ReadFull(stream, buf)
if err != nil {
return err
}
fmt.Printf(&amp;quot;Client: Got '%s'\n&amp;quot;, buf)
return nil
}
// A wrapper for io.Writer that also logs the message.
type loggingWriter struct{ io.Writer }
func (w loggingWriter) Write(b []byte) (int, error) {
fmt.Printf(&amp;quot;Server: Got '%s'\n&amp;quot;, string(b))
return w.Writer.Write(b)
}
// Setup a bare-bones TLS config for the server
func generateTLSConfig() *tls.Config {
key, err := rsa.GenerateKey(rand.Reader, 1024)
if err != nil {
panic(err)
}
template := x509.Certificate{SerialNumber: big.NewInt(1)}
certDER, err := x509.CreateCertificate(rand.Reader, &amp;amp;template, &amp;amp;template, &amp;amp;key.PublicKey, key)
if err != nil {
panic(err)
}
keyPEM := pem.EncodeToMemory(&amp;amp;pem.Block{Type: &amp;quot;RSA PRIVATE KEY&amp;quot;, Bytes: x509.MarshalPKCS1PrivateKey(key)})
certPEM := pem.EncodeToMemory(&amp;amp;pem.Block{Type: &amp;quot;CERTIFICATE&amp;quot;, Bytes: certDER})
tlsCert, err := tls.X509KeyPair(certPEM, keyPEM)
if err != nil {
panic(err)
}
return &amp;amp;tls.Config{
Certificates: []tls.Certificate{tlsCert},
NextProtos: []string{&amp;quot;quic-echo-example&amp;quot;},
}
}
&lt;/code>&lt;/pre>
&lt;p>بعد از اتمام نوشتن کد های سرور میتوانیم کد خود را اجرا و تست کنیم&lt;/p>
&lt;p>&lt;code>go run main.go&lt;/code>&lt;/p>
&lt;p>خروجی لاگ های ما به این صورت خواهد بود :&lt;/p>
&lt;pre>&lt;code>Client: Sending 'hello gifarsi!'
Server: Got 'hello gifarsi!'
Client: Got 'hello gifarsi!'
&lt;/code>&lt;/pre>
&lt;p>در انتها توجه داشته باشید این یک مثال ساده از quic در گولنگ بود شما میتوانید با استفاده از همین پکیج سرور های کامل تر و پیچیده تر را توسعه دهید و همچنین با استفاده از &lt;code>quic-go/http3&lt;/code> یک سرور http3 توسعه دهید.&lt;/p></description></item></channel></rss>