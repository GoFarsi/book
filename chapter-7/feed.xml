<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><author/><title>فصل هفتم: تست نویسی on زبان گو فارسی</title><link>https://book.gofarsi.ir/chapter-7/</link><description>Recent content in فصل هفتم: تست نویسی on زبان گو فارسی</description><generator>Hugo -- gohugo.io</generator><language>fa</language><copyright>2023 GoFarsi All rights reserved</copyright><atom:link href="https://book.gofarsi.ir/chapter-7/feed.xml" rel="self" type="application/rss+xml"/><item><author/><title>7.1 مقدمه‌ای بر تست در Go</title><link>https://book.gofarsi.ir/chapter-7/go-introduction-testing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-7/go-introduction-testing/</guid><description>&lt;p>تست‌نویسی یکی از ارکان حیاتی توسعه نرم‌افزارهای قابل‌اعتماد و نگهدارپذیر است. در دنیای امروز که سرعت توسعه و تغییرات کد روزبه‌روز بیشتر می‌شود، وجود تست‌های دقیق و ساختاریافته تضمین می‌کند که عملکرد نرم‌افزار با تغییرات جدید دچار اختلال نشود. از کشف باگ‌ها گرفته تا مستندسازی رفتار مورد انتظار ماژول‌ها، تست‌ها نقشی فراتر از صرفاً اطمینان‌بخشی دارند. آن‌ها به تیم توسعه جرئت ریفکتور می‌دهند و مرزهای طراحی سیستم را شفاف می‌کنند.&lt;/p>
&lt;p>زبان Go با در نظر گرفتن سادگی و مینیمالیسم به عنوان اصل بنیادین، تست‌نویسی را به عنوان بخشی جدانشدنی از چرخه توسعه درون خود جای داده است. بر خلاف بسیاری از زبان‌ها که برای تست‌نویسی نیاز به نصب ابزارهای اضافی دارند، Go یک ابزار تست‌نویسی داخلی، ساده و قدرتمند به نام &lt;code>testing&lt;/code> در کنار دستور &lt;code>go test&lt;/code> ارائه می‌دهد که فرآیند اجرا و گزارش‌گیری را بسیار روان و سریع می‌کند. این ابزارها با طراحی سطح پایین و بدون پیچیدگی، توسعه‌دهندگان را تشویق می‌کنند که تست را به بخشی از سبک برنامه‌نویسی خود تبدیل کنند.&lt;/p>
&lt;p>در Go، تست‌ها همان توابع عادی هستند که با قواعد ساده‌ای مانند &lt;code>TestXxx(t *testing.T)&lt;/code> نوشته می‌شوند. خبری از assertionهای پیچیده یا DSLهای سنگین نیست. همین سادگی، آزمون‌ها را خواناتر، نگهدار‌پذیرتر و از همه مهم‌تر، قابل‌درک برای همه اعضای تیم می‌کند. ابزارهای جانبی مانند &lt;code>testify&lt;/code> یا &lt;code>ginkgo&lt;/code> نیز به عنوان افزونه‌هایی قدرتمند برای پروژه‌های بزرگ‌تر و تست‌های ساختاریافته‌تر به کار گرفته می‌شوند، اما اصل فلسفه Go حفظ مینیمالیسم است.&lt;/p>
&lt;p>در این فصل، با اصول، ابزارها و الگوهای تست‌نویسی در زبان Go آشنا خواهیم شد؛ از تست واحد، جدول‌محور، یکپارچه و انتها به انتها گرفته تا بنچمارک، تست فازی و تست‌های هم‌زمانی. همچنین به ابزارهایی چون &lt;code>testify&lt;/code>, &lt;code>gomock&lt;/code>, &lt;code>ginkgo&lt;/code>, پوشش تست، ساخت Suite تستی و نحوه تست‌نویسی حرفه‌ای در پروژه‌های واقعی می‌پردازیم. هدف این فصل آن است که مهارت تست‌نویسی شما را در Go از سطح ابتدایی به سطحی قابل‌اعتماد و حرفه‌ای ارتقا دهد.&lt;/p>
&lt;blockquote class="book-hint info">
&lt;strong>به نقل از ویکی پدیا&lt;/strong>
&lt;strong>آزمون نرم‌افزار&lt;/strong> یا&lt;a href="https://fa.wikipedia.org/wiki/%D8%A2%D8%B2%D9%85%D9%88%D9%86_%D9%86%D8%B1%D9%85%E2%80%8C%D8%A7%D9%81%D8%B2%D8%A7%D8%B1"> &lt;strong>تست نرم‌افزار&lt;/strong>&lt;/a> (به &lt;a href="https://fa.wikipedia.org/wiki/%D8%B2%D8%A8%D8%A7%D9%86_%D8%A7%D9%86%DA%AF%D9%84%DB%8C%D8%B3%DB%8C" title="زبان انگلیسی">انگلیسی&lt;/a>: software testing) به فرایند ارزیابی نرم‌افزار به منظور اطمینان از عملکرد صحیح آن در رویدادهایی مختلفی که ممکن است در دوره استفاده از نرم‌افزار با آن مواجه شود می‌باشد و به عبارت دیگر پیدا کردن خطاهایی احتمالی یک نرم‌افزار برای عملکرد درست، صحیح و بهینه آن در طول استفاده از آن است. هر چقدر نرم‌افزار بتواند با رویدادها مختلف به صورت مطلوب تر و قابل پذیرش تری چه از نظر عملکرد و چه از راحتی کاربر داشته باشد می‌توان انتظار داشت نرم‌افزار دارای عملکرد بهتری می‌باشد.
&lt;/blockquote>
&lt;h2 id="711-جایگاه-تست-در-چرخه-توسعه-نرمافزار">
7.1.1 جایگاه تست در چرخه توسعه نرم‌افزار
&lt;a class="anchor" href="#711-%d8%ac%d8%a7%db%8c%da%af%d8%a7%d9%87-%d8%aa%d8%b3%d8%aa-%d8%af%d8%b1-%da%86%d8%b1%d8%ae%d9%87-%d8%aa%d9%88%d8%b3%d8%b9%d9%87-%d9%86%d8%b1%d9%85%d8%a7%d9%81%d8%b2%d8%a7%d8%b1">#&lt;/a>
&lt;/h2>
&lt;p>در توسعه نرم‌افزار، نوشتن تست فقط یک فعالیت جانبی برای اطمینان از صحت عملکرد نیست، بلکه بخش جدایی‌ناپذیری از طراحی، مستندسازی و حفظ کیفیت سیستم محسوب می‌شود. زمانی که نرم‌افزار رشد می‌کند، تغییر می‌کند و افراد جدید به تیم توسعه می‌پیوندند، تست‌ها نقش ستون‌های قابل اعتماد برای حفظ رفتار صحیح سیستم را ایفا می‌کنند. در این میان، زبان برنامه‌نویسی Go با ساده‌سازی ابزارها و یکپارچه‌سازی امکانات تست‌نویسی، فرآیند توسعه را به‌گونه‌ای طراحی کرده که تست بخشی طبیعی از چرخه توسعه باشد.&lt;/p>
&lt;h3 id="7111-تست-به-عنوان-بخشی-از-طراحی-سیستم">
7.1.1.1 تست به عنوان بخشی از طراحی سیستم
&lt;a class="anchor" href="#7111-%d8%aa%d8%b3%d8%aa-%d8%a8%d9%87-%d8%b9%d9%86%d9%88%d8%a7%d9%86-%d8%a8%d8%ae%d8%b4%db%8c-%d8%a7%d8%b2-%d8%b7%d8%b1%d8%a7%d8%ad%db%8c-%d8%b3%db%8c%d8%b3%d8%aa%d9%85">#&lt;/a>
&lt;/h3>
&lt;p>در بسیاری از روش‌های توسعه نرم‌افزار، نوشتن تست حتی پیش از پیاده‌سازی کد توصیه می‌شود. در روش‌هایی مانند &lt;span class="tooltip" data-tooltip="Test-Driven Development (TDD)" ontouchend="toggleTooltip(this)">توسعه مبتنی بر تست&lt;/span>
یا &lt;span class="tooltip" data-tooltip="Behavior-Driven Development (BDD)" ontouchend="toggleTooltip(this)">توسعه مبتنی بر رفتار&lt;/span>
، تست‌ها بخش اولیه فرآیند طراحی هستند. در زبان Go، نوشتن تست با استفاده از ساختارهای ساده‌ای مانند &lt;code>TestXxx(t *testing.T)&lt;/code> یا استفاده از الگوی &lt;span class="tooltip" data-tooltip="table-driven test" ontouchend="toggleTooltip(this)">تست جدول‌محور&lt;/span>
باعث می‌شود که طراحی APIها و منطق برنامه به‌صورت طبیعی بر پایه رفتار قابل تست شکل بگیرد. این نوع طراحی نه‌تنها کیفیت را افزایش می‌دهد، بلکه کد را تغییرپذیرتر و خواناتر می‌کند.&lt;/p>
&lt;h3 id="7112-تست-به-عنوان-مستند-رفتاری-سیستم">
7.1.1.2 تست به عنوان مستند رفتاری سیستم
&lt;a class="anchor" href="#7112-%d8%aa%d8%b3%d8%aa-%d8%a8%d9%87-%d8%b9%d9%86%d9%88%d8%a7%d9%86-%d9%85%d8%b3%d8%aa%d9%86%d8%af-%d8%b1%d9%81%d8%aa%d8%a7%d8%b1%db%8c-%d8%b3%db%8c%d8%b3%d8%aa%d9%85">#&lt;/a>
&lt;/h3>
&lt;p>تست‌ها می‌توانند جایگزینی دقیق، همیشگی و زنده برای مستندسازی باشند. هر تست، سناریویی مشخص از تعاملات سیستم با ورودی‌های مختلف است که خروجی یا رفتار خاصی را انتظار دارد. برخلاف مستندات متنی که به‌مرور زمان منسوخ می‌شوند، تست‌ها در صورت مغایرت با پیاده‌سازی، به‌وضوح شکست خواهند خورد. این ویژگی تست‌ها را به مرجع رفتاری سیستم تبدیل می‌کند. توسعه‌دهندگانی که برای هر ماژول تست می‌نویسند، در واقع رفتار آن ماژول را تعریف و مستند می‌کنند؛ به‌نحوی که برای سایر اعضای تیم یا برای توسعه‌دهندگانی که در آینده با پروژه کار می‌کنند نیز قابل درک است.&lt;/p>
&lt;blockquote>
&lt;p>تستی که می‌نویسی، قراردادی زنده با عملکرد سیستم است.&lt;/p>&lt;/blockquote>
&lt;h3 id="7113-تست-به-عنوان-سپر-تغییرات">
7.1.1.3 تست به عنوان سپر تغییرات
&lt;a class="anchor" href="#7113-%d8%aa%d8%b3%d8%aa-%d8%a8%d9%87-%d8%b9%d9%86%d9%88%d8%a7%d9%86-%d8%b3%d9%be%d8%b1-%d8%aa%d8%ba%db%8c%db%8c%d8%b1%d8%a7%d8%aa">#&lt;/a>
&lt;/h3>
&lt;p>در پروژه‌هایی که توسعه مداوم دارند، تغییر کد امری اجتناب‌ناپذیر است. اما تغییر بدون پشتوانه تست، خطر ایجاد &lt;span class="tooltip" data-tooltip="regression" ontouchend="toggleTooltip(this)">بازگشت خطا&lt;/span>
را به همراه دارد. تست‌ها در اینجا به‌عنوان یک سپر دفاعی عمل می‌کنند. پیش از اعمال تغییر، می‌توان با اجرای سریع تست‌ها مطمئن شد که تغییرات، سایر بخش‌های سیستم را تحت تأثیر قرار نداده‌اند. سرعت بالای اجرای تست‌ها در Go باعث می‌شود که این فرآیند به‌صورت مستمر در چرخه توسعه انجام شود. با وجود این تست‌ها، می‌توان با اطمینان بالا اقدام به &lt;span class="tooltip" data-tooltip="refactoring" ontouchend="toggleTooltip(this)">بازسازی ساختار کد&lt;/span>
یا اضافه‌کردن ویژگی‌های جدید کرد.&lt;/p>
&lt;blockquote>
&lt;p>نمی‌توانی چیزی را بهینه کنی که راستی‌آزمایی‌اش نکرده‌ای.&lt;/p>&lt;/blockquote>
&lt;h3 id="7114-تست-در-go-اولویت-یا-گزینه">
7.1.1.4 تست در Go: اولویت یا گزینه؟
&lt;a class="anchor" href="#7114-%d8%aa%d8%b3%d8%aa-%d8%af%d8%b1-go-%d8%a7%d9%88%d9%84%d9%88%db%8c%d8%aa-%db%8c%d8%a7-%da%af%d8%b2%db%8c%d9%86%d9%87">#&lt;/a>
&lt;/h3>
&lt;p>در زبان Go، تست‌نویسی نه‌تنها یک امکان در دسترس، بلکه بخشی از ابزار رسمی توسعه است. برخلاف بسیاری از زبان‌ها که نیازمند نصب ابزارها یا کتابخانه‌های شخص ثالث برای نوشتن تست هستند، Go با فراهم کردن ابزارهایی مانند &lt;code>testing&lt;/code>، &lt;code>go test&lt;/code>، &lt;code>-cover&lt;/code>، &lt;code>-bench&lt;/code> و &lt;code>-fuzz&lt;/code> از ابتدا زیرساخت تست را فراهم کرده است. این ابزارها سبک توسعه‌ای را ترویج می‌دهند که در آن تست‌نویسی نه بعد از پیاده‌سازی، بلکه در حین توسعه و حتی پیش از آن انجام می‌شود. به همین دلیل، در بسیاری از پروژه‌های حرفه‌ای با زبان Go، تست بخش عادی و ضروری توسعه محسوب می‌شود، نه صرفاً یک انتخاب اختیاری.&lt;/p>
&lt;h2 id="712-مزایای-تستنویسی-در-go">
7.1.2 مزایای تست‌نویسی در Go
&lt;a class="anchor" href="#712-%d9%85%d8%b2%d8%a7%db%8c%d8%a7%db%8c-%d8%aa%d8%b3%d8%aa%d9%86%d9%88%db%8c%d8%b3%db%8c-%d8%af%d8%b1-go">#&lt;/a>
&lt;/h2>
&lt;p>یکی از نقاط قوت زبان Go، سادگی و یکپارچگی ابزارهای تست‌نویسی است. در حالی که در بسیاری از زبان‌ها، برای شروع تست‌نویسی باید چارچوب‌های خارجی نصب و پیکربندی شوند، در Go هر پروژه به‌صورت پیش‌فرض می‌تواند شامل فایل‌های تست باشد و با استفاده از ابزار رسمی &lt;code>go test&lt;/code> به‌سادگی تست‌ها را اجرا کند. این طراحی باعث شده تست‌نویسی در Go نه یک کار جانبی یا پیچیده، بلکه بخشی طبیعی از توسعه روزمره باشد.&lt;/p>
&lt;h3 id="7121-سادهسازی-فرآیند-تستنویسی">
7.1.2.1 ساده‌سازی فرآیند تست‌نویسی
&lt;a class="anchor" href="#7121-%d8%b3%d8%a7%d8%af%d9%87%d8%b3%d8%a7%d8%b2%db%8c-%d9%81%d8%b1%d8%a2%db%8c%d9%86%d8%af-%d8%aa%d8%b3%d8%aa%d9%86%d9%88%db%8c%d8%b3%db%8c">#&lt;/a>
&lt;/h3>
&lt;p>تست‌ها در Go صرفاً توابعی هستند که با الگوی &lt;code>TestXxx(t *testing.T)&lt;/code> تعریف می‌شوند. نیازی به ارث‌بری، annotation یا ساختارهای پیچیده نیست. تنها چیزی که لازم است یک تابع ساده و چند شرط منطقی برای بررسی نتایج است. همین سادگی باعث می‌شود افراد تازه‌کار نیز بتوانند به‌راحتی نوشتن تست را آغاز کنند و به مرور، تست‌های پیچیده‌تر بنویسند.&lt;/p>
&lt;h3 id="7122-سرعت-بالا-در-اجرا">
7.1.2.2 سرعت بالا در اجرا
&lt;a class="anchor" href="#7122-%d8%b3%d8%b1%d8%b9%d8%aa-%d8%a8%d8%a7%d9%84%d8%a7-%d8%af%d8%b1-%d8%a7%d8%ac%d8%b1%d8%a7">#&lt;/a>
&lt;/h3>
&lt;p>تست‌های Go به دلیل ساختار ساده و اجرای مستقل، بسیار سریع اجرا می‌شوند. این موضوع در پروژه‌های بزرگ که شامل صدها یا هزاران تست هستند، اهمیت ویژه‌ای دارد. با استفاده از امکانات داخلی مانند &lt;code>-short&lt;/code>، &lt;code>-run&lt;/code> و &lt;code>-parallel&lt;/code> می‌توان تست‌ها را به‌صورت انتخابی، سریع و هم‌زمان اجرا کرد. این ویژگی، بازخورد سریع برای توسعه‌دهنده فراهم می‌کند و مانع از کند شدن چرخه توسعه می‌شود.&lt;/p>
&lt;h3 id="7123-پوشش-طیف-متنوعی-از-تستها">
7.1.2.3 پوشش طیف متنوعی از تست‌ها
&lt;a class="anchor" href="#7123-%d9%be%d9%88%d8%b4%d8%b4-%d8%b7%db%8c%d9%81-%d9%85%d8%aa%d9%86%d9%88%d8%b9%db%8c-%d8%a7%d8%b2-%d8%aa%d8%b3%d8%aa%d9%87%d8%a7">#&lt;/a>
&lt;/h3>
&lt;p>Go به‌صورت پیش‌فرض از انواع مختلف تست پشتیبانی می‌کند:&lt;/p>
&lt;ul>
&lt;li>تست واحد &lt;span class="tooltip" data-tooltip="unit test" ontouchend="toggleTooltip(this)">unit test&lt;/span>
&lt;/li>
&lt;li>تست یکپارچه &lt;span class="tooltip" data-tooltip="integration test" ontouchend="toggleTooltip(this)">integration test&lt;/span>
&lt;/li>
&lt;li>تست انتها به انتها &lt;span class="tooltip" data-tooltip="end-to-end test" ontouchend="toggleTooltip(this)">end-to-end test&lt;/span>
&lt;/li>
&lt;li>تست عملکرد &lt;span class="tooltip" data-tooltip="benchmark" ontouchend="toggleTooltip(this)">benchmark&lt;/span>
&lt;/li>
&lt;li>تست فازی &lt;span class="tooltip" data-tooltip="fuzz testing" ontouchend="toggleTooltip(this)">fuzz testing&lt;/span>
&lt;/li>
&lt;/ul>
&lt;p>بدون نیاز به ابزار خارجی، می‌توان تمامی این انواع تست را در دل پروژه نوشت و اجرا کرد. این تنوع به تیم‌ها کمک می‌کند تا از زوایای مختلف، عملکرد و صحت سیستم را ارزیابی کنند.&lt;/p>
&lt;h3 id="7124-پشتیبانی-از-ابزارهای-جانبی-و-شخص-ثالث">
7.1.2.4 پشتیبانی از ابزارهای جانبی و شخص ثالث
&lt;a class="anchor" href="#7124-%d9%be%d8%b4%d8%aa%db%8c%d8%a8%d8%a7%d9%86%db%8c-%d8%a7%d8%b2-%d8%a7%d8%a8%d8%b2%d8%a7%d8%b1%d9%87%d8%a7%db%8c-%d8%ac%d8%a7%d9%86%d8%a8%db%8c-%d9%88-%d8%b4%d8%ae%d8%b5-%d8%ab%d8%a7%d9%84%d8%ab">#&lt;/a>
&lt;/h3>
&lt;p>در کنار ابزارهای داخلی، اکوسیستم Go شامل کتابخانه‌ها و فریم‌ورک‌های محبوبی برای تست‌نویسی پیشرفته است. کتابخانه‌هایی مانند:&lt;/p>
&lt;ul>
&lt;li>&lt;code>testify&lt;/code>: برای assertions و mock&lt;/li>
&lt;li>&lt;code>ginkgo&lt;/code>: برای تست‌های ساختاریافته به سبک BDD&lt;/li>
&lt;li>&lt;code>gomock&lt;/code>, &lt;code>moq&lt;/code>: برای تولید mock خودکار&lt;/li>
&lt;li>&lt;code>go-cmp&lt;/code>: برای مقایسه دقیق ساختارهای پیچیده&lt;/li>
&lt;/ul>
&lt;p>این ابزارها امکانات اضافی و قدرتمندی به تست‌نویسی اضافه می‌کنند و در عین حال با ساختار زبان سازگار باقی می‌مانند.&lt;/p>
&lt;h3 id="7125-ادغام-آسان-با-cicd">
7.1.2.5 ادغام آسان با CI/CD
&lt;a class="anchor" href="#7125-%d8%a7%d8%af%d8%ba%d8%a7%d9%85-%d8%a2%d8%b3%d8%a7%d9%86-%d8%a8%d8%a7-cicd">#&lt;/a>
&lt;/h3>
&lt;p>از آنجا که اجرای تست در Go از طریق یک دستور ساده انجام می‌شود (&lt;code>go test ./...&lt;/code>)، ادغام آن در &lt;span class="tooltip" data-tooltip="CI/CD pipelines" ontouchend="toggleTooltip(this)">خط تولید خودکار&lt;/span>
بسیار ساده است. بیشتر پلتفرم‌های CI مثل GitHub Actions، GitLab CI، CircleCI و TravisCI، بدون نیاز به پیکربندی اضافی، می‌توانند تست‌های Go را اجرا و گزارش کنند. این ویژگی باعث می‌شود که فرهنگ تست‌نویسی در تیم به‌راحتی به یک عادت سازنده تبدیل شود.&lt;/p>
&lt;h3 id="7126-پایداری-و-نگهداری-آسان-تستها">
7.1.2.6 پایداری و نگهداری آسان تست‌ها
&lt;a class="anchor" href="#7126-%d9%be%d8%a7%db%8c%d8%af%d8%a7%d8%b1%db%8c-%d9%88-%d9%86%da%af%d9%87%d8%af%d8%a7%d8%b1%db%8c-%d8%a2%d8%b3%d8%a7%d9%86-%d8%aa%d8%b3%d8%aa%d9%87%d8%a7">#&lt;/a>
&lt;/h3>
&lt;p>ساختار تست در Go به‌گونه‌ای است که نگهداری آن در طول زمان ساده و کم‌هزینه است. چون تست‌ها از توابع معمولی تشکیل شده‌اند، به‌راحتی می‌توان آن‌ها را بازنویسی، جدا یا ترکیب کرد. همچنین از آنجا که ابزارهای تست بخشی از هسته زبان هستند، احتمال ناسازگاری نسخه‌ای یا شکستن تست‌ها به دلیل تغییر ابزار بسیار پایین است.&lt;/p>
&lt;p>حتماً، در ادامه نگارش کامل بخش &lt;strong>۷.۱.۳ رویکرد زبان Go به تست‌نویسی&lt;/strong> با رعایت ساختار مورد نظر، استفاده از کلمات تخصصی به‌صورت tooltip، بدون ارجاع مستقیم به کتاب‌ها و با زبان حرفه‌ای فارسی آورده شده است:&lt;/p>
&lt;h2 id="713-رویکرد-زبان-go-به-تستنویسی">
7.1.3 رویکرد زبان Go به تست‌نویسی
&lt;a class="anchor" href="#713-%d8%b1%d9%88%db%8c%da%a9%d8%b1%d8%af-%d8%b2%d8%a8%d8%a7%d9%86-go-%d8%a8%d9%87-%d8%aa%d8%b3%d8%aa%d9%86%d9%88%db%8c%d8%b3%db%8c">#&lt;/a>
&lt;/h2>
&lt;p>زبان Go از ابتدا با این نگرش طراحی شد که توسعه‌دهنده باید بتواند با ساده‌ترین ابزارها، بیشترین کنترل را روی کیفیت کد داشته باشد. در همین راستا، تست‌نویسی نه‌تنها به عنوان یک ابزار جانبی، بلکه به عنوان بخشی ذاتی از فلسفه زبان گنجانده شده است. رویکرد Go به تست‌نویسی بر پایه‌ی اصولی مانند سادگی، سرعت، قابلیت نگهداری و حداقل وابستگی بنا شده است.&lt;/p>
&lt;h3 id="7131-استفاده-از-ابزارهای-رسمی-و-داخلی">
7.1.3.1 استفاده از ابزارهای رسمی و داخلی
&lt;a class="anchor" href="#7131-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-%d8%a7%d8%a8%d8%b2%d8%a7%d8%b1%d9%87%d8%a7%db%8c-%d8%b1%d8%b3%d9%85%db%8c-%d9%88-%d8%af%d8%a7%d8%ae%d9%84%db%8c">#&lt;/a>
&lt;/h3>
&lt;p>در Go، نیازی به نصب هیچ ابزار اضافی برای تست‌نویسی وجود ندارد. با استفاده از پکیج &lt;span class="tooltip" data-tooltip="testing" ontouchend="toggleTooltip(this)">تستینگ&lt;/span>
و ابزار &lt;span class="tooltip" data-tooltip="go test" ontouchend="toggleTooltip(this)">گو تست&lt;/span>
می‌توان تست‌ها را نوشت، اجرا کرد و گزارش گرفت. این ابزارها بخشی از هسته زبان هستند و در کنار دستورات اصلی مانند &lt;code>go build&lt;/code> یا &lt;code>go run&lt;/code> مورد استفاده قرار می‌گیرند. این یکپارچگی باعث می‌شود تست‌نویسی بخشی کاملاً طبیعی از فرآیند توسعه باشد، نه عملی اختیاری یا پیچیده.&lt;/p>
&lt;h3 id="7132-سادگی-در-تعریف-تستها">
7.1.3.2 سادگی در تعریف تست‌ها
&lt;a class="anchor" href="#7132-%d8%b3%d8%a7%d8%af%da%af%db%8c-%d8%af%d8%b1-%d8%aa%d8%b9%d8%b1%db%8c%d9%81-%d8%aa%d8%b3%d8%aa%d9%87%d8%a7">#&lt;/a>
&lt;/h3>
&lt;p>برخلاف زبان‌هایی که برای نوشتن تست نیاز به استفاده از annotation، ارث‌بری از کلاس‌های خاص یا تعریف ساختارهای پیچیده دارند، در Go یک تست تنها یک تابع معمولی با امضای &lt;code>func TestXxx(t *testing.T)&lt;/code> است. این توابع می‌توانند هر منطق دلخواهی را پیاده‌سازی کنند و در صورت مشاهده خطا با فراخوانی &lt;code>t.Errorf()&lt;/code> یا &lt;code>t.Fatal()&lt;/code> گزارش شکست را صادر نمایند. این رویکرد باعث می‌شود تست‌ها خوانا، مینیمال و قابل فهم برای تمام اعضای تیم باشند.&lt;/p>
&lt;h3 id="7133-سبک-مینیمال-و-بدون-چارچوب">
7.1.3.3 سبک مینیمال و بدون چارچوب
&lt;a class="anchor" href="#7133-%d8%b3%d8%a8%da%a9-%d9%85%db%8c%d9%86%db%8c%d9%85%d8%a7%d9%84-%d9%88-%d8%a8%d8%af%d9%88%d9%86-%da%86%d8%a7%d8%b1%da%86%d9%88%d8%a8">#&lt;/a>
&lt;/h3>
&lt;p>Go از عمد از اضافه کردن &lt;span class="tooltip" data-tooltip="test frameworks" ontouchend="toggleTooltip(this)">چارچوب‌های تست&lt;/span>
پیچیده و سیستم‌های assertion سنگین اجتناب کرده است. این تصمیم با هدف حفظ سادگی، شفافیت و کنترل بیشتر توسعه‌دهنده اتخاذ شده است. اگرچه کتابخانه‌های شخص ثالث مانند &lt;code>testify&lt;/code> یا &lt;code>ginkgo&lt;/code> برای پروژه‌های بزرگ یا تست‌های ساختاریافته‌تر وجود دارند، اما فلسفه Go این است که تست ساده باشد و تا جای ممکن از ابزارهای استاندارد استفاده شود.&lt;/p>
&lt;h3 id="7134-پشتیبانی-طبیعی-از-انواع-تست">
7.1.3.4 پشتیبانی طبیعی از انواع تست
&lt;a class="anchor" href="#7134-%d9%be%d8%b4%d8%aa%db%8c%d8%a8%d8%a7%d9%86%db%8c-%d8%b7%d8%a8%db%8c%d8%b9%db%8c-%d8%a7%d8%b2-%d8%a7%d9%86%d9%88%d8%a7%d8%b9-%d8%aa%d8%b3%d8%aa">#&lt;/a>
&lt;/h3>
&lt;p>رویکرد Go به تست‌نویسی صرفاً محدود به بررسی صحت نیست. ابزار رسمی &lt;code>go test&lt;/code> با فلگ‌هایی مانند &lt;code>-bench&lt;/code>, &lt;code>-cover&lt;/code> و &lt;code>-fuzz&lt;/code> از تست‌های متنوعی پشتیبانی می‌کند، از جمله:&lt;/p>
&lt;ul>
&lt;li>تست عملکرد &lt;span class="tooltip" data-tooltip="benchmark" ontouchend="toggleTooltip(this)">benchmark&lt;/span>
&lt;/li>
&lt;li>سنجش پوشش کد &lt;span class="tooltip" data-tooltip="code coverage" ontouchend="toggleTooltip(this)">code coverage&lt;/span>
&lt;/li>
&lt;li>تست فازی &lt;span class="tooltip" data-tooltip="fuzz testing" ontouchend="toggleTooltip(this)">fuzz testing&lt;/span>
&lt;/li>
&lt;/ul>
&lt;p>همه این قابلیت‌ها در ابزارهای داخلی Go گنجانده شده‌اند و برای استفاده از آن‌ها نیازی به نصب افزونه یا وابستگی جدید نیست. این ویژگی Go را از بسیاری از زبان‌ها متمایز می‌کند.&lt;/p>
&lt;h3 id="7135-طراحی-برای-توسعهدهنده-نه-ابزار">
7.1.3.5 طراحی برای توسعه‌دهنده، نه ابزار
&lt;a class="anchor" href="#7135-%d8%b7%d8%b1%d8%a7%d8%ad%db%8c-%d8%a8%d8%b1%d8%a7%db%8c-%d8%aa%d9%88%d8%b3%d8%b9%d9%87%d8%af%d9%87%d9%86%d8%af%d9%87-%d9%86%d9%87-%d8%a7%d8%a8%d8%b2%d8%a7%d8%b1">#&lt;/a>
&lt;/h3>
&lt;p>فلسفه طراحی Go این است که توسعه‌دهنده باید به‌جای جنگیدن با ابزارها، مستقیماً روی حل مسئله تمرکز کند. این اصل در تست‌نویسی نیز دیده می‌شود. Go توسعه‌دهنده را تشویق می‌کند به‌جای وابستگی به جادوی فریم‌ورک‌ها، با ابزارهای ساده و قابل درک، منطق تست را به‌صورت شفاف پیاده‌سازی کند. این رویکرد در بلندمدت باعث تسهیل نگهداری پروژه، کاهش پیچیدگی و افزایش اطمینان از صحت سیستم می‌شود.&lt;/p>
&lt;h2 id="714-اصول-و-قراردادهای-تست-در-go">
7.1.4 اصول و قراردادهای تست در Go
&lt;a class="anchor" href="#714-%d8%a7%d8%b5%d9%88%d9%84-%d9%88-%d9%82%d8%b1%d8%a7%d8%b1%d8%af%d8%a7%d8%af%d9%87%d8%a7%db%8c-%d8%aa%d8%b3%d8%aa-%d8%af%d8%b1-go">#&lt;/a>
&lt;/h2>
&lt;p>در زبان Go، تست‌نویسی نه‌تنها از نظر ابزار ساده است، بلکه از نظر &lt;strong>قراردادها، ساختار پوشه‌ها و نام‌گذاری توابع&lt;/strong> نیز کاملاً روشن و استاندارد تعریف شده است. این ساختار قراردادی به توسعه‌دهندگان کمک می‌کند تا تست‌ها را به‌راحتی بنویسند، بخوانند، اجرا کنند و در ابزارهای خودکار مانند &lt;span class="tooltip" data-tooltip="CI pipelines" ontouchend="toggleTooltip(this)">سی‌آی&lt;/span>
ادغام نمایند.&lt;/p>
&lt;h3 id="7141-ساختار-فایلهای-تست">
7.1.4.1 ساختار فایل‌های تست
&lt;a class="anchor" href="#7141-%d8%b3%d8%a7%d8%ae%d8%aa%d8%a7%d8%b1-%d9%81%d8%a7%db%8c%d9%84%d9%87%d8%a7%db%8c-%d8%aa%d8%b3%d8%aa">#&lt;/a>
&lt;/h3>
&lt;p>تمام تست‌ها در Go باید در فایل‌هایی با پسوند &lt;code>_test.go&lt;/code> قرار بگیرند. این قانون توسط ابزار &lt;code>go test&lt;/code> شناسایی می‌شود و فقط این فایل‌ها برای اجرای تست در نظر گرفته می‌شوند. این فایل‌ها معمولاً در کنار فایل‌های اصلی قرار می‌گیرند، مثلاً:&lt;/p>
&lt;pre>&lt;code>math.go
math_test.go
&lt;/code>&lt;/pre>
&lt;p>این ساختار باعث می‌شود تست‌ها به راحتی با کد اصلی مقایسه و توسعه داده شوند، و وابستگی آن‌ها کاملاً واضح باشد.&lt;/p>
&lt;h3 id="7142-امضای-تابع-تست">
7.1.4.2 امضای تابع تست
&lt;a class="anchor" href="#7142-%d8%a7%d9%85%d8%b6%d8%a7%db%8c-%d8%aa%d8%a7%d8%a8%d8%b9-%d8%aa%d8%b3%d8%aa">#&lt;/a>
&lt;/h3>
&lt;p>هر تابع تست باید به شکل زیر تعریف شود:&lt;/p>
&lt;pre>&lt;code class="language-go">func TestXxx(t *testing.T)
&lt;/code>&lt;/pre>
&lt;p>در اینجا &lt;code>Xxx&lt;/code> می‌تواند نامی اختیاری و دلخواه باشد، اما باید با حرف بزرگ آغاز شود تا توسط ابزار تست شناسایی شود. آرگومان &lt;code>t&lt;/code> از نوع &lt;span class="tooltip" data-tooltip="*testing.T" ontouchend="toggleTooltip(this)">تی تستینگ&lt;/span>
است و امکاناتی مانند ثبت خطا، توقف تست، یا گزارش وضعیت را فراهم می‌کند.&lt;/p>
&lt;p>برای مثال:&lt;/p>
&lt;pre>&lt;code class="language-go">func TestAdd(t *testing.T) {
got := Add(2, 3)
if got != 5 {
t.Errorf(&amp;quot;expected 5, got %d&amp;quot;, got)
}
}
&lt;/code>&lt;/pre>
&lt;h3 id="7143-گروهبندی-تستها-با-subtest">
7.1.4.3 گروه‌بندی تست‌ها با Subtest
&lt;a class="anchor" href="#7143-%da%af%d8%b1%d9%88%d9%87%d8%a8%d9%86%d8%af%db%8c-%d8%aa%d8%b3%d8%aa%d9%87%d8%a7-%d8%a8%d8%a7-subtest">#&lt;/a>
&lt;/h3>
&lt;p>در Go می‌توان تست‌های مرتبط را با استفاده از متد &lt;code>t.Run&lt;/code> به‌صورت &lt;span class="tooltip" data-tooltip="subtest" ontouchend="toggleTooltip(this)">زیر تست&lt;/span>
اجرا کرد. این کار باعث دسته‌بندی منطقی تست‌ها و جداسازی گزارش آن‌ها در خروجی می‌شود:&lt;/p>
&lt;pre>&lt;code class="language-go">func TestMathOperations(t *testing.T) {
t.Run(&amp;quot;Addition&amp;quot;, func(t *testing.T) {
// ...
})
t.Run(&amp;quot;Multiplication&amp;quot;, func(t *testing.T) {
// ...
})
}
&lt;/code>&lt;/pre>
&lt;h3 id="7144-موازیسازی-تستها">
7.1.4.4 موازی‌سازی تست‌ها
&lt;a class="anchor" href="#7144-%d9%85%d9%88%d8%a7%d8%b2%db%8c%d8%b3%d8%a7%d8%b2%db%8c-%d8%aa%d8%b3%d8%aa%d9%87%d8%a7">#&lt;/a>
&lt;/h3>
&lt;p>Go به‌صورت بومی از اجرای هم‌زمان تست‌ها پشتیبانی می‌کند. با استفاده از &lt;code>t.Parallel()&lt;/code> می‌توان تست‌ها را به‌صورت مستقل و موازی اجرا کرد، به‌ویژه مفید برای تست‌هایی که داده‌ها یا منابع مشترک ندارند:&lt;/p>
&lt;pre>&lt;code class="language-go">func TestFastOperation(t *testing.T) {
t.Parallel()
// اجرای تست
}
&lt;/code>&lt;/pre>
&lt;p>در صورتی که تست‌هایی با منابع مشترک دارید، باید از &lt;span class="tooltip" data-tooltip="sync primitives" ontouchend="toggleTooltip(this)">سینک&lt;/span>
مانند Mutex یا channel برای کنترل استفاده کنید.&lt;/p>
&lt;h3 id="7145-قرارداد-نامگذاری-تستها">
7.1.4.5 قرارداد نام‌گذاری تست‌ها
&lt;a class="anchor" href="#7145-%d9%82%d8%b1%d8%a7%d8%b1%d8%af%d8%a7%d8%af-%d9%86%d8%a7%d9%85%da%af%d8%b0%d8%a7%d8%b1%db%8c-%d8%aa%d8%b3%d8%aa%d9%87%d8%a7">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>تمام تست‌ها باید با &lt;code>Test&lt;/code> شروع شوند.&lt;/li>
&lt;li>تست‌های بنچمارک باید با &lt;code>Benchmark&lt;/code> شروع شوند و از &lt;code>*testing.B&lt;/code> استفاده کنند.&lt;/li>
&lt;li>تست‌های فازی باید با &lt;code>Fuzz&lt;/code> شروع شوند و از &lt;code>*testing.F&lt;/code> استفاده کنند.&lt;/li>
&lt;li>استفاده از اسم‌های معنادار برای تست‌ها باعث خوانایی بهتر کد و گزارش‌ها می‌شود.&lt;/li>
&lt;/ul>
&lt;p>مثال‌های معتبر:&lt;/p>
&lt;pre>&lt;code class="language-go">func BenchmarkSort(b *testing.B) { ... }
func FuzzParseDate(f *testing.F) { ... }
&lt;/code>&lt;/pre>
&lt;h3 id="7146-تستهای-بدون-تست-واقعی">
7.1.4.6 تست‌های بدون تست واقعی
&lt;a class="anchor" href="#7146-%d8%aa%d8%b3%d8%aa%d9%87%d8%a7%db%8c-%d8%a8%d8%af%d9%88%d9%86-%d8%aa%d8%b3%d8%aa-%d9%88%d8%a7%d9%82%d8%b9%db%8c">#&lt;/a>
&lt;/h3>
&lt;p>گاهی ممکن است نیاز باشد یک تست خالی نوشته شود فقط برای اطمینان از اینکه برنامه کامپایل می‌شود یا فقط هدف خاصی را بررسی کند. در این موارد، می‌توان از &lt;code>t.Skip()&lt;/code> استفاده کرد:&lt;/p>
&lt;pre>&lt;code class="language-go">func TestStub(t *testing.T) {
t.Skip(&amp;quot;implementation pending&amp;quot;)
}
&lt;/code>&lt;/pre>
&lt;h2 id="715-مقایسه-با-زبانهای-دیگر">
7.1.5 مقایسه با زبان‌های دیگر
&lt;a class="anchor" href="#715-%d9%85%d9%82%d8%a7%db%8c%d8%b3%d9%87-%d8%a8%d8%a7-%d8%b2%d8%a8%d8%a7%d9%86%d9%87%d8%a7%db%8c-%d8%af%db%8c%da%af%d8%b1">#&lt;/a>
&lt;/h2>
&lt;p>زبان Go رویکردی ساده، سریع و بی‌واسطه به تست‌نویسی دارد که آن را از بسیاری از زبان‌های رایج توسعه نرم‌افزار متمایز می‌کند. در حالی که برخی زبان‌ها با استفاده از چارچوب‌های سنگین یا ابزارهای جانبی به سراغ تست می‌روند، Go تست را به‌عنوان بخشی از طراحی زبان در نظر گرفته است. در این بخش، نگاهی تطبیقی به روش تست‌نویسی در Go و چند زبان دیگر می‌اندازیم.&lt;/p>
&lt;h3 id="7151-مقایسه-با-python">
7.1.5.1 مقایسه با Python
&lt;a class="anchor" href="#7151-%d9%85%d9%82%d8%a7%db%8c%d8%b3%d9%87-%d8%a8%d8%a7-python">#&lt;/a>
&lt;/h3>
&lt;p>در زبان Python، تست‌نویسی اغلب با استفاده از کتابخانه‌هایی مانند &lt;code>unittest&lt;/code>, &lt;code>pytest&lt;/code>, یا &lt;code>nose&lt;/code> انجام می‌شود. اگرچه این ابزارها قدرتمند هستند و ویژگی‌هایی مانند تشخیص خودکار، fixture injection و assert پیشرفته دارند، اما معمولاً نیاز به نصب و پیکربندی اولیه دارند. در مقابل، Go از ابزار داخلی &lt;code>testing&lt;/code> استفاده می‌کند که بدون وابستگی و با دستور &lt;code>go test&lt;/code> قابل استفاده است.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>ویژگی&lt;/th>
&lt;th>Go&lt;/th>
&lt;th>Python + pytest&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>ابزار داخلی&lt;/td>
&lt;td>بله&lt;/td>
&lt;td>خیر&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>assert پیشرفته&lt;/td>
&lt;td>خیر (با &lt;code>if&lt;/code>)&lt;/td>
&lt;td>بله&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>سرعت اجرا&lt;/td>
&lt;td>بسیار بالا&lt;/td>
&lt;td>معمولی&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>منحنی یادگیری&lt;/td>
&lt;td>بسیار ساده&lt;/td>
&lt;td>نسبتاً متوسط&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="7152-مقایسه-با-java">
7.1.5.2 مقایسه با Java
&lt;a class="anchor" href="#7152-%d9%85%d9%82%d8%a7%db%8c%d8%b3%d9%87-%d8%a8%d8%a7-java">#&lt;/a>
&lt;/h3>
&lt;p>در Java، تست‌نویسی معمولاً با استفاده از چارچوب‌هایی مانند &lt;code>JUnit&lt;/code> یا &lt;code>TestNG&lt;/code> انجام می‌شود. این چارچوب‌ها مبتنی بر annotation و reflection هستند، که در Go وجود ندارد. تعریف یک تست ساده در Java نیازمند کلاس، annotation و ساختار نسبتاً سنگینی است، در حالی که در Go یک تابع ساده کافی است. از طرفی ابزارهای Java برای پروژه‌های پیچیده‌تر امکانات بیشتری دارند، اما این مزیت همراه با پیچیدگی نیز هست.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>ویژگی&lt;/th>
&lt;th>Go&lt;/th>
&lt;th>Java + JUnit&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>نیاز به annotation&lt;/td>
&lt;td>خیر&lt;/td>
&lt;td>بله&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>نوشتار ساده&lt;/td>
&lt;td>بله&lt;/td>
&lt;td>خیر&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>یکپارچگی با زبان&lt;/td>
&lt;td>کامل&lt;/td>
&lt;td>از طریق چارچوب جداگانه&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>زمان اجرا&lt;/td>
&lt;td>سریع&lt;/td>
&lt;td>کندتر&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="7153-مقایسه-با-javascript--typescript">
7.1.5.3 مقایسه با JavaScript / TypeScript
&lt;a class="anchor" href="#7153-%d9%85%d9%82%d8%a7%db%8c%d8%b3%d9%87-%d8%a8%d8%a7-javascript--typescript">#&lt;/a>
&lt;/h3>
&lt;p>در JavaScript یا TypeScript، ابزارهای متنوعی برای تست وجود دارد مانند &lt;code>Jest&lt;/code>, &lt;code>Mocha&lt;/code>, &lt;code>Chai&lt;/code>, &lt;code>Vitest&lt;/code>. اگرچه این ابزارها تجربه تست بسیار مدرنی فراهم می‌کنند (مانند snapshot testing و mocking خودکار)، اما پیکربندی آن‌ها در پروژه‌های بزرگ می‌تواند زمان‌بر باشد. از طرف دیگر، وجود اکوسیستم‌های پیچیده باعث می‌شود گاهی فهمیدن منطق تست دشوار شود. Go از این پیچیدگی اجتناب کرده و تجربه‌ای ساده، قابل پیش‌بینی و سریع ارائه می‌دهد.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>ویژگی&lt;/th>
&lt;th>Go&lt;/th>
&lt;th>JavaScript + Jest&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>نصب ابزار&lt;/td>
&lt;td>لازم نیست&lt;/td>
&lt;td>ضروری&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>snapshot testing&lt;/td>
&lt;td>ندارد&lt;/td>
&lt;td>بله&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>mocking داخلی&lt;/td>
&lt;td>ندارد&lt;/td>
&lt;td>بله&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>خطایابی آسان تست‌ها&lt;/td>
&lt;td>بله&lt;/td>
&lt;td>گاهی دشوار&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="7154-مقایسه-با-rust">
7.1.5.4 مقایسه با Rust
&lt;a class="anchor" href="#7154-%d9%85%d9%82%d8%a7%db%8c%d8%b3%d9%87-%d8%a8%d8%a7-rust">#&lt;/a>
&lt;/h3>
&lt;p>در Rust، تست‌ها معمولاً درون ماژول‌هایی با annotation &lt;code>#[cfg(test)]&lt;/code> و ماکروهای &lt;code>#[test]&lt;/code> نوشته می‌شوند. مانند Go، تست بخشی از زبان است و اجرای آن با دستور &lt;code>cargo test&lt;/code> انجام می‌شود. از این نظر، رویکرد Rust بسیار به Go نزدیک است. با این حال، تعریف ماژول‌ها و ویژگی‌های زبانی Rust ممکن است منحنی یادگیری بالاتری داشته باشد، در حالی که Go از سادگی بیشتری برخوردار است.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>ویژگی&lt;/th>
&lt;th>Go&lt;/th>
&lt;th>Rust&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>ابزار تست داخلی&lt;/td>
&lt;td>بله&lt;/td>
&lt;td>بله&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>تست داخل ماژول&lt;/td>
&lt;td>اختیاری&lt;/td>
&lt;td>بله&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>macro و annotation&lt;/td>
&lt;td>ندارد&lt;/td>
&lt;td>دارد&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>پیچیدگی یادگیری&lt;/td>
&lt;td>پایین&lt;/td>
&lt;td>متوسط به بالا&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="7155-نتیجهگیری-مقایسه">
7.1.5.5 نتیجه‌گیری مقایسه
&lt;a class="anchor" href="#7155-%d9%86%d8%aa%db%8c%d8%ac%d9%87%da%af%db%8c%d8%b1%db%8c-%d9%85%d9%82%d8%a7%db%8c%d8%b3%d9%87">#&lt;/a>
&lt;/h3>
&lt;p>رویکرد Go به تست‌نویسی کاملاً عمل‌گرا، ساده و بدون وابستگی به ابزارهای جانبی است. این سادگی باعث می‌شود تیم‌های توسعه بتوانند سریع‌تر شروع به نوشتن تست کنند و فرآیند اجرای تست‌ها نیز سبک، سریع و قابل‌اتکا باقی بماند. در حالی که بسیاری از زبان‌ها بر غنای ابزارهای تست تکیه می‌کنند، Go با ارائه یک راهکار ساده اما کارآمد، توسعه‌دهنده را به نوشتن تست تشویق می‌کند بدون اینکه او را از مسیر تولید منحرف کند.&lt;/p>
&lt;h2 id="716-آزمونگر-ایدهآل-گولنگنویس-چرا-باید-تست-بنویسیم">
7.1.6 آزمونگر ایده‌آل گولنگ‌نویس: چرا باید تست بنویسیم؟
&lt;a class="anchor" href="#716-%d8%a2%d8%b2%d9%85%d9%88%d9%86%da%af%d8%b1-%d8%a7%db%8c%d8%af%d9%87%d8%a2%d9%84-%da%af%d9%88%d9%84%d9%86%da%af%d9%86%d9%88%db%8c%d8%b3-%da%86%d8%b1%d8%a7-%d8%a8%d8%a7%db%8c%d8%af-%d8%aa%d8%b3%d8%aa-%d8%a8%d9%86%d9%88%db%8c%d8%b3%db%8c%d9%85">#&lt;/a>
&lt;/h2>
&lt;p>در اکوسیستم Go، تست‌نویسی نه یک مهارت اضافه بلکه بخشی از هویت یک توسعه‌دهنده حرفه‌ای محسوب می‌شود. اگرچه ابزارها و کتابخانه‌ها نوشتن تست را بسیار آسان کرده‌اند، اما نوشتن تست صرفاً به خاطر وجود ابزار انجام نمی‌شود. در واقع، نوشتن تست در Go به دلایل مهم‌تری ضرورت دارد.&lt;/p>
&lt;h3 id="7161-تضمین-رفتار-سیستم">
7.1.6.1 تضمین رفتار سیستم
&lt;a class="anchor" href="#7161-%d8%aa%d8%b6%d9%85%db%8c%d9%86-%d8%b1%d9%81%d8%aa%d8%a7%d8%b1-%d8%b3%db%8c%d8%b3%d8%aa%d9%85">#&lt;/a>
&lt;/h3>
&lt;p>هر خط تست، تضمینی است برای آنکه یک ویژگی مشخص از سیستم در شرایط خاص به درستی عمل می‌کند. وقتی تستی می‌نویسیم، در واقع داریم تعریف می‌کنیم که چه چیزی قابل قبول است و چه چیزی نیست. بدون تست، تغییر دادن یا توسعه کد به یک فعالیت پرریسک تبدیل می‌شود.&lt;/p>
&lt;h3 id="7162-مستندسازی-زنده">
7.1.6.2 مستندسازی زنده
&lt;a class="anchor" href="#7162-%d9%85%d8%b3%d8%aa%d9%86%d8%af%d8%b3%d8%a7%d8%b2%db%8c-%d8%b2%d9%86%d8%af%d9%87">#&lt;/a>
&lt;/h3>
&lt;p>تست‌های خوب، همانند مستندات زنده هستند. آن‌ها نشان می‌دهند که یک تابع یا ماژول در برابر چه ورودی‌هایی چه رفتاری دارد. این نوع مستندسازی برخلاف توضیحات متنی، خود را با تغییرات کد به‌روزرسانی می‌کند و در صورت عدم هماهنگی، با شکست در اجرا هشدار می‌دهد.&lt;/p>
&lt;h3 id="7163-کاهش-هزینههای-نگهداری">
7.1.6.3 کاهش هزینه‌های نگهداری
&lt;a class="anchor" href="#7163-%da%a9%d8%a7%d9%87%d8%b4-%d9%87%d8%b2%db%8c%d9%86%d9%87%d9%87%d8%a7%db%8c-%d9%86%da%af%d9%87%d8%af%d8%a7%d8%b1%db%8c">#&lt;/a>
&lt;/h3>
&lt;p>کد بدون تست، در بلندمدت هزینه‌بر خواهد شد؛ چرا که کوچک‌ترین تغییر در آن نیازمند تحلیل مجدد و اعتماد به حافظه یا شهود توسعه‌دهنده است. در حالی که وجود تست‌های پوششی، هزینه تغییر، اشکال‌زدایی و توسعه‌ی بیشتر را به‌شدت کاهش می‌دهد.&lt;/p>
&lt;h3 id="7164-ایجاد-فرهنگ-توسعه-حرفهای">
7.1.6.4 ایجاد فرهنگ توسعه حرفه‌ای
&lt;a class="anchor" href="#7164-%d8%a7%db%8c%d8%ac%d8%a7%d8%af-%d9%81%d8%b1%d9%87%d9%86%da%af-%d8%aa%d9%88%d8%b3%d8%b9%d9%87-%d8%ad%d8%b1%d9%81%d9%87%d8%a7%db%8c">#&lt;/a>
&lt;/h3>
&lt;p>نوشتن تست فقط مهارت نیست، بلکه نشانه‌ی یک طرز فکر است. توسعه‌دهنده‌ای که تست می‌نویسد، به کیفیت، آینده‌پذیری و قابل‌اعتماد بودن سیستم اهمیت می‌دهد. در دنیای Go، این رویکرد از یک توصیه فراتر رفته و به یک عرف تبدیل شده است.&lt;/p>
&lt;h2 id="717-ابزار-go-test-و-نحوه-اجرای-تستها-از-خط-فرمان">
7.1.7 ابزار go test و نحوه اجرای تست‌ها از خط فرمان
&lt;a class="anchor" href="#717-%d8%a7%d8%a8%d8%b2%d8%a7%d8%b1-go-test-%d9%88-%d9%86%d8%ad%d9%88%d9%87-%d8%a7%d8%ac%d8%b1%d8%a7%db%8c-%d8%aa%d8%b3%d8%aa%d9%87%d8%a7-%d8%a7%d8%b2-%d8%ae%d8%b7-%d9%81%d8%b1%d9%85%d8%a7%d9%86">#&lt;/a>
&lt;/h2>
&lt;p>در زبان Go، اجرای تست‌ها از طریق ابزار رسمی &lt;span class="tooltip" data-tooltip="go test command" ontouchend="toggleTooltip(this)">go test&lt;/span>
انجام می‌شود. این ابزار بخشی از زنجیره ابزارهای CLI زبان است و بدون نیاز به نصب هیچ ابزار اضافه‌ای، امکان نوشتن، اجرا و گزارش‌گیری از تست‌ها را فراهم می‌کند. در این بخش به بررسی کامل نحوه استفاده از &lt;code>go test&lt;/code>، همراه با فلگ‌ها، گزینه‌ها و حالت‌های مختلف اجرای آن می‌پردازیم.&lt;/p>
&lt;h3 id="7171-اجرای-ساده-تستها">
7.1.7.1 اجرای ساده تست‌ها
&lt;a class="anchor" href="#7171-%d8%a7%d8%ac%d8%b1%d8%a7%db%8c-%d8%b3%d8%a7%d8%af%d9%87-%d8%aa%d8%b3%d8%aa%d9%87%d8%a7">#&lt;/a>
&lt;/h3>
&lt;p>برای اجرای تست‌های موجود در یک بسته (پوشه فعلی)، تنها کافی‌ست در همان مسیر دستور زیر را وارد کنید:&lt;/p>
&lt;pre>&lt;code class="language-bash">go test
&lt;/code>&lt;/pre>
&lt;p>این دستور تمام فایل‌های &lt;code>_test.go&lt;/code> را کامپایل کرده، به صورت خودکار &lt;code>go vet&lt;/code> را اجرا می‌کند و سپس تست‌ها را اجرا می‌کند.&lt;/p>
&lt;p>خروجی به‌صورت خلاصه نمایش داده می‌شود:&lt;/p>
&lt;pre>&lt;code>ok mymodule/mypkg 0.011s
&lt;/code>&lt;/pre>
&lt;p>اگر تست‌ها شکست بخورند، خروجی با &lt;code>FAIL&lt;/code> نمایش داده می‌شود.&lt;/p>
&lt;hr>
&lt;h3 id="7172-اجرای-انتخابی-تستها-با--run">
7.1.7.2 اجرای انتخابی تست‌ها با -run
&lt;a class="anchor" href="#7172-%d8%a7%d8%ac%d8%b1%d8%a7%db%8c-%d8%a7%d9%86%d8%aa%d8%ae%d8%a7%d8%a8%db%8c-%d8%aa%d8%b3%d8%aa%d9%87%d8%a7-%d8%a8%d8%a7--run">#&lt;/a>
&lt;/h3>
&lt;p>می‌توان یک یا چند تابع تست خاص را با استفاده از الگوی منظم (regex) و فلگ &lt;code>-run&lt;/code> اجرا کرد:&lt;/p>
&lt;pre>&lt;code class="language-bash">go test -run=TestAdd
go test -run='Add|Sub'
&lt;/code>&lt;/pre>
&lt;blockquote>
&lt;p>نکته: تابع تست باید دقیقاً با الگوی &lt;code>TestXxx&lt;/code> تعریف شده باشد.&lt;/p>&lt;/blockquote>
&lt;h3 id="7173-تستهای-موازی-و-مدیریت-زمان">
7.1.7.3 تست‌های موازی و مدیریت زمان
&lt;a class="anchor" href="#7173-%d8%aa%d8%b3%d8%aa%d9%87%d8%a7%db%8c-%d9%85%d9%88%d8%a7%d8%b2%db%8c-%d9%88-%d9%85%d8%af%db%8c%d8%b1%db%8c%d8%aa-%d8%b2%d9%85%d8%a7%d9%86">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>برای تنظیم حداکثر تعداد تست‌هایی که می‌توانند هم‌زمان اجرا شوند:&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-bash">go test -parallel=4
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>برای محدود کردن زمان اجرای هر تست یا کل تست‌ها:&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-bash">go test -timeout=5s
&lt;/code>&lt;/pre>
&lt;p>در صورت عبور از این زمان، پروسه تست با خطا قطع می‌شود.&lt;/p>
&lt;hr>
&lt;h3 id="7174-سنجش-پوشش-کد-با--cover">
7.1.7.4 سنجش پوشش کد با -cover
&lt;a class="anchor" href="#7174-%d8%b3%d9%86%d8%ac%d8%b4-%d9%be%d9%88%d8%b4%d8%b4-%da%a9%d8%af-%d8%a8%d8%a7--cover">#&lt;/a>
&lt;/h3>
&lt;p>برای مشاهده درصد پوشش کد توسط تست‌ها:&lt;/p>
&lt;pre>&lt;code class="language-bash">go test -cover
&lt;/code>&lt;/pre>
&lt;p>برای تولید فایل پوشش:&lt;/p>
&lt;pre>&lt;code class="language-bash">go test -coverprofile=coverage.out
&lt;/code>&lt;/pre>
&lt;p>و برای مشاهده پوشش به صورت HTML:&lt;/p>
&lt;pre>&lt;code class="language-bash">go tool cover -html=coverage.out
&lt;/code>&lt;/pre>
&lt;hr>
&lt;h3 id="7175-اجرای-بنچمارکها-با--bench">
7.1.7.5 اجرای بنچمارک‌ها با -bench
&lt;a class="anchor" href="#7175-%d8%a7%d8%ac%d8%b1%d8%a7%db%8c-%d8%a8%d9%86%da%86%d9%85%d8%a7%d8%b1%da%a9%d9%87%d8%a7-%d8%a8%d8%a7--bench">#&lt;/a>
&lt;/h3>
&lt;p>برای اجرای بنچمارک‌ها از فلگ &lt;code>-bench&lt;/code> استفاده می‌شود. برای اجرای همه بنچمارک‌ها:&lt;/p>
&lt;pre>&lt;code class="language-bash">go test -bench=.
&lt;/code>&lt;/pre>
&lt;p>برای اجرای بنچمارک خاص:&lt;/p>
&lt;pre>&lt;code class="language-bash">go test -bench=BenchmarkSort
&lt;/code>&lt;/pre>
&lt;p>با فلگ &lt;code>-benchmem&lt;/code> می‌توان اطلاعات حافظه مصرفی را نیز دریافت کرد:&lt;/p>
&lt;pre>&lt;code class="language-bash">go test -bench=. -benchmem
&lt;/code>&lt;/pre>
&lt;hr>
&lt;h3 id="7176-تستهای-فازی-با--fuzz">
7.1.7.6 تست‌های فازی با -fuzz
&lt;a class="anchor" href="#7176-%d8%aa%d8%b3%d8%aa%d9%87%d8%a7%db%8c-%d9%81%d8%a7%d8%b2%db%8c-%d8%a8%d8%a7--fuzz">#&lt;/a>
&lt;/h3>
&lt;p>برای اجرای تست فازی:&lt;/p>
&lt;pre>&lt;code class="language-bash">go test -fuzz=FuzzParse
&lt;/code>&lt;/pre>
&lt;p>برای محدود کردن زمان اجرای فاز فازی:&lt;/p>
&lt;pre>&lt;code class="language-bash">go test -fuzz=FuzzParse -fuzztime=20s
&lt;/code>&lt;/pre>
&lt;p>در صورت یافتن نمونه‌ای که باعث شکست تست شود، داده تولیدشده ذخیره می‌شود و در اجرای بعدی بررسی خواهد شد.&lt;/p>
&lt;hr>
&lt;h3 id="7177-ترکیبهای-رایج-در-پروژههای-واقعی">
7.1.7.7 ترکیب‌های رایج در پروژه‌های واقعی
&lt;a class="anchor" href="#7177-%d8%aa%d8%b1%da%a9%db%8c%d8%a8%d9%87%d8%a7%db%8c-%d8%b1%d8%a7%db%8c%d8%ac-%d8%af%d8%b1-%d9%be%d8%b1%d9%88%da%98%d9%87%d9%87%d8%a7%db%8c-%d9%88%d8%a7%d9%82%d8%b9%db%8c">#&lt;/a>
&lt;/h3>
&lt;p>در بسیاری از پروژه‌ها از ترکیب چند فلگ استفاده می‌شود. مثال‌هایی از ترکیب‌های رایج:&lt;/p>
&lt;pre>&lt;code class="language-bash">go test -v ./... # اجرای کامل تست‌ها به‌صورت verbose
go test -run=TestHandler -cover ./handlers # تست handler خاص با پوشش کد
go test -bench=BenchmarkEncode -benchmem # اجرای بنچمارک به همراه مصرف حافظه
go test -fuzz=FuzzMyFunc -fuzztime=1m # اجرای تست فازی به مدت یک دقیقه
go test -count=1 # غیرفعال‌سازی cache
&lt;/code>&lt;/pre>
&lt;hr>
&lt;h3 id="7178-حالتهای-اجرای-go-test">
7.1.7.8 حالت‌های اجرای go test
&lt;a class="anchor" href="#7178-%d8%ad%d8%a7%d9%84%d8%aa%d9%87%d8%a7%db%8c-%d8%a7%d8%ac%d8%b1%d8%a7%db%8c-go-test">#&lt;/a>
&lt;/h3>
&lt;p>&lt;code>go test&lt;/code> در دو حالت مختلف اجرا می‌شود:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Local Directory Mode&lt;/strong>: بدون آرگومان بسته اجرا می‌شود و فقط پوشه فعلی را تست می‌کند:&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-bash">go test
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>&lt;strong>Package List Mode&lt;/strong>: با مشخص‌کردن مسیر یا پکیج اجرا می‌شود:&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-bash">go test ./...
go test mymodule/utils
&lt;/code>&lt;/pre>
&lt;p>در حالت دوم، سیستم &lt;span class="tooltip" data-tooltip="test caching" ontouchend="toggleTooltip(this)">کَش تست&lt;/span>
فعال می‌شود و تست‌های قبلاً موفق اجرا نشده و نتیجه cache نمایش داده می‌شود (با برچسب &lt;code>(cached)&lt;/code>).&lt;/p>
&lt;h3 id="7179-بررسی-race-condition-با-فلگ--race">
7.1.7.9 بررسی race condition با فلگ -race
&lt;a class="anchor" href="#7179-%d8%a8%d8%b1%d8%b1%d8%b3%db%8c-race-condition-%d8%a8%d8%a7-%d9%81%d9%84%da%af--race">#&lt;/a>
&lt;/h3>
&lt;p>در برنامه‌های همزمان، احتمال بروز &lt;span class="tooltip" data-tooltip="race condition" ontouchend="toggleTooltip(this)">شرایط مسابقه&lt;/span>
وجود دارد؛ یعنی دو یا چند goroutine به‌صورت ناهمزمان به یک متغیر مشترک دسترسی پیدا کنند و حداقل یکی از آن‌ها آن را تغییر دهد. این نوع باگ‌ها بسیار خطرناک هستند، زیرا در زمان اجرا قابل پیش‌بینی نیستند و معمولاً فقط در برخی شرایط خاص خود را نشان می‌دهند.&lt;/p>
&lt;p>برای شناسایی چنین مشکلاتی در Go، می‌توان از فلگ &lt;code>-race&lt;/code> هنگام اجرای تست‌ها استفاده کرد. این فلگ باعث می‌شود کامپایلر، برنامه را به‌گونه‌ای کامپایل کند که دسترسی به حافظه در زمان اجرا بررسی شود.&lt;/p>
&lt;h4 id="نحوه-استفاده">
نحوه استفاده:
&lt;a class="anchor" href="#%d9%86%d8%ad%d9%88%d9%87-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87">#&lt;/a>
&lt;/h4>
&lt;pre>&lt;code class="language-bash">go test -race
&lt;/code>&lt;/pre>
&lt;p>یا برای اجرای تست‌های یک پکیج خاص:&lt;/p>
&lt;pre>&lt;code class="language-bash">go test -race ./pkg/concurrent
&lt;/code>&lt;/pre>
&lt;p>در صورت وجود race، خروجی‌ای مشابه زیر نمایش داده می‌شود:&lt;/p>
&lt;pre>&lt;code>==================
WARNING: DATA RACE
Read at 0x00c0000b2000 by goroutine 6:
main.main.func1()
Previous write at 0x00c0000b2000 by goroutine 5:
main.main.func2()
==================
&lt;/code>&lt;/pre>
&lt;h4 id="نکات-مهم">
نکات مهم:
&lt;a class="anchor" href="#%d9%86%da%a9%d8%a7%d8%aa-%d9%85%d9%87%d9%85">#&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>استفاده از &lt;code>-race&lt;/code> باعث کند شدن اجرای تست‌ها (معمولاً 2 تا 5 برابر) و مصرف بیشتر حافظه می‌شود.&lt;/li>
&lt;li>توصیه می‌شود در فرآیند CI، حداقل یک‌بار در روز یا قبل از انتشار نسخه جدید با &lt;code>-race&lt;/code> تست کامل انجام شود.&lt;/li>
&lt;li>تشخیص race توسط این ابزار معمولاً دقیق است، اما به صورت صددرصد تضمینی نیست.&lt;/li>
&lt;/ul></description></item><item><author/><title>7.2 تست واحد (Unit Test)</title><link>https://book.gofarsi.ir/chapter-7/go-unit-testing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-7/go-unit-testing/</guid><description>&lt;p>تست واحد یکی از مهم‌ترین و بنیادی‌ترین ابزارهایی‌ست که یک توسعه‌دهنده حرفه‌ای در اختیار دارد. این نوع تست، تنها بر یک «واحد» مستقل از منطق برنامه تمرکز می‌کند—معمولاً یک تابع، یک متد، یا یک ساختار کوچک از کد که بدون وابستگی به منابع خارجی قابل بررسی است. هدف اصلی از نوشتن تست واحد، اطمینان از صحت رفتار دقیق و قابل پیش‌بینی کد در مواجهه با ورودی‌های مشخص و شرایط کنترل‌شده است.&lt;/p>
&lt;p>در زبان Go، فلسفه طراحی بر سادگی، سرعت و ابزارهای داخلی استوار است؛ این رویکرد به‌وضوح در ساختار تست‌نویسی نیز دیده می‌شود. بدون نیاز به هیچ‌گونه چارچوب یا ابزار جانبی، می‌توان تنها با استفاده از فایل‌های &lt;code>_test.go&lt;/code> و توابع &lt;code>TestXxx(t *testing.T)&lt;/code> تست‌های کاملی برای هر ماژول نوشت. این تست‌ها به‌صورت یکپارچه با ابزار رسمی &lt;code>go test&lt;/code> اجرا می‌شوند و خروجی‌ای دقیق، سریع و قابل‌درک ارائه می‌دهند.&lt;/p>
&lt;p>ویژگی‌هایی مانند اجرای تست‌های جداگانه با &lt;code>-run&lt;/code>، دسته‌بندی تست‌ها با &lt;code>t.Run&lt;/code>، پوشش کد با &lt;code>-cover&lt;/code>، تست‌های موازی با &lt;code>t.Parallel()&lt;/code> و پشتیبانی کامل از ساختارهای ساده Go، باعث شده‌اند که تست واحد نه فقط یک ابزار، بلکه یک عادت طبیعی در سبک توسعه Go محسوب شود. در عمل، یونیت تست‌ها نه‌تنها در کشف باگ‌ها مؤثرند، بلکه مرجعی قابل‌اطمینان برای تعریف رفتار و مستندسازی سیستم نیز به‌شمار می‌آیند.&lt;/p>
&lt;p>در ادامه این بخش، ابتدا به ساختار پایه تست واحد در Go می‌پردازیم، سپس الگوهای رایج، ضدالگوها، نکات پیشرفته و مثال‌هایی از دنیای واقعی را بررسی خواهیم کرد.&lt;/p>
&lt;blockquote class="book-hint info">
&lt;p>&lt;strong>به نقل از ویکی پدیا&lt;/strong>
&lt;strong>آزمون واحد&lt;/strong> (به &lt;a href="https://fa.wikipedia.org/wiki/%D8%B2%D8%A8%D8%A7%D9%86_%D8%A7%D9%86%DA%AF%D9%84%DB%8C%D8%B3%DB%8C" title="زبان انگلیسی">انگلیسی&lt;/a>: unit testing) در &lt;a href="https://fa.wikipedia.org/wiki/%D8%A8%D8%B1%D9%86%D8%A7%D9%85%D9%87%E2%80%8C%D9%86%D9%88%DB%8C%D8%B3%DB%8C" title="برنامه‌نویسی">برنامه‌نویسی رایانه‌ای&lt;/a>، نوعی &lt;a href="https://fa.wikipedia.org/wiki/%D8%A2%D8%B2%D9%85%D9%88%D9%86_%D9%86%D8%B1%D9%85%E2%80%8C%D8%A7%D9%81%D8%B2%D8%A7%D8%B1" title="آزمون نرم‌افزار">آزمون نرم‌افزار&lt;/a> است که در آن «واحدهای منفرد &lt;a href="https://fa.wikipedia.org/wiki/%DA%A9%D8%AF_%D9%85%D9%86%D8%A8%D8%B9" title="کد منبع">کد منبع&lt;/a>» مورد آزمون قرار می‌گیرند تا تعیین شود که آیا برای استفاده سازگار هستند یا نه. در اینجا «واحد منفرد کد منبع» یعنی مجموعه‌ای از یک یا بیشتر &lt;a href="https://fa.wikipedia.org/wiki/%D8%A8%D8%B1%D9%86%D8%A7%D9%85%D9%87%E2%80%8C%D9%86%D9%88%DB%8C%D8%B3%DB%8C_%D9%BE%D9%88%D8%AF%D9%85%D8%A7%D9%86%DB%8C" title="برنامه‌نویسی پودمانی">پودمان&lt;/a> برنامه رایانه‌ای، همراه با داده کنترلی مرتبط، &lt;a href="https://fa.wikipedia.org/wiki/%D8%B1%D9%88%DB%8C%D9%87_%5c%28%D8%B9%D9%84%D9%88%D9%85_%D8%B1%D8%A7%DB%8C%D8%A7%D9%86%D9%87%5c%29" title="رویه (علوم رایانه)">رویه&lt;/a> استفاده، و رویه عملیاتی.&lt;a href="https://fa.wikipedia.org/wiki/%D8%A2%D8%B2%D9%85%D9%88%D9%86_%D9%88%D8%A7%D8%AD%D8%AF#cite_note-kolawa-1">[۱]&lt;/a>&lt;/p>
&lt;p>آزمون‌های واحد معمولاً آزمون‌هایی &lt;a href="https://fa.wikipedia.org/wiki/%D8%A7%D8%A8%D8%B2%D8%A7%D8%B1_%D8%AA%D8%B3%D8%AA_%D9%86%D8%B1%D9%85%E2%80%8C%D8%A7%D9%81%D8%B2%D8%A7%D8%B1" title="ابزار تست نرم‌افزار">خودکار&lt;/a> هستند که توسط &lt;a href="https://fa.wikipedia.org/wiki/%D8%AA%D9%88%D8%B3%D8%B9%D9%87%E2%80%8C%D8%AF%D9%87%D9%86%D8%AF%D9%87_%D9%86%D8%B1%D9%85%E2%80%8C%D8%A7%D9%81%D8%B2%D8%A7%D8%B1" title="توسعه‌دهنده نرم‌افزار">توسعه‌دهنده نرم‌افزار&lt;/a> نوشته و اجرا می‌شوند، این آزمون برای آن انجام می‌شود تا اطمینان حاصل شود که بخشی از یک برنامه‌کاربردی (که «واحد» نام دارد) &lt;a href="https://fa.wikipedia.org/wiki/%D8%B7%D8%B1%D8%A7%D8%AD%DB%8C_%D9%86%D8%B1%D9%85%E2%80%8C%D8%A7%D9%81%D8%B2%D8%A7%D8%B1" title="طراحی نرم‌افزار">طراحی&lt;/a> را برآورده کرده‌است و رفتارش هم براساس انتظار است.&lt;a href="https://fa.wikipedia.org/wiki/%D8%A2%D8%B2%D9%85%D9%88%D9%86_%D9%88%D8%A7%D8%AD%D8%AF#cite_note-hamill-2">[۲]&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h2 id="721-اصول-نوشتن-تستهای-واحد-در-go-و-ساختار-آنها">
7.2.1 اصول نوشتن تست‌های واحد در Go و ساختار آن‌ها
&lt;a class="anchor" href="#721-%d8%a7%d8%b5%d9%88%d9%84-%d9%86%d9%88%d8%b4%d8%aa%d9%86-%d8%aa%d8%b3%d8%aa%d9%87%d8%a7%db%8c-%d9%88%d8%a7%d8%ad%d8%af-%d8%af%d8%b1-go-%d9%88-%d8%b3%d8%a7%d8%ae%d8%aa%d8%a7%d8%b1-%d8%a2%d9%86%d9%87%d8%a7">#&lt;/a>
&lt;/h2>
&lt;p>نوشتن تست‌های واحد در زبان Go ساده، شفاف و کاملاً منطبق با فلسفه‌ی طراحی زبان است: حداقل پیچیدگی، حداکثر خوانایی و وابستگی صفر به چارچوب‌های جانبی. در Go، تست‌های واحد در فایل‌هایی با پسوند &lt;code>_test.go&lt;/code> تعریف می‌شوند و باید در همان پکیجی باشند که کد اصلی قرار دارد یا در پکیجی مجزا با پسوند &lt;code>_test&lt;/code> برای جدا‌سازی وابستگی‌ها.&lt;/p>
&lt;p>هر تست واحد باید با تابعی به فرم زیر آغاز شود:&lt;/p>
&lt;pre>&lt;code class="language-go">func TestXxx(t *testing.T)
&lt;/code>&lt;/pre>
&lt;p>که در آن &lt;code>Xxx&lt;/code> می‌تواند هر نام معناداری باشد که با حرف بزرگ آغاز شده است (برای شناسایی توسط ابزار &lt;code>go test&lt;/code>) و پارامتر &lt;code>t&lt;/code> از نوع &lt;span class="tooltip" data-tooltip="*testing.T" ontouchend="toggleTooltip(this)">تی&lt;/span>
بوده و برای مدیریت وضعیت تست به‌کار می‌رود.&lt;/p>
&lt;h3 id="7211-ساختار-پایه-تست-واحد">
7.2.1.1 ساختار پایه تست واحد
&lt;a class="anchor" href="#7211-%d8%b3%d8%a7%d8%ae%d8%aa%d8%a7%d8%b1-%d9%be%d8%a7%db%8c%d9%87-%d8%aa%d8%b3%d8%aa-%d9%88%d8%a7%d8%ad%d8%af">#&lt;/a>
&lt;/h3>
&lt;pre>&lt;code class="language-go">func TestAdd(t *testing.T) {
got := Add(2, 3)
want := 5
if got != want {
t.Errorf(&amp;quot;Add(2,3) = %d; want %d&amp;quot;, got, want)
}
}
&lt;/code>&lt;/pre>
&lt;p>در این مثال ساده:&lt;/p>
&lt;ul>
&lt;li>تابع &lt;code>Add&lt;/code> بررسی می‌شود.&lt;/li>
&lt;li>نتیجه با مقدار مورد انتظار مقایسه شده.&lt;/li>
&lt;li>در صورت مغایرت، پیامی با &lt;code>t.Errorf&lt;/code> ثبت می‌شود که باعث شکست تست می‌گردد.&lt;/li>
&lt;/ul>
&lt;h3 id="7212-نقش-تابع-tfail-terror-و-tfatal">
7.2.1.2 نقش تابع &lt;code>t.Fail&lt;/code>, &lt;code>t.Error&lt;/code>, و &lt;code>t.Fatal&lt;/code>
&lt;a class="anchor" href="#7212-%d9%86%d9%82%d8%b4-%d8%aa%d8%a7%d8%a8%d8%b9-tfail-terror-%d9%88-tfatal">#&lt;/a>
&lt;/h3>
&lt;p>در تست‌های Go چندین روش برای ثبت خطا وجود دارد:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>تابع&lt;/th>
&lt;th>توضیح&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>t.Error&lt;/code>&lt;/td>
&lt;td>ثبت خطا و ادامه اجرای تست&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>t.Errorf&lt;/code>&lt;/td>
&lt;td>مانند &lt;code>t.Error&lt;/code> اما با فرمت‌دهی رشته&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>t.Fail&lt;/code>&lt;/td>
&lt;td>فقط ثبت خطا بدون پیام&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>t.Fatal&lt;/code>&lt;/td>
&lt;td>ثبت خطا و توقف فوری اجرای تابع تست&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>t.Fatalf&lt;/code>&lt;/td>
&lt;td>مانند &lt;code>t.Fatal&lt;/code> با امکان فرمت‌دهی&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>نمونه:&lt;/p>
&lt;pre>&lt;code class="language-go">if err != nil {
t.Fatalf(&amp;quot;unexpected error: %v&amp;quot;, err)
}
&lt;/code>&lt;/pre>
&lt;h3 id="7213-الزامات-ابزار-go-test">
7.2.1.3 الزامات ابزار go test
&lt;a class="anchor" href="#7213-%d8%a7%d9%84%d8%b2%d8%a7%d9%85%d8%a7%d8%aa-%d8%a7%d8%a8%d8%b2%d8%a7%d8%b1-go-test">#&lt;/a>
&lt;/h3>
&lt;p>برای اینکه &lt;code>go test&lt;/code> تست‌ها را شناسایی و اجرا کند:&lt;/p>
&lt;ul>
&lt;li>تابع تست باید با &lt;code>Test&lt;/code> شروع شود.&lt;/li>
&lt;li>آرگومان آن باید دقیقاً &lt;code>t *testing.T&lt;/code> باشد.&lt;/li>
&lt;li>نباید مقدار برگشتی داشته باشد.&lt;/li>
&lt;li>فایل باید پسوند &lt;code>_test.go&lt;/code> داشته باشد.&lt;/li>
&lt;/ul>
&lt;h3 id="7214-نحوه-سازماندهی-فایلها-و-پوشهها">
7.2.1.4 نحوه سازمان‌دهی فایل‌ها و پوشه‌ها
&lt;a class="anchor" href="#7214-%d9%86%d8%ad%d9%88%d9%87-%d8%b3%d8%a7%d8%b2%d9%85%d8%a7%d9%86%d8%af%d9%87%db%8c-%d9%81%d8%a7%db%8c%d9%84%d9%87%d8%a7-%d9%88-%d9%be%d9%88%d8%b4%d9%87%d9%87%d8%a7">#&lt;/a>
&lt;/h3>
&lt;p>در Go، تست‌ها معمولاً در کنار کد اصلی قرار می‌گیرند:&lt;/p>
&lt;pre>&lt;code>calculator/
├── add.go
└── add_test.go
&lt;/code>&lt;/pre>
&lt;p>اما برای تست رفتار خارجی بدون دسترسی به توابع یا متغیرهای داخلی، می‌توان از پکیج &lt;code>mypkg_test&lt;/code> استفاده کرد که نسخه‌ای مجزا از پکیج اصلی بدون دسترسی داخلی است:&lt;/p>
&lt;pre>&lt;code class="language-go">package mypkg_test
&lt;/code>&lt;/pre>
&lt;p>این روش برای نوشتن تست‌های سطح بالاتر یا رفتار مصرف‌کننده بسیار مناسب است.&lt;/p>
&lt;h3 id="7215-اجرای-تست">
7.2.1.5 اجرای تست
&lt;a class="anchor" href="#7215-%d8%a7%d8%ac%d8%b1%d8%a7%db%8c-%d8%aa%d8%b3%d8%aa">#&lt;/a>
&lt;/h3>
&lt;p>اجرای ساده:&lt;/p>
&lt;pre>&lt;code class="language-bash">go test
&lt;/code>&lt;/pre>
&lt;p>اجرای یک تابع خاص:&lt;/p>
&lt;pre>&lt;code class="language-bash">go test -run=TestAdd
&lt;/code>&lt;/pre>
&lt;p>اجرا با جزئیات بیشتر (verbose):&lt;/p>
&lt;pre>&lt;code class="language-bash">go test -v
&lt;/code>&lt;/pre>
&lt;h3 id="7216-چرا-این-ساختار-موفق-است">
7.2.1.6 چرا این ساختار موفق است؟
&lt;a class="anchor" href="#7216-%da%86%d8%b1%d8%a7-%d8%a7%db%8c%d9%86-%d8%b3%d8%a7%d8%ae%d8%aa%d8%a7%d8%b1-%d9%85%d9%88%d9%81%d9%82-%d8%a7%d8%b3%d8%aa">#&lt;/a>
&lt;/h3>
&lt;p>دلایل موفقیت رویکرد Go در تست‌های واحد:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>خوانایی بالا&lt;/strong>: هر تست به‌راحتی قابل درک و تحلیل است.&lt;/li>
&lt;li>&lt;strong>حداقل boilerplate&lt;/strong>: بدون نیاز به setup یا framework.&lt;/li>
&lt;li>&lt;strong>اجرای سریع&lt;/strong>: تست‌ها بلافاصله اجرا می‌شوند.&lt;/li>
&lt;li>&lt;strong>پشتیبانی بومی ابزارها&lt;/strong>: بدون وابستگی خارجی.&lt;/li>
&lt;/ul>
&lt;h2 id="722-روشهای-مدیریت-خطا-در-تستها">
7.2.2 روش‌های مدیریت خطا در تست‌ها
&lt;a class="anchor" href="#722-%d8%b1%d9%88%d8%b4%d9%87%d8%a7%db%8c-%d9%85%d8%af%db%8c%d8%b1%db%8c%d8%aa-%d8%ae%d8%b7%d8%a7-%d8%af%d8%b1-%d8%aa%d8%b3%d8%aa%d9%87%d8%a7">#&lt;/a>
&lt;/h2>
&lt;p>در تست‌های واحد، بررسی رفتار توابع در مواجهه با خطا یکی از حیاتی‌ترین جنبه‌هاست. بسیاری از توابع در Go به‌جای پرتاب استثنا، مقادیر &lt;code>error&lt;/code> بازمی‌گردانند، بنابراین انتظار بروز خطا یا نبود خطا بخشی مهم از منطق تست است. تستی که فقط مقدار بازگشتی موفق را بررسی کند، ناقص است. یک تست کامل باید حالت‌های failure را نیز پوشش دهد.&lt;/p>
&lt;h3 id="7221-بررسی-خطاهای-مورد-انتظار">
7.2.2.1 بررسی خطاهای مورد انتظار
&lt;a class="anchor" href="#7221-%d8%a8%d8%b1%d8%b1%d8%b3%db%8c-%d8%ae%d8%b7%d8%a7%d9%87%d8%a7%db%8c-%d9%85%d9%88%d8%b1%d8%af-%d8%a7%d9%86%d8%aa%d8%b8%d8%a7%d8%b1">#&lt;/a>
&lt;/h3>
&lt;p>در بسیاری از مواقع، یک تابع در شرایط خاص باید خطا بازگرداند. تست صحیح باید این خطا را بررسی کرده و اطمینان حاصل کند که نوع خطا، پیام و زمان وقوع آن دقیقاً مطابق انتظار است.&lt;/p>
&lt;p>مثال:&lt;/p>
&lt;pre>&lt;code class="language-go">func Divide(a, b int) (int, error) {
if b == 0 {
return 0, fmt.Errorf(&amp;quot;cannot divide by zero&amp;quot;)
}
return a / b, nil
}
&lt;/code>&lt;/pre>
&lt;p>تست:&lt;/p>
&lt;pre>&lt;code class="language-go">func TestDivideByZero(t *testing.T) {
_, err := Divide(10, 0)
if err == nil {
t.Fatal(&amp;quot;expected error, got nil&amp;quot;)
}
if err.Error() != &amp;quot;cannot divide by zero&amp;quot; {
t.Errorf(&amp;quot;unexpected error message: %v&amp;quot;, err)
}
}
&lt;/code>&lt;/pre>
&lt;h3 id="7222-تست-موفقیت-در-غیاب-خطا">
7.2.2.2 تست موفقیت در غیاب خطا
&lt;a class="anchor" href="#7222-%d8%aa%d8%b3%d8%aa-%d9%85%d9%88%d9%81%d9%82%db%8c%d8%aa-%d8%af%d8%b1-%d8%ba%db%8c%d8%a7%d8%a8-%d8%ae%d8%b7%d8%a7">#&lt;/a>
&lt;/h3>
&lt;p>در طرف دیگر، باید اطمینان حاصل کنیم که در شرایط صحیح، تابع بدون خطا عمل می‌کند:&lt;/p>
&lt;pre>&lt;code class="language-go">func TestDivideSuccess(t *testing.T) {
res, err := Divide(10, 2)
if err != nil {
t.Fatalf(&amp;quot;unexpected error: %v&amp;quot;, err)
}
if res != 5 {
t.Errorf(&amp;quot;expected 5, got %d&amp;quot;, res)
}
}
&lt;/code>&lt;/pre>
&lt;h3 id="7223-استفاده-از-errorsis-و-errorsas">
7.2.2.3 استفاده از errors.Is و errors.As
&lt;a class="anchor" href="#7223-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-errorsis-%d9%88-errorsas">#&lt;/a>
&lt;/h3>
&lt;p>در شرایط حرفه‌ای، به‌جای بررسی پیام خطا، بهتر است از توابع استاندارد کتابخانه &lt;code>errors&lt;/code> برای بررسی نوع خطا استفاده شود، خصوصاً زمانی که خطاها wrap می‌شوند.&lt;/p>
&lt;pre>&lt;code class="language-go">var ErrDivideByZero = errors.New(&amp;quot;cannot divide by zero&amp;quot;)
func Divide(a, b int) (int, error) {
if b == 0 {
return 0, fmt.Errorf(&amp;quot;wrap: %w&amp;quot;, ErrDivideByZero)
}
return a / b, nil
}
&lt;/code>&lt;/pre>
&lt;p>تست:&lt;/p>
&lt;pre>&lt;code class="language-go">func TestDivideByZeroTypedError(t *testing.T) {
_, err := Divide(1, 0)
if !errors.Is(err, ErrDivideByZero) {
t.Errorf(&amp;quot;expected ErrDivideByZero, got %v&amp;quot;, err)
}
}
&lt;/code>&lt;/pre>
&lt;h3 id="7224-پوشش-تمامی-مسیرهای-منطقی">
7.2.2.4 پوشش تمامی مسیرهای منطقی
&lt;a class="anchor" href="#7224-%d9%be%d9%88%d8%b4%d8%b4-%d8%aa%d9%85%d8%a7%d9%85%db%8c-%d9%85%d8%b3%db%8c%d8%b1%d9%87%d8%a7%db%8c-%d9%85%d9%86%d8%b7%d9%82%db%8c">#&lt;/a>
&lt;/h3>
&lt;p>هر تابعی که دارای چند مسیر شرطی است، باید در تست‌های واحد به‌صورت جداگانه در تمامی مسیرها آزمایش شود. عدم پوشش یکی از مسیرها می‌تواند منجر به بروز باگ‌های پنهان در آینده شود.&lt;/p>
&lt;p>برای مثال، تابع زیر دو مسیر دارد:&lt;/p>
&lt;pre>&lt;code class="language-go">func Authenticate(token string) error {
if token == &amp;quot;&amp;quot; {
return errors.New(&amp;quot;token required&amp;quot;)
}
return nil
}
&lt;/code>&lt;/pre>
&lt;p>تست صحیح باید هر دو مسیر را پوشش دهد:&lt;/p>
&lt;pre>&lt;code class="language-go">func TestAuthenticate(t *testing.T) {
tests := []struct {
name string
input string
wantErr bool
}{
{&amp;quot;valid token&amp;quot;, &amp;quot;abc123&amp;quot;, false},
{&amp;quot;empty token&amp;quot;, &amp;quot;&amp;quot;, true},
}
for _, tt := range tests {
t.Run(tt.name, func(t *testing.T) {
err := Authenticate(tt.input)
if (err != nil) != tt.wantErr {
t.Errorf(&amp;quot;unexpected error result. got error=%v&amp;quot;, err)
}
})
}
}
&lt;/code>&lt;/pre>
&lt;p>این تکنیک با نام &lt;span class="tooltip" data-tooltip="table-driven test" ontouchend="toggleTooltip(this)">تست جدول‌محور&lt;/span>
شناخته می‌شود و در بخش بعدی به‌صورت مفصل بررسی خواهد شد.&lt;/p>
&lt;h2 id="723-تست-توابع-غیرصادرشده-unexported-و-کاربرد-پکیج-_test">
7.2.3 تست توابع غیرصادرشده (Unexported) و کاربرد پکیج _test
&lt;a class="anchor" href="#723-%d8%aa%d8%b3%d8%aa-%d8%aa%d9%88%d8%a7%d8%a8%d8%b9-%d8%ba%db%8c%d8%b1%d8%b5%d8%a7%d8%af%d8%b1%d8%b4%d8%af%d9%87-unexported-%d9%88-%da%a9%d8%a7%d8%b1%d8%a8%d8%b1%d8%af-%d9%be%da%a9%db%8c%d8%ac-_test">#&lt;/a>
&lt;/h2>
&lt;p>در Go، توابع یا انواعی که با حرف کوچک آغاز می‌شوند، تنها در محدوده همان پکیج قابل مشاهده هستند. این ویژگی در راستای اصل &lt;strong>کپسوله‌سازی&lt;/strong> طراحی شده است. اما گاهی لازم است این توابع &lt;strong>غیرصادرشده&lt;/strong> را نیز مورد تست قرار دهیم. برای این کار، چند رویکرد رایج وجود دارد که هرکدام بسته به هدف تست قابل انتخاب هستند.&lt;/p>
&lt;h3 id="7231-نوشتن-تست-در-همان-پکیج">
7.2.3.1 نوشتن تست در همان پکیج
&lt;a class="anchor" href="#7231-%d9%86%d9%88%d8%b4%d8%aa%d9%86-%d8%aa%d8%b3%d8%aa-%d8%af%d8%b1-%d9%87%d9%85%d8%a7%d9%86-%d9%be%da%a9%db%8c%d8%ac">#&lt;/a>
&lt;/h3>
&lt;p>در ساده‌ترین حالت، فایل تست را در همان پکیجی می‌نویسیم که کد اصلی قرار دارد. این روش به تست دسترسی کامل به توابع، متغیرها و انواع داخلی را می‌دهد.&lt;/p>
&lt;pre>&lt;code class="language-go">// file: internal.go
package math
func subtract(a, b int) int {
return a - b
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-go">// file: internal_test.go
package math
import &amp;quot;testing&amp;quot;
func TestSubtract(t *testing.T) {
if subtract(5, 3) != 2 {
t.Errorf(&amp;quot;expected 2, got %d&amp;quot;, subtract(5, 3))
}
}
&lt;/code>&lt;/pre>
&lt;p>این روش توصیه‌شده و رسمی‌ترین راه برای تست موارد غیرصادرشده است.&lt;/p>
&lt;h3 id="7232-استفاده-از-پکیج-تست-جداگانه-_test">
7.2.3.2 استفاده از پکیج تست جداگانه (_test)
&lt;a class="anchor" href="#7232-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-%d9%be%da%a9%db%8c%d8%ac-%d8%aa%d8%b3%d8%aa-%d8%ac%d8%af%d8%a7%da%af%d8%a7%d9%86%d9%87-_test">#&lt;/a>
&lt;/h3>
&lt;p>اگر بخواهیم تست‌ها کاملاً از رفتار داخلی جدا باشند و فقط از رابط عمومی (public API) استفاده کنند، می‌توانیم از یک پکیج با پسوند &lt;code>_test&lt;/code> استفاده کنیم. این روش برای نوشتن تست‌های سطح بالاتر یا رفتاری مناسب است.&lt;/p>
&lt;pre>&lt;code class="language-go">// file: api_test.go
package math_test
import (
&amp;quot;testing&amp;quot;
&amp;quot;mymodule/math&amp;quot;
)
func TestAddPublic(t *testing.T) {
got := math.Add(1, 2)
if got != 3 {
t.Errorf(&amp;quot;expected 3, got %d&amp;quot;, got)
}
}
&lt;/code>&lt;/pre>
&lt;p>در این حالت:&lt;/p>
&lt;ul>
&lt;li>توابع داخلی (مثل &lt;code>subtract&lt;/code>) دیگر قابل دسترسی نیستند.&lt;/li>
&lt;li>تنها توابع صادرشده در دسترس هستند.&lt;/li>
&lt;li>این یک تست &amp;ldquo;از بیرون&amp;rdquo; یا &amp;ldquo;black-box&amp;rdquo; محسوب می‌شود.&lt;/li>
&lt;/ul>
&lt;h3 id="7233-تست-غیرمستقیم-توابع-داخلی">
7.2.3.3 تست غیرمستقیم توابع داخلی
&lt;a class="anchor" href="#7233-%d8%aa%d8%b3%d8%aa-%d8%ba%db%8c%d8%b1%d9%85%d8%b3%d8%aa%d9%82%db%8c%d9%85-%d8%aa%d9%88%d8%a7%d8%a8%d8%b9-%d8%af%d8%a7%d8%ae%d9%84%db%8c">#&lt;/a>
&lt;/h3>
&lt;p>اگر تابع غیرصادرشده به‌صورت مستقیم قابل تست نیست ولی از طریق توابع صادرشده فراخوانی می‌شود، بهترین راه تست آن &lt;strong>به‌صورت غیرمستقیم و از طریق خروجی تابع صادرشده&lt;/strong> است. به این ترتیب، تست به ساختار داخلی وابسته نخواهد بود.&lt;/p>
&lt;p>مزیت این روش:&lt;/p>
&lt;ul>
&lt;li>تست پایدارتر باقی می‌ماند.&lt;/li>
&lt;li>وابستگی به جزییات پیاده‌سازی کاهش می‌یابد.&lt;/li>
&lt;/ul>
&lt;h3 id="7234-مزایا-و-معایب-هر-رویکرد">
7.2.3.4 مزایا و معایب هر رویکرد
&lt;a class="anchor" href="#7234-%d9%85%d8%b2%d8%a7%db%8c%d8%a7-%d9%88-%d9%85%d8%b9%d8%a7%db%8c%d8%a8-%d9%87%d8%b1-%d8%b1%d9%88%db%8c%da%a9%d8%b1%d8%af">#&lt;/a>
&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>روش&lt;/th>
&lt;th>مزایا&lt;/th>
&lt;th>معایب&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>پکیج داخلی (&lt;code>package x&lt;/code>)&lt;/td>
&lt;td>دسترسی کامل به کد&lt;/td>
&lt;td>وابستگی مستقیم به پیاده‌سازی&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>پکیج &lt;code>_test&lt;/code>&lt;/td>
&lt;td>تست رفتاری و بدون وابستگی به داخل&lt;/td>
&lt;td>عدم امکان تست مستقیم کد داخلی&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>تست غیرمستقیم&lt;/td>
&lt;td>افزایش انعطاف تست و پایداری طولانی‌مدت&lt;/td>
&lt;td>پوشش دقیق همه مسیرها ممکن نیست&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="7235-نکات-تجربی">
7.2.3.5 نکات تجربی
&lt;a class="anchor" href="#7235-%d9%86%da%a9%d8%a7%d8%aa-%d8%aa%d8%ac%d8%b1%d8%a8%db%8c">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>تست توابع داخلی اگر رفتار پیچیده‌ای دارند، &lt;strong>ضروری&lt;/strong> است.&lt;/li>
&lt;li>اگر یک تابع داخلی توسط تابع صادرشده‌ای فراخوانی نمی‌شود، بهتر است به صورت مستقل در همان پکیج تست شود.&lt;/li>
&lt;li>از پکیج &lt;code>_test&lt;/code> در تست‌های &lt;span class="tooltip" data-tooltip="integration-like tests" ontouchend="toggleTooltip(this)">انتهایی&lt;/span>
یا برای نوشتن سناریوهای بلندمدت استفاده کنید.&lt;/li>
&lt;/ul>
&lt;h2 id="724-نکات-کاربردی-و-اشتباهات-رایج-در-تستهای-واحد">
7.2.4 نکات کاربردی و اشتباهات رایج در تست‌های واحد
&lt;a class="anchor" href="#724-%d9%86%da%a9%d8%a7%d8%aa-%da%a9%d8%a7%d8%b1%d8%a8%d8%b1%d8%af%db%8c-%d9%88-%d8%a7%d8%b4%d8%aa%d8%a8%d8%a7%d9%87%d8%a7%d8%aa-%d8%b1%d8%a7%db%8c%d8%ac-%d8%af%d8%b1-%d8%aa%d8%b3%d8%aa%d9%87%d8%a7%db%8c-%d9%88%d8%a7%d8%ad%d8%af">#&lt;/a>
&lt;/h2>
&lt;p>یونیت تست‌نویسی در Go به دلیل سادگی و سرعت بالا، بسیار محبوب است؛ اما همین سادگی ممکن است باعث شود برخی نکات ظریف، اما مهم، نادیده گرفته شوند. در این بخش، مجموعه‌ای از توصیه‌های عملی و اشتباهات رایج در یونیت تست‌ها را مرور می‌کنیم که رعایت آن‌ها منجر به تست‌هایی دقیق‌تر، پایدارتر و قابل نگهداری‌تر خواهد شد.&lt;/p>
&lt;h3 id="7241-تفاوت-بین-terror-و-tfatal-را-بشناسید">
7.2.4.1 تفاوت بین t.Error و t.Fatal را بشناسید
&lt;a class="anchor" href="#7241-%d8%aa%d9%81%d8%a7%d9%88%d8%aa-%d8%a8%db%8c%d9%86-terror-%d9%88-tfatal-%d8%b1%d8%a7-%d8%a8%d8%b4%d9%86%d8%a7%d8%b3%db%8c%d8%af">#&lt;/a>
&lt;/h3>
&lt;p>یکی از اشتباهات رایج، استفاده اشتباه از &lt;code>t.Fatal&lt;/code> به‌جای &lt;code>t.Error&lt;/code> یا بالعکس است.&lt;/p>
&lt;ul>
&lt;li>از &lt;code>t.Error&lt;/code> زمانی استفاده کنید که می‌خواهید خطا را ثبت کنید ولی اجازه دهید تست ادامه پیدا کند.&lt;/li>
&lt;li>از &lt;code>t.Fatal&lt;/code> زمانی استفاده کنید که ادامه‌ی تست بی‌معنا است و باید بلافاصله متوقف شود.&lt;/li>
&lt;/ul>
&lt;p>مثال:&lt;/p>
&lt;pre>&lt;code class="language-go">if err != nil {
t.Fatal(&amp;quot;cannot continue test, error:&amp;quot;, err)
}
if result != expected {
t.Error(&amp;quot;wrong result, got&amp;quot;, result)
}
&lt;/code>&lt;/pre>
&lt;blockquote>
&lt;p>اگر با یک خطای بحرانی مثل failure در ورودی مواجه شدید، &lt;code>Fatal&lt;/code> مناسب‌تر است.&lt;/p>&lt;/blockquote>
&lt;h3 id="7242-از-timesleep-در-یونیت-تست-استفاده-نکنید">
7.2.4.2 از time.Sleep در یونیت تست استفاده نکنید
&lt;a class="anchor" href="#7242-%d8%a7%d8%b2-timesleep-%d8%af%d8%b1-%db%8c%d9%88%d9%86%db%8c%d8%aa-%d8%aa%d8%b3%d8%aa-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d9%86%da%a9%d9%86%db%8c%d8%af">#&lt;/a>
&lt;/h3>
&lt;p>استفاده از &lt;code>time.Sleep&lt;/code> برای منتظر ماندن در تست باعث ایجاد تست‌های ناپایدار و کند می‌شود. به‌جای آن، از تکنیک‌های مبتنی بر کانال یا تکرارهای سریع (retry) استفاده کنید.&lt;/p>
&lt;p>❌ بد:&lt;/p>
&lt;pre>&lt;code class="language-go">time.Sleep(100 * time.Millisecond)
&lt;/code>&lt;/pre>
&lt;p>✅ بهتر:&lt;/p>
&lt;pre>&lt;code class="language-go">for i := 0; i &amp;lt; 100; i++ {
if ready() {
break
}
time.Sleep(1 * time.Millisecond)
}
&lt;/code>&lt;/pre>
&lt;h3 id="7243-تستهای-وابسته-به-زمان-را-کنترل-کنید">
7.2.4.3 تست‌های وابسته به زمان را کنترل کنید
&lt;a class="anchor" href="#7243-%d8%aa%d8%b3%d8%aa%d9%87%d8%a7%db%8c-%d9%88%d8%a7%d8%a8%d8%b3%d8%aa%d9%87-%d8%a8%d9%87-%d8%b2%d9%85%d8%a7%d9%86-%d8%b1%d8%a7-%da%a9%d9%86%d8%aa%d8%b1%d9%84-%da%a9%d9%86%db%8c%d8%af">#&lt;/a>
&lt;/h3>
&lt;p>تست‌هایی که از &lt;code>time.Now()&lt;/code> یا &lt;code>time.Since()&lt;/code> استفاده می‌کنند باید طوری طراحی شوند که قابل پیش‌بینی باقی بمانند. راهکار:&lt;/p>
&lt;ul>
&lt;li>تزریق زمان (dependency injection)&lt;/li>
&lt;li>استفاده از clock mock&lt;/li>
&lt;/ul>
&lt;h3 id="7244-از-ttempdir-برای-ساخت-فایل-موقت-استفاده-کنید">
7.2.4.4 از &lt;code>t.TempDir()&lt;/code> برای ساخت فایل‌ موقت استفاده کنید
&lt;a class="anchor" href="#7244-%d8%a7%d8%b2-ttempdir-%d8%a8%d8%b1%d8%a7%db%8c-%d8%b3%d8%a7%d8%ae%d8%aa-%d9%81%d8%a7%db%8c%d9%84-%d9%85%d9%88%d9%82%d8%aa-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%da%a9%d9%86%db%8c%d8%af">#&lt;/a>
&lt;/h3>
&lt;p>اگر تست نیاز به فایل یا پوشه موقتی دارد، به‌جای نوشتن مسیر دستی از &lt;code>t.TempDir()&lt;/code> استفاده کنید:&lt;/p>
&lt;pre>&lt;code class="language-go">func TestWriteFile(t *testing.T) {
dir := t.TempDir()
path := filepath.Join(dir, &amp;quot;file.txt&amp;quot;)
_ = os.WriteFile(path, []byte(&amp;quot;data&amp;quot;), 0644)
// فایل بعد از تست به‌صورت خودکار پاک می‌شود
}
&lt;/code>&lt;/pre>
&lt;h3 id="7245-مراقب-caching-ناخواسته-باشید">
7.2.4.5 مراقب caching ناخواسته باشید
&lt;a class="anchor" href="#7245-%d9%85%d8%b1%d8%a7%d9%82%d8%a8-caching-%d9%86%d8%a7%d8%ae%d9%88%d8%a7%d8%b3%d8%aa%d9%87-%d8%a8%d8%a7%d8%b4%db%8c%d8%af">#&lt;/a>
&lt;/h3>
&lt;p>هنگام اجرای مکرر تست‌ها، اگر خروجی تست‌ها در حال تغییر باشد، ممکن است به دلیل کش شدن نتیجه، نتیجه قبلی دوباره نمایش داده شود. برای جلوگیری:&lt;/p>
&lt;pre>&lt;code class="language-bash">go test -count=1
&lt;/code>&lt;/pre>
&lt;p>یا پاک‌سازی کامل کش:&lt;/p>
&lt;pre>&lt;code class="language-bash">go clean -testcache
&lt;/code>&lt;/pre>
&lt;h3 id="7246-تست-نباید-فقط-تابع-را-صدا-بزند">
7.2.4.6 تست نباید فقط تابع را صدا بزند
&lt;a class="anchor" href="#7246-%d8%aa%d8%b3%d8%aa-%d9%86%d8%a8%d8%a7%db%8c%d8%af-%d9%81%d9%82%d8%b7-%d8%aa%d8%a7%d8%a8%d8%b9-%d8%b1%d8%a7-%d8%b5%d8%af%d8%a7-%d8%a8%d8%b2%d9%86%d8%af">#&lt;/a>
&lt;/h3>
&lt;p>یونیت تست‌هایی که تنها تابع را اجرا می‌کنند ولی هیچ بررسی‌ای انجام نمی‌دهند، بی‌فایده‌اند.&lt;/p>
&lt;p>❌ بد:&lt;/p>
&lt;pre>&lt;code class="language-go">func TestNoCheck(t *testing.T) {
DoSomething()
}
&lt;/code>&lt;/pre>
&lt;p>✅ درست:&lt;/p>
&lt;pre>&lt;code class="language-go">func TestDoSomething(t *testing.T) {
result := DoSomething()
if result != expected {
t.Errorf(&amp;quot;expected %v, got %v&amp;quot;, expected, result)
}
}
&lt;/code>&lt;/pre>
&lt;h3 id="7247-گزارشدهی-دقیق-بنویسید">
7.2.4.7 گزارش‌دهی دقیق بنویسید
&lt;a class="anchor" href="#7247-%da%af%d8%b2%d8%a7%d8%b1%d8%b4%d8%af%d9%87%db%8c-%d8%af%d9%82%db%8c%d9%82-%d8%a8%d9%86%d9%88%db%8c%d8%b3%db%8c%d8%af">#&lt;/a>
&lt;/h3>
&lt;p>در هنگام ثبت خطا با &lt;code>t.Errorf&lt;/code> یا &lt;code>t.Fatalf&lt;/code>، حتماً اطلاعات کامل بدهید:&lt;/p>
&lt;pre>&lt;code class="language-go">t.Errorf(&amp;quot;expected %d, got %d&amp;quot;, want, got)
&lt;/code>&lt;/pre>
&lt;p>این کار در زمان تحلیل خروجی تست‌ها بسیار مفید است.&lt;/p>
&lt;h3 id="7248-نامگذاری-مناسب-تستها">
7.2.4.8 نام‌گذاری مناسب تست‌ها
&lt;a class="anchor" href="#7248-%d9%86%d8%a7%d9%85%da%af%d8%b0%d8%a7%d8%b1%db%8c-%d9%85%d9%86%d8%a7%d8%b3%d8%a8-%d8%aa%d8%b3%d8%aa%d9%87%d8%a7">#&lt;/a>
&lt;/h3>
&lt;p>نام تست باید گویای هدف تست باشد:&lt;/p>
&lt;pre>&lt;code class="language-go">func TestDivideByZeroReturnsError(t *testing.T) { ... }
func TestAddPositiveNumbers(t *testing.T) { ... }
&lt;/code>&lt;/pre>
&lt;p>از نام‌هایی مثل &lt;code>Test1&lt;/code>, &lt;code>TestA&lt;/code>, &lt;code>TestXYZ&lt;/code> اجتناب کنید.&lt;/p>
&lt;h2 id="725-تست-واحد-برای-ساختارها-و-متدهای-hahahugoshortcode177s4hbhb">
7.2.5 تست واحد برای ساختارها و متدهای &lt;span class="tooltip" data-tooltip="receiver methods" ontouchend="toggleTooltip(this)">گیرنده&lt;/span>
&lt;a class="anchor" href="#725-%d8%aa%d8%b3%d8%aa-%d9%88%d8%a7%d8%ad%d8%af-%d8%a8%d8%b1%d8%a7%db%8c-%d8%b3%d8%a7%d8%ae%d8%aa%d8%a7%d8%b1%d9%87%d8%a7-%d9%88-%d9%85%d8%aa%d8%af%d9%87%d8%a7%db%8c-hahahugoshortcode177s4hbhb">#&lt;/a>
&lt;/h2>
&lt;p>در زبان Go، بسیاری از قابلیت‌های سطح بالا از طریق متدهایی روی ساختارها (structs) پیاده‌سازی می‌شوند. این متدها بسته به نوع گیرنده‌شان (&lt;code>value receiver&lt;/code> یا &lt;code>pointer receiver&lt;/code>) و میزان وابستگی‌شان به وضعیت داخلی ساختار، نیاز به طراحی تست دقیق‌تری دارند.&lt;/p>
&lt;p>در این بخش، بررسی می‌کنیم که چگونه می‌توان به صورت مؤثر برای متدهای متصل به ساختارها تست واحد نوشت.&lt;/p>
&lt;h3 id="7251-تست-متدهای-گیرنده-مقداری-value-receiver">
7.2.5.1 تست متدهای گیرنده مقداری (value receiver)
&lt;a class="anchor" href="#7251-%d8%aa%d8%b3%d8%aa-%d9%85%d8%aa%d8%af%d9%87%d8%a7%db%8c-%da%af%db%8c%d8%b1%d9%86%d8%af%d9%87-%d9%85%d9%82%d8%af%d8%a7%d8%b1%db%8c-value-receiver">#&lt;/a>
&lt;/h3>
&lt;p>اگر متدی گیرنده مقداری دارد، معمولاً روی یک نسخه‌ی کپی‌شده از ساختار عمل می‌کند و تغییری در وضعیت اصلی ایجاد نمی‌کند. تست چنین متدهایی بسیار ساده است.&lt;/p>
&lt;p>مثال:&lt;/p>
&lt;pre>&lt;code class="language-go">type Point struct {
X, Y int
}
func (p Point) IsOrigin() bool {
return p.X == 0 &amp;amp;&amp;amp; p.Y == 0
}
&lt;/code>&lt;/pre>
&lt;p>تست:&lt;/p>
&lt;pre>&lt;code class="language-go">func TestPoint_IsOrigin(t *testing.T) {
p := Point{X: 0, Y: 0}
if !p.IsOrigin() {
t.Error(&amp;quot;expected true, got false&amp;quot;)
}
}
&lt;/code>&lt;/pre>
&lt;h3 id="7252-تست-متدهای-گیرنده-اشارهگری-pointer-receiver">
7.2.5.2 تست متدهای گیرنده اشاره‌گری (pointer receiver)
&lt;a class="anchor" href="#7252-%d8%aa%d8%b3%d8%aa-%d9%85%d8%aa%d8%af%d9%87%d8%a7%db%8c-%da%af%db%8c%d8%b1%d9%86%d8%af%d9%87-%d8%a7%d8%b4%d8%a7%d8%b1%d9%87%da%af%d8%b1%db%8c-pointer-receiver">#&lt;/a>
&lt;/h3>
&lt;p>اگر متد وضعیت داخلی ساختار را تغییر می‌دهد یا به صورت اشاره‌گری تعریف شده، در تست باید دقت بیشتری کرد.&lt;/p>
&lt;p>مثال:&lt;/p>
&lt;pre>&lt;code class="language-go">func (p *Point) Move(dx, dy int) {
p.X += dx
p.Y += dy
}
&lt;/code>&lt;/pre>
&lt;p>تست:&lt;/p>
&lt;pre>&lt;code class="language-go">func TestPoint_Move(t *testing.T) {
p := &amp;amp;Point{X: 1, Y: 2}
p.Move(3, 4)
if p.X != 4 || p.Y != 6 {
t.Errorf(&amp;quot;expected (4,6), got (%d,%d)&amp;quot;, p.X, p.Y)
}
}
&lt;/code>&lt;/pre>
&lt;blockquote>
&lt;p>&lt;strong>توجه:&lt;/strong> حتماً باید از اشاره‌گر (&lt;code>&amp;amp;Point{...}&lt;/code>) استفاده شود، چون متد روی pointer تعریف شده است.&lt;/p>&lt;/blockquote>
&lt;h3 id="7253-تست-چند-متد-روی-یک-نمونه">
7.2.5.3 تست چند متد روی یک نمونه
&lt;a class="anchor" href="#7253-%d8%aa%d8%b3%d8%aa-%da%86%d9%86%d8%af-%d9%85%d8%aa%d8%af-%d8%b1%d9%88%db%8c-%db%8c%da%a9-%d9%86%d9%85%d9%88%d9%86%d9%87">#&lt;/a>
&lt;/h3>
&lt;p>اگر چند متد متوالی روی یک نمونه اعمال می‌شود (تغییر وضعیت گام‌به‌گام)، بهتر است تست در قالب &lt;strong>subtest&lt;/strong> یا &lt;strong>جدول تست&lt;/strong> طراحی شود تا خوانایی حفظ شود.&lt;/p>
&lt;pre>&lt;code class="language-go">func TestPoint_Sequence(t *testing.T) {
p := &amp;amp;Point{}
t.Run(&amp;quot;Move&amp;quot;, func(t *testing.T) {
p.Move(2, 2)
})
t.Run(&amp;quot;Check&amp;quot;, func(t *testing.T) {
if p.X != 2 || p.Y != 2 {
t.Errorf(&amp;quot;expected (2,2), got (%d,%d)&amp;quot;, p.X, p.Y)
}
})
}
&lt;/code>&lt;/pre>
&lt;h3 id="7254-جداسازی-لایه-logic-از-state">
7.2.5.4 جداسازی لایه logic از state
&lt;a class="anchor" href="#7254-%d8%ac%d8%af%d8%a7%d8%b3%d8%a7%d8%b2%db%8c-%d9%84%d8%a7%db%8c%d9%87-logic-%d8%a7%d8%b2-state">#&lt;/a>
&lt;/h3>
&lt;p>در پروژه‌های واقعی، اگر متد ساختار منطق پیچیده دارد، توصیه می‌شود محاسبات را از وضعیت جدا کرده و در توابع مستقل pure قرار دهید تا تست‌پذیرتر شود.&lt;/p>
&lt;p>مثال بهینه‌شده:&lt;/p>
&lt;pre>&lt;code class="language-go">func calculateNewPosition(x, y, dx, dy int) (int, int) {
return x + dx, y + dy
}
&lt;/code>&lt;/pre>
&lt;p>این تابع را می‌توان به راحتی در یونیت تست مستقل بررسی کرد، بدون نیاز به ساختار.&lt;/p>
&lt;h3 id="7255-رفتار-پیشفرض-در-مقادیر-تهی-zero-value">
7.2.5.5 رفتار پیش‌فرض در مقادیر تهی (zero value)
&lt;a class="anchor" href="#7255-%d8%b1%d9%81%d8%aa%d8%a7%d8%b1-%d9%be%db%8c%d8%b4%d9%81%d8%b1%d8%b6-%d8%af%d8%b1-%d9%85%d9%82%d8%a7%d8%af%db%8c%d8%b1-%d8%aa%d9%87%db%8c-zero-value">#&lt;/a>
&lt;/h3>
&lt;p>در Go، مقدار پیش‌فرض (zero value) برای structها معتبر است و معمولاً باید بتوان از آن استفاده کرد. تست این رفتار برای ساختارهایی که متد دارند مهم است.&lt;/p>
&lt;pre>&lt;code class="language-go">func TestZeroValueBehavior(t *testing.T) {
var p Point
if !p.IsOrigin() {
t.Error(&amp;quot;expected origin from zero value&amp;quot;)
}
}
&lt;/code>&lt;/pre>
&lt;h3 id="7256-ترکیب-متد-و-خطا">
7.2.5.6 ترکیب متد و خطا
&lt;a class="anchor" href="#7256-%d8%aa%d8%b1%da%a9%db%8c%d8%a8-%d9%85%d8%aa%d8%af-%d9%88-%d8%ae%d8%b7%d8%a7">#&lt;/a>
&lt;/h3>
&lt;p>در صورتی که متدی روی struct خطا بازمی‌گرداند، حتماً باید شرایط موفق/ناموفق را تست کنید:&lt;/p>
&lt;pre>&lt;code class="language-go">type User struct {
Email string
}
func (u *User) Validate() error {
if u.Email == &amp;quot;&amp;quot; {
return errors.New(&amp;quot;email required&amp;quot;)
}
return nil
}
&lt;/code>&lt;/pre>
&lt;p>تست:&lt;/p>
&lt;pre>&lt;code class="language-go">func TestUser_Validate(t *testing.T) {
tests := []struct {
email string
wantErr bool
}{
{&amp;quot;&amp;quot;, true},
{&amp;quot;hello@example.com&amp;quot;, false},
}
for _, tt := range tests {
u := &amp;amp;User{Email: tt.email}
err := u.Validate()
if (err != nil) != tt.wantErr {
t.Errorf(&amp;quot;unexpected error state for email %q&amp;quot;, tt.email)
}
}
}
&lt;/code>&lt;/pre>
&lt;h2 id="726-تفکیک-تستهای-سریع-و-آهسته-با--short">
7.2.6 تفکیک تست‌های سریع و آهسته با -short
&lt;a class="anchor" href="#726-%d8%aa%d9%81%da%a9%db%8c%da%a9-%d8%aa%d8%b3%d8%aa%d9%87%d8%a7%db%8c-%d8%b3%d8%b1%db%8c%d8%b9-%d9%88-%d8%a2%d9%87%d8%b3%d8%aa%d9%87-%d8%a8%d8%a7--short">#&lt;/a>
&lt;/h2>
&lt;p>در پروژه‌های واقعی، برخی تست‌ها بسیار سریع هستند و بلافاصله اجرا می‌شوند، اما برخی دیگر—به‌دلایل مختلفی مانند تعامل با فایل، شبکه، زمان‌سنجی، یا دیتابیس—کندتر هستند و ممکن است زمان‌بر یا شکننده (flaky) باشند. ابزار &lt;code>go test&lt;/code> راهکاری ساده برای تفکیک این دو نوع تست فراهم کرده است: استفاده از فلگ &lt;code>-short&lt;/code>.&lt;/p>
&lt;p>هنگامی که دستور زیر اجرا می‌شود:&lt;/p>
&lt;pre>&lt;code class="language-bash">go test -short
&lt;/code>&lt;/pre>
&lt;p>آرگومان &lt;code>-short&lt;/code> به تمامی توابع تست به‌صورت خودکار ارسال می‌شود. سپس داخل کد می‌توان با استفاده از متد &lt;code>testing.Short()&lt;/code> بررسی کرد که آیا این تست باید اجرا شود یا رد شود.&lt;/p>
&lt;h3 id="7261-مثال-کاربردی">
7.2.6.1 مثال کاربردی
&lt;a class="anchor" href="#7261-%d9%85%d8%ab%d8%a7%d9%84-%da%a9%d8%a7%d8%b1%d8%a8%d8%b1%d8%af%db%8c">#&lt;/a>
&lt;/h3>
&lt;pre>&lt;code class="language-go">func TestSlowOperation(t *testing.T) {
if testing.Short() {
t.Skip(&amp;quot;skipping slow test in short mode&amp;quot;)
}
time.Sleep(5 * time.Second) // تست کند
t.Log(&amp;quot;test completed&amp;quot;)
}
&lt;/code>&lt;/pre>
&lt;p>در اجرای معمولی:&lt;/p>
&lt;pre>&lt;code class="language-bash">go test
&lt;/code>&lt;/pre>
&lt;p>تست اجرا می‌شود. اما در حالت short:&lt;/p>
&lt;pre>&lt;code class="language-bash">go test -short
&lt;/code>&lt;/pre>
&lt;p>خروجی:&lt;/p>
&lt;pre>&lt;code>--- SKIP: TestSlowOperation (0.00s)
slow_test.go:4: skipping slow test in short mode
PASS
&lt;/code>&lt;/pre>
&lt;h3 id="7262-مزایا">
7.2.6.2 مزایا
&lt;a class="anchor" href="#7262-%d9%85%d8%b2%d8%a7%db%8c%d8%a7">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>اجرای سریع‌تر تست‌ها در حالت پیش‌فرض&lt;/li>
&lt;li>مناسب برای CI pipelines سبک یا اجراهای local&lt;/li>
&lt;li>حذف تست‌هایی که به منابع خارجی یا شرایط خاص نیاز دارند&lt;/li>
&lt;/ul>
&lt;h3 id="7263-نکته-مهم">
7.2.6.3 نکته مهم
&lt;a class="anchor" href="#7263-%d9%86%da%a9%d8%aa%d9%87-%d9%85%d9%87%d9%85">#&lt;/a>
&lt;/h3>
&lt;p>بهتر است تست‌های کند را &lt;strong>با شرط &lt;code>testing.Short()&lt;/code> کنترل کنید&lt;/strong> نه اینکه به‌طور کلی حذف‌شان کنید یا در فایل جداگانه بگذارید. این کار نگهداری و اجرای تست‌ها را انعطاف‌پذیرتر می‌کند.&lt;/p>
&lt;h3 id="7264-ترکیب-با-ابزارهای-دیگر">
7.2.6.4 ترکیب با ابزارهای دیگر
&lt;a class="anchor" href="#7264-%d8%aa%d8%b1%da%a9%db%8c%d8%a8-%d8%a8%d8%a7-%d8%a7%d8%a8%d8%b2%d8%a7%d8%b1%d9%87%d8%a7%db%8c-%d8%af%db%8c%da%af%d8%b1">#&lt;/a>
&lt;/h3>
&lt;p>در سیستم‌های CI/CD، می‌توان دو مرحله اجرای تست داشت:&lt;/p>
&lt;pre>&lt;code class="language-bash">go test -short ./... # فقط تست‌های سریع
go test ./... # همه تست‌ها (مثلاً فقط در زمان انتشار نسخه)
&lt;/code>&lt;/pre></description></item><item><author/><title>7.3 تست جدول‌محور (Table-Driven Test)</title><link>https://book.gofarsi.ir/chapter-7/go-table-driven-tests/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-7/go-table-driven-tests/</guid><description>&lt;p>fدر زبان Go، یکی از الگوهای محبوب و بسیار قدرتمند برای نوشتن تست‌های واحد و رفتاری، الگوی «تست جدول‌محور» است. این سبک از تست‌نویسی نه‌تنها منجر به حذف تکرارهای زائد در کد تست می‌شود، بلکه ساختاری منسجم برای تعریف سناریوهای مختلف تست، به همراه ورودی و خروجی‌های مورد انتظار، فراهم می‌سازد.&lt;/p>
&lt;p>در این الگو، مجموعه‌ای از تست‌ها به‌صورت یک جدول از structها تعریف می‌شود که شامل نام تست، ورودی‌ها، خروجی مورد انتظار، و گاهی انتظار وقوع خطا است. سپس با استفاده از یک حلقه و تابع &lt;code>t.Run&lt;/code>، هر ردیف از جدول به‌صورت یک تست مستقل (subtest) اجرا می‌شود. این طراحی باعث می‌شود اضافه‌کردن یک تست جدید، تنها با افزودن یک struct به جدول امکان‌پذیر باشد—بدون نیاز به کپی‌کردن منطق کلی تست.&lt;/p>
&lt;p>این نوع تست‌نویسی به‌طور ویژه برای پوشش کامل مسیرهای مختلف در توابعی با منطق شرطی یا چند حالت ورودی مناسب است. همچنین، به‌کارگیری آن در کنار subtestها موجب می‌شود گزارش شکست‌ها دقیق‌تر، ساخت‌یافته‌تر و خواناتر باشد. در پروژه‌های مقیاس‌پذیر، این سبک نه‌تنها خوانایی تست‌ها را حفظ می‌کند، بلکه روند توسعه و نگهداری آن‌ها را نیز تسهیل می‌کند.&lt;/p>
&lt;p>در ادامه‌ی این بخش، ابتدا ساختار استاندارد یک تست جدول‌محور را معرفی می‌کنیم، سپس به بررسی تکنیک‌های پیشرفته، اشتباهات رایج، اجرای موازی تست‌ها، طراحی تست‌های نگهدارنده‌ی خطا، و الگوهای پیشنهادی برای پروژه‌های واقعی می‌پردازیم.&lt;/p>
&lt;h2 id="731-ساختار-پایه-تست-جدولمحور-و-مثال-ساده">
7.3.1 ساختار پایه تست جدول‌محور و مثال ساده
&lt;a class="anchor" href="#731-%d8%b3%d8%a7%d8%ae%d8%aa%d8%a7%d8%b1-%d9%be%d8%a7%db%8c%d9%87-%d8%aa%d8%b3%d8%aa-%d8%ac%d8%af%d9%88%d9%84%d9%85%d8%ad%d9%88%d8%b1-%d9%88-%d9%85%d8%ab%d8%a7%d9%84-%d8%b3%d8%a7%d8%af%d9%87">#&lt;/a>
&lt;/h2>
&lt;p>الگوی تست‌های جدول‌محور در Go یکی از کاربردی‌ترین الگوهای تست‌نویسی است که توسط بسیاری از توسعه‌دهندگان و در پروژه‌های رسمی Go نیز به کار می‌رود. این سبک از تست‌نویسی، بر پایه‌ی تعریف یک جدول از سناریوهای تست و اجرای آن‌ها در یک حلقه‌ی ساده بنا شده است. هدف، کاهش تکرار در کد تست، افزایش خوانایی و ساده‌سازی افزودن موارد تست جدید است.&lt;/p>
&lt;p>در این الگو، هر ردیف جدول معمولاً یک struct است که شامل فیلدهایی مانند نام تست، ورودی‌ها، خروجی مورد انتظار، و گاهی هم انتظار وقوع خطاست. ساختار کلی آن شبیه به کد زیر است:&lt;/p>
&lt;pre>&lt;code class="language-go">func TestAdd(t *testing.T) {
tests := []struct {
name string
a, b int
expected int
}{
{&amp;quot;positive numbers&amp;quot;, 2, 3, 5},
{&amp;quot;negative numbers&amp;quot;, -1, -2, -3},
{&amp;quot;mixed signs&amp;quot;, -1, 2, 1},
}
for _, tt := range tests {
t.Run(tt.name, func(t *testing.T) {
got := Add(tt.a, tt.b)
if got != tt.expected {
t.Errorf(&amp;quot;expected %d, got %d&amp;quot;, tt.expected, got)
}
})
}
}
&lt;/code>&lt;/pre>
&lt;p>در این مثال:&lt;/p>
&lt;ul>
&lt;li>با استفاده از &lt;code>t.Run&lt;/code> برای هر تست یک subtest تعریف شده است.&lt;/li>
&lt;li>پیام‌های شکست تست شامل &lt;code>tt.name&lt;/code> هستند که گزارش خطا را واضح‌تر و دقیق‌تر می‌کنند.&lt;/li>
&lt;li>اضافه‌کردن یک سناریوی تست جدید بسیار ساده است: فقط کافی‌ست یک struct دیگر به &lt;code>tests&lt;/code> اضافه کنید.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>این سبک به‌عنوان راه‌حل رسمی جامعه‌ی Go برای تست‌های با مسیرهای متنوع در توابع معرفی شده است.&lt;/p>&lt;/blockquote>
&lt;h3 id="7311-مزایای-اصلی-این-الگو">
7.3.1.1 مزایای اصلی این الگو
&lt;a class="anchor" href="#7311-%d9%85%d8%b2%d8%a7%db%8c%d8%a7%db%8c-%d8%a7%d8%b5%d9%84%db%8c-%d8%a7%db%8c%d9%86-%d8%a7%d9%84%da%af%d9%88">#&lt;/a>
&lt;/h3>
&lt;p>مزایای اصلی این الگو عبارت‌اند از:&lt;/p>
&lt;ul>
&lt;li>کاهش قابل‌توجه تکرار کد (DRY)&lt;/li>
&lt;li>ساده‌سازی تحلیل و نگهداری تست‌ها&lt;/li>
&lt;li>قابلیت اجرای موازی آسان با &lt;code>t.Parallel()&lt;/code>&lt;/li>
&lt;li>مناسب برای پوشش مسیرهای شرطی و edge cases&lt;/li>
&lt;li>امکان افزودن متغیرهای اضافی مثل &lt;code>wantErr&lt;/code>, &lt;code>errorMessage&lt;/code>, &lt;code>expectedStatusCode&lt;/code>&lt;/li>
&lt;/ul>
&lt;h3 id="7312-جایگزینی-حلقه-ساده-با-map-برای-بهبود-خوانایی">
7.3.1.2 جایگزینی حلقه ساده با map برای بهبود خوانایی
&lt;a class="anchor" href="#7312-%d8%ac%d8%a7%db%8c%da%af%d8%b2%db%8c%d9%86%db%8c-%d8%ad%d9%84%d9%82%d9%87-%d8%b3%d8%a7%d8%af%d9%87-%d8%a8%d8%a7-map-%d8%a8%d8%b1%d8%a7%db%8c-%d8%a8%d9%87%d8%a8%d9%88%d8%af-%d8%ae%d9%88%d8%a7%d9%86%d8%a7%db%8c%db%8c">#&lt;/a>
&lt;/h3>
&lt;p>در مثال قبل از یک slice از struct استفاده شد. اما می‌توان از &lt;code>map[string]testCase]&lt;/code> هم استفاده کرد تا به‌طور مستقیم نام تست را به‌عنوان کلید بیاوریم و خوانایی را افزایش دهیم:&lt;/p>
&lt;pre>&lt;code class="language-go">func TestMultiply(t *testing.T) {
tests := map[string]struct {
a, b int
expected int
}{
&amp;quot;zero&amp;quot;: {0, 5, 0},
&amp;quot;positive&amp;quot;: {2, 3, 6},
&amp;quot;negative&amp;quot;: {-2, 4, -8},
&amp;quot;mixed signs&amp;quot;: {-3, -2, 6},
}
for name, tt := range tests {
tt := tt
t.Run(name, func(t *testing.T) {
got := Multiply(tt.a, tt.b)
if got != tt.expected {
t.Errorf(&amp;quot;expected %d, got %d&amp;quot;, tt.expected, got)
}
})
}
}
&lt;/code>&lt;/pre>
&lt;p>نکته مهم در این مثال این است که حتماً باید از کپی &lt;code>tt := tt&lt;/code> در ابتدای هر subtest استفاده کنیم، تا از مشکل closure جلوگیری شود.&lt;/p>
&lt;h3 id="7313-مقایسه-با-تستهای-کلاسیک">
7.3.1.3 مقایسه با تست‌های کلاسیک
&lt;a class="anchor" href="#7313-%d9%85%d9%82%d8%a7%db%8c%d8%b3%d9%87-%d8%a8%d8%a7-%d8%aa%d8%b3%d8%aa%d9%87%d8%a7%db%8c-%da%a9%d9%84%d8%a7%d8%b3%db%8c%da%a9">#&lt;/a>
&lt;/h3>
&lt;p>در تست‌های کلاسیک، ممکن است سه یا چهار تابع تست مختلف برای یک تابع ساده نوشته شود، که هم خوانایی را پایین می‌آورد و هم نگهداری را سخت می‌کند. با Table Test، می‌توان همه این تست‌ها را در یک حلقه با ساختار مشترک نگه داشت.&lt;/p>
&lt;h3 id="7314-زمانی-که-table-test-مناسب-نیست">
7.3.1.4 زمانی که Table Test مناسب نیست
&lt;a class="anchor" href="#7314-%d8%b2%d9%85%d8%a7%d9%86%db%8c-%da%a9%d9%87-table-test-%d9%85%d9%86%d8%a7%d8%b3%d8%a8-%d9%86%db%8c%d8%b3%d8%aa">#&lt;/a>
&lt;/h3>
&lt;p>گرچه این الگو بسیار مفید است، اما همیشه انتخاب درست نیست. طبق منابع:&lt;/p>
&lt;ul>
&lt;li>اگر تست فقط یک حالت دارد، استفاده از جدول ممکن است کد را بی‌جهت پیچیده کند.&lt;/li>
&lt;li>در برخی تست‌های سطح بالا یا تست‌های تعامل‌محور (مثل تست UI یا سرویس‌های REST)، بهتر است تست‌ها به‌صورت مستقل و سناریو محور نوشته شوند، نه جدول‌محور.&lt;/li>
&lt;/ul>
&lt;h2 id="732-تست-خطا-و-ورودیهای-نادرست-در-table-tests">
7.3.2 تست خطا و ورودی‌های نادرست در Table Tests
&lt;a class="anchor" href="#732-%d8%aa%d8%b3%d8%aa-%d8%ae%d8%b7%d8%a7-%d9%88-%d9%88%d8%b1%d9%88%d8%af%db%8c%d9%87%d8%a7%db%8c-%d9%86%d8%a7%d8%af%d8%b1%d8%b3%d8%aa-%d8%af%d8%b1-table-tests">#&lt;/a>
&lt;/h2>
&lt;p>یکی از مهم‌ترین مزایای تست‌های جدول‌محور این است که می‌توان به‌راحتی سناریوهای مثبت و منفی را در کنار هم پوشش داد. به‌ویژه زمانی که توابع شما ممکن است خطا بازگردانند یا در برابر ورودی‌های ناسالم رفتاری خاص نشان دهند، این سبک از تست‌نویسی به شکل چشمگیری ساخت‌یافته و مؤثر خواهد بود.&lt;/p>
&lt;p>در طراحی جدول تست، معمولاً از فیلدی به‌نام &lt;code>wantErr&lt;/code> یا &lt;code>expectErr&lt;/code> برای تعیین انتظار بروز خطا استفاده می‌شود. این متغیر به تست‌نویس امکان می‌دهد تا به‌صورت واضح اعلام کند آیا در هر سناریو وقوع خطا انتظار می‌رود یا خیر.&lt;/p>
&lt;h3 id="7321-ساختار-تست-شامل-انتظار-خطا">
7.3.2.1 ساختار تست شامل انتظار خطا
&lt;a class="anchor" href="#7321-%d8%b3%d8%a7%d8%ae%d8%aa%d8%a7%d8%b1-%d8%aa%d8%b3%d8%aa-%d8%b4%d8%a7%d9%85%d9%84-%d8%a7%d9%86%d8%aa%d8%b8%d8%a7%d8%b1-%d8%ae%d8%b7%d8%a7">#&lt;/a>
&lt;/h3>
&lt;pre>&lt;code class="language-go">func Divide(a, b int) (int, error) {
if b == 0 {
return 0, fmt.Errorf(&amp;quot;division by zero&amp;quot;)
}
return a / b, nil
}
&lt;/code>&lt;/pre>
&lt;p>تست جدول‌محور برای پوشش رفتار صحیح و خطا:&lt;/p>
&lt;pre>&lt;code class="language-go">func TestDivide(t *testing.T) {
tests := []struct {
name string
a, b int
want int
wantErr bool
}{
{&amp;quot;valid division&amp;quot;, 6, 3, 2, false},
{&amp;quot;zero divisor&amp;quot;, 5, 0, 0, true},
}
for _, tt := range tests {
tt := tt
t.Run(tt.name, func(t *testing.T) {
got, err := Divide(tt.a, tt.b)
if (err != nil) != tt.wantErr {
t.Fatalf(&amp;quot;unexpected error state: %v&amp;quot;, err)
}
if !tt.wantErr &amp;amp;&amp;amp; got != tt.want {
t.Errorf(&amp;quot;expected %d, got %d&amp;quot;, tt.want, got)
}
})
}
}
&lt;/code>&lt;/pre>
&lt;p>در این ساختار:&lt;/p>
&lt;ul>
&lt;li>تست اول بررسی می‌کند که تقسیم معمولی به درستی انجام شده.&lt;/li>
&lt;li>تست دوم بررسی می‌کند که در تقسیم بر صفر، خطای مناسب بازگردانده شده.&lt;/li>
&lt;/ul>
&lt;h3 id="7322-نکاتی-در-مورد-مقایسه-خطا">
7.3.2.2 نکاتی در مورد مقایسه خطا
&lt;a class="anchor" href="#7322-%d9%86%da%a9%d8%a7%d8%aa%db%8c-%d8%af%d8%b1-%d9%85%d9%88%d8%b1%d8%af-%d9%85%d9%82%d8%a7%db%8c%d8%b3%d9%87-%d8%ae%d8%b7%d8%a7">#&lt;/a>
&lt;/h3>
&lt;p>برای تست دقیق‌تر خطا، گاهی لازم است پیام خطا یا نوع خطا بررسی شود. این کار را می‌توان با روش‌های مختلف انجام داد:&lt;/p>
&lt;h4 id="مقایسه-پیام-خطا">
مقایسه پیام خطا
&lt;a class="anchor" href="#%d9%85%d9%82%d8%a7%db%8c%d8%b3%d9%87-%d9%be%db%8c%d8%a7%d9%85-%d8%ae%d8%b7%d8%a7">#&lt;/a>
&lt;/h4>
&lt;pre>&lt;code class="language-go">if err != nil &amp;amp;&amp;amp; err.Error() != &amp;quot;division by zero&amp;quot; {
t.Errorf(&amp;quot;unexpected error message: %v&amp;quot;, err)
}
&lt;/code>&lt;/pre>
&lt;h4 id="استفاده-از-errorsis-یا-errorsas">
استفاده از &lt;code>errors.Is&lt;/code> یا &lt;code>errors.As&lt;/code>
&lt;a class="anchor" href="#%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-errorsis-%db%8c%d8%a7-errorsas">#&lt;/a>
&lt;/h4>
&lt;p>اگر خطا wrap شده باشد:&lt;/p>
&lt;pre>&lt;code class="language-go">var ErrDivideByZero = errors.New(&amp;quot;division by zero&amp;quot;)
if !errors.Is(err, ErrDivideByZero) {
t.Errorf(&amp;quot;expected ErrDivideByZero, got %v&amp;quot;, err)
}
&lt;/code>&lt;/pre>
&lt;h3 id="7323-ترکیب-با-subtest-برای-مدیریت-بهتر">
7.3.2.3 ترکیب با subtest برای مدیریت بهتر
&lt;a class="anchor" href="#7323-%d8%aa%d8%b1%da%a9%db%8c%d8%a8-%d8%a8%d8%a7-subtest-%d8%a8%d8%b1%d8%a7%db%8c-%d9%85%d8%af%db%8c%d8%b1%db%8c%d8%aa-%d8%a8%d9%87%d8%aa%d8%b1">#&lt;/a>
&lt;/h3>
&lt;p>حتی در سناریوهای شامل خطا هم می‌توان از &lt;code>t.Parallel()&lt;/code> برای اجرای موازی تست‌ها استفاده کرد، به شرطی که مقدار &lt;code>tt&lt;/code> را در scope هر subtest کپی کرده باشیم:&lt;/p>
&lt;pre>&lt;code class="language-go">t.Run(tt.name, func(t *testing.T) {
t.Parallel()
// اجرای تست
})
&lt;/code>&lt;/pre>
&lt;h3 id="7324-طراحی-سناریوهای-پیچیدهتر">
7.3.2.4 طراحی سناریوهای پیچیده‌تر
&lt;a class="anchor" href="#7324-%d8%b7%d8%b1%d8%a7%d8%ad%db%8c-%d8%b3%d9%86%d8%a7%d8%b1%db%8c%d9%88%d9%87%d8%a7%db%8c-%d9%be%db%8c%da%86%db%8c%d8%af%d9%87%d8%aa%d8%b1">#&lt;/a>
&lt;/h3>
&lt;p>در بسیاری از پروژه‌ها ممکن است تست شامل چند فیلد دیگر مثل ورودی‌های پیچیده‌تر، اشیای اولیه‌شده، یا توابع callback باشد. در این صورت هم جدول تست می‌تواند گسترش یابد و همچنان خوانا باقی بماند.&lt;/p>
&lt;p>مثال:&lt;/p>
&lt;pre>&lt;code class="language-go">tests := []struct {
name string
input Request
want Response
wantErr bool
}{
{&amp;quot;valid input&amp;quot;, Request{ID: 1}, Response{Success: true}, false},
{&amp;quot;invalid input&amp;quot;, Request{}, Response{}, true},
}
&lt;/code>&lt;/pre>
&lt;h2 id="733-اجرای-موازی-در-تستهای-جدولمحور-با-tparallel">
7.3.3 اجرای موازی در تست‌های جدول‌محور با t.Parallel
&lt;a class="anchor" href="#733-%d8%a7%d8%ac%d8%b1%d8%a7%db%8c-%d9%85%d9%88%d8%a7%d8%b2%db%8c-%d8%af%d8%b1-%d8%aa%d8%b3%d8%aa%d9%87%d8%a7%db%8c-%d8%ac%d8%af%d9%88%d9%84%d9%85%d8%ad%d9%88%d8%b1-%d8%a8%d8%a7-tparallel">#&lt;/a>
&lt;/h2>
&lt;p>اجرای تست‌ها به‌صورت موازی، یکی از قابلیت‌های مهم زبان Go است که می‌تواند سرعت اجرای تست‌ها را به شکل قابل‌توجهی افزایش دهد—به‌ویژه زمانی که تعداد زیادی تست داریم و هر تست مستقل از دیگری است. این ویژگی در کنار ساختار جدول‌محور، قدرتی ترکیبی می‌سازد که هم خوانایی بالا دارد و هم بازدهی.&lt;/p>
&lt;p>تابع &lt;code>t.Parallel()&lt;/code> به Go اعلام می‌کند که تست جاری می‌تواند به‌صورت همزمان با سایر تست‌ها اجرا شود. اما برای استفاده صحیح از این ویژگی در حلقه‌ی تست‌های جدول‌محور، باید نکته‌ای کلیدی را رعایت کرد: متغیر loop (مانند &lt;code>tt&lt;/code>) باید داخل scope هر subtest مجدداً shadow شود. در غیر این صورت، همه goroutineها ممکن است به مقدار یکسانی از &lt;code>tt&lt;/code> اشاره کنند و باعث بروز نتایج اشتباه شوند.&lt;/p>
&lt;h3 id="7331-مثال-صحیح-استفاده-از-tparallel">
7.3.3.1 مثال صحیح استفاده از t.Parallel
&lt;a class="anchor" href="#7331-%d9%85%d8%ab%d8%a7%d9%84-%d8%b5%d8%ad%db%8c%d8%ad-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-tparallel">#&lt;/a>
&lt;/h3>
&lt;pre>&lt;code class="language-go">func TestMultiply(t *testing.T) {
tests := []struct {
name string
a, b int
expected int
}{
{&amp;quot;positive&amp;quot;, 2, 3, 6},
{&amp;quot;zero&amp;quot;, 0, 4, 0},
{&amp;quot;negative&amp;quot;, -1, 3, -3},
}
for _, tt := range tests {
tt := tt // کپی کردن متغیر برای جلوگیری از race
t.Run(tt.name, func(t *testing.T) {
t.Parallel()
got := Multiply(tt.a, tt.b)
if got != tt.expected {
t.Errorf(&amp;quot;expected %d, got %d&amp;quot;, tt.expected, got)
}
})
}
}
&lt;/code>&lt;/pre>
&lt;p>در این مثال:&lt;/p>
&lt;ul>
&lt;li>&lt;code>t.Parallel()&lt;/code> در ابتدای هر subtest فراخوانی شده.&lt;/li>
&lt;li>متغیر &lt;code>tt := tt&lt;/code> باعث شده هر goroutine مقدار اختصاصی خود را داشته باشد.&lt;/li>
&lt;/ul>
&lt;h3 id="7332-چه-زمانی-نباید-از-tparallel-استفاده-کنیم">
7.3.3.2 چه زمانی نباید از t.Parallel استفاده کنیم
&lt;a class="anchor" href="#7332-%da%86%d9%87-%d8%b2%d9%85%d8%a7%d9%86%db%8c-%d9%86%d8%a8%d8%a7%db%8c%d8%af-%d8%a7%d8%b2-tparallel-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%da%a9%d9%86%db%8c%d9%85">#&lt;/a>
&lt;/h3>
&lt;p>با وجود مزایای بالا، استفاده از اجرای موازی در همه‌ی تست‌ها توصیه نمی‌شود. در موارد زیر باید با احتیاط یا اصلاً از &lt;code>t.Parallel()&lt;/code> استفاده نکنید:&lt;/p>
&lt;ol>
&lt;li>&lt;strong>تست‌هایی که به منابع مشترک دسترسی دارند&lt;/strong>
مانند فایل سیستم، دیتابیس، متغیرهای global یا سرویس خارجی.&lt;/li>
&lt;li>&lt;strong>تست‌هایی که به ترتیب اجرا وابسته‌اند&lt;/strong>&lt;/li>
&lt;li>&lt;strong>تست‌هایی که در زمان اجرا وضعیت را تغییر می‌دهند&lt;/strong>
مثلاً حذف یا ایجاد فایل، تغییر در داده‌های اشتراکی.&lt;/li>
&lt;/ol>
&lt;p>در این موارد، یا تست‌ها را به صورت ترتیبی اجرا کنید، یا منابع را ایزوله کنید (مثلاً از &lt;code>t.TempDir()&lt;/code> برای مسیرهای جداگانه استفاده کنید).&lt;/p>
&lt;h3 id="7333-ترکیب-تست-موازی-با-زیرساخت-ci">
7.3.3.3 ترکیب تست موازی با زیرساخت CI
&lt;a class="anchor" href="#7333-%d8%aa%d8%b1%da%a9%db%8c%d8%a8-%d8%aa%d8%b3%d8%aa-%d9%85%d9%88%d8%a7%d8%b2%db%8c-%d8%a8%d8%a7-%d8%b2%db%8c%d8%b1%d8%b3%d8%a7%d8%ae%d8%aa-ci">#&lt;/a>
&lt;/h3>
&lt;p>اجرای موازی تست‌ها در CI/CD، به‌ویژه برای پروژه‌های بزرگ، مزیت مهمی محسوب می‌شود. اما لازم است:&lt;/p>
&lt;ul>
&lt;li>تست‌ها ایزوله باشند.&lt;/li>
&lt;li>از حافظه یا دیسک مشترک استفاده نکنند.&lt;/li>
&lt;li>تست‌ها به‌صورت مستقل از محیط اجرا شوند.&lt;/li>
&lt;/ul>
&lt;h2 id="734-ساخت-تستهای-قابل-نگهداری-و-خوانا-در-جدولها">
7.3.4 ساخت تست‌های قابل نگهداری و خوانا در جدول‌ها
&lt;a class="anchor" href="#734-%d8%b3%d8%a7%d8%ae%d8%aa-%d8%aa%d8%b3%d8%aa%d9%87%d8%a7%db%8c-%d9%82%d8%a7%d8%a8%d9%84-%d9%86%da%af%d9%87%d8%af%d8%a7%d8%b1%db%8c-%d9%88-%d8%ae%d9%88%d8%a7%d9%86%d8%a7-%d8%af%d8%b1-%d8%ac%d8%af%d9%88%d9%84%d9%87%d8%a7">#&lt;/a>
&lt;/h2>
&lt;p>یکی از دلایل اصلی محبوبیت تست‌های جدول‌محور، سهولت در نگهداری و خوانایی بالای آن‌هاست. اما اگر این الگو به‌درستی اجرا نشود، می‌تواند به کدی پیچیده، گنگ و به‌سختی قابل گسترش تبدیل شود. در این بخش، تکنیک‌هایی برای نوشتن تست‌های جدول‌محور خوانا، قابل گسترش و با حداقل خطا ارائه می‌شود.&lt;/p>
&lt;h3 id="7341-استفاده-از-نامهای-گویا-برای-هر-تست">
7.3.4.1 استفاده از نام‌های گویا برای هر تست
&lt;a class="anchor" href="#7341-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-%d9%86%d8%a7%d9%85%d9%87%d8%a7%db%8c-%da%af%d9%88%db%8c%d8%a7-%d8%a8%d8%b1%d8%a7%db%8c-%d9%87%d8%b1-%d8%aa%d8%b3%d8%aa">#&lt;/a>
&lt;/h3>
&lt;p>در جدول تست، فیلد &lt;code>name&lt;/code> باید دقیق، گویا و منعکس‌کننده‌ی هدف هر تست باشد. این نام در گزارش‌های خروجی تست نمایش داده می‌شود و کلید تحلیل سریع‌تر خطاهاست.&lt;/p>
&lt;p>مثال خوب:&lt;/p>
&lt;pre>&lt;code class="language-go">{
name: &amp;quot;returns error when divisor is zero&amp;quot;,
a: 10, b: 0, wantErr: true,
}
&lt;/code>&lt;/pre>
&lt;p>اجتناب شود از نام‌هایی مانند:&lt;/p>
&lt;pre>&lt;code class="language-go">&amp;quot;name&amp;quot;: &amp;quot;test1&amp;quot;
&lt;/code>&lt;/pre>
&lt;h3 id="7342-مرتبسازی-منطقی-تستها">
7.3.4.2 مرتب‌سازی منطقی تست‌ها
&lt;a class="anchor" href="#7342-%d9%85%d8%b1%d8%aa%d8%a8%d8%b3%d8%a7%d8%b2%db%8c-%d9%85%d9%86%d8%b7%d9%82%db%8c-%d8%aa%d8%b3%d8%aa%d9%87%d8%a7">#&lt;/a>
&lt;/h3>
&lt;p>در جدول تست، بهتر است تست‌ها را به ترتیب معنایی یا گروه‌بندی شده قرار دهید:&lt;/p>
&lt;ul>
&lt;li>تست‌های موفق اول، سپس تست‌های خطا&lt;/li>
&lt;li>یا تست‌هایی با رفتار مشابه در کنار هم
این کار، درک و دیباگ تست را ساده‌تر می‌کند.&lt;/li>
&lt;/ul>
&lt;h3 id="7343-تعریف-type-مجزا-برای-تستکیسها-در-پروژههای-بزرگ">
7.3.4.3 تعریف type مجزا برای تست‌کیس‌ها (در پروژه‌های بزرگ)
&lt;a class="anchor" href="#7343-%d8%aa%d8%b9%d8%b1%db%8c%d9%81-type-%d9%85%d8%ac%d8%b2%d8%a7-%d8%a8%d8%b1%d8%a7%db%8c-%d8%aa%d8%b3%d8%aa%da%a9%db%8c%d8%b3%d9%87%d8%a7-%d8%af%d8%b1-%d9%be%d8%b1%d9%88%da%98%d9%87%d9%87%d8%a7%db%8c-%d8%a8%d8%b2%d8%b1%da%af">#&lt;/a>
&lt;/h3>
&lt;p>برای جلوگیری از تکرار تعریف struct در چندین تابع تست و ارتقای وضوح کد، می‌توان type اختصاصی برای تست‌کیس‌ها تعریف کرد:&lt;/p>
&lt;pre>&lt;code class="language-go">type divideTestCase struct {
name string
a, b int
want int
wantErr bool
}
&lt;/code>&lt;/pre>
&lt;p>و سپس در جدول تست:&lt;/p>
&lt;pre>&lt;code class="language-go">tests := []divideTestCase{ ... }
&lt;/code>&lt;/pre>
&lt;p>این کار به‌ویژه در تست‌های پیچیده یا تکراری در چند فایل بسیار مفید است.&lt;/p>
&lt;h3 id="7344-تعریف-توابع-کمکی-برای-assertions-و-آمادهسازی">
7.3.4.4 تعریف توابع کمکی برای assertions و آماده‌سازی
&lt;a class="anchor" href="#7344-%d8%aa%d8%b9%d8%b1%db%8c%d9%81-%d8%aa%d9%88%d8%a7%d8%a8%d8%b9-%da%a9%d9%85%da%a9%db%8c-%d8%a8%d8%b1%d8%a7%db%8c-assertions-%d9%88-%d8%a2%d9%85%d8%a7%d8%af%d9%87%d8%b3%d8%a7%d8%b2%db%8c">#&lt;/a>
&lt;/h3>
&lt;p>در صورت نیاز به تکرار منطق‌های بررسی نتیجه، یا ایجاد ورودی‌های خاص، بهتر است توابع کمکی بنویسید تا از تکرار و پراکندگی منطق جلوگیری شود.&lt;/p>
&lt;p>مثال:&lt;/p>
&lt;pre>&lt;code class="language-go">func assertEqual(t *testing.T, got, want int) {
if got != want {
t.Errorf(&amp;quot;expected %d, got %d&amp;quot;, want, got)
}
}
&lt;/code>&lt;/pre>
&lt;p>و در تست:&lt;/p>
&lt;pre>&lt;code class="language-go">t.Run(tc.name, func(t *testing.T) {
result := Add(tc.a, tc.b)
assertEqual(t, result, tc.expected)
})
&lt;/code>&lt;/pre>
&lt;h3 id="7345-الگوی-توصیهشده-برای-تستهای-قابل-نگهداری">
7.3.4.5 الگوی توصیه‌شده برای تست‌های قابل نگهداری
&lt;a class="anchor" href="#7345-%d8%a7%d9%84%da%af%d9%88%db%8c-%d8%aa%d9%88%d8%b5%db%8c%d9%87%d8%b4%d8%af%d9%87-%d8%a8%d8%b1%d8%a7%db%8c-%d8%aa%d8%b3%d8%aa%d9%87%d8%a7%db%8c-%d9%82%d8%a7%d8%a8%d9%84-%d9%86%da%af%d9%87%d8%af%d8%a7%d8%b1%db%8c">#&lt;/a>
&lt;/h3>
&lt;pre>&lt;code class="language-go">type mathTest struct {
name string
a, b int
want int
wantErr bool
}
func TestDivide(t *testing.T) {
cases := []mathTest{
{&amp;quot;valid input&amp;quot;, 8, 2, 4, false},
{&amp;quot;zero divisor&amp;quot;, 10, 0, 0, true},
}
for _, tc := range cases {
tc := tc
t.Run(tc.name, func(t *testing.T) {
t.Parallel()
got, err := Divide(tc.a, tc.b)
if (err != nil) != tc.wantErr {
t.Errorf(&amp;quot;unexpected error state: %v&amp;quot;, err)
}
if !tc.wantErr &amp;amp;&amp;amp; got != tc.want {
t.Errorf(&amp;quot;expected %d, got %d&amp;quot;, tc.want, got)
}
})
}
}
&lt;/code>&lt;/pre>
&lt;p>در این الگو:&lt;/p>
&lt;ul>
&lt;li>&lt;code>t.Parallel()&lt;/code> برای سرعت بالا&lt;/li>
&lt;li>&lt;code>tc := tc&lt;/code> برای جلوگیری از closure bug&lt;/li>
&lt;li>پیام‌های دقیق و واضح&lt;/li>
&lt;li>struct مشخص و تایپ‌شده برای هر تست&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>از&lt;a href="https://go.dev/blog/loopvar-preview"> نسخه 1.22 این مشکل&lt;/a> حالت کاملا حل شده است و نیازی به shadowing نیست.&lt;/p>&lt;/blockquote>
&lt;h2 id="735-استفاده-از-تستهای-تو-در-تو-subtests-در-table-test">
7.3.5 استفاده از تست‌های تو در تو (Subtests) در Table Test
&lt;a class="anchor" href="#735-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-%d8%aa%d8%b3%d8%aa%d9%87%d8%a7%db%8c-%d8%aa%d9%88-%d8%af%d8%b1-%d8%aa%d9%88-subtests-%d8%af%d8%b1-table-test">#&lt;/a>
&lt;/h2>
&lt;p>در بسیاری از مواقع، هر سناریوی تست خودش شامل چند حالت بررسی‌شدنی است. به‌جای اینکه این موارد را به تست‌های مجزای بزرگ و تودرتو تبدیل کنیم، می‌توان با استفاده از &lt;code>t.Run&lt;/code> برای هر بخش از منطق، تست‌های تو در تو (Subtests) تعریف کرد. این قابلیت که از Go 1.7 به بعد اضافه شده، ابزار قدرتمندی برای سازمان‌دهی بهتر تست‌ها، گزارش‌گیری دقیق‌تر و امکان اجرای هدفمند تست‌ها فراهم می‌کند.&lt;/p>
&lt;h3 id="7351-مثال-ساده-از-subtest-در-table-test">
7.3.5.1 مثال ساده از Subtest در Table Test
&lt;a class="anchor" href="#7351-%d9%85%d8%ab%d8%a7%d9%84-%d8%b3%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-subtest-%d8%af%d8%b1-table-test">#&lt;/a>
&lt;/h3>
&lt;p>فرض کنیم تابعی داریم که عملیات روی کاربر انجام می‌دهد و در هر حالت باید چند ویژگی خروجی را بررسی کنیم. برای هر حالت، چند subtest تعریف می‌کنیم:&lt;/p>
&lt;pre>&lt;code class="language-go">func TestUserValidation(t *testing.T) {
tests := []struct {
name string
user User
wantErr bool
wantRole string
}{
{&amp;quot;valid user&amp;quot;, User{Email: &amp;quot;a@b.com&amp;quot;}, false, &amp;quot;user&amp;quot;},
{&amp;quot;missing email&amp;quot;, User{}, true, &amp;quot;&amp;quot;},
}
for _, tt := range tests {
tt := tt
t.Run(tt.name, func(t *testing.T) {
t.Run(&amp;quot;validate email&amp;quot;, func(t *testing.T) {
err := tt.user.Validate()
if (err != nil) != tt.wantErr {
t.Errorf(&amp;quot;error mismatch: %v&amp;quot;, err)
}
})
t.Run(&amp;quot;check role&amp;quot;, func(t *testing.T) {
if tt.user.Role() != tt.wantRole {
t.Errorf(&amp;quot;expected role %q, got %q&amp;quot;, tt.wantRole, tt.user.Role())
}
})
})
}
}
&lt;/code>&lt;/pre>
&lt;p>در این مثال:&lt;/p>
&lt;ul>
&lt;li>هر &lt;code>tt&lt;/code> یک مورد جدول تست است.&lt;/li>
&lt;li>دو زیرتست برای هر &lt;code>tt&lt;/code> اجرا می‌شود:
&lt;ul>
&lt;li>بررسی اعتبار ایمیل&lt;/li>
&lt;li>بررسی نقش پیش‌فرض&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>خروجی تست‌ها در گزارش نیز به صورت سلسله‌مراتبی نشان داده می‌شود که کمک بزرگی به عیب‌یابی است.&lt;/p>
&lt;h3 id="7352-مزایای-استفاده-از-subtestها-در-table-test">
7.3.5.2 مزایای استفاده از Subtestها در Table Test
&lt;a class="anchor" href="#7352-%d9%85%d8%b2%d8%a7%db%8c%d8%a7%db%8c-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-subtest%d9%87%d8%a7-%d8%af%d8%b1-table-test">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>دسته‌بندی معنایی تست‌ها&lt;/strong>: هر مرحله از تست می‌تواند subtest جداگانه داشته باشد.&lt;/li>
&lt;li>&lt;strong>گزارش دقیق‌تر خطا&lt;/strong>: نام تست‌های تودرتو در گزارش CLI و CI به صورت کامل دیده می‌شود.&lt;/li>
&lt;li>&lt;strong>امکان اجرای selective&lt;/strong>: می‌توان فقط یک subtest خاص را با flag &lt;code>-run&lt;/code> اجرا کرد:&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-bash">go test -run=&amp;quot;TestUserValidation/valid_user/check_role&amp;quot;
&lt;/code>&lt;/pre>
&lt;h3 id="7353-اجرای-موازی-subtestها">
7.3.5.3 اجرای موازی Subtestها
&lt;a class="anchor" href="#7353-%d8%a7%d8%ac%d8%b1%d8%a7%db%8c-%d9%85%d9%88%d8%a7%d8%b2%db%8c-subtest%d9%87%d8%a7">#&lt;/a>
&lt;/h3>
&lt;p>در صورتی که هر subtest ایزوله باشد، می‌توان از &lt;code>t.Parallel()&lt;/code> نیز داخل آن استفاده کرد:&lt;/p>
&lt;pre>&lt;code class="language-go">t.Run(&amp;quot;parallel section&amp;quot;, func(t *testing.T) {
t.Parallel()
// عملیات تست
})
&lt;/code>&lt;/pre>
&lt;h3 id="7354-نمونهای-پیشرفتهتر-table--subtest--parallel">
7.3.5.4 نمونه‌ای پیشرفته‌تر: Table + Subtest + Parallel
&lt;a class="anchor" href="#7354-%d9%86%d9%85%d9%88%d9%86%d9%87%d8%a7%db%8c-%d9%be%db%8c%d8%b4%d8%b1%d9%81%d8%aa%d9%87%d8%aa%d8%b1-table--subtest--parallel">#&lt;/a>
&lt;/h3>
&lt;pre>&lt;code class="language-go">func TestCalculator(t *testing.T) {
tests := []struct {
name string
a, b int
}{
{&amp;quot;positive&amp;quot;, 1, 2},
{&amp;quot;negative&amp;quot;, -1, -3},
}
for _, tt := range tests {
tt := tt
t.Run(tt.name, func(t *testing.T) {
t.Run(&amp;quot;Add&amp;quot;, func(t *testing.T) {
t.Parallel()
if Add(tt.a, tt.b) != tt.a+tt.b {
t.Fail()
}
})
t.Run(&amp;quot;Multiply&amp;quot;, func(t *testing.T) {
t.Parallel()
if Multiply(tt.a, tt.b) != tt.a*tt.b {
t.Fail()
}
})
})
}
}
&lt;/code>&lt;/pre>
&lt;h2 id="736-خطاهای-رایج-در-پیادهسازی-table-tests">
7.3.6 خطاهای رایج در پیاده‌سازی Table Tests
&lt;a class="anchor" href="#736-%d8%ae%d8%b7%d8%a7%d9%87%d8%a7%db%8c-%d8%b1%d8%a7%db%8c%d8%ac-%d8%af%d8%b1-%d9%be%db%8c%d8%a7%d8%af%d9%87%d8%b3%d8%a7%d8%b2%db%8c-table-tests">#&lt;/a>
&lt;/h2>
&lt;p>اگرچه تست‌های جدول‌محور در Go بسیار توصیه می‌شوند و ساختار مؤثری برای مدیریت سناریوهای متنوع تست فراهم می‌کنند، اما اگر به‌درستی پیاده‌سازی نشوند، می‌توانند منجر به تست‌هایی شکننده، گمراه‌کننده یا حتی ناکارآمد شوند. در این بخش، به بررسی خطاهای رایج در پیاده‌سازی Table Tests و راه‌های جلوگیری از آن‌ها می‌پردازیم.&lt;/p>
&lt;h3 id="7361-استفاده-اشتباه-از-متغیر-loop-closure-bug">
7.3.6.1 استفاده اشتباه از متغیر loop (closure bug)
&lt;a class="anchor" href="#7361-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b4%d8%aa%d8%a8%d8%a7%d9%87-%d8%a7%d8%b2-%d9%85%d8%aa%d8%ba%db%8c%d8%b1-loop-closure-bug">#&lt;/a>
&lt;/h3>
&lt;p>یکی از خطرناک‌ترین و رایج‌ترین اشتباهات، استفاده مستقیم از متغیر loop (&lt;code>tt&lt;/code>) درون تابع &lt;code>t.Run&lt;/code> است. به دلیل اینکه &lt;code>tt&lt;/code> در هر iteration یک متغیر مشترک است، همه goroutineها ممکن است به آخرین مقدار آن دسترسی داشته باشند.&lt;/p>
&lt;p>❌ مثال اشتباه:&lt;/p>
&lt;pre>&lt;code class="language-go">for _, tt := range tests {
t.Run(tt.name, func(t *testing.T) {
t.Parallel()
doTest(tt)
})
}
&lt;/code>&lt;/pre>
&lt;p>✅ راه حل صحیح:&lt;/p>
&lt;pre>&lt;code class="language-go">for _, tt := range tests {
tt := tt // shadowing → ایجاد نسخه مجزا از tt
t.Run(tt.name, func(t *testing.T) {
t.Parallel()
doTest(tt)
})
}
&lt;/code>&lt;/pre>
&lt;h3 id="7362-عدم-گزارش-نام-تست-در-پیام-خطا">
7.3.6.2 عدم گزارش نام تست در پیام خطا
&lt;a class="anchor" href="#7362-%d8%b9%d8%af%d9%85-%da%af%d8%b2%d8%a7%d8%b1%d8%b4-%d9%86%d8%a7%d9%85-%d8%aa%d8%b3%d8%aa-%d8%af%d8%b1-%d9%be%db%8c%d8%a7%d9%85-%d8%ae%d8%b7%d8%a7">#&lt;/a>
&lt;/h3>
&lt;p>در گزارش خطاها، اگر از نام تست استفاده نشود، تشخیص خطای رخ‌داده دشوار می‌شود؛ مخصوصاً وقتی چندین تست پشت سر هم fail می‌شوند.&lt;/p>
&lt;p>❌ اشتباه رایج:&lt;/p>
&lt;pre>&lt;code class="language-go">t.Errorf(&amp;quot;expected %d, got %d&amp;quot;, want, got)
&lt;/code>&lt;/pre>
&lt;p>✅ شکل بهتر:&lt;/p>
&lt;pre>&lt;code class="language-go">t.Errorf(&amp;quot;%s: expected %d, got %d&amp;quot;, tt.name, want, got)
&lt;/code>&lt;/pre>
&lt;p>یا با subtestها، نیازی به این کار نیست چون &lt;code>t.Run&lt;/code> خودش context لازم را دارد.&lt;/p>
&lt;h3 id="7363-بررسی-نکردن-خطا-وقتی-wanterr-مشخص-است">
7.3.6.3 بررسی نکردن خطا وقتی &lt;code>wantErr&lt;/code> مشخص است
&lt;a class="anchor" href="#7363-%d8%a8%d8%b1%d8%b1%d8%b3%db%8c-%d9%86%da%a9%d8%b1%d8%af%d9%86-%d8%ae%d8%b7%d8%a7-%d9%88%d9%82%d8%aa%db%8c-wanterr-%d9%85%d8%b4%d8%ae%d8%b5-%d8%a7%d8%b3%d8%aa">#&lt;/a>
&lt;/h3>
&lt;p>در بسیاری از تست‌ها فیلدی به نام &lt;code>wantErr&lt;/code> تعریف می‌شود اما بررسی درستی روی آن انجام نمی‌گیرد یا فقط وجود/عدم وجود &lt;code>err&lt;/code> بررسی می‌شود، بدون توجه به نوع خطا.&lt;/p>
&lt;p>✅ پیشنهاد بهتر:&lt;/p>
&lt;pre>&lt;code class="language-go">if (err != nil) != tt.wantErr {
t.Fatalf(&amp;quot;unexpected error state: %v&amp;quot;, err)
}
&lt;/code>&lt;/pre>
&lt;p>در صورت نیاز، بررسی نوع خطا با &lt;code>errors.Is&lt;/code> یا &lt;code>errors.As&lt;/code> نیز می‌تواند اضافه شود.&lt;/p>
&lt;h3 id="7364-تست-نکردن-مقدار-خروجی-وقتی-خطا-انتظار-نمیرود">
7.3.6.4 تست نکردن مقدار خروجی وقتی خطا انتظار نمی‌رود
&lt;a class="anchor" href="#7364-%d8%aa%d8%b3%d8%aa-%d9%86%da%a9%d8%b1%d8%af%d9%86-%d9%85%d9%82%d8%af%d8%a7%d8%b1-%d8%ae%d8%b1%d9%88%d8%ac%db%8c-%d9%88%d9%82%d8%aa%db%8c-%d8%ae%d8%b7%d8%a7-%d8%a7%d9%86%d8%aa%d8%b8%d8%a7%d8%b1-%d9%86%d9%85%db%8c%d8%b1%d9%88%d8%af">#&lt;/a>
&lt;/h3>
&lt;p>❌ اشتباه رایج:&lt;/p>
&lt;pre>&lt;code class="language-go">if err != nil {
t.Fatalf(&amp;quot;unexpected error: %v&amp;quot;, err)
}
// هیچ بررسی‌ای روی خروجی انجام نشده
&lt;/code>&lt;/pre>
&lt;p>✅ راه صحیح:&lt;/p>
&lt;pre>&lt;code class="language-go">if err != nil {
t.Fatalf(&amp;quot;unexpected error: %v&amp;quot;, err)
}
if got != tt.want {
t.Errorf(&amp;quot;expected %v, got %v&amp;quot;, tt.want, got)
}
&lt;/code>&lt;/pre>
&lt;h3 id="7365-تبدیل-جدول-تست-به-پیچیدگی-غیرقابلخواندن">
7.3.6.5 تبدیل جدول تست به پیچیدگی غیرقابل‌خواندن
&lt;a class="anchor" href="#7365-%d8%aa%d8%a8%d8%af%db%8c%d9%84-%d8%ac%d8%af%d9%88%d9%84-%d8%aa%d8%b3%d8%aa-%d8%a8%d9%87-%d9%be%db%8c%da%86%db%8c%d8%af%da%af%db%8c-%d8%ba%db%8c%d8%b1%d9%82%d8%a7%d8%a8%d9%84%d8%ae%d9%88%d8%a7%d9%86%d8%af%d9%86">#&lt;/a>
&lt;/h3>
&lt;p>گاهی‌اوقات، با افزودن منطق اضافی داخل حلقه‌ی تست یا جدول بسیار حجیم، تست‌خوانی به‌شدت افت می‌کند. در چنین شرایطی بهتر است:&lt;/p>
&lt;ul>
&lt;li>جدول را به فایل جداگانه ببرید.&lt;/li>
&lt;li>یا توابع assertion و کمکی تعریف کنید.&lt;/li>
&lt;li>یا حتی آن تست خاص را از Table Test جدا کنید.&lt;/li>
&lt;/ul>
&lt;h3 id="7366-عدم-پوشش-شرایط-لبه-edge-cases">
7.3.6.6 عدم پوشش شرایط لبه (Edge Cases)
&lt;a class="anchor" href="#7366-%d8%b9%d8%af%d9%85-%d9%be%d9%88%d8%b4%d8%b4-%d8%b4%d8%b1%d8%a7%db%8c%d8%b7-%d9%84%d8%a8%d9%87-edge-cases">#&lt;/a>
&lt;/h3>
&lt;p>در جدول تست، اغلب فقط شرایط عادی پوشش داده می‌شوند و شرایط خاص یا مرزی نادیده گرفته می‌شوند؛ مثل:&lt;/p>
&lt;ul>
&lt;li>ورودی‌های صفر، نال، یا تهی&lt;/li>
&lt;li>بزرگ‌ترین یا کوچک‌ترین مقدار مجاز&lt;/li>
&lt;li>رشته‌های با کاراکترهای خاص&lt;/li>
&lt;/ul>
&lt;p>پوشش این موارد نه تنها کیفیت تست را بالا می‌برد بلکه از regressionهای خطرناک جلوگیری می‌کند.&lt;/p>
&lt;h3 id="7367-وابستگی-تستها-به-یکدیگر">
7.3.6.7 وابستگی تست‌ها به یکدیگر
&lt;a class="anchor" href="#7367-%d9%88%d8%a7%d8%a8%d8%b3%d8%aa%da%af%db%8c-%d8%aa%d8%b3%d8%aa%d9%87%d8%a7-%d8%a8%d9%87-%db%8c%da%a9%d8%af%db%8c%da%af%d8%b1">#&lt;/a>
&lt;/h3>
&lt;p>در صورتی که هر iteration تست جدول‌محور، وضعیت مشترکی تغییر دهد (مثل فایل، دیتابیس، متغیر global)، وابستگی بین تست‌ها ایجاد می‌شود و اجرای موازی خطرناک خواهد بود. هر تست باید کاملاً ایزوله باشد.&lt;/p>
&lt;h2 id="737-جمعبندی-و-توصیههای-نهایی-برای-طراحی-تستهای-جدولمحور">
7.3.7 جمع‌بندی و توصیه‌های نهایی برای طراحی تست‌های جدول‌محور
&lt;a class="anchor" href="#737-%d8%ac%d9%85%d8%b9%d8%a8%d9%86%d8%af%db%8c-%d9%88-%d8%aa%d9%88%d8%b5%db%8c%d9%87%d9%87%d8%a7%db%8c-%d9%86%d9%87%d8%a7%db%8c%db%8c-%d8%a8%d8%b1%d8%a7%db%8c-%d8%b7%d8%b1%d8%a7%d8%ad%db%8c-%d8%aa%d8%b3%d8%aa%d9%87%d8%a7%db%8c-%d8%ac%d8%af%d9%88%d9%84%d9%85%d8%ad%d9%88%d8%b1">#&lt;/a>
&lt;/h2>
&lt;p>تست‌های جدول‌محور یکی از ستون‌های اصلی تست‌نویسی در زبان Go به‌شمار می‌آیند. این الگو، علاوه بر ساده‌سازی نگارش و توسعه تست‌ها، ساختاری منظم، قابل‌گسترش و حرفه‌ای برای پوشش سناریوهای متنوع فراهم می‌کند. اما استفاده درست از این الگو مستلزم رعایت چند اصل کلیدی است.&lt;/p>
&lt;h3 id="7371-مزایای-کلیدی-table-driven-tests">
7.3.7.1 مزایای کلیدی Table-Driven Tests
&lt;a class="anchor" href="#7371-%d9%85%d8%b2%d8%a7%db%8c%d8%a7%db%8c-%da%a9%d9%84%db%8c%d8%af%db%8c-table-driven-tests">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>کاهش تکرار در کد تست&lt;/strong>: دیگر نیازی به کپی کردن یک منطق با ورودی‌های مختلف ندارید.&lt;/li>
&lt;li>&lt;strong>خوانایی بالا&lt;/strong>: تست‌ها در قالب جدول struct به راحتی قابل درک‌اند.&lt;/li>
&lt;li>&lt;strong>افزودن ساده‌ی تست‌های جدید&lt;/strong>: فقط کافی‌ست یک struct جدید به جدول اضافه شود.&lt;/li>
&lt;li>&lt;strong>قابلیت اجرای موازی و ایزوله&lt;/strong>: در ترکیب با &lt;code>t.Parallel()&lt;/code> امکان تسریع تست‌ها وجود دارد.&lt;/li>
&lt;li>&lt;strong>گزارش‌گیری ساخت‌یافته&lt;/strong>: با استفاده از &lt;code>t.Run()&lt;/code> و نام‌گذاری دقیق هر تست.&lt;/li>
&lt;/ul>
&lt;h3 id="7372-توصیههای-نهایی">
7.3.7.2 توصیه‌های نهایی
&lt;a class="anchor" href="#7372-%d8%aa%d9%88%d8%b5%db%8c%d9%87%d9%87%d8%a7%db%8c-%d9%86%d9%87%d8%a7%db%8c%db%8c">#&lt;/a>
&lt;/h3>
&lt;ol>
&lt;li>&lt;strong>همیشه از &lt;code>tt := tt&lt;/code> در subtest استفاده کن&lt;/strong>
حتی اگر در لحظه از &lt;code>t.Parallel()&lt;/code> استفاده نمی‌کنی، برای اطمینان از ایزولاسیون متغیرها این دستور را بنویس.&lt;/li>
&lt;li>&lt;strong>نام تست را معنی‌دار بنویس&lt;/strong>
نام هر سناریوی تست باید هدف آن را به وضوح منتقل کند؛ این موضوع در CI/CD و گزارش‌های ترمینال بسیار مفید است.&lt;/li>
&lt;li>&lt;strong>ورودی‌ها، خروجی‌ها و انتظار خطا را صریح بیان کن&lt;/strong>
حتی اگر ساده به نظر برسد، وجود فیلدهایی مثل &lt;code>wantErr&lt;/code> یا &lt;code>expectedCode&lt;/code> ساختار تست را واضح‌تر و قابل گسترش می‌کند.&lt;/li>
&lt;li>&lt;strong>برای هر لایه تستی از Subtest استفاده کن&lt;/strong>
اگر درون هر سناریوی تست چند شرط باید بررسی شود، از &lt;code>t.Run()&lt;/code> برای ساخت زیرتست استفاده کن.&lt;/li>
&lt;li>&lt;strong>Edge Caseها را فراموش نکن&lt;/strong>
ورودی‌های خاص، تهی، صفر، منفی یا ناصحیح را در جدول لحاظ کن تا تست‌ها فقط “خوش‌بینانه” نباشند.&lt;/li>
&lt;li>&lt;strong>زمانی که الگو پیچیده شد، ساده کن&lt;/strong>
اگر جدول بسیار بزرگ، پر از توابع تو در تو یا منطق شرطی شد، شاید وقت آن است که آن تست را جداگانه بنویسی یا تست را refactor کنی.&lt;/li>
&lt;li>&lt;strong>برای پروژه‌های بزرگ، از type مجزا استفاده کن&lt;/strong>
تعریف type مشخص برای struct تست‌ها خوانایی را بالا می‌برد، به‌ویژه اگر در چند فایل مشترک باشد.&lt;/li>
&lt;li>&lt;strong>مطمئن شو هر تست ایزوله و بدون side effect است&lt;/strong>
جدول تست نباید به یک ترتیب خاص یا shared state وابسته باشد. هر تست باید مستقل و بازتولیدپذیر باشد.&lt;/li>
&lt;/ol>
&lt;h3 id="7373-نتیجهگیری">
7.3.7.3 نتیجه‌گیری
&lt;a class="anchor" href="#7373-%d9%86%d8%aa%db%8c%d8%ac%d9%87%da%af%db%8c%d8%b1%db%8c">#&lt;/a>
&lt;/h3>
&lt;p>استفاده صحیح از تست‌های جدول‌محور در Go، نشانه‌ای از بلوغ تست‌نویسی در یک پروژه است. این الگو، در کنار ابزارهایی مانند &lt;code>t.Run&lt;/code>, &lt;code>t.Parallel&lt;/code>, &lt;code>t.Cleanup&lt;/code>, و پکیج‌هایی مثل &lt;code>testify&lt;/code>، به شما امکان می‌دهد تست‌هایی با کیفیت تولیدی و قابل اطمینان بنویسید.&lt;/p></description></item><item><author/><title>7.4 تست یکپارچه (Integration Test)</title><link>https://book.gofarsi.ir/chapter-7/go-integration-testing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-7/go-integration-testing/</guid><description/></item><item><author/><title>7.5 تست انتها به انتها (End-to-End Test - E2E)</title><link>https://book.gofarsi.ir/chapter-7/go-end-to-end-tests/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-7/go-end-to-end-tests/</guid><description/></item><item><author/><title>7.6 تست عملکرد (Benchmark)</title><link>https://book.gofarsi.ir/chapter-7/go-benchmarking/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-7/go-benchmarking/</guid><description/></item><item><author/><title>7.7 تست فازی (Fuzz Testing)</title><link>https://book.gofarsi.ir/chapter-7/go-fuzz-testing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-7/go-fuzz-testing/</guid><description/></item><item><author/><title>7.8 ماک و شبیه‌سازی وابستگی‌ها (Mock)</title><link>https://book.gofarsi.ir/chapter-7/go-mocking/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-7/go-mocking/</guid><description/></item><item><author/><title>7.9 استفاده از testify</title><link>https://book.gofarsi.ir/chapter-7/go-testify/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-7/go-testify/</guid><description/></item><item><author/><title>7.10 استفاده از ginkgo</title><link>https://book.gofarsi.ir/chapter-7/go-ginkgo-testing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-7/go-ginkgo-testing/</guid><description/></item><item><author/><title>7.11 تست‌های همزمانی (Concurrent Testing)</title><link>https://book.gofarsi.ir/chapter-7/go-concurrent-testing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-7/go-concurrent-testing/</guid><description/></item><item><author/><title>7.12 سنجش پوشش تست (Code Coverage)</title><link>https://book.gofarsi.ir/chapter-7/go-code-coverage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-7/go-code-coverage/</guid><description/></item><item><author/><title>7.13 تست Suite و ساختاردهی تست‌ها</title><link>https://book.gofarsi.ir/chapter-7/go-test-suites/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-7/go-test-suites/</guid><description/></item><item><author/><title>7.14 تست‌نویسی حرفه‌ای در پروژه</title><link>https://book.gofarsi.ir/chapter-7/go-production-testing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-7/go-production-testing/</guid><description/></item></channel></rss>