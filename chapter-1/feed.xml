<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><author/><title>فصل اول: آشنایی با مفاهیم گو on زبان گو فارسی</title><link>https://book.gofarsi.ir/chapter-1/</link><description>Recent content in فصل اول: آشنایی با مفاهیم گو on زبان گو فارسی</description><generator>Hugo -- gohugo.io</generator><language>fa</language><copyright>2023 GoFarsi All rights reserved</copyright><atom:link href="https://book.gofarsi.ir/chapter-1/feed.xml" rel="self" type="application/rss+xml"/><item><author/><title>1.1 ساختار کد گو</title><link>https://book.gofarsi.ir/chapter-1/structure-of-go-code/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-1/structure-of-go-code/</guid><description>&lt;p>همانطور که در تاریخچه زبان گو گفتیم, زبان گو سینتکس خیلی تمیز و ساده‌ای دارد که به راحتی می‌توانید کدهای زبان گو را بخوانید. در ادامه ما سعی می‌کنیم با مثال‌های ساده شما را با ساختار کد زبان گو آشنا کنیم.&lt;/p>
&lt;blockquote class="book-hint info">
&lt;strong>به نقل از تاریخچه&lt;/strong>
سینتکس زبان گو به گونه‌ای طراحی شده که خیلی ساده و تمیز است و این باعث می‌شود خیلی سریع زبان گو را یاد بگیرید و از همه مهم‌تر توسعه پروژه‌های &lt;span class="tooltip" data-tooltip="Scale up" ontouchend="toggleTooltip(this)">مقیاس پذیر&lt;/span>
با زبان گو به دلیل سادگی و آشکار بودن مفاهیم خیلی سریع‌تر صورت‌ گیرد.
&lt;/blockquote>
&lt;h2 id="110-زبان-برنامهنویسی">
1.1.0 زبان برنامه‌نویسی
&lt;a class="anchor" href="#110-%d8%b2%d8%a8%d8%a7%d9%86-%d8%a8%d8%b1%d9%86%d8%a7%d9%85%d9%87%d9%86%d9%88%db%8c%d8%b3%db%8c">#&lt;/a>
&lt;/h2>
&lt;p>یک زبان برنامه‌نویسی یک زبان مصنوعی انگلیسی است که برای بیان محاسباتی که توسط یک ماشین (مخصوصاً رایانه) قابل انجام است، طراحی شده‌ است. زبان‌های برنامه‌نویسی برای ایجاد برنامه‌هایی به کار می‌روند که رفتار یک ماشین را مشخص می‌کنند، الگوریتم دقیق را بیان می‌کنند، یا روشی برای تعامل انسان و رایانه هستند. بسیاری از زبان‌های برنامه‌نویسی تعدادی قالب از ویژگی‌های نوشته شده دستوری یا نحو (syntax) و معناشناسی (semantics) دارند، چرا که رایانه‌ها دستورهای دقیقاً مشخص نیاز دارند. برخی توسط سند خصوصیات (specification document) تعیین شده‌اند (برای مثال یک استاندارد ISO)، در حالی که برخی دیگر دارای پیاده‌سازی غالبی هستند. [&lt;a href="https://fa.wikipedia.org/wiki/%D8%B2%D8%A8%D8%A7%D9%86_%D8%A8%D8%B1%D9%86%D8%A7%D9%85%D9%87%E2%80%8C%D9%86%D9%88%DB%8C%D8%B3%DB%8C">به نقل از ویکی‌پدیا&lt;/a>].&lt;/p>
&lt;h2 id="111-پکیج">
1.1.1 پکیج
&lt;a class="anchor" href="#111-%d9%be%da%a9%db%8c%d8%ac">#&lt;/a>
&lt;/h2>
&lt;p>هر برنامه‌ای که با ساختار گو ایجاد شده باشد، از پکیج(ها) ساخته شده است. درواقع زبان گو یک زبان &lt;span class="tooltip" data-tooltip="package-base" ontouchend="toggleTooltip(this)">بر پایه پکیج&lt;/span>
است.
برخلاف برخی دیگر که &lt;span class="tooltip" data-tooltip="file-base" ontouchend="toggleTooltip(this)">بر پایه فایل&lt;/span>
هستند.
این به‌ این‌ معنی است که به «مجموعه»ای از ابزارها اعم از ثابت‌ها، متغیرها و عملیات مختلف که زیرمجموعه یک نام تعریف می‌شوند، پکیج می‌گوئیم. تفاوتی ندارد در یک «فایل» یا «چند» فایل، بشرطی که ابتدای همگی package name باشند.&lt;/p>
&lt;h2 id="112-یک-نمونه-کد-ساده-زبان-گو">
1.1.2 یک نمونه کد ساده زبان گو
&lt;a class="anchor" href="#112-%db%8c%da%a9-%d9%86%d9%85%d9%88%d9%86%d9%87-%da%a9%d8%af-%d8%b3%d8%a7%d8%af%d9%87-%d8%b2%d8%a8%d8%a7%d9%86-%da%af%d9%88">#&lt;/a>
&lt;/h2>
&lt;p>قبل از اینکه محتوای بدنه کد زیر را بررسی کنیم؛ بهتر است با نحوه کامنت‌گذاری کد در زبان گو آشنا شوید.&lt;/p>
&lt;h3 id="1121-کامنت-گذاری">
1.1.2.1 کامنت گذاری
&lt;a class="anchor" href="#1121-%da%a9%d8%a7%d9%85%d9%86%d8%aa-%da%af%d8%b0%d8%a7%d8%b1%db%8c">#&lt;/a>
&lt;/h3>
&lt;p>کامنت‌ها در زبان گو همانند زبان سی هستند که با قرار دادن ۲ &lt;span class="tooltip" data-tooltip="Slash" ontouchend="toggleTooltip(this)">اسلش&lt;/span>
در ابتدای خط یا قرار دادن یک یا چند خط ما بین /* و */ ایجاد می‌شود.&lt;/p>
&lt;pre>&lt;code class="language-go">// کامنت عادی یک خطی
/*
بلاک کامنت برای نوشتن کامنت چند خطی
*/
&lt;/code>&lt;/pre>
&lt;h3 id="1122-نمونه-کد">
1.1.2.2 نمونه کد
&lt;a class="anchor" href="#1122-%d9%86%d9%85%d9%88%d9%86%d9%87-%da%a9%d8%af">#&lt;/a>
&lt;/h3>
&lt;p>در پایین یک نمونه کد قرار دادیم که با کامنت هر کدام از بخش‌های بدنه کد گو را توضیح دادیم.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main // نام پکیج فایل سورس را مشخص می کند
import "math/rand" // یک پکیج استاندارد ایمپورت شده
const MaxRnd = 16 // یک ثابت تعریف شده است
// تابع
func StatRandomNumbers(n int) (int, int) {
var a, b int
for i := 0; i &lt; n; i++ {
if rand.Intn(MaxRnd) &lt; MaxRnd/2 {
a = a + 1
} else {
b++
}
}
return a, b
}
// تابع main اولین نقطه شروع اجرای کد شما می باشد که در این تابع سایر موارد تعریف می شود.
func main() {
var num = 100
x, y := StatRandomNumbers(num)
print("Result: ", x, " + ", y, " = ", num, "? ")
println(x+y == num)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>سورس کد بالا را در فایلی با نام &lt;code>basic-code-element-demo.go&lt;/code> ذخیره می‌کنیم و سپس با دستور زیر اجرا می‌کنیم تا خروجی کد فوق را ببینیم :&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go run basic-code-element-demo.go
Result: 46 + 54 = 100? true
&lt;/code>&lt;/pre>
&lt;h2 id="113-تابع-main">
1.1.3 تابع main
&lt;a class="anchor" href="#113-%d8%aa%d8%a7%d8%a8%d8%b9-main">#&lt;/a>
&lt;/h2>
&lt;p>در زبان گو پکیج main به عنوان یک پکیج منحصر به فرد در نظر گرفته شده است، به شکلی که در هنگام اجرای برنامه مشخص می‌کند شروع کار و خواندن برنامه از کجا باید باشد. در نهایت داخل این پکیج ما تابع ()main را داریم که این تابع نقطه شروع اجرای برنامه ما خواهد بود. این تابع هیچ ارگومانی نمی‌گیرد و هیچ چیزی رو هم &lt;span class="tooltip" data-tooltip="return" ontouchend="toggleTooltip(this)">بازگشت&lt;/span>
نخواهد داد. زبان گو به صورت خودکار تابع ()main را فراخوانی می‌کند. برای همین نیازی به فراخوانی این تابع توسط شما وجود ندارد. برای همین باید دقت داشته باشید در هر برنامه‌ای که می‌نویسید حتما از پکیج و تابع main باید استفاده کنید.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">// تعریف پکیج main
package main
// تعریف تابع main
func main() {
println("Hello GoFarsi!")
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;h2 id="114-اجرای-کد">
1.1.4 اجرای کد
&lt;a class="anchor" href="#114-%d8%a7%d8%ac%d8%b1%d8%a7%db%8c-%da%a9%d8%af">#&lt;/a>
&lt;/h2>
&lt;p>برای اجرای کدهای گو می‌توان از پارامتر run استفاده کرد.&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go run main.go
Result: Hello GoFarsi!
&lt;/code>&lt;/pre>
&lt;p>دستور بالا ابتدا داخل پوشه temp سیستم شما یک فایل اجرایی را درست می‌کند و سپس آن فایل را اجرا می‌کند و در نهایت خروجی را به ما نشان می‌دهد. اگر شما بخواهید خروجی فایل اجرایی (executable) داشته باشید و سپس آن را اجرا کنید می‌توانید از دستور زیر استفاده کنید:&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go build main.go
$ ./main
Result: Hello GoFarsi!
&lt;/code>&lt;/pre>
&lt;p>اگر بخواهید برای خروجی فایل اجرایی اسمی در نظر بگیرید می‌توانید از دستور زیر با پارامتر o- استفاده کنید.&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go build -o goFarsi main.go
$ ./goFarsi
Result: Hello GoFarsi!
&lt;/code>&lt;/pre>
&lt;blockquote class="book-hint info">
دقت کنید اگر از سیستم‌عامل ویندوز استفاده می‌کنید بعد از وارد کردن اسم، پسوند &lt;code>.exe&lt;/code> را نیز اضافه کنید.
&lt;/blockquote>
&lt;blockquote class="book-hint info">
برای راحتی و سرعت بخشیدن هنگام توسعه ما از دستور &lt;code>go run&lt;/code> استفاده می‌کنیم.
&lt;/blockquote>
&lt;h2 id="تابع--init">
تابع init
&lt;a class="anchor" href="#%d8%aa%d8%a7%d8%a8%d8%b9--init">#&lt;/a>
&lt;/h2>
&lt;p>همانطور که گفتیم نقطه شروع برنامه ما تابع main است. اما اگر بخواهیم قبل از اجرای برنامه مقداری را ست کنیم و یا چیزی را لود کنیم، می توانیم در داخل تابع init اینکار را انجام دهیم.
تابع init قبل از تابع main اجرا می شود&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">// تعریف پکیج main
package main
// تعریف تابع init
func init() {
println("init")
}
// تعریف تابع main
func main() {
println("Hello GoFarsi!")
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>پس از اجرای کد. خروجی زیر را مشاهده می کنید.&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go run main.go
Result:
init
Hello GoFarsi!
&lt;/code>&lt;/pre>
&lt;h2 id="115-بررسی-syntax">
1.1.5 بررسی syntax
&lt;a class="anchor" href="#115-%d8%a8%d8%b1%d8%b1%d8%b3%db%8c-syntax">#&lt;/a>
&lt;/h2>
&lt;p>برخلاف بیشتر زبان‌های برنامه نویسی در زبان گو شما نمی‌توانید از حالت‌های مختلف برای نوشتن کد خود استفاده کنید. مثلاً کد زیر هنگام کامپایل کردن خطا می‌دهد.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
func main()
{
println("not compiled")
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>خروجی کد بالا :&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go run main.go
Result:
# command-line-arguments
.\main.go:4:1: syntax error: unexpected semicolon or newline before {
&lt;/code>&lt;/pre>
&lt;p>صرفاً با تغییر براکت ما با خطا مواجه شدیم. شاید از دید شما این نوع نوشتن کد نباید خطا ایجاد کند. ولی وقتی شما داخل یک تیم هستید و مجبور هستید کدها را بازخوانی کنید تا بفهمید چه اتفاقی افتاده است، با حالت‌های مختلف سینتکس مواجه نخواهید شد، و همه کدها یک دست و از یک ساختار پیروی می‌کنند، که باعث خواندن سریع‌تر، درک بهتر و امکان توسعه سریع‌تر را برای ما و هم‌تیمی‌های ما ایجاد خواهد کرد.&lt;/p>
&lt;h3 id="1151-استفاده-از-go-fmt">
1.1.5.1 استفاده از go fmt
&lt;a class="anchor" href="#1151-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-go-fmt">#&lt;/a>
&lt;/h3>
&lt;p>برای آن که بتوان از این نوع خطاها جلوگیری کرد و فرمت مناسب و یک نواختی داخل کدهای ما وجود داشته باشد، خود IDEها این خطاها را به ما نشان می‌دهد. خود توسعه‌دهندگان زبان گو پارامتر fmt یا به عبارتی فرمت را در اختیار ما قرار داده‌اند تا هر زمان که کدی می‌نویسم و ذخیره می‌کنیم بتوانیم با استفاده از این دستور ساختار کد خود را مرتب کنیم و اگر خطایی وجود داشته باشد قبل از کامپایل کردن برنامه آن را پیدا و رفع کنیم. مثلاً خروجی استفاده از پارامتر fmt&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go fmt main.go
Result:
.\main.go:4:1: unexpected semicolon or newline before {
&lt;/code>&lt;/pre>
&lt;p>حالا فرض کنید کدی را نوشته‌اید و داخل کد شما فضای زیادی وجود دارد و اندازه tab‌ها و space‌ها مشخص نیست. به مثال زیر توجه کنید:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
func main(){
println("print line 1")
println("print line 2")
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>وقتی کدی شبیه کد بالا را دارید و از دستور go fmt استفاده می‌کنیم خروجی کد بالا به شکل زیر تغییر پیدا می‌کند:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
func main() {
println("print line 1")
println("print line 2")
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;blockquote class="book-hint info">
در برنامه فوق ما یکسری کلمات کلیدی نظیر &lt;code>package, import, const, func, var , for, if, else, return&lt;/code> استفاده کردیم و سایر کلماتی که داخل کد فوق دیدید به عنوان &lt;span class="tooltip" data-tooltip="identifier" ontouchend="toggleTooltip(this)">شناسه&lt;/span>
هستند. برای اطلاعات بیشتر در خصوص کلید واژه و شناسه لطفاً بخش &lt;a href="https://book.gofarsi.ir/chapter-1/go-built-in-keywords-identifiers/">کلید واژه و شناسه ها&lt;/a> را مطالعه فرمایید.
&lt;/blockquote></description></item><item><author/><title>1.2 کلید واژه و شناسه‌ها</title><link>https://book.gofarsi.ir/chapter-1/go-built-in-keywords-identifiers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-1/go-built-in-keywords-identifiers/</guid><description>&lt;p>در این بخش قصد داریم به &lt;span class="tooltip" data-tooltip="keyword" ontouchend="toggleTooltip(this)">کلید واژه&lt;/span>
و &lt;span class="tooltip" data-tooltip="identifier" ontouchend="toggleTooltip(this)">شناسه&lt;/span>
های زبان گو بپردازیم.&lt;/p>
&lt;h2 id="121-کلید-واژه">
1.2.1 کلید واژه
&lt;a class="anchor" href="#121-%da%a9%d9%84%db%8c%d8%af-%d9%88%d8%a7%da%98%d9%87">#&lt;/a>
&lt;/h2>
&lt;p>زبان گو تا &lt;span class="tooltip" data-tooltip="1.1.23" ontouchend="toggleTooltip(this)">نسخه فعلی&lt;/span>
فقط ۲۵ تا کلید واژه دارد که به شرح زیر ست:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>1&lt;/th>
&lt;th>2&lt;/th>
&lt;th>3&lt;/th>
&lt;th>4&lt;/th>
&lt;th>5&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>break&lt;/td>
&lt;td>default&lt;/td>
&lt;td>func&lt;/td>
&lt;td>interface&lt;/td>
&lt;td>select&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>case&lt;/td>
&lt;td>defer&lt;/td>
&lt;td>go&lt;/td>
&lt;td>map&lt;/td>
&lt;td>struct&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3&lt;/td>
&lt;td>chan&lt;/td>
&lt;td>else&lt;/td>
&lt;td>goto&lt;/td>
&lt;td>package&lt;/td>
&lt;td>switch&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>4&lt;/td>
&lt;td>const&lt;/td>
&lt;td>fallthrough&lt;/td>
&lt;td>if&lt;/td>
&lt;td>range&lt;/td>
&lt;td>type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>5&lt;/td>
&lt;td>continue&lt;/td>
&lt;td>for&lt;/td>
&lt;td>import&lt;/td>
&lt;td>return&lt;/td>
&lt;td>var&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>کلمات کلیدی فوق به ۴ دسته تقسیم می‌شوند که به شرح زیر است:&lt;/p>
&lt;ul>
&lt;li>کلمات کلیدی که بصورت گلوبال در بدنه قرار می‌گیرند «&lt;code>package, import, type, var, const, func&lt;/code>»&lt;/li>
&lt;li>کلمات کلیدی کامپوزیت «&lt;code>struct, interface, map, chan&lt;/code>»&lt;/li>
&lt;li>کلمات کلیدی که در جریان کنترل کد استفاده می‌شوند «&lt;code>break, case, continue, default, if, else, for, fallthrough, goto, range, return, switch, select&lt;/code>»&lt;/li>
&lt;/ul>
&lt;blockquote class="book-hint warning">
در بخش‌های دیگر کتاب ما بطور مفصل به مفاهیم کلمات کلیدی فوق می‌پردازیم.
&lt;/blockquote>
&lt;h2 id="122-شناسهها">
1.2.2 شناسه‌ها
&lt;a class="anchor" href="#122-%d8%b4%d9%86%d8%a7%d8%b3%d9%87%d9%87%d8%a7">#&lt;/a>
&lt;/h2>
&lt;p>شناسه توکنی است که باید از حروف یونیکد, ارقام یونیکد (اعداد دسته‌بندی شده در استاندارد ۸.۰ یونیکد) و &lt;span class="tooltip" data-tooltip="underscore" ontouchend="toggleTooltip(this)">خط زیرین&lt;/span>
&lt;code>ـ&lt;/code> تشکیل شده باشد.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>علامت&lt;/th>
&lt;th>کاربرد&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>ـ&lt;/code>&lt;/td>
&lt;td>نادیده گرفتن&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>&amp;amp;&lt;/code>&lt;/td>
&lt;td>دسترسی به آدرس حافظه&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>*&lt;/code>&lt;/td>
&lt;td>دسترسی مقدار داخل یک خانه حافظه&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="1221-قوانین-شناسهها">
1.2.2.1 قوانین شناسه‌ها
&lt;a class="anchor" href="#1221-%d9%82%d9%88%d8%a7%d9%86%db%8c%d9%86-%d8%b4%d9%86%d8%a7%d8%b3%d9%87%d9%87%d8%a7">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>نامگذاری باید از حروف a-z یا A-Z و یا 0-9 باشد.&lt;/li>
&lt;li>نام شناسه‌ها نباید با اعداد شروع شود.&lt;/li>
&lt;li>نام شناسه‌ها به حروف بزرگ و کوچک حساس است.&lt;/li>
&lt;li>استفاده از &lt;span class="tooltip" data-tooltip="keyword" ontouchend="toggleTooltip(this)">کلید واژه&lt;/span>
ممنوع است.&lt;/li>
&lt;li>هیچ محدودیتی در تعداد حروف نام شناسه وجود ندارد و مطلوب‌ترین حالت ۴ الی ۱۵ حرف است.&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-go">// شناسه‌های معتبر
_geeks23
geeks
gek23sd
Geeks
geeKs
geeks_geeks
// شناسه‌های نامعتبر
212geeks
if
default
&lt;/code>&lt;/pre>
&lt;p>در زبان گو یکسری شناسه‌ها از قبل برای برخی از بخش‌های کد تعیین شده است که در زیر می‌توانید ببینید:&lt;/p>
&lt;pre>&lt;code class="language-go">// Constant (ثابت ها)
true, false, iota, nil
// Types (تایپ ها)
int, int8, int16, int32, int64, uint,
uint8, uint16, uint32, uint64, uintptr,
float32, float64, complex128, complex64,
bool, byte, rune, string, error
// Functions (توابع)
make, len, cap, new, append, copy, close,
delete, complex, real, imag, panic, recover
&lt;/code>&lt;/pre></description></item><item><author/><title>1.3 تایپ‌های پایه</title><link>https://book.gofarsi.ir/chapter-1/go-basic-types/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-1/go-basic-types/</guid><description>&lt;h2 id="131-تایپ-چیست">
1.3.1 تایپ چیست؟
&lt;a class="anchor" href="#131-%d8%aa%d8%a7%db%8c%d9%be-%da%86%db%8c%d8%b3%d8%aa">#&lt;/a>
&lt;/h2>
&lt;p>یک تایپ مشخص کننده نوع داده است، که به کامپایلر می‌گوید قرار است چه نوع داده‌ای داخل یک متغیر ذخیره گردد. زبان‌ها انواع تایپ‌های مختلفی به صورت پیش‌فرض دارند که می‌توان از آن‌ها داخل برنامه خود استفاده کرد.
ما می‌توانیم تایپ‌ها را به دو دسته کلی تعریف کنیم.&lt;/p>
&lt;h3 id="1311-تایپ-ایستا-static-type">
1.3.1.1 تایپ ایستا (Static Type)
&lt;a class="anchor" href="#1311-%d8%aa%d8%a7%db%8c%d9%be-%d8%a7%db%8c%d8%b3%d8%aa%d8%a7-static-type">#&lt;/a>
&lt;/h3>
&lt;p>زبانی مثل زبان گو یک زبان تایپ ایستا است، یعنی وقتی ما یک داده‌ای از نوع عددی داخل یک متغیر تعریف می‌کنیم داخل همان متغیر امکان اضافه کردن داده‌ای، غیر داده عددی وجود ندارد.&lt;/p>
&lt;h3 id="1312-تایپ-پویا-dynamic-type">
1.3.1.2 تایپ پویا (Dynamic Type)
&lt;a class="anchor" href="#1312-%d8%aa%d8%a7%db%8c%d9%be-%d9%be%d9%88%db%8c%d8%a7-dynamic-type">#&lt;/a>
&lt;/h3>
&lt;p>زبان‌هایی مثل PHP، JavaScript و &amp;hellip; جزو زبان‌های تایپ پویا هستند. یعنی وقتی یک متغیری از نوع عددی تعریف می‌کنیم می‌توانیم به همان متغیر مقادیر دیگه‌ای مثل مقادیر رشته‌ای اضافه کنیم.&lt;/p>
&lt;blockquote class="book-hint info">
&lt;p>تفاوت تایپ ایستا با پویا به &lt;a href="https://yak.li/b43966">نقل از آقای استقامت&lt;/a>:&lt;/p>
&lt;p>در زبان‌هایی مثل گو که جزو زبان‌های نوع ایستا هستند، وقتی بخوایم متغیر یا ثابتی ایجاد کنیم، حتما می بایست نوع متغیر یا ثابت را به صورت مستقیم و صریح اعلان کنیم تا کامپایلر متوجه بشه که درون این متغیر یا ثابت قراره چه نوع داده ای ذخیره بشه.&lt;/p>
&lt;p>به عنوان مثال در زبان گو باید بنویسیم: &lt;code>‎var a, b int = 1, 2&lt;/code>&lt;/p>
&lt;p>و اگر نوع داده یا در این مثال(int) را مشخص نکنیم با ارور مواجه می‌شویم.&lt;/p>
&lt;p>اکنون که این دو متغیر از نوع int اعلان شدند، فقط و فقط می‌توان مقادیری از نوع اعداد صحیح را درون آن‌ها ذخیره کرد و نمی‌توان به عنوان مثال، یک رشته متنی یا اعداد اعشاری و &amp;hellip; را درون آن‌ها ذخیره نمود.&lt;/p>
&lt;p>▪️ اما در مورد زبان‌های نوع پویا مانند زبان پایتون، ما نیازی به اعلان صریح نوع متغیر نداریم. بلکه کافیست یک شناسه را به عنوان نام متغیر در نظر گرفته و مقداری را به آن انتساب دهیم. در اینجا، کامپایلر یا مفسر زبان به صورت خودکار نوع داده متغیر را بر اساس مقداری که به آن انتساب داده ایم شناسایی می کند:
به عنوان مثال در زبان پایتون داریم: &lt;code>‎n = 300&lt;/code>&lt;/p>
&lt;p>در این جا متغیر n دارای نوع int است که به صورت خودکار توسط زبان شناسایی می‌شود.&lt;/p>
&lt;p>اکنون ما می‌توانیم همین متغیر را در جاهای دیگری از کد استفاده کنیم و مقادیری از انواع داده‌ای دیگر به آن انتساب دهیم بدون اینکه هیچ مشکلی یا اروری پیش بیاید: &lt;code>&amp;quot;‎n = &amp;quot;Hello&lt;/code>&lt;/p>
&lt;p>در حال حاضر متغیر n از نوع string می باشد!&lt;/p>
&lt;/blockquote>
&lt;p>برای اطلاعات بیشتر می‌توانید &lt;a href="https://fa.wikipedia.org/wiki/%D8%B3%DB%8C%D8%B3%D8%AA%D9%85_%D9%86%D9%88%D8%B9">تایپ سیستم&lt;/a> را داخل ویکی‌پدیا مطالعه کنید.&lt;/p>
&lt;h2 id="132-تایپها-در-زبان-گو">
1.3.2 تایپ‌ها در زبان گو
&lt;a class="anchor" href="#132-%d8%aa%d8%a7%db%8c%d9%be%d9%87%d8%a7-%d8%af%d8%b1-%d8%b2%d8%a8%d8%a7%d9%86-%da%af%d9%88">#&lt;/a>
&lt;/h2>
&lt;p>زبان گو مثل سایر زبان‌ها یکسری تایپ‌های پایه دارد که در هر بخش از کد گو می‌توانید استفاده کنید. در ادامه این تایپ‌ها با مقادیر پیش‌فرض‌ معرفی شده است.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>تایپ&lt;/th>
&lt;th>محدوده&lt;/th>
&lt;th>مقدار پیش فرض یا مقدار صفر&lt;/th>
&lt;th>حجم استفاده از حافظه&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>int&lt;/td>
&lt;td>بستگی به معماری سیستم عامل که ۳۲ بیت یا ۶۴ بیت باشد&lt;/td>
&lt;td>0&lt;/td>
&lt;td>۴ یا ۸ بایت&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>int8&lt;/td>
&lt;td>128- تا 127&lt;/td>
&lt;td>0&lt;/td>
&lt;td>۱ بایت&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>int16&lt;/td>
&lt;td>32768- تا 32767&lt;/td>
&lt;td>0&lt;/td>
&lt;td>۲ بایت&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>int32&lt;/td>
&lt;td>2147483648- تا 2147483647&lt;/td>
&lt;td>0&lt;/td>
&lt;td>۴ بایت&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>int64&lt;/td>
&lt;td>9223372036854775808- تا 9223372036854775807&lt;/td>
&lt;td>0&lt;/td>
&lt;td>۸ بایت&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>uint&lt;/td>
&lt;td>بستگی به معماری سیستم عامل که ۳۲ بیت یا ۶۴ بیت باشد&lt;/td>
&lt;td>0&lt;/td>
&lt;td>۴ یا ۸ بایت&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>uint8&lt;/td>
&lt;td>0 تا 255&lt;/td>
&lt;td>0&lt;/td>
&lt;td>۱ بایت&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>uint16&lt;/td>
&lt;td>0 تا 65535&lt;/td>
&lt;td>0&lt;/td>
&lt;td>۲ بایت&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>uint32&lt;/td>
&lt;td>0 تا 6294967295&lt;/td>
&lt;td>0&lt;/td>
&lt;td>۴ بایت&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>uint64&lt;/td>
&lt;td>0 تا 18446744073709551615&lt;/td>
&lt;td>0&lt;/td>
&lt;td>۸ بایت&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>uintptr&lt;/td>
&lt;td>عدد خیلی بزرگ&lt;/td>
&lt;td>0&lt;/td>
&lt;td>۸ بایت&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>float32&lt;/td>
&lt;td>IEEE-754&lt;/td>
&lt;td>0&lt;/td>
&lt;td>۴ بایت&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>float64&lt;/td>
&lt;td>IEEE-754&lt;/td>
&lt;td>0&lt;/td>
&lt;td>۸ بایت&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>complex64&lt;/td>
&lt;td>-&lt;/td>
&lt;td>0+0i&lt;/td>
&lt;td>۸ بایت&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>complex128&lt;/td>
&lt;td>-&lt;/td>
&lt;td>0+0i&lt;/td>
&lt;td>۱۶ بایت&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>bool&lt;/td>
&lt;td>-&lt;/td>
&lt;td>false&lt;/td>
&lt;td>۱ بایت&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>string&lt;/td>
&lt;td>-&lt;/td>
&lt;td>&amp;quot; &amp;quot;&lt;/td>
&lt;td>۱۶ بایت&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>زبان گو به‌طور پیش‌فرض از دو نوع تایپ با نام مستعار پشتیبانی می‌کند :&lt;/p>
&lt;ul>
&lt;li>تایپ &lt;code>byte&lt;/code> این تایپ نام مستعار برای تایپ &lt;code>uint8&lt;/code> است.&lt;/li>
&lt;li>تایپ &lt;code>rune&lt;/code> این تایپ نام مستعار برای تایپ &lt;code>int32&lt;/code> است.&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;p>تفاوت &lt;strong>int&lt;/strong> و &lt;strong>uint&lt;/strong> در این است که نوع داده &lt;strong>int&lt;/strong> به عنوان &lt;strong>Signed Integer&lt;/strong> شناخته می‌شود و &lt;strong>توانایی ذخیره اعداد منفی ، 0 و اعداد مثبت را دارد&lt;/strong> اما نوع داده &lt;strong>uint&lt;/strong> به معنای &lt;strong>Unsigned Integer&lt;/strong> بوده و &lt;strong>فقط توانایی نگهداری اعداد مثبت و 0 را داراست&lt;/strong>.&lt;/p>
&lt;blockquote class="book-hint info">
&lt;p>تایپ &lt;strong>uintptr&lt;/strong> به &lt;a href="https://yak.li/5a2b5f">نقل از آقای استقامت&lt;/a>:&lt;/p>
&lt;p>در مورد نوع داده &lt;strong>uintptr&lt;/strong> که در متن بالا در مورد آن گفته شده &amp;ldquo;&lt;strong>عدد خیلی بزرگ&lt;/strong>&amp;quot;، با بیان این مطلب که چنین توضیحی &lt;strong>نادرست&lt;/strong> است، توجه شما رو به ادامه این یادداشت جلب می‌کنم:&lt;/p>
&lt;p>کلمه &lt;strong>uintptr&lt;/strong> همان‌طور که قابل حدس زدن است کوتاه شده &lt;strong>Unsigned Integer Pointer&lt;/strong> است.&lt;/p>
&lt;p>از این نوع داده برای ذخیره و نگهداری &lt;strong>آدرس‌های حافظه&lt;/strong>(RAM) استفاده می‌شود.&lt;/p>
&lt;p>فضایی که این نوع داده در سیستم اِشغال می‌کند، به نوع معماری سیستم عامل بستگی دارد.&lt;/p>
&lt;p>و در نهایت، به جای عبارت &amp;ldquo;&lt;em>عدد خیلی بزرگ&lt;/em>&amp;rdquo; که مفهوم اشتباه و نادرستی می‌رساند، باید اینگونه بگوییم که &lt;strong>این نوع داده به اندازه کافی بزرگ است تا بتواند اشاره گرهایی(Pointers) به هر آدرس از حافظه را درون خودش ذخیره کند.(&lt;a href="https://golangbyexample.com/understanding-uintptr-golang/">منبع&lt;/a>)&lt;/strong>&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
&lt;p>func main() {
var var1 uintptr = 0xc82000c290
fmt.Println(&amp;ldquo;Value of var1:&amp;rdquo;, var1)
fmt.Printf(&amp;ldquo;Type of var1: %T&amp;rdquo;, var1)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>&lt;/p>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;/blockquote>
&lt;h2 id="133-سفارشیسازی-تایپها">
1.3.3 سفارشی‌سازی تایپ‌(ها)
&lt;a class="anchor" href="#133-%d8%b3%d9%81%d8%a7%d8%b1%d8%b4%db%8c%d8%b3%d8%a7%d8%b2%db%8c-%d8%aa%d8%a7%db%8c%d9%be%d9%87%d8%a7">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>&lt;span class="tooltip" data-tooltip="type alias" ontouchend="toggleTooltip(this)">نام‌گذاری جدید&lt;/span>
: برای تایپ‌های رشته‌ای، عددی و بول، می‌توان نام سفارشی جدید انتخاب و در پروژه استفاده کرد:&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-go">
/* type alias */
// bul and bool define the same type.
type bul = bool
// content and string define the same type.
type content = string
// UI8, uint8 and byte define the same type.
type UI8 = uint8
// Word, rune and int32 define the same type.
type Word = rune
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>&lt;span class="tooltip" data-tooltip="type definition" ontouchend="toggleTooltip(this)">ایجاد تایپ جدید معادل یک تایپ موجود&lt;/span>
: همچنین می‌توان از تایپ‌های موجود، یک نمونه جدید ایجاد کرد:&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-go">/* type definition */
// state and bool are two different types.
type state bool
// str and string are two different types.
type str string
// ID and uint64 are two different types.
type ID uint64
// decimal and float32 are two different types.
type decimal float32
&lt;/code>&lt;/pre>
&lt;h2 id="134-مقدار-پیش-فرض-تایپها">
1.3.4 مقدار پیش فرض تایپ‌ها
&lt;a class="anchor" href="#134-%d9%85%d9%82%d8%af%d8%a7%d8%b1-%d9%be%db%8c%d8%b4-%d9%81%d8%b1%d8%b6-%d8%aa%d8%a7%db%8c%d9%be%d9%87%d8%a7">#&lt;/a>
&lt;/h2>
&lt;p>مقدار پیش‌فرض تایپ‌ها در زبان گو به شرح زیر است :&lt;/p>
&lt;ul>
&lt;li>مقدار پیش‌فرض تایپ بولین false است.&lt;/li>
&lt;li>مقدار پیش‌فرض تمامی تایپ اعداد (int, uint, float) صفر است.&lt;/li>
&lt;li>مقدار پیش‌فرض تایپ &lt;strong>string&lt;/strong> برابر با &lt;strong>رشته تهی&lt;/strong> یا &lt;strong>empty string&lt;/strong> است .&lt;/li>
&lt;/ul>
&lt;p>رشته تهی معادل عبارت &lt;strong>&amp;quot;&amp;quot;&lt;/strong> است (دو علامت نقل قول &lt;strong>بدون هیچ کاراکتری در بین آن‌ها&lt;/strong>) و عبارت &lt;strong>&amp;quot; &amp;ldquo;&lt;/strong> که &lt;strong>دارای یک فاصله خالی&lt;/strong>(Space) در بین دو نقل قول است، &lt;strong>یک رشته تهی نیست&lt;/strong> و بنابراین اشتباه است!&lt;/p>
&lt;h2 id="135-انواع-مقادیر-تایپها">
1.3.5 انواع مقادیر تایپ‌ها
&lt;a class="anchor" href="#135-%d8%a7%d9%86%d9%88%d8%a7%d8%b9-%d9%85%d9%82%d8%a7%d8%af%db%8c%d8%b1-%d8%aa%d8%a7%db%8c%d9%be%d9%87%d8%a7">#&lt;/a>
&lt;/h2>
&lt;p>در زبان گو تایپ‌ها یکسری مقادیر مختلفی را دریافت می‌کنند که در زیر به این مقادیر می‌پردازیم.&lt;/p>
&lt;h3 id="1351-تایپ-بولین">
1.3.5.1 تایپ بولین
&lt;a class="anchor" href="#1351-%d8%aa%d8%a7%db%8c%d9%be-%d8%a8%d9%88%d9%84%db%8c%d9%86">#&lt;/a>
&lt;/h3>
&lt;p>تایپ بولین فقط &lt;code>true&lt;/code> و &lt;code>false&lt;/code> را به عنوان مقدار دریافت می‌کند.&lt;/p>
&lt;h3 id="1352-تایپ-integer">
1.3.5.2 تایپ Integer
&lt;a class="anchor" href="#1352-%d8%aa%d8%a7%db%8c%d9%be-integer">#&lt;/a>
&lt;/h3>
&lt;p>تایپ اعداد ۴ نوع مقدار مختلف دریافت می‌کند که به ترتیب Decimal (پایه ۱۰), Octal (پایه ۸), Hex (پایه ۱۶) و Binrary (پایه ۲ یا دودویی) است.&lt;/p>
&lt;pre>&lt;code class="language-go">0xF // the hex form (starts with a &amp;quot;0x&amp;quot; or &amp;quot;0X&amp;quot;)
0XF
017 // the octal form (starts with a &amp;quot;0&amp;quot;, &amp;quot;0o&amp;quot; or &amp;quot;0O&amp;quot;)
0o17
0O17
0b1111 // the binary form (starts with a &amp;quot;0b&amp;quot; or &amp;quot;0B&amp;quot;)
0B1111
15 // the decimal form (starts without a &amp;quot;0&amp;quot;)
&lt;/code>&lt;/pre>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
func main() {
println(15 == 017) // true
println(15 == 0xF) // true
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;h3 id="1353-تایپ-float">
1.3.5.3 تایپ Float
&lt;a class="anchor" href="#1353-%d8%aa%d8%a7%db%8c%d9%be-float">#&lt;/a>
&lt;/h3>
&lt;p>تایپ Float چند نوع مقدار را دریافت می‌کند که به ترتیب مقدار ممیز شناور اعشاری ممکن است شامل یک قسمت صحیح اعشاری، یک نقطه اعشاری، یک قسمت کسری اعشاری، و یک قسمت توانی عدد صحیح (مبتنی بر 10) باشد.&lt;/p>
&lt;pre>&lt;code class="language-go">1.23
01.23 // == 1.23
.23
1.
// An &amp;quot;e&amp;quot; or &amp;quot;E&amp;quot; starts the exponent part (10-based).
1.23e2 // == 123.0
123E2 // == 12300.0
123.E+2 // == 12300.0
1e-1 // == 0.1
.1e0 // == 0.1
0010e-2 // == 0.1
0e+5 // == 0.0
&lt;/code>&lt;/pre>
&lt;h3 id="1354-تایپ-rune">
1.3.5.4 تایپ rune
&lt;a class="anchor" href="#1354-%d8%aa%d8%a7%db%8c%d9%be-rune">#&lt;/a>
&lt;/h3>
&lt;p>تایپ rune یک تایپ با نام مستعار int32 است که از تایپ‌های اعداد صحیح خاص هستند. از rune می‌توان برای ذخیره کاراکترهای یونیکد استفاده کرد که در مثال زیر چند نمونه قرار داده شده است:&lt;/p>
&lt;pre>&lt;code class="language-go">'a' // an English character
'π'
'众' // a Chinese character
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-go">// 141 is the octal representation of decimal number 97.
'\141'
// 61 is the hex representation of decimal number 97.
'\x61'
'\u0061'
'\U00000061'
&lt;/code>&lt;/pre>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
func main() {
println('a' == 97)
println('a' == '\141')
println('a' == '\x61')
println('a' == '\u0061')
println('a' == '\U00000061')
println(0x61 == '\x61')
println('\u4f17' == '众')
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>◾️استاندارد یونیکد، مجموعه‌ای از &lt;strong>تمام&lt;/strong> کاراکترهای موجود در جهان است (کاراکترهای زبان‌های لاتین، فارسی، عربی، چینی و &amp;hellip;، اموجی‌ها (مانند😊)، کاراکترهای غیرقابل نمایش و &amp;hellip;).&lt;/p>
&lt;p>◾️هر کدام از این کاراکترها در استاندارد یونیکد، &lt;strong>توسط یک عدد یکتا و منحصر به فرد&lt;/strong> مشخص شده است. به این عدد &lt;strong>Unicode Code Point&lt;/strong> می‌گویند.&lt;/p>
&lt;p>◾️به عنوان مثال، کد پوینت کاراکتر «😊» برابر است با &lt;strong>U+1F60A&lt;/strong> یا کد پوینت کاراکتر «&lt;strong>ن&lt;/strong>» در زبان فارسی برابر است ب&lt;strong>ا&lt;/strong> &lt;strong>U+0646&lt;/strong>.&lt;/p>
&lt;p>◾️&lt;strong>این کد پوینت‌ها&lt;/strong> دقیقا همان چیزهایی هستند که در &lt;strong>rune&lt;/strong>ها ذخیره می‌شوند.&lt;/p>
&lt;p>◾️از آنجا که زبان گو، از استاندارد &lt;strong>UTF-8&lt;/strong> (ارائه شده توسط کنسرسیوم یونیکد) برای encoding کاراکترها استفاده می‌کند و در این استاندارد، هر کاراکتر فضایی بین 1 تا 4 بایت(8 بیت تا 32 بیت) را در حافظه اِشغال می‌کند. به همین دلیل نوع داده &lt;strong>rune&lt;/strong> یک نام مستعار برای نوع داده &lt;strong>int32&lt;/strong> در زبان گو است.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
var r rune = 'k'
fmt.Printf("%c %T %U", r, r, r)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;h3 id="1355-byte-string-و-rune">
1.3.5.5 byte، string و rune
&lt;a class="anchor" href="#1355-byte-string-%d9%88-rune">#&lt;/a>
&lt;/h3>
&lt;p>مقادیر string و rune[] قابل تبدیل به یک دیگر هستند. اما تفاوت این دو در چیست؟ هر string از مجموعه ای از byte ها تشکیل شده که هر یک 8 بیت هستند. هر کاراکتر در UTF-8 از 1 تا 4 بایت تشکیل شده. مثلا حرف &amp;lsquo;a&amp;rsquo; از یک بایت و کاراکتر &amp;lsquo;你&amp;rsquo; از 3 بایت تشکیل میشه. به کد زیر توجه کنید:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func stringAndRuneCompare() {
s := "hello你好"
fmt.Printf("%s, type: %T, len: %d\n", s, s, len(s))
rs := []rune(s)
fmt.Printf("%v, type: %T, len: %d\n", rs, rs, len(rs))
}
func main() {
stringAndRuneCompare()
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>طول رشته در تایپ string یازده و در تایپ rune[] برابر 7 است. علت چیست؟
رشته در تایپ string یازده است، زیرا 5 نویسه اول هر کدام فقط 1 بایت می گیرند، در حالی که 2 نویسه چینی آخر هر کدام 3 بایت می گیرند. بنابراین، کل بایت 3 * 2 + 1 * 5 = 11 است.&lt;/p>
&lt;p>هنگام تبدیل رشته به rune[]، گو 7 کاراکتر 32 بیتی پیدا می کند. از انجایی که هر rune برابر 32 بیت است، کاراکتر های انگلیسی و چینی هر کدام یک rune را اشغال می کنند. در نتیجه مجموعا 7 rune وجود دارد.&lt;/p>
&lt;h3 id="1356-تایپ-رشته-string">
1.3.5.6 تایپ رشته (string)
&lt;a class="anchor" href="#1356-%d8%aa%d8%a7%db%8c%d9%be-%d8%b1%d8%b4%d8%aa%d9%87-string">#&lt;/a>
&lt;/h3>
&lt;p>در زبان گو مقدار تایپ رشته بطور پیش‌فرض از نوع یونیکد UTF-8 است.&lt;/p>
&lt;pre>&lt;code class="language-go">// The interpreted form.
&amp;quot;Hello\nworld!\n\&amp;quot;你好世界\&amp;quot;&amp;quot;
// The raw form.
`Hello
world!
&amp;quot;你好世界&amp;quot;`
&lt;/code>&lt;/pre>
&lt;p>همچنین رشته از کارکترهای خاص یونیکد مانند &lt;code>0x0D&lt;/code> پشتیبانی می‌کند.&lt;/p>
&lt;h2 id="136-خوانایی-بهتر-اعداد-با-_">
1.3.6 خوانایی بهتر اعداد با _
&lt;a class="anchor" href="#136-%d8%ae%d9%88%d8%a7%d9%86%d8%a7%db%8c%db%8c-%d8%a8%d9%87%d8%aa%d8%b1-%d8%a7%d8%b9%d8%af%d8%a7%d8%af-%d8%a8%d8%a7-_">#&lt;/a>
&lt;/h2>
&lt;p>در زبان گو می‌توان برای خوانایی بهتر اعداد چند رقمی، از &lt;code>_&lt;/code> برای جداسازی استفاده کرد.&lt;/p>
&lt;pre>&lt;code class="language-go">// Legal ones:
6_9 // == 69
0_33_77_22 // == 0337722
0x_Bad_Face // == 0xBadFace
0X_1F_FFP-16 // == 0X1FFFP-16
0b1011_0111 + 0xA_B.Fp2i
// Illegal ones:
_69 // _ can't appear as the first character
69_ // _ can't appear as the last character
6__9 // one side of _ is a illegal character
0_xBadFace // &amp;quot;x&amp;quot; is not a legal octal digit
1_.5 // &amp;quot;.&amp;quot; is not a legal octal digit
1._5 // &amp;quot;.&amp;quot; is not a legal octal digit
&lt;/code>&lt;/pre></description></item><item><author/><title>1.4 عملگرها</title><link>https://book.gofarsi.ir/chapter-1/go-operators/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-1/go-operators/</guid><description>&lt;p>زبان گو مثل سایر زبان‌ها دارای یکسری &lt;span class="tooltip" data-tooltip="Oprators" ontouchend="toggleTooltip(this)">عملگرها&lt;/span>
مانند: عملگرهای حسابی, عملگرهای مقایسه‌ای, عملگرهای منطقی و عملگرهای بیتی است.&lt;/p>
&lt;h2 id="141-عملگرهای-حسابی">
1.4.1 عملگرهای حسابی
&lt;a class="anchor" href="#141-%d8%b9%d9%85%d9%84%da%af%d8%b1%d9%87%d8%a7%db%8c-%d8%ad%d8%b3%d8%a7%d8%a8%db%8c">#&lt;/a>
&lt;/h2>
&lt;p>زبان گو دارای ۵ تا عملگر حسابی است که به ترتیب:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>عملگر&lt;/th>
&lt;th>نام&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>+&lt;/code>&lt;/td>
&lt;td>جمع&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>-&lt;/code>&lt;/td>
&lt;td>تفریق&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>*&lt;/code>&lt;/td>
&lt;td>ضرب&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>/&lt;/code>&lt;/td>
&lt;td>تقسیم&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>%&lt;/code>&lt;/td>
&lt;td>باقی مانده&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>این ۵ تا عملگر اغلب به ترتیب مجموع, تفاوت, حاصل‌ضرب و ضریب نیز نامیده می‌شوند.&lt;/p>
&lt;pre>&lt;code class="language-go"> a := 1
b := 2
c := a + b // 3
d := a - b // -1
e := a * b // 2
f := a / b // 0
g := a % b // 1
&lt;/code>&lt;/pre>
&lt;blockquote class="book-hint info">
در نمونه کد بالا ما از عملگر &lt;code>:=&lt;/code> که شیوه تعریف متغیر به روش کوتاه است استفاده کردیم که در بخش &lt;a href="https://book.gofarsi.ir/chapter-1/go-variables-and-consts/">1.5 متغیرها و ثابت ها معرفی&lt;/a> خواهیم کرد.
&lt;/blockquote>
&lt;h2 id="142-عملگرهای-مقایسهای">
1.4.2 عملگرهای مقایسه‌ای
&lt;a class="anchor" href="#142-%d8%b9%d9%85%d9%84%da%af%d8%b1%d9%87%d8%a7%db%8c-%d9%85%d9%82%d8%a7%db%8c%d8%b3%d9%87%d8%a7%db%8c">#&lt;/a>
&lt;/h2>
&lt;p>زبان گو دارای ۶ عملگر مقایسه‌ای است که به ترتیب:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>عملگر&lt;/th>
&lt;th>نام&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>==&lt;/code>&lt;/td>
&lt;td>مساوی بودن&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>=!&lt;/code>&lt;/td>
&lt;td>مساوی نبودن با&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>&amp;gt;&lt;/code>&lt;/td>
&lt;td>کوچکتر از&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>=&amp;gt;&lt;/code>&lt;/td>
&lt;td>کوچکتر یا مساوی&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>&amp;lt;&lt;/code>&lt;/td>
&lt;td>بزرگتر&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>=&amp;lt;&lt;/code>&lt;/td>
&lt;td>بزرگتر یا مساوی&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>نتیجه استفاده از این عملگرهای مقایسه‌ای, یک نوع untyped بولین است. یعنی حاصل این مقایسه‌ها در واقع true یا false است.&lt;/p>
&lt;pre>&lt;code class="language-go"> a := 1
b := 2
c := 1
println(a == b) // false
println(a == c) // true
println(a &amp;lt; b) // true
println(b &amp;gt; c) // true
println(c &amp;lt;= a) // true
println(c &amp;gt;= b) // false
println(b != a) // true
println(c != a) // false
&lt;/code>&lt;/pre>
&lt;h2 id="143-عملگرهای-منطقی">
1.4.3 عملگرهای منطقی
&lt;a class="anchor" href="#143-%d8%b9%d9%85%d9%84%da%af%d8%b1%d9%87%d8%a7%db%8c-%d9%85%d9%86%d8%b7%d9%82%db%8c">#&lt;/a>
&lt;/h2>
&lt;p>زبان گو دارای ۳ نوع عملگر منطقی است که به ترتیب:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>عملگر&lt;/th>
&lt;th>نام&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>&amp;amp;&amp;amp;&lt;/code>&lt;/td>
&lt;td>AND&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code> &lt;/code>||&lt;/td>
&lt;td>OR&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>!&lt;/code>&lt;/td>
&lt;td>NOT&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>عملگر &lt;strong>&amp;amp;&amp;amp;&lt;/strong> به انگلیسی &lt;strong>AND&lt;/strong> به فارسی &lt;strong>و&lt;/strong> , اگر هردو عملگر true باشد مقدار بازگشتی true و در غیر اینصورت false خواهد بود.&lt;/li>
&lt;li>عملگر &lt;strong>||&lt;/strong> به انگلیسی &lt;strong>OR&lt;/strong> به فارسی &lt;strong>یا&lt;/strong> , اگر یکی از عملگرها true باشد مقدار بازگشتی true در غیر این صورت false خواهد بود.&lt;/li>
&lt;li>عملگر &lt;strong>!&lt;/strong> به انگلیسی &lt;strong>NOT&lt;/strong> به فارسی ‍‍&lt;strong>منفی یا نفی&lt;/strong> , زمانیکه شما از عملگر ! استفاده می کنید معکوس نتیجه عملوند را نیاز دارید.&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-go">a := true
b := true
c := false
fmt.Println(a &amp;amp;&amp;amp; b) //true
fmt.Println(a || b) //true
fmt.Println(!a) //false
fmt.Println(!c) //true
&lt;/code>&lt;/pre>
&lt;p>مثال زیر نتیجه مقادیر متفاوت و عملگرهای منطقی را نشان می‌دهد.&lt;/p>
&lt;pre>&lt;code class="language-go"> // x y x &amp;amp;&amp;amp; y x || y !x !y
true true true true false false
true false false true false true
false true false true true false
false false false false true true
&lt;/code>&lt;/pre>
&lt;h2 id="144-عملگرهای-بیتی">
1.4.4 عملگرهای بیتی
&lt;a class="anchor" href="#144-%d8%b9%d9%85%d9%84%da%af%d8%b1%d9%87%d8%a7%db%8c-%d8%a8%db%8c%d8%aa%db%8c">#&lt;/a>
&lt;/h2>
&lt;p>زبان گو داری 5 عملگر بیتی است که به ترتیب:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>عملگر&lt;/th>
&lt;th>نام&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>&amp;lt;&amp;lt;&lt;/code>&lt;/td>
&lt;td>شیفت بیتی به چپ&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>&amp;gt;&amp;gt;&lt;/code>&lt;/td>
&lt;td>شیفت بیتی به راست&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>&amp;amp;&lt;/code>&lt;/td>
&lt;td>AND&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>|&lt;/td>
&lt;td>OR&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>^&lt;/code>&lt;/td>
&lt;td>XOR&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>‍‍&lt;/p>
&lt;ul>
&lt;li>عملگر &lt;code>&amp;lt;&amp;lt;&lt;/code> به انگلیسی &lt;strong>Zero fill left shift&lt;/strong> یا به اختصار &lt;strong>left shift&lt;/strong> که به فارسی اسم مناسبی نیافتیم به نقل از &lt;a href="https://fa.wikipedia.org/wiki/%D8%B9%D9%85%D9%84%DB%8C%D8%A7%D8%AA_%D8%A8%DB%8C%D8%AA%DB%8C">ویکی پدیا&lt;/a> &lt;strong>شیفت بیتی به چپ&lt;/strong>, مقدار باینری ما را با استفاده از انتقال یا اضافه کردن صفرها به سمت چپ انتقال می‌دهد.&lt;/li>
&lt;li>عملگر &lt;code>&amp;gt;&amp;gt;&lt;/code> به انگلیسی &lt;strong>Zero fill right shift&lt;/strong> یا به اختصار &lt;strong>right shift&lt;/strong> که به فارسی اسم مناسبی نیافتیم به نقل از &lt;a href="https://fa.wikipedia.org/wiki/%D8%B9%D9%85%D9%84%DB%8C%D8%A7%D8%AA_%D8%A8%DB%8C%D8%AA%DB%8C">ویکی پدیا&lt;/a> &lt;strong>شیفت بیتی به راست&lt;/strong>, مقدار باینری ما را با به سمت راست انتقال می‌دهد.&lt;/li>
&lt;/ul>
&lt;p>در زیر دو مثال رو مشاهده می‌کنید که از این دو عملگر استفاده شده:&lt;/p>
&lt;pre>&lt;code class="language-go">//example 1
a := 0b01000101
b := a &amp;lt;&amp;lt; 1
c := a &amp;gt;&amp;gt; 1
fmt.Printf(&amp;quot;binary:%08b,value:%v&amp;quot;, a, a) //binary:01000101,value:69
fmt.Println(&amp;quot;&amp;quot;)
fmt.Printf(&amp;quot;binary:%08b,value:%v&amp;quot;, b, b) //binary:10001010,value:138
fmt.Println(&amp;quot;&amp;quot;)
fmt.Printf(&amp;quot;binary:%08b,value:%v&amp;quot;, c, c) //binary:00100010,value:34
fmt.Println(&amp;quot;\n\n---------------\n&amp;quot;)
//example 2
d := 0b01010101
e := d &amp;lt;&amp;lt; 3
f := d &amp;gt;&amp;gt; 3
fmt.Printf(&amp;quot;binary:%08b,value:%v&amp;quot;, d, d) //binary:01010101,value:85
fmt.Println(&amp;quot;&amp;quot;)
fmt.Printf(&amp;quot;binary:%08b,value:%v&amp;quot;, e, e) //binary:1010101000,value:680
fmt.Println(&amp;quot;&amp;quot;)
fmt.Printf(&amp;quot;binary:%08b,value:%v&amp;quot;, f, f) //binary:00001010,value:10
fmt.Println(&amp;quot;&amp;quot;)
*/
&lt;/code>&lt;/pre>
&lt;p>در مثال دو همانطور که مشاهده کردید زمانی که از عملگر &lt;code>&amp;gt;&amp;gt;&lt;/code> استفاده کردید در صورتی که اولین خانه باینری از سمت چپ مقدار 1 داشته باشد مابقی مقدار به صورت 0 به باینری اضافه می‌شود و در غیر این صورت 1 ها به همان مقدار به سمت چپ خواهد رفت.&lt;/p>
&lt;blockquote class="book-hint info">
در واقع &lt;code>08b%&lt;/code> یک شناساگر قالب (format specifier) برای نمایش باینری در هشت خانه است در &lt;a href="https://pkg.go.dev/fmt">اینجا&lt;/a> می‌توانید بیشتر راجب شناساگرهای قالب بخوانید.
&lt;/blockquote>
&lt;ul>
&lt;li>عملگر &lt;code>&amp;amp;&lt;/code> به انگلیسی &lt;strong>AND&lt;/strong> به فارسی &lt;strong>و&lt;/strong> دو مقدار باینری رو با یک دیگر مقایسه و اگر هر بیت مقدار 1 در هر دو طرف داشته باشد آن را 1 نگه می‌دارد و در غیر اینصورت آن بیت را 0 می‌کند.&lt;/li>
&lt;li>&lt;/li>
&lt;li>عملگر &lt;code>|&lt;/code> به انگلیسی &lt;strong>OR&lt;/strong> به فارسی &lt;strong>یا&lt;/strong> دو مقدار باینری رو با یک دیگر مقایسه و اگر هر بیت مقدار 1 در یک طرف یا هر دوطرف داشته باشد آن را 1 نگه می‌دارد و در غیر اینصورت آن بیت را 0 می‌کند.&lt;/li>
&lt;/ul>
&lt;p>عملگر &lt;code>^&lt;/code> به انگلیسی &lt;strong>XOR&lt;/strong> به فارسی &lt;strong>نامی ندارد&lt;/strong> دو مقدار باینری رو با یک دیگر مقایسه و اگر هر بیت مقدار 1 در هر دوطرف داشته باشد آن را 0 می‌کند.&lt;/p>
&lt;pre>&lt;code class="language-go">//&amp;amp; operator example
a := 0b01000101
b := 0b01010100
c := a &amp;amp; b
fmt.Printf(&amp;quot;binary:%08b,value:%v&amp;quot;, a, a) //binary:01000101,value:69
fmt.Println(&amp;quot;&amp;quot;)
fmt.Printf(&amp;quot;binary:%08b,value:%v&amp;quot;, b, b) //binary:01010100,value:84
fmt.Println(&amp;quot;&amp;quot;)
fmt.Printf(&amp;quot;binary:%08b,value:%v&amp;quot;, c, c) //binary:01000100,value:68
fmt.Println(&amp;quot;\n\n---------------\n&amp;quot;)
//| operator example
d := 0b01000101
e := 0b01010100
f := d | e
fmt.Printf(&amp;quot;binary:%08b,value:%v&amp;quot;, d, d) //binary:01000101,value:69
fmt.Println(&amp;quot;&amp;quot;)
fmt.Printf(&amp;quot;binary:%08b,value:%v&amp;quot;, e, e) //binary:01010100,value:84
fmt.Println(&amp;quot;&amp;quot;)
fmt.Printf(&amp;quot;binary:%08b,value:%v&amp;quot;, f, f) //binary:01010101,value:85
fmt.Println(&amp;quot;\n\n---------------\n&amp;quot;)
//^ operator example
g := 0b01000101
h := 0b01010100
i := a ^ b
fmt.Printf(&amp;quot;binary:%08b,value:%v&amp;quot;, g, g) //binary:01000101,value:69
fmt.Println(&amp;quot;&amp;quot;)
fmt.Printf(&amp;quot;binary:%08b,value:%v&amp;quot;, h, h) //binary:01010100,value:84
fmt.Println(&amp;quot;&amp;quot;)
fmt.Printf(&amp;quot;binary:%08b,value:%v&amp;quot;, i, i) //binary:00010001,value:17
&lt;/code>&lt;/pre>
&lt;h2 id="145-اولویت-عملگرها">
1.4.5 اولویت عملگرها
&lt;a class="anchor" href="#145-%d8%a7%d9%88%d9%84%d9%88%db%8c%d8%aa-%d8%b9%d9%85%d9%84%da%af%d8%b1%d9%87%d8%a7">#&lt;/a>
&lt;/h2>
&lt;p>در زبان گو یکسری اولویت‌ها برای عملگرها وجود دارد و همچنین در زبان گو مثل سایر زبان‌ها پرانتز &lt;code>()&lt;/code> ترویج دهنده اولویت‌ها است.&lt;/p>
&lt;pre>&lt;code class="language-go"> * / % &amp;lt;&amp;lt; &amp;gt;&amp;gt; &amp;amp; &amp;amp;^
+ - | ^
== != &amp;lt; &amp;lt;= &amp;gt; &amp;gt;=
&amp;amp;&amp;amp;
||
&lt;/code>&lt;/pre>
&lt;blockquote class="book-hint warning">
توجه در زبان گو اولویت &lt;code>&amp;lt;&amp;lt;&lt;/code> و &lt;code>&amp;gt;&amp;gt;&lt;/code> بیشتر از + و - است.
&lt;/blockquote></description></item><item><author/><title>1.5 متغیرها و constant</title><link>https://book.gofarsi.ir/chapter-1/go-variables-and-consts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-1/go-variables-and-consts/</guid><description>&lt;h2 id="151-متغیر-variable">
1.5.1 متغیر (Variable)
&lt;a class="anchor" href="#151-%d9%85%d8%aa%d8%ba%db%8c%d8%b1-variable">#&lt;/a>
&lt;/h2>
&lt;p>در برنامه‌نویسی رایانه، یک &lt;span class="tooltip" data-tooltip="Variable" ontouchend="toggleTooltip(this)">متغیر&lt;/span>
یک مکان در حافظه (آدرس حافظه) است که دارای یک نام نمادین با عنوان است و می‌تواند حاوی اطلاعات یا یک مقدار معلوم یا مجهول که به آن &lt;span class="tooltip" data-tooltip="Value" ontouchend="toggleTooltip(this)">ارزش یا مقدار&lt;/span>
می‌گویند، باشد. به زبان دیگر، متغیر در برنامه‌نویسی به فضایی که برای ذخیره داده‌ها کنار گذاشته شده‌ است می‌گویند (&lt;a href="https://fa.wikipedia.org/wiki/%D9%85%D8%AA%D8%BA%DB%8C%D8%B1_%28%D8%A8%D8%B1%D9%86%D8%A7%D9%85%D9%87%E2%80%8C%D9%86%D9%88%DB%8C%D8%B3%DB%8C%29">به نقل از سایت ویکی‌پدیا&lt;/a>)&lt;/p>
&lt;h3 id="تعریف-یک-متغیر-رشته">
تعریف یک متغیر رشته
&lt;a class="anchor" href="#%d8%aa%d8%b9%d8%b1%db%8c%d9%81-%db%8c%da%a9-%d9%85%d8%aa%d8%ba%db%8c%d8%b1-%d8%b1%d8%b4%d8%aa%d9%87">#&lt;/a>
&lt;/h3>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"fmt"
)
func main() {
var s string = "Hello World"
fmt.Println(s)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;ol>
&lt;li>یک &lt;span class="tooltip" data-tooltip="Variable" ontouchend="toggleTooltip(this)">متغیر&lt;/span>
با استفاده از &lt;span class="tooltip" data-tooltip="keyword" ontouchend="toggleTooltip(this)">کلید واژه&lt;/span>
&lt;code>var&lt;/code> ایجاد کردیم.&lt;/li>
&lt;li>نام &lt;span class="tooltip" data-tooltip="Variable" ontouchend="toggleTooltip(this)">متغیر&lt;/span>
را &lt;code>s&lt;/code> گذاشتیم.&lt;/li>
&lt;li>تایپ &lt;span class="tooltip" data-tooltip="Variable" ontouchend="toggleTooltip(this)">متغیر&lt;/span>
را از نوع &lt;code>string&lt;/code> تعیین کردیم.&lt;/li>
&lt;li>سپس با عملگر &lt;code>=&lt;/code> مقدار &lt;span class="tooltip" data-tooltip="Variable" ontouchend="toggleTooltip(this)">متغیر&lt;/span>
را مشخص از نوع رشته تعیین کردیم.&lt;/li>
&lt;li>رشته &lt;code>&amp;quot;Hello World&amp;quot;&lt;/code> به عنوان مقدار &lt;span class="tooltip" data-tooltip="Variable" ontouchend="toggleTooltip(this)">متغیر&lt;/span>
&lt;code>s&lt;/code> است و این مقدار در خانه مشخصی از حافظه قرار داده شده است.&lt;/li>
&lt;li>از پکیج استاندارد &lt;code>fmt&lt;/code> برای چاپ مقدار &lt;span class="tooltip" data-tooltip="Variable" ontouchend="toggleTooltip(this)">متغیر&lt;/span>
&lt;code>s&lt;/code> استفاده کردیم که این پکیج یکسری توابع جهت انجام عملیات‌های مختلفی نظیر چاپ مقادیر را دارد که در کد بالا ما از تابع &lt;code>Println&lt;/code> استفاده کردیم.&lt;/li>
&lt;/ol>
&lt;h3 id="1511-اختصاص-مقدار-جدید-به-متغیر-از-قبل-ایجاد-شده">
1.5.1.1 اختصاص مقدار جدید به متغیر از قبل ایجاد شده
&lt;a class="anchor" href="#1511-%d8%a7%d8%ae%d8%aa%d8%b5%d8%a7%d8%b5-%d9%85%d9%82%d8%af%d8%a7%d8%b1-%d8%ac%d8%af%db%8c%d8%af-%d8%a8%d9%87-%d9%85%d8%aa%d8%ba%db%8c%d8%b1-%d8%a7%d8%b2-%d9%82%d8%a8%d9%84-%d8%a7%db%8c%d8%ac%d8%a7%d8%af-%d8%b4%d8%af%d9%87">#&lt;/a>
&lt;/h3>
&lt;p>در کد زیر ما یک &lt;span class="tooltip" data-tooltip="Variable" ontouchend="toggleTooltip(this)">متغیر&lt;/span>
از قبل تعریف کردیم و مقدار جدید را در خط ۹ به &lt;span class="tooltip" data-tooltip="Variable" ontouchend="toggleTooltip(this)">متغیر&lt;/span>
اختصاص دادیم.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"fmt"
)
func main() {
var s string
s = "Hello World"
fmt.Println(s)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;blockquote class="book-hint info">
زمانی که شما یک &lt;span class="tooltip" data-tooltip="Variable" ontouchend="toggleTooltip(this)">متغیر&lt;/span>
بصورت &lt;code>var s string&lt;/code> تعریف می‌کنید مقدار پیش‌فرض &lt;code>&amp;quot;&amp;quot;&lt;/code> برای &lt;span class="tooltip" data-tooltip="Variable" ontouchend="toggleTooltip(this)">متغیر&lt;/span>
تعیین شده است.
&lt;/blockquote>
&lt;h3 id="1512-اختصاص-مقدار-رشته-به-تایپ-اشتباه">
1.5.1.2 اختصاص مقدار رشته به تایپ اشتباه
&lt;a class="anchor" href="#1512-%d8%a7%d8%ae%d8%aa%d8%b5%d8%a7%d8%b5-%d9%85%d9%82%d8%af%d8%a7%d8%b1-%d8%b1%d8%b4%d8%aa%d9%87-%d8%a8%d9%87-%d8%aa%d8%a7%db%8c%d9%be-%d8%a7%d8%b4%d8%aa%d8%a8%d8%a7%d9%87">#&lt;/a>
&lt;/h3>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"fmt"
)
func main() {
var i int
i = "One"
fmt.Println(i)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در کد بالا ما یک &lt;span class="tooltip" data-tooltip="Variable" ontouchend="toggleTooltip(this)">متغیر&lt;/span>
از نوع &lt;code>int&lt;/code> تعریف کردیم و در خط ۹ مقدار &lt;code>&amp;quot;One&amp;quot;&lt;/code> را به آن تخصیص دادیم و پس از اجرا با خطای &lt;code>cannot use &amp;quot;One&amp;quot; (type string) as type int in assignment&lt;/code> مواجه شدیم. این خطا یعنی اینکه شما یک مقدار رشته را به تایپ اشتباه اختصاص داده‌اید.&lt;/p>
&lt;h3 id="1513-تعریف-متغیر-به-صورت-خلاصه">
1.5.1.3 تعریف متغیر به صورت خلاصه
&lt;a class="anchor" href="#1513-%d8%aa%d8%b9%d8%b1%db%8c%d9%81-%d9%85%d8%aa%d8%ba%db%8c%d8%b1-%d8%a8%d9%87-%d8%b5%d9%88%d8%b1%d8%aa-%d8%ae%d9%84%d8%a7%d8%b5%d9%87">#&lt;/a>
&lt;/h3>
&lt;p>زبان گو علاوه بر اینکه از &lt;span class="tooltip" data-tooltip="keyword" ontouchend="toggleTooltip(this)">کلید واژه&lt;/span>
&lt;code>var&lt;/code> برای تعریف متغیر پشتیبانی می‌کند, از &lt;code>=:&lt;/code> به انگلیسی &lt;code>short variable declaration&lt;/code> نیز برای تعریف متغیرها پشتیبانی می‌کند. شما می‌توانید یک &lt;span class="tooltip" data-tooltip="Variable" ontouchend="toggleTooltip(this)">متغیر&lt;/span>
تعریف کنید و نیازی به مشخص کردن تایپ متغیر نیست، چون زبان گو بر اساس مقدار تعیین شده تایپ متغیر را تشخیص می‌دهد.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
s := "Hello World"
fmt.Println(s)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;blockquote class="book-hint warning">
&lt;p>توجه کنید شما فقط داخل تابع می‌توانید به صورت مختصر متغیر تعریف کنید و جهت تعریف متغیر به‌صورت عمومی باید از کلید واژه &lt;code>var&lt;/code> استفاده کنید.&lt;/p>
&lt;p>بهتر است برای تعریف متغیر داخل تابع از روش مختصر استفاده کنید و متغیر با &lt;code>var&lt;/code> بصورت عمومی در بدنه کد باشد.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
&lt;p>import (
&amp;ldquo;fmt&amp;rdquo;
)&lt;/p>
&lt;p>var s string = &amp;ldquo;Hello World&amp;rdquo;&lt;/p>
&lt;p>func main() {
fmt.Println(s)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>&lt;/p>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;/blockquote>
&lt;h3 id="1514-تعریف-چند-متغیر-در-یک-خط">
1.5.1.4 تعریف چند متغیر در یک خط
&lt;a class="anchor" href="#1514-%d8%aa%d8%b9%d8%b1%db%8c%d9%81-%da%86%d9%86%d8%af-%d9%85%d8%aa%d8%ba%db%8c%d8%b1-%d8%af%d8%b1-%db%8c%da%a9-%d8%ae%d8%b7">#&lt;/a>
&lt;/h3>
&lt;p>در زبان گو شما می‌توانید همزمان چند متغیر را در یک خط تعریف کنید که در زیر یک نمونه کد مثال زدیم :&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
a, b, c := "hello", 1, 1.5
var d, e, f = "world", 13, 24
fmt.Println(a, b, c, d, e, f)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;h3 id="1515-تعریف-متغیر-با-مقدار-پیشفرض">
1.5.1.5 تعریف متغیر با مقدار پیش‌فرض
&lt;a class="anchor" href="#1515-%d8%aa%d8%b9%d8%b1%db%8c%d9%81-%d9%85%d8%aa%d8%ba%db%8c%d8%b1-%d8%a8%d8%a7-%d9%85%d9%82%d8%af%d8%a7%d8%b1-%d9%be%db%8c%d8%b4%d9%81%d8%b1%d8%b6">#&lt;/a>
&lt;/h3>
&lt;p>در کد زیر ما یکسری متغیر با تایپ‌های مختلف تعریف کردیم که با مقدار پیش‌فرض ایجاد شده‌اند.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
var i int
var f float32
var b bool
var s string
fmt.Printf("%v %v %v %q\n", i, f, b, s) //0 0 false ""
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;h2 id="152-مقدار-ثابت-constant">
1.5.2 مقدار ثابت (Constant)
&lt;a class="anchor" href="#152-%d9%85%d9%82%d8%af%d8%a7%d8%b1-%d8%ab%d8%a7%d8%a8%d8%aa-constant">#&lt;/a>
&lt;/h2>
&lt;p>ثابت &lt;code>(Constant)&lt;/code>‌ها بر خلاف متغیر‌ها که با کلید واژه &lt;code>var&lt;/code> تعریف می‌شود, با کلید واژه &lt;code>const&lt;/code> تعریف می‌شوند با این تفاوت که ثابت‌ها در طول اجرای کد مقدارشان غیرقابل تغییر هست به انگلیسی &lt;code>Immutable&lt;/code>, و تضمین می‌کنند هیچ چیزی در طول اجرای برنامه, باعث تغییر مقدار &lt;code>ثابت&lt;/code> نشود.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"fmt"
)
const s string = "Hello World"
func main() {
fmt.Println(s)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>همانطور که در مثال فوق گفتیم شما نمی‌توانید &lt;code>ثابت&lt;/code>‌ها را مجددا مقدار دهی کنید. در مثال زیر خطایی که بعد از مقدار دهی دوباره یک &lt;code>ثابت&lt;/code> در زمان اجرا رخ داده است را قرار دادیم :&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
func main() {
const a int = 8
a = 9
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;h3 id="1521-تعریف-constant-بدون-نیاز-به-تعیین-تایپ">
1.5.2.1 تعریف Constant بدون نیاز به تعیین تایپ
&lt;a class="anchor" href="#1521-%d8%aa%d8%b9%d8%b1%db%8c%d9%81-constant-%d8%a8%d8%af%d9%88%d9%86-%d9%86%db%8c%d8%a7%d8%b2-%d8%a8%d9%87-%d8%aa%d8%b9%db%8c%db%8c%d9%86-%d8%aa%d8%a7%db%8c%d9%be">#&lt;/a>
&lt;/h3>
&lt;p>در تعریف &lt;code>ثابت&lt;/code>‌ها همانند متغیر ها شما می‌توانید یک &lt;code>ثابت&lt;/code> بدون تعیین تایپ تعریف کنید و زبان گو در زمان اجرا با توجه به مقدار اختصاص داده شده به &lt;code>ثابت&lt;/code> شما, تایپ را تشخیص می دهد.&lt;/p>
&lt;pre>&lt;code class="language-go">const a = 1 //Default hidden type is int
const b = &amp;quot;circle&amp;quot; //Default hidden type is string
const c = 5.4 //Default hidden type is float64
const d = true //Default hidden type is bool
const e = 'a' //Default hidden type is rune
const f = 3+5i //Default hidden type is complex128
&lt;/code>&lt;/pre>
&lt;h2 id="153-نحوه-مشاهده-تایپ-متغیر-یا-constant">
1.5.3 نحوه مشاهده تایپ متغیر یا Constant
&lt;a class="anchor" href="#153-%d9%86%d8%ad%d9%88%d9%87-%d9%85%d8%b4%d8%a7%d9%87%d8%af%d9%87-%d8%aa%d8%a7%db%8c%d9%be-%d9%85%d8%aa%d8%ba%db%8c%d8%b1-%db%8c%d8%a7-constant">#&lt;/a>
&lt;/h2>
&lt;p>در مثال زیر ما با استفاده از یکی از توابع پکیج &lt;code>fmt&lt;/code> نوع و مقدار متغیر یا ثابت ها را چاپ کردیم.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
// Named untyped constant
const a = 123 //Default hidden type is int
const b = "circle" //Default hidden type is string
const c = 5.6 //Default hidden type is float64
const d = true //Default hidden type is bool
const e = 'a' //Default hidden type is rune
const f = 3 + 5i //Default hidden type is complex8
var u = 123 //Default hidden type is int
var v = "circle" //Default hidden type is string
var w = 5.6 //Default hidden type is float64
var x = true //Default hidden type is bool
var y = 'a' //Default hidden type is rune
var z = 3 + 5i //Default hidden type is complex128
func main() {
fmt.Println("")
fmt.Printf("Type: %T Value: %v\n", a, a)
fmt.Printf("Type: %T Value: %v\n", b, b)
fmt.Printf("Type: %T Value: %v\n", c, c)
fmt.Printf("Type: %T Value: %v\n", d, d)
fmt.Printf("Type: %T Value: %v\n", e, e)
fmt.Printf("Type: %T Value: %v\n", f, f)
fmt.Printf("Type: %T Value: %v\n", u, u)
fmt.Printf("Type: %T Value: %v\n", v, v)
fmt.Printf("Type: %T Value: %v\n", w, w)
fmt.Printf("Type: %T Value: %v\n", x, x)
fmt.Printf("Type: %T Value: %v\n", y, y)
fmt.Printf("Type: %T Value: %v\n", z, z)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;h3 id="1531-استفاده-از-iota-در-constant">
1.5.3.1 استفاده از iota در constant
&lt;a class="anchor" href="#1531-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-iota-%d8%af%d8%b1-constant">#&lt;/a>
&lt;/h3>
&lt;p>شناسه &lt;code>iota&lt;/code> فقط با &lt;code>ثابت&lt;/code>‌ها قابل استفاده است و با آن می‌توانید اعداد &lt;code>auto increment&lt;/code> ایجاد کنید.&lt;/p>
&lt;p>&lt;strong>ایجاد auto increment بدون &lt;code>iota&lt;/code> :&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">const (
a = 0
b = 1
c = 2
)
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>ایجاد auto increment با &lt;code>iota&lt;/code> :&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">const (
a = iota // 0
b // 1
c // 2
)
&lt;/code>&lt;/pre>
&lt;blockquote class="book-hint warning">
توجه کنید مقدار پیش‌فرض &lt;code>iota&lt;/code> صفر, و &lt;code>ثابت&lt;/code> ما از نوع &lt;code>int&lt;/code> است.
&lt;/blockquote>
&lt;h3 id="1532-نحوه-ایجاد-enum">
1.5.3.2 نحوه ایجاد enum
&lt;a class="anchor" href="#1532-%d9%86%d8%ad%d9%88%d9%87-%d8%a7%db%8c%d8%ac%d8%a7%d8%af-enum">#&lt;/a>
&lt;/h3>
&lt;p>از &lt;code>iota&lt;/code> و &lt;code>ثابت&lt;/code> برای ایجاد &lt;a href="https://en.wikipedia.org/wiki/Enumerated_type">enum&lt;/a> ها هم می‌توان استفاده کرد که در مثال زیر یک نمونه کد برای ایجاد enum را نیز قرار داده‌ایم.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
type Size uint8
const (
small Size = iota
medium
large
extraLarge
)
func main() {
fmt.Println(small)
fmt.Println(medium)
fmt.Println(large)
fmt.Println(extraLarge)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;h3 id="1533-نادیده-گرفتن-مقدار-اول-iota">
1.5.3.3 نادیده گرفتن مقدار اول iota
&lt;a class="anchor" href="#1533-%d9%86%d8%a7%d8%af%db%8c%d8%af%d9%87-%da%af%d8%b1%d9%81%d8%aa%d9%86-%d9%85%d9%82%d8%af%d8%a7%d8%b1-%d8%a7%d9%88%d9%84-iota">#&lt;/a>
&lt;/h3>
&lt;p>وقتی که داریم از &lt;code>iota&lt;/code> استفاده می‌کنیم شاید هنگام استفاده از auto increament نیاز باشد مقدار اول را نادیده بگیریم. برای اینکار می‌توان از &lt;code>_&lt;/code> استفاده کرد به شکل زیر :&lt;/p>
&lt;pre>&lt;code class="language-go">const (
_ = iota // ignore
a // 1
b // 2
c // 3
)
&lt;/code>&lt;/pre>
&lt;h3 id="1534-خودآزمون-iota">
1.5.3.4 خودآزمون iota
&lt;a class="anchor" href="#1534-%d8%ae%d9%88%d8%af%d8%a2%d8%b2%d9%85%d9%88%d9%86-iota">#&lt;/a>
&lt;/h3>
&lt;p>خروجی کد زیر را در ذهن محاسبه کنید و با اجرای کد صحت آن را بررسی کنید.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
const (
A = iota
B
C
D = B + C
E
F
G = iota
H
I = H
J
K
)
fmt.Println(A, B, C, D, E, F, G, H, I, J, K)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;h2 id="154-قوانین-نامگذاری-متغیر-و-constant">
1.5.4 قوانین نام‌گذاری متغیر و constant
&lt;a class="anchor" href="#154-%d9%82%d9%88%d8%a7%d9%86%db%8c%d9%86-%d9%86%d8%a7%d9%85%da%af%d8%b0%d8%a7%d8%b1%db%8c-%d9%85%d8%aa%d8%ba%db%8c%d8%b1-%d9%88-constant">#&lt;/a>
&lt;/h2>
&lt;p>در زیر ما یکسری قوانین جهت نام‌گذاری متغیر و &lt;code>تابت&lt;/code>‌ها تعریف کرده‌ایم :&lt;/p>
&lt;ul>
&lt;li>نام متغیر یا ثابت باید با یک حرف انگلیسی یا &lt;code>_&lt;/code> شروع شود.&lt;/li>
&lt;li>نام‌ها می‌توانند ترکیبی از اعداد و حروف انگلیسی یا &lt;code>_&lt;/code> باشد.&lt;/li>
&lt;li>زبان گو به حروف بزرگ و کوچک در نام ها حساس است و اگر شما &lt;code>hello&lt;/code> یا &lt;code>Hello&lt;/code> را تعریف کنید, ۲ متغیر یا ثابت متفاوت محسوب می‌شوند.&lt;/li>
&lt;li>محدودیتی در تعداد حروف نام‌ها وجود ندارد ولی بهتر است از یک تعداد مطلوب و مشخصی برای نام‌ها استفاده کنید.&lt;/li>
&lt;/ul>
&lt;blockquote class="book-hint info">
&lt;p>توجه داشته باشید اصولا اسم ثابت‌ها را با حروف بزرگ و خارج از توابع تعریف می‌کنند.&lt;/p>
&lt;ul>
&lt;li>با تعریف کردن ثابت‌ها با حروف بزرگ, هنگام استفاده مشخص‌تر خواهند بود.&lt;/li>
&lt;li>از آنجایی که ثابت‌ها فقط امکان read یا همان خواندن را می‌دهند ممکن است در قسمت‌های مختلف به آن مقادیر نیاز داشته باشیم.&lt;/li>
&lt;li>به دلیل اینکه با هر بار فراخوانی &lt;code>تابع&lt;/code>, کامپایلر عملیات مقدار دهی ثابت را دوباره انجام می‌دهد, بهتر است آن را خارج از تابع تعریف کنیم.&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item><item><author/><title>1.6 مقادیر صفر تایپ‌ها (zero values)</title><link>https://book.gofarsi.ir/chapter-1/go-zero-values/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-1/go-zero-values/</guid><description>&lt;p>در جدول زیر فهرست تمامی تایپ‌ها را با مقادیر صفرشان &lt;code>(پیش‌فرض)&lt;/code> قرار دادیم:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>تایپ&lt;/th>
&lt;th>مقدار پیش فرض یا مقدار صفر&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>int&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>int8&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>int16&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>int32&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>int64&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>uint&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>uint8&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>uint16&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>uint32&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>uint64&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>uintptr&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>float32&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>float64&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>complex64&lt;/td>
&lt;td>0+0i&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>complex128&lt;/td>
&lt;td>0+0i&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>bool&lt;/td>
&lt;td>false&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>string&lt;/td>
&lt;td>&amp;quot;&amp;quot;&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>interface&lt;/td>
&lt;td>nil&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>slice&lt;/td>
&lt;td>nil&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>channel&lt;/td>
&lt;td>nil&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>map&lt;/td>
&lt;td>nil&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>pointer&lt;/td>
&lt;td>nil&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>function&lt;/td>
&lt;td>nil&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>struct&lt;/td>
&lt;td>براساس مقدار پیش فرض فیلدها&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>نمونه کد نمایش مقدار صفر تایپ‌ها:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"fmt"
)
func main() {
var (
a int
b int8
c int16
d int32
e int64
f uint
g uint8
h uint16
i uint32
j uint64
k uintptr
l float32
m float64
n complex64
o complex128
p bool
q string
r interface{}
s []int
t chan int
u map[string]int
v *int
w func()
x struct{}
y struct {
ya int
yb bool
yc rune
}
)
fmt.Println("int:", a)
fmt.Println("int8:", b)
fmt.Println("int16:", c)
fmt.Println("int32:", d)
fmt.Println("int64:", e)
fmt.Println("uint:", f)
fmt.Println("uint8:", g)
fmt.Println("uint16:", h)
fmt.Println("uint32:", i)
fmt.Println("uint64:", j)
fmt.Println("uintptr:", k)
fmt.Println("float32:", l)
fmt.Println("float64:", m)
fmt.Println("complex64:", n)
fmt.Println("complex128:", o)
fmt.Println("bool:", p)
fmt.Println("string:", q)
fmt.Println("interface:", r)
fmt.Println("slice:", s)
fmt.Println("channel:", t)
fmt.Println("map:", u)
fmt.Println("pointer:", v)
fmt.Println("function:", w)
fmt.Println("struct:", x)
fmt.Println("struct:", y)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div></description></item><item><author/><title>1.7 تابع (function)</title><link>https://book.gofarsi.ir/chapter-1/go-function/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-1/go-function/</guid><description>&lt;h2 id="171-تابع-چیست">
1.7.1 تابع چیست؟
&lt;a class="anchor" href="#171-%d8%aa%d8%a7%d8%a8%d8%b9-%da%86%db%8c%d8%b3%d8%aa">#&lt;/a>
&lt;/h2>
&lt;p>در برنامه‌نویسی، &lt;strong>تابع&lt;/strong> به تکه کدهایی گفته می‌شود که برای انجام عملی خاص استفاده می‌شوند. به کمک توابع می‌توانیم تکه کدها را از یکدیگر جدا کنیم و از تکرار کدها جلوگیری کنیم.&lt;/p>
&lt;p>همانند شکل زیر تابع مانند یک جعبه (یا قطعه کد) است. که یک مقدار ورودی گرفته و روی آن پردازش‌هایی انجام می‌دهد و یک خروجی تولید می‌کند. تابع می‌تواند هر چندتا ورودی یا خروجی داشته باشد.
&lt;img src="https://res.cloudinary.com/practicaldev/image/fetch/s--iCkOfD0L--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://cdn-images-1.medium.com/max/1024/1%2A709ugF12LLkYxvb839YNlg.png" alt="" />&lt;/p>
&lt;h3 id="1711-چرا-از-توابع-در-برنامه-نویسی-استفاده-میکنیم">
1.7.1.1 چرا از توابع در برنامه نویسی استفاده می‌کنیم؟
&lt;a class="anchor" href="#1711-%da%86%d8%b1%d8%a7-%d8%a7%d8%b2-%d8%aa%d9%88%d8%a7%d8%a8%d8%b9-%d8%af%d8%b1-%d8%a8%d8%b1%d9%86%d8%a7%d9%85%d9%87-%d9%86%d9%88%db%8c%d8%b3%db%8c-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d9%85%db%8c%da%a9%d9%86%db%8c%d9%85">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>با استفاده از توابع، می‌توانیم یک قطعه کد را یک بار بنویسیم و چندین بار از آن استفاده کنیم.&lt;/li>
&lt;li>با استفاده از توابع، حجم کدنویسی ما کم‌تر می‌شود و سرعت توسعه نرم‌افزار بیشتر می‌شود.&lt;/li>
&lt;li>توابع به ما کمک می‌کنند تا کد خود را به تکه‌هایی کوچک‌تر تقسیم کنیم تا برنامه ی ما خوانا و قابل درک‌تر باشد. همچنین نگهداری و اشکال زدایی کد را آسان‌تر می‌کند.&lt;/li>
&lt;/ul>
&lt;h2 id="172-توابع-در-زبان-گولنگ">
1.7.2 توابع در زبان گولنگ
&lt;a class="anchor" href="#172-%d8%aa%d9%88%d8%a7%d8%a8%d8%b9-%d8%af%d8%b1-%d8%b2%d8%a8%d8%a7%d9%86-%da%af%d9%88%d9%84%d9%86%da%af">#&lt;/a>
&lt;/h2>
&lt;p>توابع یکی از قابلیت‌های مهم هر زبانی محسوب می‌شوند. توابع در گولنگ داری سینتکس ساده‌ای هستند.&lt;/p>
&lt;h3 id="1721-تعریف-یک-تابع">
1.7.2.1 تعریف یک تابع
&lt;a class="anchor" href="#1721-%d8%aa%d8%b9%d8%b1%db%8c%d9%81-%db%8c%da%a9-%d8%aa%d8%a7%d8%a8%d8%b9">#&lt;/a>
&lt;/h3>
&lt;pre>&lt;code class="language-go">func function_name( [Parameter-list] ) [return_types] {
// body of the function
}
&lt;/code>&lt;/pre>
&lt;ol>
&lt;li>&lt;strong>func&lt;/strong> - با این کلید واژه یک تابع تعریف می‌کنیم.&lt;/li>
&lt;li>&lt;strong>function_name&lt;/strong> - نام تابع باید یکتا و در طول برنامه منحصر به فرد باشد.&lt;/li>
&lt;li>&lt;strong>Parameter-list&lt;/strong> - پارامترهای ورودی در این قسمت تعریف می‌شوند. پارامترها اختیاری هستند یعنی ممکن است یک تابع هیچ پارامتری نداشته باشد.&lt;/li>
&lt;li>&lt;strong>Return_type&lt;/strong> - نوع داده‌های بازگشتی را در این قسمت مشخص می‌کنیم و در برخی توابع عملیات موردنظر را بدون بازگرداندن مقداری انجام می‌دهند در این توابع نیازی به تعیین return_type نیست.&lt;/li>
&lt;li>&lt;strong>Function Body&lt;/strong> - این قسمت شامل کدهایی است که نشان می‌دهد تابع چه کارهایی انجام می‌دهد.&lt;/li>
&lt;/ol>
&lt;h4 id="17211-مثال">
1.7.2.1.1 مثال
&lt;a class="anchor" href="#17211-%d9%85%d8%ab%d8%a7%d9%84">#&lt;/a>
&lt;/h4>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func plus(a int, b int) int {
return a + b
}
func main() {
fmt.Println(plus(4, 13))
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;ol>
&lt;li>در اینجا یک تابع با نام plus تعریف کردیم که دو پارامتر a, b را با نوع داده int دریافت می‌کند و جمع این دو عدد را حساب می‌کند. توجه کنید که همیشه باید نوع داده را مشخص کنیم.&lt;/li>
&lt;li>بعد از تعریف پارامترهای ورودی و قبل از قرار دادن کد داخل براکت int را می‌بینید که نوع خروجی داده را مشخص می‌کند، یعنی خروجی این تابع باید از نوع int باشد.&lt;/li>
&lt;li>برای صدا زدن توابع کافی است نام تابع رو همراه با پرانتز باز و بسته تایپ کنید, برای مثال ()plus.&lt;/li>
&lt;/ol>
&lt;blockquote class="book-hint info">
&lt;p>در صورتی که پارامترهای ورودی از یک نوع باشند بجای تعریف نوع به‌صورت تکی، می‌توانیم نوع داده را در آخر همه پارامترهای هم نوع مشخص کنیم.&lt;/p>
&lt;pre>&lt;code class="language-go">func plus(a, b int)
// or
func name(a string, b,c int)
&lt;/code>&lt;/pre>
&lt;/blockquote>
&lt;h4 id="17212-الگو-دیگر-تعریف-تابع">
1.7.2.1.2 الگو دیگر تعریف تابع:
&lt;a class="anchor" href="#17212-%d8%a7%d9%84%da%af%d9%88-%d8%af%db%8c%da%af%d8%b1-%d8%aa%d8%b9%d8%b1%db%8c%d9%81-%d8%aa%d8%a7%d8%a8%d8%b9">#&lt;/a>
&lt;/h4>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
plus := func (a int, b int) int {
return a + b
}
fmt.Println(plus(3, 4))
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;h2 id="173-قوانین-نام-گذاری-تابع-در-گولنگ">
1.7.3 قوانین نام گذاری تابع در گولنگ
&lt;a class="anchor" href="#173-%d9%82%d9%88%d8%a7%d9%86%db%8c%d9%86-%d9%86%d8%a7%d9%85-%da%af%d8%b0%d8%a7%d8%b1%db%8c-%d8%aa%d8%a7%d8%a8%d8%b9-%d8%af%d8%b1-%da%af%d9%88%d9%84%d9%86%da%af">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>نام تابع باید با یک حرف شروع شود.&lt;/li>
&lt;li>نام تابع فقط می‌تواند شامل حروف-عدد و underscores باشد.  (&lt;code>A-z&lt;/code>, &lt;code>0-9&lt;/code>,  &lt;code>_&lt;/code> )&lt;/li>
&lt;li>نام تابع به حروف کوچک و بزرگ حساس است.&lt;/li>
&lt;li>در نام‌گذاری تابع از فاصله نمی‌توانیم استفاده کنیم.&lt;/li>
&lt;/ul>
&lt;br/>
&lt;h2 id="174-توابع-چند-بازگشتی-در-گولنگ-multiple-results">
‬1.7.4 توابع چند بازگشتی در گولنگ (Multiple results)
&lt;a class="anchor" href="#174-%d8%aa%d9%88%d8%a7%d8%a8%d8%b9-%da%86%d9%86%d8%af-%d8%a8%d8%a7%d8%b2%da%af%d8%b4%d8%aa%db%8c-%d8%af%d8%b1-%da%af%d9%88%d9%84%d9%86%da%af-multiple-results">#&lt;/a>
&lt;/h2>
&lt;p>همچنین در گولنگ توابع می‌توانند چندین مقادیر را برگردانند.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func vals() (int, int) {
return 3, 7
}
func main() {
a, b := vals()
fmt.Println(a)
fmt.Println(b)
_, c := vals()
fmt.Println(c)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;ol>
&lt;li>در کد بالا تابعی ساختیم با اسم vals که دو خروجی از نوع int دارد بنابراین نوع تعریف توابع چندبازگشتی متفاوت است و بصورت (data-type, data-type, &amp;hellip; ) است.&lt;/li>
&lt;li>در مثال اول ما با کمک دو متغیر a,b دو خروجی تابع vals را دریافت کردیم.&lt;/li>
&lt;li>در مثال دوم ما با استفاده از _ blank identifier از دریافت یا استخراج خروجی اول صرف نظر کردیم و فقط خروجی دوم با متغیر c را دریافت کردیم.&lt;/li>
&lt;/ol>
&lt;blockquote class="book-hint warning">
در توابع چند بازگشتی خروجی آنها را باید با , از هم جدا کرد
&lt;/blockquote>
&lt;br/>
&lt;h3 id="1741-مقادیر-بازگشتی-نام-گذاری-شده-named-return-values">
1.7.4.1 مقادیر بازگشتی نام گذاری شده (Named Return Values)
&lt;a class="anchor" href="#1741-%d9%85%d9%82%d8%a7%d8%af%db%8c%d8%b1-%d8%a8%d8%a7%d8%b2%da%af%d8%b4%d8%aa%db%8c-%d9%86%d8%a7%d9%85-%da%af%d8%b0%d8%a7%d8%b1%db%8c-%d8%b4%d8%af%d9%87-named-return-values">#&lt;/a>
&lt;/h3>
&lt;p>در گولنگ می‌توانیم مقدار بازگشتی یک تابع را نامگذاری کنیم. به مثال زیر توجه کنید:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func split(sum int) (x, y int) {
x = sum * 4 / 9
y = sum - x
return
}
func main() {
fmt.Println(split(17))
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;ol>
&lt;li>ما در این تابع مقدار بازگشتی را x, y از نوع int نام گذاری می‌کنیم.&lt;/li>
&lt;li>در اینجا یک دستور return بدون تعیین آرگومان بازگشتی، مقادیر نام گذاری شده را باز می‌گرداند، که به عنوان &lt;strong>Naked return&lt;/strong> شناخته می‌شود.&lt;/li>
&lt;li>از naked return باید در توابع کوتاه مانند مثال بالا استفاده شود. استفاده آن در تابع طولانی منجر به کاهش خوانایی کد می شود.&lt;/li>
&lt;/ol>
&lt;br/>
&lt;h2 id="175-توابع-متنوع-در-گولنگ-variadic-functions">
1.7.5 توابع متنوع در گولنگ (Variadic Functions)
&lt;a class="anchor" href="#175-%d8%aa%d9%88%d8%a7%d8%a8%d8%b9-%d9%85%d8%aa%d9%86%d9%88%d8%b9-%d8%af%d8%b1-%da%af%d9%88%d9%84%d9%86%da%af-variadic-functions">#&lt;/a>
&lt;/h2>
&lt;p>یکی از قابلیت‌های گو وجود توابع متنوع است. منظور از توابع متنوع توابعی هستند که بدون محدودیت پارامتر دریافت می‌کنند &lt;code>(این نکته رو در نظر بگیرین که نباید تایپ ورودی‌ها با یکدیگر فرق کند، برای مثال همه باید int باشند)&lt;/code>.
‍‍
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func sum(nums ...int) {
fmt.Print(nums, " ")
total := 0
for _, num := range nums {
total += num
}
fmt.Println(total)
}
func main() {
sum(1, 2)
sum(1, 2, 3)
nums := []int{1, 2, 3, 4}
sum(nums...)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;/p>
&lt;ol>
&lt;li>در اینجا تابعی تعریف کردیم که تعداد دلخواهی از آرگومان‌ها از نوع int را به کمک &amp;hellip; &lt;code>(بهش میگن Ellipsis)&lt;/code> که قبل از نوع داده قرار گرفته به داخل تابع منتقل می‌کند.&lt;/li>
&lt;li>برای صدا زدن این توابع می‌توان به روش sum(num1, num2, &amp;hellip;) عمل کرد.&lt;/li>
&lt;li>اگر شما داده‌ای با نوع slice دارید می‌توانید آن را به کمک اپراتور &amp;hellip;&lt;code>(Ellipsis)&lt;/code> به صورت sum(nums&amp;hellip;) به داخل تابع انتقال بدید.&lt;/li>
&lt;/ol>
&lt;br/>
&lt;h2 id="176-توابع-ناشناس-در-گولنگ-anonymous-functions">
1.7.6 توابع ناشناس در گولنگ (Anonymous Functions)
&lt;a class="anchor" href="#176-%d8%aa%d9%88%d8%a7%d8%a8%d8%b9-%d9%86%d8%a7%d8%b4%d9%86%d8%a7%d8%b3-%d8%af%d8%b1-%da%af%d9%88%d9%84%d9%86%da%af-anonymous-functions">#&lt;/a>
&lt;/h2>
&lt;p>در زبان گولنگ می‌توانیم تابع بدون نام تعریف کنیم، که به عنوان توابع ناشناس شناخته می‌شوند.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
// anonymous function
var sum = func(n1, n2 int) int {
sum := n1 + n2
return sum
}
// function call
result := sum(5, 3)
fmt.Println("Sum is:", result)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;ol>
&lt;li>از آنجایی که توابع ناشناس نامی ندارد ما در بعضی اوقات آن‌ها را به یک متغیر اختصاص می‌دهیم سپس از نام متغیر برای فراخوانی تابع استفاده می‌کنیم. در این مثال می‌بینید که ما از sum برای فراخوانی تابع استفاده می‌کنیم.&lt;/li>
&lt;li>مانند توابع معمولی ما می‌توانیم برای تابع ناشناس پارامتر تعریف کنیم و همچنین مقداری را از تابع برگردانیم در این مثال تابع دو مقدار با نوع داده int دریافت می‌کنید و یک خروجی با نوع int دارد.&lt;/li>
&lt;li>تابع ناشناس را می‌توان برای عملکردهایی که نیازی به نام‌گذاری ندارند و معمولا برای استفاده کوتاه مدت هست، استفاده کرد.&lt;/li>
&lt;/ol>
&lt;p>اما یکی از موارد کاربردی توابع ناشناس در گولنگ پاس دادن آن‌ها به توابعی هستند که تابعی را تحت عنوان پارامتر ورودی دریافت میکنند.
در مثال زیر ما یک تابع تعریف کردیم که در پارامتر سوم یک تابع دریافت می‌کند که باید دو ورودی int و یک خروجی int داشته باشد.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func add10AndSum(num1 int, num2 int, sum func(n1, n2 int) int) {
result := sum(num1+10, num2+10)
fmt.Println("Sum by adding 10 is:", result)
}
func main() {
add10AndSum(5, 3, func(n1, n2 int) int {
sum := n1 + n2
return sum
})
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;br/>
&lt;h2 id="177-توابع-از-پیش-تعریف-شده-built-in-function">
1.7.7 توابع از پیش تعریف شده (Built-in Function)
&lt;a class="anchor" href="#177-%d8%aa%d9%88%d8%a7%d8%a8%d8%b9-%d8%a7%d8%b2-%d9%be%db%8c%d8%b4-%d8%aa%d8%b9%d8%b1%db%8c%d9%81-%d8%b4%d8%af%d9%87-built-in-function">#&lt;/a>
&lt;/h2>
&lt;p>در گولنگ علاوه بر تابع‌هایی که توسط کاربر تعریف می‌شود یکسری توابع وجود دارد که از قبل تعریف شده‌اند که طراحان این زبان برای سهولت کار برنامه‌نویسان این توابع را نوشته‌اند و آن را همراه زبان گولنگ ارائه می‌دهند.&lt;/p>
&lt;p>&lt;a href="https://book.gofarsi.ir/chapter-1/go-builtins/">https://book.gofarsi.ir/chapter-1/go-builtins/&lt;/a>&lt;/p>
&lt;br/>
&lt;h2 id="177-کلوژرfunction-closure">
1.7.7 کلوژر(Function closure)
&lt;a class="anchor" href="#177-%da%a9%d9%84%d9%88%da%98%d8%b1function-closure">#&lt;/a>
&lt;/h2>
&lt;p>یک نوع دیگری از anonymous function ها در زبان گولنگ، کلوژر ها هستند. به بیان ساده زمانی که یک فانکشن درون خودش، متغیر هایی که اسکوپ آنها خارج از اسکوپ خودش قرار دارد استفاده کند. کلوژر میگوییم.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
number := 1
func() {
fmt.Println(number * 2)
}()
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در مثال بالا ما یک anonymous function داریم که درون خودش از متغیر اسکوپی که خارج از خودش قرار دارد استفاده کرده است. به این عمل کلوژر می گوییم.&lt;/p>
&lt;p>زمانی که از کلوژر ها استفاده می کنید. برخی مواقع بهتر است به‌جای اینکه به‌صورت مستقیم به متغیر اسکوپ خارجی دسترسی داشته باشید، در پارامتر های ورودی مقدار را دریافت کنید. به مثال زیر دقت کنید(در این مثال از concurrency استفاده کردیم. اگر آشنایی ندارید با مطالعه مقدمه ای از فصل سوم مثال را متوجه می شوید)&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"fmt"
"time"
)
func main() {
for i := 0; i &lt; 10; i++ {
go func() {
fmt.Println(i)
}()
}
time.Sleep(time.Second * 1)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>خروجی کد برخلاف چیزی که تصور می کنیم به این شکل است:&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go run main.go
4
9
5
6
7
8
1
0
2
3
&lt;/code>&lt;/pre>
&lt;p>این اتفاق به این دلیل می افتد چون کلوژر ها به‌صورت مستقیم به مقدار اسکوپ بالایی خود دسترسی دارند. قبل از اینکه گوروتین ها مقدار را چاپ کنند حلقه به انتها می رسد و مقدار i برابر با 10 می شود. برای همین در خروجی همه گوروتین ها مقدار 10 چاپ می شود.
برای حل این مشکل مقدار i را در پارامتر فانکشن دریافت می کنیم:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"fmt"
"time"
)
func main() {
for i := 0; i &lt; 10; i++ {
go func(num int) {
fmt.Println(num)
}(i)
}
time.Sleep(time.Second * 1)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>پس زمانی که از کلوژر ها استفاده می کنید به این نکات دقت کنید.&lt;/p></description></item><item><author/><title>1.8 آرایه و slice</title><link>https://book.gofarsi.ir/chapter-1/go-array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-1/go-array/</guid><description>&lt;p>&lt;span class="tooltip" data-tooltip="array" ontouchend="toggleTooltip(this)">آرایه&lt;/span>
و slice دو نوع تایپ با یک وجه اشتراک در زبان گو هستند ولی این دو نوع تایپ یکسری تفاوت‌هایی نیز با هم دارند که در ادامه به آن‌ها می‌پردازیم.&lt;/p>
&lt;h2 id="181-تعریف-آرایه">
1.8.1 تعریف آرایه
&lt;a class="anchor" href="#181-%d8%aa%d8%b9%d8%b1%db%8c%d9%81-%d8%a2%d8%b1%d8%a7%db%8c%d9%87">#&lt;/a>
&lt;/h2>
&lt;p>&lt;span class="tooltip" data-tooltip="array" ontouchend="toggleTooltip(this)">آرایه&lt;/span>
یکی از عمومی‌ترین تایپ‌ها در زبان‌های برنامه‌نویسی آرایه‌ها هستند که برای نگه داری گروهی مقادیر از یک نوع تایپ استفاده می‌شود.
برای دسترسی به هر کدام از مقادیر درون آرایه باید از &lt;span class="tooltip" data-tooltip="Index" ontouchend="toggleTooltip(this)">اندیس&lt;/span>
استفاده کرد.
معمولا برای تعریف آرایه تعداد مشخص و ثابتی را برای تعداد مقادیر مشخص میکنید. یعنی این آرایه قرار است چند تا مقدار نگه داری کند.&lt;/p>
&lt;p>&lt;img src="../../assets/img/content/chapter1/array-slice/1.png" alt="array" />&lt;/p>
&lt;p>در مثال زیر یک نمونه کد در خصوص چگونگی تعریف &lt;span class="tooltip" data-tooltip="array" ontouchend="toggleTooltip(this)">آرایه&lt;/span>
قرار داده‌ایم :&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
arrayInts := [5]int{1, 25, 12354, 654, 32}
fmt.Println(arrayInts)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;ol>
&lt;li>یک متغیر کوتاه از نوع آرایه با نام &lt;strong>arrayInts&lt;/strong> تعریف کردیم.&lt;/li>
&lt;li>ظرفیت آرایه را با عدد &lt;strong>۵&lt;/strong> تعیین کردیم (یعنی این آرایه فقط ۵ تا مقدار بیشتر نگه داری نمی‌کند)&lt;/li>
&lt;li>سپس تایپ آرایه را از نوع &lt;strong>int&lt;/strong> مشخص کردیم.&lt;/li>
&lt;li>در نهایت در همانجا آرایه را مقدار دهی کردیم. در زبان گو مقدار دهی با باز کردن &lt;code>{}&lt;/code> به انگلیسی &lt;code>curly bracket&lt;/code> انجام می‌شود.&lt;/li>
&lt;/ol>
&lt;h2 id="182-مفهوم-اندازه-و-ظرفیت-size-capacity">
1.8.2 مفهوم اندازه و ظرفیت (size, capacity)
&lt;a class="anchor" href="#182-%d9%85%d9%81%d9%87%d9%88%d9%85-%d8%a7%d9%86%d8%af%d8%a7%d8%b2%d9%87-%d9%88-%d8%b8%d8%b1%d9%81%db%8c%d8%aa-size-capacity">#&lt;/a>
&lt;/h2>
&lt;p>در آرایه ما ۲ تا مفهوم داریم: اندازه و ظرفیت که از عنوان این مفهوم مشخص است آرایه دارای یک اندازه و ظرفیت مشخصی است و اگر شما بیشتر از ظرفیت و اندازه تعیین شده مقدار دهی کنید با خطا مواجه خواهید شد.&lt;/p>
&lt;blockquote class="book-hint info">
در آرایه ظرفیت به نسبت اندازه تعیین می‌شود.
&lt;/blockquote>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
arrayString := [3]string{"a", "b", "c", "d"}
fmt.Println(arrayString)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در کد فوق ما یک آرایه با اندازه ۳ تعریف کردیم و ۴ تا مقدار داخلش قرار دادیم و پس از اجرا, با خطای &lt;code>تعداد مقادیر بیشتر از اندازه و ظرفیت می باشد&lt;/code> مواجه شدیم.&lt;/p>
&lt;h3 id="1821-تابع-len-و-cap">
1.8.2.1 تابع len و cap
&lt;a class="anchor" href="#1821-%d8%aa%d8%a7%d8%a8%d8%b9-len-%d9%88-cap">#&lt;/a>
&lt;/h3>
&lt;p>برای آرایه و slice ما ۲ تا تابع داریم که می‌توانیم اندازه و ظرفیت یک آرایه یا slice را بگیریم.&lt;/p>
&lt;ul>
&lt;li>تابع &lt;strong>len&lt;/strong> یکی از توابع بسیار کاربردی و پراستفاده هنگام کار با آرایه یا slice است که می‌توانید اندازه آرایه یا slice را بگیرید.&lt;/li>
&lt;li>تابع &lt;strong>cap&lt;/strong> ظرفیت آرایه و slice را نمایش می‌دهد.&lt;/li>
&lt;/ul>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
arrayString := [3]string{"a", "b", "c"}
fmt.Printf("array %v, len %d, cap %d", arrayString, len(arrayString), cap(arrayString))
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;h2 id="183-تعریف-آرایه-و-مقدارهی">
1.8.3 تعریف آرایه و مقدارهی
&lt;a class="anchor" href="#183-%d8%aa%d8%b9%d8%b1%db%8c%d9%81-%d8%a2%d8%b1%d8%a7%db%8c%d9%87-%d9%88-%d9%85%d9%82%d8%af%d8%a7%d8%b1%d9%87%db%8c">#&lt;/a>
&lt;/h2>
&lt;p>در مثال زیر ما یک آرایه با مقدار 5 تعریف کردیم و قصد داریم در ادامه کد، آرایه رو مقداردهی کنیم.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
nums := [5]int{}
fmt.Printf("array nums values %v, len %d, cap %d", nums, len(nums), cap(nums))
nums[0] = 1
nums[1] = 2
nums[2] = 10
nums[4] = 999
fmt.Println("")
fmt.Printf("array nums values %v, len %d, cap %d", nums, len(nums), cap(nums))
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>&lt;img src="../../assets/img/content/chapter1/array-slice/2.png" alt="array" />&lt;/p>
&lt;ol>
&lt;li>در کد فوق در ابتدا ما یک آرایه بدون مقدار تعریف کردیم.&lt;/li>
&lt;li>سپس با استفاده از &lt;span class="tooltip" data-tooltip="Index" ontouchend="toggleTooltip(this)">اندیس&lt;/span>
مقدار را در خانه مشخص قرار دادیم.&lt;/li>
&lt;/ol>
&lt;h3 id="1831-تعریف-آرایه-با-اندازه-تعیین-شده-توسط-کامپایلر-شما-اندازه-رو-بهش-نمیدین">
1.8.3.1 تعریف آرایه با اندازه تعیین شده توسط کامپایلر &lt;code>(شما اندازه رو بهش نمیدین.)&lt;/code>
&lt;a class="anchor" href="#1831-%d8%aa%d8%b9%d8%b1%db%8c%d9%81-%d8%a2%d8%b1%d8%a7%db%8c%d9%87-%d8%a8%d8%a7-%d8%a7%d9%86%d8%af%d8%a7%d8%b2%d9%87-%d8%aa%d8%b9%db%8c%db%8c%d9%86-%d8%b4%d8%af%d9%87-%d8%aa%d9%88%d8%b3%d8%b7-%da%a9%d8%a7%d9%85%d9%be%d8%a7%db%8c%d9%84%d8%b1-%d8%b4%d9%85%d8%a7-%d8%a7%d9%86%d8%af%d8%a7%d8%b2%d9%87-%d8%b1%d9%88-%d8%a8%d9%87%d8%b4-%d9%86%d9%85%db%8c%d8%af%db%8c%d9%86">#&lt;/a>
&lt;/h3>
&lt;p>شما در زبان گو می‌توانید با استفاده از &lt;code>...&lt;/code> &lt;code>(Ellipsis)&lt;/code> یک آرایه با اندازه مشخص شده توسط کامپایلر تعریف کنید.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
nums := [...]int{1, 25, 45, 8797, 78, 879, 541, 11}
fmt.Printf("array nums values %v, len %d, cap %d", nums, len(nums), cap(nums))
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;blockquote class="book-hint danger">
توجه کنید زمانی که &lt;code>...&lt;/code> &lt;code>(Ellipsis)&lt;/code> برای تعریف آرایه استفاده می‌کنید فقط در همان لحظه تعریف می‌توانید آرایه رو مقدار دهی کنید.
&lt;/blockquote>
&lt;h3 id="1832-تعریف-آرایه-دو-بعدی-یا-چند-بعدی">
1.8.3.2 تعریف آرایه دو بعدی یا چند بعدی
&lt;a class="anchor" href="#1832-%d8%aa%d8%b9%d8%b1%db%8c%d9%81-%d8%a2%d8%b1%d8%a7%db%8c%d9%87-%d8%af%d9%88-%d8%a8%d8%b9%d8%af%db%8c-%db%8c%d8%a7-%da%86%d9%86%d8%af-%d8%a8%d8%b9%d8%af%db%8c">#&lt;/a>
&lt;/h3>
&lt;p>در زبان گو همانند سایر زبان‌ها می‌توانید آرایه دو بعدی یا چند بعدی تعریف کنید. این نوع آرایه‌ها برای پیاده‌سازی ماتریس یا یکسری سناریوهای توسعه کاربردی مناسب هستند.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
nums := [2][2][2]int{{{1, 2}, {2, 3}}, {{4, 5}, {6, 7}}}
fmt.Printf("array nums values %v, len %d, cap %d", nums, len(nums), cap(nums))
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>&lt;img src="../../assets/img/content/chapter1/array-slice/3.png" alt="array" />&lt;/p>
&lt;h3 id="1833-مقایسه-آرایهها">
1.8.3.3 مقایسه آرایه‌ها
&lt;a class="anchor" href="#1833-%d9%85%d9%82%d8%a7%db%8c%d8%b3%d9%87-%d8%a2%d8%b1%d8%a7%db%8c%d9%87%d9%87%d8%a7">#&lt;/a>
&lt;/h3>
&lt;p>در کد زیر ما یک نمونه از مقایسه آرایه‌ها را قرار داده‌ایم که این مقایسه براساس تایپ، اندازه و مقادیر در نظر گرفته شده است.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
nums := [2]int{1, 2}
nums2 := [2]int{1, 3}
nums3 := [2]int{1, 2}
nums4 := [3]int{1, 2, 3}
chars := [2]string{"a", "b"}
fmt.Println(nums == nums2) // false
fmt.Println(nums == nums3) // true
fmt.Println(nums == nums4) // error: invalid operation: nums == nums4 (mismatched types [2]int and [3]int)
fmt.Println(nums == chars) // error: invalid operation: nums == chars (mismatched types [2]int and [2]string)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;h2 id="184-برش-slice">
1.8.4 برش (slice)
&lt;a class="anchor" href="#184-%d8%a8%d8%b1%d8%b4-slice">#&lt;/a>
&lt;/h2>
&lt;p>همانطور که می‌دانید آرایه یکی از مهم‌ترین عناوین در زبان‌های برنامه‌نویسی است، اما در زبان گو slice نسبت به آرایه بسیار پر استفاده و کاربردی‌تر است. اگر بخواهیم خیلی ساده slice را توصیف کنیم در واقع &amp;ldquo;یک slice به عنوان یک بخش بهم پیوسته از یک آرایه تعریف می‌شود که شما می‌توانید المنت‌ها را در حال اجرا افزایش یا کاهش دهید بدون آنکه ظرفیت و اندازه آن را مشخص کنید.&amp;rdquo;&lt;/p>
&lt;p>اما این سوال پیش می‌آید علت اینکه slice به نسبت آرایه کاربرد بیشتری دارد چیست؟
آرایه دارای برخی از محدودیت‌ها علی الخصوص، اندازه ثابت می‌باشد اما در slice شما این محدودیت‌ها را نخواهید داشت و خیلی ساده می‌توانید المنت‌ها را افزایش، حذف و حتی کپی کنید.&lt;/p>
&lt;blockquote class="book-hint info">
در زبان گو slice‌ها یک پارچگی آرایه را حفظ می‌کنند و کار با آرایه خیلی ساده و آسان‌تر خواهد شد.
&lt;/blockquote>
&lt;p>&lt;img src="../../assets/img/content/chapter1/array-slice/4.png" alt="slice" />&lt;/p>
&lt;h3 id="1841-تعریف-یک-slice-با-اندازه-مشخص">
1.8.4.1 تعریف یک slice با اندازه مشخص
&lt;a class="anchor" href="#1841-%d8%aa%d8%b9%d8%b1%db%8c%d9%81-%db%8c%da%a9-slice-%d8%a8%d8%a7-%d8%a7%d9%86%d8%af%d8%a7%d8%b2%d9%87-%d9%85%d8%b4%d8%ae%d8%b5">#&lt;/a>
&lt;/h3>
&lt;p>شما می توانید با استفاده از تابع &lt;code>make&lt;/code> یک slice با اندازه مشخص تعریف کنید.&lt;/p>
&lt;p>&lt;img src="../../assets/img/content/chapter1/array-slice/5.png" alt="slice" />&lt;/p>
&lt;pre>&lt;code class="language-go">slice := make([]int, 5)
fmt.Println(len(slice)) // Print 5
fmt.Println(cap(slice)) // Print 5
&lt;/code>&lt;/pre>
&lt;h3 id="1842-تعریف-یک-slice-با-اندازه-و-ظرفیت-مشخص">
1.8.4.2 تعریف یک slice با اندازه و ظرفیت مشخص
&lt;a class="anchor" href="#1842-%d8%aa%d8%b9%d8%b1%db%8c%d9%81-%db%8c%da%a9-slice-%d8%a8%d8%a7-%d8%a7%d9%86%d8%af%d8%a7%d8%b2%d9%87-%d9%88-%d8%b8%d8%b1%d9%81%db%8c%d8%aa-%d9%85%d8%b4%d8%ae%d8%b5">#&lt;/a>
&lt;/h3>
&lt;p>شما می‌توانید با استفاده از تابع &lt;code>make&lt;/code> یک slice با ظرفیت و اندازه مشخص تعریف کنید.&lt;/p>
&lt;p>&lt;img src="../../assets/img/content/chapter1/array-slice/6.png" alt="slice" />&lt;/p>
&lt;pre>&lt;code class="language-go">slice := make([]int, 3, 5)
fmt.Println(len(slice)) // Print 3
fmt.Println(cap(slice)) // Print 5
&lt;/code>&lt;/pre>
&lt;blockquote class="book-hint warning">
&lt;p>توجه کنید مقدار ظرفیت نباید کمتر از مقدار اندازه باشد.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
&lt;p>import &amp;ldquo;fmt&amp;rdquo;&lt;/p>
&lt;p>func main() {
test := make([]int, 5, 4)
fmt.Println(test)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>&lt;/p>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;/blockquote>
&lt;h3 id="1843-تعریف-یک-slice-با-متغیر-کوتاه-short-variable-declaration">
1.8.4.3 تعریف یک slice با متغیر کوتاه &lt;code>short variable declaration&lt;/code>
&lt;a class="anchor" href="#1843-%d8%aa%d8%b9%d8%b1%db%8c%d9%81-%db%8c%da%a9-slice-%d8%a8%d8%a7-%d9%85%d8%aa%d8%ba%db%8c%d8%b1-%da%a9%d9%88%d8%aa%d8%a7%d9%87-short-variable-declaration">#&lt;/a>
&lt;/h3>
&lt;p>شما خیلی ساده می‌توانید یک slice را توسط متغیر کوتاه ایجاد کنید.&lt;/p>
&lt;pre>&lt;code class="language-go">slice := []string{&amp;quot;Red&amp;quot;, &amp;quot;Blue&amp;quot;, &amp;quot;Green&amp;quot;, &amp;quot;Yellow&amp;quot;, &amp;quot;Pink&amp;quot;}
fmt.Println(len(slice)) //Print 5
fmt.Println(cap(slice)) //Print 5
intSlice:= []int{10, 20, 30}
fmt.Println(len(intSlice)) //Print 3
fmt.Println(cap(intSlice)) //Print 3
&lt;/code>&lt;/pre>
&lt;h3 id="1844-تعریف-یک-slice-با-موقعیتهای-شاخص">
1.8.4.4 تعریف یک slice با موقعیت‌های شاخص
&lt;a class="anchor" href="#1844-%d8%aa%d8%b9%d8%b1%db%8c%d9%81-%db%8c%da%a9-slice-%d8%a8%d8%a7-%d9%85%d9%88%d9%82%d8%b9%db%8c%d8%aa%d9%87%d8%a7%db%8c-%d8%b4%d8%a7%d8%ae%d8%b5">#&lt;/a>
&lt;/h3>
&lt;p>شما می‌توانید یک slice را با موقعیت‌های شاخص ایجاد کنید که n تا المنت با مقدار پیش‌فرض ایجاد می‌کند و در آخر x را به آخر slice اضافه می‌کند. &lt;code>(در مثال زیر ۹۹ تا المنت با مقدار 0 و در اخر یک المنت با مقدار 88)&lt;/code> درست می‌کند.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
test := []int{99: 88}
fmt.Println(len(test), cap(test))
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>&lt;img src="../../assets/img/content/chapter1/array-slice/7.png" alt="slice" />&lt;/p>
&lt;h3 id="1845-تعریف-یک-slice-خالی">
1.8.4.5 تعریف یک slice خالی
&lt;a class="anchor" href="#1845-%d8%aa%d8%b9%d8%b1%db%8c%d9%81-%db%8c%da%a9-slice-%d8%ae%d8%a7%d9%84%db%8c">#&lt;/a>
&lt;/h3>
&lt;p>شما می‌توانید خیلی ساده یک slice خالی ایجاد کنید.&lt;/p>
&lt;pre>&lt;code class="language-go">sliceOne := make([]int, 0)
sliceTwo := []int{}
fmt.Println(sliceOne == nil) // print false
fmt.Println(len(sliceOne)) // print 0
fmt.Println(cap(sliceOne)) // print 0
fmt.Println(sliceTwo == nil) // print false
fmt.Println(len(sliceTwo)) // print 0
fmt.Println(cap(sliceTwo)) // print 0
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="../../assets/img/content/chapter1/array-slice/8.png" alt="slice" />&lt;/p>
&lt;h2 id="185-مقدار-دهی-مجدد-یکی-از-المنت-های-slice-یا-آرایه">
1.8.5 مقدار دهی مجدد یکی از المنت های slice یا آرایه
&lt;a class="anchor" href="#185-%d9%85%d9%82%d8%af%d8%a7%d8%b1-%d8%af%d9%87%db%8c-%d9%85%d8%ac%d8%af%d8%af-%db%8c%da%a9%db%8c-%d8%a7%d8%b2-%d8%a7%d9%84%d9%85%d9%86%d8%aa-%d9%87%d8%a7%db%8c-slice-%db%8c%d8%a7-%d8%a2%d8%b1%d8%a7%db%8c%d9%87">#&lt;/a>
&lt;/h2>
&lt;p>شما خیلی راحت می‌توانید مقدار یکی از المنت‌های slice یا آرایه را مقدار دهی کنید.&lt;/p>
&lt;pre>&lt;code class="language-go">slice := []int{10, 20, 30, 40}
fmt.Println(slice) //print [10 20 30 40]
slice[1] = 25
fmt.Println(slice) // print [10 25 30 40]
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="../../assets/img/content/chapter1/array-slice/9.png" alt="slice" />&lt;/p>
&lt;h2 id="186-ایجاد-یک-slice-جدید-بر-اساس-یک-slice-از-پیش-تعریف-شده">
1.8.6 ایجاد یک slice جدید بر اساس یک slice از پیش تعریف شده
&lt;a class="anchor" href="#186-%d8%a7%db%8c%d8%ac%d8%a7%d8%af-%db%8c%da%a9-slice-%d8%ac%d8%af%db%8c%d8%af-%d8%a8%d8%b1-%d8%a7%d8%b3%d8%a7%d8%b3-%db%8c%da%a9-slice-%d8%a7%d8%b2-%d9%be%db%8c%d8%b4-%d8%aa%d8%b9%d8%b1%db%8c%d9%81-%d8%b4%d8%af%d9%87">#&lt;/a>
&lt;/h2>
&lt;p>شما می‌توانید یک slice جدید را بر اساس یک slice از پیش تعریف شده ایجاد کنید.&lt;/p>
&lt;pre>&lt;code class="language-go">x := []int{10, 20, 30, 40, 50}
fmt.Println(x) // Print [10 20 30 40 50]
fmt.Println(len(x)) // Print 5
fmt.Println(cap(x)) // Print 5
y := x[1:3]
fmt.Println(y) //Print [20 30]
fmt.Println(len(y)) //Print 2
fmt.Println(cap(y)) //Print 4
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="../../assets/img/content/chapter1/array-slice/10.png" alt="slice" />&lt;/p>
&lt;ul>
&lt;li>ما یک متغیر با نام &lt;code>x&lt;/code> با ۵ تا المنت مقدار دهی شده تعریف کردیم.&lt;/li>
&lt;li>سپس یک متغیر کوتاه با نام y تعریف کردیم که متغیر x را داخلش قرار دادیم.&lt;/li>
&lt;li>سپس به متغیر x گفتیم از اندیس ۱ تا ۳ را به y اختصاص بدهد.&lt;/li>
&lt;/ul>
&lt;blockquote class="book-hint info">
&lt;p>توجه کنید اتفاقی که مثال بالا رخ داد این بود که ما اندازه و ظرفیت جدیدی برای متغیر y تعیین کردیم.&lt;/p>
&lt;p>Len: 3 - 1 = 2
Cap: 5 - 1 = 4&lt;/p>
&lt;/blockquote>
&lt;h2 id="187-خطای-index-out-of-range-در-slice">
1.8.7 خطای index out of range در slice
&lt;a class="anchor" href="#187-%d8%ae%d8%b7%d8%a7%db%8c-index-out-of-range-%d8%af%d8%b1-slice">#&lt;/a>
&lt;/h2>
&lt;p>یک slice فقط با توجه به اندازه و اندیس‌هایش امکان دسترسی و مقدار دهی مجدد المنت هایش را می‌دهد، اما اگر شما بخواهید خارج از اندازه تعیین شده جهت مقداری دهی و یا دسترسی به slice اقدام کنید با خطای index out of range مواجه خواهید شد.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
slice := []int{10, 20, 30, 40, 50}
newSlice := slice[1:3]
newSlice[3] = 45
fmt.Println(newSlice)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;h2 id="188-افرودن-append-المنتهای-یک-slice">
1.8.8 افرودن (append) المنت‌های یک slice
&lt;a class="anchor" href="#188-%d8%a7%d9%81%d8%b1%d9%88%d8%af%d9%86-append-%d8%a7%d9%84%d9%85%d9%86%d8%aa%d9%87%d8%a7%db%8c-%db%8c%da%a9-slice">#&lt;/a>
&lt;/h2>
&lt;p>شما خیلی ساده می‌توانید با استفاده از تابع &lt;code>append&lt;/code> به المنت‌های یک slice بیفزایید.&lt;/p>
&lt;pre>&lt;code class="language-go">slice := []int{10, 20, 30, 40, 50}
newSlice := slice[1:3]
fmt.Println(len(newSlice)) // Print 2
fmt.Println(cap(newSlice)) // Print 4
newSlice = append(newSlice, 60)
fmt.Println(len(newSlice)) // Print 3
fmt.Println(cap(newSlice)) // Print 4
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="../../assets/img/content/chapter1/array-slice/11.png" alt="slice" />&lt;/p>
&lt;blockquote class="book-hint info">
&lt;p>در کد زیر اتفاقی که صورت گرفته است این است که اگر شما &lt;code>...&lt;/code> &lt;code>Ellipsis&lt;/code> را بعد از کلمه slice بزارید یعنی دارید می‌گید تمامی المنت‌های داخل slice به newSlice اضافه شود.&lt;/p>
&lt;pre>&lt;code class="language-go">slice := []int{10, 20, 30, 40, 50}
newSlice := []int{}
newSlice = append(newSlice, slice...)
&lt;/code>&lt;/pre>
&lt;/blockquote>
&lt;h2 id="189-نحوه-حذف-یک-المنت-در-slice">
1.8.9 نحوه حذف یک المنت در slice
&lt;a class="anchor" href="#189-%d9%86%d8%ad%d9%88%d9%87-%d8%ad%d8%b0%d9%81-%db%8c%da%a9-%d8%a7%d9%84%d9%85%d9%86%d8%aa-%d8%af%d8%b1-slice">#&lt;/a>
&lt;/h2>
&lt;p>برای حذف یک المنت در slice باید بصورت تکنیکی اینکار را انجام دهید چون زبان گو یک روش built-in برای این کار ندارد.&lt;/p>
&lt;p>&lt;img src="../../assets/img/content/chapter1/array-slice/12.png" alt="slice" />&lt;/p>
&lt;ul>
&lt;li>در این روش شما باید در ابتدا آخرین المنت را به المنت مورد نظر با استفاده از اندیس کپی کنید.&lt;/li>
&lt;li>سپس آخرین المنت را از slice حذف کنید.&lt;/li>
&lt;/ul>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
slice := []int{10, 20, 30, 40, 50}
slice[1] = slice[len(slice)-1]
slice = slice[:len(slice)-1]
fmt.Println(slice)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;ul>
&lt;li>یک روش دیگر برای حذف یک المنت از slice استفاده از تابع &lt;code>append&lt;/code> است.&lt;/li>
&lt;li>به مثال زیر توجه کنید.&lt;/li>
&lt;/ul>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
slice := []int{1, 2, 3, 4, 5}
index := 2 // ایندکس المنتی که میخاییم حذفش کنیم
slice = append(slice[:index], slice[index+1:]...)
fmt.Println(slice) // خروجی: [1 2 4 5]
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;h2 id="1810-تابع-copy-در-slice">
1.8.10 تابع copy در slice
&lt;a class="anchor" href="#1810-%d8%aa%d8%a7%d8%a8%d8%b9-copy-%d8%af%d8%b1-slice">#&lt;/a>
&lt;/h2>
&lt;p>شما با استفاده از تابع &lt;code>copy&lt;/code> می‌توانید یک slice را به slice دیگری کپی کنید.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
src := []int{1, 2, 3, 4, 5}
dst := make([]int, 5)
numberOfElementsCopied := copy(dst, src)
fmt.Println(numberOfElementsCopied, dst)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;h2 id="1811-نحوه-مرتب-کردن-sort-یک-slice">
1.8.11 نحوه مرتب کردن (sort) یک slice
&lt;a class="anchor" href="#1811-%d9%86%d8%ad%d9%88%d9%87-%d9%85%d8%b1%d8%aa%d8%a8-%da%a9%d8%b1%d8%af%d9%86-sort-%db%8c%da%a9-slice">#&lt;/a>
&lt;/h2>
&lt;p>برای مرتب کردن یک slice می‌توانید از توابع کتابخانه sort در زبان گو استفاده کنید.&lt;/p>
&lt;ul>
&lt;li>&lt;code>sort.Ints&lt;/code>&lt;/li>
&lt;li>&lt;code>sort.Float64s&lt;/code>&lt;/li>
&lt;li>&lt;code>sort.Strings&lt;/code>&lt;/li>
&lt;/ul>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"fmt"
"sort"
)
func main() {
s := []int{4, 2, 3, 1}
sort.Ints(s)
fmt.Println(s)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;h2 id="1812-فرق-بین-آرایه-و-slice">
1.8.12 فرق بین آرایه و slice
&lt;a class="anchor" href="#1812-%d9%81%d8%b1%d9%82-%d8%a8%db%8c%d9%86-%d8%a2%d8%b1%d8%a7%db%8c%d9%87-%d9%88-slice">#&lt;/a>
&lt;/h2>
&lt;ol>
&lt;li>فرق نوع تعریف آرایه و slice
&lt;ul>
&lt;li>برای تعریف آرایه شما باید داخل براکت [] یک مقداری را قرار دهید.&lt;/li>
&lt;li>برای تعریف slice هیچ مقداری را داخل براکت [] نباید قرار دهید.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-go">array := [3]int{10, 20, 30}
slice := []int{10, 20, 30}
&lt;/code>&lt;/pre>
&lt;ol start="2">
&lt;li>فرق بین مقدار صفر آرایه و slice
&lt;ul>
&lt;li>مقدار خالی slice ها nil است.&lt;/li>
&lt;li>مقدار خالی یک آرایه، همان آرایه با المنت‌های مقدار پیش‌فرض است.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-go">var slice []int32
var array [2]int32
fmt.Println(slice == nil) // print true
fmt.Println(len(slice)) // print 0
fmt.Println(cap(slice)) // print 0
fmt.Println(array) // print [0 0]
&lt;/code>&lt;/pre></description></item><item><author/><title>1.9 حلقه‌ها (for)</title><link>https://book.gofarsi.ir/chapter-1/go-for/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-1/go-for/</guid><description>&lt;h2 id="191-حلقه">
1.9.1 حلقه
&lt;a class="anchor" href="#191-%d8%ad%d9%84%d9%82%d9%87">#&lt;/a>
&lt;/h2>
&lt;p>حلقه‌ها را در زبان گو به ساده‌ترین شکل ممکن و فقط با استفاده از کلید واژه for و در مدل‌های مختلف (سه‌بخشی، بی نهایت، foreach و &amp;hellip;) می‌توان پیاده‌سازی کرد.&lt;/p>
&lt;h2 id="192-حلقه-سه-بخشی">
1.9.2 حلقه سه بخشی
&lt;a class="anchor" href="#192-%d8%ad%d9%84%d9%82%d9%87-%d8%b3%d9%87-%d8%a8%d8%ae%d8%b4%db%8c">#&lt;/a>
&lt;/h2>
&lt;p>این نمونه که متداول‌ترین نوع حلقه &lt;code>for&lt;/code> نیز هستند با استفاده از سه‌ بخش:&lt;/p>
&lt;ul>
&lt;li>مقداردهی&lt;/li>
&lt;li>شرط&lt;/li>
&lt;li>شمارنده&lt;/li>
&lt;/ul>
&lt;p>ایجاد می‌شوند.&lt;/p>
&lt;pre>&lt;code class="language-go">for initialization ; condition ; counter {
//loop codes
}
&lt;/code>&lt;/pre>
&lt;p>در مثال زیر نمونه‌ای از این حلقه‌ قابل مشاهده و اجرا است.
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
sum := 0
for i := 1; i &lt; 10; i++ {
sum += i
}
fmt.Println(sum)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;/p>
&lt;h2 id="193-حلقه-while">
1.9.3 حلقه while
&lt;a class="anchor" href="#193-%d8%ad%d9%84%d9%82%d9%87-while">#&lt;/a>
&lt;/h2>
&lt;p>این مدل حلقه شبیه while در بیشتر زبان ها مثل پایتون و C است. با این تفاوت که پیاده‌سازی آن، تنها با کلیدواژه‌ی &lt;code>for&lt;/code> و با حذف بخش مقداردهی و شمارنده حلقه سه‌بخشی انجام می‌گیرد. در واقع در این حلقه تنها یک شرط تعریف می‌شود و تا برقرار بودن آن شرط حلقه اجرا می‌شود. به مثال زیر توجه کنید:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
i := 0
for i &lt; 10 {
fmt.Println(i)
i++
}
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;h2 id="194-حلقه-بینهایت">
1.9.4 حلقه بی‌نهایت
&lt;a class="anchor" href="#194-%d8%ad%d9%84%d9%82%d9%87-%d8%a8%db%8c%d9%86%d9%87%d8%a7%db%8c%d8%aa">#&lt;/a>
&lt;/h2>
&lt;p>اگر از حلقه‌ی &lt;code>while&lt;/code> که در مثال بالا تعریف کردیم بخش شرط را حذف کنیم چه اتفاقی می‌افتد؟ در این حالت ما یک شرط بی نهایت ساخته‌ایم (شبیه به while(1)) که تا زمانی‌ که برنامه متوقف نشود و یا کدهای داخل حلقه، فرمان خروج از حلقه را ندهند، چرخه ی اجرای حلقه ادامه خواهد یافت.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
sum := 0
for {
sum++
}
fmt.Println("this line will never execute")
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>با اجرای کد بالا خطای تایم‌اوت دریافت خواهید کرد &lt;code>(اگر در playground سایت گو اجراش کنین)&lt;/code>، به‌ دلیل اینکه حلقه هیچ‌گاه تمام نمی‌شود.&lt;/p>
&lt;h2 id="195-حلقه-for-range">
1.9.5 حلقه for-range
&lt;a class="anchor" href="#195-%d8%ad%d9%84%d9%82%d9%87-for-range">#&lt;/a>
&lt;/h2>
&lt;p>حلقه for-range یکی از پرکاربردترین حلقه‌ها در زبان گو می‌باشد که شما می‌توانید برای slice، آرایه و map یا رشته از این حلقه استفاده کنید.&lt;/p>
&lt;pre>&lt;code class="language-go">for index, value := range slice/array {}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-go">for key, value := range map {}
&lt;/code>&lt;/pre>
&lt;h3 id="1951-حلقه-for-range-برای-slice-و-آرایه">
1.9.5.1 حلقه for-range برای slice و آرایه
&lt;a class="anchor" href="#1951-%d8%ad%d9%84%d9%82%d9%87-for-range-%d8%a8%d8%b1%d8%a7%db%8c-slice-%d9%88-%d8%a2%d8%b1%d8%a7%db%8c%d9%87">#&lt;/a>
&lt;/h3>
&lt;p>شما با استفاده از حلقه for-range می‌توانید به المنت‌های آرایه یا slice و همچنین اندیس‌شان &lt;code>(Index)&lt;/code> دسترسی پیدا کنید. دقت کنید ۲ حالت وجود دارد:&lt;/p>
&lt;h4 id="19511-دسترسی-با-استفاده-از-یک-کپی-از-المنت">
1.9.5.1.1 دسترسی با استفاده از یک کپی از المنت
&lt;a class="anchor" href="#19511-%d8%af%d8%b3%d8%aa%d8%b1%d8%b3%db%8c-%d8%a8%d8%a7-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-%db%8c%da%a9-%da%a9%d9%be%db%8c-%d8%a7%d8%b2-%d8%a7%d9%84%d9%85%d9%86%d8%aa">#&lt;/a>
&lt;/h4>
&lt;p>در کد زیر ما با استفاده از for-range به یک کپی از المنت‌های اسلایس &lt;code>letter&lt;/code> دسترسی پیدا کردیم.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
letters := []string{"a", "b", "c"}
//With index and value
fmt.Println("Both Index and Value")
for i, letter := range letters {
fmt.Printf("Index: %d Value:%s\n", i, letter)
}
//Only value
fmt.Println("\nOnly value")
for _, letter := range letters {
fmt.Printf("Value: %s\n", letter)
}
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;h4 id="19512-دسترسی-مستقیم-به-خانه-حافظه-المنت">
1.9.5.1.2 دسترسی مستقیم به خانه حافظه المنت
&lt;a class="anchor" href="#19512-%d8%af%d8%b3%d8%aa%d8%b1%d8%b3%db%8c-%d9%85%d8%b3%d8%aa%d9%82%db%8c%d9%85-%d8%a8%d9%87-%d8%ae%d8%a7%d9%86%d9%87-%d8%ad%d8%a7%d9%81%d8%b8%d9%87-%d8%a7%d9%84%d9%85%d9%86%d8%aa">#&lt;/a>
&lt;/h4>
&lt;p>شما با استفاده از اندیس (index) می‌توانید مستقیماً به خانه حافظه المنت دسترسی پیدا کنید و آن المنت رو با استفاده از اندیس &lt;code>(Index)&lt;/code> نمایش بدید. به مثال زیر توجه کنید:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
letters := []string{"a", "b", "c"}
fmt.Println("\nOnly letter")
for i := range letters {
fmt.Printf("letter: %s\n", letters[i])
}
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;h3 id="1912-حلقه-for-range-برای-map">
1.9.1.2 حلقه for-range برای map
&lt;a class="anchor" href="#1912-%d8%ad%d9%84%d9%82%d9%87-for-range-%d8%a8%d8%b1%d8%a7%db%8c-map">#&lt;/a>
&lt;/h3>
&lt;p>شما با استفاده از حلقه for-range برروی map, میتوانید به کلید و مقدار هر یک از مقادیر map دسترسی پیدا کنید.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
sample := map[string]string{
"a": "x",
"b": "y",
}
//Iterating over all keys and values
fmt.Println("Both Key and Value")
for k, v := range sample {
fmt.Printf("key :%s value: %s\n", k, v)
}
//Iterating over only keys
fmt.Println("\nOnly keys")
for k := range sample {
fmt.Printf("key :%s\n", k)
}
//Iterating over only values
fmt.Println("\nOnly values")
for _, v := range sample {
fmt.Printf("value :%s\n", v)
}
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;h3 id="1913-حلقه-for-range-برای-رشته-string">
1.9.1.3 حلقه for-range برای رشته (string)
&lt;a class="anchor" href="#1913-%d8%ad%d9%84%d9%82%d9%87-for-range-%d8%a8%d8%b1%d8%a7%db%8c-%d8%b1%d8%b4%d8%aa%d9%87-string">#&lt;/a>
&lt;/h3>
&lt;p>شما با استفاده از حلقه for-range می توانید به هرکدام از کارکترهای رشته دسترسی پیدا کنید.&lt;/p>
&lt;pre>&lt;code class="language-go">for index, character := range string {
//Do something with index and character
}
&lt;/code>&lt;/pre>
&lt;p>به کد نمونه زیر توجه کنید :&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
sample := "a£b"
//With index and value
fmt.Println("Both Index and Value")
for i, letter := range sample {
fmt.Printf("Start Index: %d Value:%s\n", i, string(letter))
}
//Only value
fmt.Println("\nOnly value")
for _, letter := range sample {
fmt.Printf("Value:%s\n", string(letter))
}
//Only index
fmt.Println("\nOnly Index")
for i := range sample {
fmt.Printf("Start Index: %d\n", i)
}
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;h2 id="196-کلید-واژه-break">
1.9.6 کلید واژه break
&lt;a class="anchor" href="#196-%da%a9%d9%84%db%8c%d8%af-%d9%88%d8%a7%da%98%d9%87-break">#&lt;/a>
&lt;/h2>
&lt;p>با استفاده از &lt;code>break&lt;/code> می‌توان چرخه‌ی اجرای یک حلقه را پایان داد. به عنوان مثال در حلقه بی‌نهایتی که در بخش &lt;code>1.9.4&lt;/code> مشاهده کردید، می‌توان با تعریف یک شرط خاص از حلقه خارج شد. کد زیر نمونه استفاده از &lt;code>break&lt;/code> را نمایش می‌دهد.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
sum := 0
for {
sum++
if sum == 10 {
break
}
}
fmt.Println(sum)
fmt.Println("now this line will execute")
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;h1 id="197-label-در-حلقه-ها">
1.9.7 label در حلقه ها
&lt;a class="anchor" href="#197-label-%d8%af%d8%b1-%d8%ad%d9%84%d9%82%d9%87-%d9%87%d8%a7">#&lt;/a>
&lt;/h1>
&lt;p>شما با قابلیت label در زبان گو می‌توانید لیبلی را به یک حلقه خاص اختصاص دهید و بعد از چند حلقه تو در تو حلقه مورد نظر را break کنید.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
letters := []string{"a", "b", "c"}
for i := 1; i &lt; 10; i++ {
// define a lable with name 'second' for this loop
second:
for i := 2; i &lt; 9; i++ {
for _, l := range letters {
if l == "b" {
// break the loop with second lable
break second
}
}
}
}
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در کد بالا زمانی که از لیبل استفاده نشود سومین حلقه درونی break خواهد شد.
اما با استفاده از لیبل‌ها هرکدام از حلقه‌های مورد نظر را می‌توان break کرد.&lt;/p>
&lt;h2 id="198-کلیدواژه-continue">
1.9.8 کلیدواژه continue
&lt;a class="anchor" href="#198-%da%a9%d9%84%db%8c%d8%af%d9%88%d8%a7%da%98%d9%87-continue">#&lt;/a>
&lt;/h2>
&lt;p>این کلید‌واژه چرخه‌ اجرای حلقه را یک مرحله جلو می‌برد. به این‌ معنی که اگر در حلقه از این کلید‌واژه استفاده شود، کدهای بعد از continue اجرا نشده و چرخه بعدی (گام بعدی) اجرا خواهد شد.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
for i := 1; i &lt; 10; i++ {
if i%2 == 0 {
continue
}
fmt.Println(i)
}
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;blockquote class="book-hint info">
قابل ذکر است که &lt;code>continue&lt;/code> و &lt;code>break&lt;/code> در حلقه‌های تو در تو، فقط روی اولین حلقه درونی تاثیر خواهند گذاشت.
&lt;/blockquote>
&lt;h2 id="199-خودآزمون-حلقه">
1.9.9 خودآزمون حلقه
&lt;a class="anchor" href="#199-%d8%ae%d9%88%d8%af%d8%a2%d8%b2%d9%85%d9%88%d9%86-%d8%ad%d9%84%d9%82%d9%87">#&lt;/a>
&lt;/h2>
&lt;div class="book-tabs">&lt;input type="radio" class="toggle" name="tabs-loop_exam" id="tabs-loop_exam-0" checked="checked" />
&lt;label for="tabs-loop_exam-0">سوال&lt;/label>
&lt;div class="book-tabs-content markdown-inner">&lt;p>با استفاده از زبان گو برنامه‌ای بنویسید که سری‌ زیر را ایجاد کند:&lt;/p>
&lt;pre>&lt;code class="language-bash">1
22
333
55555
88888888
13131313131313131313131313
212121212121212121212121212121212121212121
&lt;/code>&lt;/pre>&lt;/div>&lt;input type="radio" class="toggle" name="tabs-loop_exam" id="tabs-loop_exam-1" />
&lt;label for="tabs-loop_exam-1">الگوریتم پاسخ&lt;/label>
&lt;div class="book-tabs-content markdown-inner">&lt;ul>
&lt;li>‍1 + 0 = 1&lt;/li>
&lt;li>1 + 1 = 2&lt;/li>
&lt;li>2 + 1 = 3&lt;/li>
&lt;li>3 + 2 = 5&lt;/li>
&lt;li>5 + 3 = 8&lt;/li>
&lt;li>8 + 5 = 13&lt;/li>
&lt;li>13 + 8 = 21&lt;/li>
&lt;/ul>
&lt;hr>
&lt;ul>
&lt;li>a + b = c&lt;/li>
&lt;li>b = a&lt;/li>
&lt;li>a = c&lt;/li>
&lt;/ul>
&lt;hr>
&lt;/div>&lt;input type="radio" class="toggle" name="tabs-loop_exam" id="tabs-loop_exam-2" />
&lt;label for="tabs-loop_exam-2">کد پاسخ&lt;/label>
&lt;div class="book-tabs-content markdown-inner">&lt;pre>&lt;code class="language-go">package main
import &amp;quot;fmt&amp;quot;
func main() {
var (
n = 6 // can define any result count ...
a, b, c = 1, 0, 0
)
for i := 0; i &amp;lt;= n; i++ {
c = a + b
for j := 1; j &amp;lt;= c; j++ {
fmt.Print(c)
}
fmt.Println()
b, a = a, c
}
}
&lt;/code>&lt;/pre>
&lt;/div>&lt;/div></description></item><item><author/><title>1.10 نقشه map</title><link>https://book.gofarsi.ir/chapter-1/go-map/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-1/go-map/</guid><description>&lt;h2 id="1101-مقدمه">
1.10.1 مقدمه
&lt;a class="anchor" href="#1101-%d9%85%d9%82%d8%af%d9%85%d9%87">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>&lt;span class="tooltip" data-tooltip="map" ontouchend="toggleTooltip(this)">نقشه&lt;/span>
، یک نوع ساختار داده است.&lt;/li>
&lt;li>&lt;span class="tooltip" data-tooltip="map" ontouchend="toggleTooltip(this)">نقشه&lt;/span>
ها جهت جمع‌آوری و نگهداری مجموعه‌ای از داده‌ها استفاده می‌گردند.&lt;/li>
&lt;li>&lt;span class="tooltip" data-tooltip="map" ontouchend="toggleTooltip(this)">نقشه&lt;/span>
، از نوع داده‌های &lt;span class="tooltip" data-tooltip="associative data type" ontouchend="toggleTooltip(this)">انجمنی&lt;/span>
(هش) بصورت &lt;span class="tooltip" data-tooltip="key-value" ontouchend="toggleTooltip(this)">«کلید-مقدار»&lt;/span>
است.&lt;/li>
&lt;li>&lt;span class="tooltip" data-tooltip="map" ontouchend="toggleTooltip(this)">نقشه&lt;/span>
، مجموعه‌ای از داده‌ها بصورت &lt;span class="tooltip" data-tooltip="unordered key:value pairs" ontouchend="toggleTooltip(this)">جفت‌‌های مرتب‌نشده&lt;/span>
است.&lt;/li>
&lt;/ul>
&lt;h2 id="1102-تعریف">
1.10.2 تعریف
&lt;a class="anchor" href="#1102-%d8%aa%d8%b9%d8%b1%db%8c%d9%81">#&lt;/a>
&lt;/h2>
&lt;p>یک مپ شبیه به فرمت زیر است:&lt;/p>
&lt;pre>&lt;code class="language-go">map[KeyType]ValueType
&lt;/code>&lt;/pre>
&lt;p>کلمه کلیدی &lt;code>map&lt;/code> و بعد نوع کلید و در آخر هم نوع مقدار تعریف می‌شود.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>کلید: برای اشاره به یک مقدار ذخیره شده، نیاز به یک نام‌ داریم و این یعنی «کلید» آن مقدار.&lt;/p>
&lt;ul>
&lt;li>مقدار کلید در یک مپ، باید &lt;span class="tooltip" data-tooltip="unique" ontouchend="toggleTooltip(this)">یکتا&lt;/span>
باشد.&lt;/li>
&lt;li>محدودیت: برای تعریف کلید، از انواع تایپ‌هایی که &lt;span class="tooltip" data-tooltip="comparable " ontouchend="toggleTooltip(this)">قابل مقایسه&lt;/span>
هستند، می‌توان استفاده کرد:
&lt;ul>
&lt;li>Boolean(s)&lt;/li>
&lt;li>Number(s)&lt;/li>
&lt;li>String(s)&lt;/li>
&lt;li>Array(s)&lt;/li>
&lt;li>Pointer(s)&lt;/li>
&lt;li>Struct(s)&lt;/li>
&lt;li>Interface(s) (تا زمانی که از مقادیر مقایسه‌پذیر استفاده می‌کند)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>از
&lt;ul>
&lt;li>&lt;code>Slice(s)&lt;/code>&lt;/li>
&lt;li>&lt;code>Map(s)&lt;/code>&lt;/li>
&lt;li>&lt;code>Function(s)&lt;/code>
نمی‌توان برای تعریف «کلید» مپ استفاده کرد.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote class="book-hint info">
&lt;pre>&lt;code>در مپ می‌توان برای کلید از مقدار داخل یک متغیر بهره برد.
&lt;/code>&lt;/pre>
&lt;/blockquote>
&lt;/li>
&lt;/ul>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
myMap := make(map[int]string)
myKey := 13
myMap[myKey] = "thirteen"
fmt.Println(myMap) //map[13:thirteen]
fmt.Println(myMap[myKey]) //thirteen
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;ul>
&lt;li>مقدار: حاوی داده‌ای است که کلید به آن اشاره می‌کند و برخلاف کلید، هیچ محدودیت برای انتخاب «نوع» آن وجود ندارد، به‌عنوان نمونه می‌توان از یک مپ دیگر برای مقدار استفاده کرد.
(&lt;span class="tooltip" data-tooltip="Nested Map" ontouchend="toggleTooltip(this)">مپ‌های تودرتو&lt;/span>
)&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-go">map[string]map[int]string
&lt;/code>&lt;/pre>
&lt;h2 id="1103-ایجاد-و-مقداردهی-اولیه">
1.10.3 ایجاد و مقداردهی اولیه
&lt;a class="anchor" href="#1103-%d8%a7%db%8c%d8%ac%d8%a7%d8%af-%d9%88-%d9%85%d9%82%d8%af%d8%a7%d8%b1%d8%af%d9%87%db%8c-%d8%a7%d9%88%d9%84%db%8c%d9%87">#&lt;/a>
&lt;/h2>
&lt;p>مقدار پیش‌فرض برای یک مپ nil می‌باشد. برای مقداردهی مپ‌ ها از روش‌های زیر استفاده می‌شود:&lt;/p>
&lt;ul>
&lt;li>استفاده از کلمه کلیدی var&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-go">var sampleMap = map[keyType]valueType{keyName1:value1, keyName2:value2, ...}
var sampleMap map[keyType]valueType = map[keyType]valueType{}
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>استفاده از علامت &lt;code>=:&lt;/code> &lt;code>short variable declaration&lt;/code>&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-go">sampleMap := map[keyType]valueType{keyName1:value1, keyName2:value2, ...}
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>استفاده از تابع make&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-go">var sampleMap = make(map[keyType]valueType)
sampleMap := make(map[keyType]valueType)
&lt;/code>&lt;/pre>
&lt;h2 id="1104-مپ-با-مقدار-nil">
1.10.4 مپ با مقدار nil
&lt;a class="anchor" href="#1104-%d9%85%d9%be-%d8%a8%d8%a7-%d9%85%d9%82%d8%af%d8%a7%d8%b1-nil">#&lt;/a>
&lt;/h2>
&lt;p>درصورت تعریف اولیه مپ توسط دستور &lt;code>var sampleMap map[keyType]valueType&lt;/code> یک مپ با مقدار nil ساخته می‌شود که نمی‌توان بدون مقداردهی اولیه، روی آن عملیات ارسال و دریافت داده‌ انجام داد:&lt;/p>
&lt;pre>&lt;code class="language-go"> var sampleMap map[uint8]int
sampleMap[13] = 9999999
//panic: assignment to entry in nil map
&lt;/code>&lt;/pre>
&lt;p>برای مقداردهی یک مپ nil که به روش زیر ساخته اید:&lt;/p>
&lt;pre>&lt;code class="language-go">var m map[string]string
&lt;/code>&lt;/pre>
&lt;p>از روش‌های زیر می‌توان بهره گرفت:&lt;/p>
&lt;pre>&lt;code class="language-go">var m map[string]string = map[string]string{}
m := make(map[string]string)
m := map[string]string{}
&lt;/code>&lt;/pre>
&lt;h2 id="1105-توابع-مربوط-به-مپ">
1.10.5 توابع مربوط به مپ
&lt;a class="anchor" href="#1105-%d8%aa%d9%88%d8%a7%d8%a8%d8%b9-%d9%85%d8%b1%d8%a8%d9%88%d8%b7-%d8%a8%d9%87-%d9%85%d9%be">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>تابع (len):
برای برگشت تعداد عناصر داخل مپ از &lt;code>len&lt;/code> استفاده می‌شود:
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
var sampleMap = map[string]bool{}
var otherMap = make(map[string]uint)
var nilMap map[bool]bool
sampleMap["condition#1"] = true
sampleMap["condition#2"] = false
otherMap["foo"] = 1
fmt.Println(len(sampleMap)) //2
fmt.Println(len(otherMap)) //1
fmt.Println(len(nilMap)) //0 (len nil is zero)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;/li>
&lt;/ul>
&lt;p>مقدار برگشتی برای تابع len روی مپ‌ nil برابر صفر (۰) است.&lt;/p>
&lt;h2 id="1106-عملیات-crud-روی-مپ">
1.10.6 عملیات CRUD روی مپ
&lt;a class="anchor" href="#1106-%d8%b9%d9%85%d9%84%db%8c%d8%a7%d8%aa-crud-%d8%b1%d9%88%db%8c-%d9%85%d9%be">#&lt;/a>
&lt;/h2>
&lt;div class="book-tabs">&lt;input type="radio" class="toggle" name="tabs-myid" id="tabs-myid-0" checked="checked" />
&lt;label for="tabs-myid-0">C : Create&lt;/label>
&lt;div class="book-tabs-content markdown-inner">&lt;p>برای ایجاد مپ، اغلب از تابع make استفاده می شود:&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import &amp;quot;fmt&amp;quot;
func main() {
animals := make(map[int]string) // nil map of string-int pairs
animals[1] = &amp;quot;Gopher&amp;quot;
animals[2] = &amp;quot;owl&amp;quot;
animals[3] = &amp;quot;cheetah&amp;quot;
animals[4] = &amp;quot;eagle&amp;quot;
animals[5] = &amp;quot;lion&amp;quot;
fmt.Println(animals) //map[1:Gopher 2:owl 3:cheetah 4:eagle 5:lion]
}
&lt;/code>&lt;/pre>&lt;/div>&lt;input type="radio" class="toggle" name="tabs-myid" id="tabs-myid-1" />
&lt;label for="tabs-myid-1">R : Read&lt;/label>
&lt;div class="book-tabs-content markdown-inner">&lt;p>جهت خواندن مقادیر مپ می‌توان از الگوی زیر استفاده کرد:
&lt;code>mapName[&amp;quot;keyName&amp;quot;]&lt;/code>
مثال:&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import &amp;quot;fmt&amp;quot;
func main() {
animals := make(map[int]string) // nil map of string-int pairs
animals[1] = &amp;quot;Gopher&amp;quot;
animals[2] = &amp;quot;owl&amp;quot;
animals[3] = &amp;quot;cheetah&amp;quot;
animals[4] = &amp;quot;eagle&amp;quot;
animals[5] = &amp;quot;lion&amp;quot;
fmt.Println(animals[2]) //owl
}
&lt;/code>&lt;/pre>&lt;/div>&lt;input type="radio" class="toggle" name="tabs-myid" id="tabs-myid-2" />
&lt;label for="tabs-myid-2">U : Update&lt;/label>
&lt;div class="book-tabs-content markdown-inner">&lt;p>برای بروزرسانی مقادیر مپ، از الگوی
&lt;code>mapName[keyName] = newValue&lt;/code>
استفاده می‌شود.
مثال:&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import &amp;quot;fmt&amp;quot;
func main() {
animals := make(map[int]string) // nil map of string-int pairs
animals[1] = &amp;quot;Gopher&amp;quot;
animals[2] = &amp;quot;owl&amp;quot;
animals[3] = &amp;quot;cheetah&amp;quot;
animals[4] = &amp;quot;eagle&amp;quot;
animals[5] = &amp;quot;lion&amp;quot;
fmt.Println(animals[2]) //owl
animals[2] = &amp;quot;wolf&amp;quot;
fmt.Println(animals[2]) //wolf
}
&lt;/code>&lt;/pre>&lt;/div>&lt;input type="radio" class="toggle" name="tabs-myid" id="tabs-myid-3" />
&lt;label for="tabs-myid-3">D : Delete&lt;/label>
&lt;div class="book-tabs-content markdown-inner">&lt;p>جهت حذف مقادیر در مپ، از تابع &lt;code>delete&lt;/code> متعلق به پکیج &lt;code>builtin&lt;/code> استفاده می‌شود.&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import &amp;quot;fmt&amp;quot;
func main() {
animals := make(map[int]string) // nil map of string-int pairs
animals[1] = &amp;quot;Gopher&amp;quot;
animals[2] = &amp;quot;owl&amp;quot;
animals[3] = &amp;quot;cheetah&amp;quot;
animals[4] = &amp;quot;eagle&amp;quot;
animals[5] = &amp;quot;lion&amp;quot;
fmt.Println(animals) //map[1:Gopher 2:owl 3:cheetah 4:eagle 5:lion]
fmt.Println(len(animals)) //5
delete(animals, 4)
fmt.Println(animals) //map[1:Gopher 2:owl 3:cheetah 5:lion]
fmt.Println(len(animals)) //4
}
&lt;/code>&lt;/pre>
&lt;blockquote class="book-hint warning">
&lt;p>نکته: اگر کلید مورد استفاده در فانکشن &lt;code>delete()&lt;/code> پیدا نشود، هیچ اتفاقی نخواهد افتاد.
علت عدم بازگشت ارور در فانکشن &lt;code>delete()&lt;/code> است&lt;/p>
&lt;pre>&lt;code class="language-go">// The delete built-in function deletes the element with the specified key
// (m[key]) from the map. If m is nil or there is no such element, delete
// is a no-op.
func delete(m map[Type]Type1, key Type)
&lt;/code>&lt;/pre>
&lt;/blockquote>
&lt;/div>&lt;/div>
&lt;h2 id="1107-بررسی-وجود-کلید">
1.10.7 بررسی وجود کلید
&lt;a class="anchor" href="#1107-%d8%a8%d8%b1%d8%b1%d8%b3%db%8c-%d9%88%d8%ac%d9%88%d8%af-%da%a9%d9%84%db%8c%d8%af">#&lt;/a>
&lt;/h2>
&lt;p>یکی از خدماتی که مپ ارائه می‌دهد،‌ پاسخ به سوال وجود یک کلید خاص در مپ می‌باشد که به‌عنوان راهکاری برای حل مسائل از آن استفاده می‌شود. مثال زیر را ببینید:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
var personData = map[string]string{"name": "frank", "family": "colleti", "dob": "1970-05-12"}
name, nameExist := personData["name"]
family, familyExist := personData["family"]
dob, dobExist := personData["dob"]
organization, organizationExist := personData["organization"]
fmt.Println(name, nameExist)
//frank true
fmt.Println(family, familyExist)
//colleti true
fmt.Println(dob, dobExist)
//1970-05-12 true
fmt.Println(organization, organizationExist)
// false
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;ul>
&lt;li>این روش بیشتر به اسم &lt;code>comma, ok&lt;/code> شناخته می‌شود و بسیاری از توابع چه در کتابخانه استاندارد و چه کتابخانه‌های عمومی در گولنگ، از این نوع نام‌گذاری برای برگشت دادن مقدار و ارور پشتیبانی می‌کنند.&lt;/li>
&lt;li>در مثال بالا تمامی متغیرهایی که با &lt;code>Exist&lt;/code> تمام می‌شوند برای برسی وجود و عدم وجود یک کلید در &lt;code>مپ&lt;/code> استفاده می‌شوند، به این صورت که اگر مقدار مشخص شده در &lt;code>مپ&lt;/code> وجود داشت مقدار برگشتی در این متغیرها &lt;code>true&lt;/code> خواهد بود و در غیر این صورت مقدار برگشتی &lt;code>false&lt;/code>.&lt;/li>
&lt;/ul>
&lt;div class="run">
&lt;form action="https://go.dev/play/p/55Ga1f_c8Fz" target="_blank" >
&lt;input type="submit" value="اجرای کد فوق در playground" class="goplay-btn" />
&lt;/form>
&lt;/div>
&lt;h2 id="1108-مپ-یک-جدول-یک-منبع">
1.10.8 مپ، یک جدول، یک منبع
&lt;a class="anchor" href="#1108-%d9%85%d9%be-%db%8c%da%a9-%d8%ac%d8%af%d9%88%d9%84-%db%8c%da%a9-%d9%85%d9%86%d8%a8%d8%b9">#&lt;/a>
&lt;/h2>
&lt;p>وقتی یک مپ تعریف می‌شود، اگر مپ(های) دیگری از روی آن ساخته شود، دارای یک منبع &lt;code>(reference type)&lt;/code> برای ذخیره و دریافت اطلاعات خواهند بود. در مثال زیر، مپ &lt;code>editorMap&lt;/code> از مپ &lt;code>companyProfile&lt;/code> ایجاد و وقتی ویرایش می‌شود، مپ اصلی &lt;strong>نیز&lt;/strong>،‌ ویرایش می‌شود.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
var companyProfile = map[string]string{
"name": "companyName",
"address": "sampleAddress",
}
var editorMap = companyProfile // == editorMap := companyProfile
fmt.Println(companyProfile["name"], "\t", companyProfile["address"])
//companyName sampleAddress
fmt.Println(editorMap["name"], "\t", editorMap["address"])
//companyName sampleAddress
editorMap["name"] = "new name"
editorMap["address"] = "new address"
//reference map also edited when editor map edit
fmt.Println(companyProfile["name"], "\t", companyProfile["address"])
//new name new address
fmt.Println(editorMap["name"], "\t", editorMap["address"])
//new name new address
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>برای اینکه بتوانید مقادیر یک مپ را درون یک مپ دیگر کپی کنید، راه حل این است داخل آن مپ پیمایش کنید و مقادیرش را در مپ جدید قرار دهید.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
var companyProfile = map[string]string{
"name": "companyName",
"address": "sampleAddress",
}
var editorMap = map[string]string{}
for key, value := range companyProfile {
editorMap[key] = value
}
fmt.Println(companyProfile["name"], "\t", companyProfile["address"])
fmt.Println(editorMap["name"], "\t", editorMap["address"])
editorMap["name"] = "new address"
editorMap["address"] = "new address"
fmt.Println(companyProfile["name"], "\t", companyProfile["address"])
fmt.Println(editorMap["name"], "\t", editorMap["address"])
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;h2 id="1109-پیمایش-روی-مپ">
1.10.9 پیمایش روی مپ
&lt;a class="anchor" href="#1109-%d9%be%db%8c%d9%85%d8%a7%db%8c%d8%b4-%d8%b1%d9%88%db%8c-%d9%85%d9%be">#&lt;/a>
&lt;/h2>
&lt;p>یکی از اصلی‌ترین اهداف ایجاد و نگهداری انواع تایپ‌های مربوط به مجموعه داده‌ها، امکان دسترسی به اجزای داده و انواع لوپ از ابزارهای آن است.
با استفاده از for-range می‌توان به اجزای یک داده‌ از نوع کلید-مقدار دسترسی داشت&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"fmt"
)
func main() {
animals := make(map[int][]string) // nil map of string-int pairs
animals[0] = []string{"Gopher", "running", "rodent"}
animals[1] = []string{"owl", "flying", "carnivorous"}
animals[2] = []string{"cheetah", "running", "carnivorous"}
animals[3] = []string{"eagle", "flying", "carnivorous"}
animals[4] = []string{"lion", "running", "carnivorous"}
for index, animal := range animals {
fmt.Printf("%v- %s is %s animal and can %s \n", index, animal[0], animal[2], animal[1])
}
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>به نحوه چیدمان خروجی‌ها دقت کنید، درباره علت یکسان نبودن خروجی‌ها در اجراهای متعدد تحقیق کنید &lt;code>تقلب کوچیک بهتون بدم :). مپ ها unordered هستن&lt;/code>.&lt;/p>
&lt;h2 id="11010-تبدیل-اطلاعات-رشته--مپ--اسلایس">
1.10.10 تبدیل اطلاعات رشته − مپ − اسلایس
&lt;a class="anchor" href="#11010-%d8%aa%d8%a8%d8%af%db%8c%d9%84-%d8%a7%d8%b7%d9%84%d8%a7%d8%b9%d8%a7%d8%aa-%d8%b1%d8%b4%d8%aa%d9%87--%d9%85%d9%be--%d8%a7%d8%b3%d9%84%d8%a7%db%8c%d8%b3">#&lt;/a>
&lt;/h2>
&lt;p>نمونه کد زیر یک رشته را به مپ و یک مپ را به اسلایس تبدیل می‌کند.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"fmt"
)
func seriesStringToMap(inputs ...string) map[int]string {
result := make(map[int]string)
for index, input := range inputs {
result[index] = input
}
return result
}
func mapToSlice(inputs map[int]string) []string {
result := make([]string, len(inputs))
for index, input := range inputs {
result[index] = input
}
return result
}
func main() {
myAnimal := "Eagle Cheetah Owl Lion Gopher"
myMappedAnimal := seriesStringToMap(myAnimal)
fmt.Println(myMappedAnimal)
//map[0:Eagle Cheetah Owl Lion Gopher]
mySlicedAnimal := mapToSlice(myMappedAnimal)
fmt.Println(mySlicedAnimal)
//[Eagle Cheetah Owl Lion Gopher]
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;h2 id="11011-خودآزمون">
1.10.11 خودآزمون
&lt;a class="anchor" href="#11011-%d8%ae%d9%88%d8%af%d8%a2%d8%b2%d9%85%d9%88%d9%86">#&lt;/a>
&lt;/h2>
&lt;p>کد زیر را بررسی کنید و خروجی(های) آن را با ذهن خود پردازش کنید. سپس صحت آن(ها) را بررسی و درباره آن تحقیق کنید:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
var myMap map[string]int
fmt.Println(myMap)
var otherMap = map[string]int{}
fmt.Println(otherMap)
myMap["foo"] = 13
fmt.Println(myMap)
otherMap["bar"] = 99
fmt.Println(otherMap)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div></description></item><item><author/><title>1.11 شرط (if, switch)</title><link>https://book.gofarsi.ir/chapter-1/go-if-switch/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-1/go-if-switch/</guid><description>&lt;h2 id="1111-شرط-if-else">
1.11.1 شرط (if-else)
&lt;a class="anchor" href="#1111-%d8%b4%d8%b1%d8%b7-if-else">#&lt;/a>
&lt;/h2>
&lt;p>زبان گو همانند سایر زبان‌ها دارای &lt;span class="tooltip" data-tooltip="if-else" ontouchend="toggleTooltip(this)">شرط&lt;/span>
است که شما خیلی ساده می‌توانید از آن استفاده کنید. در مثال زیر ما فرمت استاندارد &lt;span class="tooltip" data-tooltip="if-else" ontouchend="toggleTooltip(this)">شرط&lt;/span>
در زبان گو را قرار دادیم:&lt;/p>
&lt;pre>&lt;code class="language-go">if condition {
//Do something
} else if condition {
//Do something
} else {
//Do something
}
&lt;/code>&lt;/pre>
&lt;p>در بالا &lt;strong>condition&lt;/strong> عبارتی است که قرار است وضعیت شرط را مشخص کند و در صورت &lt;strong>true&lt;/strong> شدن شرط بر قرار می‌شود و در صورت برقرار نشدن شرط اول، برنامه وارد else if می‌شود و مجدد یک &lt;strong>condition&lt;/strong> دیگری را چک می‌کند که وضعیتش &lt;strong>true&lt;/strong> می‌شود یا خیر و در نهایت منتهی می‌شود به &lt;strong>else&lt;/strong>.&lt;/p>
&lt;p>در &lt;span class="tooltip" data-tooltip="if-else" ontouchend="toggleTooltip(this)">شرط&lt;/span>
ما یک یا چندتا condition می‌توانیم داشته باشیم که این condition‌ ها برای تعیین وضعیت از یکسری عملگرها نظیر &lt;code>&amp;amp;&amp;amp; , || , &amp;gt; , &amp;lt; , &amp;lt;= , =&amp;gt; , !&lt;/code> و &amp;hellip; استفاده می کنند.&lt;/p>
&lt;p>زبان گو از فرمت‌های زیر برای ایجاد &lt;span class="tooltip" data-tooltip="if-else" ontouchend="toggleTooltip(this)">شرط&lt;/span>
استفاده می‌کند:&lt;/p>
&lt;ul>
&lt;li>فقط if&lt;/li>
&lt;li>if-else تو در تو (nested)&lt;/li>
&lt;li>شرط کوتاه با if&lt;/li>
&lt;/ul>
&lt;h2 id="1112-کلمه-if-به-تنهایی">
1.11.2 کلمه if به تنهایی
&lt;a class="anchor" href="#1112-%da%a9%d9%84%d9%85%d9%87-if-%d8%a8%d9%87-%d8%aa%d9%86%d9%87%d8%a7%db%8c%db%8c">#&lt;/a>
&lt;/h2>
&lt;p>شما می‌توانید به تنهایی از if استفاده و یک condition را بررسی کنید:&lt;/p>
&lt;pre>&lt;code class="language-go">if condition {
//Do something
}
&lt;/code>&lt;/pre>
&lt;p>برای نمونه کد زیر را ببینید:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
a := 6
if a > 5 {
fmt.Println("a is greater than 5")
}
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در مثال بالا ما مقدار a را با عدد ۵ مقایسه کردیم، شرط ما به این صورت بود که آیا a از ۵ بزرگتر است یا خیر؟ جواب &lt;code>true&lt;/code> است. a بزرگتر از 5 است و شرط برقرار میشود.&lt;/p>
&lt;p>در مثال زیر ما چند condition را داخل یک شرط بررسی کردیم. &lt;code>آیا a بزرگتر از 3 و a کوچک تر از 6 است؟&lt;/code>&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
a := 4
if a > 3 &amp;&amp; a &lt; 6 {
fmt.Println("a is within range")
}
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;h2 id="1113-کلمه-else">
1.11.3 کلمه else
&lt;a class="anchor" href="#1113-%da%a9%d9%84%d9%85%d9%87-else">#&lt;/a>
&lt;/h2>
&lt;p>فرمت شرط همراه با else مانند مثال زیر است:&lt;/p>
&lt;pre>&lt;code class="language-go">if condition {
//Do something
} else {
//Do something
}
&lt;/code>&lt;/pre>
&lt;p>در مثال بالا اگر condition برقرار نشود، کدهای داخل else اجرا خواهند شد. به مثال زیر توجه کنید:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
a := 1
b := 2
if a > b {
fmt.Println("a is greater than b")
} else {
fmt.Println("b is greater than a")
}
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;h2 id="1114-ادامه-شرط-با-else-if">
1.11.4 ادامه شرط با else if
&lt;a class="anchor" href="#1114-%d8%a7%d8%af%d8%a7%d9%85%d9%87-%d8%b4%d8%b1%d8%b7-%d8%a8%d8%a7-else-if">#&lt;/a>
&lt;/h2>
&lt;p>شما با استفاده از کلید واژه else if &lt;code>دقیقا به همین فرمت که اینجا نوشته شده&lt;/code> می‌توانید condition دیگری را بررسی کرده و در صورت برقرار شدن شرط، عملیات را انجام دهید.&lt;/p>
&lt;pre>&lt;code class="language-go">if condition1 {
//Do something
} else if condition2 {
//Do something
} else {
//Do something
}
&lt;/code>&lt;/pre>
&lt;p>به مثال زیر توجه کنید:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
age := 29
if age &lt; 18 {
fmt.Println("Kid")
} else if age >= 18 &amp;&amp; age &lt; 40 {
fmt.Println("Young")
} else {
fmt.Println("Old")
}
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;h2 id="1115-شرط-تو-در-تو-nested">
1.11.5 شرط تو در تو (nested)
&lt;a class="anchor" href="#1115-%d8%b4%d8%b1%d8%b7-%d8%aa%d9%88-%d8%af%d8%b1-%d8%aa%d9%88-nested">#&lt;/a>
&lt;/h2>
&lt;p>در زبان گولنگ شما می‌توانید شرط‌های تو در تو (nested) داشته باشید (برای توسعه بهتر پروژه، بهتر است کمتر از شرطهای تو در تو استفاده کنید، زیرا این گونه شرط نویسی خوانایی کد را پایین می‌آورد)&lt;/p>
&lt;pre>&lt;code class="language-go">if condition {
//Do something
if condition2 {
//Do something
}
//Do something
}
&lt;/code>&lt;/pre>
&lt;p>در مثال زیر یک نمونه شرط تو در تو به همراه else قرار دادیم:&lt;/p>
&lt;pre>&lt;code class="language-go">if condition1 {
//...
} else {
//...
if condition2 {
//...
} else {
//....
}
//....
}
&lt;/code>&lt;/pre>
&lt;p>در کد زیر مثالی برای شروط تو در تو زدیم:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
a := 1
b := 2
c := 3
if a > b &amp;&amp; a > c {
fmt.Println("Biggest is a")
} else if b > a &amp;&amp; b > c {
fmt.Println("Biggest is b")
} else {
fmt.Println("Biggest is c")
}
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;h2 id="1116-تعریف-شرط-و-قرار-دادن-condition-در-متغیر-کوتاه">
1.11.6 تعریف شرط و قرار دادن condition در متغیر کوتاه
&lt;a class="anchor" href="#1116-%d8%aa%d8%b9%d8%b1%db%8c%d9%81-%d8%b4%d8%b1%d8%b7-%d9%88-%d9%82%d8%b1%d8%a7%d8%b1-%d8%af%d8%a7%d8%af%d9%86-condition-%d8%af%d8%b1-%d9%85%d8%aa%d8%ba%db%8c%d8%b1-%da%a9%d9%88%d8%aa%d8%a7%d9%87">#&lt;/a>
&lt;/h2>
&lt;p>در زبان گو شرط‌ها, امکان تعریف متغیر به روش کوتاه در شرط برای condition را دارند و شما می‌توانید قبل از بررسی کردن condition اون رو در همان خط مقدار دهی کنید.&lt;/p>
&lt;pre>&lt;code class="language-go">if statement; condition {
//Do something
}
&lt;/code>&lt;/pre>
&lt;p>به مثال زیر توجه کنید:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
if a := 6; a > 5 {
fmt.Println("a is greater than 5")
}
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در مثال بالا ما یک متغیر کوتاه با نام a را داخل شرط تعریف کردیم و مقدار 6 را بهش دادیم، سپس با قرار دادن &lt;code>;&lt;/code> &lt;code>semi-colon&lt;/code> برقراری وضعیت شرط را بررسی کردیم.&lt;/p>
&lt;h2 id="1117-switch">
1.11.7 Switch
&lt;a class="anchor" href="#1117-switch">#&lt;/a>
&lt;/h2>
&lt;p>زبان گو ‌مانند برخی از زبان‌ها از switch پشتیبانی می‌کند. switch یک روش بسیار ساده‌تر و همچنین روشی برای جلوگیری از else if های مکرر در شرط است.&lt;/p>
&lt;pre>&lt;code class="language-go">switch statement; expression {
case expression1:
//Dosomething
case expression2:
//Dosomething
default:
//Dosomething
}
&lt;/code>&lt;/pre>
&lt;p>زمانیکه switch رو تعریف می‌کنیم, &lt;code>هم می‌توانیم مقداری که قبلا تعریف کردیم رو برای بررسی بهش بدیم و هم می‌توانیم از روش (تعریف متغیر به روش کوتاه) یک مقدار جدید تعریف کنیم و ازش استفاده کنیم&lt;/code>. بعد از کلمه switch باید یک مقدار رو بهش بدیم و داخل switch با استفاده از case بررسی کنیم که مقداری که داده شده با اون چیزی که مد نظر ما هست برابر هست یا خیر. اگر هیج کدام از شرط ها برقرار نبود، کد های بعد از default اجرا میشن. استفاده از شرط default اجباری نیست.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
switch ch := "b"; ch {
case "a":
fmt.Println("a")
case "b", "c":
fmt.Println("b or c")
default:
fmt.Println("No matching character")
}
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در مثال بالا ما یک متغیر با نام ch رو به روش &lt;code>تعریف متغیر به روش کوتاه&lt;/code> مقدار دهی کردم و همون متغیر را برای بررسی به switch دادیم. سپس با استفاده از کلید واژه case بررسی کردیم که آیا ch برابر است با اون مقادیری که ما تعریف کردیم یا خیر. اگر برابر بود کدهای درون اون case اجرا خواهند شد و اگر برابر نبود ما با استفاده از کلید واژه default مقدار پیش‌فرضی را در خروجی چاپ می‌کنیم.&lt;/p>
&lt;h2 id="1118-fallthrough">
1.11.8 fallthrough
&lt;a class="anchor" href="#1118-fallthrough">#&lt;/a>
&lt;/h2>
&lt;p>اگر در آخر یک case از این keyword استفاده شود، case بعدی بدون هیچ شرطی اجرا می‌شود. نکته ای که حتی بسیاری از منابع انگلیسی هم به صورت واضح اشاره نکرده اند، این است وقتی از fallthrough استفاده می کنیم، کیس بعد از آن بدون بررسی اجرا می شود حتی اگر شرطش برقرار نباشد.
در ادامه اول یک مثال صحیح از استفاده ی fallthrough و سپس یک مثال اشتباه می زنیم.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
var dayOfWeek int
fmt.Printf("Enter a day of week: ")
fmt.Scanln(&amp;dayOfWeek)
switch dayOfWeek {
case 1:
fmt.Println("Monday")
fallthrough
case 2:
fmt.Println("Tuesday")
fallthrough
case 3:
fmt.Println("Wednesday")
fallthrough
case 4:
fmt.Println("Thursday")
fallthrough
case 5:
fmt.Println("Friday")
fallthrough
case 6:
fmt.Println("Saturday")
fallthrough
case 7:
fmt.Println("Sunday")
default:
fmt.Println("Invalid Day")
}
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در این مثال از کاربر یک روز هفته را می گیریم، سپس اسم آن روز به علاوه ی اسم تعداد روز های باقی مانده از هفته را چاپ می کنیم. با استفاده از fallthrough به سادگی می توان اینکار را انجام داد.&lt;/p>
&lt;p>خروجی کد ما اگر روز سوم هفته را وارد کنیم به این صورت است:&lt;/p>
&lt;pre>&lt;code class="language-bash">Enter a day of week: 3
Wednesday
Thursday
Friday
Saturday
Sunday
&lt;/code>&lt;/pre>
&lt;p>اما اگر از fallthrough به‌صورت اشتباه استفاده کنیم، کد ما ازنظر منطقی با مشکل مواجه می شود. به مثال زیر دقت کنید:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"fmt"
"strings"
)
func main() {
var notificationType string = "sms,email"
switch {
case strings.Contains(notificationType, "sms"):
fmt.Println("Sent sms")
fallthrough
case strings.Contains(notificationType, "email"):
fmt.Println("Sent email")
fallthrough
case strings.Contains(notificationType, "push"):
fmt.Println("Sent push")
default:
fmt.Println("Unknown")
}
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در این مثال، برنامه نویس اینگونه در نظر گرفته است که fallthrough روشی است تا بتواند در صورت درست بودن یک شرط، سراغ شرط بعدی برود و آن را هم چک کند. اما fallthrough بدون اینکه شرط کیس بعدی را چک کند. آن را اجرا می کند.
در این مثال با اینکه مشخص کردیم فقط sms و email شود، push هم می کند.&lt;/p>
&lt;pre>&lt;code class="language-bash">Sent sms
Sent email
Sent push
&lt;/code>&lt;/pre>
&lt;h2 id="1119-switch-خودآزمون">
1.11.9 Switch خودآزمون
&lt;a class="anchor" href="#1119-switch-%d8%ae%d9%88%d8%af%d8%a2%d8%b2%d9%85%d9%88%d9%86">#&lt;/a>
&lt;/h2>
&lt;p>تفاوت ساختار و خروجی چهار فرمت مشابه زیر را بررسی کنید:&lt;/p>
&lt;div class="book-tabs">&lt;input type="radio" class="toggle" name="tabs-myid" id="tabs-myid-0" checked="checked" />
&lt;label for="tabs-myid-0">حالت اول&lt;/label>
&lt;div class="book-tabs-content markdown-inner">&lt;pre>&lt;code class="language-go">switch f(); {
case true:
println(1)
case false:
println(0)
}
&lt;/code>&lt;/pre>
&lt;/div>&lt;input type="radio" class="toggle" name="tabs-myid" id="tabs-myid-1" />
&lt;label for="tabs-myid-1">حالت دوم&lt;/label>
&lt;div class="book-tabs-content markdown-inner">&lt;pre>&lt;code class="language-go">switch f()
{
case true:
println(1)
case false:
println(0)
}
&lt;/code>&lt;/pre>
&lt;/div>&lt;input type="radio" class="toggle" name="tabs-myid" id="tabs-myid-2" />
&lt;label for="tabs-myid-2">حالت سوم&lt;/label>
&lt;div class="book-tabs-content markdown-inner">&lt;pre>&lt;code class="language-go">switch f() {
case true:
println(1)
case false:
println(0)
}
&lt;/code>&lt;/pre>
&lt;/div>&lt;input type="radio" class="toggle" name="tabs-myid" id="tabs-myid-3" />
&lt;label for="tabs-myid-3">حالت چهارم&lt;/label>
&lt;div class="book-tabs-content markdown-inner">&lt;pre>&lt;code class="language-go">switch f(); true {
case true:
println(1)
case false:
println(0)
}
&lt;/code>&lt;/pre>
&lt;/div>&lt;/div>
&lt;blockquote class="book-hint info">
کدها در زمان اجرا یا پیش از آن، در برخی IDE یا Code Editor(ها) فرمت می‌شوند.
هدف این خودآزمون دقت به ساختار ابزار switch است.
&lt;/blockquote></description></item><item><author/><title>1.12 اضافه کردن پکیج در کد (package)</title><link>https://book.gofarsi.ir/chapter-1/go-package/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-1/go-package/</guid><description>&lt;p>زبان برنامه‌نویسی گو به شکلی طراحی شده است تا بتوانیم شیو‌ه‌های خوب مهندسی نرم‌افزار را به سادگی پیاده‌سازی کنیم. یکی از الگوهای مهم برای ارتقای کیفیت یک نرم افزار استفاده از DRY principle است. کلمه DRY مخفف &lt;strong>D&lt;/strong>on’t &lt;strong>R&lt;/strong>epeat &lt;strong>Y&lt;/strong>ourself &lt;code>همون چرخ رو دوباره اختراع نکن خودمون&lt;/code> است, که اگر به صورت خیلی ساده بیانش کنیم یعنی، کدی که خواهید نوشت را دوبار تکرار نکنید. تا جایی که امکان دارد باید بتوانید از کدهای قبلی که نوشته اید استفاده کنید. پکیج‌ها امکاناتی از جمله:&lt;/p>
&lt;ul>
&lt;li>قابلیت استفاده مجدد از کد را به ما میدهند.&lt;/li>
&lt;li>امکان ماژولار، و قابل نگهداری بودن کد را فراهم می‌کنند.&lt;/li>
&lt;li>امکان مدیریت بهتر فایل‌ها را در یک واحد ایجاد می‌کنند.&lt;/li>
&lt;/ul>
&lt;h2 id="1121-پکیجها-در-زبان-گو">
1.12.1 پکیج‌ها در زبان گو
&lt;a class="anchor" href="#1121-%d9%be%da%a9%db%8c%d8%ac%d9%87%d8%a7-%d8%af%d8%b1-%d8%b2%d8%a8%d8%a7%d9%86-%da%af%d9%88">#&lt;/a>
&lt;/h2>
&lt;p>پکیج در اصل یک یا مجموعه‌ای از سورس فایل‌های شما است که ممکن است داخل یک فولدر قرار بگیرد. هر سورس فایلی که در زبان گو دارید متعلق به یک پکیج است. برای تعریف یک پکیج از دستور زیر استفاده می‌کنیم:&lt;/p>
&lt;pre>&lt;code class="language-go">package &amp;lt;packagename&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>برای تعریف پکیج باید در اولین خط فایل، آن را با کلید واژه package تعریف کنید.
داخل این پکیج شما می‌توانید کد‌هایی که لازم دارید را بنویسید و تصمیم بگیرید کدام متغییر، فانکشن یا تایپ باید به صورت عمومی باشد و یا باید به صورت خصوصی فقط داخل پکیج مورد استفاده قرار بگیرد.&lt;/p>
&lt;p>قطعا می‌دانیم بعد از نوشتن پکیج اگر بخواهیم از آن پکیج داخل پکیج‌های دیگر استفاده کنیم باید از کلید واژه import استفاده کنیم.&lt;/p>
&lt;h2 id="1122-اضافه-کردن-پکیج">
1.12.2 اضافه کردن پکیج
&lt;a class="anchor" href="#1122-%d8%a7%d8%b6%d8%a7%d9%81%d9%87-%da%a9%d8%b1%d8%af%d9%86-%d9%be%da%a9%db%8c%d8%ac">#&lt;/a>
&lt;/h2>
&lt;p>برای اضافه کردن پکیج‌های مختلف ما از کلید واژه import استفاده می‌کنیم.&lt;/p>
&lt;pre>&lt;code class="language-go">import &amp;quot;fmt&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>برای مثال, در کد بالا ما از پکیج &lt;code>fmt&lt;/code> که در کتابخانه استاندارد گو وجود دارد استفاده کردیم. این به این معنی است همراه با تعریف کلمه fmt میتوانیم از توابعی که داخل این پکیج نوشته شده است استفاده کنیم. در مثال زیر ما از تابع Println برای چاپ مقدار&lt;code>Hello GoFarsi!‍&lt;/code> استفاده کردیم.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
fmt.Println("Hello GoFarsi!")
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>تعریف کردن توابع به این شکل مزایای زیادی دارد از جمله:&lt;/p>
&lt;ul>
&lt;li>اگر اسم‌های مشابهی داشته باشید، داخل پکیج‌های مختلف می‌توانید از آن‌ها استفاده کنید، همچنین خوانایی برنامه افزایش پیدا می‌کند و باعث می‌شود از نام‌های طولانی استفاده نکنیم.&lt;/li>
&lt;li>مجموعه کدهایی که مربوط به هم هستن را در یک پکیج می‌توانیم قرار دهیم, که باعث می‌شود پیدا کردن و استفاده مجدد از کد را برای ما راحت‌تر کند.&lt;/li>
&lt;li>فرایند تغییر و کامپایل را می‌تواند به حداقل برساند.&lt;/li>
&lt;/ul>
&lt;h3 id="11221-اضافه-کردن-چندین-پکیج">
1.12.2.1 اضافه کردن چندین پکیج
&lt;a class="anchor" href="#11221-%d8%a7%d8%b6%d8%a7%d9%81%d9%87-%da%a9%d8%b1%d8%af%d9%86-%da%86%d9%86%d8%af%db%8c%d9%86-%d9%be%da%a9%db%8c%d8%ac">#&lt;/a>
&lt;/h3>
&lt;p>ما می‌توانیم برای اضافه کردن هر پکیج از کلید واژه import به شکل زیر استفاده کنیم:&lt;/p>
&lt;pre>&lt;code class="language-go">import &amp;quot;fmt&amp;quot;
import &amp;quot;time&amp;quot;
import &amp;quot;math&amp;quot;
import &amp;quot;math/rand&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>اما با تشکر از زبان گو, ما می‌توانیم چندین پکیج رو به صورت زیر و فقط با یک بار نوشتن کلید واژه &lt;code>import&lt;/code> فراخوانی کنیم:&lt;/p>
&lt;pre>&lt;code class="language-go">import (
&amp;quot;fmt&amp;quot;
&amp;quot;time&amp;quot;
&amp;quot;math&amp;quot;
&amp;quot;math/rand&amp;quot;
)
&lt;/code>&lt;/pre>
&lt;p>یعنی یک بار از کلید واژه import استفاده کنیم و بعد اسم پکیج‌ها را به ترتیب داخل آن بنویسیم.&lt;/p>
&lt;p>همینطور ما می‌توانیم به پکیج هایی که &lt;code>import&lt;/code> کردیم یک &lt;code>alias&lt;/code> هم بدیم، یعنی همون &lt;code>اسم مستعار&lt;/code>, به مثال زیر توجه کنید:&lt;/p>
&lt;pre>&lt;code class="language-go">import (
format &amp;quot;fmt&amp;quot;
)
&lt;/code>&lt;/pre>
&lt;p>و مانند مثال زیر از آن ها استفاده کنیم:‌&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import format "fmt"
func main() {
format.Println("Hello from Gofarsi")
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;h2 id="1123-اسمهای-عمومی-و-خصوصی-export-و-unexport">
1.12.3 اسم‌های عمومی و خصوصی (Export و Unexport)
&lt;a class="anchor" href="#1123-%d8%a7%d8%b3%d9%85%d9%87%d8%a7%db%8c-%d8%b9%d9%85%d9%88%d9%85%db%8c-%d9%88-%d8%ae%d8%b5%d9%88%d8%b5%db%8c-export-%d9%88-unexport">#&lt;/a>
&lt;/h2>
&lt;p>همه توابع، متغیر‌ها، ثابت ها و تایپ‌هایی که با حروف کوچک شروع می‌شوند، فقط در همان پکیج قابل دسترس هستند. برای عمومی کردن آنها، حرف اول آنها را به صورت Capital می‌نویسیم.
برای مثال به کد زیر نگاه کنید:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "encoding/json"
type jSON struct {
Name string `json:"name"`
}
func main() {
var data []byte
json.Unmarshal(data, &amp;jSON{})
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>چون پکیج json نیاز داره تا فیلد Name رو تغییر بده پس در نتیجه در کد بالا حتما باید این فیلد رو با حرف بزرگ می‌نوشتیم.&lt;/p>
&lt;h2 id="1124-اضافه-کردن-پکیجهای-3rd-party">
1.12.4 اضافه کردن پکیج‌های 3rd party
&lt;a class="anchor" href="#1124-%d8%a7%d8%b6%d8%a7%d9%81%d9%87-%da%a9%d8%b1%d8%af%d9%86-%d9%be%da%a9%db%8c%d8%ac%d9%87%d8%a7%db%8c-3rd-party">#&lt;/a>
&lt;/h2>
&lt;p>فرض کنید می‌خواهیم از پکیج &lt;a href="https://github.com/gin-gonic/gin"> Gin (github.com)&lt;/a> استفاده کنیم، برای اضافه کردن این پکیج ما ‌می‌توانیم به دو شکل زیر آن را اضافه کنیم.&lt;/p>
&lt;p>داخل پروژه خود از دستور زیر استفاده کنید:&lt;/p>
&lt;pre>&lt;code class="language-bash">$ go get -u github.com/gin-gonic/gin
&lt;/code>&lt;/pre>
&lt;p>بعدا می‌توانید وارد پروژه خود شوید و با کلید واژه import از آن استفاده کنید. به مثال زیر نگاه کنید:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"net/http"
"github.com/gin-gonic/gin"
)
func main() {
r := gin.Default()
r.GET("/ping", func(c *gin.Context) {
c.JSON(http.StatusOK, gin.H{
"message": "pong",
})
})
r.Run() // listen and serve on 0.0.0.0:8080 (for windows "localhost:8080")
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>حالت دیگر استفاده از &lt;code>go mod tidy&lt;/code> است, به این شکل که ما از دستور &lt;code>go get&lt;/code> استفاده نمی‌کنیم و به صورت مستقیم داخل پروژه آدرس gin را import می‌کنیم.&lt;/p>
&lt;p>و همان ابتدا داخل کد یک فانکشن را از همان پکیج فراخوانی می‌کنیم (اینکار لازم است چون همانطور که می‌دانید خود go tool وقتی بداند شما پکیجی را تعریف کردید و استفاده نکردید آن را خودکار پاک می‌کند. البته که کد ادیتورهای معروف هم مانند &lt;code>goland,vsCode&lt;/code> و &amp;hellip;، همین کارو رو در حین نوشتن کد برای شما انجام می‌دهند.)&lt;/p>
&lt;p>سپس از دستور زیر استفاده میکنیم:&lt;/p>
&lt;pre>&lt;code class="language-bash">$ go mod tidy
&lt;/code>&lt;/pre>
&lt;p>این دستور کل کدهای شما را بررسی می‌کند و اگر ببینید پکیجی تعریف شده است و شما آن را ندارید سعی میکند آن پکیج را برای شما دانلود و به پروژه شما اضافه کند.&lt;/p></description></item><item><author/><title>1.13 defer, panic, recovery</title><link>https://book.gofarsi.ir/chapter-1/go-defer-panic-recovery/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-1/go-defer-panic-recovery/</guid><description>&lt;h2 id="1131-تعویق-defer">
1.13.1 تعویق (defer)
&lt;a class="anchor" href="#1131-%d8%aa%d8%b9%d9%88%db%8c%d9%82-defer">#&lt;/a>
&lt;/h2>
&lt;p>کلمه کلیدی defer یکی از کاربردی‌ترین امکانات زبان گو را برای ما فراهم می‌سازد. شما می‌توانید اجرای یک تابع را به تعویق بندازید‍‍. عموماً defer برای توابعی کاربرد دارد که قصد پاک‌سازی یا بستن عملیات‌های صورت گرفته را دارند، نظیر توابع Close در برخی از جاها.&lt;/p>
&lt;p>&lt;img src="../../assets/img/content/chapter1/defer-panic-recovery/1.png" alt="defer" />&lt;/p>
&lt;p>به مثال زیر توجه کنید:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"fmt"
)
func main() {
defer fmt.Println("world")
fmt.Println("hello")
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;h3 id="11311-تعویق-defer-در-توابع-anonymous">
1.13.1.1 تعویق (defer) در توابع (Anonymous)
&lt;a class="anchor" href="#11311-%d8%aa%d8%b9%d9%88%db%8c%d9%82-defer-%d8%af%d8%b1-%d8%aa%d9%88%d8%a7%d8%a8%d8%b9-anonymous">#&lt;/a>
&lt;/h3>
&lt;p>شما خیلی ساده می‌توانید با استفاده از توابع &lt;code>Anonymous&lt;/code> &lt;code>توابع بینام یا گمنام :)&lt;/code> اجرای قسمتی از برنامه خودتان را به تعویق بندازید. به مثال زیر توجه کنید:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
defer func() { fmt.Println("In inline defer") }()
fmt.Println("Executed")
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>به این نکته توجه کنید که &lt;code>defer&lt;/code> قبل از &lt;code>return&lt;/code> صدا زده می‌شود. یعنی قبل از اینکه تابع شما خروجی را برگشت بدهد &lt;code>اگه تابع خروجی داشته باشه&lt;/code> &lt;strong>defer&lt;/strong> اجرا خواهد شد.&lt;/p>
&lt;h3 id="11312-تعویق-defer-چندین-تابع-درون-یک-تابع">
1.13.1.2 تعویق (defer) چندین تابع درون یک تابع
&lt;a class="anchor" href="#11312-%d8%aa%d8%b9%d9%88%db%8c%d9%82-defer-%da%86%d9%86%d8%af%db%8c%d9%86-%d8%aa%d8%a7%d8%a8%d8%b9-%d8%af%d8%b1%d9%88%d9%86-%db%8c%da%a9-%d8%aa%d8%a7%d8%a8%d8%b9">#&lt;/a>
&lt;/h3>
&lt;p>در کد زیر, ما داخل یک تابع چند تابع را با استفاده از (defer) به تعویق انداختیم. به مثال زیر توجه کنید:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
i := 0
i = 1
defer fmt.Println(i)
i = 2
defer fmt.Println(i)
i = 3
defer fmt.Println(i)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>&lt;strong>دقت داشته باشید که مقداردهی پارامترهای ورودی، برای تابعی که آن را defer کردیم در همان لحظه call شدن آن انجام می‌شود. به مثال زیر توجه کنید:&lt;/strong>&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
i:=1
defer fmt.Println(i)
i++
fmt.Println(i)
fmt.Println("First")
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در این مرحله شما باید پی برده باشید که &lt;strong>defer&lt;/strong> در همان خطی که نوشته شده است صدا زده می‌شود، ولی اجرای آن دقیقاً به قبل از &lt;strong>return&lt;/strong> در تابع موکول می‌شود.&lt;/p>
&lt;h2 id="1132-پنیک-panic">
1.13.2 پنیک (panic)
&lt;a class="anchor" href="#1132-%d9%be%d9%86%db%8c%da%a9-panic">#&lt;/a>
&lt;/h2>
&lt;p>در زبان گو panic همانند exception به معنای خروج از برنامه در شرایط غیر عادی است. panic در ۲ حالت زیر پیش می‌آید:&lt;/p>
&lt;ul>
&lt;li>خطاهای &lt;span class="tooltip" data-tooltip="runtime" ontouchend="toggleTooltip(this)">در زمان اجرای&lt;/span>
برنامه&lt;/li>
&lt;li>فراخوانی تابع panic توسط برنامه نویس در بخش های مختلف برنامه&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-go">func panic(v interface{})
&lt;/code>&lt;/pre>
&lt;p>شما می‌توانید با استفاده از تابع داخلی فوق، panic ایجاد کنید و به عنوان ورودی دلیل panic را در قالب یک رشته به تابع ارسال کنید.&lt;/p>
&lt;h3 id="11321-خطای-panic-در-زمان-اجرا-runtime">
1.13.2.1 خطای panic در زمان اجرا (runtime)
&lt;a class="anchor" href="#11321-%d8%ae%d8%b7%d8%a7%db%8c-panic-%d8%af%d8%b1-%d8%b2%d9%85%d8%a7%d9%86-%d8%a7%d8%ac%d8%b1%d8%a7-runtime">#&lt;/a>
&lt;/h3>
&lt;p>خطاهای panic در زمان اجرا به دلایل زیر می‌تواند رخ دهد:&lt;/p>
&lt;ul>
&lt;li>خطای Out of bounds/range array/slice&lt;/li>
&lt;li>فراخوانی متغیری که nil pointer باشد &lt;code>یعنی به هیچ آدرسی از حافظه &lt;/code> &lt;strong>memory&lt;/strong> &lt;code>اشاره نمی‌کند&lt;/code>&lt;/li>
&lt;li>ارسال داده برروی کانال‌های بسته شده&lt;/li>
&lt;li>type assertion نادرست&lt;/li>
&lt;/ul>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
a := []string{"a", "b"}
print(a, 2)
}
func print(a []string, index int) {
fmt.Println(a[index])
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در تابع فوق ما یک تابع نوشتیم که به عنوان ورودی یک اسلایس از نوع رشته و یک ایندکس از نوع عدد از ما دریافت می‌کند و المنت &lt;strong>ایندکسم&lt;/strong>‌ اون اسلایس را برای ما چاپ میکند &lt;code>در مثال بالا یعنی اندیس شماره 2&lt;/code>. این کار ما باعث بروز یک &lt;strong>panic&lt;/strong> میشود, فکر میکنید به چه دلیل ؟ بله به این دلیل که اسلایس ما اندیس شماره 2 ندارد و دلیل آن هم این است که اسلایس, لیست و &amp;hellip;. از 0 شروع می‌شوند.&lt;/p>
&lt;p>پنیک یک سری اطلاعات در مورد چرایی بوجود آمدنش به ما می‌دهد که در ادامه آن‌ها را توضیح دادیم:&lt;/p>
&lt;ul>
&lt;li>پنیک رخ داده شامل متن خطا&lt;/li>
&lt;li>محل رخ دادن panic در قالب stacktrace&lt;/li>
&lt;/ul>
&lt;h3 id="11322-خطای-panic-از-قبل-تعیین-شده-توسط-برنامهنویس">
1.13.2.2 خطای panic از قبل تعیین شده توسط برنامه‌نویس
&lt;a class="anchor" href="#11322-%d8%ae%d8%b7%d8%a7%db%8c-panic-%d8%a7%d8%b2-%d9%82%d8%a8%d9%84-%d8%aa%d8%b9%db%8c%db%8c%d9%86-%d8%b4%d8%af%d9%87-%d8%aa%d9%88%d8%b3%d8%b7-%d8%a8%d8%b1%d9%86%d8%a7%d9%85%d9%87%d9%86%d9%88%db%8c%d8%b3">#&lt;/a>
&lt;/h3>
&lt;p>همانطور که گفتیم شما می‌توانید هرجایی از بدنه توابع خود، تابع panic را فراخوانی کنید &lt;strong>البته این روش پیشنهاد نمی‌شود و روش پیشنهادی استفاده از شیوه ارور هندلینگ خود گولنگ است و فقط در صورت لزوم بهتر است از پنیک استفاده شود. همینطور شما باید در داکیومنت برنامه ذکر کنید که کدام قسمت برنامه امکان پنیک را دارد تا دیگران بتوانند در صورت لزوم آن را recover کنند. recover را در ادمه توضیح خواهم داد.&lt;/strong> تا برنامه در آن محل خطایی را نمایش داده و متوقف شود.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
a := []string{"a", "b"}
checkAndPrint(a, 2)
}
func checkAndPrint(a []string, index int) {
if index > (len(a) - 1) {
panic("Out of bound access for slice")
}
fmt.Println(a[index])
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;blockquote class="book-hint info">
توجه کنید استفاده از تابع panic در برخی مواقع مفید می‌باشد. به عنوان مثال قصد دارید هنگام اجرای برنامه، یکسری تنظیمات از سمت کاربر دریافت کنید و در صورتی‌که تنظیمات دارای مشکل بودند، می‌توانید با استفاده panic جلوی ادامه روند برنامه را بگیرید تا کاربر خطا را رفع کند.
&lt;/blockquote>
&lt;h2 id="1133-بازیابی-recovery">
1.13.3 بازیابی (recovery)
&lt;a class="anchor" href="#1133-%d8%a8%d8%a7%d8%b2%db%8c%d8%a7%d8%a8%db%8c-recovery">#&lt;/a>
&lt;/h2>
&lt;p>برخی اوقات panic‌ها غیرقابل پیش‌ بینی می‌شوند. ممکن است برنامه شما بدون هیچ خطایی اجرا شود و به روند خود ادامه دهد، اما این هم ممکن است که به یک دلیل نامعلوم یا بهتر است بگوییم پیش بینی نشده، panic رخ دهد و برنامه شما کاملاً متوقف و باعث از دست دادن وضعیت استیبل برنامه شود.&lt;/p>
&lt;p>به همین منظور در گولنگ یک تابع به نام &lt;code>recover&lt;/code> وجود دارد که پس از رخ دادن panic در برنامه، این قابلیت را به ما می‌دهد تا بتوانیم برنامه را به وضعیت قبلی خود بازگردانیم تا بعداً خطای panic رخ داده را بررسی و رفع کنیم.&lt;/p>
&lt;pre>&lt;code class="language-go">func recover() interface{}
&lt;/code>&lt;/pre>
&lt;p>همینطور که شما هم میبینید، تابع ریکاور هیچ ورودی نمی‌گیرد و یک خروجی از تایپ &lt;code>interface&lt;/code> را برمی‌گرداند.&lt;/p>
&lt;p>به مثالی که در مورد تابع &lt;strong>recover&lt;/strong> زدیم نگاه کنید:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
a := []string{"a", "b"}
checkAndPrint(a, 2)
fmt.Println("Exiting normally")
}
func checkAndPrint(a []string, index int) {
defer handleOutOfBounds()
if index > (len(a) - 1) {
panic("Out of bound access for slice")
}
fmt.Println(a[index])
}
func handleOutOfBounds() {
if r := recover(); r != nil {
fmt.Println("Recovering from panic:", r)
}
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در کد فوق ما یک تابع داریم که در این تابع یک المنت از یک اسلایس را چاپ می‌کند، اما اگر این اندیس خارج از تعداد المنت‌های اسلایس باشد یک خطای panic رخ می‌دهد.
ما برای جلوگیری از خطای panic تابع handleOutOfBounds را با استفاده defer درون تابع checkAndPrint قرار دادیم که پس از رخ دادن panic بصورت خودکار بازیابی صورت بگیرد تا برنامه ما متوقف نشود.&lt;/p>
&lt;h2 id="1134-چاپ-اطلاعات-stacktrace-پس-از-بازیابی">
1.13.4 چاپ اطلاعات stacktrace پس از بازیابی
&lt;a class="anchor" href="#1134-%da%86%d8%a7%d9%be-%d8%a7%d8%b7%d9%84%d8%a7%d8%b9%d8%a7%d8%aa-stacktrace-%d9%be%d8%b3-%d8%a7%d8%b2-%d8%a8%d8%a7%d8%b2%db%8c%d8%a7%d8%a8%db%8c">#&lt;/a>
&lt;/h2>
&lt;p>شما می‌توانید پس از اینکه بازیابی را انجام دادید، جزئیات بیشتری در خصوص خطای panic رخ داده بدست آوردید. به مثال زیر توجه کنید:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"fmt"
"runtime/debug"
)
func main() {
a := []string{"a", "b"}
checkAndPrint(a, 2)
fmt.Println("Exiting normally")
}
func checkAndPrint(a []string, index int) {
defer handleOutOfBounds()
if index > (len(a) - 1) {
panic("Out of bound access for slice")
}
fmt.Println(a[index])
}
func handleOutOfBounds() {
if r := recover(); r != nil {
fmt.Println("Recovering from panic:", r)
fmt.Println("Stack Trace:")
debug.PrintStack()
}
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>برای چاپ اطلاعات stacktrace همانطور که می‌بینید ما از پکیج runtime که در کتابخانه استاندارد گولنگ وجود دارد استفاده کردیم&lt;/p>
&lt;p>&lt;strong>توضیح کوتاه در خصوص stacktrace:&lt;/strong>&lt;/p>
&lt;p>در برنامه نویسی مفهومی به اسم stack trace و یا stack backtrace مطرح است.
بصورت خیلی مختصر کاری که انجام می دهد این است مسیر اجرای کد شمارا از نقطه شروع اجرای کد تا زمانی که به اتمام برسد در استک ذخیره میکند. برای مثال زمانی که با یک panic مواجه میشوید شما می توانید مسیری که برنامه از آن عبور کرده تا به panic خورده را مشاهده کنید که این کار با کمک stack trace انجام میشود.&lt;/p></description></item><item><author/><title>1.14 لیست تایپ‌ها و توابع Builtin</title><link>https://book.gofarsi.ir/chapter-1/go-builtins/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-1/go-builtins/</guid><description>&lt;p>در مثال زیر لیست تایپ‌ها و توابع Builtin را با توضیحات قرار دادیم.&lt;/p>
&lt;pre>&lt;code class="language-go">// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
/*
Package builtin provides documentation for Go's predeclared identifiers.
The items documented here are not actually in package builtin
but their descriptions here allow godoc to present documentation
for the language's special identifiers.
*/
package builtin
import &amp;quot;cmp&amp;quot;
// bool is the set of boolean values, true and false.
type bool bool
// true and false are the two untyped boolean values.
const (
true = 0 == 0 // Untyped bool.
false = 0 != 0 // Untyped bool.
)
// uint8 is the set of all unsigned 8-bit integers.
// Range: 0 through 255.
type uint8 uint8
// uint16 is the set of all unsigned 16-bit integers.
// Range: 0 through 65535.
type uint16 uint16
// uint32 is the set of all unsigned 32-bit integers.
// Range: 0 through 4294967295.
type uint32 uint32
// uint64 is the set of all unsigned 64-bit integers.
// Range: 0 through 18446744073709551615.
type uint64 uint64
// int8 is the set of all signed 8-bit integers.
// Range: -128 through 127.
type int8 int8
// int16 is the set of all signed 16-bit integers.
// Range: -32768 through 32767.
type int16 int16
// int32 is the set of all signed 32-bit integers.
// Range: -2147483648 through 2147483647.
type int32 int32
// int64 is the set of all signed 64-bit integers.
// Range: -9223372036854775808 through 9223372036854775807.
type int64 int64
// float32 is the set of all IEEE 754 32-bit floating-point numbers.
type float32 float32
// float64 is the set of all IEEE 754 64-bit floating-point numbers.
type float64 float64
// complex64 is the set of all complex numbers with float32 real and
// imaginary parts.
type complex64 complex64
// complex128 is the set of all complex numbers with float64 real and
// imaginary parts.
type complex128 complex128
// string is the set of all strings of 8-bit bytes, conventionally but not
// necessarily representing UTF-8-encoded text. A string may be empty, but
// not nil. Values of string type are immutable.
type string string
// int is a signed integer type that is at least 32 bits in size. It is a
// distinct type, however, and not an alias for, say, int32.
type int int
// uint is an unsigned integer type that is at least 32 bits in size. It is a
// distinct type, however, and not an alias for, say, uint32.
type uint uint
// uintptr is an integer type that is large enough to hold the bit pattern of
// any pointer.
type uintptr uintptr
// byte is an alias for uint8 and is equivalent to uint8 in all ways. It is
// used, by convention, to distinguish byte values from 8-bit unsigned
// integer values.
type byte = uint8
// rune is an alias for int32 and is equivalent to int32 in all ways. It is
// used, by convention, to distinguish character values from integer values.
type rune = int32
// any is an alias for interface{} and is equivalent to interface{} in all ways.
type any = interface{}
// comparable is an interface that is implemented by all comparable types
// (booleans, numbers, strings, pointers, channels, arrays of comparable types,
// structs whose fields are all comparable types).
// The comparable interface may only be used as a type parameter constraint,
// not as the type of a variable.
type comparable interface{ comparable }
// iota is a predeclared identifier representing the untyped integer ordinal
// number of the current const specification in a (usually parenthesized)
// const declaration. It is zero-indexed.
const iota = 0 // Untyped int.
// nil is a predeclared identifier representing the zero value for a
// pointer, channel, func, interface, map, or slice type.
var nil Type // Type must be a pointer, channel, func, interface, map, or slice type
// Type is here for the purposes of documentation only. It is a stand-in
// for any Go type, but represents the same type for any given function
// invocation.
type Type int
// Type1 is here for the purposes of documentation only. It is a stand-in
// for any Go type, but represents the same type for any given function
// invocation.
type Type1 int
// IntegerType is here for the purposes of documentation only. It is a stand-in
// for any integer type: int, uint, int8 etc.
type IntegerType int
// FloatType is here for the purposes of documentation only. It is a stand-in
// for either float type: float32 or float64.
type FloatType float32
// ComplexType is here for the purposes of documentation only. It is a
// stand-in for either complex type: complex64 or complex128.
type ComplexType complex64
// The append built-in function appends elements to the end of a slice. If
// it has sufficient capacity, the destination is resliced to accommodate the
// new elements. If it does not, a new underlying array will be allocated.
// Append returns the updated slice. It is therefore necessary to store the
// result of append, often in the variable holding the slice itself:
//
// slice = append(slice, elem1, elem2)
// slice = append(slice, anotherSlice...)
//
// As a special case, it is legal to append a string to a byte slice, like this:
//
// slice = append([]byte(&amp;quot;hello &amp;quot;), &amp;quot;world&amp;quot;...)
func append(slice []Type, elems ...Type) []Type
// The copy built-in function copies elements from a source slice into a
// destination slice. (As a special case, it also will copy bytes from a
// string to a slice of bytes.) The source and destination may overlap. Copy
// returns the number of elements copied, which will be the minimum of
// len(src) and len(dst).
func copy(dst, src []Type) int
// The delete built-in function deletes the element with the specified key
// (m[key]) from the map. If m is nil or there is no such element, delete
// is a no-op.
func delete(m map[Type]Type1, key Type)
// The len built-in function returns the length of v, according to its type:
//
// - Array: the number of elements in v.
// - Pointer to array: the number of elements in *v (even if v is nil).
// - Slice, or map: the number of elements in v; if v is nil, len(v) is zero.
// - String: the number of bytes in v.
// - Channel: the number of elements queued (unread) in the channel buffer;
// if v is nil, len(v) is zero.
//
// For some arguments, such as a string literal or a simple array expression, the
// result can be a constant. See the Go language specification's &amp;quot;Length and
// capacity&amp;quot; section for details.
func len(v Type) int
// The cap built-in function returns the capacity of v, according to its type:
//
// - Array: the number of elements in v (same as len(v)).
// - Pointer to array: the number of elements in *v (same as len(v)).
// - Slice: the maximum length the slice can reach when resliced;
// if v is nil, cap(v) is zero.
// - Channel: the channel buffer capacity, in units of elements;
// if v is nil, cap(v) is zero.
//
// For some arguments, such as a simple array expression, the result can be a
// constant. See the Go language specification's &amp;quot;Length and capacity&amp;quot; section for
// details.
func cap(v Type) int
// The make built-in function allocates and initializes an object of type
// slice, map, or chan (only). Like new, the first argument is a type, not a
// value. Unlike new, make's return type is the same as the type of its
// argument, not a pointer to it. The specification of the result depends on
// the type:
//
// - Slice: The size specifies the length. The capacity of the slice is
// equal to its length. A second integer argument may be provided to
// specify a different capacity; it must be no smaller than the
// length. For example, make([]int, 0, 10) allocates an underlying array
// of size 10 and returns a slice of length 0 and capacity 10 that is
// backed by this underlying array.
// - Map: An empty map is allocated with enough space to hold the
// specified number of elements. The size may be omitted, in which case
// a small starting size is allocated.
// - Channel: The channel's buffer is initialized with the specified
// buffer capacity. If zero, or the size is omitted, the channel is
// unbuffered.
func make(t Type, size ...IntegerType) Type
// The max built-in function returns the largest value of a fixed number of
// arguments of [cmp.Ordered] types. There must be at least one argument.
// If T is a floating-point type and any of the arguments are NaNs,
// max will return NaN.
func max[T cmp.Ordered](x T, y ...T) T
// The min built-in function returns the smallest value of a fixed number of
// arguments of [cmp.Ordered] types. There must be at least one argument.
// If T is a floating-point type and any of the arguments are NaNs,
// min will return NaN.
func min[T cmp.Ordered](x T, y ...T) T
// The new built-in function allocates memory. The first argument is a type,
// not a value, and the value returned is a pointer to a newly
// allocated zero value of that type.
func new(Type) *Type
// The complex built-in function constructs a complex value from two
// floating-point values. The real and imaginary parts must be of the same
// size, either float32 or float64 (or assignable to them), and the return
// value will be the corresponding complex type (complex64 for float32,
// complex128 for float64).
func complex(r, i FloatType) ComplexType
// The real built-in function returns the real part of the complex number c.
// The return value will be floating point type corresponding to the type of c.
func real(c ComplexType) FloatType
// The imag built-in function returns the imaginary part of the complex
// number c. The return value will be floating point type corresponding to
// the type of c.
func imag(c ComplexType) FloatType
// The clear built-in function clears maps and slices.
// For maps, clear deletes all entries, resulting in an empty map.
// For slices, clear sets all elements up to the length of the slice
// to the zero value of the respective element type. If the argument
// type is a type parameter, the type parameter's type set must
// contain only map or slice types, and clear performs the operation
// implied by the type argument. If t is nil, clear is a no-op.
func clear[T ~[]Type | ~map[Type]Type1](t T)
// The close built-in function closes a channel, which must be either
// bidirectional or send-only. It should be executed only by the sender,
// never the receiver, and has the effect of shutting down the channel after
// the last sent value is received. After the last value has been received
// from a closed channel c, any receive from c will succeed without
// blocking, returning the zero value for the channel element. The form
//
// x, ok := &amp;lt;-c
//
// will also set ok to false for a closed and empty channel.
func close(c chan&amp;lt;- Type)
// The panic built-in function stops normal execution of the current
// goroutine. When a function F calls panic, normal execution of F stops
// immediately. Any functions whose execution was deferred by F are run in
// the usual way, and then F returns to its caller. To the caller G, the
// invocation of F then behaves like a call to panic, terminating G's
// execution and running any deferred functions. This continues until all
// functions in the executing goroutine have stopped, in reverse order. At
// that point, the program is terminated with a non-zero exit code. This
// termination sequence is called panicking and can be controlled by the
// built-in function recover.
//
// Starting in Go 1.21, calling panic with a nil interface value or an
// untyped nil causes a run-time error (a different panic).
// The GODEBUG setting panicnil=1 disables the run-time error.
func panic(v any)
// The recover built-in function allows a program to manage behavior of a
// panicking goroutine. Executing a call to recover inside a deferred
// function (but not any function called by it) stops the panicking sequence
// by restoring normal execution and retrieves the error value passed to the
// call of panic. If recover is called outside the deferred function it will
// not stop a panicking sequence. In this case, or when the goroutine is not
// panicking, recover returns nil.
//
// Prior to Go 1.21, recover would also return nil if panic is called with
// a nil argument. See [panic] for details.
func recover() any
// The print built-in function formats its arguments in an
// implementation-specific way and writes the result to standard error.
// Print is useful for bootstrapping and debugging; it is not guaranteed
// to stay in the language.
func print(args ...Type)
// The println built-in function formats its arguments in an
// implementation-specific way and writes the result to standard error.
// Spaces are always added between arguments and a newline is appended.
// Println is useful for bootstrapping and debugging; it is not guaranteed
// to stay in the language.
func println(args ...Type)
// The error built-in interface type is the conventional interface for
// representing an error condition, with the nil value representing no error.
type error interface {
Error() string
}
&lt;/code>&lt;/pre></description></item><item><author/><title>1.15 قالب بندی رشته‌ها</title><link>https://book.gofarsi.ir/chapter-1/go-string-formatting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-1/go-string-formatting/</guid><description>&lt;p>در زبان گو مانند سایر زبان‌ها یکسری عناوین برای قالب‌بندی رشته وجود دارد که برخی از این عناوین مشترک بین همه زبان‌ها هست و برخی مختص زبان گو.&lt;/p>
&lt;h2 id="1151-قالب-بندی-با-توابع-printf-و-sprintf">
1.15.1 قالب بندی با توابع Printf و Sprintf
&lt;a class="anchor" href="#1151-%d9%82%d8%a7%d9%84%d8%a8-%d8%a8%d9%86%d8%af%db%8c-%d8%a8%d8%a7-%d8%aa%d9%88%d8%a7%d8%a8%d8%b9-printf-%d9%88-sprintf">#&lt;/a>
&lt;/h2>
&lt;p>زمانیکه شما از تابع Printf یا Sprintf استفاده می‌کنید می‌توانید رشته خروجی را با استفاده از پارامترهای بعد از رشته قالب‌بندی کنید، و در نهایت به‌صورت یک رشته نمایش دهید.&lt;/p>
&lt;pre>&lt;code class="language-go">fmt.Printf(&amp;quot;{{Verb}}&amp;quot;, value1, value2, value3, ..., valueN)
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-go">fmt.Sprintf(&amp;quot;{{Verb}}&amp;quot;, value1, value2, value3, ..., valueN)
&lt;/code>&lt;/pre>
&lt;blockquote class="book-hint info">
&lt;p>توجه کنید هر دو تابع فوق خیلی کاربردی و پر استفاده هستند. این ۲ تابع کارکردشان مشترک است ولی خروجی متفاوتی دارند.&lt;/p>
&lt;p>به عنوان مثال :&lt;/p>
&lt;ul>
&lt;li>شما با استفاده از Printf می‌توانید یک رشته را قالب‌بندی کنید و در نهایت به عنوان خروجی چاپ کنید.&lt;/li>
&lt;li>ولی با استفاده از Sprintf می‌توانید یک رشته را قالب‌بندی کنید و در نهایت به جای اینکه مقدار خروجی را چاپ کنید، اون رو داخل یک متغیر قرار بریزید. به مثال زیر توجه کنید:&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-go">x := fmt.Sprintf(&amp;quot;age %s is %d years&amp;quot;, &amp;quot;Javad&amp;quot;, 30)
&lt;/code>&lt;/pre>
&lt;/blockquote>
&lt;h3 id="11511-قالببندی-یک-slice">
1.15.1.1 قالب‌بندی یک slice
&lt;a class="anchor" href="#11511-%d9%82%d8%a7%d9%84%d8%a8%d8%a8%d9%86%d8%af%db%8c-%db%8c%da%a9-slice">#&lt;/a>
&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Verb&lt;/th>
&lt;th>&lt;code>fmt.Printf(&amp;quot;{{Verb}}&amp;quot;, []int64{0, 1})&lt;/code> خروجی&lt;/th>
&lt;th>توضیحات&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;span dir="ltr">%v&lt;/span>&lt;/td>
&lt;td>&lt;code>[0 1]&lt;/code>&lt;/td>
&lt;td>فرمت پیش‌فرض&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;span dir="ltr">%#v&lt;/span>&lt;/td>
&lt;td>&lt;code>[]int64{0, 1}&lt;/code>&lt;/td>
&lt;td>قالب‌بندی کد گو&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;span dir="ltr">%T&lt;/span>&lt;/td>
&lt;td>&lt;code>[]int64&lt;/code>&lt;/td>
&lt;td>تایپ مقدار&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;blockquote class="book-hint info">
توجه کنید &lt;code>v%&lt;/code> یکی از پرکاربرد‌ترین Verb‌ها در گولنگ است و مواقعی مورد استفاده قرار می‌گیرد که شما قصد دارید یک مقدار را داخل رشته بزارید، ولی از تایپ اون مقدار خبر ندارید.
&lt;/blockquote>
&lt;h3 id="11512-قالببندی-اعداد-صحیح">
1.15.1.2 قالب‌بندی اعداد صحیح
&lt;a class="anchor" href="#11512-%d9%82%d8%a7%d9%84%d8%a8%d8%a8%d9%86%d8%af%db%8c-%d8%a7%d8%b9%d8%af%d8%a7%d8%af-%d8%b5%d8%ad%db%8c%d8%ad">#&lt;/a>
&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Verb&lt;/th>
&lt;th>&lt;code>fmt.Printf(&amp;quot;{{Verb}}&amp;quot;, 15)&lt;/code> خروجی&lt;/th>
&lt;th>توضیحات&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;span dir="ltr">%d&lt;/span>&lt;/td>
&lt;td>&lt;code>15&lt;/code>&lt;/td>
&lt;td>عدد پایه ۱۰&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;span dir="ltr">%+d&lt;/span>&lt;/td>
&lt;td>&lt;code>+15&lt;/code>&lt;/td>
&lt;td>نمایش + در کنار عدد&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;span dir="ltr">%4d&lt;/span>&lt;/td>
&lt;td>␣␣&lt;code>15&lt;/code>&lt;/td>
&lt;td>۴ کارکتر با فاصله از راست&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;span dir="ltr">%-4d&lt;/span>&lt;/td>
&lt;td>&lt;code>15&lt;/code>␣␣&lt;/td>
&lt;td>۴ کارکتر با فاصله از چپ&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;span dir="ltr">%04d&lt;/span>&lt;/td>
&lt;td>&lt;code>0015&lt;/code>&lt;/td>
&lt;td>نمایش عدد با پیشوند صفر&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;span dir="ltr">%b&lt;/span>&lt;/td>
&lt;td>&lt;code>1111&lt;/code>&lt;/td>
&lt;td>عدد با پایه باینری&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;span dir="ltr">%o&lt;/span>&lt;/td>
&lt;td>&lt;code>17&lt;/code>&lt;/td>
&lt;td>عدد با پایه ۸ اکتال&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;span dir="ltr">%x&lt;/span>&lt;/td>
&lt;td>&lt;code>f&lt;/code>&lt;/td>
&lt;td>عدد با پایه ۱۶ هگز حروف کوچک&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;span dir="ltr">%X&lt;/span>&lt;/td>
&lt;td>&lt;code>F&lt;/code>&lt;/td>
&lt;td>عدد با پایه ۱۶ هگز حروف بزرگ&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;span dir="ltr">%#x&lt;/span>&lt;/td>
&lt;td>&lt;code>0xf&lt;/code>&lt;/td>
&lt;td>عدد با پایه ۱۶ هگز به همراه 0x&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="11513-قالببندی-اعداد-اعشاری">
1.15.1.3 قالب‌بندی اعداد اعشاری
&lt;a class="anchor" href="#11513-%d9%82%d8%a7%d9%84%d8%a8%d8%a8%d9%86%d8%af%db%8c-%d8%a7%d8%b9%d8%af%d8%a7%d8%af-%d8%a7%d8%b9%d8%b4%d8%a7%d8%b1%db%8c">#&lt;/a>
&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Verb&lt;/th>
&lt;th>&lt;code>fmt.Printf(&amp;quot;{{Verb}}&amp;quot;, 123.456)&lt;/code> خروجی&lt;/th>
&lt;th>توضیحات&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;span dir="ltr">%e&lt;/span>&lt;/td>
&lt;td>&lt;code>1.234560e+02&lt;/code>&lt;/td>
&lt;td>نمایش بصورت نماد عملی&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;span dir="ltr">%f&lt;/span>&lt;/td>
&lt;td>&lt;code>123.456000&lt;/code>&lt;/td>
&lt;td>نقطه اعشاری، بدون نما. دقت پیش فرض 6 است&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;span dir="ltr">%.2f&lt;/span>&lt;/td>
&lt;td>&lt;code>123.46&lt;/code>&lt;/td>
&lt;td>عرض پیش فرض، دقت 2 رقم بعد از نقطه اعشار&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;span dir="ltr">%8.2f&lt;/span>&lt;/td>
&lt;td>␣␣&lt;code>123.46&lt;/code>&lt;/td>
&lt;td>عرض 8 کاراکتر، دقت 2 رقم بعد از نقطه اعشار. کاراکتر پیش‌فرض padding space است&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;span dir="ltr">%08.2f&lt;/span>&lt;/td>
&lt;td>&lt;code>00123.46&lt;/code>&lt;/td>
&lt;td>عرض 8 کاراکتر، دقت 2 رقم بعد از نقطه اعشار. لایه سمت چپ با نویسه مشخص شده (اینجا، 0)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;span dir="ltr">%g&lt;/span>&lt;/td>
&lt;td>&lt;code>123.456&lt;/code>&lt;/td>
&lt;td>نما در صورت نیاز، فقط ارقام ضروری&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="11514-قالببندی-کارکترها">
1.15.1.4 قالب‌بندی کارکترها
&lt;a class="anchor" href="#11514-%d9%82%d8%a7%d9%84%d8%a8%d8%a8%d9%86%d8%af%db%8c-%da%a9%d8%a7%d8%b1%da%a9%d8%aa%d8%b1%d9%87%d8%a7">#&lt;/a>
&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Verb&lt;/th>
&lt;th>&lt;code>fmt.Printf(&amp;quot;{{Verb}}&amp;quot;, 'A')&lt;/code> خروجی&lt;/th>
&lt;th>توضیحات&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;span dir="ltr">%c&lt;/span>&lt;/td>
&lt;td>&lt;code>A&lt;/code>&lt;/td>
&lt;td>کارکتر&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;span dir="ltr">%q&lt;/span>&lt;/td>
&lt;td>&lt;code>&amp;quot;A&amp;quot;&lt;/code>&lt;/td>
&lt;td>کارکتر به همراه دابل کوتیشن&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;span dir="ltr">%U&lt;/span>&lt;/td>
&lt;td>&lt;code>U+0041&lt;/code>&lt;/td>
&lt;td>یونیکد&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;span dir="ltr">%#U&lt;/span>&lt;/td>
&lt;td>&lt;code>U+0041 'A'&lt;/code>&lt;/td>
&lt;td>یونیکد به همراه کارکتر&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="11515-قالببندی-رشته-string-و-slice-بایت">
1.15.1.5 قالب‌بندی رشته (string) و slice بایت
&lt;a class="anchor" href="#11515-%d9%82%d8%a7%d9%84%d8%a8%d8%a8%d9%86%d8%af%db%8c-%d8%b1%d8%b4%d8%aa%d9%87-string-%d9%88-slice-%d8%a8%d8%a7%db%8c%d8%aa">#&lt;/a>
&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Verb&lt;/th>
&lt;th>&lt;code>fmt.Printf(&amp;quot;{{Verb}}&amp;quot;, &amp;quot;gophers&amp;quot;)&lt;/code> خروجی&lt;/th>
&lt;th>توضیحات&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;span dir="ltr">%s&lt;/span>&lt;/td>
&lt;td>&lt;code>gophers&lt;/code>&lt;/td>
&lt;td>رشته ساده&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;span dir="ltr">%8s&lt;/span>&lt;/td>
&lt;td>␣␣&lt;code>gophers&lt;/code>&lt;/td>
&lt;td>با ۸ پدینگ راست چین شده&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;span dir="ltr">%-8s&lt;/span>&lt;/td>
&lt;td>&lt;code>gophers&lt;/code>␣␣&lt;/td>
&lt;td>با ۸ پدینگ چپ چین شده&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;span dir="ltr">%q&lt;/span>&lt;/td>
&lt;td>&lt;code>&amp;quot;gophers&amp;quot;&lt;/code>&lt;/td>
&lt;td>رشته به همراه دابل کوتیشن&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;span dir="ltr">%x&lt;/span>&lt;/td>
&lt;td>&lt;code>676f7068657273&lt;/code>&lt;/td>
&lt;td>خروجی هگز مقدار&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;span dir="ltr">% x&lt;/span>&lt;/td>
&lt;td>&lt;code>67 6f 70 68 65 72 73&lt;/code>&lt;/td>
&lt;td>خروجی هگز مقدار با فاصله&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="11516-قالببندی-بولین">
1.15.1.6 قالب‌بندی بولین
&lt;a class="anchor" href="#11516-%d9%82%d8%a7%d9%84%d8%a8%d8%a8%d9%86%d8%af%db%8c-%d8%a8%d9%88%d9%84%db%8c%d9%86">#&lt;/a>
&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Verb&lt;/th>
&lt;th>&lt;code>fmt.Printf(&amp;quot;{{Verb}}&amp;quot;, true)&lt;/code> خروجی&lt;/th>
&lt;th>توضیحات&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;span dir="ltr">%t&lt;/span>&lt;/td>
&lt;td>&lt;code>true&lt;/code>&lt;/td>
&lt;td>نمایش مقدار بولین در رشته&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="11516-قالببندی-اشارهگر-pointer">
1.15.1.6 قالب‌بندی اشاره‌گر (pointer)
&lt;a class="anchor" href="#11516-%d9%82%d8%a7%d9%84%d8%a8%d8%a8%d9%86%d8%af%db%8c-%d8%a7%d8%b4%d8%a7%d8%b1%d9%87%da%af%d8%b1-pointer">#&lt;/a>
&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Verb&lt;/th>
&lt;th>&lt;code>fmt.Printf(&amp;quot;{{Verb}}&amp;quot;, new(int))&lt;/code> خروجی&lt;/th>
&lt;th>توضیحات&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;span dir="ltr">%p&lt;/span>&lt;/td>
&lt;td>&lt;code>0xc0000b2000&lt;/code>&lt;/td>
&lt;td>نمایش آدرس حافظه با پایه ۱۶ به همراه 0x&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="1152-مقادیر-خاص-در-رشته">
1.15.2 مقادیر خاص در رشته
&lt;a class="anchor" href="#1152-%d9%85%d9%82%d8%a7%d8%af%db%8c%d8%b1-%d8%ae%d8%a7%d8%b5-%d8%af%d8%b1-%d8%b1%d8%b4%d8%aa%d9%87">#&lt;/a>
&lt;/h2>
&lt;p>همانطور که گفتیم زبان گو یکسری کارکترهای خاص دارد که باعث تغییراتی در خروجی رشته خواهد شد و این کارکترهای خاص بین همه زبان‌ها مشترک هستند. در ادامه لیست این کاراکتر‌ها را آورده‌ایم:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Verb&lt;/th>
&lt;th>توضیحات&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;span dir="ltr">\a&lt;/span>&lt;/td>
&lt;td>U+0007 هشدار یا زنگ&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;span dir="ltr">\b&lt;/span>&lt;/td>
&lt;td>U+0008 بک اسپیس backspace&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;span dir="ltr">\\ &lt;/span>&lt;/td>
&lt;td>U+005c بک اسلش backslash&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;span dir="ltr">\t&lt;/span>&lt;/td>
&lt;td>U+0009 تب بصورت افقی&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;span dir="ltr">\n&lt;/span>&lt;/td>
&lt;td>U+000A خط جدید&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;span dir="ltr">\f&lt;/span>&lt;/td>
&lt;td>U+000C حالت فرم&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;span dir="ltr">\r&lt;/span>&lt;/td>
&lt;td>U+000D حالت برگشت&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;span dir="ltr">\v&lt;/span>&lt;/td>
&lt;td>U+000b تب بصورت عمودی&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;span dir="ltr">%%&lt;/span>&lt;/td>
&lt;td>نمایش درصد برای حالت‌های خاص نظیر &lt;code>fmt.Printf(&amp;quot;%05.2f%%&amp;quot;, math.Pi)&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="1153-پکیج-strings-و-متد-های-پر-کاربرد-آن">
1.15.3 پکیج strings و متد های پر کاربرد آن
&lt;a class="anchor" href="#1153-%d9%be%da%a9%db%8c%d8%ac-strings-%d9%88-%d9%85%d8%aa%d8%af-%d9%87%d8%a7%db%8c-%d9%be%d8%b1-%da%a9%d8%a7%d8%b1%d8%a8%d8%b1%d8%af-%d8%a2%d9%86">#&lt;/a>
&lt;/h2>
&lt;p>برای کار با رشته ها، یکی از پکیج های پرکاربرد strings است که به‌صورت built-in در گولنگ وجود دارد. در این قسمت با برخی از متد های این پکیج آشنا می شویم.&lt;/p>
&lt;h2 id="11531-متد-contains-و-containsany">
1.15.3.1 متد Contains و ContainsAny
&lt;a class="anchor" href="#11531-%d9%85%d8%aa%d8%af-contains-%d9%88-containsany">#&lt;/a>
&lt;/h2>
&lt;p>با استفاده از این دو متد می توانید چک کنید که در رشته مدنظر شما، آن چیزی که می خواهید وجود دارد یا نه. فرق بین Contains و ContainsAny در این است که Contains باید دقیقا همان الگویی که داده اید داخل رشته پیدا شود اما ContainsAny حتی اگر یکی از کاراکتر ها وجود داشته باشد true بر میگرداند.&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;fmt&amp;quot;
&amp;quot;strings&amp;quot;
)
func main() {
text := &amp;quot;Go will make you love programming again. We promise&amp;quot;
fmt.Println(strings.Contains(text, &amp;quot;Golang&amp;quot;))
fmt.Println(strings.ContainsAny(text, &amp;quot;Golang&amp;quot;))
}
&lt;/code>&lt;/pre>
&lt;p>پس از اجرای کد. خروجی زیر را مشاهده می کنید.&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go run main.go
Result:
false
true
&lt;/code>&lt;/pre>
&lt;h2 id="11532-متد-count">
1.15.3.2 متد Count
&lt;a class="anchor" href="#11532-%d9%85%d8%aa%d8%af-count">#&lt;/a>
&lt;/h2>
&lt;p>با استفاده از این متد، می توانید تعداد تکرار یک الگو را بدست بیاورید. Count نسبت به بزرگ و کوچک بودن کلمات حساس است.&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;fmt&amp;quot;
&amp;quot;strings&amp;quot;
)
func main() {
text := &amp;quot;Golang go Go will make you love programming again. We promise&amp;quot;
fmt.Println(strings.Count(text, &amp;quot;Go&amp;quot;))
}
&lt;/code>&lt;/pre>
&lt;p>پس از اجرای کد. خروجی زیر را مشاهده می کنید.&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go run main.go
Result:
2
&lt;/code>&lt;/pre>
&lt;h2 id="11533-متد-index-و-lastindex">
1.15.3.3 متد Index و LastIndex
&lt;a class="anchor" href="#11533-%d9%85%d8%aa%d8%af-index-%d9%88-lastindex">#&lt;/a>
&lt;/h2>
&lt;p>با استفاده از متد های Index می توانیم اندیس قرارگرفتن کاراکتر مدنظر را پیدا کنیم. فرق بین Index و LastIndex این است که متد Index اولین کاراکتری که پیدا می کند اندیسش را برمیگرداند، اما LastIndex آخرین کاراکتری که پیدا می کند.&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;fmt&amp;quot;
&amp;quot;strings&amp;quot;
)
func main() {
text := &amp;quot;Go will make you love programming again. We promise&amp;quot;
fmt.Println(strings.Index(text, &amp;quot;o&amp;quot;))
fmt.Println(strings.LastIndex(text, &amp;quot;o&amp;quot;))
}
&lt;/code>&lt;/pre>
&lt;p>پس از اجرای کد. خروجی زیر را مشاهده می کنید.&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go run main.go
Result:
1
46
&lt;/code>&lt;/pre>
&lt;h2 id="11534-متد-split">
1.15.3.4 متد Split
&lt;a class="anchor" href="#11534-%d9%85%d8%aa%d8%af-split">#&lt;/a>
&lt;/h2>
&lt;p>با استفاده از متد Split می توانیم یک رشته را بر اساس یک الگویی(برای مثال space) تکه تکه کنیم. خروجی این متد یک slice از جنس string است.&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;fmt&amp;quot;
&amp;quot;strings&amp;quot;
)
func main() {
text := &amp;quot;Go will make you love programming again. We promise&amp;quot;
textSlice := strings.Split(text, &amp;quot; &amp;quot;)
for _, item := range textSlice {
fmt.Println(item)
}
}
&lt;/code>&lt;/pre>
&lt;p>پس از اجرای کد. خروجی زیر را مشاهده می کنید.&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go run main.go
Result:
Go
will
make
you
love
programming
again.
We
promise
&lt;/code>&lt;/pre>
&lt;h2 id="11535-متد-join">
1.15.3.5 متد Join
&lt;a class="anchor" href="#11535-%d9%85%d8%aa%d8%af-join">#&lt;/a>
&lt;/h2>
&lt;p>با Join می توانیم المنت های یک اسلایس از جنس string را با یک الگویی به یکدیگر بچسبانیم و در خروجی یک string از المنت های داخل اسلایس بدست بیاوریم. در این مثال text قبلی را که با Split تکه تکه کردیم و داخل textSlice ریختیم، با Join تبدیل به text می کنیم.&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;fmt&amp;quot;
&amp;quot;strings&amp;quot;
)
func main() {
// array of strings
textSlice := []string{&amp;quot;Go&amp;quot;, &amp;quot;will&amp;quot;, &amp;quot;make&amp;quot;, &amp;quot;you&amp;quot;, &amp;quot;love&amp;quot;, &amp;quot;programming&amp;quot;, &amp;quot;again.&amp;quot;, &amp;quot;We&amp;quot;, &amp;quot;promise&amp;quot;}
// joining the string by separator
fmt.Println(strings.Join(textSlice, &amp;quot; &amp;quot;))
}
&lt;/code>&lt;/pre>
&lt;p>پس از اجرای کد. خروجی زیر را مشاهده می کنید.&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go run main.go
Result:
Go will make you love programming again. We promise
&lt;/code>&lt;/pre>
&lt;h2 id="11536-متد-hasprefix-و-hassuffix">
1.15.3.6 متد HasPrefix و HasSuffix
&lt;a class="anchor" href="#11536-%d9%85%d8%aa%d8%af-hasprefix-%d9%88-hassuffix">#&lt;/a>
&lt;/h2>
&lt;p>با استفاده از HasPrefix می توانیم چک کنیم که اول رشته با چیزی که ما می خواهیم شروع شده است یا خیر. با HasSuffix می توانیم چک کنیم که اتمام رشته با آن چیزی که ما می خواهیم هست یا خیر.&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;fmt&amp;quot;
&amp;quot;strings&amp;quot;
)
func main() {
text := &amp;quot;Go will make you love programming again. We promise&amp;quot;
fmt.Println(&amp;quot;HasPrefix Go:&amp;quot;, strings.HasPrefix(text, &amp;quot;Go&amp;quot;))
fmt.Println(&amp;quot;HasPrefix se:&amp;quot;, strings.HasPrefix(text, &amp;quot;se&amp;quot;))
fmt.Println(&amp;quot;HasSuffix se:&amp;quot;, strings.HasSuffix(text, &amp;quot;se&amp;quot;))
fmt.Println(&amp;quot;HasSuffix Go:&amp;quot;, strings.HasSuffix(text, &amp;quot;Go&amp;quot;))
}
&lt;/code>&lt;/pre>
&lt;p>پس از اجرای کد. خروجی زیر را مشاهده می کنید.&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go run main.go
Result:
HasPrefix Go: true
HasPrefix se: false
HasSuffix se: true
HasSuffix Go: false
&lt;/code>&lt;/pre>
&lt;p>متد های پرکاربرد دیگری مانند Replace, ReplaceAll برای جاگزین کردن. متد های Compare و EqualFold برای مقایسه بین دو رشته. متد های Trim, TrimLeft, TrimRight برای حذف کردن کاراکتر های اضافی از اول و آخر رشته و &amp;hellip; نیز وجود دارند که پیشنهاد می کنم حتما مطالعه کنید.&lt;/p></description></item></channel></rss>