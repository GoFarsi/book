<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><author/><title>صفحه اصلی on زبان گو فارسی</title><link>https://book.gofarsi.ir/</link><description>Recent content in صفحه اصلی on زبان گو فارسی</description><generator>Hugo -- gohugo.io</generator><language>fa</language><copyright>2023 GoFarsi All rights reserved</copyright><atom:link href="https://book.gofarsi.ir/rss.xml" rel="self" type="application/rss+xml"/><item><author/><title>پیشگفتار</title><link>https://book.gofarsi.ir/preface/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/preface/</guid><description>&lt;ul>
&lt;li>
&lt;p>چرا از گو استفاده می‌کنیم؟&lt;/p>
&lt;p>وقتی در نوامبر سال ۲۰۰۹ رابرت گریسیمر، راب پایک و کن تامپسون برای اولین‌بار گو را بصورت عمومی انتشار دادند، خودشان مطمئن نبودند که به‌صورت گسترده مورد استفاده قرار می‌گیرد یا خیر. تا به تاریخ انتشار این مطلب، مشخص شده،‌گو بسیار فراگیرتر و رشد آن در صنعت وسیع‌تر از چیزی بوده‌است که ایجادکنندگان آن حدس می‌زدند.
این‌ها نمونه‌هایی از کاربرد گو در دنیای امروز تکنولوژی هستند:&lt;/p></description></item><item><author/><title>تاریخچه</title><link>https://book.gofarsi.ir/history/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/history/</guid><description>&lt;p>زبان گو (Go) در سال ۲۰۰۷ (به شمسی: ۱۳۸۶) توسط «شرکت گوگل» با هدف افزایش بهره‌وری برنامه‌نویسی در محیط چندهسته‌ای، رایانه‌های شبکه‌ای و کدبیس‌های بزرگ طراحی شد [&lt;a href="https://fa.wikipedia.org/wiki/%DA%AF%D9%88_%28%D8%B2%D8%A8%D8%A7%D9%86_%D8%A8%D8%B1%D9%86%D8%A7%D9%85%D9%87%E2%80%8C%D9%86%D9%88%DB%8C%D8%B3%DB%8C%29">به نقل از ویکی‌پدیا&lt;/a>] و سپس به عنوان یک زبان کامپایلری و تایپ استاتیک در نوامبر سال ۲۰۰۹ به‌صورت عمومی با هدف &lt;span class="tooltip" data-tooltip="efficient compilation" ontouchend="toggleTooltip(this)">کامپایل کارآمد&lt;/span>
، &lt;span class="tooltip" data-tooltip="efficient execution" ontouchend="toggleTooltip(this)">اجرای کارآمد&lt;/span>
و &lt;span class="tooltip" data-tooltip="ease of programming" ontouchend="toggleTooltip(this)">سهولت برنامه‌نویسی&lt;/span>
عرضه شد. بسیاری از اعضای تیم طراحی و توسعه زبان گو [&lt;a href="https://en.wikipedia.org/wiki/Ken_Thompson">Ken Thompson&lt;/a>, &lt;a href="https://en.wikipedia.org/wiki/Rob_Pike">Rob Pike&lt;/a>, &lt;a href="https://en.wikipedia.org/wiki/Robert_Griesemer">Robert Griesemer&lt;/a>] سال‌ها تجربه در زمینه تحقیق و توسعه زبان برنامه‌نویسی دارند.&lt;/p></description></item><item><author/><title>چرا زبان Go؟</title><link>https://book.gofarsi.ir/why-go/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/why-go/</guid><description>&lt;p>زبان Go (یا Golang) با تأکید بر &lt;strong>سادگی سینتکسی، سرعت بالا، و پشتیبانی قوی از همزمانی&lt;/strong>، گزینه‌ای بی‌نظیر برای توسعه‌دهندگان و تیم‌های مهندسی نرم‌افزار به‌شمار می‌آید. Go با بهره‌گیری از &lt;strong>کامپایل سریع و استاتیک&lt;/strong>، اجرای باینری‌های مستقل با سرعتی نزدیک به زبان‌های سطح پایین را ممکن می‌سازد. یکی از برجسته‌ترین قابلیت‌های آن، مدل درون‌ساختاری همزمانی مبتنی بر &lt;strong>goroutine&lt;/strong> و &lt;strong>channel&lt;/strong> است که پردازش موازی با مصرف حافظه بهینه را تسهیل می‌کند. علاوه بر این، وجود &lt;strong>جمع‌آوری خودکار حافظه (GC)&lt;/strong> و مجموعه ابزار استاندارد (از جمله go fmt، go test، go doc و…) روند توسعه را شفاف و قابل‌پیش‌بینی می‌کند. با پشتوانه رسمی گوگل و پذیرش گسترده در پروژه‌های ابری، زیرساخت‌ها و شرکت‌های مطرح (مثل Docker، Kubernetes، Uber)، Go به ابزاری کلیدی در اکوسیستم مدرن توسعه نرم‌افزار تبدیل شده است.&lt;/p></description></item><item><author/><title>آموزش نصب</title><link>https://book.gofarsi.ir/installation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/installation/</guid><description>&lt;p>جهت نصب زبان گو بر روی سیستم عامل مورد نظر خود در ابتدا باید نسخه مناسب با پلت‌فرم خود را &lt;a href="https://go.dev/dl/">دانلود&lt;/a> کنید.&lt;/p>
&lt;p>&lt;img src="../assets/img/content/installation/1.png" alt="Featured downloads golang" />&lt;/p>
&lt;p>نکته:&lt;/p>
&lt;p>وب سایت گولنگ ایران را تحریم کرده است و احتمالا برای دانلود کردن گولنگ با مشکل مواجه می شوید. برای اینکه بتوانید تحریم ها را دور بزنید، روش های زیادی وجود دارد. یکی از مرسوم ترین روش ها استفاده از یک سرویس دی ان اس مانند &lt;a href="https://shecan.ir/">شکن&lt;/a> است.&lt;/p></description></item><item><author/><title>ابزارها, دستورات گو و معرفی IDE</title><link>https://book.gofarsi.ir/toolchain/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/toolchain/</guid><description>&lt;p>پس از اینکه زبان گو را برروی سیستم خود نصب کردید از طریق &lt;span class="tooltip" data-tooltip="Terminal" ontouchend="toggleTooltip(this)">ترمینال&lt;/span>
و یا &lt;span class="tooltip" data-tooltip="Command prompt" ontouchend="toggleTooltip(this)">خط فرمان&lt;/span>
ویندوز قابل دسترس است که می‌توانید با زدن کلمه &lt;code>go&lt;/code> یکسری عملیات انجام دهید:&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go
Go is a tool for managing Go source code.
Usage:
go &amp;lt;command&amp;gt; [arguments]
The commands are:
bug start a bug report
build compile packages and dependencies
clean remove object files and cached files
doc show documentation for package or symbol
env print Go environment information
fix update packages to use new APIs
fmt gofmt (reformat) package sources
generate generate Go files by processing source
get add dependencies to current module and install them
install compile and install packages and dependencies
list list packages or modules
mod module maintenance
work workspace maintenance
run compile and run Go program
test test packages
tool run specified go tool
version print Go version
vet report likely mistakes in packages
Use &amp;quot;go help &amp;lt;command&amp;gt;&amp;quot; for more information about a command.
Additional help topics:
buildconstraint build constraints
buildmode build modes
c calling between Go and C
cache build and test caching
environment environment variables
filetype file types
go.mod the go.mod file
gopath GOPATH environment variable
gopath-get legacy GOPATH go get
goproxy module proxy protocol
importpath import path syntax
modules modules, module versions, and more
module-get module-aware go get
module-auth module authentication using go.sum
packages package lists and patterns
private configuration for downloading non-public code
testflag testing flags
testfunc testing functions
vcs controlling version control with GOVCS
Use &amp;quot;go help &amp;lt;topic&amp;gt;&amp;quot; for more information about that topic.
&lt;/code>&lt;/pre>
&lt;h2 id="جدول-دستورات-commands">
جدول دستورات (Commands)
&lt;a class="anchor" href="#%d8%ac%d8%af%d9%88%d9%84-%d8%af%d8%b3%d8%aa%d9%88%d8%b1%d8%a7%d8%aa-commands">#&lt;/a>
&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>دستور&lt;/th>
&lt;th>توضیحات&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>build&lt;/td>
&lt;td>با این دستور (&lt;code>go build main.go&lt;/code>) می‌توانید فایل &lt;code>go&lt;/code> را کامپایل کنید.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>clean&lt;/td>
&lt;td>با این دستور می‌توانید فایل‌های کش‌شده را پاکسازی کنید.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>doc&lt;/td>
&lt;td>با این دستور (&lt;code>go doc fmt.Println&lt;/code>) می‌توانید داکیومنت هر یک از توابع عمومی را ببینید.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>env&lt;/td>
&lt;td>با این دستور می‌توانید &lt;span class="tooltip" data-tooltip="environment variable" ontouchend="toggleTooltip(this)">متغیرهای محیطی&lt;/span>
تنظیم شده زبان گو را ببینید و آن‌ها را با دستور &lt;code>go env -w key=value&lt;/code> مقداردهی کنید.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>fmt&lt;/td>
&lt;td>با این دستور می‌توانید کدهای خود را مرتب &lt;code>go fmt ./...&lt;/code> کنید.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>install&lt;/td>
&lt;td>با استفاده از این دستور می‌توانید یکسری پکیج‌ها را گرفته و کامپایل کنید.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>list&lt;/td>
&lt;td>لیست پکیج‌ها و ماژول‌های دانلود شده.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>generate&lt;/td>
&lt;td>با این دستور می‌توانید از قابلیت Generator زبان گو استفاده کنید و فایل generate کنید.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>mod&lt;/td>
&lt;td>برای مدیریت و ایجاد فایل mod به ازای هر پروژه.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>get&lt;/td>
&lt;td>با این دستور می‌توانید پکیجی را دانلود یا بروزرسانی کنید و همچنین برای استفاده از این دستور نیاز به &lt;code>git&lt;/code> دارید که نصب باشد.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>work&lt;/td>
&lt;td>با این دستور می‌توانید یک workspace ایجاد کنید و آن را مدیریت کنید.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>run&lt;/td>
&lt;td>با این دستور (&lt;code>go run main.go&lt;/code>) می‌توانید فایل‌های گو یا پروژه را اجرا کنید.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>test&lt;/td>
&lt;td>با این دستور (&lt;code>go test example_test.go&lt;/code>) می‌توانید فایل‌های تست را اجرا کنید.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>version&lt;/td>
&lt;td>با این دستور می‌توانید نسخه نصب شده زبان گو را ببینید.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>vet&lt;/td>
&lt;td>با این دستور می‌توانید اشتباهات کدهای خود را ببینید.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="اجرای-کد-ساده-در-زبان-گو">
اجرای کد ساده در زبان گو
&lt;a class="anchor" href="#%d8%a7%d8%ac%d8%b1%d8%a7%db%8c-%da%a9%d8%af-%d8%b3%d8%a7%d8%af%d9%87-%d8%af%d8%b1-%d8%b2%d8%a8%d8%a7%d9%86-%da%af%d9%88">#&lt;/a>
&lt;/h2>
&lt;p>در زیر یک نمونه کد ساده قرار دادیم که به سادگی می‌توانید با دستور &lt;code>go run main.go&lt;/code> اجرا کنید و خروجی را ببینید.&lt;/p></description></item><item><author/><title>نقشه یادگیری زبان گو</title><link>https://book.gofarsi.ir/roadmap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/roadmap/</guid><description>&lt;p>نقشه یادگیری زیر &lt;a href="https://roadmap.sh/">roadmap.sh&lt;/a> به ترتیب مسیر توصیه شده ی یادگیری ابزارها و مفاهیم اولیه گو، سپس سمت سرور و در نهایت معماری نرم افزار را نشان می‌دهد.&lt;/p>
&lt;p>&lt;img src="../assets/img/content/roadmap/go.jpg" alt="roadmap go" />
&lt;img src="../assets/img/content/roadmap/backend.jpg" alt="roadmap backend" />
&lt;img src="../assets/img/content/roadmap/software-design.jpg" alt="software design" />
&lt;img src="../assets/img/content/roadmap/software-architect.jpg" alt="software architect" />&lt;/p></description></item><item><author/><title>نمونه سوالات مصاحبه</title><link>https://book.gofarsi.ir/interview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/interview/</guid><description>&lt;p>در این بخش ما یکسری سوالات مصاحبه به زبان فارسی ارائه دادیم که برای یافتن ضعف‌ها کاربردی می‌باشد.&lt;/p>
&lt;details >&lt;summary>1: چه تایپ‌هایی مقدار zero آن‌ها nil است؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;ul>
&lt;li>interfaces&lt;/li>
&lt;li>slices&lt;/li>
&lt;li>channels&lt;/li>
&lt;li>maps&lt;/li>
&lt;li>pointers&lt;/li>
&lt;li>functions&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>2: تایپ‌های نوع Reference؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;ul>
&lt;li>Pointers&lt;/li>
&lt;li>slices&lt;/li>
&lt;li>maps&lt;/li>
&lt;li>functions&lt;/li>
&lt;li>channels&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>3: تایپ‌های نوع Aggregate؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;ul>
&lt;li>Array&lt;/li>
&lt;li>structs&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/details>
&lt;details >&lt;summary>4: چه وقت باید از پوینتر استفاده کنیم؟&lt;/summary>
&lt;div class="markdown-inner">
&lt;p>&lt;strong>1- تابعی که یکی از پارامترهای خود را تغییر می‌دهد&lt;/strong>
-وقتی تابعی را فراخوانی می‌کنیم که یک پوینتر را به عنوان پارامتر می‌گیرد، انتظار داریم که متغیر ما تغییر داده شود. اگر شما متغیر را در تابع خود تغییر نمی‌دهید، پس احتمالا نباید از پوینتر استفاده کنید.&lt;/p></description></item><item><author/><title>1.1 ساختار کد گو</title><link>https://book.gofarsi.ir/chapter-1/structure-of-go-code/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-1/structure-of-go-code/</guid><description>&lt;p>همانطور که در تاریخچه زبان گو گفتیم, زبان گو سینتکس خیلی تمیز و ساده‌ای دارد که به راحتی می‌توانید کدهای زبان گو را بخوانید. در ادامه ما سعی می‌کنیم با مثال‌های ساده شما را با ساختار کد زبان گو آشنا کنیم.&lt;/p>
&lt;blockquote class="book-hint info">
&lt;strong>به نقل از تاریخچه&lt;/strong>
سینتکس زبان گو به گونه‌ای طراحی شده که خیلی ساده و تمیز است و این باعث می‌شود خیلی سریع زبان گو را یاد بگیرید و از همه مهم‌تر توسعه پروژه‌های &lt;span class="tooltip" data-tooltip="Scale up" ontouchend="toggleTooltip(this)">مقیاس پذیر&lt;/span>
با زبان گو به دلیل سادگی و آشکار بودن مفاهیم خیلی سریع‌تر صورت‌ گیرد.
&lt;/blockquote>
&lt;h2 id="110-زبان-برنامهنویسی">
1.1.0 زبان برنامه‌نویسی
&lt;a class="anchor" href="#110-%d8%b2%d8%a8%d8%a7%d9%86-%d8%a8%d8%b1%d9%86%d8%a7%d9%85%d9%87%d9%86%d9%88%db%8c%d8%b3%db%8c">#&lt;/a>
&lt;/h2>
&lt;p>یک زبان برنامه‌نویسی یک زبان مصنوعی انگلیسی است که برای بیان محاسباتی که توسط یک ماشین (مخصوصاً رایانه) قابل انجام است، طراحی شده‌ است. زبان‌های برنامه‌نویسی برای ایجاد برنامه‌هایی به کار می‌روند که رفتار یک ماشین را مشخص می‌کنند، الگوریتم دقیق را بیان می‌کنند، یا روشی برای تعامل انسان و رایانه هستند. بسیاری از زبان‌های برنامه‌نویسی تعدادی قالب از ویژگی‌های نوشته شده دستوری یا نحو (syntax) و معناشناسی (semantics) دارند، چرا که رایانه‌ها دستورهای دقیقاً مشخص نیاز دارند. برخی توسط سند خصوصیات (specification document) تعیین شده‌اند (برای مثال یک استاندارد ISO)، در حالی که برخی دیگر دارای پیاده‌سازی غالبی هستند. [&lt;a href="https://fa.wikipedia.org/wiki/%D8%B2%D8%A8%D8%A7%D9%86_%D8%A8%D8%B1%D9%86%D8%A7%D9%85%D9%87%E2%80%8C%D9%86%D9%88%DB%8C%D8%B3%DB%8C">به نقل از ویکی‌پدیا&lt;/a>].&lt;/p></description></item><item><author/><title>1.2 کلید واژه و شناسه‌ها</title><link>https://book.gofarsi.ir/chapter-1/go-built-in-keywords-identifiers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-1/go-built-in-keywords-identifiers/</guid><description>&lt;p>در این بخش قصد داریم به &lt;span class="tooltip" data-tooltip="keyword" ontouchend="toggleTooltip(this)">کلید واژه&lt;/span>
و &lt;span class="tooltip" data-tooltip="identifier" ontouchend="toggleTooltip(this)">شناسه&lt;/span>
های زبان گو بپردازیم.&lt;/p>
&lt;h2 id="121-کلید-واژه">
1.2.1 کلید واژه
&lt;a class="anchor" href="#121-%da%a9%d9%84%db%8c%d8%af-%d9%88%d8%a7%da%98%d9%87">#&lt;/a>
&lt;/h2>
&lt;p>زبان گو تا &lt;span class="tooltip" data-tooltip="1.1.23" ontouchend="toggleTooltip(this)">نسخه فعلی&lt;/span>
فقط ۲۵ تا کلید واژه دارد که به شرح زیر ست:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>1&lt;/th>
&lt;th>2&lt;/th>
&lt;th>3&lt;/th>
&lt;th>4&lt;/th>
&lt;th>5&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>break&lt;/td>
&lt;td>default&lt;/td>
&lt;td>func&lt;/td>
&lt;td>interface&lt;/td>
&lt;td>select&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>case&lt;/td>
&lt;td>defer&lt;/td>
&lt;td>go&lt;/td>
&lt;td>map&lt;/td>
&lt;td>struct&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3&lt;/td>
&lt;td>chan&lt;/td>
&lt;td>else&lt;/td>
&lt;td>goto&lt;/td>
&lt;td>package&lt;/td>
&lt;td>switch&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>4&lt;/td>
&lt;td>const&lt;/td>
&lt;td>fallthrough&lt;/td>
&lt;td>if&lt;/td>
&lt;td>range&lt;/td>
&lt;td>type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>5&lt;/td>
&lt;td>continue&lt;/td>
&lt;td>for&lt;/td>
&lt;td>import&lt;/td>
&lt;td>return&lt;/td>
&lt;td>var&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>کلمات کلیدی فوق به ۴ دسته تقسیم می‌شوند که به شرح زیر است:&lt;/p></description></item><item><author/><title>1.3 تایپ‌های پایه</title><link>https://book.gofarsi.ir/chapter-1/go-basic-types/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-1/go-basic-types/</guid><description>&lt;h2 id="131-تایپ-چیست">
1.3.1 تایپ چیست؟
&lt;a class="anchor" href="#131-%d8%aa%d8%a7%db%8c%d9%be-%da%86%db%8c%d8%b3%d8%aa">#&lt;/a>
&lt;/h2>
&lt;p>یک تایپ مشخص کننده نوع داده است، که به کامپایلر می‌گوید قرار است چه نوع داده‌ای داخل یک متغیر ذخیره گردد. زبان‌ها انواع تایپ‌های مختلفی به صورت پیش‌فرض دارند که می‌توان از آن‌ها داخل برنامه خود استفاده کرد.
ما می‌توانیم تایپ‌ها را به دو دسته کلی تعریف کنیم.&lt;/p></description></item><item><author/><title>1.4 عملگرها</title><link>https://book.gofarsi.ir/chapter-1/go-operators/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-1/go-operators/</guid><description>&lt;p>زبان گو مثل سایر زبان‌ها دارای یکسری &lt;span class="tooltip" data-tooltip="Oprators" ontouchend="toggleTooltip(this)">عملگرها&lt;/span>
مانند: عملگرهای حسابی, عملگرهای مقایسه‌ای, عملگرهای منطقی و عملگرهای بیتی است.&lt;/p>
&lt;h2 id="141-عملگرهای-حسابی">
1.4.1 عملگرهای حسابی
&lt;a class="anchor" href="#141-%d8%b9%d9%85%d9%84%da%af%d8%b1%d9%87%d8%a7%db%8c-%d8%ad%d8%b3%d8%a7%d8%a8%db%8c">#&lt;/a>
&lt;/h2>
&lt;p>زبان گو دارای ۵ تا عملگر حسابی است که به ترتیب:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>عملگر&lt;/th>
&lt;th>نام&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>+&lt;/code>&lt;/td>
&lt;td>جمع&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>-&lt;/code>&lt;/td>
&lt;td>تفریق&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>*&lt;/code>&lt;/td>
&lt;td>ضرب&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>/&lt;/code>&lt;/td>
&lt;td>تقسیم&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>%&lt;/code>&lt;/td>
&lt;td>باقی مانده&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>این ۵ تا عملگر اغلب به ترتیب مجموع, تفاوت, حاصل‌ضرب و ضریب نیز نامیده می‌شوند.&lt;/p>
&lt;pre>&lt;code class="language-go"> a := 1
b := 2
c := a + b // 3
d := a - b // -1
e := a * b // 2
f := a / b // 0
g := a % b // 1
&lt;/code>&lt;/pre>
&lt;blockquote class="book-hint info">
در نمونه کد بالا ما از عملگر &lt;code>:=&lt;/code> که شیوه تعریف متغیر به روش کوتاه است استفاده کردیم که در بخش &lt;a href="https://book.gofarsi.ir/chapter-1/go-variables-and-consts/">1.5 متغیرها و ثابت ها معرفی&lt;/a> خواهیم کرد.
&lt;/blockquote>
&lt;h2 id="142-عملگرهای-مقایسهای">
1.4.2 عملگرهای مقایسه‌ای
&lt;a class="anchor" href="#142-%d8%b9%d9%85%d9%84%da%af%d8%b1%d9%87%d8%a7%db%8c-%d9%85%d9%82%d8%a7%db%8c%d8%b3%d9%87%d8%a7%db%8c">#&lt;/a>
&lt;/h2>
&lt;p>زبان گو دارای ۶ عملگر مقایسه‌ای است که به ترتیب:&lt;/p></description></item><item><author/><title>1.5 متغیرها و constant</title><link>https://book.gofarsi.ir/chapter-1/go-variables-and-consts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-1/go-variables-and-consts/</guid><description>&lt;h2 id="151-متغیر-variable">
1.5.1 متغیر (Variable)
&lt;a class="anchor" href="#151-%d9%85%d8%aa%d8%ba%db%8c%d8%b1-variable">#&lt;/a>
&lt;/h2>
&lt;p>در برنامه‌نویسی رایانه، یک &lt;span class="tooltip" data-tooltip="Variable" ontouchend="toggleTooltip(this)">متغیر&lt;/span>
یک مکان در حافظه (آدرس حافظه) است که دارای یک نام نمادین با عنوان است و می‌تواند حاوی اطلاعات یا یک مقدار معلوم یا مجهول که به آن &lt;span class="tooltip" data-tooltip="Value" ontouchend="toggleTooltip(this)">ارزش یا مقدار&lt;/span>
می‌گویند، باشد. به زبان دیگر، متغیر در برنامه‌نویسی به فضایی که برای ذخیره داده‌ها کنار گذاشته شده‌ است می‌گویند (&lt;a href="https://fa.wikipedia.org/wiki/%D9%85%D8%AA%D8%BA%DB%8C%D8%B1_%28%D8%A8%D8%B1%D9%86%D8%A7%D9%85%D9%87%E2%80%8C%D9%86%D9%88%DB%8C%D8%B3%DB%8C%29">به نقل از سایت ویکی‌پدیا&lt;/a>)&lt;/p>
&lt;h3 id="تعریف-یک-متغیر-رشته">
تعریف یک متغیر رشته
&lt;a class="anchor" href="#%d8%aa%d8%b9%d8%b1%db%8c%d9%81-%db%8c%da%a9-%d9%85%d8%aa%d8%ba%db%8c%d8%b1-%d8%b1%d8%b4%d8%aa%d9%87">#&lt;/a>
&lt;/h3>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"fmt"
)
func main() {
var s string = "Hello World"
fmt.Println(s)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;ol>
&lt;li>یک &lt;span class="tooltip" data-tooltip="Variable" ontouchend="toggleTooltip(this)">متغیر&lt;/span>
با استفاده از &lt;span class="tooltip" data-tooltip="keyword" ontouchend="toggleTooltip(this)">کلید واژه&lt;/span>
&lt;code>var&lt;/code> ایجاد کردیم.&lt;/li>
&lt;li>نام &lt;span class="tooltip" data-tooltip="Variable" ontouchend="toggleTooltip(this)">متغیر&lt;/span>
را &lt;code>s&lt;/code> گذاشتیم.&lt;/li>
&lt;li>تایپ &lt;span class="tooltip" data-tooltip="Variable" ontouchend="toggleTooltip(this)">متغیر&lt;/span>
را از نوع &lt;code>string&lt;/code> تعیین کردیم.&lt;/li>
&lt;li>سپس با عملگر &lt;code>=&lt;/code> مقدار &lt;span class="tooltip" data-tooltip="Variable" ontouchend="toggleTooltip(this)">متغیر&lt;/span>
را مشخص از نوع رشته تعیین کردیم.&lt;/li>
&lt;li>رشته &lt;code>&amp;quot;Hello World&amp;quot;&lt;/code> به عنوان مقدار &lt;span class="tooltip" data-tooltip="Variable" ontouchend="toggleTooltip(this)">متغیر&lt;/span>
&lt;code>s&lt;/code> است و این مقدار در خانه مشخصی از حافظه قرار داده شده است.&lt;/li>
&lt;li>از پکیج استاندارد &lt;code>fmt&lt;/code> برای چاپ مقدار &lt;span class="tooltip" data-tooltip="Variable" ontouchend="toggleTooltip(this)">متغیر&lt;/span>
&lt;code>s&lt;/code> استفاده کردیم که این پکیج یکسری توابع جهت انجام عملیات‌های مختلفی نظیر چاپ مقادیر را دارد که در کد بالا ما از تابع &lt;code>Println&lt;/code> استفاده کردیم.&lt;/li>
&lt;/ol>
&lt;h3 id="1511-اختصاص-مقدار-جدید-به-متغیر-از-قبل-ایجاد-شده">
1.5.1.1 اختصاص مقدار جدید به متغیر از قبل ایجاد شده
&lt;a class="anchor" href="#1511-%d8%a7%d8%ae%d8%aa%d8%b5%d8%a7%d8%b5-%d9%85%d9%82%d8%af%d8%a7%d8%b1-%d8%ac%d8%af%db%8c%d8%af-%d8%a8%d9%87-%d9%85%d8%aa%d8%ba%db%8c%d8%b1-%d8%a7%d8%b2-%d9%82%d8%a8%d9%84-%d8%a7%db%8c%d8%ac%d8%a7%d8%af-%d8%b4%d8%af%d9%87">#&lt;/a>
&lt;/h3>
&lt;p>در کد زیر ما یک &lt;span class="tooltip" data-tooltip="Variable" ontouchend="toggleTooltip(this)">متغیر&lt;/span>
از قبل تعریف کردیم و مقدار جدید را در خط ۹ به &lt;span class="tooltip" data-tooltip="Variable" ontouchend="toggleTooltip(this)">متغیر&lt;/span>
اختصاص دادیم.&lt;/p></description></item><item><author/><title>1.6 مقادیر صفر تایپ‌ها (zero values)</title><link>https://book.gofarsi.ir/chapter-1/go-zero-values/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-1/go-zero-values/</guid><description>&lt;p>در جدول زیر فهرست تمامی تایپ‌ها را با مقادیر صفرشان &lt;code>(پیش‌فرض)&lt;/code> قرار دادیم:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>تایپ&lt;/th>
&lt;th>مقدار پیش فرض یا مقدار صفر&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>int&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>int8&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>int16&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>int32&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>int64&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>uint&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>uint8&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>uint16&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>uint32&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>uint64&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>uintptr&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>float32&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>float64&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>complex64&lt;/td>
&lt;td>0+0i&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>complex128&lt;/td>
&lt;td>0+0i&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>bool&lt;/td>
&lt;td>false&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>string&lt;/td>
&lt;td>&amp;quot;&amp;quot;&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>interface&lt;/td>
&lt;td>nil&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>slice&lt;/td>
&lt;td>nil&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>channel&lt;/td>
&lt;td>nil&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>map&lt;/td>
&lt;td>nil&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>pointer&lt;/td>
&lt;td>nil&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>function&lt;/td>
&lt;td>nil&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>struct&lt;/td>
&lt;td>براساس مقدار پیش فرض فیلدها&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>نمونه کد نمایش مقدار صفر تایپ‌ها:&lt;/p></description></item><item><author/><title>1.7 تابع (function)</title><link>https://book.gofarsi.ir/chapter-1/go-function/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-1/go-function/</guid><description>&lt;h2 id="171-تابع-چیست">
1.7.1 تابع چیست؟
&lt;a class="anchor" href="#171-%d8%aa%d8%a7%d8%a8%d8%b9-%da%86%db%8c%d8%b3%d8%aa">#&lt;/a>
&lt;/h2>
&lt;p>در برنامه‌نویسی، &lt;strong>تابع&lt;/strong> به تکه کدهایی گفته می‌شود که برای انجام عملی خاص استفاده می‌شوند. به کمک توابع می‌توانیم تکه کدها را از یکدیگر جدا کنیم و از تکرار کدها جلوگیری کنیم.&lt;/p>
&lt;p>همانند شکل زیر تابع مانند یک جعبه (یا قطعه کد) است. که یک مقدار ورودی گرفته و روی آن پردازش‌هایی انجام می‌دهد و یک خروجی تولید می‌کند. تابع می‌تواند هر چندتا ورودی یا خروجی داشته باشد.
&lt;img src="https://res.cloudinary.com/practicaldev/image/fetch/s--iCkOfD0L--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://cdn-images-1.medium.com/max/1024/1%2A709ugF12LLkYxvb839YNlg.png" alt="" />&lt;/p></description></item><item><author/><title>1.8 آرایه و slice</title><link>https://book.gofarsi.ir/chapter-1/go-array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-1/go-array/</guid><description>&lt;p>&lt;span class="tooltip" data-tooltip="array" ontouchend="toggleTooltip(this)">آرایه&lt;/span>
و slice دو نوع تایپ با یک وجه اشتراک در زبان گو هستند ولی این دو نوع تایپ یکسری تفاوت‌هایی نیز با هم دارند که در ادامه به آن‌ها می‌پردازیم.&lt;/p>
&lt;h2 id="181-تعریف-آرایه">
1.8.1 تعریف آرایه
&lt;a class="anchor" href="#181-%d8%aa%d8%b9%d8%b1%db%8c%d9%81-%d8%a2%d8%b1%d8%a7%db%8c%d9%87">#&lt;/a>
&lt;/h2>
&lt;p>&lt;span class="tooltip" data-tooltip="array" ontouchend="toggleTooltip(this)">آرایه&lt;/span>
یکی از عمومی‌ترین تایپ‌ها در زبان‌های برنامه‌نویسی آرایه‌ها هستند که برای نگه داری گروهی مقادیر از یک نوع تایپ استفاده می‌شود.
برای دسترسی به هر کدام از مقادیر درون آرایه باید از &lt;span class="tooltip" data-tooltip="Index" ontouchend="toggleTooltip(this)">اندیس&lt;/span>
استفاده کرد.
معمولا برای تعریف آرایه تعداد مشخص و ثابتی را برای تعداد مقادیر مشخص میکنید. یعنی این آرایه قرار است چند تا مقدار نگه داری کند.&lt;/p></description></item><item><author/><title>1.9 حلقه‌ها (for)</title><link>https://book.gofarsi.ir/chapter-1/go-for/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-1/go-for/</guid><description>&lt;h2 id="191-حلقه">
1.9.1 حلقه
&lt;a class="anchor" href="#191-%d8%ad%d9%84%d9%82%d9%87">#&lt;/a>
&lt;/h2>
&lt;p>حلقه‌ها را در زبان گو به ساده‌ترین شکل ممکن و فقط با استفاده از کلید واژه for و در مدل‌های مختلف (سه‌بخشی، بی نهایت، foreach و &amp;hellip;) می‌توان پیاده‌سازی کرد.&lt;/p>
&lt;h2 id="192-حلقه-سه-بخشی">
1.9.2 حلقه سه بخشی
&lt;a class="anchor" href="#192-%d8%ad%d9%84%d9%82%d9%87-%d8%b3%d9%87-%d8%a8%d8%ae%d8%b4%db%8c">#&lt;/a>
&lt;/h2>
&lt;p>این نمونه که متداول‌ترین نوع حلقه &lt;code>for&lt;/code> نیز هستند با استفاده از سه‌ بخش:&lt;/p>
&lt;ul>
&lt;li>مقداردهی&lt;/li>
&lt;li>شرط&lt;/li>
&lt;li>شمارنده&lt;/li>
&lt;/ul>
&lt;p>ایجاد می‌شوند.&lt;/p>
&lt;pre>&lt;code class="language-go">for initialization ; condition ; counter {
//loop codes
}
&lt;/code>&lt;/pre>
&lt;p>در مثال زیر نمونه‌ای از این حلقه‌ قابل مشاهده و اجرا است.
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
sum := 0
for i := 1; i &lt; 10; i++ {
sum += i
}
fmt.Println(sum)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;/p></description></item><item><author/><title>1.10 نقشه map</title><link>https://book.gofarsi.ir/chapter-1/go-map/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-1/go-map/</guid><description>&lt;h2 id="1101-مقدمه">
1.10.1 مقدمه
&lt;a class="anchor" href="#1101-%d9%85%d9%82%d8%af%d9%85%d9%87">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>&lt;span class="tooltip" data-tooltip="map" ontouchend="toggleTooltip(this)">نقشه&lt;/span>
، یک نوع ساختار داده است.&lt;/li>
&lt;li>&lt;span class="tooltip" data-tooltip="map" ontouchend="toggleTooltip(this)">نقشه&lt;/span>
ها جهت جمع‌آوری و نگهداری مجموعه‌ای از داده‌ها استفاده می‌گردند.&lt;/li>
&lt;li>&lt;span class="tooltip" data-tooltip="map" ontouchend="toggleTooltip(this)">نقشه&lt;/span>
، از نوع داده‌های &lt;span class="tooltip" data-tooltip="associative data type" ontouchend="toggleTooltip(this)">انجمنی&lt;/span>
(هش) بصورت &lt;span class="tooltip" data-tooltip="key-value" ontouchend="toggleTooltip(this)">«کلید-مقدار»&lt;/span>
است.&lt;/li>
&lt;li>&lt;span class="tooltip" data-tooltip="map" ontouchend="toggleTooltip(this)">نقشه&lt;/span>
، مجموعه‌ای از داده‌ها بصورت &lt;span class="tooltip" data-tooltip="unordered key:value pairs" ontouchend="toggleTooltip(this)">جفت‌‌های مرتب‌نشده&lt;/span>
است.&lt;/li>
&lt;/ul>
&lt;h2 id="1102-تعریف">
1.10.2 تعریف
&lt;a class="anchor" href="#1102-%d8%aa%d8%b9%d8%b1%db%8c%d9%81">#&lt;/a>
&lt;/h2>
&lt;p>یک مپ شبیه به فرمت زیر است:&lt;/p>
&lt;pre>&lt;code class="language-go">map[KeyType]ValueType
&lt;/code>&lt;/pre>
&lt;p>کلمه کلیدی &lt;code>map&lt;/code> و بعد نوع کلید و در آخر هم نوع مقدار تعریف می‌شود.&lt;/p></description></item><item><author/><title>1.11 شرط (if, switch)</title><link>https://book.gofarsi.ir/chapter-1/go-if-switch/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-1/go-if-switch/</guid><description>&lt;h2 id="1111-شرط-if-else">
1.11.1 شرط (if-else)
&lt;a class="anchor" href="#1111-%d8%b4%d8%b1%d8%b7-if-else">#&lt;/a>
&lt;/h2>
&lt;p>زبان گو همانند سایر زبان‌ها دارای &lt;span class="tooltip" data-tooltip="if-else" ontouchend="toggleTooltip(this)">شرط&lt;/span>
است که شما خیلی ساده می‌توانید از آن استفاده کنید. در مثال زیر ما فرمت استاندارد &lt;span class="tooltip" data-tooltip="if-else" ontouchend="toggleTooltip(this)">شرط&lt;/span>
در زبان گو را قرار دادیم:&lt;/p>
&lt;pre>&lt;code class="language-go">if condition {
//Do something
} else if condition {
//Do something
} else {
//Do something
}
&lt;/code>&lt;/pre>
&lt;p>در بالا &lt;strong>condition&lt;/strong> عبارتی است که قرار است وضعیت شرط را مشخص کند و در صورت &lt;strong>true&lt;/strong> شدن شرط بر قرار می‌شود و در صورت برقرار نشدن شرط اول، برنامه وارد else if می‌شود و مجدد یک &lt;strong>condition&lt;/strong> دیگری را چک می‌کند که وضعیتش &lt;strong>true&lt;/strong> می‌شود یا خیر و در نهایت منتهی می‌شود به &lt;strong>else&lt;/strong>.&lt;/p></description></item><item><author/><title>1.12 اضافه کردن پکیج در کد (package)</title><link>https://book.gofarsi.ir/chapter-1/go-package/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-1/go-package/</guid><description>&lt;p>زبان برنامه‌نویسی گو به شکلی طراحی شده است تا بتوانیم شیو‌ه‌های خوب مهندسی نرم‌افزار را به سادگی پیاده‌سازی کنیم. یکی از الگوهای مهم برای ارتقای کیفیت یک نرم افزار استفاده از DRY principle است. کلمه DRY مخفف &lt;strong>D&lt;/strong>on’t &lt;strong>R&lt;/strong>epeat &lt;strong>Y&lt;/strong>ourself &lt;code>همون چرخ رو دوباره اختراع نکن خودمون&lt;/code> است, که اگر به صورت خیلی ساده بیانش کنیم یعنی، کدی که خواهید نوشت را دوبار تکرار نکنید. تا جایی که امکان دارد باید بتوانید از کدهای قبلی که نوشته اید استفاده کنید. پکیج‌ها امکاناتی از جمله:&lt;/p></description></item><item><author/><title>1.13 defer, panic, recovery</title><link>https://book.gofarsi.ir/chapter-1/go-defer-panic-recovery/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-1/go-defer-panic-recovery/</guid><description>&lt;h2 id="1131-تعویق-defer">
1.13.1 تعویق (defer)
&lt;a class="anchor" href="#1131-%d8%aa%d8%b9%d9%88%db%8c%d9%82-defer">#&lt;/a>
&lt;/h2>
&lt;p>کلمه کلیدی defer یکی از کاربردی‌ترین امکانات زبان گو را برای ما فراهم می‌سازد. شما می‌توانید اجرای یک تابع را به تعویق بندازید‍‍. عموماً defer برای توابعی کاربرد دارد که قصد پاک‌سازی یا بستن عملیات‌های صورت گرفته را دارند، نظیر توابع Close در برخی از جاها.&lt;/p>
&lt;p>&lt;img src="../../assets/img/content/chapter1/defer-panic-recovery/1.png" alt="defer" />&lt;/p>
&lt;p>به مثال زیر توجه کنید:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"fmt"
)
func main() {
defer fmt.Println("world")
fmt.Println("hello")
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;h3 id="11311-تعویق-defer-در-توابع-anonymous">
1.13.1.1 تعویق (defer) در توابع (Anonymous)
&lt;a class="anchor" href="#11311-%d8%aa%d8%b9%d9%88%db%8c%d9%82-defer-%d8%af%d8%b1-%d8%aa%d9%88%d8%a7%d8%a8%d8%b9-anonymous">#&lt;/a>
&lt;/h3>
&lt;p>شما خیلی ساده می‌توانید با استفاده از توابع &lt;code>Anonymous&lt;/code> &lt;code>توابع بینام یا گمنام :)&lt;/code> اجرای قسمتی از برنامه خودتان را به تعویق بندازید. به مثال زیر توجه کنید:&lt;/p></description></item><item><author/><title>1.14 لیست تایپ‌ها و توابع Builtin</title><link>https://book.gofarsi.ir/chapter-1/go-builtins/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-1/go-builtins/</guid><description>&lt;p>در مثال زیر لیست تایپ‌ها و توابع Builtin را با توضیحات قرار دادیم.&lt;/p>
&lt;pre>&lt;code class="language-go">// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
/*
Package builtin provides documentation for Go's predeclared identifiers.
The items documented here are not actually in package builtin
but their descriptions here allow godoc to present documentation
for the language's special identifiers.
*/
package builtin
import &amp;quot;cmp&amp;quot;
// bool is the set of boolean values, true and false.
type bool bool
// true and false are the two untyped boolean values.
const (
true = 0 == 0 // Untyped bool.
false = 0 != 0 // Untyped bool.
)
// uint8 is the set of all unsigned 8-bit integers.
// Range: 0 through 255.
type uint8 uint8
// uint16 is the set of all unsigned 16-bit integers.
// Range: 0 through 65535.
type uint16 uint16
// uint32 is the set of all unsigned 32-bit integers.
// Range: 0 through 4294967295.
type uint32 uint32
// uint64 is the set of all unsigned 64-bit integers.
// Range: 0 through 18446744073709551615.
type uint64 uint64
// int8 is the set of all signed 8-bit integers.
// Range: -128 through 127.
type int8 int8
// int16 is the set of all signed 16-bit integers.
// Range: -32768 through 32767.
type int16 int16
// int32 is the set of all signed 32-bit integers.
// Range: -2147483648 through 2147483647.
type int32 int32
// int64 is the set of all signed 64-bit integers.
// Range: -9223372036854775808 through 9223372036854775807.
type int64 int64
// float32 is the set of all IEEE 754 32-bit floating-point numbers.
type float32 float32
// float64 is the set of all IEEE 754 64-bit floating-point numbers.
type float64 float64
// complex64 is the set of all complex numbers with float32 real and
// imaginary parts.
type complex64 complex64
// complex128 is the set of all complex numbers with float64 real and
// imaginary parts.
type complex128 complex128
// string is the set of all strings of 8-bit bytes, conventionally but not
// necessarily representing UTF-8-encoded text. A string may be empty, but
// not nil. Values of string type are immutable.
type string string
// int is a signed integer type that is at least 32 bits in size. It is a
// distinct type, however, and not an alias for, say, int32.
type int int
// uint is an unsigned integer type that is at least 32 bits in size. It is a
// distinct type, however, and not an alias for, say, uint32.
type uint uint
// uintptr is an integer type that is large enough to hold the bit pattern of
// any pointer.
type uintptr uintptr
// byte is an alias for uint8 and is equivalent to uint8 in all ways. It is
// used, by convention, to distinguish byte values from 8-bit unsigned
// integer values.
type byte = uint8
// rune is an alias for int32 and is equivalent to int32 in all ways. It is
// used, by convention, to distinguish character values from integer values.
type rune = int32
// any is an alias for interface{} and is equivalent to interface{} in all ways.
type any = interface{}
// comparable is an interface that is implemented by all comparable types
// (booleans, numbers, strings, pointers, channels, arrays of comparable types,
// structs whose fields are all comparable types).
// The comparable interface may only be used as a type parameter constraint,
// not as the type of a variable.
type comparable interface{ comparable }
// iota is a predeclared identifier representing the untyped integer ordinal
// number of the current const specification in a (usually parenthesized)
// const declaration. It is zero-indexed.
const iota = 0 // Untyped int.
// nil is a predeclared identifier representing the zero value for a
// pointer, channel, func, interface, map, or slice type.
var nil Type // Type must be a pointer, channel, func, interface, map, or slice type
// Type is here for the purposes of documentation only. It is a stand-in
// for any Go type, but represents the same type for any given function
// invocation.
type Type int
// Type1 is here for the purposes of documentation only. It is a stand-in
// for any Go type, but represents the same type for any given function
// invocation.
type Type1 int
// IntegerType is here for the purposes of documentation only. It is a stand-in
// for any integer type: int, uint, int8 etc.
type IntegerType int
// FloatType is here for the purposes of documentation only. It is a stand-in
// for either float type: float32 or float64.
type FloatType float32
// ComplexType is here for the purposes of documentation only. It is a
// stand-in for either complex type: complex64 or complex128.
type ComplexType complex64
// The append built-in function appends elements to the end of a slice. If
// it has sufficient capacity, the destination is resliced to accommodate the
// new elements. If it does not, a new underlying array will be allocated.
// Append returns the updated slice. It is therefore necessary to store the
// result of append, often in the variable holding the slice itself:
//
// slice = append(slice, elem1, elem2)
// slice = append(slice, anotherSlice...)
//
// As a special case, it is legal to append a string to a byte slice, like this:
//
// slice = append([]byte(&amp;quot;hello &amp;quot;), &amp;quot;world&amp;quot;...)
func append(slice []Type, elems ...Type) []Type
// The copy built-in function copies elements from a source slice into a
// destination slice. (As a special case, it also will copy bytes from a
// string to a slice of bytes.) The source and destination may overlap. Copy
// returns the number of elements copied, which will be the minimum of
// len(src) and len(dst).
func copy(dst, src []Type) int
// The delete built-in function deletes the element with the specified key
// (m[key]) from the map. If m is nil or there is no such element, delete
// is a no-op.
func delete(m map[Type]Type1, key Type)
// The len built-in function returns the length of v, according to its type:
//
// - Array: the number of elements in v.
// - Pointer to array: the number of elements in *v (even if v is nil).
// - Slice, or map: the number of elements in v; if v is nil, len(v) is zero.
// - String: the number of bytes in v.
// - Channel: the number of elements queued (unread) in the channel buffer;
// if v is nil, len(v) is zero.
//
// For some arguments, such as a string literal or a simple array expression, the
// result can be a constant. See the Go language specification's &amp;quot;Length and
// capacity&amp;quot; section for details.
func len(v Type) int
// The cap built-in function returns the capacity of v, according to its type:
//
// - Array: the number of elements in v (same as len(v)).
// - Pointer to array: the number of elements in *v (same as len(v)).
// - Slice: the maximum length the slice can reach when resliced;
// if v is nil, cap(v) is zero.
// - Channel: the channel buffer capacity, in units of elements;
// if v is nil, cap(v) is zero.
//
// For some arguments, such as a simple array expression, the result can be a
// constant. See the Go language specification's &amp;quot;Length and capacity&amp;quot; section for
// details.
func cap(v Type) int
// The make built-in function allocates and initializes an object of type
// slice, map, or chan (only). Like new, the first argument is a type, not a
// value. Unlike new, make's return type is the same as the type of its
// argument, not a pointer to it. The specification of the result depends on
// the type:
//
// - Slice: The size specifies the length. The capacity of the slice is
// equal to its length. A second integer argument may be provided to
// specify a different capacity; it must be no smaller than the
// length. For example, make([]int, 0, 10) allocates an underlying array
// of size 10 and returns a slice of length 0 and capacity 10 that is
// backed by this underlying array.
// - Map: An empty map is allocated with enough space to hold the
// specified number of elements. The size may be omitted, in which case
// a small starting size is allocated.
// - Channel: The channel's buffer is initialized with the specified
// buffer capacity. If zero, or the size is omitted, the channel is
// unbuffered.
func make(t Type, size ...IntegerType) Type
// The max built-in function returns the largest value of a fixed number of
// arguments of [cmp.Ordered] types. There must be at least one argument.
// If T is a floating-point type and any of the arguments are NaNs,
// max will return NaN.
func max[T cmp.Ordered](x T, y ...T) T
// The min built-in function returns the smallest value of a fixed number of
// arguments of [cmp.Ordered] types. There must be at least one argument.
// If T is a floating-point type and any of the arguments are NaNs,
// min will return NaN.
func min[T cmp.Ordered](x T, y ...T) T
// The new built-in function allocates memory. The first argument is a type,
// not a value, and the value returned is a pointer to a newly
// allocated zero value of that type.
func new(Type) *Type
// The complex built-in function constructs a complex value from two
// floating-point values. The real and imaginary parts must be of the same
// size, either float32 or float64 (or assignable to them), and the return
// value will be the corresponding complex type (complex64 for float32,
// complex128 for float64).
func complex(r, i FloatType) ComplexType
// The real built-in function returns the real part of the complex number c.
// The return value will be floating point type corresponding to the type of c.
func real(c ComplexType) FloatType
// The imag built-in function returns the imaginary part of the complex
// number c. The return value will be floating point type corresponding to
// the type of c.
func imag(c ComplexType) FloatType
// The clear built-in function clears maps and slices.
// For maps, clear deletes all entries, resulting in an empty map.
// For slices, clear sets all elements up to the length of the slice
// to the zero value of the respective element type. If the argument
// type is a type parameter, the type parameter's type set must
// contain only map or slice types, and clear performs the operation
// implied by the type argument. If t is nil, clear is a no-op.
func clear[T ~[]Type | ~map[Type]Type1](t T)
// The close built-in function closes a channel, which must be either
// bidirectional or send-only. It should be executed only by the sender,
// never the receiver, and has the effect of shutting down the channel after
// the last sent value is received. After the last value has been received
// from a closed channel c, any receive from c will succeed without
// blocking, returning the zero value for the channel element. The form
//
// x, ok := &amp;lt;-c
//
// will also set ok to false for a closed and empty channel.
func close(c chan&amp;lt;- Type)
// The panic built-in function stops normal execution of the current
// goroutine. When a function F calls panic, normal execution of F stops
// immediately. Any functions whose execution was deferred by F are run in
// the usual way, and then F returns to its caller. To the caller G, the
// invocation of F then behaves like a call to panic, terminating G's
// execution and running any deferred functions. This continues until all
// functions in the executing goroutine have stopped, in reverse order. At
// that point, the program is terminated with a non-zero exit code. This
// termination sequence is called panicking and can be controlled by the
// built-in function recover.
//
// Starting in Go 1.21, calling panic with a nil interface value or an
// untyped nil causes a run-time error (a different panic).
// The GODEBUG setting panicnil=1 disables the run-time error.
func panic(v any)
// The recover built-in function allows a program to manage behavior of a
// panicking goroutine. Executing a call to recover inside a deferred
// function (but not any function called by it) stops the panicking sequence
// by restoring normal execution and retrieves the error value passed to the
// call of panic. If recover is called outside the deferred function it will
// not stop a panicking sequence. In this case, or when the goroutine is not
// panicking, recover returns nil.
//
// Prior to Go 1.21, recover would also return nil if panic is called with
// a nil argument. See [panic] for details.
func recover() any
// The print built-in function formats its arguments in an
// implementation-specific way and writes the result to standard error.
// Print is useful for bootstrapping and debugging; it is not guaranteed
// to stay in the language.
func print(args ...Type)
// The println built-in function formats its arguments in an
// implementation-specific way and writes the result to standard error.
// Spaces are always added between arguments and a newline is appended.
// Println is useful for bootstrapping and debugging; it is not guaranteed
// to stay in the language.
func println(args ...Type)
// The error built-in interface type is the conventional interface for
// representing an error condition, with the nil value representing no error.
type error interface {
Error() string
}
&lt;/code>&lt;/pre></description></item><item><author/><title>1.15 قالب بندی رشته‌ها</title><link>https://book.gofarsi.ir/chapter-1/go-string-formatting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-1/go-string-formatting/</guid><description>&lt;p>در زبان گو مانند سایر زبان‌ها یکسری عناوین برای قالب‌بندی رشته وجود دارد که برخی از این عناوین مشترک بین همه زبان‌ها هست و برخی مختص زبان گو.&lt;/p>
&lt;h2 id="1151-قالب-بندی-با-توابع-printf-و-sprintf">
1.15.1 قالب بندی با توابع Printf و Sprintf
&lt;a class="anchor" href="#1151-%d9%82%d8%a7%d9%84%d8%a8-%d8%a8%d9%86%d8%af%db%8c-%d8%a8%d8%a7-%d8%aa%d9%88%d8%a7%d8%a8%d8%b9-printf-%d9%88-sprintf">#&lt;/a>
&lt;/h2>
&lt;p>زمانیکه شما از تابع Printf یا Sprintf استفاده می‌کنید می‌توانید رشته خروجی را با استفاده از پارامترهای بعد از رشته قالب‌بندی کنید، و در نهایت به‌صورت یک رشته نمایش دهید.&lt;/p>
&lt;pre>&lt;code class="language-go">fmt.Printf(&amp;quot;{{Verb}}&amp;quot;, value1, value2, value3, ..., valueN)
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-go">fmt.Sprintf(&amp;quot;{{Verb}}&amp;quot;, value1, value2, value3, ..., valueN)
&lt;/code>&lt;/pre>
&lt;blockquote class="book-hint info">
&lt;p>توجه کنید هر دو تابع فوق خیلی کاربردی و پر استفاده هستند. این ۲ تابع کارکردشان مشترک است ولی خروجی متفاوتی دارند.&lt;/p></description></item><item><author/><title>2.1 اشاره‌گر (Pointer)</title><link>https://book.gofarsi.ir/chapter-2/pointer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-2/pointer/</guid><description>&lt;p>&lt;span class="tooltip" data-tooltip="pointer" ontouchend="toggleTooltip(this)">اشاره‌گر&lt;/span>
در واقع متغیری است که، آدرس حافظه یک مقدار را نگه می‌دارد.&lt;/p>
&lt;pre>&lt;code class="language-go">var ex *T
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="../../assets/img/content/chapter2/pointer/1.png" alt="pointer" />&lt;/p>
&lt;p>درک اشاره‌گرها (Pointers) برای بسیاری از مبتدیان ترسناک به نظر می‌رسد، اما در واقع اگر با یک مثال ساده آن را توضیح دهیم، می‌تواند بسیار قابل فهم باشد. اجازه بدهید ترجمه و توضیحی روان بر پایه مثالی که دادی ارائه کنم:&lt;/p>
&lt;blockquote>
&lt;p>اشاره‌گرها پیچیده به نظر می‌رسند،
اما واقعاً نیازی نیست که این‌طور باشند.
اشاره‌گرها را می‌توان شبیه &amp;ldquo;فهرست مطالب یک کتاب&amp;rdquo; در نظر گرفت.
برای مثال، همین کتاب را در نظر بگیر.
فهرست مطالب این کتاب مثل پنج اشاره‌گر است.
شما می‌توانید آن‌ها را بخوانید و بفهمید که اطلاعات مربوط به هر فصل در کجا قرار دارد.
مثلاً فصل «زندگی من» در صفحه ۱ است (یعنی به صفحه ۱ اشاره می‌کند).
و فصل «شغل من» در صفحه ۲۳ است.&lt;/p></description></item><item><author/><title>2.2 ساختار (struct)</title><link>https://book.gofarsi.ir/chapter-2/struct/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-2/struct/</guid><description>&lt;p>در زبان گو &lt;span class="tooltip" data-tooltip="struct" ontouchend="toggleTooltip(this)">ساختار&lt;/span>
کالکشنی از فیلدها با تایپ‌های مختلف است. شما با استفاده از &lt;span class="tooltip" data-tooltip="struct" ontouchend="toggleTooltip(this)">ساختار&lt;/span>
می‌توانید یک مدل کلی از بدنه پروژه خود را تعریف کنید. برای نمونه ما در مثال زیر یک نمونه از &lt;span class="tooltip" data-tooltip="struct" ontouchend="toggleTooltip(this)">ساختار&lt;/span>
employee &lt;code>کارمند&lt;/code> را مثال زدیم تا شما کمی با مفهوم &lt;span class="tooltip" data-tooltip="struct" ontouchend="toggleTooltip(this)">ساختار&lt;/span>
آشنا شوید.&lt;/p>
&lt;pre>&lt;code class="language-go">type employee struct {
name string
age int
salary int
}
&lt;/code>&lt;/pre>
&lt;blockquote class="book-hint warning">
&lt;p>نکته: ساختار می‌تواند بصورت خالی جهت برخی اهداف ایجاد گردد. به مثال زیر دقت کنید:‌&lt;/p></description></item><item><author/><title>2.3 متد (Method)</title><link>https://book.gofarsi.ir/chapter-2/method/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-2/method/</guid><description>&lt;p>متد در واقع یک تابع گیرنده (receiver) است که به واسطه یک تایپ در دسترس خواهد بود. توجه کنید برای تعریف متد باید قبل از اسم تابع، داخل پرانتز یک نام و یک تایپ قرار دهید. برای درک بهتر این موضوع فکر کنید نامی که داخل پرانتز قرار می‌دید یه متغیر هست که به تایپ شما اشاره می‌کند. به مثال زیر توجه کنید:&lt;/p>
&lt;pre>&lt;code class="language-go">func (receiver receiver_type) some_func_name(arguments) return_values
&lt;/code>&lt;/pre>
&lt;p>برای درک بهتر این مفهوم، می‌توانید متد را دقیقاً یک تابع در نظر بگیرید. نحوه تعریف به صورت متد صرفاً برای راحتی در زمان توسعه نرم افزار است و به برنامه‌نویس امکان توسعه بهتر بدون نیاز به حفظ کردن زیاد عملکرد‌های سیستم را می‌دهد.&lt;/p></description></item><item><author/><title>2.4 اینترفیس (Interface)</title><link>https://book.gofarsi.ir/chapter-2/interface/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-2/interface/</guid><description>&lt;p>اینترفیس در زبان گو مجموعه‌ای از متدها است. این مجموعه متدها با توجه به ورودی و خروجی که دارند دارای رفتارهای خاصی هستند. زمانیکه شما یک اینترفیس به همراه یکسری از متدها تعریف می‌کنید باید در جایی این متدها را پیاده سازی کنید.&lt;/p>
&lt;p>اینترفیس‌ها به شما اجازه می‌دهد تا از &lt;a href="https://fa.wikipedia.org/wiki/%D9%86%D9%88%D8%B9%E2%80%8C%D8%AF%D9%87%DB%8C_%D8%A7%D8%B1%D8%AF%DA%A9%DB%8C">Duck typing&lt;/a> استفاده کنید. حالا این duck typing چیست؟&lt;/p>
&lt;p>duck typing روشی در برنامه‌نویسی کامپیوتری است که به شما امکان می‌دهد تست اردک را انجام دهید، جایی که ما نوع را بررسی نمی‌کنیم، بلکه تنها وجود برخی ویژگی‌ها یا روش‌ها را بررسی می‌کنیم. بنابراین آنچه واقعاً اهمیت دارد این است که آیا یک شی دارای ویژگی‌ها و روش‌های خاصی است و نه نوع آن.&lt;/p></description></item><item><author/><title>2.5 جاسازی تایپ (type embedding)</title><link>https://book.gofarsi.ir/chapter-2/type-embedding/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-2/type-embedding/</guid><description>&lt;p>در زبان گو برای ساختار و اینترفیس امکان &lt;span class="tooltip" data-tooltip="embedding" ontouchend="toggleTooltip(this)">جاسازی&lt;/span>
تایپ وجود دارد. یعنی شما می‌توانید یک ساختار یا یک اینترفیس را داخل ساختار دیگر &lt;span class="tooltip" data-tooltip="embedding" ontouchend="toggleTooltip(this)">جاسازی&lt;/span>
کنید و یا داخل اینترفیس یک اینترفیس دیگر را جاسازی کنید.&lt;/p>
&lt;pre>&lt;code class="language-go">
type animal interface {
breathe()
walk()
}
type human interface {
animal
speak()
}
type base struct {
num int
}
type container struct {
human
base
str string
}
&lt;/code>&lt;/pre>
&lt;p>در بالا ما اینترفیس animal را در اینترفیس human &lt;span class="tooltip" data-tooltip="embedding" ontouchend="toggleTooltip(this)">جاسازی&lt;/span>
کردیم و در ادامه داخل ساختار container اینترفیس human و ساختار base را &lt;span class="tooltip" data-tooltip="embedding" ontouchend="toggleTooltip(this)">جاسازی&lt;/span>
کردیم.&lt;/p></description></item><item><author/><title>2.6 مدیریت خطاها</title><link>https://book.gofarsi.ir/chapter-2/error-handling/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-2/error-handling/</guid><description>&lt;p>در این بخش قصد داریم به مقوله مدیریت خطاها در زبان گو بپردازیم و اینکه چطور می‌توانید خیلی ساده خطاها را مدیریت کنید. مدیریت خطا در زبان گو با سایر زبان‌ها متفاوت هست و شما با چیزی به نام try-catch یا try-except سروکار ندارید.&lt;/p>
&lt;p>مدیریت خطاها در زبان گو به دو روش صورت می گیرد:&lt;/p>
&lt;ul>
&lt;li>با استفاده از پیاده سازی اینترفیس error که یک روش مرسوم جهت مدیریت و نمایش خطا است.&lt;/li>
&lt;li>با استفاده از panic/recover که در فصل اول توضیح دادیم.&lt;/li>
&lt;/ul>
&lt;h2 id="261-مدیریت-خطا-با-اینترفیس-error">
2.6.1 مدیریت خطا با اینترفیس error
&lt;a class="anchor" href="#261-%d9%85%d8%af%db%8c%d8%b1%db%8c%d8%aa-%d8%ae%d8%b7%d8%a7-%d8%a8%d8%a7-%d8%a7%db%8c%d9%86%d8%aa%d8%b1%d9%81%db%8c%d8%b3-error">#&lt;/a>
&lt;/h2>
&lt;p>روش زبان گو برای مقابله با خطا این است که به صراحت، شما خطا را به عنوان خروجی تابع برگردانید. برای این کار کافیست اگر میخواهید خطای هر تابع را مدیریت کنید، اینترفیس error را در خروجی تابع بگذارید.&lt;/p></description></item><item><author/><title>2.7 فرق casting با conversion</title><link>https://book.gofarsi.ir/chapter-2/casting-vs-conversion/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-2/casting-vs-conversion/</guid><description>&lt;h2 id="271-conversion">
2.7.1 conversion
&lt;a class="anchor" href="#271-conversion">#&lt;/a>
&lt;/h2>
&lt;p>conversion زمانی اتفاق می‌افتد که ما مقدار یک داده را به تایپ دیگری اختصاص دهیم.&lt;/p>
&lt;p>زبان‌هایی که Static Type هستند از این مقوله بطور &lt;span class="tooltip" data-tooltip="implicit" ontouchend="toggleTooltip(this)">ضمنی&lt;/span>
پشتیبانی می‌کنند ولی در زبان گو کمی متفاوت است. اگر شما بخواهید conversion انجام دهید باید بصورت دستی اینکار را انجام دهید. چون کامپایلر گو برخی از عناوین را بطور &lt;span class="tooltip" data-tooltip="explicit" ontouchend="toggleTooltip(this)">صریح&lt;/span>
در نظر می‌گیرد.&lt;/p>
&lt;h2 id="272-type-casting">
2.7.2 type casting
&lt;a class="anchor" href="#272-type-casting">#&lt;/a>
&lt;/h2>
&lt;p>در زبان گو، چیزی به نام type casting بطور کلی وجود ندارد. پس بهتر است در خصوص این مورد داخل داکیومنت‌ها یا سایت‌های مختلف نگردید. برای درک بهتر این موضوع بهتره &lt;a href="https://go.dev/ref/spec#Conversions">https://go.dev/ref/spec#Conversions&lt;/a> را مطالعه کنید.&lt;/p></description></item><item><author/><title>3.1 آشنایی با همزمانی</title><link>https://book.gofarsi.ir/chapter-3/go-concurrency/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-3/go-concurrency/</guid><description>&lt;p>&lt;img src="../../assets/img/content/chapter3/concurrency/1.png" alt="concurrency" />&lt;/p>
&lt;p>نرم‌افزارهای بزرگ به منظور توسعه راحت‌تر و &lt;span class="tooltip" data-tooltip="Maintainability" ontouchend="toggleTooltip(this)">قابلیت نگهداری&lt;/span>
بیشتر و همچنین &lt;span class="tooltip" data-tooltip="Reusibility" ontouchend="toggleTooltip(this)">پرهیز از تکرار&lt;/span>
از ده‌ها زیر برنامه کوچک‌تر تشکیل می‌شوند که به آنها توابع می‌گوییم و تمامی این زیربرنامه‌های کوچک در کنار هم اما به صورت مستقل عملکرد کلی برنامه بزرگتر را شکل می‌دهند. به عنوان مثال یک وب سرور درخواست‌های ارسال شده از سمت مرورگرها را مدیریت می کند و در پاسخ صفحات وب HTML را آماده کرده و ارائه می‌دهد و هر در خواست از طریق فراخوانی چندین برنامه کوچک رسیدگی می شود تا نتیجه را به مرورگر برگردانده شود.&lt;/p></description></item><item><author/><title>3.2 گوروتین (goroutine)</title><link>https://book.gofarsi.ir/chapter-3/goroutine/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-3/goroutine/</guid><description>&lt;p>گوروتین ها را می توان به عنوان یک thread سبک در نظر گرفت که بصورت مستقل می توانند همزمان با سایر گوروتین های دیگر کارها را انجام دهند. و همچنین گوروتین ها می توانند به واسطه کانال داده ها را بین هم به اشتراک گذاشته و منتقل کنند.&lt;/p>
&lt;blockquote class="book-hint info">
&lt;p>حداکثر اندازه stack یک گوروتین در زبان گو ۱ گیگابایت می باشد.&lt;/p>
&lt;pre>&lt;code class="language-go">var maxstacksize uintptr = 1 &amp;lt;&amp;lt; 20 // enough until runtime.main sets it for real
if newsize &amp;gt; maxstacksize || newsize &amp;gt; maxstackceiling {
if maxstacksize &amp;lt; maxstackceiling {
print(&amp;quot;runtime: goroutine stack exceeds &amp;quot;, maxstacksize, &amp;quot;-byte limit\n&amp;quot;)
} else {
print(&amp;quot;runtime: goroutine stack exceeds &amp;quot;, maxstackceiling, &amp;quot;-byte limit\n&amp;quot;)
}
print(&amp;quot;runtime: sp=&amp;quot;, hex(sp), &amp;quot; stack=[&amp;quot;, hex(gp.stack.lo), &amp;quot;, &amp;quot;, hex(gp.stack.hi), &amp;quot;]\n&amp;quot;)
throw(&amp;quot;stack overflow&amp;quot;)
}
&lt;/code>&lt;/pre>
&lt;/blockquote>
&lt;p>در زیر با استفاده از کلمه کلیدی &lt;code>go&lt;/code> یک نمونه گوروتین ایجاد کردیم و توجه کنید شما فقط توابع را می توانید به صورت همزمان اجرا کنید.&lt;/p></description></item><item><author/><title>3.3 پکیج sync</title><link>https://book.gofarsi.ir/chapter-3/go-sync-package/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-3/go-sync-package/</guid><description>&lt;p>پکیج &lt;code>sync&lt;/code> یکی از کاربردی ترین پکیج ها در زمینه همزمانی می باشد و یکسری تایپ و توابع برای&lt;span class="tooltip" data-tooltip="synchronize" ontouchend="toggleTooltip(this)">همگام سازی&lt;/span>
و کنترل دسترسی همزمان به داده های مشترک ارائه می دهد. پرکاربرد ترین ویژگی های این پکیج شامل موارد زیر می شود :&lt;/p>
&lt;ul>
&lt;li>&lt;code>Mutex&lt;/code> : با استفاده از این تایپ می توانید آن بخش از داده ای که گوروتین ها بطور همزمان قصد دارند دسترسی داشته باشند را قفل کنید.&lt;/li>
&lt;li>&lt;code>RWMutex&lt;/code> : با استفاده از این تایپ می توانید به چندین گوروتین اجازه خواندن دهید اما فقط یک گوروتین قابلیت نوشتن در یک زمان مشخص را دارد.&lt;/li>
&lt;li>&lt;code>WaitGroup&lt;/code>: یک هماهنگ کننده گوروتین می باشد، برای اینکه ترتیب عملیات ها در هنگام همزمانی رعایت شود.&lt;/li>
&lt;li>&lt;code>Once&lt;/code>: این تایپ تضمین می کند که یک تابع فقط یک بار اجرا شود.&lt;/li>
&lt;li>&lt;code>Pool&lt;/code>: مجموعه‌ای از آبجکت های موقت که امکان ذخیره و دریافت دارند بدون اینکه بخشی از حافظه را اشغال کنند.&lt;/li>
&lt;li>&lt;code>Cond&lt;/code>:با استفاده از Cond می توانید چندین گوروتین ایجاد کنید و اجرای فرآیند آن ها را منتظر وقوع یک رویداد قرار دهید.&lt;/li>
&lt;/ul>
&lt;blockquote class="book-hint info">
توجه کنید که پکیج &lt;code>sync&lt;/code> فقط و فقط برای مدیریت و همگام سازی دسترسی های گوروتین ها به یک داده مشترک استفاده می شود.
&lt;/blockquote>
&lt;h2 id="331-mutex">
3.3.1 Mutex
&lt;a class="anchor" href="#331-mutex">#&lt;/a>
&lt;/h2>
&lt;p>در پکیج &lt;code>sync&lt;/code> یک تایپ به نام &lt;code>Mutex&lt;/code> وجود دارد که به شما این امکان را می دهد دسترسی به داده های مشترک را &lt;span class="tooltip" data-tooltip="synchronize" ontouchend="toggleTooltip(this)">همگام سازی&lt;/span>
کنید. با استفاده از این قابلیت در واقع منابع مشترک محافظت شده و این اطمینان به شما داده می شود که تنها یک گوروتین در یک زمان مشخص، به دیتای مشترک بین گوروتین ها دسترسی دارد.
تایپ Mutex شامل دو متد مهم Lock و Unlock است. وقتی Lock فراخوانی می شود فقط و فقط یک گوروتین می تواند برروی آن بخش از داده کار کند و تا زمانیکه شما Unlock نکنید سایر گوروتین ها نمی توانند به دیتای مورد نظر شما دسترسی داشته باشند و تا زمانیکه Unlock صورت گیرد سایر گوروتین هادر حالت انتظار باقی می مانند.&lt;/p></description></item><item><author/><title>3.4 پکیج atomic</title><link>https://book.gofarsi.ir/chapter-3/go-atomic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-3/go-atomic/</guid><description>&lt;p>&lt;strong>پکیج &lt;a href="https://pkg.go.dev/sync/atomic">sync/atomic&lt;/a>&lt;/strong> در زبان Go مجموعه‌ای از توابع سطح پایین (low-level) را برای انجام عملیات خواندن و نوشتن &lt;strong>اتمی (atomic)&lt;/strong> روی متغیرهای حافظه فراهم می‌کند. منظور از عملیات اتمیک، عملیاتی است که به طور کامل و یکپارچه توسط CPU انجام می‌شود؛ یعنی هیچ گوروتین، thread یا پردازش دیگری نمی‌تواند مقدار متغیر را بین شروع و پایان یک عملیات اتمیک مشاهده یا تغییر دهد. این ویژگی برای پیاده‌سازی &lt;strong>الگوهای همگام‌سازی سبک و بدون قفل (lock-free synchronization)&lt;/strong> و &lt;strong>متغیرهای اشتراکی با دسترسی سریع و ایمن&lt;/strong> ضروری است.&lt;/p></description></item><item><author/><title>3.5 آموزش مقابله با data race</title><link>https://book.gofarsi.ir/chapter-3/goroutine-data-race/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-3/goroutine-data-race/</guid><description>&lt;p>معمولا تو بحث همزمانی یکی از اتفاقاتی که خیلی ممکن است رخ دهد بحث data race است و data race زمانی رخ می دهد که ۲ یا چند گوروتین قصد دارند به یک آدرس حافظه در یک زمان دسترسی داشته باشند. حال اگر ما جلوی data race را نگیریم ممکن است تغییرات نادرست برروی مقادیر داخل خانه حافظه صورت گیرد.&lt;/p>
&lt;p>راه هایی برای مقابله با data race وجود دارد که به شرح زیر است :&lt;/p></description></item><item><author/><title>3.6 کانال (channel)</title><link>https://book.gofarsi.ir/chapter-3/go-channel/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-3/go-channel/</guid><description>&lt;center>&lt;a href="#">
&lt;img src="../../assets/img/content/chapter3/channel/1.png" alt="channel">
&lt;/a>&lt;/center>
&lt;p>کانال یک نوع تایپ است که داده از نوع خاصی را نگه داری میکند و امکان برقراری ارتباط و همگام سازی داده بین گوروتین ها را فراهم می کند. شما می توانید کانال ها را به عنوان خط لوله هایی در نظر بگیرید که این خط لوله ها به گوروتین ها متصل می شوند و باعث برقراری ارتباط بین گوروتین ها می شوند. این ارتباط بین گوروتین ها به هیچ قفل صریحی نیاز ندارد (منظورم mutex و &amp;hellip;) چون کانال ها بصورت داخلی قفل ها را مدیریت میکنند و در زمان های مناسب و مشخص Lock و UnLock می کنند.&lt;/p></description></item><item><author/><title>3.7 آموزش استفاده از select</title><link>https://book.gofarsi.ir/chapter-3/go-select/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-3/go-select/</guid><description>&lt;p>در زبان گو select همانند switch می باشد که دارای case و default هستش اما یک فرق کلی دارد که به عملکردش برمیگردد. case های select برای عملیات ارسال و دریافت از کانال منتظر می ماند. در کل شما با استفاده از select می توانید از کانال های مختلف اطلاعات ارسال و دریافت کنید و پس از آن برروی آن اطلاعات عملیات انجام دهید.&lt;/p>
&lt;ul>
&lt;li>select تا زمانی که یکی از case ها آماده شود بلاک می شود.&lt;/li>
&lt;li>اگر همزمان چندتا case برای انجام عملیات آماده شود select بصورت تصادفی یکی را انتخاب میکند تا عملیات تکمیل شود.&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-go">select {
case channel_send_or_receive:
//Dosomething
case channel_send_or_receive:
//Dosomething
default:
//Dosomething
}
&lt;/code>&lt;/pre>
&lt;p>select از بین case ها موردی را انتخاب می کند که در آن عملیات ارسال یا دریافت کانال بلاک نشده باشد و آماده اجرا باشد. اگر چند مورد از case ها آماده باشد یکی از آنها بصورت تصادفی انتخاب می شود تا فرآیند را تکمیل کند.&lt;/p></description></item><item><author/><title>3.8 پکیج context</title><link>https://book.gofarsi.ir/chapter-3/go-context/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-3/go-context/</guid><description>&lt;center>&lt;a href="#">
&lt;img src="../../assets/img/content/chapter3/context/1.png" alt="context">
&lt;/a>&lt;/center>
&lt;p>پکیج &lt;a href="https://pkg.go.dev/context">context&lt;/a> یک پکیج built-in است که یکی از پرکاربرد ترین پکیج های زبان گو می باشد. کار اصلی این پکیج فراهم کردن بستری است که بتوان به داده های مشترک دسترسی داشت و یا بتوان آنها را به اشتراک گذاشت و مدیریت کرد. حتی اگر شما نخواسته باشید سمت این پکیج بروید به مرور زمان که جلوتر می روید با این پکیج رو به رو خواهید شد و مجبور خواهید بود این پکیج را یاد بگیرید.&lt;/p></description></item><item><author/><title>3.9 تکنیک های همزمانی</title><link>https://book.gofarsi.ir/chapter-3/go-concurrency-teqniques/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-3/go-concurrency-teqniques/</guid><description>&lt;h2 id="391-ارسال-سیگنال-انجام-شدن-با-کانال-ساختار">
3.9.1 ارسال سیگنال انجام شدن با کانال ساختار
&lt;a class="anchor" href="#391-%d8%a7%d8%b1%d8%b3%d8%a7%d9%84-%d8%b3%db%8c%da%af%d9%86%d8%a7%d9%84-%d8%a7%d9%86%d8%ac%d8%a7%d9%85-%d8%b4%d8%af%d9%86-%d8%a8%d8%a7-%da%a9%d8%a7%d9%86%d8%a7%d9%84-%d8%b3%d8%a7%d8%ae%d8%aa%d8%a7%d8%b1">#&lt;/a>
&lt;/h2>
&lt;p>شما می توانید با استفاده از کانال struct سیگنالی برای تکمیل شدن انجام یک کار را بفرستید.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"fmt"
"time"
)
func task1(done chan struct{}) {
// Do some work here
fmt.Println("doing task 1")
time.Sleep(2 * time.Second)
fmt.Println("task 1 has been completed")
done &lt;- struct{}{}
}
func task2(done &lt;-chan struct{}) {
select {
case &lt;-done:
// Do some work here
fmt.Println("doing task 2")
time.Sleep(2 * time.Second)
fmt.Println("task 2 has been completed")
}
}
func main() {
done := make(chan struct{})
go task1(done)
go task2(done)
time.Sleep(5 * time.Second)
fmt.Println("all tasks has been completed")
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در کد فوق ما دو تابع به نام task1 و task2 داریم که داخل گوروتین هستند و به عنوان پارامتر ورودی یک کانال ساختار خالی میگیرد حال کانال ساختار را به هر دو تابع پاس دادیم در ابتدا task1 فرآیند خود را انجام می دهد و سپس سیگنال انجام شدن را می فرستد و در ادامه تابع task2 سیگنال را دریافت می کند و فرآیندهای خود را انجام می دهد.&lt;/p></description></item><item><author/><title>3.10 الگو های همزمانی</title><link>https://book.gofarsi.ir/chapter-3/go-concurrency-patterns/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-3/go-concurrency-patterns/</guid><description>&lt;p>الگو های همزمانی را در فصل ۹ در کنار سایر الگوهای طراحی قرار دادیم یک مرجع کامل از الگوهای طراحی برای زبان گو داشته باشیم. در این بخش فقط ما خلاصه توضیحی در خصوص الگوها قرار دادیم و شما را ارجاع می دهیم به صفحه الگو :&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>عنوان&lt;/th>
&lt;th>توضیحات&lt;/th>
&lt;th>وضعیت&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;a href="../../chapter-9/concurrency-patterns/go-concurrency-pattern-wait-for-result">Wait For Result&lt;/a>&lt;/td>
&lt;td>با استفاده از الگو Wait For Result می توانید یک عملیاتی را بصورت همزمانی انجام دهید و سپس منتظر نتیجه عملیات صورت گرفته بمانید. برای اینکار از کانال استفاده می شود.&lt;/td>
&lt;td>✅&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="../../chapter-9/concurrency-patterns/go-concurrency-pattern-fan-out-in">Fan Out/In&lt;/a>&lt;/td>
&lt;td>الگو Fan Out/In یک تکنیک همزمانی در زبان گو می باشد که به شما اجازه می دهد چندین کار را با گوروتین همزمان انجام دهید و در نتیجه خروجی این کارها را با هم ترکیب کنید و به عنوان نتیجه نهایی دریافت کنید.&lt;/td>
&lt;td>✅&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="../../chapter-9/concurrency-patterns/go-concurrency-pattern-wait-for-task">Wait For Task&lt;/a>&lt;/td>
&lt;td>الگو wait for task یکی از الگوهای رایج در زبان گو می باشد و انتظار برای تکمیل یک تسک یا فرآیند استفاده می شود. یک تسک با استفاده از گوروتین اجرا می شود و پس اتمامش کار تسک از طریق کانال سیگنال انجام می فرستد.&lt;/td>
&lt;td>✅&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="../../chapter-9/concurrency-patterns/go-concurrency-pattern-drop">Drop&lt;/a>&lt;/td>
&lt;td>الگو Drop یک الگو مهم برای انجام خدمات سنگین می باشد. خدماتی که مواقعی باعث می شود حجم درخواست هایش بیش از ظرفیت موجود باشد و این درخواست ها بواسطه این الگو می تواند Drop شود. به عنوان مثال سرویس های DNS باید از این الگو استفاده کنند.&lt;/td>
&lt;td>✅&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="../../chapter-9/concurrency-patterns/go-concurrency-pattern-cancellation">Context Cancellation Pattern&lt;/a>&lt;/td>
&lt;td>الگو cancellation که حرکت تکنیکی هست برای ارسال سینگال به گوروتین ها استفاده می شود که باید اجرای کاری را متوقف کند و ایده اصلی این کار با استفاده بستن کانال صورت میگیرد.&lt;/td>
&lt;td>✅&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="../../chapter-9/concurrency-patterns/go-concurrency-pattern-semaphore">Semaphore&lt;/a>&lt;/td>
&lt;td>الگو Semaphore برای مدیریت کنترل دسترسی به منابع مشترک در همزمانی استفاده می شود. فرض کنید بصورت موازی ۱۰۰ درخواست HTTP سمت سرور میاد و I/O شبکه برای پردازش همزمان این ۱۰۰ درخواست درگیر میشود و به مرور عملکرد کاهش می یابد. حال اگر ما بیایم این ۱۰۰ درخواست موازی را تقسیم کنیم به ۵ دسته ۲۰ تایی که بصورت همزمانی انجام شود باعث می شود I/O شبکه کاهش یابد و عملکرد بهتری را خواهیم داشت.&lt;/td>
&lt;td>✅&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="../../chapter-9/concurrency-patterns/go-concurrency-pattern-worker-pool">Worker Pool&lt;/a>&lt;/td>
&lt;td>با استفاده از الگو Bounded Work Pooling امکان محدود سازی تعداد گوروتین ها را براساس کار مشخصی دارید و گوروتین ها را محدود به تعداد دفعات کار مشخص شده محدود می شود. این الگو برای وقت مفید است که شما می خواهید منابع را به یک کار خاص محدود کنید.&lt;/td>
&lt;td>✅&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="../../chapter-9/concurrency-patterns/go-concurrency-pattern-retry-timeout">Retry Timeout&lt;/a>&lt;/td>
&lt;td>شما از الگو Retry Timeout برای تلاش مجدد یکسری عملیات استفاده کنید. برای اینکار شما می توانید از حلقه و تابع After در پکیج time کمک بگیرید و برای هرتلاش یک timeout مشخص کنید.&lt;/td>
&lt;td>✅&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="../../chapter-9/concurrency-patterns/go-concurrency-pattern-channel-cancellation">Channel Cancellation&lt;/a>&lt;/td>
&lt;td>از کانال ها برای ارتباط بین گوروتین ها و هماهنگ کردن اجرا استفاده می شود. حال گاهی اوقات نیاز است که ما یکسری فرآیند را داخل گوروتین لغو کنیم. در اینجا می توانیم با استفاده از کانال سیگنال لغو کردن بفرستید تا عملیات هایی که گوروتین مورد نظر انجام می داد لغو شود.&lt;/td>
&lt;td>✅&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="../../chapter-9/concurrency-patterns/go-concurrency-pattern-producer-consumer">Producer-Consumer&lt;/a>&lt;/td>
&lt;td>الگو producer-consumer یکی از کاربردی ترین الگوها در زبان گو می باشد که با استفاده از الگو می توانید بطور همزمان یکسری اطلاعات تولید کنید و بفرستید داخل کانال و این اطلاعات توسط مصرف کننده بواسطه کانال دریافت شود.&lt;/td>
&lt;td>✅&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="../../chapter-9/concurrency-patterns/go-concurrency-pattern-monitor">Monitor&lt;/a>&lt;/td>
&lt;td>الگوی مانیتور به گروتین‌ ها اجازه می‌دهد هنگام ورود به حالت خواب بدون مسدود کردن اجرا یا مصرف منابع، منتظر شرایط خاصی باشند.&lt;/td>
&lt;td>✅&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="../../chapter-9/concurrency-patterns/go-concurrency-pattern-future">Future&lt;/a>&lt;/td>
&lt;td>در زبان گو الگو Future راهی برای نمایش نتیجه یک عملیات ناهمزمان (asynchronous) است که ممکن است آن عملیات هنوز تکمیل نشده باشد اما این الگو به شما این امکان را می دهد کدی بنویسید که طوری رفتار کند که گویی نتیجه یک عملیات فورا در دسترس است. حتی اگر عملیات در پس زمینه در حال اجرا باشد.&lt;/td>
&lt;td>✅&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="../../chapter-9/concurrency-patterns/go-concurrency-pattern-pipeline">Pipeline&lt;/a>&lt;/td>
&lt;td>الگو خط لوله (Pipeline) یکی از پرکاربردی ترین الگوها در همزمانی می باشد شما با استفاده از این الگو می توانید تسک های بزرگ را به تسک های کوچکتر و مستقل تقسیم کنید که می توانند بطور همزمان کار کنند. هر stage داخل یک گوروتین انجام می شود و بواسطه کانال داده ها بین stage های مختلف منتقل می شود.&lt;/td>
&lt;td>✅&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="../../chapter-9/concurrency-patterns/go-concurrency-pattern-subscription">Subscription&lt;/a>&lt;/td>
&lt;td>الگو Subscription یکی از الگوهای کاربردی برای پیاده سازی consumer می باشد که به یک آدرسی مشترک شوید و در بازده زمانی مختلف درخواست دهید و یکسری اطلاعات دریافت کنید.&lt;/td>
&lt;td>✅&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="../../chapter-9/concurrency-patterns/go-concurrency-pattern-brdige-channel">Bridge Channel&lt;/a>&lt;/td>
&lt;td>با استفاده از الگو Bridge Channel می توانید بین ۲ کانال داده ای را منتقل کنید فرض کنید یک داده را به کانال input میفرستید و از دریافت داده آن را می توانید به کانال دیگری منتقل کنید و عملا شما یک پل برای انتقال داده ایجاد کردید.&lt;/td>
&lt;td>✅&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="../../chapter-9/concurrency-patterns/go-concurrency-pattern-queuing">Queuing&lt;/a>&lt;/td>
&lt;td>الگوی &amp;ldquo;صف&amp;rdquo; در زبان گو الگویی است که در آن از یک گوروتین برای بافر کردن و مدیریت ترتیب مقادیر ارسال شده و دریافت شده از یک کانال استفاده می شود.&lt;/td>
&lt;td>✅&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="../../chapter-9/concurrency-patterns/go-concurrency-pattern-ratelimit">Rate limit&lt;/a>&lt;/td>
&lt;td>الگوی &lt;strong>Rate Limiting&lt;/strong> برای کنترل تعداد درخواست‌ها یا وظایف همزمان در یک بازه زمانی مشخص استفاده می‌شود. این الگو با استفاده از یک &lt;code>time.Ticker&lt;/code> یا روش‌های مشابه، اجرای گوروتین‌ها یا پردازش داده‌ها را محدود می‌کند.&lt;/td>
&lt;td>✅&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="../../chapter-9/concurrency-patterns/go-concurrency-pattern-deadlock-recovery">Deadlock Recovery&lt;/a>&lt;/td>
&lt;td>الگوی &lt;strong>بازیابی از بن‌بست&lt;/strong> (Deadlock Recovery) برای شناسایی و بازیابی از وضعیت‌های بن‌بست استفاده می‌شود، جایی که چندین گوروتین به طور نامحدود منتظر منابعی هستند که توسط یکدیگر نگه داشته شده‌اند. بن‌بست می‌تواند به دلیل همگام‌سازی نادرست یا رقابت برای منابع در برنامه‌های همزمان رخ دهد.&lt;/td>
&lt;td>✅&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="../../chapter-9/concurrency-patterns/go-concurrency-pattern-lock-free-synchronization">Lock-free synchronization&lt;/a>&lt;/td>
&lt;td>&lt;strong>همگام‌سازی بدون قفل (lock-free synchronization)&lt;/strong> به مجموعه‌ای از تکنیک‌ها و الگوهای برنامه‌نویسی گفته می‌شود که به چندین thread یا goroutine اجازه می‌دهد به طور همزمان و ایمن به داده‌های مشترک دسترسی پیدا کنند، بدون اینکه از primitiveهایی مثل Mutex یا قفل‌های سنتی استفاده شود. هدف اصلی این الگوها افزایش &lt;strong>بازدهی (throughput)&lt;/strong>، کاهش &lt;strong>زمان انتظار (latency)&lt;/strong> و جلوگیری از مشکلات رایج قفل‌گذاری (مثل deadlock، priority inversion و contention) است. الگوریتم‌های lock-free تضمین می‌کنند که حتی اگر برخی از threadها متوقف شوند یا دچار کندی شوند، باقی سیستم همچنان قادر به پیشرفت خواهد بود (&lt;strong>progress guarantee&lt;/strong>).&lt;/td>
&lt;td>✅&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><author/><title>4.1 آموزش Build پروژه</title><link>https://book.gofarsi.ir/chapter-4/build-go-file/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/build-go-file/</guid><description>&lt;p>برای build یک پروژه شما باید از کامند go build استفاده کنید که این کامند دارای یکسری سوییچ می باشد که در زیر ما معرفی خواهیم کرد.&lt;/p>
&lt;h2 id="411-نحوه-build-یک-فایل-گو">
4.1.1 نحوه build یک فایل گو
&lt;a class="anchor" href="#411-%d9%86%d8%ad%d9%88%d9%87-build-%db%8c%da%a9-%d9%81%d8%a7%db%8c%d9%84-%da%af%d9%88">#&lt;/a>
&lt;/h2>
&lt;p>معمولا شما باید برای build فایلی که دارای package main هست را برای build استفاده کنید مانند مثال زیر :&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go build main.go
&lt;/code>&lt;/pre>
&lt;p>پس از build در محل همان فایل یک فایل با نام main ایجاد می شود.&lt;/p></description></item><item><author/><title>4.2 آموزش کار با Debugging</title><link>https://book.gofarsi.ir/chapter-4/debugging-go-code/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/debugging-go-code/</guid><description>&lt;p>برای بحث debugging در زبان گو روش های مختلفی وجود دارد که محبوبترین روش ها به شرح زیر می باشد :&lt;/p>
&lt;ol>
&lt;li>با استفاده پکیج &lt;code>fmt&lt;/code> : شما با استفاده از تابع &lt;code>fmt.Println&lt;/code> می توانید مقادیر برخی از متغیرها را چاپ کنید و یکی از روش های ساده برای بحث دیباگ هستش.&lt;/li>
&lt;li>با استفاده از پکیج &lt;code>log&lt;/code> : یکی از کاربردی ترین روش ها بحث لاگ کردن هستش که شما می توانید هر بخش از کدهای خود را لاگ کنید و بصورت زنده در console یا داخل فایل ببینید و از همه مهمتر شما می توانید لاگ های خود را سطح بندی کنید تا بهتر بتوانید دیباگ کنید.&lt;/li>
&lt;li>استفاده از پکیج &lt;code>pprof&lt;/code> : پکیج pprof به شما کمک می کند تا راحتر مشکلات عملکردی برنامه خود را بیابید و همچنین خروجی profile از عملکرد برنامه با CPU و Memory را آنالیز کنید.&lt;/li>
&lt;li>با استفاده از IDE ها: اکثر IDE هایی (Goland, Vscode) که قبلا معرفی کردیم دارای دیباگر داخلی می باشند که شما می توانید در هر بخش از کد خود breakpoint بزارید و خط به خط کد را دیباگ کنید و مشکلات را برطرف کنید.&lt;/li>
&lt;li>با استفاده از دیباگر &lt;code>dlv&lt;/code> : یکی از محبوبترین دیباگرهایی بصورت متن باز در حال توسعه است &lt;a href="https://github.com/go-delve/delve">delve&lt;/a> می باشد که به شما برای دیباگ کردن بصورت تعاملی هنگام اجرا کمک می کند.&lt;/li>
&lt;/ol>
&lt;p>حال در ادامه ما با مثال هایی نحوه کار با این شیوه هایی که معرفی کردیم آموزش می دهیم.&lt;/p></description></item><item><author/><title>4.3 آموزش کار با go mod</title><link>https://book.gofarsi.ir/chapter-4/go-mod/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/go-mod/</guid><description>&lt;p>از نسخه 1.11 زبان گو مفهوم جدیدی برای مدیریت &lt;span class="tooltip" data-tooltip="dependencies" ontouchend="toggleTooltip(this)">وابستگی ها&lt;/span>
آمد و جایگزین GOPATH شد. ماژول های گو این امکان را می دهد خیلی راحت ماژول های مختلف را به پروژه اضافه کنید و نسخه های هر ماژول را مدیریت کنید. با استفاده از ماژول گو برنامه نویسان گو محدود به GOPATH برای توسعه نخواهد بود و در جایی می توانند پروژه خود را ایجاد و ماژول های پروژه را به آسانی مدیریت کند.&lt;/p></description></item><item><author/><title>4.4 آموزش کار با workspace</title><link>https://book.gofarsi.ir/chapter-4/workspace/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/workspace/</guid><description>&lt;p>با استفاده از workspace می توانید همزمان چندین ماژول در یک محل داشته باشید و هر ماژول را به راحتی مدیریت کنید و همچنین همزمان به آسانی این ماژول ها را build و اجرا کنید.&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go help work
Work provides access to operations on workspaces.
Note that support for workspaces is built into many other commands, not
just 'go work'.
See 'go help modules' for information about Go's module system of which
workspaces are a part.
See https://go.dev/ref/mod#workspaces for an in-depth reference on
workspaces.
See https://go.dev/doc/tutorial/workspaces for an introductory
tutorial on workspaces.
A workspace is specified by a go.work file that specifies a set of
module directories with the &amp;quot;use&amp;quot; directive. These modules are used as
root modules by the go command for builds and related operations. A
workspace that does not specify modules to be used cannot be used to do
builds from local modules.
go.work files are line-oriented. Each line holds a single directive,
made up of a keyword followed by arguments. For example:
go 1.18
use ../foo/bar
use ./baz
replace example.com/foo v1.2.3 =&amp;gt; example.com/bar v1.4.5
The leading keyword can be factored out of adjacent lines to create a block,
like in Go imports.
use (
../foo/bar
./baz
)
The use directive specifies a module to be included in the workspace's
set of main modules. The argument to the use directive is the directory
containing the module's go.mod file.
The go directive specifies the version of Go the file was written at. It
is possible there may be future changes in the semantics of workspaces
that could be controlled by this version, but for now the version
specified has no effect.
The replace directive has the same syntax as the replace directive in a
go.mod file and takes precedence over replaces in go.mod files. It is
primarily intended to override conflicting replaces in different workspace
modules.
To determine whether the go command is operating in workspace mode, use
the &amp;quot;go env GOWORK&amp;quot; command. This will specify the workspace file being
used.
Usage:
go work &amp;lt;command&amp;gt; [arguments]
The commands are:
edit edit go.work from tools or scripts
init initialize workspace file
sync sync workspace build list to modules
use add modules to workspace file
Use &amp;quot;go help work &amp;lt;command&amp;gt;&amp;quot; for more information about a command.
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>پیش نیاز ها&lt;/strong>&lt;/p></description></item><item><author/><title>4.5 آموزش کار با Vendor</title><link>https://book.gofarsi.ir/chapter-4/vendor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/vendor/</guid><description>&lt;p>در زبان گو یک کامند کاربردی در go mod به نام vendor داریم که ماژول هایی که داخل پروژه استفاده شده و مورد نیاز برای اجرا و بیلد می باشد را در محل پروژه کش می کند و به شما این امکان را می دهد خیلی سریع و راحت بدون نیاز به دانلود مجدد ماژول پروژه را بیلد و اجرا کنید.&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go help mod vendor
usage: go mod vendor [-e] [-v] [-o outdir]
Vendor resets the main module's vendor directory to include all packages
needed to build and test all the main module's packages.
It does not include test code for vendored packages.
The -v flag causes vendor to print the names of vendored
modules and packages to standard error.
The -e flag causes vendor to attempt to proceed despite errors
encountered while loading packages.
The -o flag causes vendor to create the vendor directory at the given
path instead of &amp;quot;vendor&amp;quot;. The go command can only use a vendor directory
named &amp;quot;vendor&amp;quot; within the module root directory, so this flag is
primarily useful for other tools.
See https://golang.org/ref/mod#go-mod-vendor for more about 'go mod vendor'.
&lt;/code>&lt;/pre>
&lt;h2 id="451-ایجاد-vendor">
4.5.1 ایجاد vendor
&lt;a class="anchor" href="#451-%d8%a7%db%8c%d8%ac%d8%a7%d8%af-vendor">#&lt;/a>
&lt;/h2>
&lt;p>با دستور زیر می توانید در محل پروژه خود پوشه vendor ایجاد کنید و ماژول های استفاده شده را داخل این پوشه کش کنید.&lt;/p></description></item><item><author/><title>4.6 آموزش نوشتن برنامه command line</title><link>https://book.gofarsi.ir/chapter-4/command-line-go/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/command-line-go/</guid><description>&lt;h2 id="461-مقدمه">
4.6.1 مقدمه
&lt;a class="anchor" href="#461-%d9%85%d9%82%d8%af%d9%85%d9%87">#&lt;/a>
&lt;/h2>
&lt;p>هنگامی که می‌خواهید نرم‌افزاری بنویسید، ممکن است بخواهید از محیط Command Line یا خط فرمان استفاده کنید. خط فرمان، رابط کاربری ساده‌تری نسبت به محیط گرافیکی دارد و در برخی موارد، سرعت بخش بسیار قابل توجهی است. برای آموزش نوشتن برنامه در خط فرمان، شما به یک زبان برنامه‌نویسی نیاز دارید که از بسیاری از کانسپت‌هایی که در برنامه‌نویسی استفاده می‌شوند، پشتیبانی کند. ما به شما پیشنهاد می‌دهیم که از زبان برنامه‌نویسی Go استفاده کنید زیرا برای کار با Command Line بسیار مناسب است.&lt;/p></description></item><item><author/><title>4.7 آموزش کار با فایل</title><link>https://book.gofarsi.ir/chapter-4/work-with-file-in-go/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/work-with-file-in-go/</guid><description>&lt;h2 id="471-مقدمه">
4.7.1 مقدمه
&lt;a class="anchor" href="#471-%d9%85%d9%82%d8%af%d9%85%d9%87">#&lt;/a>
&lt;/h2>
&lt;p>توسعه دهندگان Go می‌توانند از پکیج‌های built-in مانند &amp;ldquo;os&amp;rdquo; و &amp;ldquo;io&amp;rdquo; برای کار با فایل‌ها استفاده کنند. همچنین، پکیج‌های دیگری نیز برای کار با فایل وجود دارند که می‌توان به عنوان پکیج استاندارد نامید. نمونه ای از این پکیج‌ها، پکیج &amp;ldquo;bufio&amp;rdquo; است که برای کار با بافرهای ورودی/خروجی استفاده شده و به توسعه دهندگان اجازه می‌دهد تا برنامه‌هایی با عملکرد بهتر و با کارایی بالاتر ایجاد کنند.&lt;/p></description></item><item><author/><title>4.8 آموزش کار با json</title><link>https://book.gofarsi.ir/chapter-4/work-with-json-file-in-go/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/work-with-json-file-in-go/</guid><description>&lt;h2 id="481-مقدمه">
4.8.1 مقدمه
&lt;a class="anchor" href="#481-%d9%85%d9%82%d8%af%d9%85%d9%87">#&lt;/a>
&lt;/h2>
&lt;p>JSON یک فرمت متنی است که برای مبادله و ذخیره داده‌ها استفاده می‌شود. نام JSON مخفف عبارت JavaScript Object Notation است و در ابتدا به عنوان یک زبان مبتنی بر جاوااسکریپت توسعه یافته است. با این حال، در حال حاضر JSON به راحتی با بیشتر زبان‌های برنامه‌نویسی سازگار است.&lt;/p>
&lt;p>JSON یک مجموعه از جفت‌های «key: value» است که با کاما از یکدیگر جدا شده‌اند و بین آنها با «:» ارتباط دارند. JSON در بین برنامه‌نویسان به عنوان یک ساختار داده‌ای محبوب است و به راحتی داده‌ها را به صورت ساختاردهی شده در برنامه‌های کاربردی مختلف به کار می‌رود. این فرمت دیتا استاندارد و مستقل از زبان‌ها و پلتفرم‌های برنامه‌نویسی است و برای برنامه‌های تحت وب، موبایل، دسکتاپ و سرور قابل استفاده است.&lt;/p></description></item><item><author/><title>4.9 آموزش کار با toml</title><link>https://book.gofarsi.ir/chapter-4/work-with-toml-file-in-go/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/work-with-toml-file-in-go/</guid><description>&lt;h2 id="491-مقدمه">
4.9.1 مقدمه
&lt;a class="anchor" href="#491-%d9%85%d9%82%d8%af%d9%85%d9%87">#&lt;/a>
&lt;/h2>
&lt;p>فایل‌های TOML یک نمونه از فایل‌های پیکربندی هستند که در سیستم‌های مدرن مورد استفاده قرار می‌گیرند، این فایل‌ها به صورت متنی و قابل خواندن برای انسان و در عین حال قابل پردازش برای ماشین طراحی شده‌اند.&lt;/p>
&lt;p>TOML مخفف کلمات (Tom&amp;rsquo;s Obvious, Minimal Language) می‌باشد. جمعیت بزرگتری از افراد آن را مفسرند به این شکل که TOML ابزاری ساده برای پیکربندی بسیار درون‌فرمانی است. این فرمت فایل متنی دارای مقادیر شبیه به دیکشنری بوده و در بسیاری از نرم‌افزارها، به‌طور خاص در نرم‌افزارهای ساخته شده با golang بسیار به‌کار می‌رود.&lt;/p></description></item><item><author/><title>4.10 آموزش کار با yaml</title><link>https://book.gofarsi.ir/chapter-4/work-with-yaml-file-in-go/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/work-with-yaml-file-in-go/</guid><description>&lt;h2 id="4101-مقدمه">
4.10.1 مقدمه
&lt;a class="anchor" href="#4101-%d9%85%d9%82%d8%af%d9%85%d9%87">#&lt;/a>
&lt;/h2>
&lt;p>YAML یک زبان فراهم کننده ساختار پذیر برای نمایش اطلاعات است که در قالب متن موجود می‌باشد. این زبان ابتدا برای نوشتن سند‌های XML توسعه یافت که با پیشرفت کاربردهای آن به محل جایگزینی برای فرمت‌های رایجی همچون JSON و اقلیتاً TOML تبدیل شده است.&lt;/p>
&lt;p>این فرمت در صنعت‌های مختلف مورد استفاده و ستوده شده ‌است، مانند ذخیره سازی تنظیمات سیستمی، فایل‌های کانفیگ مختلف، فایل‌های داده و &amp;hellip; . همچنین به خاطر قابل خواندن بودن برای انسان، استفاده از YAML در فایل‌هایی که باید توسط بشر خوانده شوند مانند فایل‌های خودرو، پروژه و&amp;hellip; صورت گرفته است.&lt;/p></description></item><item><author/><title>4.11 آموزش کار با csv</title><link>https://book.gofarsi.ir/chapter-4/work-with-csv-file-in-go/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/work-with-csv-file-in-go/</guid><description>&lt;h2 id="4111-مقدمه">
4.11.1 مقدمه
&lt;a class="anchor" href="#4111-%d9%85%d9%82%d8%af%d9%85%d9%87">#&lt;/a>
&lt;/h2>
&lt;p>CSV یکی از فرمت‌های متداول برای ذخیره داده‌های جدولی است. خروجی اکثر برنامه‌های قابلیت دستکاری داده، همراه با نرم‌افزار‌های آفیس، به فرمت CSV تولید می‌شود. فرمت CSV چندین ستون در یک ردیف را با استفاده از کاما (,) جدا کرده و هر ردیف را با استفاده از عبارت جدید (newline) جدا می‌کند.&lt;/p>
&lt;p>در زبان برنامه‌نویسی Go نیز پکیج encoding/csv وجود دارد که در آن، توابع مربوط به خواندن و نوشتن داده‌های CSV به صورت دستی یا از طریق پرونده‌ها فراهم شده است. با استفاده از این پکیج، می‌توان داده‌های CSV را به داده‌های جدولی تبدیل کرد و برعکس.&lt;/p></description></item><item><author/><title>4.12 آموزش کار با ini</title><link>https://book.gofarsi.ir/chapter-4/work-with-ini-file-in-go/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/work-with-ini-file-in-go/</guid><description>&lt;p>بطور خلاصه فایل های ini.* جهت ذخیره تنظیمات مختلف استفاده می شود تنظیماتی مثل: آدرس خاص در شبکه، اطلاعات ورود به سیستم های مختلف و موارد از این قبیل.&lt;/p>
&lt;p>برای شروع ساختار پروژه ما به این شکل است&lt;/p>
&lt;pre>&lt;code class="language-shell">$ mkdir -p /tmp/ini
$ cd /tmp/ini
$ touch my.ini main.go
$ tree . .
├── main.go
└── my.ini
&lt;/code>&lt;/pre>
&lt;p>در پروژه دو فایل ایجاد کردیم یکی فایل اصلی برنامه main.go و دیگری my.ini که می خواهیم تنظیمات برنامه را در آن نگهداری کنیم. محتوای داخل فایل ini را بصورت ذیل تعریف کرده ایم&lt;/p></description></item><item><author/><title>4.13 آموزش کار با environment variable</title><link>https://book.gofarsi.ir/chapter-4/work-with-environment-variable/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/work-with-environment-variable/</guid><description>&lt;p>Environment Variables یا متغیرهای محیطی، متغیرهایی هستند که در فضای محیطی سیستم عامل مشخص شده‌اند. این متغیرها، شامل اطلاعاتی مانند مسیر فایل‌ها، تنظیمات سیستم، ترجیحات و تعیینات ساده و دیگر اطلاعات مورد استفاده توسط برنامه‌ها هستند.&lt;/p>
&lt;p>به عنوان مثال، در سیستم عامل لینوکس، PATH یک متغیر محیطی است که شامل یک فهرست از دایرکتوری‌هایی است که سیستم به دنبال فایل‌ها و برنامه‌ها می‌گردد. برای دسترسی به این متغیر، می‌توان از دستور زیر در خط فرمان استفاده کرد:&lt;/p></description></item><item><author/><title>4.14 آموزش کار با regexp</title><link>https://book.gofarsi.ir/chapter-4/go-regular-expressions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/go-regular-expressions/</guid><description>&lt;p>مواقعی در کد نویسی دارید که نیاز هست تا یک عبارتی مثل شماره تلفن،کد پستی و یا شماره پاسپورت وارد شده را بصورت قاعده مند بررسی کنید به عبارتی کاربر نتواند برای فیلد شماره تلفن، کاراکتر غیر عددی وارد کند. در این مواقع بهتر است داده وارد شده بصورت قاعده مند بررسی شود. برای درک بهتر موضوع به رشته وارد شده توسط کاربر که می تواند سهوا باشد دقت کنید&lt;/p></description></item><item><author/><title>4.15 آموزش reflection</title><link>https://book.gofarsi.ir/chapter-4/go-reflection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/go-reflection/</guid><description>&lt;p>پکیج &lt;a href="https://pkg.go.dev/reflect">reflect&lt;/a> در زبان Go، امکانات reflection زمان اجرا را فراهم می‌کند که به یک برنامه اجازه می‌دهد تا با اشیاءی با انواع دلخواه کار کند. استفاده اصلی این پکیج، گرفتن اطلاعات نوع پویای یک مقدار با نوع استاتیک interface{} با فراخوانی تابع TypeOf است که یک مقدار Type را برمی‌گرداند.&lt;/p>
&lt;p>با فراخوانی تابع ValueOf، یک شیء Value که حاوی دادهٔ زمان اجراست، برمی‌گرداند. تابع Zero یک مقدار Type دریافت کرده و یک شیء Value را که مقدار صفر برای آن نوع است، برمی‌گرداند.&lt;/p></description></item><item><author/><title>4.16 آموزش generator</title><link>https://book.gofarsi.ir/chapter-4/go-generator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/go-generator/</guid><description>&lt;p>کد generator در گو، یک ابزار است که برای تولید کد خودکار استفاده می‌شود. برای ایجاد یک کد generator در گو، می‌توان از قابلیت‌هایی که در زبان گو موجود است، مانند بسته‌های &lt;code>go/ast&lt;/code> و &lt;code>go/parser&lt;/code> استفاده کرد.&lt;/p>
&lt;p>با استفاده از بسته &lt;code>go/ast&lt;/code> می‌توانید ساختار داده‌های AST (Abstract Syntax Tree) را برای کد خود بسازید. AST، ساختار درختی از کدهای گو است که به طور معمول برای بررسی و تحلیل کد استفاده می‌شود.&lt;/p></description></item><item><author/><title>4.17 آموزش stringer</title><link>https://book.gofarsi.ir/chapter-4/go-stringer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/go-stringer/</guid><description>&lt;p>Stringer به طور کلی برای پیاده‌سازی مفهوم شمارشی (enumeration) استفاده می‌شود در حالی که از برنامه‌نویسی ثابت رشته‌های مقدار استفاده نمی‌کند. شمارشی یا enum زمانی استفاده می‌شود که می‌خواهید مجموعه‌ای متناهی و ثابتی از مقادیر یک نوع داده‌ای را تعریف کنید. به عنوان مثال، انواع غذا در منو (پیش غذا، اصلی، دسر)، انواع پوکمون (گیاهی، آبی، آتشی، و غیره).&lt;/p>
&lt;p>بنابراین، زمانی که می‌خواهیم از این مجموعه‌های تعریف شده استفاده کنیم، باید از برنامه‌نویسی ثابت رشته‌های مقدار استفاده کنیم زیرا ممکن است به خطاهای انسانی مانند اشتباهات املایی منجر شود. اگر از Stringer استفاده کنیم، مقادیر را یکبار تولید می‌کنیم و مطمئن می‌شویم که هیچ خطایی ایجاد نمی‌شود. پس از آن، می‌توانیم از آن‌ها بدون نگرانی از خطاهای انسانی استفاده کنیم.&lt;/p></description></item><item><author/><title>4.18 تکنیک های کدنویسی زبان گو</title><link>https://book.gofarsi.ir/chapter-4/effective-go/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/effective-go/</guid><description>&lt;p>در این بخش به موارد زیر می پردازیم.&lt;/p>
&lt;ul>
&lt;li>کارآمدی (effective)&lt;/li>
&lt;li>استایل اوبر&lt;/li>
&lt;li>تکنیک ها&lt;/li>
&lt;li>نکات فنی&lt;/li>
&lt;li>بهینه سازی&lt;/li>
&lt;/ul>
&lt;h2 id="4181-کارآمدی-effective">
4.18.1 کارآمدی (Effective)
&lt;a class="anchor" href="#4181-%da%a9%d8%a7%d8%b1%d8%a2%d9%85%d8%af%db%8c-effective">#&lt;/a>
&lt;/h2>
&lt;p>در زیر به کارآمدی زبان گو می پردازیم.&lt;/p>
&lt;h3 id="41811-نام-پکیج-ها">
4.18.1.1 نام پکیج ها
&lt;a class="anchor" href="#41811-%d9%86%d8%a7%d9%85-%d9%be%da%a9%db%8c%d8%ac-%d9%87%d8%a7">#&lt;/a>
&lt;/h3>
&lt;p>زمانیکه شما یک پکیج را ایمپورت میکنید نام پکیج در بالای بدنه فایل گو قرار میگیرد مانند :&lt;/p>
&lt;pre>&lt;code class="language-go">import &amp;quot;bytes&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>حال وقتی که پکیج ایمپورت می شود و نام اش در بالای بدنه فایل کد شما قرار میگیرد می توانید در ادامه نام پکیج توابع, تایپ ها و یا متغیر و const ها را مانند &lt;code>bytes.Buffer&lt;/code> فراخوانی کنید.&lt;/p></description></item><item><author/><title>4.19 اصول کامنت نویسی</title><link>https://book.gofarsi.ir/chapter-4/go-commentry/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/go-commentry/</guid><description>&lt;p>اصول کامنت‌نویسی در زبان گو&lt;/p>
&lt;h2 id="4191-تعریف">
4.19.1 تعریف
&lt;a class="anchor" href="#4191-%d8%aa%d8%b9%d8%b1%db%8c%d9%81">#&lt;/a>
&lt;/h2>
&lt;p>«کامنت» به توضیحات‌ی گفته می‌شود که داخل کد، به‌قصد «یادآوری»، «جلب‌توجه مخاطب به موضوع‌(ها)ی خاص»، کمک به onboard شدن اعضاء جدید تیم و مانند اون نگارش می‌شود. در زبان گو، به شیوه‌های زیر کامنت می‌گذاریم:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>قرار دادن &lt;code>//&lt;/code> در ابتدای سطر.&lt;/p>
&lt;pre>&lt;code class="language-go">// defined to store multi string (see below why this is not a good comment)
var sliceVar []string
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>قراردادن متن کامنت داخل یک بلوک که با &lt;code>*/&lt;/code> شروع می‌شود و &lt;code>/*&lt;/code> تمام می‌شود.&lt;/p></description></item><item><author/><title>4.20 قوانین کدنویسی در گو</title><link>https://book.gofarsi.ir/chapter-4/go-code-rules/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/go-code-rules/</guid><description>&lt;p>قوانین در زبان گو همانند دیگر زبان های برنامه نویسی به دو دسته تقسیم می شود. بخشی از قوانین در سطح &lt;span class="tooltip" data-tooltip="Syntax" ontouchend="toggleTooltip(this)">سینتکس&lt;/span>
زبان مطرح می شوند، لذا رعایت آنها مهم هست، در غیر اینصورت کامپایلر قادر به کامپایل درست کدهای شما نخواهد بود و در بعضی شرایط ممکن است به صورت خاموش خطا به محیط اجرا (runtime) نیز برده شود. بخشی از قوانین به عنوان پیشنهاد و ترجیح مطرح هستند که عموما توسط لینتر بررسی می شوند و تاثیر اصلی بر خوانایی منطق کدها دارند. یعنی رعایت آنها الزام قطعی ندارد. به طور مثال استفاده از &lt;code>_&lt;/code> در نام گذاری ها در گو توصیه نمی شود ولی در کتابخانه استاندارد (الحاقی به زبان گو) به وفور عدم رعایت این موضوع دیده می شود.&lt;/p></description></item><item><author/><title>4.21 زباله جمع کن (garbage collector)</title><link>https://book.gofarsi.ir/chapter-4/go-garbage-collector/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/go-garbage-collector/</guid><description>&lt;p>یکی از جذابیت های زبان های برنامه نویسی جدید قابلیت زباله جمع کن (garbage collector) ایجاد شده در آنها است. بطور خلاصه مدیریت و آزاد سازی منابع اختصاص داده شده از حافظه را که بصورت خودکار در زبان های برنامه نویسی مدرن انجام می شود را garbage collector می شناسیم.&lt;/p>
&lt;p>مدیریت منابع حافظه که بسیار حساس و در مواقعی زمان بر است توسط برخی زبان ها بصورت توکار پشتیبانی می شود و این کار به افزایش سرعت و همچنین کاهش خطا در زمان و پروسه تولید نرم افزار می شود. با تمام این تفاسیر مواقعی است که برنامه نویس می باید خودش مدیریت حافظه را در دست گرفته و پیش از بروز شرایط بحرانی اقدام به آزاد سازی حافظه و یا منابع اختصاص یافته نماید. خبر خوب اینکه در زبان Go مدیریت منابع حافظه نسبت به زبان های دیگر ساده تر و راحتر است ولی در این نوشته سعی می کنیم تا درک خوبی از مدیریت منابع و نحوه عملکرد آن داشته باشید بنابر این در ادامه با یک مثال که نیاز به بررسی کد در سطوح پایین دارد می پردازیم.&lt;/p></description></item><item><author/><title>4.22 کتابخانه Plugin</title><link>https://book.gofarsi.ir/chapter-4/go-plugin/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/go-plugin/</guid><description>&lt;p>در میان ویژگی‌های قابل توجه Go نسخه 1.8، سیستم جدید پلاگین‌های Go قرار دارد. این ویژگی به برنامه‌نویسان اجازه می‌دهد تا برنامه‌های ماژولار بدون ارتباط زنجیره‌ای با هم، با استفاده از بسته‌هایی که به صورت کتابخانه‌های اشیا شیء‌گرا کامپایل شده‌اند، ساخته شوند و به‌صورت پویا در زمان اجرا بارگذاری و به‌صورت پیوسته به آن‌ها پیوند داده شوند.&lt;/p>
&lt;p>این تغییر بزرگی است! چرا که توسعه‌دهندگان نرم‌افزارهای سیستمی بزرگ در Go، بدون شک، نیاز به ماژولارسازی کد خود دارند. ما برای دستیابی به ماژولارسازی کد، از طراحی‌های متعدد out-of-process، مانند &lt;a href="https://kubernetes.io/docs/admin/network-plugins/">OS exec calls&lt;/a>، &lt;a href="https://docs.docker.com/engine/extend/plugin_api/">سوکت&lt;/a> و &lt;a href="https://github.com/hashicorp/go-plugin">RPC/gRPC&lt;/a> (و غیره) استفاده کرده‌ایم. این روش‌ها ممکن است به خوبی کار کنند، اما در بسیاری از زمینه‌ها به‌عنوان پایانه‌ای برای پردازش با قبل نبود یک سیستم پلاگین‌ای ناتیو در Go بکار رفته‌اند.&lt;/p></description></item><item><author/><title>4.23.1 کپسوله سازی (Encapsulation)</title><link>https://book.gofarsi.ir/chapter-4/oop/go-encapsulation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/oop/go-encapsulation/</guid><description>&lt;p>کپسوله سازی در زبان گو یا هر زبان دیگری یک مفهوم مشترک می باشد که شما یک داده یک تابع را پشت یک آبجکت یا یک واحد مستقل بپوشانید. با اینکار شما جلوی دسترسی مستقیم برروی داده را میگیرید. این کار در شی گرایی کمک می کند شما کدهای خود را بهتر سازماندهی کنید و جلوی دسترسی مستقیم ناخواسته را بگیرید.&lt;/p>
&lt;p>در زبان گو برای Public/Private کردن یک آبجکت یا تابع کلمه کلیدی به نام public/private ندارد ولی در عوض شما می توانید داخل هر پکیج با بزرگ یا کوچک کردن حرف اول نام هر آبجکت یا تابع جلو دسترسی مستقیم را بگیرید.&lt;/p></description></item><item><author/><title>4.22.2 ارث بری</title><link>https://book.gofarsi.ir/chapter-4/oop/go-inheritance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/oop/go-inheritance/</guid><description>&lt;p>در زبان گو ارث بری در واقع type embedding هست با استفاده &lt;a href="../../../chapter-2/type-embedding/">type embedding&lt;/a> می توانید یک type را داخل type دیگری جاسازی کنید و به واسطه type والد قابل دسترس است.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
type Person struct {
Name string
}
func (p *Person) Introduce() {
fmt.Printf("Hi, my name is %s\n", p.Name)
}
type Student struct {
Person
School string
}
func main() {
s := &amp;Student{Person{"John Doe"}, "Go University"}
s.Introduce()
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div></description></item><item><author/><title>4.23.3 پلی مورفیسم (Polymorphism)</title><link>https://book.gofarsi.ir/chapter-4/oop/go-polymorphism/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/oop/go-polymorphism/</guid><description>&lt;p>پلی مورفیسم یکی از مفاهیم مهم در شی گرایی می باشد و هدف استفاده از پلی مورفیسم این است بین آبجکت ها رفتار مشترکی ایجاد کنیم. در زبان گو شما می توانید یک اینترفیس تعریف کنید و برای ساختارهای مختلف متدهای اینترفیس را پیاده سازی کنید.&lt;/p>
&lt;p>به مثال زیر توجه کنید :&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
// Shape is an interface that defines a method named `Area`
type Shape interface {
Area() float64
}
// Rectangle is a struct that represents a rectangle
type Rectangle struct {
width float64
height float64
}
// Area implements the Shape interface for Rectangle
func (r Rectangle) Area() float64 {
return r.width * r.height
}
// Circle is a struct that represents a circle
type Circle struct {
radius float64
}
// Area implements the Shape interface for Circle
func (c Circle) Area() float64 {
return 3.14 * c.radius * c.radius
}
func CalcArea(shapes ...Shape) {
for _, shape := range shapes {
fmt.Println(shape.Area())
}
}
func main() {
r := Rectangle{width: 10, height: 5}
c := Circle{radius: 5}
CalcArea(r, c)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در کد فوق ما یک اینترفیس Shape داریم که داخلش یک متد به نام Area هست حال این متد را برای ساختارهای Rectangle و Circle پیاده سازی کردیم که مساحت دایره و مستطیل را محاسبه کنیم. حال یک تابع CalcArea داریم به عنوان پارامتر slice از Shape ها میگیرد که ما داخل تابع main ساختار Rectangle و Circle که متد Area اینترفیس Shape را پیاده سازی کرده اند را پاس دادیم و در نهایت محاسبه مساحت را در خروجی چاپ می کند.&lt;/p></description></item><item><author/><title>4.23.4 overriding</title><link>https://book.gofarsi.ir/chapter-4/oop/go-overriding/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/oop/go-overriding/</guid><description>&lt;p>در زبان گو مثل سایر زبان های شی گرا امکان overriding مستقیم یک متد وجود ندارد اما در عوض شما می توانید با استفاده از &lt;a href="../../../chapter-2/type-embedding/">type embedding&lt;/a> و پیاده سازی متد یک اینترفیس این تکنیک را انجام دهید و به متدی که override انجام داده Shadow Method می گویند.&lt;/p>
&lt;p>به مثال زیر توجه کنید :&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
type User interface {
PrintName()
}
type Person struct {
Name string
}
func (p Person) PrintName() {
fmt.Println("My name is", p.Name)
}
type Student struct {
Person
}
func (s Student) PrintName() {
fmt.Println("I am a student and my name is", s.Name)
}
func main() {
p := Person{Name: "John"}
s := Student{Person{Name: "Jane"}}
p.PrintName()
s.PrintName()
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در کد فوق ما یک اینترفیس User داریم که داخلش یک متد PrintName وجود دارد که این متد نام شخص یا دانش آموز را به همراه توضیحات چاپ می کند.
حال ۲ تا ساختار داریم Person و Student که ساختار student فقط Person را جاسازی کرده است. سپس برای این ۲ ساختار متد PrintName را پیاده سازی کردیم با این تفاوت که داخل متد PrintName ساختار Student متن دیگری قرار دادیم. در تابع main ما متغیر p, s را از نوع Person و Student ایجاد و مقدار دهی کردیم. سپس متد PrintName هر دو را فراخوانی کردیم.&lt;/p></description></item><item><author/><title>4.23.5 abstraction</title><link>https://book.gofarsi.ir/chapter-4/oop/go-abstraction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/oop/go-abstraction/</guid><description>&lt;p>&lt;strong>Abstraction&lt;/strong> (به معنای انتزاع)، فرآیند حذف یا از بین بردن برخی ویژگی‌های غیرضروری یک چیز به‌منظور کاهش، خلاصه‌سازی و به کار بردن آن در مجموعه‌ای از ویژگی‌های ضروری است. در برنامه‌نویسی شیءگرا(OOP)، انتزاع یکی از سه مفهوم اصلی (به همراه مفاهیم Encapsulation و Inheritance) است.&lt;/p>
&lt;blockquote class="book-hint info">
&lt;p>به نقل از ویکی پدیا :
&lt;strong>انتزاع&lt;/strong>،&lt;a href="https://fa.wikipedia.org/wiki/%D8%A7%D9%86%D8%AA%D8%B2%D8%A7%D8%B9#cite_note-1">[۱]&lt;/a> (به &lt;a href="https://fa.wikipedia.org/wiki/%D8%B2%D8%A8%D8%A7%D9%86_%D8%A7%D9%86%DA%AF%D9%84%DB%8C%D8%B3%DB%8C" title="زبان انگلیسی">انگلیسی&lt;/a>: Abstraction) &lt;strong>تجرید&lt;/strong> یا &lt;strong>آهنجش&lt;/strong> فرایند اختصار، فشرده‌سازی، و تلخیص &lt;a href="https://fa.wikipedia.org/wiki/%D8%A7%D8%B7%D9%84%D8%A7%D8%B9%D8%A7%D8%AA" title="اطلاعات">اطّلاعات&lt;/a> از طریق شناسائی، استخراج و سپس، جداسازی و پنهان‌سازی جزئیّات&lt;a href="https://fa.wikipedia.org/wiki/%D8%A7%D9%86%D8%AA%D8%B2%D8%A7%D8%B9#cite_note-2">[۲]&lt;/a> از کلیّات&lt;a href="https://fa.wikipedia.org/wiki/%D8%A7%D9%86%D8%AA%D8%B2%D8%A7%D8%B9#cite_note-3">[۳]&lt;/a> است. &lt;em>انتزاع&lt;/em> در لغت به معنای جدا کردن، گرفتن، درآوردن جزئی از یک کل&lt;a href="https://fa.wikipedia.org/wiki/%D8%A7%D9%86%D8%AA%D8%B2%D8%A7%D8%B9#cite_note-4">[۴]&lt;/a> و به معنای بازداشتن و امتناع کردن، برکندن و از جای کشیدن، گرفتن، و دور شدن می‌باشد.&lt;a href="https://fa.wikipedia.org/wiki/%D8%A7%D9%86%D8%AA%D8%B2%D8%A7%D8%B9#cite_note-5">[۵]&lt;/a>&lt;/p></description></item><item><author/><title>4.24 آموزش tracing</title><link>https://book.gofarsi.ir/chapter-4/tracing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/tracing/</guid><description>&lt;p>در این فصل، این مورد را یاد خواهیم گرفت که چگونه یک برنامه در حال اجرا را ردیابی کنیم و آن را با ابزار ردیابی مشاهده کنیم. در این حالت با استفاده از کتابخانه استاندارد، یک ردیابی ایجاد خواهیم کرد.&lt;/p>
&lt;h2 id="4241--مثال-از-tracing">
4.24.1 مثال از tracing
&lt;a class="anchor" href="#4241--%d9%85%d8%ab%d8%a7%d9%84-%d8%a7%d8%b2-tracing">#&lt;/a>
&lt;/h2>
&lt;p>ما برنامه ای داریم که تعداد دفعات یافتن یک topic را در collection ای ازRSS news feed document را می شمارد. این برنامه از یک threaded algorithm به نام freq استفاده می کند که روی collection تکرار می شود و هر سند را یک به یک پردازش می کند و تعداد دفعاتی که topic پیدا شده است را برمی‌گرداند.&lt;/p></description></item><item><author/><title>4.25 آموزش profiling</title><link>https://book.gofarsi.ir/chapter-4/profiling/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/profiling/</guid><description>&lt;p>پروفایلینگ یک تکنیک مفید برای شناسایی &lt;span class="tooltip" data-tooltip="bottlenecks" ontouchend="toggleTooltip(this)">گلوگاه‌های&lt;/span>
&lt;span class="tooltip" data-tooltip="performance" ontouchend="toggleTooltip(this)">عملکرد&lt;/span>
، بررسی مصرف حافظه و به دست آوردن بینش درباره سربار جمع‌آوری زباله (Garbage Collection) و موارد دیگر است. اکوسیستم Go ابزارهای فوق‌العاده‌ای برای این منظور ارائه می‌دهد. امکان فعال و غیرفعال کردن پروفایلینگ به ویژه هنگام رفع اشکال در یک برنامه CLI نوشته شده با Go بسیار مفید است.&lt;/p>
&lt;blockquote class="book-hint info">
&lt;p>&lt;strong>نقل و قول نویسنده:&lt;/strong>&lt;/p>
&lt;p>شاید profiling برای حال حاضر قابل اهمیت نباشد اما روزی خواهد رسید که در بخش هایی از پروژه دچار مصرف بیش از حد memory, CPU خواهید شد و اینجاس که profiling به شما کمک خواهد کرد سریز منابع را پیدا کنید.&lt;/p></description></item><item><author/><title>5.1 شبکه چیست</title><link>https://book.gofarsi.ir/chapter-5/network-basic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-5/network-basic/</guid><description>&lt;p>به تجهیزات متصل یکدیگر شبکه گفته می‌شود. مکانیزم‌های اتصال ممکن است از طریق سیم مسی، اترنت، فیبر نوری یا بی‌سیم. اندازه ی شبکه می تواند به اندازه ی اینترنت بزرگ یا به اندازه ی یک شبکه خانگی کوچک باشد. یک شبکه محلی (LAN) کامپیوترهایی را که در نزدیکی یکدیگر هستند، معمولاً تعلق به یک خانه، سازمان کوچک یا قسمتی از یک سازمان بزرگ دارند، به هم متصل می‌کند.&lt;/p>
&lt;p>یک شبکه گسترده (WAN) کامپیوترها را در یک منطقه فیزیکی بزرگتر، مانند بین شهرها متصل می‌کند. انواع دیگری هم وجود دارند، مانند MANs (شبکه‌های منطقه شهری)، PANs (شبکه‌های منطقه شخصی) و حتی BANs (شبکه‌های منطقه بدن).&lt;/p></description></item><item><author/><title>5.2 سرور tcp مقدماتی</title><link>https://book.gofarsi.ir/chapter-5/go-tcp-server-begginer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-5/go-tcp-server-begginer/</guid><description>&lt;p>ما میتوانیم در گو با استفاده از کتابخانه net یک سرور &lt;a href="https://fa.wikipedia.org/wiki/%D9%BE%D8%B1%D9%88%D8%AA%DA%A9%D9%84_%D9%87%D8%AF%D8%A7%DB%8C%D8%AA_%D8%A7%D9%86%D8%AA%D9%82%D8%A7%D9%84">tcp&lt;/a> ایجاد کنیم
بعد از تکمیل شدن سرور با استفاده از دستور &lt;code>telnet&lt;/code> به آن متصل میشویم&lt;/p>
&lt;p>در قطعه کد زیر
با تابع &lt;code>acceptLoop()&lt;/code> درخواست های اتصال را مپذیریم
و با تابع &lt;code>readLoop()&lt;/code> پیام های اتصال را میخوانیم&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"fmt"
"log"
"net"
)
// ساختار هر پیام در سرور
type Message struct {
// ادرس ip ارسال کننده پیام
from string
// متن و محتوای پیام
payload []byte
}
// ساختار سرور
type Server struct {
// ادرس و یا پورت سرور
listenAddr string
// listener
ln net.Listener
// چنل پیام برای انتقال پیام های دریافتی از اتصال ها بین گوروتین ها
msgch chan Message
}
// ایجاد یک سرور جدید
func newServer(listenAddr string) *Server {
return &amp;Server{
listenAddr: listenAddr,
msgch: make(chan Message, 10),
}
}
// شروع سرور و دریافت اتصال های جدید
func (s *Server) start() error {
// شروع سرور
ln, err := net.Listen("tcp", s.listenAddr)
if err != nil {
return err
}
// مقدار دهی listener
s.ln = ln
// با تابع acceptLoop اتصال های جدید به سرور را مدیریت میکنیم
// با استفاده از go هر اتصال را روی یک گوروتین مجزا مدیریت میکنیم
go s.acceptLoop()
return nil
}
// اینجا برای استاپ کردن سرور یک متد جدید تعریف میکنیم
func (s *Server) stop() {
if s.ln != nil {
s.ln.Close()
}
}
func (s *Server) acceptLoop() {
for {
// اتصال های موجود را تایید میکنیم متغییر conn را با اتصال مورد نظر مقدار دهی میکنیم
conn, err := s.ln.Accept()
if err != nil {
fmt.Println("accept error:", err)
continue
}
// با استفاده از این تابع مقادیر ارسال شده توسط اتصال را به چنل message میدهیم
go s.readLoop(conn)
}
}
func (s *Server) readLoop(conn net.Conn) {
defer conn.Close()
buf := make([]byte, 2048)
for {
// پیام ارسال شده توسط هر اتصال را به متغییر buf میدهیم
n, err := conn.Read(buf)
if err != nil {
fmt.Println("read error:", err)
continue
}
s.msgch &lt;- Message{
// ادرس ip ارسال کننده پیام از نوع net.IP
from: conn.RemoteAddr().String(),
// متن پیام
payload: buf[:n],
}
// بعد از دریافت هر پیام یک پیام به عنوان پاسخ ارسال میکنیم
conn.Write([]byte("your message recived!\n"))
}
}
func main() {
// ساخت سرور
server := newServer(":3000")
//start the server
if err := server.start(); err != nil {
log.Fetal(err)
}
go func() {
// در ازای هر پیام مقادیر آن را چاپ میکنیم
for msg := range server.msgch {
fmt.Printf("recived new from connection(%s): %s\n", msg.from, msg.payload)
}
}()
// Run an infinite loop to keep the program running
select {}
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>بعد از پایان پیاده سازی سرور tcp
با دستور زیر سرور خود را اجرا میکنیم:
&lt;code>go run main.go&lt;/code>&lt;/p></description></item><item><author/><title>5.3 سرور tcp پیشرفته</title><link>https://book.gofarsi.ir/chapter-5/go-tcp-server-advanced/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-5/go-tcp-server-advanced/</guid><description>&lt;p>در این قسمت به طراحی و ساخت یک سرور tcp بصورت پیشرفته میپردازیم.
در قسمت قبل بعد از ایجاد سرور TCP ساده با استفاده از کلاینت telnet به آن متصل شدیم و دیتایی را انتقال دادیم.&lt;/p>
&lt;p>در این قسمت یک سرور tcp را با هدف انتقال فایل های &lt;span class="tooltip" data-tooltip="large file" ontouchend="toggleTooltip(this)">حجیم&lt;/span>
بصورت &lt;span class="tooltip" data-tooltip="stream" ontouchend="toggleTooltip(this)">جریان&lt;/span>
ایجاد میکنم.&lt;/p>
&lt;p>قبل از شروع ایجاد سرور خود به دلیل اینکه چرا فایل های حجیم را استریم میکنیم و یا اصلا استریم چیست میپردازیم.
زمانی که شما فایل های کم حجم را مستقیما انتقال میدهید با تاخیر کم و بصورت مطلوب انجام میشود.
اما روایت برای فایل های سنگین تر متفاوت است، اگر این عمل بصورت مستقیم و یکجا انجام شود باعث ایجاد تاخیر و مصرف منابع بیش از حد روی سرور میشود.
اما ما با استفاده از روش استریم، داده و فایل خود را بصورت &lt;span class="tooltip" data-tooltip="chunk file" ontouchend="toggleTooltip(this)">قطعه&lt;/span>
های کم حجم و پشت سر هم ارسال میکنیم.&lt;/p></description></item><item><author/><title>5.4 سرور udp مقدماتی</title><link>https://book.gofarsi.ir/chapter-5/go-udp-server-begginer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-5/go-udp-server-begginer/</guid><description>&lt;p>در این قسمت به طراحی و ساخت یک سرور UDP مقدماتی با گولنگ می پردازیم.&lt;/p>
&lt;h2 id="541-معرفی-udp">
5.4.1 معرفی UDP
&lt;a class="anchor" href="#541-%d9%85%d8%b9%d8%b1%d9%81%db%8c-udp">#&lt;/a>
&lt;/h2>
&lt;p>پروتکل(User Datagram Protocol)
یک پروتکل &lt;span class="tooltip" data-tooltip="connectionless" ontouchend="toggleTooltip(this)">فاقد اتصال&lt;/span>
است.
به این معنا که &lt;span class="tooltip" data-tooltip="packet" ontouchend="toggleTooltip(this)">بسته&lt;/span>
های این پروتکل بدون اتصال قبلی و بررسی اینکه ایا همه بسته ها به درستی ارسال شده اند به دستگاه مورد نظر ارسال میشود.
به همین دلیل سرعت در این پروتکل از پروتکل tcp پایین تر است اما تظمین ارسال کامل و سالم داده وجود ندارد.
از موارد استفاده این پروتکل میتوان سرور بازی های انلاین را مثال زد.&lt;/p></description></item><item><author/><title>5.5 سرور udp پیشرفته</title><link>https://book.gofarsi.ir/chapter-5/go-udp-server-advanced/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-5/go-udp-server-advanced/</guid><description>&lt;p>در قسمت قبل به ایجاد یک سرور udp ساده و ارسال پکت به آن پرداختیم.
در این قسمت با استفاده از یک سرور و کلاینت udp یک پیام رسان بصورت feed میسازیم.
عملکرد سرور و کلاینت:
یک سرور udp ایجاد میکنیم که تمام کانکشن های موجود را ذخیره میکند و به محض دریافت پیام از هر یک از کانکشن ها پیام را برای تمام کانکشن های دیگر بجر کانکشن ارسال کننده پیام ارسال میکند.&lt;/p></description></item><item><author/><title>5.6 کتابخانه http سمت سرور مقدماتی</title><link>https://book.gofarsi.ir/chapter-5/go-http-server-begginer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-5/go-http-server-begginer/</guid><description>&lt;p>یکی از قابلیت های زبان گو این است که می توان با استفاده از کتابخانه http داخلی گو استفاده کرده و وب سرور پیاده سازی کرد.&lt;/p>
&lt;p>برای پیاده سازی یک وب سرور حداقل به 3 چیز نیاز داریم: 1) مسیر 2) درگاه وب سرور 3) مقدار برگشتی&lt;/p>
&lt;p>مسیر: عبارت است از URL منحصر به فرد برای ارسال و دریافت اطلاعات ورودی&lt;/p>
&lt;p>درگاه وب سرور: هر وب سرور نیاز دارد که درگاه (Port) خاصی را در اختیار داشته باشد و همواره به آن درگاه گوش بسپارد.&lt;/p></description></item><item><author/><title>5.7 کتابخانه http سمت سرور پیشرفته</title><link>https://book.gofarsi.ir/chapter-5/go-http-server-advanced/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-5/go-http-server-advanced/</guid><description>&lt;p>در قسمت قبل با استفاده از کتابخانه &lt;code>net/http&lt;/code> یک api ساده ایجاد کردیم.&lt;/p>
&lt;p>در این قسمت به پیاده سازی یک سرور http برای مدیریت لیست TODO های خود میپردازیم و از چهار متد GET, POST, DELET and PATCH استفاده میکنیم.&lt;/p>
&lt;p>در این پروژه از دیتابیس استفاده نمیشود. روش ذخیره سازی اطلاعات درون متغییر هاست دلیل استفاده نکردن از یک دیتابیس تمرکز این قسمت روی کتابخانه و پروتکل http است.&lt;/p>
&lt;p>در ادامه به ایجاد سرور خود میپردازیم.&lt;/p></description></item><item><author/><title>5.8 کتابخانه http سمت کلاینت مقدماتی</title><link>https://book.gofarsi.ir/chapter-5/go-http-client-begginer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-5/go-http-client-begginer/</guid><description>&lt;p>برای ایجاد کلاینت http در گولنگ نیاز به کتابخانه &lt;code>net/http&lt;/code> داریم.
قبل از شروع به نوشتن کلاینت خود چند مفهوم کلی راه بررسی میکنیم.&lt;/p>
&lt;h2 id="581-سرور">
5.8.1 سرور
&lt;a class="anchor" href="#581-%d8%b3%d8%b1%d9%88%d8%b1">#&lt;/a>
&lt;/h2>
&lt;p>همانطور که میدانیم سرور های http برای تعریف مسیر ها منطق سرور و دریافت درخواست ها طراحی و ساخته میشوند.
(در قسمت های قبل ایجاد سرور http بصورت کامل یادگرفتیم)&lt;/p>
&lt;h2 id="582-کلاینت">
5.8.2 کلاینت
&lt;a class="anchor" href="#582-%da%a9%d9%84%d8%a7%db%8c%d9%86%d8%aa">#&lt;/a>
&lt;/h2>
&lt;p>کلاینت های در پروتوکول http برای صدا کردن (call) و ارسال درخواست به سرور ها طراحی و ساخته میشوند.
در ادامه یک کلاینت مقدماتی و ساده را در زبان گولنگ ایجاد میکنیم.&lt;/p></description></item><item><author/><title>5.9 کتابخانه http سمت کلاینت پیشرفته</title><link>https://book.gofarsi.ir/chapter-5/go-http-client-advanced/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-5/go-http-client-advanced/</guid><description>&lt;p>در قسمت قبل به ایجاد یک کلاینت http ساده و ارسال یک درخواست با متد get پرداختیم.&lt;/p>
&lt;p>در این قسمت به موارد کامل تر و جزیی تر کلاینت http میپردازیم.&lt;/p>
&lt;p>برای انجام تمرین های این قسمت از یک api تستی که جهت یادگیری ساخته شده است استفاده میکنیم (شما میتوانید از هر api یا سروری استفاده کنید حتی سرور http که خودتان نوشته باشید.)&lt;/p>
&lt;p>در این آموزش ما از api زیر استفاده میکنیم:
&lt;a href="https://fakestoreapi.com/docs">api docs&lt;/a>&lt;/p></description></item><item><author/><title>5.10 پروتکل quic</title><link>https://book.gofarsi.ir/chapter-5/go-quic-prtoocol/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-5/go-quic-prtoocol/</guid><description>&lt;p>پروتکل quic یک پروتکل توسعه یافته توسط google است. این پروتکل برای امنیت و سرعت بیشتر توسعه داده شده است.&lt;/p>
&lt;p>پروتکل quic از UDP استفاده میکند و در لایه transport قرار میگیرد.&lt;/p>
&lt;p>این پروتکل اجازه ایجاد چند کانکشن بصورت همزمان را فراهم میکنید و همچنین http/3 بر اساس این پروتکل طراحی و ایجاد شده است.&lt;/p>
&lt;p>چند مورد از ویژگی های کلیدی quic :
۱. ایجاد کانکشن سریع تر به دلیل اسفاده از udp.
۲. نیازی به دست دادن سه مرحله مثل tcp ندارد.
۳. بصورت پیش فرص از رمزنگاری استفاده میکند.&lt;/p></description></item><item><author/><title>4.26 ساختار پروژه</title><link>https://book.gofarsi.ir/chapter-4/go-project-layout/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/go-project-layout/</guid><description>&lt;h2 id="4261-نمای-کلی-project-layout">
4.26.1 نمای کلی project-layout
&lt;a class="anchor" href="#4261-%d9%86%d9%85%d8%a7%db%8c-%da%a9%d9%84%db%8c-project-layout">#&lt;/a>
&lt;/h2>
&lt;p>این متن یک طرح اساسی برای پروژه‌های برنامه‌نویسی به زبان Go است. توجه داشته باشید که این طرح از نظر محتوا ساده است، زیرا فقط روی layout کلی تمرکز دارد و نه آنچه در داخل آن قرار دارد. همچنین ساده است هر چند که از نظر محتوی پیشرفته است ولی به جزئیات زیادی در مورد نحوه ساختاردهی بیشتر پروژه شما نمی‌پردازد. برای مثال، سعی نمی‌کند ساختار پروژه‌ای را با چیزی مانند Clean Architecture پوشش دهد.
برای بررسی نمونه کدهای مشابه و مرجع این متن به این &lt;a href="https://github.com/golang-standards/project-layout/tree/master">لینک&lt;/a> مراجعه کنید.
این یک &lt;code>استاندارد رسمی تعریف شده توسط تیم توسعه اصلی Go نیست&lt;/code>. این مجموعه‌ای از الگوهای layout پروژه‌های رایج با سابقه و نوظهور در اکوسیستم Go است. برخی از این الگوها از بقیه محبوب‌تر هستند. همچنین دارای تعدادی بهبود کوچک همراه با چندین دایرکتوری پشتیبانی مشترک در هر برنامه واقعی به اندازه کافی بزرگ است. توجه داشته باشید که تیم اصلی Go مجموعه خوبی از دستورالعمل‌های عمومی در مورد ساختاردهی پروژه‌های Go و معنای آن برای پروژه شما هنگام وارد شدن و نصب آن ارائه می‌دهد. برای اطلاعات بیشتر، به صفحه &lt;a href="https://go.dev/doc/modules/layout">&lt;code>Organizing a Go module&lt;/code>&lt;/a> در اسناد رسمی Go مراجعه کنید. این صفحه شامل الگوهای دایرکتوری داخلی و cmd (که در زیر توضیح داده شده است) و سایر اطلاعات مفید است.
اگر در حال یادگیری Go هستید یا یک PoC یا یک پروژه ساده برای خودتان می‌سازید، این طرح پروژه بیش از حد پیچیده است. در عوض، با چیزی بسیار ساده شروع کنید (یک فایل main.go و go.mod بیش از اندازه کافی است). با پیشرفت پروژه، به خاطر داشته باشید که ساختاردهی مناسب کد شما بسیار مهم خواهد بود، در غیر این صورت در نهایت با یک کد نامرتب با وابستگی‌های پنهان (hidden dependencies) و global state زیادی مواجه خواهید شد. وقتی افراد بیشتری روی پروژه کار می‌کنند، به ساختار بیشتری نیاز خواهید داشت. در این زمان است که معرفی یک روش مشترک برای مدیریت بسته‌ها/کتابخانه‌ها اهمیت دارد. وقتی یک پروژه متن‌باز دارید یا می‌دانید که پروژه‌های دیگر کد را از مخزن پروژه شما وارد می‌کنند، آن زمان است که داشتن بسته‌ها و کدهای خصوصی (معادل internal) اهمیت دارد. repository را کپی کنید، آنچه را که نیاز دارید نگه دارید و بقیه را حذف کنید! فقط به این دلیل که وجود دارد، به این معنی نیست که باید از همه آن استفاده کنید. هیچ یک از این الگوها در هر پروژه‌ای استفاده نمی‌شوند. حتی الگوی &lt;code>vendor&lt;/code> نیز universal نیست.
با آمدن Go 1.14 در نهایت &lt;a href="https://go.dev/wiki/Modules">&lt;code>Go Modules&lt;/code>&lt;/a> برای production آماده شدند. از &lt;a href="https://blog.golang.org/using-go-modules">&lt;code>Go Modules&lt;/code>&lt;/a> استفاده کنید، مگر اینکه دلیل خاصی برای استفاده نکردن از آن‌ها داشته باشید و اگر اینطور است، نیازی به نگرانی در مورد $GOPATH و جایی که پروژه خود را قرار می‌دهید ندارید. فایل &lt;code>go.mod&lt;/code> پایه در مخزن فرض می‌کند که پروژه شما در GitHub میزبانی می‌شود، اما این یک الزام نیست. module path می‌تواند هر چیزی باشد، اگرچه اولین جزء module path باید یک نقطه در نام خود داشته باشد (نسخه فعلی Go دیگر آن را اجباری نمی‌کند، اما اگر از نسخه‌های کمی قدیمی‌تر استفاده می‌کنید، تعجب نکنید اگر ساخت‌های شما بدون آن شکست بخورد). اگر می‌خواهید درباره آن بیشتر بدانید، به Issues &lt;a href="https://github.com/golang/go/issues/37554">&lt;code>37554&lt;/code>&lt;/a> و &lt;a href="https://github.com/golang/go/issues/32819">&lt;code>32819&lt;/code>&lt;/a>مراجعه کنید.
این طرح پروژه عمداً عمومی است و سعی نمی‌کند یک ساختار پکیج Go خاص را تحمیل کند.
این یک تلاش مشترک است. اگر الگوی جدیدی مشاهده کردید یا فکر می‌کنید یکی از الگوهای موجود نیاز به به‌روزرسانی دارد، یک issue را باز کنید.
اگر به کمک در مورد نام‌گذاری، قالب‌بندی و style نیاز دارید، ابتدا &lt;a href="https://golang.org/cmd/gofmt/">&lt;code>gofmt&lt;/code>&lt;/a> و &lt;a href="https://github.com/dominikh/go-tools/tree/master/cmd/staticcheck">&lt;code>staticcheck&lt;/code>&lt;/a> را اجرا کنید. linter استاندارد قبلی، golint، اکنون منسوخ شده است و نگهداری نمی‌شود؛ استفاده از یک linter در حال توسعه و نگهداری شده مانند staticcheck توصیه می‌شود. همچنین مطمئن شوید که این دستورالعمل‌ها و توصیه‌های Go code style را بخوانید:&lt;/p></description></item><item><author/><title>4.27 آموزش کار با پکیج io</title><link>https://book.gofarsi.ir/chapter-4/go-io-package/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-4/go-io-package/</guid><description>&lt;p align="center">
&lt;img src="../../assets/img/content/chapter4/io/go-io.png" alt="io">
&lt;/p>
&lt;p>پکیج &lt;code>io&lt;/code> در زبان Go یکی از ابزارهای پایه و همه‌فن‌حریف برای کار با عملیات &lt;span class="tooltip" data-tooltip="ورودی/خروجی" ontouchend="toggleTooltip(this)">Input/Output&lt;/span>
است. فلسفه‌اش اینه که ما بدون وابستگی به نوع خاص داده (مثل فایل، شبکه یا حافظه) بتونیم از یک &lt;span class="tooltip" data-tooltip="رابط" ontouchend="toggleTooltip(this)">Interface&lt;/span>
ساده استفاده کنیم. این یعنی اگر یک شیء فقط متد مورد نیاز رو پیاده‌سازی کنه، می‌تونه در تمام جاهایی که اون رابط انتظار میره استفاده بشه. مثلا &lt;code>io.Reader&lt;/code> فقط یک متد &lt;code>Read&lt;/code> داره و &lt;code>io.Writer&lt;/code> یک متد &lt;code>Write&lt;/code>، ولی همین دو قرارداد ساده پایه تمام سیستم &lt;span class="tooltip" data-tooltip="انتزاع ورودی/خروجی" ontouchend="toggleTooltip(this)">I/O Abstraction&lt;/span>
در Go رو تشکیل میدن.&lt;/p></description></item><item><author/><title>6.1 مقدمه و اهمیت ژنریک‌ها</title><link>https://book.gofarsi.ir/chapter-6/go-generics-basic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-6/go-generics-basic/</guid><description>&lt;p>ایده ژنریک (Generics) به مفهوم &lt;strong>برنامه‌نویسی پارامتری (Parametric Polymorphism)&lt;/strong> برمی‌گردد؛ یعنی نوشتن توابع، کلاس‌ها یا انواعی که با انواع مختلف داده کار کنند بدون اینکه برای هر نوع داده، پیاده‌سازی مجزایی لازم باشد. این مفهوم در علوم کامپیوتر از دهه ۱۹۷۰ مطرح بود و به تدریج به زبان‌های اصلی برنامه‌نویسی راه یافت.&lt;/p>
&lt;h4 id="نقش-کلیدی-david-r-musser-و-alexander-a-stepanov">
نقش کلیدی &lt;strong>David R. Musser&lt;/strong> و &lt;strong>Alexander A. Stepanov&lt;/strong>
&lt;a class="anchor" href="#%d9%86%d9%82%d8%b4-%da%a9%d9%84%db%8c%d8%af%db%8c-david-r-musser-%d9%88-alexander-a-stepanov">#&lt;/a>
&lt;/h4>
&lt;p>دو نفر از پیشگامان و پژوهشگران مهم این حوزه، &lt;strong>David R. Musser&lt;/strong> و &lt;strong>Alexander A. Stepanov&lt;/strong> هستند. آن‌ها در دهه ۸۰ و ۹۰ میلادی پژوهش‌هایی درباره طراحی و پیاده‌سازی الگوریتم‌های ژنریک انجام دادند.&lt;br>
یکی از مهم‌ترین مقالات آن‌ها:&lt;/p></description></item><item><author/><title>6.2 مبانی ژنریک‌ها در Go</title><link>https://book.gofarsi.ir/chapter-6/go-generics-fundamentals/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-6/go-generics-fundamentals/</guid><description>&lt;h3 id="۶۲۱-تعریف-ژنریک-generic-چیست">
۶.۲.۱ تعریف ژنریک (Generic) چیست؟
&lt;a class="anchor" href="#%db%b6%db%b2%db%b1-%d8%aa%d8%b9%d8%b1%db%8c%d9%81-%da%98%d9%86%d8%b1%db%8c%da%a9-generic-%da%86%db%8c%d8%b3%d8%aa">#&lt;/a>
&lt;/h3>
&lt;p>&lt;strong>ژنریک (Generic)&lt;/strong> به معنی &amp;ldquo;کلی&amp;rdquo;، &amp;ldquo;عام&amp;rdquo; یا &amp;ldquo;نوع‌پذیر&amp;rdquo; است؛ مفهومی که به شما امکان می‌دهد یک تابع، نوع داده یا ساختار را به گونه‌ای بنویسید که با انواع مختلف داده‌ها کار کند، بدون اینکه برای هر نوع، پیاده‌سازی جداگانه لازم باشد.&lt;br>
به بیان دیگر، ژنریک‌ها قابلیتی برای &lt;strong>بازاستفاده امن و بهینه از کد&lt;/strong> در سطح زبان برنامه‌نویسی هستند.&lt;/p>
&lt;blockquote class="book-hint info">
&lt;p>&lt;strong>یه جمله ای از Ian lancer tailor هست:&lt;/strong>&lt;/p></description></item><item><author/><title>6.3 سینتکس و ساختار ژنریک‌ها در Go</title><link>https://book.gofarsi.ir/chapter-6/go-generics-syntax-and-structure/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-6/go-generics-syntax-and-structure/</guid><description>&lt;h2 id="۶۳۱-تعریف-تابع-ژنریک-generic-functions">
۶.۳.۱ تعریف تابع ژنریک (Generic Functions)
&lt;a class="anchor" href="#%db%b6%db%b3%db%b1-%d8%aa%d8%b9%d8%b1%db%8c%d9%81-%d8%aa%d8%a7%d8%a8%d8%b9-%da%98%d9%86%d8%b1%db%8c%da%a9-generic-functions">#&lt;/a>
&lt;/h2>
&lt;p>در Go از نسخه ۱.۱۸، می‌توانید توابعی بنویسید که به‌جای نوع خاص، با نوع پارامتری کار می‌کنند. پارامترهای نوعی (type parameters) در کروشه &lt;code>[]&lt;/code> بعد از نام تابع قرار می‌گیرند.&lt;/p>
&lt;h4 id="نمونه-سینتکس">
&lt;strong>نمونه سینتکس:&lt;/strong>
&lt;a class="anchor" href="#%d9%86%d9%85%d9%88%d9%86%d9%87-%d8%b3%db%8c%d9%86%d8%aa%da%a9%d8%b3">#&lt;/a>
&lt;/h4>
&lt;pre>&lt;code class="language-go">func Swap[T any](a, b T) (T, T) {
return b, a
}
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>T&lt;/strong> پارامتر نوعی است که می‌تواند هر نوعی را بپذیرد (در اینجا با constraint &lt;code>any&lt;/code>).&lt;/p></description></item><item><author/><title>6.4 Constraints و Type Sets</title><link>https://book.gofarsi.ir/chapter-6/go-generics-type-sets-and-constraints/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-6/go-generics-type-sets-and-constraints/</guid><description>&lt;h2 id="۶۴۱-مفهوم-constraint-و-نقش-آن-در-ژنریکها">
۶.۴.۱ مفهوم constraint و نقش آن در ژنریک‌ها
&lt;a class="anchor" href="#%db%b6%db%b4%db%b1-%d9%85%d9%81%d9%87%d9%88%d9%85-constraint-%d9%88-%d9%86%d9%82%d8%b4-%d8%a2%d9%86-%d8%af%d8%b1-%da%98%d9%86%d8%b1%db%8c%da%a9%d9%87%d8%a7">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>Constraint&lt;/strong> (قید یا محدودیت) در ژنریک‌های Go ابزاری است برای کنترل اینکه یک پارامتر نوعی (type parameter) باید چه ویژگی‌هایی داشته باشد.&lt;br>
بدون constraint، هر نوعی می‌تواند جایگزین شود، اما با تعریف constraint، دایره‌ی مجاز را محدود می‌کنیم تا هم ایمنی نوعی بالا رود و هم امکانات بیشتری برای پیاده‌سازی داشته باشیم.&lt;/p>
&lt;h4 id="نقش-constraint">
&lt;strong>نقش constraint:&lt;/strong>
&lt;a class="anchor" href="#%d9%86%d9%82%d8%b4-constraint">#&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>جلوگیری از استفاده نادرست از ژنریک‌ها (مثلاً استفاده از عملیات غیرمجاز روی نوع پارامتری)&lt;/li>
&lt;li>افزایش قابلیت تشخیص خطا در زمان کامپایل&lt;/li>
&lt;li>امکان تعریف abstractionهای قوی‌تر&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>مثال ساده:&lt;/strong>&lt;/p></description></item><item><author/><title>6.5 مثال‌ها و کاربردهای عملی ژنریک‌ها</title><link>https://book.gofarsi.ir/chapter-6/go-generics-examples-and-practical/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-6/go-generics-examples-and-practical/</guid><description>&lt;h2 id="۶۵۱-توابع-ژنریک-متداول-مانند-min-max-map-filter">
۶.۵.۱ توابع ژنریک متداول (مانند Min, Max, Map, Filter)
&lt;a class="anchor" href="#%db%b6%db%b5%db%b1-%d8%aa%d9%88%d8%a7%d8%a8%d8%b9-%da%98%d9%86%d8%b1%db%8c%da%a9-%d9%85%d8%aa%d8%af%d8%a7%d9%88%d9%84-%d9%85%d8%a7%d9%86%d9%86%d8%af-min-max-map-filter">#&lt;/a>
&lt;/h2>
&lt;h4 id="تابع-min-و-max">
تابع Min و Max
&lt;a class="anchor" href="#%d8%aa%d8%a7%d8%a8%d8%b9-min-%d9%88-max">#&lt;/a>
&lt;/h4>
&lt;pre>&lt;code class="language-go">import &amp;quot;cmp&amp;quot; // از Go 1.21+
func Min[T cmp.Ordered](a, b T) T {
if a &amp;lt; b {
return a
}
return b
}
func Max[T cmp.Ordered](a, b T) T {
if a &amp;gt; b {
return a
}
return b
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>توضیح:&lt;/strong>&lt;br>
این دو تابع ژنریک به شما اجازه می‌دهند با هر نوع داده‌ای که قابل مقایسه با عملگرهای بزرگ‌تر/کوچک‌تر باشد (مثل int، float64، string و&amp;hellip;) بیشینه یا کمینه دو مقدار را به دست آورید. پارامتر نوعی &lt;code>T&lt;/code> باید قید &lt;code>cmp.Ordered&lt;/code> را داشته باشد تا عملیات مقایسه مجاز باشد. این ساختار به جای نوشتن نسخه‌های تکراری برای هر نوع داده، یک تابع عمومی و امن ایجاد می‌کند.&lt;/p></description></item><item><author/><title>6.6 مقایسه ژنریک‌ها با راهکارهای قبل از Go 1.18</title><link>https://book.gofarsi.ir/chapter-6/comparing-generics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-6/comparing-generics/</guid><description>&lt;h2 id="۶۶۱-استفاده-از-interface-و-reflect-قبل-از-ژنریکها">
۶.۶.۱ استفاده از interface{} و reflect قبل از ژنریک‌ها
&lt;a class="anchor" href="#%db%b6%db%b6%db%b1-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-interface-%d9%88-reflect-%d9%82%d8%a8%d9%84-%d8%a7%d8%b2-%da%98%d9%86%d8%b1%db%8c%da%a9%d9%87%d8%a7">#&lt;/a>
&lt;/h2>
&lt;p>پیش از Go 1.18، برای پیاده‌سازی توابع یا ساختارهای داده عمومی، معمولاً از نوع &lt;strong>interface{}&lt;/strong> (نوع همه‌کاره) استفاده می‌شد.
در موارد نیاز به عملیات خاص یا تبدیل نوع، ناچار به استفاده از &lt;strong>reflect&lt;/strong> یا type assertion بودیم. این روش‌ها معایب و ریسک‌های خاص خود را داشتند.&lt;/p>
&lt;h4 id="مثال-تابع-max-با-interface-و-reflect">
&lt;strong>مثال: تابع Max با interface{} و reflect&lt;/strong>
&lt;a class="anchor" href="#%d9%85%d8%ab%d8%a7%d9%84-%d8%aa%d8%a7%d8%a8%d8%b9-max-%d8%a8%d8%a7-interface-%d9%88-reflect">#&lt;/a>
&lt;/h4>
&lt;p>`&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">import (
"fmt"
"reflect"
)
func Max(a, b interface{}) interface{} {
av := reflect.ValueOf(a)
bv := reflect.ValueOf(b)
if av.Kind() == reflect.Int &amp;&amp; bv.Kind() == reflect.Int {
if av.Int() > bv.Int() {
return a
}
return b
}
// می‌توانید برای انواع دیگر هم کد بنویسید
return nil
}
func main() {
fmt.Println(Max(3, 7)) // خروجی: 7
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;/p></description></item><item><author/><title>6.7 محدودیت‌ها، خطاها و ضدالگوها در ژنریک‌ها</title><link>https://book.gofarsi.ir/chapter-6/limitations-errors-and-anti-patterns-in-generics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-6/limitations-errors-and-anti-patterns-in-generics/</guid><description>&lt;h2 id="۶۷۱-محدودیتهای-فعلی-ژنریکها-در-go-compile-time--runtime">
۶.۷.۱ محدودیت‌های فعلی ژنریک‌ها در Go (Compile-time &amp;amp; Runtime)
&lt;a class="anchor" href="#%db%b6%db%b7%db%b1-%d9%85%d8%ad%d8%af%d9%88%d8%af%db%8c%d8%aa%d9%87%d8%a7%db%8c-%d9%81%d8%b9%d9%84%db%8c-%da%98%d9%86%d8%b1%db%8c%da%a9%d9%87%d8%a7-%d8%af%d8%b1-go-compile-time--runtime">#&lt;/a>
&lt;/h2>
&lt;p>اگرچه ژنریک‌ها قابلیت فوق‌العاده‌ای به Go افزوده‌اند، اما هنوز با برخی محدودیت‌های فنی و زبانی روبه‌رو هستند که باید حتماً در پروژه‌های جدی مدنظر قرار گیرد:&lt;/p>
&lt;h4 id="محدودیتهای-زمان-کامپایل-compile-time">
محدودیت‌های زمان کامپایل (Compile-time)
&lt;a class="anchor" href="#%d9%85%d8%ad%d8%af%d9%88%d8%af%db%8c%d8%aa%d9%87%d8%a7%db%8c-%d8%b2%d9%85%d8%a7%d9%86-%da%a9%d8%a7%d9%85%d9%be%d8%a7%db%8c%d9%84-compile-time">#&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>عدم پشتیبانی از عملیات ریاضی یا منطقی روی هر نوع دلخواه:&lt;/strong>&lt;br>
فقط انواعی که قید مناسب (مانند &lt;code>cmp.Ordered&lt;/code> یا union خاص) دارند می‌توانند با عملگرهای مقایسه یا ریاضی استفاده شوند.&lt;/p></description></item><item><author/><title>6.8 بهترین شیوه‌های استفاده از ژنریک‌ها (Best Practices)</title><link>https://book.gofarsi.ir/chapter-6/generics-best-practice/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-6/generics-best-practice/</guid><description>&lt;p>در این بخش، به‌صورت حرفه‌ای، کاربردی و تجربی، &lt;strong>بهترین شیوه‌های استفاده از ژنریک‌ها&lt;/strong> در پروژه‌های Go را همراه با نکات تولیدی و فنی ارائه می‌دهم.&lt;/p>
&lt;h3 id="۶۸۱-راهنمای-تصمیمگیری-چه-زمانی-ژنریک-چه-زمانی-نه">
۶.۸.۱ راهنمای تصمیم‌گیری: چه زمانی ژنریک؟ چه زمانی نه؟
&lt;a class="anchor" href="#%db%b6%db%b8%db%b1-%d8%b1%d8%a7%d9%87%d9%86%d9%85%d8%a7%db%8c-%d8%aa%d8%b5%d9%85%db%8c%d9%85%da%af%db%8c%d8%b1%db%8c-%da%86%d9%87-%d8%b2%d9%85%d8%a7%d9%86%db%8c-%da%98%d9%86%d8%b1%db%8c%da%a9-%da%86%d9%87-%d8%b2%d9%85%d8%a7%d9%86%db%8c-%d9%86%d9%87">#&lt;/a>
&lt;/h3>
&lt;p>&lt;strong>ژنریک‌ها ابزار قدرتمندی هستند، اما استفاده درست و هوشمندانه از آن‌ها حیاتی است.&lt;/strong>&lt;br>
بهتر است ژنریک را فقط زمانی به کار ببرید که:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>یک منطق تکراری برای چندین نوع مختلف وجود دارد&lt;/strong> و پیاده‌سازی جداگانه برای هر نوع باعث تکرار و دشواری نگهداری می‌شود.&lt;/li>
&lt;li>&lt;strong>نیاز به abstraction و توسعه‌پذیری کد&lt;/strong> برای آینده وجود دارد، مانند ساختار داده‌ها (Stack, Queue, Map)، یا توابع عمومی (Map, Filter, Reduce).&lt;/li>
&lt;li>&lt;strong>ایمنی نوعی (Type Safety)&lt;/strong> برایتان مهم است و می‌خواهید خطاها را در زمان کامپایل متوجه شوید.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>چه زمانی ژنریک استفاده نکنیم؟&lt;/strong>&lt;/p></description></item><item><author/><title>6.9 مثال‌های پیشرفته و نکات ویژه</title><link>https://book.gofarsi.ir/chapter-6/generics-advanced-examples-and-tips/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-6/generics-advanced-examples-and-tips/</guid><description>&lt;h2 id="۶۹۱-ساخت-کتابخانههای-عمومی-و-abstractionهای-حرفهای-با-ژنریکها">
۶.۹.۱ ساخت کتابخانه‌های عمومی و abstractionهای حرفه‌ای با ژنریک‌ها
&lt;a class="anchor" href="#%db%b6%db%b9%db%b1-%d8%b3%d8%a7%d8%ae%d8%aa-%da%a9%d8%aa%d8%a7%d8%a8%d8%ae%d8%a7%d9%86%d9%87%d9%87%d8%a7%db%8c-%d8%b9%d9%85%d9%88%d9%85%db%8c-%d9%88-abstraction%d9%87%d8%a7%db%8c-%d8%ad%d8%b1%d9%81%d9%87%d8%a7%db%8c-%d8%a8%d8%a7-%da%98%d9%86%d8%b1%db%8c%da%a9%d9%87%d8%a7">#&lt;/a>
&lt;/h2>
&lt;p>در پروژه‌های مدرن، معمولاً نیاز به abstraction و لایه‌بندی وجود دارد تا بتوانید کدهای reusable و توسعه‌پذیر بسازید. ژنریک‌ها در Go این کار را بسیار ساده و حرفه‌ای می‌کنند.&lt;/p>
&lt;h4 id="مثال-کتابخانه-datastore-ژنریک">
&lt;strong>مثال: کتابخانه DataStore ژنریک&lt;/strong>
&lt;a class="anchor" href="#%d9%85%d8%ab%d8%a7%d9%84-%da%a9%d8%aa%d8%a7%d8%a8%d8%ae%d8%a7%d9%86%d9%87-datastore-%da%98%d9%86%d8%b1%db%8c%da%a9">#&lt;/a>
&lt;/h4>
&lt;pre>&lt;code class="language-go">type DataStore[T any] interface {
Get(id string) (T, error)
Save(id string, data T) error
}
type MemoryStore[T any] struct {
data map[string]T
}
func NewMemoryStore[T any]() *MemoryStore[T] {
return &amp;amp;MemoryStore[T]{data: make(map[string]T)}
}
func (m *MemoryStore[T]) Get(id string) (T, error) {
v, ok := m.data[id]
if !ok {
var zero T
return zero, fmt.Errorf(&amp;quot;not found&amp;quot;)
}
return v, nil
}
func (m *MemoryStore[T]) Save(id string, data T) error {
m.data[id] = data
return nil
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>توضیح:&lt;/strong>&lt;br>
در این مثال یک abstraction برای ذخیره‌سازی داده‌ها پیاده‌سازی شده که می‌تواند برای هر نوع داده‌ای مورد استفاده قرار گیرد (مثلاً User, Order, Product و &amp;hellip;). این ساختار با پیاده‌سازی interface ژنریک، قابلیت توسعه و تست بسیار بالایی دارد و به راحتی می‌توانید MemoryStore را با نسخه DatabaseStore یا CacheStore جایگزین کنید.&lt;/p></description></item><item><author/><title>7.1 مقدمه‌ای بر تست در Go</title><link>https://book.gofarsi.ir/chapter-7/go-introduction-testing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-7/go-introduction-testing/</guid><description>&lt;p>تست‌نویسی یکی از ارکان حیاتی توسعه نرم‌افزارهای قابل‌اعتماد و نگهدارپذیر است. در دنیای امروز که سرعت توسعه و تغییرات کد روزبه‌روز بیشتر می‌شود، وجود تست‌های دقیق و ساختاریافته تضمین می‌کند که عملکرد نرم‌افزار با تغییرات جدید دچار اختلال نشود. از کشف باگ‌ها گرفته تا مستندسازی رفتار مورد انتظار ماژول‌ها، تست‌ها نقشی فراتر از صرفاً اطمینان‌بخشی دارند. آن‌ها به تیم توسعه جرئت ریفکتور می‌دهند و مرزهای طراحی سیستم را شفاف می‌کنند.&lt;/p></description></item><item><author/><title>7.2 تست واحد (Unit Test)</title><link>https://book.gofarsi.ir/chapter-7/go-unit-testing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-7/go-unit-testing/</guid><description>&lt;p>تست واحد یکی از مهم‌ترین و بنیادی‌ترین ابزارهایی‌ست که یک توسعه‌دهنده حرفه‌ای در اختیار دارد. این نوع تست، تنها بر یک «واحد» مستقل از منطق برنامه تمرکز می‌کند—معمولاً یک تابع، یک متد، یا یک ساختار کوچک از کد که بدون وابستگی به منابع خارجی قابل بررسی است. هدف اصلی از نوشتن تست واحد، اطمینان از صحت رفتار دقیق و قابل پیش‌بینی کد در مواجهه با ورودی‌های مشخص و شرایط کنترل‌شده است.&lt;/p></description></item><item><author/><title>7.3 تست جدول‌محور (Table-Driven Test)</title><link>https://book.gofarsi.ir/chapter-7/go-table-driven-tests/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-7/go-table-driven-tests/</guid><description>&lt;p>در زبان Go، یکی از الگوهای محبوب و بسیار قدرتمند برای نوشتن تست‌های واحد و رفتاری، الگوی «تست جدول‌محور» است. این سبک از تست‌نویسی نه‌تنها منجر به حذف تکرارهای زائد در کد تست می‌شود، بلکه ساختاری منسجم برای تعریف سناریوهای مختلف تست، به همراه ورودی و خروجی‌های مورد انتظار، فراهم می‌سازد.&lt;/p>
&lt;p>در این الگو، مجموعه‌ای از تست‌ها به‌صورت یک جدول از structها تعریف می‌شود که شامل نام تست، ورودی‌ها، خروجی مورد انتظار، و گاهی انتظار وقوع خطا است. سپس با استفاده از یک حلقه و تابع &lt;code>t.Run&lt;/code>، هر ردیف از جدول به‌صورت یک تست مستقل (subtest) اجرا می‌شود. این طراحی باعث می‌شود اضافه‌کردن یک تست جدید، تنها با افزودن یک struct به جدول امکان‌پذیر باشد—بدون نیاز به کپی‌کردن منطق کلی تست.&lt;/p></description></item><item><author/><title>7.4 تست یکپارچه (Integration Test)</title><link>https://book.gofarsi.ir/chapter-7/go-integration-testing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-7/go-integration-testing/</guid><description>&lt;p>تست‌های یکپارچه نوعی از تست نرم‌افزار هستند که به بررسی تعامل صحیح میان اجزای مختلف سیستم می‌پردازند. برخلاف &lt;span class="tooltip" data-tooltip="تست‌های واحد" ontouchend="toggleTooltip(this)">Unit Tests&lt;/span>
که یک بخش از کد را به‌صورت ایزوله بررسی می‌کنند، این تست‌ها بر اطمینان از عملکرد هماهنگ چند ماژول، لایه یا سرویس در کنار هم تمرکز دارند. هدف اصلی آن‌ها شبیه‌سازی سناریوهای نزدیک به شرایط واقعی و اطمینان از این است که بخش‌های سیستم در کنار یکدیگر همان‌طور که انتظار می‌رود کار می‌کنند.&lt;/p></description></item><item><author/><title>7.5 تست انتها به انتها (End-to-End Test - E2E)</title><link>https://book.gofarsi.ir/chapter-7/go-end-to-end-tests/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-7/go-end-to-end-tests/</guid><description/></item><item><author/><title>7.6 تست عملکرد (Benchmark)</title><link>https://book.gofarsi.ir/chapter-7/go-benchmarking/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-7/go-benchmarking/</guid><description/></item><item><author/><title>7.7 تست فازی (Fuzz Testing)</title><link>https://book.gofarsi.ir/chapter-7/go-fuzz-testing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-7/go-fuzz-testing/</guid><description/></item><item><author/><title>7.8 ماک و شبیه‌سازی وابستگی‌ها (Mock)</title><link>https://book.gofarsi.ir/chapter-7/go-mocking/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-7/go-mocking/</guid><description/></item><item><author/><title>7.9 استفاده از testify</title><link>https://book.gofarsi.ir/chapter-7/go-testify/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-7/go-testify/</guid><description/></item><item><author/><title>7.10 استفاده از ginkgo</title><link>https://book.gofarsi.ir/chapter-7/go-ginkgo-testing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-7/go-ginkgo-testing/</guid><description/></item><item><author/><title>7.11 تست‌های همزمانی (Concurrent Testing)</title><link>https://book.gofarsi.ir/chapter-7/go-concurrent-testing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-7/go-concurrent-testing/</guid><description/></item><item><author/><title>7.12 سنجش پوشش تست (Code Coverage)</title><link>https://book.gofarsi.ir/chapter-7/go-code-coverage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-7/go-code-coverage/</guid><description/></item><item><author/><title>7.13 تست Suite و ساختاردهی تست‌ها</title><link>https://book.gofarsi.ir/chapter-7/go-test-suites/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-7/go-test-suites/</guid><description/></item><item><author/><title>7.14 تست‌نویسی حرفه‌ای در پروژه</title><link>https://book.gofarsi.ir/chapter-7/go-production-testing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-7/go-production-testing/</guid><description/></item><item><author/><title>12.1.1 بلاکچین چیست</title><link>https://book.gofarsi.ir/chapter-12/blockchain/blockchain/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/blockchain/blockchain/</guid><description>&lt;center>&lt;a href="#">
&lt;img src="../../../assets/img/content/chapter12/blockchain/12.1-0.jpg" alt="Blockchain">
&lt;/a>&lt;/center>
&lt;p>بلاکچین (زنجیره بلوک) در واقع یک سیستم توزیع شده &lt;span class="tooltip" data-tooltip="P2P" ontouchend="toggleTooltip(this)">همتا به همتا&lt;/span>
(Peer to Peer) &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup> می باشد که هیچ سرور مرکزی وجود ندارد و این شبکه با افزایش تعداد بلوک ها, تراکنش ها و کلاینت ها رشد می کند و در این شبکه تمامی اطلاعات بصورت رمزنگاری شده رد و بدل می شود و از انواع رمزنگاری متقارن و نامتقارن برای افزایش امنیت شبکه استفاده می شود.&lt;/p>
&lt;p>هدف اصلی بلاکچین بوجود آمدن یک سیستم شفاف و غیرمرکزی هست که دولت ها یا شرکت ها هیچ دسترسی مستقیمی برروی اطلاعات موجود در شبکه نداشته باشند و تمامی اطلاعات بصورت رمزنگاری شده داخل شبکه رد و بدل شود, منظور از سیستم غیرمرکزی یعنی کلاینت هایی که به شبکه متصل می شوند یکدیگر را به هیچ عنوان نمی شناسند و ممکن است یکی از کلاینت ها سیستم شخصی شما باشد یا اینکه یک سرور مجازی و&amp;hellip; باشد و این کلاینت ها با متصل شدن به یکدیگر و انتشار اطلاعات برای سایر اعضای مجموعه خود باعث بروز شدن اطلاعات شبکه می باشد.&lt;/p></description></item><item><author/><title>12.1.2 تاریخچه بلاکچین</title><link>https://book.gofarsi.ir/chapter-12/blockchain/blockchain-history/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/blockchain/blockchain-history/</guid><description>&lt;p>تاریخچه بلاکچین&lt;/p></description></item><item><author/><title>12.1.3 معماری بلاکچین</title><link>https://book.gofarsi.ir/chapter-12/blockchain/blockchain-architecture/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/blockchain/blockchain-architecture/</guid><description>&lt;p>معماری بلاکچین&lt;/p></description></item><item><author/><title>12.1.4 انواع بلاکچین</title><link>https://book.gofarsi.ir/chapter-12/blockchain/blockchain-type/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/blockchain/blockchain-type/</guid><description>&lt;p>انواع بلاکچین&lt;/p></description></item><item><author/><title>12.1.5 تفاوت سیستم متمرکز با غیرمتمرکز</title><link>https://book.gofarsi.ir/chapter-12/blockchain/blockchain-different-with-centerlized/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/blockchain/blockchain-different-with-centerlized/</guid><description>&lt;p>تفاوت سیستم متمرکز با غیرمتمرکز&lt;/p></description></item><item><author/><title>12.1.6 مقیاس پذیری در بلاکچین</title><link>https://book.gofarsi.ir/chapter-12/blockchain/blockchain-scale/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/blockchain/blockchain-scale/</guid><description>&lt;p>مقیاس پذیری در بلاکچین&lt;/p></description></item><item><author/><title>12.1.7 امنیت در بلاکچین</title><link>https://book.gofarsi.ir/chapter-12/blockchain/blockchain-security/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/blockchain/blockchain-security/</guid><description>&lt;p>امنیت در بلاکچین&lt;/p></description></item><item><author/><title>12.1.8 مفاهیم رمزنگاری</title><link>https://book.gofarsi.ir/chapter-12/blockchain/blockchain-cryptography/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/blockchain/blockchain-cryptography/</guid><description>&lt;p>مفاهیم رمزنگاری&lt;/p></description></item><item><author/><title>12.1.10 الگوریتم اجماع (Consensus)</title><link>https://book.gofarsi.ir/chapter-12/blockchain/blockchain-consensus-algorithm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/blockchain/blockchain-consensus-algorithm/</guid><description>&lt;p>الگوریتم اجماع (Consensus)&lt;/p></description></item><item><author/><title>12.1.11 ساختار و کاربرد شبکه P2P</title><link>https://book.gofarsi.ir/chapter-12/blockchain/blockchain-p2p-network/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/blockchain/blockchain-p2p-network/</guid><description>&lt;h2 id="2111-معماری-p2p-چیست">
2.11.1 معماری P2P چیست؟
&lt;a class="anchor" href="#2111-%d9%85%d8%b9%d9%85%d8%a7%d8%b1%db%8c-p2p-%da%86%db%8c%d8%b3%d8%aa">#&lt;/a>
&lt;/h2>
&lt;p>معماری P2P یا همتا به همتا، نوعی ساختار شبکه است که در آن دستگاه ها به طور مثال کامپیوتر ها به طور مستقیم و بدون نیاز به سرور مرکزی به یکدیگر متصل می‌شوند. در این نوع شبکه، هر دستگاهی (که به آن گره یا نود هم می‌گویند) می‌تواند هم به عنوان فرستنده و هم به عنوان گیرنده اطلاعات عمل کند.&lt;/p>
&lt;center>&lt;a href="#">
&lt;img src="../../assets/img/content/chapter12/blockchain/12.1-11.jpg" alt="P2PvsCS">
&lt;/a>&lt;/center>
&lt;h2 id="12112-انواع-شبکههای-p2p">
12.11.2 انواع شبکه‌های P2P
&lt;a class="anchor" href="#12112-%d8%a7%d9%86%d9%88%d8%a7%d8%b9-%d8%b4%d8%a8%da%a9%d9%87%d9%87%d8%a7%db%8c-p2p">#&lt;/a>
&lt;/h2>
&lt;ol>
&lt;li>شبکه‌های P2P بدون ساختار: در این نوع شبکه‌ها، هیچ نظم و ترتیبی در اتصال گره‌ها به یکدیگر وجود ندارد. گره‌ها به طور تصادفی به یکدیگر متصل می‌شوند و به اشتراک‌گذاری فایل‌ها به صورت تصادفی انجام می‌شود&lt;/li>
&lt;li>شبکه‌های P2P با ساختار: در این نوع شبکه‌ها، گره‌ها به طور منظم به یکدیگر متصل می‌شوند. به اشتراک‌گذاری فایل‌ها بر اساس قوانین و الگوریتم‌های خاصی انجام می‌شود.&lt;/li>
&lt;/ol>
&lt;h2 id="12113-کاربرد-های-معماری-p2p">
12.11.3 کاربرد های معماری P2P
&lt;a class="anchor" href="#12113-%da%a9%d8%a7%d8%b1%d8%a8%d8%b1%d8%af-%d9%87%d8%a7%db%8c-%d9%85%d8%b9%d9%85%d8%a7%d8%b1%db%8c-p2p">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>اشتراک‌گذاری فایل: شبکه‌های P2P برای اشتراک‌گذاری فایل‌ها، مانند موسیقی، فیلم و نرم‌افزار، بسیار محبوب هستند.&lt;/p></description></item><item><author/><title>12.1.12 مدیریت داده در بلاکچین</title><link>https://book.gofarsi.ir/chapter-12/blockchain/blockchain-data-management/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/blockchain/blockchain-data-management/</guid><description>&lt;p>مدیریت داده در بلاکچین&lt;/p></description></item><item><author/><title>12.1.13 تست پذیری شبکه</title><link>https://book.gofarsi.ir/chapter-12/blockchain/blockchain-network-testing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/blockchain/blockchain-network-testing/</guid><description>&lt;p>تست پذیری شبکه&lt;/p></description></item><item><author/><title>12.1.14 ارزیابی و بهینه سازی شبکه</title><link>https://book.gofarsi.ir/chapter-12/blockchain/blockchain-analyze-and-optimization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/blockchain/blockchain-analyze-and-optimization/</guid><description>&lt;p>ارزیابی و بهینه سازی شبکه&lt;/p></description></item><item><author/><title>12.1.15 مانیتورینگ شبکه</title><link>https://book.gofarsi.ir/chapter-12/blockchain/blockchain-monitoring/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/blockchain/blockchain-monitoring/</guid><description>&lt;p>مانیتورینگ شبکه&lt;/p></description></item><item><author/><title>12.1.16 استراتژی فورک ها</title><link>https://book.gofarsi.ir/chapter-12/blockchain/blockchain-forking/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/blockchain/blockchain-forking/</guid><description>&lt;p>استراتژی فورک ها&lt;/p></description></item><item><author/><title>12.1.17 پیاده سازی انواع API ها و SDK ها</title><link>https://book.gofarsi.ir/chapter-12/blockchain/blockchain-api-and-sdk/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/blockchain/blockchain-api-and-sdk/</guid><description>&lt;p>پیاده سازی انواع API ها و SDK ها&lt;/p></description></item><item><author/><title>12.1.18 کلیدها و آدرس ها</title><link>https://book.gofarsi.ir/chapter-12/blockchain/blockchain-keys-and-addresses/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/blockchain/blockchain-keys-and-addresses/</guid><description>&lt;p>کلیدها و آدرس ها&lt;/p></description></item><item><author/><title>12.1.19 اکانت ها</title><link>https://book.gofarsi.ir/chapter-12/blockchain/blockchain-accounts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/blockchain/blockchain-accounts/</guid><description>&lt;p>اکانت ها&lt;/p></description></item><item><author/><title>12.1.20 تراکنش ها و پیام ها</title><link>https://book.gofarsi.ir/chapter-12/blockchain/blockchain-transactions-and-messages/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/blockchain/blockchain-transactions-and-messages/</guid><description>&lt;p>تراکنش ها و پیام ها&lt;/p></description></item><item><author/><title>12.1.21 بلوک ها (Blocks)</title><link>https://book.gofarsi.ir/chapter-12/blockchain/blockchain-blocks/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/blockchain/blockchain-blocks/</guid><description>&lt;p>بلوک ها&lt;/p></description></item><item><author/><title>12.1.22 جنسیس (Genesis)</title><link>https://book.gofarsi.ir/chapter-12/blockchain/blockchain-genesis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/blockchain/blockchain-genesis/</guid><description>&lt;p>جنسیس (Genesis)&lt;/p></description></item><item><author/><title>12.1.23 قراردادهای هوشمند</title><link>https://book.gofarsi.ir/chapter-12/blockchain/blockchain-smart-contracts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/blockchain/blockchain-smart-contracts/</guid><description>&lt;p>قراردادهای هوشمند&lt;/p></description></item><item><author/><title>12.1.24 حریم خصوصی شبکه</title><link>https://book.gofarsi.ir/chapter-12/blockchain/blockchain-privacy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/blockchain/blockchain-privacy/</guid><description>&lt;p>حریم خصوصی شبکه&lt;/p></description></item><item><author/><title>12.2.1 معرفی بیت کوین</title><link>https://book.gofarsi.ir/chapter-12/bitcoin/bitcoin/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/bitcoin/bitcoin/</guid><description>&lt;p>معرفی بیت کوین&lt;/p></description></item><item><author/><title>12.2.2 رمزنگاری در بیت کوین</title><link>https://book.gofarsi.ir/chapter-12/bitcoin/bitcoin-cryptography/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/bitcoin/bitcoin-cryptography/</guid><description>&lt;p>رمزنگاری در بیت کوین&lt;/p></description></item><item><author/><title>12.2.3 آدرس ها</title><link>https://book.gofarsi.ir/chapter-12/bitcoin/bitcoin-addresses/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/bitcoin/bitcoin-addresses/</guid><description>&lt;p>آدرس ها&lt;/p></description></item><item><author/><title>12.2.4 تراکنش ها</title><link>https://book.gofarsi.ir/chapter-12/bitcoin/bitcoin-transactions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/bitcoin/bitcoin-transactions/</guid><description>&lt;p>تراکنش ها&lt;/p></description></item><item><author/><title>12.2.5 ساختار بلاکچین بیت کوین</title><link>https://book.gofarsi.ir/chapter-12/bitcoin/bitcoin-structure/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/bitcoin/bitcoin-structure/</guid><description>&lt;p>ساختار بلاکچین بیت کوین&lt;/p></description></item><item><author/><title>12.2.6 الگوریتم اجماع</title><link>https://book.gofarsi.ir/chapter-12/bitcoin/bitcoin-consensus/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/bitcoin/bitcoin-consensus/</guid><description>&lt;p>الگوریتم اجماع&lt;/p></description></item><item><author/><title>12.2.7 ماینرها</title><link>https://book.gofarsi.ir/chapter-12/bitcoin/bitcoin-miners/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/bitcoin/bitcoin-miners/</guid><description>&lt;p>ماینرها&lt;/p></description></item><item><author/><title>12.2.8 شبکه</title><link>https://book.gofarsi.ir/chapter-12/bitcoin/bitcoin-network/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/bitcoin/bitcoin-network/</guid><description>&lt;p>شبکه&lt;/p></description></item><item><author/><title>12.2.9 والت ها</title><link>https://book.gofarsi.ir/chapter-12/bitcoin/bitcoin-wallets/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/bitcoin/bitcoin-wallets/</guid><description>&lt;p>والت ها&lt;/p></description></item><item><author/><title>12.2.10 بیت کوین در دنیای واقعی</title><link>https://book.gofarsi.ir/chapter-12/bitcoin/bitcoin-in-real-world/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/bitcoin/bitcoin-in-real-world/</guid><description>&lt;p>بیت کوین در دنیای واقعی&lt;/p></description></item><item><author/><title>12.2.11 نوآوری</title><link>https://book.gofarsi.ir/chapter-12/bitcoin/bitcoin-innovation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/bitcoin/bitcoin-innovation/</guid><description>&lt;p>نوآوری&lt;/p></description></item><item><author/><title>12.2.12 کلاینت ها</title><link>https://book.gofarsi.ir/chapter-12/bitcoin/bitcoin-clients/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/bitcoin/bitcoin-clients/</guid><description>&lt;p>کلاینت ها&lt;/p></description></item><item><author/><title>12.2.13 برنامه نویسی در بیت کوین</title><link>https://book.gofarsi.ir/chapter-12/bitcoin/bitcoin-programming/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/bitcoin/bitcoin-programming/</guid><description>&lt;p>برنامه نویسی در بیت کوین&lt;/p></description></item><item><author/><title>12.3.1 معرفی اتریوم</title><link>https://book.gofarsi.ir/chapter-12/ethereum/ethereum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/ethereum/ethereum/</guid><description>&lt;h1 id="12311-اتریوم">
12.3.1.1 اتریوم
&lt;a class="anchor" href="#12311-%d8%a7%d8%aa%d8%b1%db%8c%d9%88%d9%85">#&lt;/a>
&lt;/h1>
&lt;center>&lt;a href="#">
&lt;img src="../../../assets/img/content/chapter12/ethereum/ethereum-logo.png" alt="Ethereum logo">
&lt;/a>&lt;/center>
&lt;p>بعد از حل مشکلاتی که برای ایجاد یک ارز یا سکه دیجیتالی یا مجازی وجود داشت توسط بیتکوین، با استفاده از ایجاد یک دفتر کل غیر متمرکز، دیتا مدل بلاکچین و سیستم غیرمتمرکز آن موقعیتی برای ایجاد و حل مشکلات دیگه فراهم کرد.&lt;/p>
&lt;p>ویتالیک بوترین ایده اتریوم و وایت پیپر ان را اولین بار در سال ۲۰۱۳ منتشر کرد. او یک فعال در مجله بیتکوین بود و اعتقاد داشت بیتکوین دارای مشکلاتی است که باید برطرف شود. او در سال ۲۰۱۴ با چند توسعه دهنده دیگر در ماه اوت همان سال برای اجرای ایده خود شروع به جذب سرمایه کرد.&lt;/p></description></item><item><author/><title>12.3.2 رمزنگاری</title><link>https://book.gofarsi.ir/chapter-12/ethereum/ethereum-cryptography/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/ethereum/ethereum-cryptography/</guid><description>&lt;p>رمزنگاری&lt;/p></description></item><item><author/><title>12.3.3 آدرس ها و کلیدها</title><link>https://book.gofarsi.ir/chapter-12/ethereum/ethereum-keys-and-addresses/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/ethereum/ethereum-keys-and-addresses/</guid><description>&lt;p>آدرس ها و کلیدها&lt;/p></description></item><item><author/><title>12.3.4 اکانت ها</title><link>https://book.gofarsi.ir/chapter-12/ethereum/ethereum-accounts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/ethereum/ethereum-accounts/</guid><description>&lt;p>همانطور که میدانید اتریوم از مدل account based بجای &lt;a href="https://en.wikipedia.org/wiki/Unspent_transaction_output">UTXO&lt;/a> استفاده میکند.
اکانت ها در اتریوم، با شبکه بیتکوین تفاوت هایی اساسی دارند. اکانت های اتریوم بصورت کلی به دو دسته EOA و CA تقسیم میشوند.
(external owned account) (contract account)&lt;/p>
&lt;p>در ادامه به خصوصیات و جزییات هر یک از اکانت های کانترکت و اکانت های مالک خارجی (کنترل شده توسط شخص) میپردازیم.&lt;/p>
&lt;h1 id="12341-external-owned-accounts-eoa">
12.3.4.1 external owned accounts (EOA)
&lt;a class="anchor" href="#12341-external-owned-accounts-eoa">#&lt;/a>
&lt;/h1>
&lt;p>حساب های کنترل شده توسط افراد خارجی یا کنترل شده توسط شخص، حساب هایی معمولی هستند که توانایی نگهداری ارز اتر و انتقال ان با استفاده از ایجاد تراکنش بر روی شبکه را دارند.&lt;/p></description></item><item><author/><title>12.3.5 تراکنش ها و پیام ها</title><link>https://book.gofarsi.ir/chapter-12/ethereum/ethereum-transactions-and-messages/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/ethereum/ethereum-transactions-and-messages/</guid><description>&lt;h1 id="12351-تراکنش-ها-در-بلاکچین-اتریوم">
12.3.5.1 تراکنش ها در بلاکچین اتریوم
&lt;a class="anchor" href="#12351-%d8%aa%d8%b1%d8%a7%da%a9%d9%86%d8%b4-%d9%87%d8%a7-%d8%af%d8%b1-%d8%a8%d9%84%d8%a7%da%a9%da%86%db%8c%d9%86-%d8%a7%d8%aa%d8%b1%db%8c%d9%88%d9%85">#&lt;/a>
&lt;/h1>
&lt;p>تراکنش ها در شبکه اتریوم دارای خصوصیاتی متفاوت از تراکنش ها در بیتکوین هستند. علل اصلی این تفاوت ها روش متفاوت اتریوم برای جلوگیری از برخی از حملات و همچنین نیاز به مناسب بودن برای اجرا کانترکت ها در ازای تراکنش ها می باشد.&lt;/p>
&lt;p>در اتریوم تراکنش ها بصورت اتمیک هستند. یعنی ما نمیتوانیم یک تراکنش را به قسمت های دیگری تقسیم و بصورت جدا اجرا و اراعه کنیم. همچنین وضعیت یک تراکنش در اتریوم تنها دو حالت میتوانند داشته باشند. یا انجام شده اند و تغییری برروی ورلد استیت ایجاد کرده اند یا انجام نشده و اثری بر شبکه ندارند.&lt;/p></description></item><item><author/><title>12.3.6 ماشین مجازی اتریوم</title><link>https://book.gofarsi.ir/chapter-12/ethereum/ethereum-virtual-machine/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/ethereum/ethereum-virtual-machine/</guid><description>&lt;h1 id="12361-ماشین-مجازی">
12.3.6.1 ماشین مجازی
&lt;a class="anchor" href="#12361-%d9%85%d8%a7%d8%b4%db%8c%d9%86-%d9%85%d8%ac%d8%a7%d8%b2%db%8c">#&lt;/a>
&lt;/h1>
&lt;p>قبل از شروع بررسی ماشین مجازی اتریوم به مفهوم ماشین مجازی میپردازیم. همانطور که در قسمت های قبل به ورلد استیت اتریوم اشاره کردیم و فهمیدیم که تمام نود های اتریوم یک حافظه وضعیت و یا حالت کلی دارند که همیشه باهم برابر است و در حالت یکسانی قرار دارد و تغییرات بر ورلد استیت با تراکنش ها اعمال میشوند.&lt;/p>
&lt;p>اما تمام شبکه اتریوم به خودی خود یه ورلد کامپیوتر هم میباشد که باید بتواند تمام تراکنش ها را اجرا کند و تغییرات انها را بر روی ورلد استیت اعمال کند. پس اصلی ترین رکن این ورلد کامپیوتر این است که در هر زمان توسط هر کدام از نود ها که اجرا شد خروجی برابری بدهد. (این مساله یکی از دلایلی است که با عدد نانس ترتیب تراکنش ها حفظ میشود و ماشین مجازی اتریوم قابلیت همزمانی را ندارد.)&lt;/p></description></item><item><author/><title>12.3.7 بلاک ها</title><link>https://book.gofarsi.ir/chapter-12/ethereum/ethereum-blocks/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/ethereum/ethereum-blocks/</guid><description>&lt;p>بلاک ها&lt;/p></description></item><item><author/><title>12.3.8 الگوریتم اجماع</title><link>https://book.gofarsi.ir/chapter-12/ethereum/ethereum-consensus/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/ethereum/ethereum-consensus/</guid><description>&lt;p>الگوریتم اجماع&lt;/p></description></item><item><author/><title>12.3.9 نودها و ماینرها</title><link>https://book.gofarsi.ir/chapter-12/ethereum/ethereum-nodes-and-miners/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/ethereum/ethereum-nodes-and-miners/</guid><description>&lt;p>نودها و ماینرها&lt;/p></description></item><item><author/><title>12.3.10 شبکه</title><link>https://book.gofarsi.ir/chapter-12/ethereum/ethereum-network/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/ethereum/ethereum-network/</guid><description>&lt;p>شبکه&lt;/p></description></item><item><author/><title>12.3.11 قراردادهای هوشمند</title><link>https://book.gofarsi.ir/chapter-12/ethereum/ethereum-smart-contracts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/ethereum/ethereum-smart-contracts/</guid><description>&lt;p>قراردادهای هوشمند&lt;/p></description></item><item><author/><title>12.3.12 والت ها و کلاینت ها</title><link>https://book.gofarsi.ir/chapter-12/ethereum/ethereum-wallets-and-clients/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/ethereum/ethereum-wallets-and-clients/</guid><description>&lt;p>والت ها و کلاینت ها&lt;/p></description></item><item><author/><title>12.3.13 معرفی go-ethereum</title><link>https://book.gofarsi.ir/chapter-12/ethereum/go-ethereum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/ethereum/go-ethereum/</guid><description>&lt;p>معرفی go-ethereum&lt;/p></description></item><item><author/><title>12.3.14 کار با اکانت ها</title><link>https://book.gofarsi.ir/chapter-12/ethereum/work-with-accounts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/ethereum/work-with-accounts/</guid><description>&lt;p>کار با اکانت ها&lt;/p></description></item><item><author/><title>12.3.15 تراکنش برروی اتریوم</title><link>https://book.gofarsi.ir/chapter-12/ethereum/transactions-on-ethereum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/ethereum/transactions-on-ethereum/</guid><description>&lt;p>تراکنش برروی اتریوم&lt;/p></description></item><item><author/><title>12.3.16 نوشتن و ارتباط با قراردادهای هوشمند</title><link>https://book.gofarsi.ir/chapter-12/ethereum/read-write-in-smart-contracts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/ethereum/read-write-in-smart-contracts/</guid><description>&lt;p>نوشتن و ارتباط با قراردادهای هوشمند&lt;/p></description></item><item><author/><title>12.3.17 آشنایی با فایل ABI و bytecode</title><link>https://book.gofarsi.ir/chapter-12/ethereum/abi-and-bin-file/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/ethereum/abi-and-bin-file/</guid><description>&lt;p>آشنایی با فایل ABI و bytecode&lt;/p></description></item><item><author/><title>12.3.18 خواندن و دریافت لحظه ای لاگ های کانترکت ها</title><link>https://book.gofarsi.ir/chapter-12/ethereum/event-logs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/ethereum/event-logs/</guid><description>&lt;p>خواندن و دریافت لحظه ای لاگ های کانترکت ها&lt;/p></description></item><item><author/><title>12.3.19 ایجاد و تایید امضا</title><link>https://book.gofarsi.ir/chapter-12/ethereum/signature/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/ethereum/signature/</guid><description>&lt;p>ایجاد و تایید امضا&lt;/p></description></item><item><author/><title>12.3.20 کار با geth</title><link>https://book.gofarsi.ir/chapter-12/ethereum/geth/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/ethereum/geth/</guid><description>&lt;p>کار با geth&lt;/p></description></item><item><author/><title>12.3.21 کار با پروتکل whisper و swarm</title><link>https://book.gofarsi.ir/chapter-12/ethereum/protocol-swarm-and-whisper/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/ethereum/protocol-swarm-and-whisper/</guid><description>&lt;p>کار با پروتکل whisper و swarm&lt;/p></description></item><item><author/><title>12.4.1 معرفی پکتوس</title><link>https://book.gofarsi.ir/chapter-12/pactus/pactus/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/pactus/pactus/</guid><description>&lt;p>معرفی پکتوس&lt;/p></description></item><item><author/><title>12.4.2 نقشه راه و اهداف</title><link>https://book.gofarsi.ir/chapter-12/pactus/pactus-roadmap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/pactus/pactus-roadmap/</guid><description>&lt;p>نقشه راه و اهداف&lt;/p></description></item><item><author/><title>12.4.3 رمزنگاری</title><link>https://book.gofarsi.ir/chapter-12/pactus/pactus-cryptography/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/pactus/pactus-cryptography/</guid><description>&lt;p>رمزنگاری&lt;/p></description></item><item><author/><title>12.4.4 آدرس ها و کلیدها</title><link>https://book.gofarsi.ir/chapter-12/pactus/pactus-addresses-and-keys/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/pactus/pactus-addresses-and-keys/</guid><description>&lt;p>آدرس ها و کلیدها&lt;/p></description></item><item><author/><title>12.4.5 اکانت ها</title><link>https://book.gofarsi.ir/chapter-12/pactus/pactus-accounts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/pactus/pactus-accounts/</guid><description>&lt;p>اکانت ها&lt;/p></description></item><item><author/><title>12.4.6 تراکنش ها و پیغام ها</title><link>https://book.gofarsi.ir/chapter-12/pactus/pactus-transactions-and-messages/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/pactus/pactus-transactions-and-messages/</guid><description>&lt;p>تراکنش ها و پیغام ها&lt;/p></description></item><item><author/><title>12.4.7 الگوریتم اجماع</title><link>https://book.gofarsi.ir/chapter-12/pactus/pactus-consensus/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/pactus/pactus-consensus/</guid><description>&lt;p>الگوریتم اجماع&lt;/p></description></item><item><author/><title>12.4.8 کار با کلاینت</title><link>https://book.gofarsi.ir/chapter-12/pactus/pactus-client/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/pactus/pactus-client/</guid><description>&lt;p>کار با کلاینت&lt;/p></description></item><item><author/><title>12.4.9 قراردادهای هوشمند (بزودی)</title><link>https://book.gofarsi.ir/chapter-12/pactus/pactus-smart-contracts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-12/pactus/pactus-smart-contracts/</guid><description>&lt;p>قراردادهای هوشمند (بزودی)&lt;/p></description></item><item><author/><title>9.1.1 الگو Singleton</title><link>https://book.gofarsi.ir/chapter-9/creational-patterns/go-singleton-pattern/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/creational-patterns/go-singleton-pattern/</guid><description>&lt;p>&lt;span class="tooltip" data-tooltip="Singleton" ontouchend="toggleTooltip(this)">سینگلتون&lt;/span>
یک &lt;span class="tooltip" data-tooltip="Creational Design Pattern" ontouchend="toggleTooltip(this)">الگوی طراحی سازنده&lt;/span>
است که به شما این اجازه را می‌دهد، تنها یک &lt;span class="tooltip" data-tooltip="Object" ontouchend="toggleTooltip(this)">شی&lt;/span>
از &lt;span class="tooltip" data-tooltip="Struct" ontouchend="toggleTooltip(this)">ساختار&lt;/span>
خود را با &lt;span class="tooltip" data-tooltip="Global Access" ontouchend="toggleTooltip(this)">دسترسی سراسری&lt;/span>
ایجاد کنید.&lt;/p>
&lt;center>&lt;a href="#">
&lt;img src="../../../assets/img/content/chapter9/designPatterns/1.png" alt="Singleton">
&lt;/a>&lt;/center>
&lt;p>&lt;strong>الگوی طراحی سینگلتون:&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>اطمینان می‌دهد که تنها یک شی از یک ساختار ایجاد می‌شود.&lt;/li>
&lt;li>مشابه یک متغیر سراسری، به شما امکان می‌دهد از هر جای برنامه به آن شی دسترسی داشته باشید و از بازنویسی توسط نقاط دیگر برنامه نیز محافظت می‌کند.&lt;/li>
&lt;/ol>
&lt;blockquote class="book-hint info">
از الگوی سینگلتون زمانی استفاده کنید که بخواهید تنها یک شی از یک ساختار در دسترس کل برنامه باشد. به عنوان مثال، می‌توانید از الگوی سینگلتون برای ایجاد یک شی واحد از &lt;span class="tooltip" data-tooltip="Logger" ontouchend="toggleTooltip(this)">لاگر&lt;/span>
استفاده کنید که توسط بخش‌های مختلف برنامه به آن دسترسی دارند.
&lt;/blockquote>
&lt;p>&lt;strong>مثال مفهومی از الگوی سینگلتون:&lt;/strong>&lt;/p></description></item><item><author/><title>9.1.2 الگو Factory Method</title><link>https://book.gofarsi.ir/chapter-9/creational-patterns/go-factory-method-pattern/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/creational-patterns/go-factory-method-pattern/</guid><description>&lt;p>الگو Factory Method&amp;hellip;&lt;/p></description></item><item><author/><title>9.1.3 الگو Prototype</title><link>https://book.gofarsi.ir/chapter-9/creational-patterns/go-prototype-pattern/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/creational-patterns/go-prototype-pattern/</guid><description>&lt;p>الگو Prototype&amp;hellip;&lt;/p></description></item><item><author/><title>9.1.4 الگو Abstract Factory</title><link>https://book.gofarsi.ir/chapter-9/creational-patterns/go-abstract-factory-pattern/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/creational-patterns/go-abstract-factory-pattern/</guid><description>&lt;p>الگو Abstract Factory&amp;hellip;&lt;/p></description></item><item><author/><title>9.1.6 الگو Builder</title><link>https://book.gofarsi.ir/chapter-9/creational-patterns/go-builder-pattern/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/creational-patterns/go-builder-pattern/</guid><description>&lt;p>الگو Builder&amp;hellip;&lt;/p></description></item><item><author/><title>9.1.7 الگو Object Pool</title><link>https://book.gofarsi.ir/chapter-9/creational-patterns/go-object-pool-pattern/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/creational-patterns/go-object-pool-pattern/</guid><description>&lt;p>الگو Object Pool&amp;hellip;&lt;/p></description></item><item><author/><title>9.2.1 الگو Adaptor</title><link>https://book.gofarsi.ir/chapter-9/structural-patterns/go-adaptor-pattern/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/structural-patterns/go-adaptor-pattern/</guid><description>&lt;p>الگو Adaptor
الگوی adapter یک الگوی ساختاری است که برای سازگار کردن موجودیت های مختلف با هم به کار می‌رود.&lt;/p>
&lt;p>داده ها در دنیای دیجیتال به فرمت‌های مختلف ذخیره و پردازش می‌شوند. این تفاوت در لایه‌ها و فرمت‌های مختلف نمایان و آشکار است. نمونه واضح و پرکاربرد آن فرمت‌های مختلفی مانند json و xml و باینری&amp;hellip; است که در پروتکل‌های ارتباطی متفاوت مورد استفاده قرار می‌گیرد و گاها برای ایجاد ارتباط و امکان خوانده شدن این داده‌ها نیازمند یک روش و الگوی قابل گسترش هستیم.&lt;/p></description></item><item><author/><title>9.2.2 الگو Bridge</title><link>https://book.gofarsi.ir/chapter-9/structural-patterns/go-bridge-pattern/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/structural-patterns/go-bridge-pattern/</guid><description>&lt;p>الگو Bridge&amp;hellip;&lt;/p></description></item><item><author/><title>9.2.3 الگو Composite</title><link>https://book.gofarsi.ir/chapter-9/structural-patterns/go-composite-pattern/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/structural-patterns/go-composite-pattern/</guid><description>&lt;p>الگو Composite&amp;hellip;&lt;/p></description></item><item><author/><title>9.2.1 الگو Decorator</title><link>https://book.gofarsi.ir/chapter-9/structural-patterns/go-decorator-pattern/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/structural-patterns/go-decorator-pattern/</guid><description>&lt;p>الگو Decorator&amp;hellip;&lt;/p></description></item><item><author/><title>9.2.5 الگو Facade</title><link>https://book.gofarsi.ir/chapter-9/structural-patterns/go-facade-pattern/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/structural-patterns/go-facade-pattern/</guid><description>&lt;p>الگو Facade&amp;hellip;&lt;/p></description></item><item><author/><title>9.2.6 الگو Flyweight</title><link>https://book.gofarsi.ir/chapter-9/structural-patterns/go-flyweight-pattern/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/structural-patterns/go-flyweight-pattern/</guid><description>&lt;p>الگو Flyweight&amp;hellip;&lt;/p></description></item><item><author/><title>9.2.7 الگو Proxy</title><link>https://book.gofarsi.ir/chapter-9/structural-patterns/go-proxy-pattern/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/structural-patterns/go-proxy-pattern/</guid><description>&lt;p>الگو Proxy&amp;hellip;&lt;/p></description></item><item><author/><title>9.3.1 الگو Chain Of Responsibility</title><link>https://book.gofarsi.ir/chapter-9/behavioral-patterns/go-chain-of-responsibility-pattern/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/behavioral-patterns/go-chain-of-responsibility-pattern/</guid><description>&lt;h2 id="9311---الگوی-زنجیره-مسئولیت-chain-of-responsibility">
9.3.1.1 - الگوی زنجیره مسئولیت (Chain of Responsibility)
&lt;a class="anchor" href="#9311---%d8%a7%d9%84%da%af%d9%88%db%8c-%d8%b2%d9%86%d8%ac%db%8c%d8%b1%d9%87-%d9%85%d8%b3%d8%a6%d9%88%d9%84%db%8c%d8%aa-chain-of-responsibility">#&lt;/a>
&lt;/h2>
&lt;p>الگوی زنجیره مسئولیت (Chain of Responsibility) یک الگوی طراحی رفتاری است که به شما امکان می‌دهد درخواست‌ها را در امتداد زنجیره‌ای از هندلرها (handlers) پاس دهید. هر هندلر پس از دریافت یک درخواست، تصمیم می‌گیرد که درخواست را پردازش کند یا آن را به هندلر بعدی در زنجیره منتقل نماید.&lt;/p>
&lt;h3 id="9312----مشکل">
9.3.1.2 - مشکل
&lt;a class="anchor" href="#9312----%d9%85%d8%b4%da%a9%d9%84">#&lt;/a>
&lt;/h3>
&lt;p>فرض کنید روی یک سیستم سفارش آنلاین کار می‌کنید. می‌خواهید دسترسی به سیستم را محدود کنید تا فقط کاربران احراز هویت شده بتوانند سفارش ایجاد کنند. همچنین، کاربرانی که دارای مجوز مدیریت هستند باید دسترسی کامل به تمام سفارشات داشته باشند.&lt;/p></description></item><item><author/><title>9.3.2 الگو Command</title><link>https://book.gofarsi.ir/chapter-9/behavioral-patterns/go-command-pattern/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/behavioral-patterns/go-command-pattern/</guid><description>&lt;h2 id="9321-الگوی-طراحی-فرمان-command">
9.3.2.1-الگوی طراحی فرمان (Command)
&lt;a class="anchor" href="#9321-%d8%a7%d9%84%da%af%d9%88%db%8c-%d8%b7%d8%b1%d8%a7%d8%ad%db%8c-%d9%81%d8%b1%d9%85%d8%a7%d9%86-command">#&lt;/a>
&lt;/h2>
&lt;p>الگوی طراحی Command یک الگوی رفتاری است که یک درخواست را به یک شیء(object) مستقل تبدیل می کند که حاوی تمام اطلاعات مربوط به درخواست است. این تغییر شکل به شما امکان می دهد درخواست‌ها را به عنوان آرگومان متد ارسال کنید و اجرای یک درخواست را به تعویق بیندازید یا در صف قرار دهید و از عملیات قابل لغو پشتیبانی کنید.&lt;/p>
&lt;h2 id="9322-مشکل">
9.3.2.2-مشکل
&lt;a class="anchor" href="#9322-%d9%85%d8%b4%da%a9%d9%84">#&lt;/a>
&lt;/h2>
&lt;p>فرض کنید روی یک برنامه ویرایشگر متن جدید کار می‌کنید. وظیفه فعلی شما ایجاد نوار ابزار با تعدادی دکمه برای عملیات مختلف ویرایشگر است. شما یک کلاس Button بسیار مرتب ایجاد کرده اید که می‌توان از آن برای دکمه های روی نوار ابزار و همچنین برای دکمه های عمومی در گفتگوهای مختلف استفاده کرد.&lt;/p></description></item><item><author/><title>9.3.3 الگو Iterator</title><link>https://book.gofarsi.ir/chapter-9/behavioral-patterns/go-iterator-pattern/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/behavioral-patterns/go-iterator-pattern/</guid><description>&lt;h2 id="9331-هدف">
9.3.3.1-هدف
&lt;a class="anchor" href="#9331-%d9%87%d8%af%d9%81">#&lt;/a>
&lt;/h2>
&lt;p>الگوي طراحی تکرارکننده (Iterator) یک الگوی رفتاری است که به شما امکان می دهد عناصر یک مجموعه را بدون نمایش ساختار درونی آن (فهرست، پشته، درخت و غیره) پیمایش کنید.&lt;/p>
&lt;h2 id="9332-مشکل">
9.3.3.2-مشکل
&lt;a class="anchor" href="#9332-%d9%85%d8%b4%da%a9%d9%84">#&lt;/a>
&lt;/h2>
&lt;p>مجموعه ها (collections) یکی از پرکاربردترین انواع داده در برنامه نویسی هستند. با این وجود، یک مجموعه فقط یک ظرف برای گروهی از اشیاء است.&lt;/p>
&lt;p>&lt;img src="../../../assets/img/content/chapter9/designPatterns/iterator-problem1.png" alt="iterator-problem1" />
(انواع مختلف از collections)&lt;/p>
&lt;p>اکثر مجموعه ها عناصر خود را در لیست های ساده ذخیره می کنند. با این حال، برخی از آنها بر اساس پشته‌ها، درختان، نمودارها و سایر ساختارهای داده پیچیده ساخته شده‌اند.&lt;/p></description></item><item><author/><title>9.3.4 الگو Mediator</title><link>https://book.gofarsi.ir/chapter-9/behavioral-patterns/go-mediator-pattern/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/behavioral-patterns/go-mediator-pattern/</guid><description>&lt;h2 id="9341-الگوی-طراحی-mediator">
9.3.4.1-&lt;strong>الگوی طراحی Mediator&lt;/strong>
&lt;a class="anchor" href="#9341-%d8%a7%d9%84%da%af%d9%88%db%8c-%d8%b7%d8%b1%d8%a7%d8%ad%db%8c-mediator">#&lt;/a>
&lt;/h2>
&lt;p>الگوی طراحی واسطه (&lt;strong>Mediator&lt;/strong>)، یک الگوی رفتاری است که به شما امکان می‌دهد تا وابستگی‌های درهم‌تنیده بین اشیاء را کاهش دهید. این الگو ارتباط مستقیم بین اشیاء را محدود می‌کند و آن‌ها را مجبور می‌سازد تا تنها از طریق یک شیء واسطه با هم همکاری کنند.&lt;/p>
&lt;h3 id="9342-مشکل">
9.3.4.2-&lt;strong>مشکل&lt;/strong>
&lt;a class="anchor" href="#9342-%d9%85%d8%b4%da%a9%d9%84">#&lt;/a>
&lt;/h3>
&lt;p>فرض کنید یک جعبه dialog برای ایجاد و ویرایش پروفایل کاربران دارید. این جعبه dialog شامل کنترل‌های مختلف فرم مانند فیلدهای متنی، کادرهای انتخابی(checkbox)، دکمه‌ها و غیره می‌شود.&lt;/p></description></item><item><author/><title>9.3.5 الگو Memento</title><link>https://book.gofarsi.ir/chapter-9/behavioral-patterns/go-memento-pattern/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/behavioral-patterns/go-memento-pattern/</guid><description>&lt;p>الگو Memento&amp;hellip;&lt;/p></description></item><item><author/><title>9.3.6 الگو Observer</title><link>https://book.gofarsi.ir/chapter-9/behavioral-patterns/go-observer-pattern/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/behavioral-patterns/go-observer-pattern/</guid><description>&lt;p>الگو Observer&amp;hellip;&lt;/p></description></item><item><author/><title>9.3.7 الگو State</title><link>https://book.gofarsi.ir/chapter-9/behavioral-patterns/go-state-pattern/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/behavioral-patterns/go-state-pattern/</guid><description>&lt;p>الگو State&amp;hellip;&lt;/p>
&lt;h2 id="9371-مقدمه">
9.3.7.1 مقدمه:
&lt;a class="anchor" href="#9371-%d9%85%d9%82%d8%af%d9%85%d9%87">#&lt;/a>
&lt;/h2>
&lt;p>دیزاین پترن State یک دیزاین پترن behavioral است که مبتنی بر Finite State Machine است. ما دیزاین پترن State را در زمینه نمونه ای از &lt;a href="https://en.wikipedia.org/wiki/Vending_machine">Vending Machine&lt;/a> توضیح خواهیم داد. برای سادگی، بیایید فرض کنیم که Vending Machine فقط یک نوع کالا یا محصول دارد. همچنین برای سادگی، فرض می کنیم که یک Vending Machine می تواند در 4 حالت(state) مختلف باشد:&lt;/p>
&lt;ol>
&lt;li>&lt;strong>hasItem&lt;/strong>&lt;/li>
&lt;li>&lt;strong>noItem&lt;/strong>&lt;/li>
&lt;li>&lt;strong>itemRequested&lt;/strong>&lt;/li>
&lt;li>&lt;strong>hasMoney&lt;/strong>&lt;/li>
&lt;/ol>
&lt;p>یک Vending Machine خودکار نیز عملکردهای متفاوتی خواهد داشت. دوباره برای سادگی فرض می کنیم که فقط چهار عمل وجود دارد:&lt;/p></description></item><item><author/><title>9.3.8 الگو Strategy</title><link>https://book.gofarsi.ir/chapter-9/behavioral-patterns/go-strategy-pattern/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/behavioral-patterns/go-strategy-pattern/</guid><description>&lt;p>الگو Strategy&amp;hellip;&lt;/p></description></item><item><author/><title>9.3.9 الگو Template Method</title><link>https://book.gofarsi.ir/chapter-9/behavioral-patterns/go-template-method-pattern/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/behavioral-patterns/go-template-method-pattern/</guid><description>&lt;p>الگو Template Method&amp;hellip;&lt;/p>
&lt;h2 id="9391-مقدمه">
9.3.9.1 مقدمه:
&lt;a class="anchor" href="#9391-%d9%85%d9%82%d8%af%d9%85%d9%87">#&lt;/a>
&lt;/h2>
&lt;p>الگوی Template Method یک الگوی طراحی behavioral است که به شما امکان می دهد یک الگو یا الگوریتم برای یک عملیات خاص تعریف کنید. بیایید الگوی Template Method را با یک مثال درک کنیم.&lt;/p>
&lt;p>مثال یک مرز یک بار مصرف (One Time Password) یا OTP را در نظر بگیرید. انواع مختلفی از OTP وجود دارد که می تواند برای مثال اجرا شود. OTP می تواند SMS OTP یا EMAIL OTP باشد. اما صرف نظر از اینکه یک پیامک OTP یا EMAIL OTP باشد، کل مراحل فرآیند OTP یکسان است. مراحل مورد نظر به ترتیب زیر هستند.&lt;/p></description></item><item><author/><title>9.3.10 الگو Visitor</title><link>https://book.gofarsi.ir/chapter-9/behavioral-patterns/go-visitor-pattern/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/behavioral-patterns/go-visitor-pattern/</guid><description>&lt;p>الگو Visitor&amp;hellip;&lt;/p>
&lt;h2 id="93101-مقدمه">
9.3.10.1 مقدمه:
&lt;a class="anchor" href="#93101-%d9%85%d9%82%d8%af%d9%85%d9%87">#&lt;/a>
&lt;/h2>
&lt;p>الگوی طراحی Visitor یک الگوی طراحی Behavioural است که به شما امکان می‌دهد بدون تغییر در ساختار برنامه، رفتاری را به ساختار آن اضافه کنید.&lt;br>
بیایید الگوی Visitor را با یک مثال درک کنیم. فرض کنید شما نگهدارنده(maintainer) یک lib هستید که ساختارهای با شکل‌های متفاوتی دارد مانند:&lt;/p>
&lt;ol>
&lt;li>Square&lt;/li>
&lt;li>Circle&lt;/li>
&lt;li>Triangle&lt;/li>
&lt;/ol>
&lt;p>هر یک از ساختارهای شکل بالا یک شکل رابط مشترک را پیاده سازی می کند. تیم های زیادی در شرکت شما وجود دارند که از lib شما استفاده می کنند. حال فرض کنید یکی از تیم از شما می خواهد که یک رفتار دیگر (getArea()) به ساختارهای Shape اضافه کنید. در نتیجه گزینه های زیادی برای حل این مشکل وجود دارد.&lt;/p></description></item><item><author/><title>9.4.1 الگو Wait For Result</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-wait-for-result/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-wait-for-result/</guid><description>&lt;h2 id="9411-توضیحات">
9.4.1.1 توضیحات
&lt;a class="anchor" href="#9411-%d8%aa%d9%88%d8%b6%db%8c%d8%ad%d8%a7%d8%aa">#&lt;/a>
&lt;/h2>
&lt;p>الگوی &lt;strong>Wait For Result&lt;/strong> یکی از پرکاربردترین الگوها در برنامه‌نویسی همزمان با Go است که هدفش اجرای عملیات به صورت goroutine و انتظار برای دریافت نتیجه از طریق channel است. در این الگو، معمولاً یک کانال تعریف می‌شود تا داده یا نتیجه (و حتی خطا) از goroutine به کد اصلی منتقل شود. این کار باعث می‌شود عملیات‌های طولانی یا زمان‌بر (مثل خواندن فایل، تماس با API یا انجام محاسبات سنگین) بدون بلاک کردن کل برنامه اجرا شوند و به محض آماده شدن نتیجه، به صورت ایمن و همزمان، دریافت شوند. ساختار معمول این الگو به این صورت است که یک goroutine کار را انجام می‌دهد و در پایان نتیجه را داخل کانال می‌فرستد؛ در این مدت goroutine اصلی (یا هر مصرف‌کننده دیگر) با دریافت روی کانال منتظر نتیجه می‌ماند.&lt;/p></description></item><item><author/><title>9.4.2 الگو Fan Out/In</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-fan-out-in/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-fan-out-in/</guid><description>&lt;h2 id="9421-توضیحات">
9.4.2.1 توضیحات
&lt;a class="anchor" href="#9421-%d8%aa%d9%88%d8%b6%db%8c%d8%ad%d8%a7%d8%aa">#&lt;/a>
&lt;/h2>
&lt;p>الگوی &lt;strong>Fan Out/In&lt;/strong> یکی از مهم‌ترین تکنیک‌های همزمانی در زبان Go است که برای افزایش کارایی و سرعت پردازش در سناریوهایی به‌کار می‌رود که نیاز داریم چندین کار مشابه یا مستقل را به صورت موازی انجام دهیم و در نهایت نتایج همه آن‌ها را جمع‌آوری و تجمیع کنیم. در این الگو، معمولاً یک goroutine اصلی چندین goroutine فرعی را راه‌اندازی می‌کند (Fan Out) تا هر کدام یک وظیفه مستقل را انجام دهند؛ سپس نتایج این goroutineها (که می‌تواند هر نوع داده یا حتی خطا باشد) از طریق کانال‌ها جمع‌آوری شده و پس از اتمام همه کارها، نتیجه نهایی (Fan In) به goroutine اصلی برگردانده می‌شود.&lt;/p></description></item><item><author/><title>9.4.3 الگو Wait For Task</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-wait-for-task/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-wait-for-task/</guid><description>&lt;h2 id="9431-توضیحات">
9.4.3.1 توضیحات
&lt;a class="anchor" href="#9431-%d8%aa%d9%88%d8%b6%db%8c%d8%ad%d8%a7%d8%aa">#&lt;/a>
&lt;/h2>
&lt;p>الگوی &lt;strong>Wait For Task&lt;/strong> یکی از ساده‌ترین و در عین حال پراستفاده‌ترین الگوهای همزمانی در Go است که برای &lt;strong>منتظر ماندن تا اتمام یک فرآیند یا تسک معین&lt;/strong> کاربرد دارد. در این الگو معمولاً یک goroutine برای انجام کاری خاص راه‌اندازی می‌شود و پس از اتمام، از طریق یک channel به goroutine اصلی سیگنال پایان کار یا حتی داده‌ی تولیدشده را منتقل می‌کند. این روش به شما امکان می‌دهد همزمان چند کار مستقل را اجرا کنید و به صورت مجزا منتظر پایان هرکدام باشید، یا دقیقاً در لحظه‌ای مشخص بدانید یک تسک خاص تمام شده است و می‌توانید ادامه برنامه را اجرا کنید.&lt;/p></description></item><item><author/><title>9.4.4 الگوی Worker Pool</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-worker-pool/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-worker-pool/</guid><description>&lt;h2 id="9441-توضیحات">
9.4.4.1 توضیحات
&lt;a class="anchor" href="#9441-%d8%aa%d9%88%d8%b6%db%8c%d8%ad%d8%a7%d8%aa">#&lt;/a>
&lt;/h2>
&lt;p>الگوی &lt;strong>Worker Pool&lt;/strong> یکی از مهم‌ترین الگوهای همزمانی در Go محسوب می‌شود و زمانی به‌کار می‌رود که بخواهید تعداد مشخصی goroutine (معمولاً با نقش کارگر یا worker) داشته باشید که وظایف مختلف را به صورت صف (queue) دریافت و اجرا کنند. این کار باعث کنترل بهتر منابع، جلوگیری از ایجاد goroutine بیش از حد (که ممکن است باعث مصرف بی‌رویه CPU و memory یا حتی crash برنامه شود) و مدیریت صف کارها در سیستم‌های real-world و پرلود می‌شود. در این الگو، یک یا چند کانال برای ارسال وظایف (task queue) و دریافت نتایج بین goroutineهای تولیدکننده (producer) و goroutineهای worker (مصرف‌کننده) استفاده می‌شود.&lt;/p></description></item><item><author/><title>9.4.5 الگو Drop</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-drop/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-drop/</guid><description>&lt;h2 id="9451-توضیحات">
9.4.5.1 توضیحات
&lt;a class="anchor" href="#9451-%d8%aa%d9%88%d8%b6%db%8c%d8%ad%d8%a7%d8%aa">#&lt;/a>
&lt;/h2>
&lt;p>الگوی &lt;strong>Drop&lt;/strong> یا &lt;strong>Drop Overflow&lt;/strong> یکی از الگوهای حیاتی برای سیستم‌هایی است که ممکن است با موجی از درخواست‌ها روبرو شوند که بیش از ظرفیت واقعی سیستم است. در این الگو، زمانی که صف یا ظرفیت پردازش درخواست‌ها (مثلاً یک کانال یا بافر) پر می‌شود، به جای اینکه سیستم را دچار ازدحام، توقف یا crash کند، به سادگی درخواست‌های اضافی (یا جدیدتر یا قدیمی‌تر، بر اساس سیاست) را حذف (Drop) می‌کند. این کار باعث می‌شود سرویس همواره پایدار و قابل اطمینان باقی بماند و منابع اصلی به خاطر یک سناریوی غیرعادی یا حمله دچار مشکل نشود.&lt;/p></description></item><item><author/><title>9.4.6 الگو Context Cancellation Pattern</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-cancellation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-cancellation/</guid><description>&lt;h2 id="9461-توضیحات">
9.4.6.1 توضیحات
&lt;a class="anchor" href="#9461-%d8%aa%d9%88%d8%b6%db%8c%d8%ad%d8%a7%d8%aa">#&lt;/a>
&lt;/h2>
&lt;p>الگوی &lt;strong>Cancellation&lt;/strong> یا &lt;strong>Context Cancellation Pattern&lt;/strong> یکی از تکنیک‌های کلیدی در Go برای کنترل lifecycle goroutineها و جلوگیری از اجرای ناخواسته یا بی‌پایان آن‌هاست. هدف اصلی این الگو، ارسال سیگنال توقف به goroutineهایی است که به هر دلیلی باید عملیات خود را زودتر از موعد قطع کنند؛ مثلاً کاربر درخواست کنسل می‌دهد، تایم‌اوت رخ می‌دهد یا رویداد خاصی در سیستم اتفاق می‌افتد.&lt;/p>
&lt;p>در معماری idiomatic Go، برای پیاده‌سازی لغو عملیات، به‌جای بستن کانال‌های اختصاصی، از &lt;strong>context.Context&lt;/strong> استفاده می‌شود که یک سازوکار استاندارد، ساده و thread-safe برای انتشار سیگنال لغو (cancelation) و همچنین مدیریت تایم‌اوت‌ها و مقادیر مرتبط است. معمولاً یک context اصلی با دستور &lt;code>context.WithCancel&lt;/code> یا &lt;code>context.WithTimeout&lt;/code> ساخته می‌شود و این context به تمامی goroutineها و تابع‌های فرزند پاس داده می‌شود. هر goroutine به طور دوره‌ای وضعیت context را بررسی می‌کند (با &lt;code>&amp;lt;-ctx.Done()&lt;/code> یا &lt;code>ctx.Err()&lt;/code>) و اگر سیگنال لغو صادر شده باشد، عملیات خود را متوقف می‌کند و منابع را آزاد می‌سازد.&lt;/p></description></item><item><author/><title>9.4.7 الگو Semaphore</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-semaphore/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-semaphore/</guid><description>&lt;h2 id="9471-توضیحات">
9.4.7.1 توضیحات
&lt;a class="anchor" href="#9471-%d8%aa%d9%88%d8%b6%db%8c%d8%ad%d8%a7%d8%aa">#&lt;/a>
&lt;/h2>
&lt;p>الگوی &lt;strong>Semaphore&lt;/strong> (سمیفور) یکی از مفاهیم کلیدی در دنیای همزمانی (Concurrency) است و نقش آن مدیریت کنترل دسترسی به منابع محدود (مانند فایل، شبکه، دیتابیس و…) در یک زمان است. این الگو مخصوصاً زمانی کاربرد دارد که چندین goroutine یا درخواست به طور همزمان قصد استفاده از یک منبع یا سرویس را دارند، اما تنها تعداد محدودی مجاز به استفاده همزمان از آن هستند. پیاده‌سازی این الگو در Go بسیار ساده و idiomatic است و معمولاً از &lt;strong>کانال بافر دار&lt;/strong> (buffered channel) به عنوان سمیفور استفاده می‌شود.&lt;/p></description></item><item><author/><title>9.4.8 الگو Retry Timeout</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-retry-timeout/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-retry-timeout/</guid><description>&lt;h2 id="9481-توضیحات">
9.4.8.1 توضیحات
&lt;a class="anchor" href="#9481-%d8%aa%d9%88%d8%b6%db%8c%d8%ad%d8%a7%d8%aa">#&lt;/a>
&lt;/h2>
&lt;p>الگوی &lt;strong>Retry Timeout&lt;/strong> یکی از رایج‌ترین و مهم‌ترین الگوها در توسعه سرویس‌های پایدار (resilient) و سیستم‌های توزیع‌شده است. این الگو زمانی کاربرد دارد که عملیاتی مانند تماس با سرویس خارجی (مثلاً API، پایگاه داده، یا هر نوع ارتباط شبکه‌ای) ممکن است به صورت موقت شکست بخورد و لازم باشد با رعایت یک فاصله زمانی معین (timeout) چند بار به طور خودکار تلاش مجدد (retry) صورت بگیرد تا شانس موفقیت افزایش یابد و تجربه کاربری بهبود پیدا کند.&lt;/p></description></item><item><author/><title>9.4.9 الگو Producer-Consumer</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-producer-consumer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-producer-consumer/</guid><description>&lt;h2 id="9491-توضیحات">
9.4.9.1 توضیحات
&lt;a class="anchor" href="#9491-%d8%aa%d9%88%d8%b6%db%8c%d8%ad%d8%a7%d8%aa">#&lt;/a>
&lt;/h2>
&lt;p>الگوی &lt;strong>Producer-Consumer&lt;/strong> یکی از الگوهای بنیادی و بسیار پرکاربرد در برنامه‌نویسی همزمان (concurrent) با زبان Go است که امکان تولید و مصرف داده به صورت همزمان و ایمن را فراهم می‌کند. در این الگو، معمولاً یک یا چند goroutine به عنوان &lt;strong>تولیدکننده (Producer)&lt;/strong> وظیفه تولید داده، رویداد یا پیام را بر عهده دارند و داده‌های تولیدی را از طریق یک &lt;strong>کانال (channel)&lt;/strong> به goroutineهای دیگر که نقش &lt;strong>مصرف‌کننده (Consumer)&lt;/strong> را دارند، ارسال می‌کنند. مصرف‌کننده‌ها نیز به صورت موازی داده‌های دریافتی را از کانال خوانده و پردازش می‌کنند. این جداسازی نقش تولید و مصرف، باعث می‌شود بخش‌های مختلف برنامه به صورت مستقل و همزمان عمل کرده و در عین حال از race condition و مشکلات همزمانی جلوگیری شود.&lt;/p></description></item><item><author/><title>9.4.10 الگو Monitor</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-monitor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-monitor/</guid><description>&lt;h2 id="94101-توضیحات">
9.4.10.1 توضیحات
&lt;a class="anchor" href="#94101-%d8%aa%d9%88%d8%b6%db%8c%d8%ad%d8%a7%d8%aa">#&lt;/a>
&lt;/h2>
&lt;p>الگوی &lt;strong>مانیتور (Monitor Pattern)&lt;/strong> یکی از مفاهیم کلیدی در طراحی سیستم‌های همزمان است که هدف آن فراهم کردن مکانیزمی برای مدیریت ایمن و هماهنگ دسترسی چندین goroutine به یک منبع یا وضعیت مشترک است. این الگو به گونه‌ای طراحی شده که goroutineها بتوانند زمانی که منتظر وقوع یک شرط خاص (مثلاً آماده شدن داده یا تغییر وضعیت یک منبع) هستند، بدون مصرف بیهوده منابع (مانند CPU) یا بلاک شدن کل برنامه، به حالت خواب بروند و به محض برقرار شدن شرط، از خواب بیدار شوند و ادامه اجرا دهند. این رفتار دقیقاً چیزی است که در زبان Go می‌توان با کمک ساختار &lt;strong>sync.Cond&lt;/strong> پیاده‌سازی کرد.&lt;/p></description></item><item><author/><title>9.4.11 الگو Future</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-future/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-future/</guid><description>&lt;h2 id="94111-توضیحات">
9.4.11.1 توضیحات
&lt;a class="anchor" href="#94111-%d8%aa%d9%88%d8%b6%db%8c%d8%ad%d8%a7%d8%aa">#&lt;/a>
&lt;/h2>
&lt;p>الگوی &lt;strong>Future&lt;/strong> (یا &lt;strong>Promise&lt;/strong>) یکی از الگوهای مهم و کاربردی در طراحی سیستم‌های ناهمزمان (asynchronous) است که در زبان Go نیز، اگرچه به صورت مستقیم در کتابخانه استاندارد وجود ندارد، اما می‌توان با استفاده از ابزارهای زبان مانند goroutine و channel، به‌سادگی آن را پیاده‌سازی کرد. هدف این الگو این است که یک &amp;ldquo;آبجکت&amp;rdquo; یا واسط به برنامه‌نویس داده شود که نماینده نتیجه یک عملیات (مانند درخواست شبکه یا محاسبه سنگین) است—حتی اگر آن عملیات هنوز به پایان نرسیده باشد.&lt;/p></description></item><item><author/><title>9.4.12 الگو Pipeline</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-pipeline/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-pipeline/</guid><description>&lt;h2 id="94121-توضیحات">
9.4.12.1 توضیحات
&lt;a class="anchor" href="#94121-%d8%aa%d9%88%d8%b6%db%8c%d8%ad%d8%a7%d8%aa">#&lt;/a>
&lt;/h2>
&lt;p>الگوی &lt;strong>خط لوله (Pipeline)&lt;/strong> یکی از حرفه‌ای‌ترین و پرکاربردترین الگوهای همزمانی در زبان Go است که نقش بسیار مهمی در طراحی سیستم‌های مقیاس‌پذیر، قابل نگهداری و با کارایی بالا دارد. هدف این الگو این است که یک کار بزرگ یا پردازش پیچیده را به چند مرحله (stage) کاملاً مستقل تقسیم کند، به طوری که هر مرحله بتواند همزمان با مراحل دیگر اجرا شود. در این ساختار، هر stage مسئولیت انجام یک بخش خاص از فرآیند را بر عهده دارد (مثلاً خواندن داده، پاک‌سازی، پردازش، ذخیره‌سازی و&amp;hellip;) و معمولاً هر stage در یک goroutine مجزا اجرا می‌شود.&lt;/p></description></item><item><author/><title>9.4.13 الگو Subscription</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-subscription/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-subscription/</guid><description>&lt;h2 id="94131-توضیحات">
9.4.13.1 توضیحات
&lt;a class="anchor" href="#94131-%d8%aa%d9%88%d8%b6%db%8c%d8%ad%d8%a7%d8%aa">#&lt;/a>
&lt;/h2>
&lt;p>الگوی &lt;strong>Subscription&lt;/strong> (یا Pub-Sub / Observer Pattern) یکی از پرکاربردترین الگوها در معماری‌های رویداد-محور و همزمان (event-driven &amp;amp; concurrent) است که امکان &lt;strong>ثبت‌نام (subscribe) یک یا چند مصرف‌کننده (consumer)&lt;/strong> را برای دریافت خودکار داده‌های جدید از یک منبع یا سرویس فراهم می‌کند. در این الگو، یک یا چند &lt;strong>مصرف‌کننده&lt;/strong> به یک &amp;ldquo;آدرس&amp;rdquo; یا منبع اشتراک (مثلاً یک topic، کانال یا event source) متصل می‌شوند و هر زمان که داده یا رویداد جدیدی منتشر شد (publish)، اطلاعات به طور خودکار و بی‌نیاز از polling مکرر به همه‌ی مصرف‌کننده‌های عضو ارسال می‌شود.&lt;/p></description></item><item><author/><title>9.4.14 الگو Bridge Channel</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-brdige-channel/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-brdige-channel/</guid><description>&lt;h2 id="94141-توضیحات">
9.4.14.1 توضیحات
&lt;a class="anchor" href="#94141-%d8%aa%d9%88%d8%b6%db%8c%d8%ad%d8%a7%d8%aa">#&lt;/a>
&lt;/h2>
&lt;p>الگوی &lt;strong>Bridge Channel&lt;/strong> یکی از الگوهای ساده اما بسیار مفید در زبان Go است که امکان &lt;strong>اتصال و انتقال داده بین دو یا چند کانال مستقل&lt;/strong> را فراهم می‌کند. این الگو زمانی کاربرد دارد که بخواهید داده‌های تولیدشده در یک goroutine یا زیرسیستم را پس از دریافت، به کانال دیگری هدایت کنید؛ به عبارتی، مانند یک &lt;strong>پل (bridge)&lt;/strong> عمل می‌کنید که داده‌ها را از یک کانال ورودی گرفته و به کانال خروجی منتقل می‌نماید.&lt;/p></description></item><item><author/><title>9.4.15 الگو Queuing</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-queuing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-queuing/</guid><description>&lt;h2 id="94151-توضیحات">
9.4.15.1 توضیحات
&lt;a class="anchor" href="#94151-%d8%aa%d9%88%d8%b6%db%8c%d8%ad%d8%a7%d8%aa">#&lt;/a>
&lt;/h2>
&lt;p>الگوی &lt;strong>صف (Queue Pattern)&lt;/strong> در زبان Go، الگویی است که در آن با استفاده از یک goroutine مرکزی و یک یا چند &lt;strong>کانال ورودی و خروجی&lt;/strong>، داده‌ها را به صورت منظم، &lt;strong>به ترتیب ورود (FIFO)&lt;/strong> مدیریت می‌کند. در این الگو، برخلاف استفاده مستقیم از کانال که ممکن است ترتیب یا بافر محدودی داشته باشد، یک گوروتین به عنوان &lt;strong>صف درون‌ساخت (in-memory queue)&lt;/strong> عمل می‌کند و داده‌های دریافتی از کانال ورودی را در یک &lt;strong>ساختار صف مانند (مانند slice)&lt;/strong> نگه می‌دارد، سپس بر اساس منطق زمان‌بندی یا در دسترس بودن مصرف‌کننده، آن‌ها را به کانال خروجی ارسال می‌کند.&lt;/p></description></item><item><author/><title>9.4.16 الگو Rate limit</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-ratelimit/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-ratelimit/</guid><description>&lt;h2 id="94161-توضیحات">
9.4.16.1 توضیحات
&lt;a class="anchor" href="#94161-%d8%aa%d9%88%d8%b6%db%8c%d8%ad%d8%a7%d8%aa">#&lt;/a>
&lt;/h2>
&lt;p>الگوی &lt;strong>Rate Limiting&lt;/strong> یا &amp;ldquo;محدودسازی نرخ درخواست&amp;rdquo; یکی از الگوهای پرکاربرد برای کنترل ترافیک ورودی یا پردازش عملیات در سیستم‌های نرم‌افزاری است. هدف اصلی این الگو، جلوگیری از اجرای بیش از حد عملیات در یک بازه‌ی زمانی مشخص است تا از بارگذاری بیش از حد سیستم، نقض محدودیت‌های منابع خارجی (مثل APIها)، یا سوءاستفاده از سرویس جلوگیری شود. این الگو در سرویس‌هایی که به منابع محدود یا خارجی متصل‌اند—مثل وب‌سرویس‌ها، میکروسرویس‌ها، API گیت‌وی‌ها یا سیستم‌های صف پردازش—به‌شدت حیاتی است.&lt;/p></description></item><item><author/><title>9.4.17 الگو Deadlock Recovery</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-deadlock-recovery/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-deadlock-recovery/</guid><description>&lt;h2 id="94171-توضیحات">
9.4.17.1 توضیحات
&lt;a class="anchor" href="#94171-%d8%aa%d9%88%d8%b6%db%8c%d8%ad%d8%a7%d8%aa">#&lt;/a>
&lt;/h2>
&lt;p>الگوی &lt;strong>بازیابی از بن‌بست (Deadlock Recovery)&lt;/strong> یکی از الگوهای مهم در طراحی سیستم‌های همزمان (concurrent systems) است که به ما کمک می‌کند از شرایطی خطرناک به نام &lt;em>بن‌بست&lt;/em> (deadlock) خارج شویم. در شرایط بن‌بست، دو یا چند گوروتین (یا نخ) در حالتی گیر می‌افتند که هر یک منتظر آزاد شدن منبعی است که توسط دیگری نگه داشته شده؛ در نتیجه هیچ‌کدام نمی‌توانند پیش بروند و کل سیستم در حالت توقف (freeze) باقی می‌ماند.&lt;/p></description></item><item><author/><title>9.4.18 الگو Channel Cancellation</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-channel-cancellation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-channel-cancellation/</guid><description>&lt;h2 id="94181-توضیحات">
9.4.18.1 توضیحات
&lt;a class="anchor" href="#94181-%d8%aa%d9%88%d8%b6%db%8c%d8%ad%d8%a7%d8%aa">#&lt;/a>
&lt;/h2>
&lt;p>الگوی &lt;strong>Channel Cancellation&lt;/strong> یا «لغو با کانال» یکی از الگوهای کلیدی در طراحی برنامه‌های همزمان (concurrent) در زبان Go است. این الگو زمانی استفاده می‌شود که نیاز باشد یک یا چند گوروتین را به‌صورت هماهنگ و ایمن متوقف کنیم، به‌ویژه در شرایطی که ادامه اجرای آن‌ها بی‌فایده یا مضر است (مثلاً خطا رخ داده، زمان‌سنج تمام شده یا برنامه در حال خاتمه است). این الگو برخلاف استفاده از &lt;code>context.Context&lt;/code> (که در Go برای لغو استاندارد توصیه می‌شود)، از یک &lt;code>channel&lt;/code> اختصاصی برای ارسال سیگنال لغو استفاده می‌کند.&lt;/p></description></item><item><author/><title>9.4.19 الگو Lock-free synchronization</title><link>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-lock-free-synchronization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/concurrency-patterns/go-concurrency-pattern-lock-free-synchronization/</guid><description>&lt;h2 id="94191-توضیحات">
9.4.19.1 توضیحات
&lt;a class="anchor" href="#94191-%d8%aa%d9%88%d8%b6%db%8c%d8%ad%d8%a7%d8%aa">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>همگام‌سازی بدون قفل (lock-free synchronization)&lt;/strong> به مجموعه‌ای از تکنیک‌ها و الگوهای برنامه‌نویسی گفته می‌شود که به چندین thread یا goroutine اجازه می‌دهد به طور همزمان و ایمن به داده‌های مشترک دسترسی پیدا کنند، بدون اینکه از primitiveهایی مثل Mutex یا قفل‌های سنتی استفاده شود. هدف اصلی این الگوها افزایش &lt;strong>بازدهی (throughput)&lt;/strong>، کاهش &lt;strong>زمان انتظار (latency)&lt;/strong> و جلوگیری از مشکلات رایج قفل‌گذاری (مثل deadlock، priority inversion و contention) است. الگوریتم‌های lock-free تضمین می‌کنند که حتی اگر برخی از threadها متوقف شوند یا دچار کندی شوند، باقی سیستم همچنان قادر به پیشرفت خواهد بود (&lt;strong>progress guarantee&lt;/strong>).&lt;/p></description></item><item><author/><title>9.7 اصول SOLID</title><link>https://book.gofarsi.ir/chapter-9/solid-principle-in-golang/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/solid-principle-in-golang/</guid><description>&lt;p>این مقاله ترجمه ارایه اصول solid در golang توسط &lt;a href="https://dave.cheney.net/">Dave Cheney&lt;/a>می‌‌باشد.
در این مبحث به بررسی پیاده سازی solid در زبان Go می‌پردازیم.&lt;/p>
&lt;h4 id="بررسی-کد">
بررسی کد
&lt;a class="anchor" href="#%d8%a8%d8%b1%d8%b1%d8%b3%db%8c-%da%a9%d8%af">#&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>چه کسی اینجا بررسی کد را به عنوان بخشی از کار خود انجام می‌دهد؟ تمام اتاق دستشان را بالا بردند که تشویق کننده بود. خوب، چرا بررسی کد انجام می‌دهید؟ کسی فریاد زد «برای جلوگیری از کد بد»&lt;/li>
&lt;li>اگر code review برای شناسایی کد‌های نامناسب است، پس چگونه می‌دانید کدی که بررسی می‌کنید خوب است یا بد؟&lt;/li>
&lt;li>حالا خوب است بگوییم «آن کد نامناسب است» یا «آن کد منبع زیبا است»، درست مانند اینکه بگویید «این نقاشی زیبا است» یا «این اتاق زیبا است» اما اینها اصطلاحات ذهنی هستند و من به دنبال راه‌های عینی برای صحبت در مورد خواص کد خوب یا بد هستم.&lt;/li>
&lt;/ul>
&lt;h4 id="کد-بد">
کد بد
&lt;a class="anchor" href="#%da%a9%d8%af-%d8%a8%d8%af">#&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>برخی از ویژگی‌های کد بد که ممکن است در بررسی کد به آن پی ببرید کدامند؟&lt;/li>
&lt;li>سفت و خشک یا در اصطلاح Rigid. آیا کد Rigid است؟ آیا دارای یک محافظ محدود کننده از انواع و پارامترهای غالب است که اصلاح آن را دشوار می‌کند؟&lt;/li>
&lt;li>شکننده یا در اصطلاح Fragile. آیا کد Fragile است؟ آیا کوچکترین تغییر در کد باعث ایجاد ویرانی‌های فراوان می‌شود؟&lt;/li>
&lt;li>بی‌حرکتی یا Immobile . آیا تغییر در ساختار کد سخت است؟ آیا اضافه کردن یک حلقه ساده در برنامه کار پیچیده‌ای است؟&lt;/li>
&lt;li>پیچیده (Complex). آیا کدها به دلیل اینکه فقط کدی نوشته شده باشد بدون آن که به آن نیاز باشد، وجود دارد، آیا چیزها بیش از حد مهندسی (over-engineered) شده‌اند؟&lt;/li>
&lt;li>شرح دادن بیش از حد یا Verbose. آیا استفاده و بررسی از کد خسته‌کننده است؟ وقتی به آن نگاه می‌کنید، می‌توانید بگویید این کد چه کاری می‌خواهد انجام دهد؟&lt;/li>
&lt;li>آیا این کلمات مثبت هستند؟ آیا از شنیدن این کلمات در بررسی کد خود خوشحال خواهید شد؟&lt;/li>
&lt;li>احتمالا نه.&lt;/li>
&lt;/ul>
&lt;h4 id="طراحی-خوب">
طراحی خوب
&lt;a class="anchor" href="#%d8%b7%d8%b1%d8%a7%d8%ad%db%8c-%d8%ae%d9%88%d8%a8">#&lt;/a>
&lt;/h4>
&lt;p>اما این یک بهبود دادن در سطح کد است، حالا می‌توانیم چیزهایی مثل «من این را دوست ندارم چون خیلی سخت است تغییرش داد» یا «من این را دوست ندارم چون نمی‌توانم بفهمم کد چه کاری می‌خواهد انجام دهد» بگوییم، اما چه می‌شود اگر با مثبت شروع کنیم؟&lt;/p></description></item><item><author/><title>9.5.1 الگو Circuit Breaker</title><link>https://book.gofarsi.ir/chapter-9/cloud-native-patterns/go-cloud-native-circuit-breaker-pattern/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/cloud-native-patterns/go-cloud-native-circuit-breaker-pattern/</guid><description>&lt;p>الگو Circuit Breaker&amp;hellip;&lt;/p></description></item><item><author/><title>9.5.2 الگو Debounce</title><link>https://book.gofarsi.ir/chapter-9/cloud-native-patterns/go-cloud-native-debounce-pattern/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/cloud-native-patterns/go-cloud-native-debounce-pattern/</guid><description>&lt;p>الگو Debounce&amp;hellip;&lt;/p></description></item><item><author/><title>9.5.3 الگو Retry</title><link>https://book.gofarsi.ir/chapter-9/cloud-native-patterns/go-cloud-native-retry-pattern/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/cloud-native-patterns/go-cloud-native-retry-pattern/</guid><description>&lt;p>الگو Retry&amp;hellip;&lt;/p></description></item><item><author/><title>9.5.4 الگو Throttle</title><link>https://book.gofarsi.ir/chapter-9/cloud-native-patterns/go-cloud-native-throttle-pattern/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/cloud-native-patterns/go-cloud-native-throttle-pattern/</guid><description>&lt;p>الگو Throttle&amp;hellip;&lt;/p></description></item><item><author/><title>9.5.5 الگو Timeout</title><link>https://book.gofarsi.ir/chapter-9/cloud-native-patterns/go-cloud-native-timeout-pattern/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/cloud-native-patterns/go-cloud-native-timeout-pattern/</guid><description>&lt;p>الگو Timeout&amp;hellip;&lt;/p></description></item><item><author/><title>9.6.1 ضد الگو سینتکسی</title><link>https://book.gofarsi.ir/chapter-9/anti-pattern/go-anti-patterns-in-syntax/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-9/anti-pattern/go-anti-patterns-in-syntax/</guid><description>&lt;p>ضد الگو سینتکسی&lt;/p></description></item><item><author/><title/><link>https://book.gofarsi.ir/chapter-10/10.1--data-structures-queue-stack-lists/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-10/10.1--data-structures-queue-stack-lists/</guid><description>&lt;p>در این قسمت به بررسی مواردی مهم از ساختمان داده در زبان گو می‌پردازیم و این آموزش مناسب افرادی هست که با مباحث ساختمان داده آشنایی داشته باشند.&lt;/p>
&lt;h2 id="1011--queue-in-golang">
10.1.1 Queue in Golang
&lt;a class="anchor" href="#1011--queue-in-golang">#&lt;/a>
&lt;/h2>
&lt;p>یک صف (queue) ساده را می توان با استفاده از GO به کمک موارد زیر پیاده سازی کرد:&lt;/p>
&lt;ol>
&lt;li>container/list package&lt;/li>
&lt;li>slice&lt;/li>
&lt;/ol>
&lt;p>یک صف عملیات زیر را انجام می‌دهد:&lt;/p>
&lt;ol>
&lt;li>Enqueue&lt;/li>
&lt;li>Dequeue&lt;/li>
&lt;li>Front&lt;/li>
&lt;li>Size&lt;/li>
&lt;li>Empty&lt;/li>
&lt;/ol>
&lt;h3 id="10111---list-implementation">
10.1.1.1 &lt;strong>List Implementation&lt;/strong>
&lt;a class="anchor" href="#10111---list-implementation">#&lt;/a>
&lt;/h3>
&lt;p>پیاده سازی صف به کمک لیست‌ها&lt;/p></description></item></channel></rss>