<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><author/><title>فصل دوم: مکانیزم‌های زبان on زبان گو فارسی</title><link>https://book.gofarsi.ir/chapter-2/</link><description>Recent content in فصل دوم: مکانیزم‌های زبان on زبان گو فارسی</description><generator>Hugo -- gohugo.io</generator><language>fa</language><copyright>2023 GoFarsi All rights reserved</copyright><atom:link href="https://book.gofarsi.ir/chapter-2/feed.xml" rel="self" type="application/rss+xml"/><item><author/><title>2.1 اشاره‌گر (Pointer)</title><link>https://book.gofarsi.ir/chapter-2/pointer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-2/pointer/</guid><description>&lt;p>&lt;span class="tooltip" data-tooltip="pointer" ontouchend="toggleTooltip(this)">اشاره‌گر&lt;/span>
در واقع متغیری است که، آدرس حافظه یک مقدار را نگه می‌دارد.&lt;/p>
&lt;pre>&lt;code class="language-go">var ex *T
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="../../assets/img/content/chapter2/pointer/1.png" alt="pointer" />&lt;/p>
&lt;p>درک اشاره‌گرها (Pointers) برای بسیاری از مبتدیان ترسناک به نظر می‌رسد، اما در واقع اگر با یک مثال ساده آن را توضیح دهیم، می‌تواند بسیار قابل فهم باشد. اجازه بدهید ترجمه و توضیحی روان بر پایه مثالی که دادی ارائه کنم:&lt;/p>
&lt;blockquote>
&lt;p>اشاره‌گرها پیچیده به نظر می‌رسند،
اما واقعاً نیازی نیست که این‌طور باشند.
اشاره‌گرها را می‌توان شبیه &amp;ldquo;فهرست مطالب یک کتاب&amp;rdquo; در نظر گرفت.
برای مثال، همین کتاب را در نظر بگیر.
فهرست مطالب این کتاب مثل پنج اشاره‌گر است.
شما می‌توانید آن‌ها را بخوانید و بفهمید که اطلاعات مربوط به هر فصل در کجا قرار دارد.
مثلاً فصل «زندگی من» در صفحه ۱ است (یعنی به صفحه ۱ اشاره می‌کند).
و فصل «شغل من» در صفحه ۲۳ است.&lt;/p>&lt;/blockquote>
&lt;blockquote class="book-hint info">
&lt;p>در بین برنامه نویسان زبان Go همیشه این مسئله بوده که &lt;strong>کی و کجا&lt;/strong> باید از Pointer استفاده کنیم؟!&lt;/p>
&lt;p>دیدگاه من نسبت به Pointer :&lt;/p>
&lt;p>زمانی باید از Pointer استفاده کنید که &lt;strong>قصد دارید یک متغیری را در scope ها و توابع مختلف مقدار دهی کنید&lt;/strong> در اینجا بهتر است از Pointer استفاده کنیم تا جلو کپی شدن متغیر در خانه های مختلف حافظه گرفته شود.&lt;/p>
&lt;p>ساده تر بهش بخواهیم نگاه کنیم &lt;strong>وقتی حس کردی میخوای یک متغیر را در چند جای مختلف خارج از اونجایی که تعریف شده مقدار دهی کنی بهتر است آن متغیر را بصورت Pointer برای مقدار دهی پاس دهید.&lt;/strong>&lt;/p>
&lt;p>حتی این قضیه برای اینکه method تعریف کنیم صدق میکنه که چرا باید متد با Pointer یا بدون Pointer تعریف کنیم.&lt;/p>
&lt;p>نکته مهم 1: &lt;strong>استفاده از Pointer باید با دقت انجام شود تا از مشکلاتی مانند دسترسی همزمان به متغیرها و اشتباهات مرتبط با حافظه جلوگیری شود.&lt;/strong>&lt;/p>
&lt;p>نکته مهم 2: استفاده از Pointer خیلی خوب و مفید است اما در جای درست چون اگر نتوانیم تشخیص دهیم کی و کجا استفاده کنیم به مرور باعث کاهش عملکرد برنامه خواهد شد.&lt;/p>
&lt;/blockquote>
&lt;p>در مثال بالا ما شیوه تعریف یک متغیر اشاره‌گر را توضیح دادیم. اول کلید واژه ی &lt;strong>var&lt;/strong> بعد اسم متغیر و در آخر هم *T یعنی تایپ متغیر. به مثال زیر توجه کنید:&lt;/p>
&lt;pre>&lt;code class="language-go">var ptr *string
&lt;/code>&lt;/pre>
&lt;p>در تعریف &lt;span class="tooltip" data-tooltip="pointer" ontouchend="toggleTooltip(this)">اشاره‌گر&lt;/span>
‌ها, ما ۲ تا اپراتور داریم که کارکرد هر کدام از این اپراتورها رو در ادامه توضیح میدم:&lt;/p>
&lt;ul>
&lt;li>&lt;code>&amp;amp;&lt;/code> &lt;code>بهش میگن ampersand&lt;/code> با استفاده از این می‌توانیم آدرس حافظه متغیر فرضا x را به متغیر دیگری بدهیم (&lt;code>y := &amp;amp;x&lt;/code>)&lt;/li>
&lt;li>&lt;code>*&lt;/code> &lt;code>بهش میگن asterisk&lt;/code> با استفاده از این می‌توانیم به مقدار داخل حافظه متغیر فرضا x دسترسی پیدا کنیم (&lt;code>x*&lt;/code>)&lt;/li>
&lt;/ul>
&lt;p>برای اینکه یک &lt;span class="tooltip" data-tooltip="pointer" ontouchend="toggleTooltip(this)">اشاره گر&lt;/span>
تعریف کنیم ۲ روش وجود دارد:&lt;/p>
&lt;ol>
&lt;li>استفاده از تابع &lt;code>new&lt;/code>&lt;/li>
&lt;li>استفاده از اپراتور &lt;code>&amp;amp;&lt;/code> (آمپرسند)&lt;/li>
&lt;/ol>
&lt;h3 id="مثال-1">
مثال 1
&lt;a class="anchor" href="#%d9%85%d8%ab%d8%a7%d9%84-1">#&lt;/a>
&lt;/h3>
&lt;p>فرض کنید شما 1 متغیر دارید و قصد دارید داخل 3 تابع مختلف مقدارش را بروز کنید و با یک تابع دیگر نمایش دهید:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
var count int
addCount(&amp;count)
addCount(&amp;count)
addCountWithoutPointer(count)
fmt.Printf("value = %d, address in memory = %p\n", count, &amp;count)
printCount(count)
}
func addCount(x *int) {
*x++
fmt.Printf("value = %d, address in memory = %p\n", *x, x)
}
func addCountWithoutPointer(x int) {
x++
fmt.Printf("value = %d, address in memory = %p\n", x, &amp;x)
}
func printCount(x int) {
fmt.Printf("value = %d, address in memory = %p\n", x, &amp;x)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>&lt;img src="../../assets/img/content/chapter2/pointer/2.jpg" alt="pointer" />&lt;/p>
&lt;p>در کد فوق ما یک متغیر به نام count ساختیم که داخل تابع (scope) main می باشد.&lt;/p>
&lt;p>&lt;strong>رخداد اول:&lt;/strong> حال این متغیر را 2 بار بصورت Pointer به تابع &lt;strong>addCount&lt;/strong> پاس دادیم و داخل همان تابع مقدار دهیش کردیم و پس از مقدار دهی در همان تابع print ش کردیم.
اتفاقی که افتاد مقدار متغیر در همان خانه حافظه که &lt;strong>0xc0000a6068&lt;/strong> هست مقدار دهی شد و عملا بخشی دیگر از حافظه گرفته نشد.&lt;/p>
&lt;p>&lt;strong>رخداد دوم:&lt;/strong> متغیر را بدون Pointer به تابع &lt;strong>addCountWithoutPointer&lt;/strong> پاس دادیم و در همان تابع مقدار دهید و print کردیم,
اتفاقی که افتاد ما متغیر را اینبار بدون Pointer پاس دادیم یعنی عملا یک کپی از متغیر را به تابع &lt;strong>addCountWithoutPointer&lt;/strong> فرستادیم و اگر به آدرس حافظه مقدار دقت کنید &lt;strong>0xc0000a6088&lt;/strong> عملا یک خانه جدید به این کپی تخصیص داده شد و مقدارش در همان خانه بروز شده و اون متغیر &lt;strong>x&lt;/strong> تنها در همان تابع زنده اس و در صورتیکه اگر &lt;strong>x&lt;/strong> را از تابع بازگشت دهید دوباره یک کپی از آن به بیرون منتقل می شود.&lt;/p>
&lt;h3 id="مثال-2">
مثال 2
&lt;a class="anchor" href="#%d9%85%d8%ab%d8%a7%d9%84-2">#&lt;/a>
&lt;/h3>
&lt;p>فرض کنید یک تایپ count دارید که &lt;span class="tooltip" data-tooltip="Alias" ontouchend="toggleTooltip(this)">نام مستعار&lt;/span>
تایپ int می باشد و 3 تا متد (متد را در بخش 2.3 می توانید بخوانید) گیرنده Pointer با نام های increase , decrease و print دارند.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
type count int
func main() {
x := new(count)
x.increase()
x.increase()
x.decrease()
x.increase()
x.printWithoutPointer()
}
func (c *count) increase() {
*c++
c.print()
}
func (c *count) decrease() {
*c--
c.print()
}
func (c *count) print() {
fmt.Printf("value = %d, address in memory = %p\n", *c, c)
}
func (c count) printWithoutPointer() {
fmt.Printf("value = %d, address in memory = %p\n", c, &amp;c)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>ما در مثال فوق با استفاده از تابع new اومدیم متغیر x را ایجاد کردیم سپس متد &lt;strong>increase&lt;/strong> برای افزایش مقدار متغیر x و متد &lt;strong>decrease&lt;/strong> را برای کاهش مقدار x و در نهایت print را برای چاپ استفاده کردیم.&lt;/p>
&lt;p>در اینجا به دلیل گیرنده Pointer بودن تایپ &lt;strong>count&lt;/strong> توانستیم درهمان خانه حافظه مقدار x را افزایش یا کاهش دهیم و در نهایت با استفاده از متد print اومدیم مقدار و خانه حافظه را چاپ کردیم.&lt;/p>
&lt;p>اما یک متد &lt;strong>printWithoutPointer&lt;/strong> داریم که یک کپی از مقدار &lt;strong>x&lt;/strong> را چاپ میکند و عملا مقدار را از یک خانه حافظه جدید را به نمایش میگذارد.&lt;/p>
&lt;blockquote class="book-hint info">
متد &lt;strong>printWithoutPointer&lt;/strong> بدون Pointer می باشد و زمانیکه سایر متدهایتان با یا بدون Pointer هست بهتر است متدهای جدیدتان با Pointer باشد تا جلو سردرگمی گرفته شود. طبق داکیومنت های ارائه شده برای Go چندان لزومی ندارد چنین ترکیبی انجام دهید.
&lt;/blockquote>
&lt;h2 id="211-استفاده-از-تابع-new">
2.1.1 استفاده از تابع new
&lt;a class="anchor" href="#211-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-%d8%aa%d8%a7%d8%a8%d8%b9-new">#&lt;/a>
&lt;/h2>
&lt;p>یک &lt;span class="tooltip" data-tooltip="pointer" ontouchend="toggleTooltip(this)">اشاره‌گر&lt;/span>
با استفاده از تابع &lt;code>new&lt;/code> بصورت مثال زیر تعریف شده است:&lt;/p>
&lt;pre>&lt;code class="language-go">a := new(int)
*a = 10
fmt.Println(*a) //Output will be 10
&lt;/code>&lt;/pre>
&lt;p>در مثال بالا ما متغیر a را از نوع int اشاره‌گر &lt;code>pointer a&lt;/code> تعریف کردیم و سپس داخل آدرس حافظه a مقدار ۱۰ را قرار دادیم.&lt;/p>
&lt;blockquote class="book-hint warning">
توجه کنید مقدار پیش‌فرض یک متغیر از نوع &lt;span class="tooltip" data-tooltip="pointer" ontouchend="toggleTooltip(this)">اشاره‌گر&lt;/span>
&lt;code>nil&lt;/code> است. اگر جایی شما متغیر از نوع &lt;span class="tooltip" data-tooltip="pointer" ontouchend="toggleTooltip(this)">اشاره‌گر&lt;/span>
را بصورت &lt;code>nil&lt;/code> بفرستید ممکن است به panic از نوع &lt;strong>nil pointer&lt;/strong> بر بخورید و اجرای برنامه شما کاملا متوقف شود.
&lt;/blockquote>
&lt;h2 id="212-استفاده-از-اپراتور-">
2.1.2 استفاده از اپراتور &amp;lsquo;&amp;amp;&amp;rsquo;
&lt;a class="anchor" href="#212-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-%d8%a7%d9%be%d8%b1%d8%a7%d8%aa%d9%88%d8%b1-">#&lt;/a>
&lt;/h2>
&lt;p>برای دریافت آدرس حافظه یک متغیر از &lt;code>&amp;amp;&lt;/code> می‌توان استفاده کرد:&lt;/p>
&lt;pre>&lt;code class="language-go">a := 2
b := &amp;amp;a
fmt.Println(*b) //Output will be 2
&lt;/code>&lt;/pre>
&lt;p>به مثال زیر توجه کنید:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
var b *int
a := 2
b = &amp;a
fmt.Println(b)
fmt.Println(*b)
b = new(int)
*b = 10
fmt.Println(*b)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در خروجی بالا &lt;code>0xc0000b0018&lt;/code> آدرس حافظه متغیر a است. در واقع متغیر a ساخته شد و ما آدرس حافظه آن را به متغیر b دادیم. یعنی هر دو متغیر به یک آدرس از حافظه اشاره می‌کنند.&lt;/p>
&lt;h2 id="213-اپراتور--اشارهگر">
2.1.3 اپراتور * اشاره‌گر
&lt;a class="anchor" href="#213-%d8%a7%d9%be%d8%b1%d8%a7%d8%aa%d9%88%d8%b1--%d8%a7%d8%b4%d8%a7%d8%b1%d9%87%da%af%d8%b1">#&lt;/a>
&lt;/h2>
&lt;p>ما می‌توانیم اپراتور * را برای عملیات‌های زیر به کار ببریم:&lt;/p>
&lt;ul>
&lt;li>گرفتن مقدار یک آدرس حافظه که با استفاده از اشاره‌گر ذخیره شده است.&lt;/li>
&lt;li>تغییر مقدار یک آدرس حافظه.&lt;/li>
&lt;/ul>
&lt;h3 id="به-مثال-زیر-توجه-کنید">
به مثال زیر توجه کنید:
&lt;a class="anchor" href="#%d8%a8%d9%87-%d9%85%d8%ab%d8%a7%d9%84-%d8%b2%db%8c%d8%b1-%d8%aa%d9%88%d8%ac%d9%87-%da%a9%d9%86%db%8c%d8%af">#&lt;/a>
&lt;/h3>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
a := 2
b := &amp;a
fmt.Println(a)
fmt.Println(*b)
*b = 3
fmt.Println(a)
fmt.Println(*b)
a = 4
fmt.Println(a)
fmt.Println(*b)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در مثال بالا &lt;code>a&lt;/code> و &lt;code>b*&lt;/code> هر دو دارند به یک آدرس از حافظه اشاره می‌کنند. بنابرین تغییر مقدار یکی از آن‌ها، روی هر دو متغیر تاثیر می‌گذارد.&lt;/p>
&lt;h2 id="214-اشارهگر-به-یک-اشارهگر-double-pointers">
2.1.4 اشاره‌گر به یک اشاره‌گر (Double Pointers)
&lt;a class="anchor" href="#214-%d8%a7%d8%b4%d8%a7%d8%b1%d9%87%da%af%d8%b1-%d8%a8%d9%87-%db%8c%da%a9-%d8%a7%d8%b4%d8%a7%d8%b1%d9%87%da%af%d8%b1-double-pointers">#&lt;/a>
&lt;/h2>
&lt;p>شما می‌‌توانید یک متغیر اشاره‌گر تعریف کنید و متغیر اشاره‌گر دیگری را بهش اختصاص دهید.&lt;/p>
&lt;pre>&lt;code class="language-go">a := 2
b := &amp;amp;a
c := &amp;amp;b
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="../../assets/img/content/chapter2/pointer/3.jpg" alt="array" />&lt;/p>
&lt;p>همانطور که در مثال و عکس بالا می‌بینید، متغیر a مقدارش ۲ و آدرسش در حافظه &lt;code>0xXXXXXX&lt;/code> است. در مقدار متغیر b ما اشاره کردیم به آدرس حافظه متغیر a و در ادامه در متغیر c به آدرس حافظه متغیر b اشاره کردیم.&lt;/p>
&lt;p>زمانیکه شما بخواهید مقدار c را چاپ کنید کافیست از &lt;code>c**&lt;/code> استفاده کنید تا مقدار ۲ را چاپ کند.&lt;/p>
&lt;p>به مثال زیر توجه کنید:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
a := 2
b := &amp;a
c := &amp;b
fmt.Printf("a: %d\n", a)
fmt.Printf("b: %x\n", b)
fmt.Printf("c: %x\n", c)
fmt.Println()
fmt.Printf("a: %d\n", a)
fmt.Printf("*&amp;a: %d\n", *&amp;a)
fmt.Printf("*b: %d\n", *b)
fmt.Printf("**c: %d\n", **c)
fmt.Println()
fmt.Printf("&amp;a: %d\n", &amp;a)
fmt.Printf("b: %d\n", b)
fmt.Printf("&amp;*b: %d\n", &amp;*b)
fmt.Printf("*&amp;b: %d\n", *&amp;b)
fmt.Printf("*c: %d\n", *c)
fmt.Println()
fmt.Printf("&amp;b: %d\n", &amp;b)
fmt.Printf("c: %d\n", c)
fmt.Printf("*c: %d\n", *c)
fmt.Printf("**c: %d\n", **c)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;blockquote class="book-hint danger">
&lt;p>توجه کنید در زبان گو علی رغم زبان c استفاده از اشاره‌گر حسابی (Pointer Arithmetic) امکان پذیر نمی‌باشد و در صورت استفاده با خطای زیر مواجه خواهید شد:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
func main() {
a := 1
b := &amp;a
b = b + 1
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;/blockquote></description></item><item><author/><title>2.2 ساختار (struct)</title><link>https://book.gofarsi.ir/chapter-2/struct/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-2/struct/</guid><description>&lt;p>در زبان گو &lt;span class="tooltip" data-tooltip="struct" ontouchend="toggleTooltip(this)">ساختار&lt;/span>
کالکشنی از فیلدها با تایپ‌های مختلف است. شما با استفاده از &lt;span class="tooltip" data-tooltip="struct" ontouchend="toggleTooltip(this)">ساختار&lt;/span>
می‌توانید یک مدل کلی از بدنه پروژه خود را تعریف کنید. برای نمونه ما در مثال زیر یک نمونه از &lt;span class="tooltip" data-tooltip="struct" ontouchend="toggleTooltip(this)">ساختار&lt;/span>
employee &lt;code>کارمند&lt;/code> را مثال زدیم تا شما کمی با مفهوم &lt;span class="tooltip" data-tooltip="struct" ontouchend="toggleTooltip(this)">ساختار&lt;/span>
آشنا شوید.&lt;/p>
&lt;pre>&lt;code class="language-go">type employee struct {
name string
age int
salary int
}
&lt;/code>&lt;/pre>
&lt;blockquote class="book-hint warning">
&lt;p>نکته: ساختار می‌تواند بصورت خالی جهت برخی اهداف ایجاد گردد. به مثال زیر دقت کنید:‌&lt;/p>
&lt;pre>&lt;code class="language-go">type sample struct {}
&lt;/code>&lt;/pre>
&lt;p>اگر می‌خواهید در مورد متودها اطلاعات کسب کنید به بخش &lt;a href="https://book.gofarsi.ir/chapter-2/method/">متدها روی ساختار&lt;/a> سر بزنید، هر چند توصیه می‌کنم اول این قسمت رو بخونید و تمرین کنید و بعد به قسمت متودها بروید.&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>برای ایجاد &lt;span class="tooltip" data-tooltip="struct" ontouchend="toggleTooltip(this)">ساختار&lt;/span>
باید از کلمه کلیدی &lt;code>type&lt;/code> اسم ساختار و در ادامه کلمه کلیدی &lt;code>struct&lt;/code> استفاده کنید.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>سپس داخل بدنه &lt;span class="tooltip" data-tooltip="struct" ontouchend="toggleTooltip(this)">ساختار&lt;/span>
فیلدها را تعریف کنید.&lt;/p>
&lt;ul>
&lt;li>فیلد name از نوع string&lt;/li>
&lt;li>فیلد age از نوع int&lt;/li>
&lt;li>فیلد salary از نوع int&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote class="book-hint info">
&lt;span class="tooltip" data-tooltip="struct" ontouchend="toggleTooltip(this)">ساختار&lt;/span>
را در زبان گو، با class در سایر زبان‌ها مقایسه می‌کنند. هرچند زبان گو یک زبان شی‌گرا محسوب نمی‌شود.
&lt;/blockquote>
&lt;h2 id="221-تعریف-تایپ-struct">
2.2.1 تعریف تایپ struct
&lt;a class="anchor" href="#221-%d8%aa%d8%b9%d8%b1%db%8c%d9%81-%d8%aa%d8%a7%db%8c%d9%be-struct">#&lt;/a>
&lt;/h2>
&lt;p>به مثال زیر توجه کنید:&lt;/p>
&lt;pre>&lt;code class="language-go">type point struct {
x float64
y float64
}
&lt;/code>&lt;/pre>
&lt;p>در مثال بالا ما ۲ تا فیلد برای &lt;span class="tooltip" data-tooltip="struct" ontouchend="toggleTooltip(this)">ساختار&lt;/span>
تعریف کردیم که هر دو فیلد از نوع &lt;code>float64&lt;/code> هستند.&lt;/p>
&lt;h2 id="222-ایجاد-یک-متغیر-ساختار-struct">
2.2.2 ایجاد یک متغیر ساختار (struct)
&lt;a class="anchor" href="#222-%d8%a7%db%8c%d8%ac%d8%a7%d8%af-%db%8c%da%a9-%d9%85%d8%aa%d8%ba%db%8c%d8%b1-%d8%b3%d8%a7%d8%ae%d8%aa%d8%a7%d8%b1-struct">#&lt;/a>
&lt;/h2>
&lt;p>برای ایجاد یک متغیر &lt;span class="tooltip" data-tooltip="struct" ontouchend="toggleTooltip(this)">ساختار&lt;/span>
می‌توانید یک متغیر تعریف کنید و ساختار را به عنوان مقدار به آن بدهید. به مثال زیر توجه کنید:&lt;/p>
&lt;pre>&lt;code class="language-go">emp := employee{}
&lt;/code>&lt;/pre>
&lt;p>در مثال بالا ما یک متغیر با مقدار پیش‌فرض صفر &lt;span class="tooltip" data-tooltip="struct" ontouchend="toggleTooltip(this)">ساختار&lt;/span>
employee تعریف کردیم.&lt;/p>
&lt;blockquote class="book-hint info">
زمانیکه یک متغیر &lt;span class="tooltip" data-tooltip="struct" ontouchend="toggleTooltip(this)">ساختار&lt;/span>
خالی، مانند مثال بالا تعریف می‌کنید مقدار استفاده شده از حافظه &lt;strong>0 بایت&lt;/strong> است.
&lt;/blockquote>
&lt;ul>
&lt;li>ایجاد متغیر ساختار و مقدار دهی فیلدها در یک خط:&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-go">emp := employee{name: &amp;quot;Sam&amp;quot;, age: 31, salary: 2000}
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>ایجاد متغیر ساختار و مقدار دهی فیلد در خط‌های مختلف (این روش برای خوانایی و درک بهتر توصیه می‌شود) :&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-go">emp := employee{
name: &amp;quot;Sam&amp;quot;,
age: 31,
salary: 2000,
}
&lt;/code>&lt;/pre>
&lt;p>توجه کنید هیچ اجباری نیست که حتماً شما باید فیلدی را مقدار دهی کنید، شما می‌توانید هر زمانیکه نیاز داشتید ساختار خودتان رو مقدار دهی کنید.&lt;/p>
&lt;pre>&lt;code class="language-go">emp := employee{
name: &amp;quot;Sam&amp;quot;,
age: 31,
}
&lt;/code>&lt;/pre>
&lt;p>در مثال بالا ما فیلد salary را مقدار دهی نکردیم. کامپایلر بطور پیش‌فرض با توجه به تایپ فیلد، مقدار پیش‌فرض صفر را برای اون تایپ در نظر می‌گیرد.
در ادامه به مثالی که از نحوه ایجاد ساختارها زدیم، توجه کنید:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
type employee struct {
name string
age int
salary int
}
func main() {
emp1 := employee{}
fmt.Printf("Emp1: %+v\n", emp1)
emp2 := employee{name: "Sam", age: 31, salary: 2000}
fmt.Printf("Emp2: %+v\n", emp2)
emp3 := employee{
name: "Sam",
age: 31,
salary: 2000,
}
fmt.Printf("Emp3: %+v\n", emp3)
emp4 := employee{
name: "Sam",
age: 31,
}
fmt.Printf("Emp4: %+v\n", emp4)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;ul>
&lt;li>ایجاد متغیر ساختار و مقدار دهی فیلدها بدون نام فیلد:&lt;/li>
&lt;/ul>
&lt;p>شما می‌توانید فیلدها را بدون اینکه نام فیلد را قرار دهید مقدار دهی کنید اما از نظر تکنیکی این کار توصیه نمی‌شود، دلیل این توصیه هم این است که اگر شما فیلدها رو به این روش مقدار دهی کنید، باید ترتیب رو در نظر بگیرید یعنی &lt;strong>1: باید نام باشد، 2: باید سن باشد، 3: باید درآمد باشد&lt;/strong> و اگر این ترتیب رعایت نشود شما دیتای اشتباهی خواهید داشت.&lt;/p>
&lt;pre>&lt;code class="language-go">emp := employee{&amp;quot;Sam&amp;quot;, 31, 2000}
{Sam 31 2000} // حروجی
&lt;/code>&lt;/pre>
&lt;p>در مثال بالا ترتیب رعایت شده. به مثال زیر توجه کنید:&lt;/p>
&lt;pre>&lt;code class="language-go">emp := employee{&amp;quot;Sam&amp;quot;, 2000, 31}
{Sam 2000 31} // حروجی
&lt;/code>&lt;/pre>
&lt;p>همانطور که در مثال بالا دیدین الان با ترتیب اشتباه سن کارمند و درآمدش جابه جا شدن و ما دیتای اشتباهی از کارمند خواهیم داشت.&lt;/p>
&lt;h2 id="223-دسترسی-و-تنظیم-فیلدهای-ساختار-struct">
2.2.3 دسترسی و تنظیم فیلدهای ساختار (struct)
&lt;a class="anchor" href="#223-%d8%af%d8%b3%d8%aa%d8%b1%d8%b3%db%8c-%d9%88-%d8%aa%d9%86%d8%b8%db%8c%d9%85-%d9%81%db%8c%d9%84%d8%af%d9%87%d8%a7%db%8c-%d8%b3%d8%a7%d8%ae%d8%aa%d8%a7%d8%b1-struct">#&lt;/a>
&lt;/h2>
&lt;p>زمانیکه شما یک متغیر ساختار تعریف می‌کنید، می‌توانید خیلی آسان با استفاده از همان متغیر به فیلدهای ساختار دسترسی پیدا کنید و مقدار هر کدام از فیلدها را تغییر دهید. به مثال زیر توجه کنید:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
type employee struct {
name string
age int
salary int
}
func main() {
emp := employee{name: "Sam", age: 31, salary: 2000}
//Accessing a struct field
fmt.Printf("Current name is: %s\n", emp.name)
//Assigning a new value to name field
emp.name = "John"
fmt.Printf("New name is: %s\n", emp.name)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;h2 id="224-کار-با-اشارهگر-pointer-در-ساختار-struct">
2.2.4 کار با اشاره‌گر (Pointer) در ساختار (struct)
&lt;a class="anchor" href="#224-%da%a9%d8%a7%d8%b1-%d8%a8%d8%a7-%d8%a7%d8%b4%d8%a7%d8%b1%d9%87%da%af%d8%b1-pointer-%d8%af%d8%b1-%d8%b3%d8%a7%d8%ae%d8%aa%d8%a7%d8%b1-struct">#&lt;/a>
&lt;/h2>
&lt;p>شما برای ایجاد یک struct از نوع &lt;span class="tooltip" data-tooltip="Pointer" ontouchend="toggleTooltip(this)">اشاره‌گر&lt;/span>
می‌توانید از دو حالت زیر استفاده کنید:&lt;/p>
&lt;ul>
&lt;li>با استفاده از عملگر &lt;code>&amp;amp;&lt;/code> که اشاره به خانه حافظه دارد&lt;/li>
&lt;li>با استفاده از تابع &lt;code>new&lt;/code>&lt;/li>
&lt;/ul>
&lt;h3 id="2241-ایجاد-ساختار-با-استفاده-از-عملگر-">
2.2.4.1 ایجاد ساختار با استفاده از عملگر &amp;amp;
&lt;a class="anchor" href="#2241-%d8%a7%db%8c%d8%ac%d8%a7%d8%af-%d8%b3%d8%a7%d8%ae%d8%aa%d8%a7%d8%b1-%d8%a8%d8%a7-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-%d8%b9%d9%85%d9%84%da%af%d8%b1-">#&lt;/a>
&lt;/h3>
&lt;p>برای اینکه بتوانید یک ساختار از نوع &lt;span class="tooltip" data-tooltip="Pointer" ontouchend="toggleTooltip(this)">اشاره گر&lt;/span>
ایجاد کنید می‌توانید از عملگر &lt;code>&amp;amp;&lt;/code> استفاده کنید. به مثال زیر توجه کنید:&lt;/p>
&lt;pre>&lt;code class="language-go">emp := employee{name: &amp;quot;Sam&amp;quot;, age: 31, salary: 2000}
empP := &amp;amp;emp
&lt;/code>&lt;/pre>
&lt;p>حتی شما می‌توانید یک ساختار اشاره‌گر را مستقیماً ایجاد کنید &lt;strong>این روش پیشنهاد می‌شود&lt;/strong>. به مثال زیر توجه کنید:&lt;/p>
&lt;pre>&lt;code class="language-go">empP := &amp;amp;employee{name: &amp;quot;Sam&amp;quot;, age: 31, salary: 2000}
&lt;/code>&lt;/pre>
&lt;p>در مثال زیر هر دو روش رو برای شما توضیح دادیم. با دقت به کد و خروجی کد نگاه کنید:‌&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
type employee struct {
name string
age int
salary int
}
func main() {
emp := employee{name: "Sam", age: 31, salary: 2000}
empP := &amp;emp
fmt.Printf("Emp: %+v\n", empP)
empP = &amp;employee{name: "John", age: 30, salary: 3000}
fmt.Printf("Emp: %+v\n", empP)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;h3 id="2242-ایجاد-ساختار-با-استفاده-تابع-new">
2.2.4.2 ایجاد ساختار با استفاده تابع new
&lt;a class="anchor" href="#2242-%d8%a7%db%8c%d8%ac%d8%a7%d8%af-%d8%b3%d8%a7%d8%ae%d8%aa%d8%a7%d8%b1-%d8%a8%d8%a7-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%aa%d8%a7%d8%a8%d8%b9-new">#&lt;/a>
&lt;/h3>
&lt;pre>&lt;code class="language-go">func new(Type) *Type
&lt;/code>&lt;/pre>
&lt;p>همینطور که در تعریف تابع &lt;code>new&lt;/code> هم می‌بینید، این تابع یک تایپ از ما می‌گیرد و مقدار دهی می‌کند، و در آخر هم تایپ را از نوع اشاره‌گر برای ما بر می‌گرداند.&lt;/p>
&lt;p>با استفاده از تابع &lt;code>new &lt;/code>:&lt;/p>
&lt;ul>
&lt;li>شما یک ساختار ایجاد می‌کنید.&lt;/li>
&lt;li>سپس فیلدها، با مقدار پیش‌فرض صفر مقدار دهی اولیه می‌شوند.&lt;/li>
&lt;li>در نهایت ساختار شما از نوع اشاره‌گر بازگشت داده می‌شود.&lt;/li>
&lt;/ul>
&lt;p>به مثال زیر توجه کنید:&lt;/p>
&lt;pre>&lt;code class="language-go">empP := new(employee)
&lt;/code>&lt;/pre>
&lt;p>برای اینکه آدرس خانه حافظه ساختار، از نوع اشاره‌گر را ببینید کافی است با استفاده از &lt;strong>p%&lt;/strong> اون ساختار رو چاپ کنید. به مثال زیر توجه کنید:&lt;/p>
&lt;pre>&lt;code class="language-go">fmt.Printf(&amp;quot;Emp Pointer: %p\n&amp;quot;, empP)
&lt;/code>&lt;/pre>
&lt;p>برای اینکه مقدار کلی فیلدها را ببینید کافی است با استفاده از &lt;strong>v+%&lt;/strong> اون رو چاپ کنید. به مثال زیر توجه کنید:&lt;/p>
&lt;pre>&lt;code class="language-go">fmt.Printf(&amp;quot;Emp Value: %+v\n&amp;quot;, *empP)
&lt;/code>&lt;/pre>
&lt;p>در مثال زیر خروجی آنچه در بالا گفته شد رو قرار دادیم. لطفاً با دقت به مثال زیر نگاه کنید و در آخر هم مثال‌های مشابهی رو برای خودتان بنویسید:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
type employee struct {
name string
age int
salary int
}
func main() {
empP := new(employee)
fmt.Printf("Emp Pointer Address: %p\n", empP)
fmt.Printf("Emp Pointer: %+v\n", empP)
fmt.Printf("Emp Value: %+v\n", *empP)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;h2 id="225-چاپ-یک-متغیر-ساختار-struct">
2.2.5 چاپ یک متغیر ساختار (struct)
&lt;a class="anchor" href="#225-%da%86%d8%a7%d9%be-%db%8c%da%a9-%d9%85%d8%aa%d8%ba%db%8c%d8%b1-%d8%b3%d8%a7%d8%ae%d8%aa%d8%a7%d8%b1-struct">#&lt;/a>
&lt;/h2>
&lt;p>برای اینکه بتوانید یک متغیر ساختار &lt;code>struct&lt;/code> را چاپ کنید، از دو روش زیر می‌توانید استفاده کنید. توجه کنید متغیر ساختار بصورت key/value هست.&lt;/p>
&lt;ul>
&lt;li>با استفاده از پکیج &lt;strong>fmt&lt;/strong>&lt;/li>
&lt;li>با استفاده از پکیج &lt;strong>json/encoding&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h3 id="2251-چاپ-با-استفاده-از-fmt">
2.2.5.1 چاپ با استفاده از fmt
&lt;a class="anchor" href="#2251-%da%86%d8%a7%d9%be-%d8%a8%d8%a7-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-fmt">#&lt;/a>
&lt;/h3>
&lt;p>در پکیج fmt ما 2 تا تابع کاربردی جهت چاپ داریم که اکثر اوقات از این دو تابع استفاده می‌کنیم:&lt;/p>
&lt;ul>
&lt;li>تابع &lt;code>Println&lt;/code> ورودی را با فرمت پیش‌فرض چاپ می‌کند.&lt;/li>
&lt;li>تابع &lt;code>Printf&lt;/code> ورودی را با فرمت مشخص شده چاپ می‌کند &lt;code>فرمت رو خود ما مشخص می‌کنیم&lt;/code>.&lt;/li>
&lt;/ul>
&lt;p>در مثال زیر ما یک نمونه از ساختار employee را ایجاد کردیم:&lt;/p>
&lt;pre>&lt;code class="language-go">emp := employee{name: &amp;quot;Sam&amp;quot;, age: 31, salary: 2000}
&lt;/code>&lt;/pre>
&lt;p>حال با استفاده از تابع &lt;code>Printf&lt;/code> ساختار را با فرمت دلخواه خودمان چاپ کردیم:&lt;/p>
&lt;pre>&lt;code class="language-go">fmt.Printf(&amp;quot;%v&amp;quot;, emp) - {Sam 31 2000}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-go">fmt.Printf(&amp;quot;%+v&amp;quot;, emp) - {name:Sam age:31 salary:2000}
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>%v - مقدار &lt;code>value&lt;/code> هر کدام از فیلدهای ساختار را چاپ می‌کند.&lt;/li>
&lt;li>%+v - مقدار هرکدام از فیلدها به همراه اسم فیلد &lt;code>key-value&lt;/code> را چاپ می‌کند.&lt;/li>
&lt;/ul>
&lt;p>در مثال زیر ما با استفاده از از تابع &lt;code>Println&lt;/code> ساختار را چاپ کردیم:&lt;/p>
&lt;pre>&lt;code class="language-go">fmt.Println(emp) - {Sam 31 2000}
&lt;/code>&lt;/pre>
&lt;p>در نهایت کد زیر یک مثال کلی از چاپ با استفاده از پکیج fmt است‌:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
type employee struct {
name string
age int
salary int
}
func main() {
emp := employee{name: "Sam", age: 31, salary: 2000}
fmt.Printf("Emp: %v\n", emp)
fmt.Printf("Emp: %+v\n", emp)
fmt.Printf("Emp: %#v\n", emp)
fmt.Println(emp)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;h3 id="2252-چاپ-ساختار-با-استفاده-از-پکیج-json">
2.2.5.2 چاپ ساختار با استفاده از پکیج JSON
&lt;a class="anchor" href="#2252-%da%86%d8%a7%d9%be-%d8%b3%d8%a7%d8%ae%d8%aa%d8%a7%d8%b1-%d8%a8%d8%a7-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-%d9%be%da%a9%db%8c%d8%ac-json">#&lt;/a>
&lt;/h3>
&lt;p>در این روش ما با استفاده از ۲ تابع &lt;strong>Marshal&lt;/strong> و &lt;strong>MarshalIndent&lt;/strong> پکیج json، ساختار را encode می‌کنیم و در نهایت خروجی encode شده را چاپ می‌کنیم.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Marshal&lt;/strong> - در این تابع ما به عنوان ورودی‌، ساختار را پاس می‌دهیم و در نهایت ۲ خروجی از نوع بایت و خطا دریافت می‌کنیم.&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-go">Marshal(v interface{}) ([]byte, error)
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>&lt;strong>MarhsalIndent&lt;/strong> - در این تابع ما ۳ تا ورودی به تابع می‌فرستیم, به ترتیب ساختار، پیشوند و indent و در نهایت ۲ خروجی از نوع بایت و خطا دریافت می‌کنیم.&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-go">MarshalIndent(v interface{}, prefix, indent string) ([]byte, error)
&lt;/code>&lt;/pre>
&lt;p>حالا با استفاده از توابع فوق یک کد نمونه مثال می‌زنیم و به شما یاد می‌دیم که چطور از این توابع استفاده کنید. به مثال زیر دقت کنید:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"encoding/json"
"fmt"
"log"
)
type employee struct {
Name string
Age int
salary int
}
func main() {
emp := employee{Name: "Sam", Age: 31, salary: 2000}
//Marshal
empJSON, err := json.Marshal(emp)
if err != nil {
log.Fatalf(err.Error())
}
fmt.Printf("Marshal funnction output %s\n", string(empJSON))
//MarshalIndent
empJSON, err = json.MarshalIndent(emp, "", " ")
if err != nil {
log.Fatalf(err.Error())
}
fmt.Printf("MarshalIndent funnction output %s\n", string(empJSON))
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;blockquote class="book-hint warning">
برای اطلاعات بیشتر در خصوص پکیج json می‌توانید به بخش &lt;a href="https://book.gofarsi.ir/chapter-4/work-with-json-file-in-go/">آموزش کار با json&lt;/a> مراجعه کنید.
&lt;/blockquote>
&lt;h2 id="226-کار-با-تگ-ها-در-ساختار-struct">
2.2.6 کار با تگ ها در ساختار (struct)
&lt;a class="anchor" href="#226-%da%a9%d8%a7%d8%b1-%d8%a8%d8%a7-%d8%aa%da%af-%d9%87%d8%a7-%d8%af%d8%b1-%d8%b3%d8%a7%d8%ae%d8%aa%d8%a7%d8%b1-struct">#&lt;/a>
&lt;/h2>
&lt;p>ساختار زبان گو، به شما امکان اضافه کردن metadata به هر یک از فیلدها را می‌دهد و ما این قابلیت را به عنوان تگ می‌شناسیم. تگ‌ها برای انجام یکسری عملیات خاص نظیر encode/decode، اعتبارسنجی مقادیر فیلدها و &amp;hellip; به ما کمک می‌کند و یکی از کاربردی‌ترین عناوین در ساختار هستند.&lt;/p>
&lt;p>به مثال های زیر توجه کنید تا کارکرد تگ ها را متوجه شوید:&lt;/p>
&lt;pre>&lt;code class="language-go">type strutName struct{
fieldName type `key:&amp;quot;value&amp;quot; key2:&amp;quot;value2&amp;quot;`
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-go">type employee struct {
Name string
Age int
Salary int
}
&lt;/code>&lt;/pre>
&lt;p>در این مثال، مقدار داخل متغیری که از نوع Employee است را تبدیل به json می کنیم و چاپ می کنیم.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"encoding/json"
"fmt"
"log"
)
type employee struct {
Name string
Age int
Salary int
}
func main() {
emp := employee{Name: "Sam", Age: 31, Salary: 2000}
//Converting to jsonn
empJSON, err := json.MarshalIndent(emp, "", " ")
if err != nil {
log.Fatalf(err.Error())
}
fmt.Println(string(empJSON))
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>حالا به ما می گویند که اول اسم فیلد ها در خروجی json با حرف بزرگ شروع نشود و حرف کوچک باشد. اولین چیزی که شاید به ذهن شما خطور کند این است که اسم فیلد ها را در ساختار تعریف شده با حروف کوچک شروع کنیم:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"encoding/json"
"fmt"
"log"
)
type employee struct {
name string
age int
salary int
}
func main() {
emp := employee{name: "Sam", age: 31, salary: 2000}
//Converting to jsonn
empJSON, err := json.MarshalIndent(emp, "", " ")
if err != nil {
log.Fatalf(err.Error())
}
fmt.Println(string(empJSON))
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>اما خروجی ما یک json خالی است. جرا؟ چون زمانی که اسم فیلد‌ ها با حروف کوچک شروع شوند private هستند و از بیرون قابل دسترسی نیستند. به همین دلیل خروجی یک json خالی است.&lt;/p>
&lt;p>برای حل این مشکل ما برای ساختار خودمان یک تگ json اضافه می کنیم و می گوییم اسم فیلد تو در json چیز دیگری است:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"encoding/json"
"fmt"
"log"
)
type employee struct {
Name string `json:"name"`
Age int `json:"age"`
Salary int `json:"salary"`
}
func main() {
emp := employee{Name: "Sam", Age: 31, Salary: 2000}
//Converting to jsonn
empJSON, err := json.MarshalIndent(emp, "", " ")
if err != nil {
log.Fatalf(err.Error())
}
fmt.Println(string(empJSON))
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>فکر می‌کنم خروجی بالا کاملاً برای ما روشن کرد که دقیقاً اون تگ‌هایی که قرار دادیم، برای ما چه کاری انجام دادند. بله &lt;strong>کلید-key&lt;/strong>‌های ما را به اون نام‌هایی که در تگ‌ها نوشته بودیم تغییر دادند.&lt;/p>
&lt;h2 id="2261-چند-نمونه-از-کاربرد-تگ-ها">
2.2.6.1 چند نمونه از کاربرد تگ ها
&lt;a class="anchor" href="#2261-%da%86%d9%86%d8%af-%d9%86%d9%85%d9%88%d9%86%d9%87-%d8%a7%d8%b2-%da%a9%d8%a7%d8%b1%d8%a8%d8%b1%d8%af-%d8%aa%da%af-%d9%87%d8%a7">#&lt;/a>
&lt;/h2>
&lt;p>تگ ها کاربرد های خیلی زیادی دارند که در بخش قرار است بعضی از آنها را بررسی کنیم.&lt;/p>
&lt;p>می توانید با تگ (-) مشخص کنید که آن فیلد موقع سریالایز نادیده گرفته شود و نمایش داده نشود. مثال:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"encoding/json"
"fmt"
"log"
)
type employee struct {
Name string `json:"name"`
Age int `json:"-"`
Salary int `json:"salary"`
}
func main() {
emp := employee{Name: "Sam", Salary: 2000}
//Converting to jsonn
empJSON, err := json.MarshalIndent(emp, "", " ")
if err != nil {
log.Fatalf(err.Error())
}
fmt.Println(string(empJSON))
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>با استفاده از تگ omitempty اگر آن فیلد مقداری نداشته باشد، نمایش داده نمی شود:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"encoding/json"
"fmt"
"log"
)
type employee struct {
Name string `json:"name,omitempty"`
Age int `json:"age,omitempty"`
Salary int `json:"salary,omitempty"`
}
func main() {
emp := employee{Age: 22, Salary: 2000}
//Converting to jsonn
empJSON, err := json.MarshalIndent(emp, "", " ")
if err != nil {
log.Fatalf(err.Error())
}
fmt.Println(string(empJSON))
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>از دیگر کاربرد های تگ ها می توان به عملیات اعتبار سنجی اشاره کرد. برای مثال می توان چک کرد فیلد شماره موبایل از یازده رقم بیشتر و کمتر نباشد. همچنین در تعریف مدل های دیتابیس با استفاده از تگ ها ارتباط بین دیتابیس و مدل را می توانیم پیاده سازی کنیم و &amp;hellip;&lt;/p>
&lt;h2 id="227-تعریف-فیلد-ناشناس-در-ساختار-struct">
2.2.7 تعریف فیلد ناشناس در ساختار (struct)
&lt;a class="anchor" href="#227-%d8%aa%d8%b9%d8%b1%db%8c%d9%81-%d9%81%db%8c%d9%84%d8%af-%d9%86%d8%a7%d8%b4%d9%86%d8%a7%d8%b3-%d8%af%d8%b1-%d8%b3%d8%a7%d8%ae%d8%aa%d8%a7%d8%b1-struct">#&lt;/a>
&lt;/h2>
&lt;p>شما در ساختار &lt;code>struct&lt;/code> امکان تعریف فیلدهای &lt;span class="tooltip" data-tooltip="anonymous" ontouchend="toggleTooltip(this)">ناشناس&lt;/span>
را دارید و همینطور می‌توانید فیلدهای ناشناس را نیز مقدار دهی کنید.&lt;/p>
&lt;pre>&lt;code class="language-go">type employee struct {
string
age int
salary int
}
&lt;/code>&lt;/pre>
&lt;p>در کد زیر یک مثال ساده در خصوص تعریف و مقدار دهی فیلدهای ناشناس زده‌ایم:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
type employee struct {
string
age int
salary int
}
func main() {
emp := employee{string: "Sam", age: 31, salary: 2000}
//Accessing a struct field
n := emp.string
fmt.Printf("Current name is: %s\n", n)
//Assigning a new value
emp.string = "John"
fmt.Printf("New name is: %s\n", emp.string)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>توجه داشته باشید زمانی که از فیلد های ناشناس استفاده می کنید، از هر دیتاتایپ فقط یکبار می توانید استفاده کنید:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"fmt"
)
type employee struct {
string // name
int // age
int // salary
}
func main() {
emp := employee{"alireza", 22, 10_000_000}
fmt.Printf("%+v", emp)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;h2 id="228-تعریف-ساختار-تو-در-تو-nested">
2.2.8 تعریف ساختار تو در تو (nested)
&lt;a class="anchor" href="#228-%d8%aa%d8%b9%d8%b1%db%8c%d9%81-%d8%b3%d8%a7%d8%ae%d8%aa%d8%a7%d8%b1-%d8%aa%d9%88-%d8%af%d8%b1-%d8%aa%d9%88-nested">#&lt;/a>
&lt;/h2>
&lt;p>یکی دیگر از امکانات ساختار در زبان گو بحث ساختار &lt;span class="tooltip" data-tooltip="nested" ontouchend="toggleTooltip(this)">تو در تو&lt;/span>
است. در مثالی که در ادامه زدیم ساختار address را داخل employee قرار دادیم:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
type employee struct {
name string
age int
salary int
address address
}
type address struct {
city string
country string
}
func main() {
address := address{city: "London", country: "UK"}
emp := employee{name: "Sam", age: 31, salary: 2000, address: address}
fmt.Printf("City: %s\n", emp.address.city)
fmt.Printf("Country: %s\n", emp.address.country)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;blockquote class="book-hint warning">
&lt;p>توجه کنید شما طبق روش زیر می‌توانید به فیلدهای تو در تو دسترسی داشته باشید:&lt;/p>
&lt;pre>&lt;code class="language-go">emp.address.city
emp.address.country
&lt;/code>&lt;/pre>
&lt;/blockquote>
&lt;p>بعضی مواقع بهتر است بصورت مستقیم به فیلد های درون ساختار تو‌در‌تو دسترسی داشته باشیم. به مثال زیر دقت کنید:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
type Product struct {
Name string
Price int
}
type Mobile struct {
Product Product
Ram int
SimCount int
}
func main() {
var mobile Mobile = Mobile{}
mobile.Product.Name = "Iphone 11"
mobile.Product.Price = 1000
mobile.Ram = 8
mobile.SimCount = 1
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>همانطور که می بینید برای تعریف اسم موبایل باید بگوییم mobile.Product.Name که این زیاد جالب نیست. پس به این صورت ساختار Product را درون موبایل قرار می دهیم:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
type Product struct {
Name string
Price int
}
type Mobile struct {
Product
Ram int
SimCount int
}
func main() {
var mobile Mobile = Mobile{}
mobile.Name = "Iphone 11"
mobile.Price = 1000
mobile.Ram = 8
mobile.SimCount = 1
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>الان بصورت مستقیم می توانیم به فیلد های درون Product دسترسی داشته باشیم.&lt;/p>
&lt;h2 id="229-تعریف-یک-ساختار-عمومی-یا-خصوصی-publicprivate">
2.2.9 تعریف یک ساختار عمومی یا خصوصی (Public/Private)
&lt;a class="anchor" href="#229-%d8%aa%d8%b9%d8%b1%db%8c%d9%81-%db%8c%da%a9-%d8%b3%d8%a7%d8%ae%d8%aa%d8%a7%d8%b1-%d8%b9%d9%85%d9%88%d9%85%db%8c-%db%8c%d8%a7-%d8%ae%d8%b5%d9%88%d8%b5%db%8c-publicprivate">#&lt;/a>
&lt;/h2>
&lt;p>در زبان گو، چیزی به عنوان کلمه کلیدی public یا private جهت تعیین وضعیت دسترسی &lt;code>struct&lt;/code> به بیرون وجود ندارد، در عوض کامپایلر گو بر اساس حرف بزرگ یا کوچک عنوان ساختار یا سایر تایپ‌ها، تشخیص می‌دهد تایپ شما عمومی است یا خصوصی. در صورتیکه شما حرف اول را کوچک قرار دهید تایپ شما بیرون از پکیج قابل دسترس نخواهد بود مثل مثال‌های بالا و اگر حرف اول تایپ رو بزرگ قرار دهید، تایپ یا تابع شما بیرون از پکیج نیز در دسترس خواهد بود. مثال تابع &lt;code>fmt.Println&lt;/code>.&lt;/p>
&lt;pre>&lt;code class="language-go">type Person struct {
Name string
age int
}
type company struct {
Name string
}
&lt;/code>&lt;/pre>
&lt;blockquote class="book-hint warning">
برای اطلاعات بیشتر بهتر است به بخش &lt;a href="https://book.gofarsi.ir/chapter-4/oop/go-encapsulation/">کپسوله سازی&lt;/a> مراجعه کنید.
&lt;/blockquote>
&lt;h2 id="2210-مقایسه-ساختارها">
2.2.10 مقایسه ساختارها
&lt;a class="anchor" href="#2210-%d9%85%d9%82%d8%a7%db%8c%d8%b3%d9%87-%d8%b3%d8%a7%d8%ae%d8%aa%d8%a7%d8%b1%d9%87%d8%a7">#&lt;/a>
&lt;/h2>
&lt;p>شما در زبان گو می‌توانید ساختارها را بر اساس عنوان فیلد، تایپ و مقدارشان مقایسه کنید. اما باید توجه کنید ساختارها فقط براساس تایپ‌هایی که در ادامه معرفی کردیم, امکان مقایسه را خواهند داشت:&lt;/p>
&lt;ul>
&lt;li>boolean&lt;/li>
&lt;li>numeric&lt;/li>
&lt;li>string&lt;/li>
&lt;li>pointer&lt;/li>
&lt;li>channel&lt;/li>
&lt;li>interface types&lt;/li>
&lt;li>structs&lt;/li>
&lt;li>array&lt;/li>
&lt;/ul>
&lt;p>و اما ۳ تایپ زیر امکان مقایسه را به شما نمی‌دهند:&lt;/p>
&lt;ul>
&lt;li>Slice&lt;/li>
&lt;li>Map&lt;/li>
&lt;li>Function&lt;/li>
&lt;/ul>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
type employee struct {
name string
age int
salary int
}
func main() {
emp1 := employee{name: "Sam", age: 31, salary: 2000}
emp2 := employee{name: "Sam", age: 31, salary: 2000}
if emp1 == emp2 {
fmt.Println("emp1 annd emp2 are equal")
} else {
fmt.Println("emp1 annd emp2 are not equal")
}
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div></description></item><item><author/><title>2.3 متد (Method)</title><link>https://book.gofarsi.ir/chapter-2/method/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-2/method/</guid><description>&lt;p>متد در واقع یک تابع گیرنده (receiver) است که به واسطه یک تایپ در دسترس خواهد بود. توجه کنید برای تعریف متد باید قبل از اسم تابع، داخل پرانتز یک نام و یک تایپ قرار دهید. برای درک بهتر این موضوع فکر کنید نامی که داخل پرانتز قرار می‌دید یه متغیر هست که به تایپ شما اشاره می‌کند. به مثال زیر توجه کنید:&lt;/p>
&lt;pre>&lt;code class="language-go">func (receiver receiver_type) some_func_name(arguments) return_values
&lt;/code>&lt;/pre>
&lt;p>برای درک بهتر این مفهوم، می‌توانید متد را دقیقاً یک تابع در نظر بگیرید. نحوه تعریف به صورت متد صرفاً برای راحتی در زمان توسعه نرم افزار است و به برنامه‌نویس امکان توسعه بهتر بدون نیاز به حفظ کردن زیاد عملکرد‌های سیستم را می‌دهد.&lt;/p>
&lt;pre>&lt;code class="language-go">func (r receiver_T) some_func_name(arg1 arg1_T, ...) return_values
func some_func_name(r receiver_T, arg1 arg1_T, ...) return_values
&lt;/code>&lt;/pre>
&lt;p>نکته قابل ذکر دیگر در خصوص این مفهوم این است که متد در زبان گو از رویکرد static method به صورت مستقیم پشتیبانی نمی‌‌کند، یعنی تا زمانیکه شما یک متغیر از نوع تایپی که دارای متد است را راه اندازی نکنید، به متدهایش دسترسی نخواهید داشت.&lt;/p>
&lt;p>اکثراً متد را یکی از عناوین شی‌گرایی در زبان گو می‌شناسند که مزایای خوبی دارد، بخصوص اگر متدها برای تایپ struct تعریف شوند شما می‌توانید برای هر یک از فیلدهای ساختار، توابع بخصوصی در قالب متد بنویسید، ولی اگر بخوایم کمی دقیق‌تر بگیم مفهوم متد برگرفته از الگوی &lt;a href="https://en.wikipedia.org/wiki/Encapsulation_%28computer_programming%29">Encapsulation&lt;/a> است که بر خلاف تصور رایج صرفاً محدود به رویکرد OOP نیست و یک الگوی پذیرفته شده حتی در زبان‌های &lt;strong>Functional programming languages&lt;/strong> نیز است.&lt;/p>
&lt;h2 id="231-متدها-برای-ساختار-struct">
2.3.1 متدها برای ساختار (struct)
&lt;a class="anchor" href="#231-%d9%85%d8%aa%d8%af%d9%87%d8%a7-%d8%a8%d8%b1%d8%a7%db%8c-%d8%b3%d8%a7%d8%ae%d8%aa%d8%a7%d8%b1-struct">#&lt;/a>
&lt;/h2>
&lt;p>زبان گو یک زبان شی گرا نیست ولی برخی از مفاهیم شی‌گرایی را بصورت قرار دادی دارد. ساختار در زبان گو یک تایپ است که این تایپ نیز کالکشنی از تایپ‌های مختلف را در بر می‌گیرد که ما در بخش قبلی بهش پرداختیم.&lt;/p>
&lt;p>به مثالی که در مورد پیاده‌سازی متد‌ها زده‌ایم توجه کنید:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
type employee struct {
name string
age int
salary int
}
func (e employee) details() {
fmt.Printf("Name: %s\n", e.name)
fmt.Printf("Age: %d\n", e.age)
}
func (e employee) getSalary() int {
return e.salary
}
func main() {
emp := employee{name: "Sam", age: 31, salary: 2000}
emp.details()
fmt.Printf("Salary %d\n", emp.getSalary())
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در کد بالا ما یک ساختار با نام employee ایجاد کردیم و سپس ۲ متد با نام‌های details و getSalary برای آن تعریف کردیم. حال برای اینکه بتوانیم از این متدها استفاده کنیم داخل تابع main، یک متغیر از نوع employee تعریف کردیم و سپس با استفاده از نقطه &lt;code>.&lt;/code> پس از نام متغیر به متدها دسترسی پیدا کردیم همانند دسترسی به فیلدهای ساختار.&lt;/p>
&lt;p>&lt;strong>آیا با استفاده از متد می‌توانیم مقدار یکی از فیلدهای داخل ساختار را تغییر دهیم ؟&lt;/strong> این سوال ۲ جواب دارد هم بله و هم خیر&lt;/p>
&lt;p>حال به مثال زیر توجه کنید تا توضیح دهیم:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
type employee struct {
name string
age int
salary int
}
func (e employee) setNewName(newName string) {
e.name = newName
}
func main() {
emp := employee{name: "Sam", age: 31, salary: 2000}
emp.setNewName("John")
fmt.Printf("Name: %s\n", emp.name)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;ul>
&lt;li>&lt;strong>علت اینکه می‌گوییم خیر :&lt;/strong> به خاطر اینکه ما داریم با یک کپی از فیلدهای ساختار کار می‌کنیم و با تغییر مقدار هر یک از فیلدها تغییر بر روی کپی آن اعمال خواهد شد.&lt;/li>
&lt;li>&lt;strong>اما علت اینکه می‌گوییم بله :&lt;/strong> اگر ما با استفاده از اشاره‌گر &lt;strong>pointer&lt;/strong> به فیلدهای داخل ساختار دسترسی پیدا کنیم می‌توانیم مستقیماً به داخل خانه حافظه تایپ دسترسی داشته باشیم و مقدار فیلد مورد نظر را در هر جایی از پروژه تغییر دهیم.&lt;/li>
&lt;/ul>
&lt;h2 id="232-استفاده-از-اشارهگر-pointer-در-متدها">
2.3.2 استفاده از اشاره‌گر (pointer) در متدها
&lt;a class="anchor" href="#232-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-%d8%a7%d8%b4%d8%a7%d8%b1%d9%87%da%af%d8%b1-pointer-%d8%af%d8%b1-%d9%85%d8%aa%d8%af%d9%87%d8%a7">#&lt;/a>
&lt;/h2>
&lt;p>در مثال بالا ما به این اشاره کردیم که آیا می‌شود مقدار هر یک از فیلدهای ساختار را با استفاده از متد تغییر داد یا خیر و در پاسخ گفتیم هم می شود و هم نه. سپس علتش را توضیح دادیم. حال می‌خواهیم با یک مثال این مورد را توضیح دهیم چگونه می نوانیم هر یک از فیلد های ساختار را از طریق متد تغییر دهیم. به مثال زیر توجه کنید:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
type employee struct {
name string
age int
salary int
}
func (e *employee) setNewName(newName string) {
e.name = newName
}
func main() {
emp := &amp;employee{name: "Sam", age: 31, salary: 2000}
emp.setNewName("John")
fmt.Printf("Name: %s\n", emp.name)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در مثال بالا متد setNewName یک نوع متد گیرنده از نوع اشاره‌گر است که ما داخل این متد به مقدار فیلدهای داخل خانه حافظه ساختار employee دسترسی داریم و می‌توانیم آن‌ها را مقدار دهی کنیم.&lt;/p>
&lt;p>&lt;strong>آیا استفاده از گیرنده اشاره‌گر واقعا ضروری است؟&lt;/strong> خیر، ضروری نیست زیرا ما وقتی به متدها دسترسی داریم که یک نمونه (instance) از تایپ مورد نظر ایجاد کنیم تا به متدهایش دسترسی داشته باشیم و همچنین اگر فرضاً نیاز داشته باشیم که یکی از فیلدهای ساختار را مقدار دهی کنیم، باز هم می‌توانیم به آدرس خانه متغیری که ساختار را نگه داری می‌کند اشاره کنیم و مقدارش را تغییر دهیم. به مثال زیر توجه کنید:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
type employee struct {
name string
age int
salary int
}
func (e *employee) setNewName(newName string) {
e.name = newName
}
func main() {
emp := employee{name: "Sam", age: 31, salary: 2000}
emp.setNewName("John")
fmt.Printf("Name: %s\n", emp.name)
(&amp;emp).setNewName("Mike")
fmt.Printf("Name: %s\n", emp.name)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;h3 id="2321-چه-موقع-باید-از-گیرنده-اشارهگر-برای-متد-استفاده-کنیم">
2.3.2.1 چه موقع باید از گیرنده اشاره‌گر برای متد استفاده کنیم؟
&lt;a class="anchor" href="#2321-%da%86%d9%87-%d9%85%d9%88%d9%82%d8%b9-%d8%a8%d8%a7%db%8c%d8%af-%d8%a7%d8%b2-%da%af%db%8c%d8%b1%d9%86%d8%af%d9%87-%d8%a7%d8%b4%d8%a7%d8%b1%d9%87%da%af%d8%b1-%d8%a8%d8%b1%d8%a7%db%8c-%d9%85%d8%aa%d8%af-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%da%a9%d9%86%db%8c%d9%85">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>زمانیکه قصد داریم متدهایی بنویسیم که برروی مقدار فیلدهای ساختار در زمان اجرا تغییراتی انجام میدهند.&lt;/li>
&lt;li>زمانیکه ساختار خیلی بزرگ است و فیلدهای زیادی دارد. در این سناریو بهتر است از گیرنده اشاره‌گر استفاده کنیم تا هر بار با یکی کپی از ساختار مواجه نشویم.&lt;/li>
&lt;/ul>
&lt;h2 id="234-تعریف-متد-برای-فیلدهای-ساختار-تو-در-تو-nested">
2.3.4 تعریف متد برای فیلدهای ساختار تو در تو (nested)
&lt;a class="anchor" href="#234-%d8%aa%d8%b9%d8%b1%db%8c%d9%81-%d9%85%d8%aa%d8%af-%d8%a8%d8%b1%d8%a7%db%8c-%d9%81%db%8c%d9%84%d8%af%d9%87%d8%a7%db%8c-%d8%b3%d8%a7%d8%ae%d8%aa%d8%a7%d8%b1-%d8%aa%d9%88-%d8%af%d8%b1-%d8%aa%d9%88-nested">#&lt;/a>
&lt;/h2>
&lt;p>شما می‌توانید برای فیلدهایی که ساختار تو در تو دارند نیز متد بنویسید. به مثال زیر توجه کنید:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
type employee struct {
name string
age int
salary int
address address
}
type address struct {
city string
country string
}
func (a address) details() {
fmt.Printf("City: %s\n", a.city)
fmt.Printf("Country: %s\n", a.country)
}
func main() {
address := address{city: "London", country: "UK"}
emp := employee{name: "Sam", age: 31, salary: 2000, address: address}
emp.address.details()
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در مثال بالا ما یک متد برای ساختار address تعریف کردیم و سپس ساختار address را داخل ساختار employee گذاشتیم. در نهایت شما با استفاده از employee می‌توانید به متدهای address هم دسترسی داشته باشید و از آن‌ها استفاده کنید.&lt;/p></description></item><item><author/><title>2.4 اینترفیس (Interface)</title><link>https://book.gofarsi.ir/chapter-2/interface/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-2/interface/</guid><description>&lt;p>اینترفیس در زبان گو مجموعه‌ای از متدها است. این مجموعه متدها با توجه به ورودی و خروجی که دارند دارای رفتارهای خاصی هستند. زمانیکه شما یک اینترفیس به همراه یکسری از متدها تعریف می‌کنید باید در جایی این متدها را پیاده سازی کنید.&lt;/p>
&lt;p>اینترفیس‌ها به شما اجازه می‌دهد تا از &lt;a href="https://fa.wikipedia.org/wiki/%D9%86%D9%88%D8%B9%E2%80%8C%D8%AF%D9%87%DB%8C_%D8%A7%D8%B1%D8%AF%DA%A9%DB%8C">Duck typing&lt;/a> استفاده کنید. حالا این duck typing چیست؟&lt;/p>
&lt;p>duck typing روشی در برنامه‌نویسی کامپیوتری است که به شما امکان می‌دهد تست اردک را انجام دهید، جایی که ما نوع را بررسی نمی‌کنیم، بلکه تنها وجود برخی ویژگی‌ها یا روش‌ها را بررسی می‌کنیم. بنابراین آنچه واقعاً اهمیت دارد این است که آیا یک شی دارای ویژگی‌ها و روش‌های خاصی است و نه نوع آن.&lt;/p>
&lt;p>برگردیم به بحث اینترفیس, در زیر ما یک نمونه اینترفیس را قرار دادیم:&lt;/p>
&lt;pre>&lt;code class="language-go">type name_of_interface interface{
//Method signature 1
//Method signature 2
}
&lt;/code>&lt;/pre>
&lt;p>برای درک بهتر مفهوم ارائه شده، بیایید از یک مثال ساده استفاده کنیم. فرض کنید ما یک شی به نام «animal» داریم که شامل یکسری رفتارها است، مانند نفس کشیدن و راه رفتن. این رفتارها باید به یک حیوان خاص اختصاص یابند تا بتوانیم ویژگی‌ها و رفتارهای دقیق آن حیوان را مشخص و تعریف کنیم.&lt;/p>
&lt;pre>&lt;code class="language-go">type animal interface {
breathe()
walk()
}
&lt;/code>&lt;/pre>
&lt;p>در بالا ما یک اینترفیس تعریف کردیم ۲ تا متد دارد حالا بیاید یک متغیر از نوع اینترفیس animal درست کنیم و چاپ کنیم.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
type animal interface {
breathe()
walk()
}
func main() {
var a animal
fmt.Println(a)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در بالا وقتی اینترفیس را چاپ کردیم، خروجی &lt;code>nil&lt;/code> بود.
توجه کنید اینترفیس مقدار پیش‌فرض یا خالی بودنش &lt;code>nil&lt;/code> هست.&lt;/p>
&lt;h2 id="241-پیادهسازی-اینترفیس">
2.4.1 پیاده‌سازی اینترفیس
&lt;a class="anchor" href="#241-%d9%be%db%8c%d8%a7%d8%af%d9%87%d8%b3%d8%a7%d8%b2%db%8c-%d8%a7%db%8c%d9%86%d8%aa%d8%b1%d9%81%db%8c%d8%b3">#&lt;/a>
&lt;/h2>
&lt;p>در بالا ما یک اینترفیس animal تعریف کردیم که ۲ متد داشت حالا قصد داریم یک شی (منظور ساختار در گو) به نام lion تعریف کنیم و متدهای اینترفیس animal را پیاده‌سازی کنیم.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
type animal interface {
breathe()
walk()
}
type lion struct {
age int
}
func (l lion) breathe() {
fmt.Println("Lion breathes")
}
func (l lion) walk() {
fmt.Println("Lion walk")
}
func main() {
var a animal
a = lion{age: 10}
a.breathe()
a.walk()
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در بالا ما یک متغیر با تایپ animal تعریف کردیم:&lt;/p>
&lt;pre>&lt;code class="language-go">var a animal
&lt;/code>&lt;/pre>
&lt;p>سپس ما یک نمونه از ساختار lion را بهش اختصاص دادیم:&lt;/p>
&lt;pre>&lt;code class="language-go">a = lion{}
&lt;/code>&lt;/pre>
&lt;p>اختصاص یک نمونه از ساختار lion به متغیر a که با تایپ lion بود موفقیت آمیز بود زیرا ما برای lion متدهای مربوط به animal را که breathe و walk بود، پیاده سازی کردیم. این مفهوم کاملاً شبیه به ducking typing هست که در بالا گفتیم. یک شیر می‌تواند نفس بکشد و راه برود از این رو او یک حیوان است.&lt;/p>
&lt;blockquote class="book-hint info">
&lt;p>توجه کنید اگر شما متد جدیدی را اضافه یا کم کنید و همچنین اگر تغییر ایجاد کنید باید این تغییرات بر روی اشیایی که با اینترفیس شما در ارتباط هستند صورت بگیرید.&lt;/p>
&lt;p>به عنوان مثال شما اگر به اینترفیس animal یک متد جدیدی اضافه کنید حتما باید برای ساختار lion هم پیاده سازی کنید.&lt;/p>
&lt;/blockquote>
&lt;h2 id="242-اینترفیسها-بطور-ضمنی-implicitly-پیاده-سازی-میشود">
2.4.2 اینترفیس‌ها بطور ضمنی (implicitly) پیاده سازی می‌شود
&lt;a class="anchor" href="#242-%d8%a7%db%8c%d9%86%d8%aa%d8%b1%d9%81%db%8c%d8%b3%d9%87%d8%a7-%d8%a8%d8%b7%d9%88%d8%b1-%d8%b6%d9%85%d9%86%db%8c-implicitly-%d9%be%db%8c%d8%a7%d8%af%d9%87-%d8%b3%d8%a7%d8%b2%db%8c-%d9%85%db%8c%d8%b4%d9%88%d8%af">#&lt;/a>
&lt;/h2>
&lt;p>برای اینترفیس هیچ حالت صریح (explicit) هنگام تعریف وجود ندارد و همه چی بصورت ضمنی است تا زمانیکه یک اینترفیس برای یک شی (ساختار) متدهایش پیاده سازی نشود هیچ کاربردی نخواهد داشت.&lt;/p>
&lt;p>توجه کنید هیچ حالت صریحی وجود ندارد که بگوید شما تمامی متدهای اینترفیس animal را برای ساختار lion پیاده سازی کردید یا خیر و فقط در زمان کامپایل اگر ایرادی وجود داشته باشد کامپایلر به شما خطا می‌دهد و البته IDE هایی مانند: Goland , Vscode به شما هنگام نوشتن کد در خصوص این مورد کمک می‌کنند قبل از کامپایل متوجه خطاهای مرتبط با پیاده سازی اینترفیس شوید.&lt;/p>
&lt;p>خب بزارید یک مثال پیچیده برای اینترفیس animal بزنیم و یک شی (ساختار) دیگر به نام dog اضافه کنیم و متدهای اینترفیس animal را برای این شی پیاده سازی کنیم.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
type animal interface {
breathe()
walk()
}
type lion struct {
age int
}
func (l lion) breathe() {
fmt.Println("Lion breathes")
}
func (l lion) walk() {
fmt.Println("Lion walk")
}
type dog struct {
age int
}
func (l dog) breathe() {
fmt.Println("Dog breathes")
}
func (l dog) walk() {
fmt.Println("Dog walk")
}
func main() {
var a animal
a = lion{age: 10}
a.breathe()
a.walk()
a = dog{age: 5}
a.breathe()
a.walk()
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در مثال بالا ما یک ساختار با نام dog تعریف کردیم و سپس متدهای animal را برای ساختار dog پیاده سازی کردیم و در نهایت ساختار dog را به متغیر اینترفیس a اختصاص دادیم. همانطور که می‌بینیم dog هم همانند lion نفس می‌کشد و راه می‌رود.&lt;/p>
&lt;blockquote class="book-hint info">
توجه کنید در بالا ما برای ۲ تا شی lion و dog یک وجه مشترک به نام animal به همراه رفتار مشترک تعریف کردیم که به اینکار پلی مورفیسم می‌گویند و یکی از عناوین پر کاربرد در شی‌گرایی می باشد که در &lt;a href="https://book.gofarsi.ir/chapter-4/oop/go-polymorphism/">بخش شی گرایی زبان گو&lt;/a> بیشتر می‌پردازیم.
&lt;/blockquote>
&lt;p>&lt;strong>دو نکته مهم در خصوص اینترفیس‌:&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>اینترفیس‌ها فقط زمان کامپایل مشخص می‌شود که برای اشیا به درستی پیاده سازی شده‌اند یا خیر و اگر فرضاً ما برای ساختار lion در کد بالا متد walk را حذف کنیم با خطای زیر رو به رو خواهیم شد:&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-go">cannot use lion literal (type lion) as type animal in assignment:
&lt;/code>&lt;/pre>
&lt;ol start="2">
&lt;li>ورود و خروجی‌های هر متدی که پیاده سازی می‌کنید برای اشیا (ساختارها) بستگی به تعریف ضمنی متد داخل اینترفیس دارد و اگر شما متدی را داخل اینترفیس تغییر دهید حتما باید آن متد در اشیایی که قبلا پیاده سازی شده تغییر یابد.&lt;/li>
&lt;/ol>
&lt;p>حالا فرض کنید ما برای اینترفیس animal یک متد جدیدی به نام speed تعریف کردیم که این متد به عنوان خروجی مقداری با تایپ int بر می‌گرداند:&lt;/p>
&lt;pre>&lt;code class="language-go">type animal interface {
breathe()
walk()
speed() int
}
&lt;/code>&lt;/pre>
&lt;p>حالا ساختار lion باید متد speed را مانند کد زیر پیاده سازی کرده باشد :&lt;/p>
&lt;pre>&lt;code class="language-go">func (l lion) speed()
&lt;/code>&lt;/pre>
&lt;p>اگر دقت کنید ما داخل اینترفیس animal گفتیم متد speed یک مقدار خروجی از نوع int دارد ولی ما برای ساختار lion متد speed را بدون خروجی نوشتیم. اتفاقی که می‌افتد هنگام کامپایل با خطای زیر مواجه خواهیم شد :&lt;/p>
&lt;pre>&lt;code class="language-go">cannot use lion literal (type lion) as type animal in assignment:
lion does not implement animal (wrong type for speed method)
have speed()
want speed() int
&lt;/code>&lt;/pre>
&lt;p>با توجه به اتفاقی که افتاد ما نتیجه میگریم متدی که داخل اینترفیس به همراه ورودی و خروجی اضافه می‌شود باید به همان شکل برای ساختارهامون پیاده سازی کنیم.&lt;/p>
&lt;h2 id="243-استفاده-از-اینترفیس-به-عنوان-پارامتر-ورودی-تابع">
2.4.3 استفاده از اینترفیس به عنوان پارامتر ورودی تابع
&lt;a class="anchor" href="#243-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-%d8%a7%db%8c%d9%86%d8%aa%d8%b1%d9%81%db%8c%d8%b3-%d8%a8%d9%87-%d8%b9%d9%86%d9%88%d8%a7%d9%86-%d9%be%d8%a7%d8%b1%d8%a7%d9%85%d8%aa%d8%b1-%d9%88%d8%b1%d9%88%d8%af%db%8c-%d8%aa%d8%a7%d8%a8%d8%b9">#&lt;/a>
&lt;/h2>
&lt;p>توابع، تایپ‌های اینترفیس را به عنوان ورودی قبول می‌کنند و هر ساختار یا تایپی متدهای اینترفیس را پیاده سازی کرده باشد می‌تواند به عنوان پارامتر ورودی به تابع ارسال شود.&lt;/p>
&lt;p>به عنوان مثال ما در کد زیر ۲ تا تابع داریم به نام های &lt;strong>callBreathe&lt;/strong> و &lt;strong>callWalk&lt;/strong> که به عنوان ورودی اینترفیس animal را قبول می‌کند و ما ۲ نمونه از ساختارهای lion و dog را که متدهای اینترفیس animal را پیاده سازی کرده‌اند را به این ۲ تابع پاس دادیم.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
type animal interface {
breathe()
walk()
}
type lion struct {
age int
}
func (l lion) breathe() {
fmt.Println("Lion breathes")
}
func (l lion) walk() {
fmt.Println("Lion walk")
}
type dog struct {
age int
}
func (l dog) breathe() {
fmt.Println("Dog breathes")
}
func (l dog) walk() {
fmt.Println("Dog walk")
}
func main() {
l := lion{age: 10}
callBreathe(l)
callWalk(l)
d := dog{age: 5}
callBreathe(d)
callWalk(d)
}
func callBreathe(a animal) {
a.breathe()
}
func callWalk(a animal) {
a.breathe()
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;h2 id="244-چرا-اینترفیس">
2.4.4 چرا اینترفیس؟
&lt;a class="anchor" href="#244-%da%86%d8%b1%d8%a7-%d8%a7%db%8c%d9%86%d8%aa%d8%b1%d9%81%db%8c%d8%b3">#&lt;/a>
&lt;/h2>
&lt;p>شاید برای شما این سوال پیش بیاد چرا باید از اینترفیس استفاده کنیم و مزایای آن چیست؟ ما در زیر مزایای استفاده از اینترفیس و علت اینکه چرا باید از اینترفیس استفاده کنیم را توضیح خواهیم داد.&lt;/p>
&lt;ol>
&lt;li>اینترفیس به ما در نوشتن کدهای ماژولارتر و &lt;span class="tooltip" data-tooltip="decoupled" ontouchend="toggleTooltip(this)">جدا شده‌‌تر&lt;/span>
بین بخش‌های مختلف کد کمک می‌کند و همچنین می‌تواند باعث کاهش وابستگی بین بخش‌های مختلف کد شود.&lt;/li>
&lt;/ol>
&lt;h2 id="کد-باید-برای-تغییر-بسته-و-برای-توسعه-باز-باشد">
کد باید برای تغییر بسته، و برای توسعه باز باشد.
&lt;a class="anchor" href="#%da%a9%d8%af-%d8%a8%d8%a7%db%8c%d8%af-%d8%a8%d8%b1%d8%a7%db%8c-%d8%aa%d8%ba%db%8c%db%8c%d8%b1-%d8%a8%d8%b3%d8%aa%d9%87-%d9%88-%d8%a8%d8%b1%d8%a7%db%8c-%d8%aa%d9%88%d8%b3%d8%b9%d9%87-%d8%a8%d8%a7%d8%b2-%d8%a8%d8%a7%d8%b4%d8%af">#&lt;/a>
&lt;/h2>
&lt;p>اصل باز و بسته بودن یا اصل Open/Closed به نظر بسیاری، اساس برنامه نویسی شی گرا را تشکیل می‌دهد. رابرت مارتین (Robert C. Martin) که در بین برنامه نویسان به عمو باب (Uncle Bob) مشهور است با عبارت: &amp;ldquo;مهم‌ترین اصل طراحی شی گرا&amp;rdquo; از این اصل یاد کرده است. ما با استفاده از اینترفیس ها میتونیم این اصل مهم رو پیاده سازی کنیم.&lt;/p>
&lt;p>&lt;strong>بزارید چند مثال کاربردی بزنیم:&lt;/strong>
فرض کنید ما چند تا سرویس اس ام اس داریم و در آینده هم ممکنه که سرویس های اس ام اس تغییر کنند و از یک ارائه دهنده دیگه خدمات بگیریم. خب در این صورت ما باید چیکار کنیم که با حذف و اضافه کردن سرویس جدید کد های ما تغییر نکنند؟
میایم یک اینترفیس به اسم مثلا Sms می نویسیم و مشخص میکنیم هر کی که میخواد از این اینترفیس استفاده کنه باید متد send_sms و هر چیزی که نیاز هستش رو پیاده سازیش کنه.&lt;/p>
&lt;p>فرض کنید شما یک برنامه نوشتید که یک لایه دیتابیس دارد و داده‌ها، با توجه به کانفیگ، در یکی از دو دیتابیس mongodb یا arangodb ذخیره ‌می‌شود.
حالا اگر ما بیایم در لایه دیتابیس یک اینترفیس قرار دهیم و متدهای مربوط به تعاملات با دیتابیس را ایجاد کنیم، در برنامه‌ای که نوشتیم فقط کافیست متدهای ایترفیس استفاده شود تا با توجه به نوع کانفینگ دیتابیس، پیاده سازی متود اجرا شود.
یعنی اگر ما بیایم داخل کانفیگ پروژه تنظیمات arangodb را به mongodb تغییر دهیم بدون هیچ تغییری در لایه برنامه می‌توانیم به واسطه اینترفیسی که قرار دادیم با دیتابیس mongodb تعامل داشته باشیم.&lt;/p>
&lt;ol start="2">
&lt;li>از اینترفیس‌ها می‌توان برای پیاده‌سازی مفهوم &lt;span class="tooltip" data-tooltip="polymorphism" ontouchend="toggleTooltip(this)">پلی مورفیسم&lt;/span>
در زمان اجرا استفاده کرد. که به این مفهوم RunTime Polymorphism می‌گویند.&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>بزارید یک مثال برای توضیح فوق بزنیم:&lt;/strong>&lt;/p>
&lt;p>فرض کنید کشورهای مختلف روش‌های مختلفی برای محاسبه مالیات دارند که شما می‌توانید با استفاده از یک اینترفیس این عملیات محاسبه را انجام دهید.&lt;/p>
&lt;pre>&lt;code class="language-go">type taxCalculator interface{
calculateTax()
}
&lt;/code>&lt;/pre>
&lt;p>در بالا ما یک اینترفیس با نام taxCalculator داریم که یک متد به نام calculateTax برای محاسبه مالیات دارد. حالا ما باید به ازای هر کشور یک ساختار داشته باشیم که این ساختارها باید متد calculateTax را با توجه شیوه محاسباتی خود پیاده سازی کرده باشند.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
type taxSystem interface {
calculateTax() int
}
type indianTax struct {
taxPercentage int
income int
}
func (i *indianTax) calculateTax() int {
tax := i.income * i.taxPercentage / 100
return tax
}
type singaporeTax struct {
taxPercentage int
income int
}
func (i *singaporeTax) calculateTax() int {
tax := i.income * i.taxPercentage / 100
return tax
}
type usaTax struct {
taxPercentage int
income int
}
func (i *usaTax) calculateTax() int {
tax := i.income * i.taxPercentage / 100
return tax
}
func main() {
indianTax := &amp;indianTax{
taxPercentage: 30,
income: 1000,
}
singaporeTax := &amp;singaporeTax{
taxPercentage: 10,
income: 2000,
}
taxSystems := []taxSystem{indianTax, singaporeTax}
totalTax := calculateTotalTax(taxSystems)
fmt.Printf("Total Tax is %d\n", totalTax)
}
func calculateTotalTax(taxSystems []taxSystem) int {
totalTax := 0
for _, t := range taxSystems {
totalTax += t.calculateTax() // در اینجا runtime polymorphism رخ می دهد
}
return totalTax
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در خط زیر RunTime Polymorphism رخ داده است.&lt;/p>
&lt;pre>&lt;code class="language-go"> totalTax += t.calculateTax() //This is where runtime polymorphism happens
&lt;/code>&lt;/pre>
&lt;h2 id="245-استفاده-از-اشارهگر-هنگام-پیادهسازی-اینترفیس">
2.4.5 استفاده از اشاره‌گر هنگام پیاده‌سازی اینترفیس
&lt;a class="anchor" href="#245-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-%d8%a7%d8%b4%d8%a7%d8%b1%d9%87%da%af%d8%b1-%d9%87%d9%86%da%af%d8%a7%d9%85-%d9%be%db%8c%d8%a7%d8%af%d9%87%d8%b3%d8%a7%d8%b2%db%8c-%d8%a7%db%8c%d9%86%d8%aa%d8%b1%d9%81%db%8c%d8%b3">#&lt;/a>
&lt;/h2>
&lt;p>متدها تایپ‌های گیرنده خود را به دو صورت &lt;span class="tooltip" data-tooltip="pointer" ontouchend="toggleTooltip(this)">اشاره‌گر&lt;/span>
یا &lt;span class="tooltip" data-tooltip="value" ontouchend="toggleTooltip(this)">مقدار&lt;/span>
می‌توانند دریافت کنند. در بالا مثال animal را داشتیم که با حالت &lt;span class="tooltip" data-tooltip="value receiver" ontouchend="toggleTooltip(this)">گیرنده مقدار&lt;/span>
بود. حالا می‌خواهیم بصورت &lt;span class="tooltip" data-tooltip="pointer receiver" ontouchend="toggleTooltip(this)">گیرنده اشاره‌گر&lt;/span>
تعریف کنیم.&lt;/p>
&lt;p>2 نکته با توجه مثالی که خواهیم زد وجود دارد:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>اگر شما برای یک تایپ تمامی متدهای اینترفیس را بصورت &lt;span class="tooltip" data-tooltip="value receiver" ontouchend="toggleTooltip(this)">گیرنده مقدار&lt;/span>
تعریف کرده باشید، هر دو متغیری که یک نمونه از تایپ را بصورت اشاره‌گر و بدون اشاره‌گر تعریف کرده باشد، می‌تواند به اینترفیس animal انتصاب شود و بدون هیچ مشکلی کار کند.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>اگر شما برای یک تایپی تمامی متدهای اینترفیس را بصورت &lt;span class="tooltip" data-tooltip="pointer receiver" ontouchend="toggleTooltip(this)">گیرنده اشاره‌گر&lt;/span>
تعریف کرده باشید فقط متغیری که یک نمونه از تایپ که با اشاره‌گر تعریف کرده باشد می‌تواند به اینترفیس انتصاب یابد.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>مثال با حالت اولی که توضیح دادیم:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
type animal interface {
breathe()
walk()
}
type lion struct {
age int
}
func (l lion) breathe() {
fmt.Println("Lion breathes", l)
}
func (l lion) walk() {
fmt.Println("Lion walk", l)
}
func main() {
var a animal
a = lion{age: 10}
a.breathe()
a.walk()
a = &amp;lion{age: 5}
a.breathe()
a.walk()
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در بالا ما یک نمونه از ساختار lion با اشاره‌گر ایجاد کردیم و مقدار age را ۵ قرار دادیم و به اینترفیس animal انتصابش کردیم و بدون هیچ مشکلی کار کرد.&lt;/p>
&lt;p>حالا برای حالت دوم به مثال زیر توجه کنید:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
type animal interface {
breathe()
walk()
}
type lion struct {
age int
}
func (l *lion) breathe() {
fmt.Println("Lion breathes")
}
func (l *lion) walk() {
fmt.Println("Lion walk")
}
func main() {
var a animal
a = lion{age: 10}
a.breathe()
a.walk()
a = &amp;lion{age: 5}
a.breathe()
a.walk()
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در واقع شما فقط در صورت استفاده از اشاره‌گر، می‌توانید یک نمونه از ساختار lion بسازید در غیر این صورت با خطا مواجه خواهید شد.&lt;/p>
&lt;h2 id="246-پیاده-سازی-اینترفیس-برای-تایپهای-غیر-ساختار">
2.4.6 پیاده سازی اینترفیس برای تایپ‌های غیر ساختار
&lt;a class="anchor" href="#246-%d9%be%db%8c%d8%a7%d8%af%d9%87-%d8%b3%d8%a7%d8%b2%db%8c-%d8%a7%db%8c%d9%86%d8%aa%d8%b1%d9%81%db%8c%d8%b3-%d8%a8%d8%b1%d8%a7%db%8c-%d8%aa%d8%a7%db%8c%d9%be%d9%87%d8%a7%db%8c-%d8%ba%db%8c%d8%b1-%d8%b3%d8%a7%d8%ae%d8%aa%d8%a7%d8%b1">#&lt;/a>
&lt;/h2>
&lt;p>همانطور که قبلاً گفتیم شما می‌توانید برای هر تایپی متد تعریف کنید و در اینجا هم می‌توانید متدهای یک اینترفیس را برای هر تایپی پیاده سازی کنید.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
type animal interface {
breathe()
walk()
}
type cat string
func (c cat) breathe() {
fmt.Println("Cat breathes")
}
func (c cat) walk() {
fmt.Println("Cat walk")
}
func main() {
var a animal
a = cat("smokey")
a.breathe()
a.walk()
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در بالا ما یک تایپ با نام cat از نوع رشته تعریف کردیم و سپس متدهای اینترفیس animal را برای این تایپ پیاده‌سازی کردیم.&lt;/p>
&lt;h2 id="247-پیادهسازی-چندتایی-اینترفیس-برای-تایپ">
2.4.7 پیاده‌سازی چندتایی اینترفیس برای تایپ
&lt;a class="anchor" href="#247-%d9%be%db%8c%d8%a7%d8%af%d9%87%d8%b3%d8%a7%d8%b2%db%8c-%da%86%d9%86%d8%af%d8%aa%d8%a7%db%8c%db%8c-%d8%a7%db%8c%d9%86%d8%aa%d8%b1%d9%81%db%8c%d8%b3-%d8%a8%d8%b1%d8%a7%db%8c-%d8%aa%d8%a7%db%8c%d9%be">#&lt;/a>
&lt;/h2>
&lt;p>شما می‌توانید برای تایپ‌های خود چندین اینترفیس مختلف استفاده کنید و متدهای این اینترفیس‌ها را پیاده سازی کنید.&lt;/p>
&lt;p>در کد زیر ما ۲ تا اینترفیس animal و mammal داریم که داخل اینترفیس mammal یک متد با نام feed وجود دارد حالا می‌خواهیم برای ساختار lion از این اینترفیس استفاده کنیم.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
type animal interface {
breathe()
walk()
}
type mammal interface {
feed()
}
type lion struct {
age int
}
func (l lion) breathe() {
fmt.Println("Lion breathes")
}
func (l lion) walk() {
fmt.Println("Lion walk")
}
func (l lion) feed() {
fmt.Println("Lion feeds young")
}
func main() {
var a animal
l := lion{}
a = l
a.breathe()
a.walk()
var m mammal
m = l
m.feed()
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;h2 id="248-مقدار-صفر-یا-پیشفرض-اینترفیس">
2.4.8 مقدار صفر یا پیش‌فرض اینترفیس
&lt;a class="anchor" href="#248-%d9%85%d9%82%d8%af%d8%a7%d8%b1-%d8%b5%d9%81%d8%b1-%db%8c%d8%a7-%d9%be%db%8c%d8%b4%d9%81%d8%b1%d8%b6-%d8%a7%db%8c%d9%86%d8%aa%d8%b1%d9%81%db%8c%d8%b3">#&lt;/a>
&lt;/h2>
&lt;p>اینترفیس هم همانند سایر تایپ‌ها یک مقدار پیش‌فرض دارد که این مقدار پیش‌فرض &lt;strong>nil&lt;/strong> هست.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
type animal interface {
breathe()
walk()
}
func main() {
var a animal
fmt.Println(a)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;h2 id="249-بدنه-اینترفیس">
2.4.9 بدنه اینترفیس
&lt;a class="anchor" href="#249-%d8%a8%d8%af%d9%86%d9%87-%d8%a7%db%8c%d9%86%d8%aa%d8%b1%d9%81%db%8c%d8%b3">#&lt;/a>
&lt;/h2>
&lt;p>اینترفیس دارای یک بدنه است که از دو بخش تشکیل شده تایپ و مقدار وقتی شما یک تایپی را به اینترفیس منتصب می‌کنید در بخش مقدار نوع و مقدار تایپی که منتصب کردید به اینترفیس در دسترس است.&lt;/p>
&lt;div class="mermaid">
graph TD
A[Interface Variable]
--> B(Interface Type) &amp; C(Interface Value)
C --> D(تایپ داخلی) &amp; E(مقدار داخلی)
&lt;/div>
&lt;p>اگر بخواهیم با توجه به مثال ساختار lion توجه کنیم به شکل زیر می‌شود:&lt;/p>
&lt;div class="mermaid">
graph TD
A[Interface Variable]
--> B(Interface Type) &amp; C(Interface Value)
C --> D(lion) &amp; E("{age: 10}")
&lt;/div>
&lt;p>حالا در زیر مثالی زدیم با استفاده از &lt;code>T%&lt;/code> و &lt;code>v%&lt;/code> نوع و مقدار را می‌توانید چاپ کنیم.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
type animal interface {
breathe()
walk()
}
type lion struct {
age int
}
func (l lion) breathe() {
fmt.Println("Lion breathes")
}
func (l lion) walk() {
fmt.Println("Lion walk")
}
func main() {
var a animal
a = lion{age: 10}
fmt.Printf("Underlying Type: %T\n", a)
fmt.Printf("Underlying Value: %v\n", a)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;h2 id="2410-دسترسی-به-مقادیر-داخلی-اینترفیس">
2.4.10 دسترسی به مقادیر داخلی اینترفیس
&lt;a class="anchor" href="#2410-%d8%af%d8%b3%d8%aa%d8%b1%d8%b3%db%8c-%d8%a8%d9%87-%d9%85%d9%82%d8%a7%d8%af%db%8c%d8%b1-%d8%af%d8%a7%d8%ae%d9%84%db%8c-%d8%a7%db%8c%d9%86%d8%aa%d8%b1%d9%81%db%8c%d8%b3">#&lt;/a>
&lt;/h2>
&lt;p>برای اینکه بتوانید به مقادیر داخلی اینترفیس دسترسی پیدا کنید ۲ تا روش وجود دارد‌:&lt;/p>
&lt;ul>
&lt;li>با استفاده از Type Assertion&lt;/li>
&lt;li>با استفاده از Switch&lt;/li>
&lt;/ul>
&lt;h3 id="24101-با-استفاده-از-type-assertion">
2.4.10.1 با استفاده از Type Assertion
&lt;a class="anchor" href="#24101-%d8%a8%d8%a7-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-type-assertion">#&lt;/a>
&lt;/h3>
&lt;p>برای اینکه بتوانید به مقدار داخلی یک اینترفیس دسترسی پیدا کنید باید جلوی متغیر از نوع اینترفیس یک نقطه &lt;code>.&lt;/code> و در ادامه داخل پرانتز تایپ مورد نظری که قصد دارید تشخیص دهید را باید قرار دهید.&lt;/p>
&lt;pre>&lt;code class="language-go">val, ok := i.({type})
&lt;/code>&lt;/pre>
&lt;p>در بالا زمانیکه Type Assertion انجام می‌دهید ۲ تا متغیر دارید که اولیش مقدار است و دومیش تایید می‌کند تایپی که به اینترفیس دادید همان است (منظور متغیر ok است که مقدار آن از نوع bool است)&lt;/p>
&lt;blockquote class="book-hint danger">
اگر هنگام Type Assertion شما وضعیت متغیر ok را بررسی نکنید با خطای panic مواجه خواهید شد.
&lt;/blockquote>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
type animal interface {
breathe()
walk()
}
type lion struct {
age int
}
func (l lion) breathe() {
fmt.Println("Lion breathes")
}
func (l lion) walk() {
fmt.Println("Lion walk")
}
type dog struct {
age int
}
func (d dog) breathe() {
fmt.Println("Dog breathes")
}
func (d dog) walk() {
fmt.Println("Dog walk")
}
func main() {
var a animal
a = lion{age: 10}
print(a)
}
func print(a animal) {
l, ok := a.(lion)
if ok {
fmt.Printf("Age: %d\n", l.age)
}
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در بالا ما تایپ lion را به اینترفیس animal پاس دادیم و بررسی کردیم آیا تایپ lion از نوع تایپ داخلی اینترفیس animal هست یا خیر.&lt;/p>
&lt;pre>&lt;code class="language-go">l := a.(lion)
&lt;/code>&lt;/pre>
&lt;h3 id="24102-با-استفاده-از-switch">
2.4.10.2 با استفاده از Switch
&lt;a class="anchor" href="#24102-%d8%a8%d8%a7-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-switch">#&lt;/a>
&lt;/h3>
&lt;p>شما با استفاده از switch می‌توانید تایپ اینترفیس را تشخیص دهید.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
type animal interface {
breathe()
walk()
}
type lion struct {
age int
}
func (l lion) breathe() {
fmt.Println("Lion breathes")
}
func (l lion) walk() {
fmt.Println("Lion walk")
}
type dog struct {
age int
}
func (d dog) breathe() {
fmt.Println("Dog breathes")
}
func (d dog) walk() {
fmt.Println("Dog walk")
}
func main() {
var a animal
a = lion{age: 10}
print(a)
}
func print(a animal) {
switch v := a.(type) {
case lion:
fmt.Println("Type: lion")
case dog:
fmt.Println("Type: dog")
default:
fmt.Printf("Unknown Type %T", v)
}
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;h2 id="2411-اینترفیس-خالی">
2.4.11 اینترفیس خالی
&lt;a class="anchor" href="#2411-%d8%a7%db%8c%d9%86%d8%aa%d8%b1%d9%81%db%8c%d8%b3-%d8%ae%d8%a7%d9%84%db%8c">#&lt;/a>
&lt;/h2>
&lt;p>شما می‌توانید اینترفیس بصورت خالی و بدون متد در هرجایی از کد خود استفاده کنید و هر تایپی را می‌توانید به این اینترفیس انتصاب دهید. به عنوان مثال در زیر یک تابع نوشتیم که به عنوان پارامتر ورودی یک اینترفیس خالی می‌گیرد و مقدار این پارامتر را چاپ می‌کند.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
test("thisisstring")
test("10")
test(true)
}
func test(a interface{}) {
fmt.Printf("(%v, %T)\n", a, a)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>توجه کنید اینترفیس خالی خیلی کاربردی هست و usecase‌های مختلفی دارد.&lt;/p></description></item><item><author/><title>2.5 جاسازی تایپ (type embedding)</title><link>https://book.gofarsi.ir/chapter-2/type-embedding/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-2/type-embedding/</guid><description>&lt;p>در زبان گو برای ساختار و اینترفیس امکان &lt;span class="tooltip" data-tooltip="embedding" ontouchend="toggleTooltip(this)">جاسازی&lt;/span>
تایپ وجود دارد. یعنی شما می‌توانید یک ساختار یا یک اینترفیس را داخل ساختار دیگر &lt;span class="tooltip" data-tooltip="embedding" ontouchend="toggleTooltip(this)">جاسازی&lt;/span>
کنید و یا داخل اینترفیس یک اینترفیس دیگر را جاسازی کنید.&lt;/p>
&lt;pre>&lt;code class="language-go">
type animal interface {
breathe()
walk()
}
type human interface {
animal
speak()
}
type base struct {
num int
}
type container struct {
human
base
str string
}
&lt;/code>&lt;/pre>
&lt;p>در بالا ما اینترفیس animal را در اینترفیس human &lt;span class="tooltip" data-tooltip="embedding" ontouchend="toggleTooltip(this)">جاسازی&lt;/span>
کردیم و در ادامه داخل ساختار container اینترفیس human و ساختار base را &lt;span class="tooltip" data-tooltip="embedding" ontouchend="toggleTooltip(this)">جاسازی&lt;/span>
کردیم.&lt;/p>
&lt;p>با اینکار ما به متدهای اینترفیس human و animal و همچنین به فیلدهای ساختار base دسترسی داریم و می توانیم از متدها و فیلدهای &lt;span class="tooltip" data-tooltip="embedding" ontouchend="toggleTooltip(this)">جاسازی&lt;/span>
با استفاده از ساختار container استفاده کنیم.&lt;/p>
&lt;blockquote class="book-hint warning">
توجه کنید شما نمی‌توانید یک ساختار را داخل اینترفیس &lt;span class="tooltip" data-tooltip="embedding" ontouchend="toggleTooltip(this)">جاسازی&lt;/span>
کنید.
&lt;/blockquote>
&lt;h2 id="251-جاسازی-ساختار">
2.5.1 جاسازی ساختار
&lt;a class="anchor" href="#251-%d8%ac%d8%a7%d8%b3%d8%a7%d8%b2%db%8c-%d8%b3%d8%a7%d8%ae%d8%aa%d8%a7%d8%b1">#&lt;/a>
&lt;/h2>
&lt;p>شما می‌توانید هر چندتا ساختاری که دارید داخل یک ساختاری &lt;span class="tooltip" data-tooltip="embedding" ontouchend="toggleTooltip(this)">جاسازی&lt;/span>
و به هرکدام از فیلدهای ساختارهای &lt;span class="tooltip" data-tooltip="embedding" ontouchend="toggleTooltip(this)">جاسازی&lt;/span>
شده دسترسی دارید.&lt;/p>
&lt;p>&lt;strong>به مثال زیر توجه کنید :&lt;/strong>&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
type base struct {
num int
}
func (b base) describe() string {
return fmt.Sprintf("base with num=%v", b.num)
}
type container struct {
base
str string
}
func main() {
co := container{
base: base{
num: 1,
},
str: "some name",
}
fmt.Printf("co={num: %v, str: %v}\n", co.num, co.str)
fmt.Println("also num:", co.base.num)
fmt.Println("describe:", co.describe())
type describer interface {
describe() string
}
var d describer = co
fmt.Println("describer:", d.describe())
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;h3 id="2511-جاسازی-اینترفیس-در-ساختار">
2.5.1.1 جاسازی اینترفیس در ساختار
&lt;a class="anchor" href="#2511-%d8%ac%d8%a7%d8%b3%d8%a7%d8%b2%db%8c-%d8%a7%db%8c%d9%86%d8%aa%d8%b1%d9%81%db%8c%d8%b3-%d8%af%d8%b1-%d8%b3%d8%a7%d8%ae%d8%aa%d8%a7%d8%b1">#&lt;/a>
&lt;/h3>
&lt;p>همانطور که گفتیم یک اینترفیس می‌‌تواند داخل یک ساختار جاسازی شود و همه متدهای اینترفیس به واسطه ساختار مورد قابل دسترس است و می‌توانید هر یک از متدها را استفاده کنید.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
type animal interface {
breathe()
walk()
}
type dog struct {
age int
}
func (d dog) breathe() {
fmt.Println("Dog breathes")
}
func (d dog) walk() {
fmt.Println("Dog walk")
}
type pet1 struct {
a animal
name string
}
type pet2 struct {
animal
name string
}
func main() {
d := dog{age: 5}
p1 := pet1{name: "Milo", a: d}
fmt.Println(p1.name)
// p1.breathe()
// p1.walk()
p1.a.breathe()
p1.a.walk()
p2 := pet2{name: "Oscar", animal: d}
fmt.Println(p1.name)
p2.breathe()
p2.walk()
p1.a.breathe()
p1.a.walk()
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;h2 id="252-جاسازی-اینترفیس">
2.5.2 جاسازی اینترفیس
&lt;a class="anchor" href="#252-%d8%ac%d8%a7%d8%b3%d8%a7%d8%b2%db%8c-%d8%a7%db%8c%d9%86%d8%aa%d8%b1%d9%81%db%8c%d8%b3">#&lt;/a>
&lt;/h2>
&lt;p>شما همانند ساختارها می‌توانید اینترفیس‌ها را &lt;span class="tooltip" data-tooltip="embedding" ontouchend="toggleTooltip(this)">جاسازی&lt;/span>
کنید و فقط کافیه اینترفیس‌ها را داخل دیگر اینترفیس‌ها &lt;span class="tooltip" data-tooltip="embedding" ontouchend="toggleTooltip(this)">جاسازی&lt;/span>
کنید تا متدهای اینترفیس‌های &lt;span class="tooltip" data-tooltip="embedding" ontouchend="toggleTooltip(this)">جاسازی&lt;/span>
شده دسترسی داشته باشید.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
type animal interface {
breathe()
walk()
}
type human interface {
animal
speak()
}
type employee struct {
name string
}
func (e employee) breathe() {
fmt.Println("Employee breathes")
}
func (e employee) walk() {
fmt.Println("Employee walk")
}
func (e employee) speak() {
fmt.Println("Employee speaks")
}
func main() {
var h human
h = employee{name: "John"}
h.breathe()
h.walk()
h.speak()
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>یکی دیگه از مثال‌هایی که می‌توانیم بزنیم پکیج io اینترفیس ReadWriter هست که ۲ تا اینترفیس &lt;a href="https://golang.org/pkg/io/#Reader">Reader&lt;/a> و &lt;a href="https://golang.org/pkg/io/#Writer">Writer&lt;/a> داخل این اینترفیس جاسازی شده است.&lt;/p></description></item><item><author/><title>2.6 مدیریت خطاها</title><link>https://book.gofarsi.ir/chapter-2/error-handling/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-2/error-handling/</guid><description>&lt;p>در این بخش قصد داریم به مقوله مدیریت خطاها در زبان گو بپردازیم و اینکه چطور می‌توانید خیلی ساده خطاها را مدیریت کنید. مدیریت خطا در زبان گو با سایر زبان‌ها متفاوت هست و شما با چیزی به نام try-catch یا try-except سروکار ندارید.&lt;/p>
&lt;p>مدیریت خطاها در زبان گو به دو روش صورت می گیرد:&lt;/p>
&lt;ul>
&lt;li>با استفاده از پیاده سازی اینترفیس error که یک روش مرسوم جهت مدیریت و نمایش خطا است.&lt;/li>
&lt;li>با استفاده از panic/recover که در فصل اول توضیح دادیم.&lt;/li>
&lt;/ul>
&lt;h2 id="261-مدیریت-خطا-با-اینترفیس-error">
2.6.1 مدیریت خطا با اینترفیس error
&lt;a class="anchor" href="#261-%d9%85%d8%af%db%8c%d8%b1%db%8c%d8%aa-%d8%ae%d8%b7%d8%a7-%d8%a8%d8%a7-%d8%a7%db%8c%d9%86%d8%aa%d8%b1%d9%81%db%8c%d8%b3-error">#&lt;/a>
&lt;/h2>
&lt;p>روش زبان گو برای مقابله با خطا این است که به صراحت، شما خطا را به عنوان خروجی تابع برگردانید. برای این کار کافیست اگر میخواهید خطای هر تابع را مدیریت کنید، اینترفیس error را در خروجی تابع بگذارید.&lt;/p>
&lt;p>&lt;a href="https://pkg.go.dev/builtin#error">https://pkg.go.dev/builtin#error&lt;/a>&lt;/p>
&lt;pre>&lt;code class="language-go">type error interface {
Error() string
}
&lt;/code>&lt;/pre>
&lt;p>به مثال زیر توجه کنید:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"fmt"
"os"
)
func main() {
file, err := os.Open("non-existing.txt")
if err != nil {
fmt.Println(err)
} else {
fmt.Println(file.Name() + "opened succesfully")
}
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در کد بالا ما با استفاده از تابع Open که در پکیج os وجود دارد فایل non-existing.txt را باز کرده‌ایم. اگر دقت کنید این تابع ۲ تا خروجی دارد یکی ساختار File هست و دیگری خطا هست. در ادامه ما با استفاده شرط آمدیم چک کردیم اینترفیس err آیا خالی است یا خیر؟ در کد بالا این اینترفیس خالی &lt;code>nil&lt;/code> نیست و ما خطا را چاپ کردیم.&lt;/p>
&lt;p>این روش به طور گسترده در پکیج‌های داخلی و شخص ثالث گو استفاده می‌شود.&lt;/p>
&lt;p>دقت کنید اینترفیس error یک متد دارد به نام ()Error که این متد متن خطا را بصورت رشته بر می‌گرداند.&lt;/p>
&lt;p>&lt;strong>آیا همیشه نیاز است خطاها را مدیریت کنیم؟&lt;/strong>&lt;/p>
&lt;p>شاید بپرسید آیا واقعا نیاز هست ما همیشه خطاها را مدیریت کنیم؟ در جواب این سوال می توانیم بگیم هم بله و هم خیر&lt;/p>
&lt;ul>
&lt;li>علت اینکه می‌گوییم بله از این بابت هست اگر خطاها بدرستی مدیریت نشود احتمال اینکه با panic در هر جا مواجه شویم خیلی زیاد است. بخصوص خطای &lt;code>nil pointer&lt;/code> . پس بهتر است تا جایی که می‌توانید خطاها را بدرستی مدیریت کنید و همچنین اگر جایی احتمال می‌دهید panic پیش میاد بهتر است از recover استفاده کنید تا پایداری برنامه را بالا ببرید.&lt;/li>
&lt;li>علت اینکه می‌گوییم خیر از این بابت هست که در زبان گو، هیچ اجباری برای مدیریت خطاها وجود ندارد و گاهی اوقات می‌توانید خطاها را نادیده بگیرید که با استفاده از &lt;code>ـ&lt;/code> امکان پذیر است.&lt;/li>
&lt;/ul>
&lt;h2 id="262-مزایای-استفاده-از-error-به-عنوان-یک-تایپ-در-زبان-گو">
2.6.2 مزایای استفاده از error به عنوان یک تایپ در زبان گو
&lt;a class="anchor" href="#262-%d9%85%d8%b2%d8%a7%db%8c%d8%a7%db%8c-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-error-%d8%a8%d9%87-%d8%b9%d9%86%d9%88%d8%a7%d9%86-%db%8c%da%a9-%d8%aa%d8%a7%db%8c%d9%be-%d8%af%d8%b1-%d8%b2%d8%a8%d8%a7%d9%86-%da%af%d9%88">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>به شما این امکان را می‌دهد کنترل بیشتری رو خطاها داشته باشید و تو هر قدم می‌توانید خطاها را بررسی کنید.&lt;/li>
&lt;li>جلوگیری از try-catch جهت مدیریت خطا (دقت کنید در سایر زبان ها باید تا جایی که ممکن است از try-catch کمتر استفاده کنید)&lt;/li>
&lt;/ul>
&lt;h2 id="263-روشهای-مختلف-برای-ایجاد-یک-خطا">
2.6.3 روش‌های مختلف برای ایجاد یک خطا
&lt;a class="anchor" href="#263-%d8%b1%d9%88%d8%b4%d9%87%d8%a7%db%8c-%d9%85%d8%ae%d8%aa%d9%84%d9%81-%d8%a8%d8%b1%d8%a7%db%8c-%d8%a7%db%8c%d8%ac%d8%a7%d8%af-%db%8c%da%a9-%d8%ae%d8%b7%d8%a7">#&lt;/a>
&lt;/h2>
&lt;p>در زبان گو شما می‌توانید در هرجای کد خود یک خطا با محتوای مناسب ایجاد کنید و یا اینکه برخی از خطاهای برخی از کتابخانه‌ها را &lt;span class="tooltip" data-tooltip="wrap" ontouchend="toggleTooltip(this)">هم‌پوشانی&lt;/span>
کنید.&lt;/p>
&lt;p>&lt;strong>1. با استفاده (&amp;ldquo;متن خطا&amp;rdquo;)errors.New&lt;/strong>&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"errors"
"fmt"
)
func main() {
sampleErr := errors.New("error occured")
fmt.Println(sampleErr)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در بالا ما با استفاده از تابع New پکیج errors یک خطا با متن مشخص ایجاد کردیم و متغیر sampleErr از نوع اینترفیس error می‌باشد که می‌توانید در هر جای کد خود مدیریتش کنید.&lt;/p>
&lt;p>&lt;strong>2. با استفاده از (&amp;ldquo;error is %s&amp;rdquo;, &amp;ldquo;some error message&amp;rdquo;)fmt.Errorf&lt;/strong>&lt;/p>
&lt;p>شما با استفاده از تابع Errorf در پکیج fmt می‌توانید یک خطا ایجاد کنید و توجه کنید این متن خطا قابل فرمت است و حتی شما می‌توانید متن خطا را داینامیک کنید.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"fmt"
)
func main() {
msg := "database connection issue"
sampleErr := fmt.Errorf("Err is: %s", msg)
fmt.Println(sampleErr)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;h2 id="264-ایجاد-خطا-پیشرفته">
2.6.4 ایجاد خطا پیشرفته
&lt;a class="anchor" href="#264-%d8%a7%db%8c%d8%ac%d8%a7%d8%af-%d8%ae%d8%b7%d8%a7-%d9%be%db%8c%d8%b4%d8%b1%d9%81%d8%aa%d9%87">#&lt;/a>
&lt;/h2>
&lt;p>در مثال زیر ما قصد داریم یک خطای پیشرفته ایجاد کنیم و آن را به آسانی مدیریت کنیم.&lt;/p>
&lt;p>&lt;strong>ویژگی‌های خطای پیشرفته :&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>در زیر inputError یک نوع ساختار است که داخلش ۲ تا فیلد message و missingField دارد و همچنین دارای یک متد ()Error است.&lt;/li>
&lt;li>شما می‌توانید به این ساختار خطای پیشرفته، متدهای بیشتری اضافه کنید و همچنین گسترش دهید که به عنوان مثال ما متد getMissingFields را برای گرفتن محتوای missingField اضافه کردیم.&lt;/li>
&lt;li>ما با استفاده از type assertion می‌توانیم اینترفیس error را به inputError تبدیل کنیم.&lt;/li>
&lt;/ul>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
type inputError struct {
message string
missingField string
}
func (i *inputError) Error() string {
return i.message
}
func (i *inputError) getMissingField() string {
return i.missingField
}
func main() {
err := validate("", "")
if err != nil {
if err, ok := err.(*inputError); ok {
fmt.Println(err)
fmt.Printf("Missing Field is %s\n", err.getMissingField())
}
}
}
func validate(name, gender string) error {
if name == "" {
return &amp;inputError{message: "Name is mandatory", missingField: "name"}
}
if gender == "" {
return &amp;inputError{message: "Gender is mandatory", missingField: "gender"}
}
return nil
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;h2 id="265-نادیده-گرفتن-خطاها">
2.6.5 نادیده گرفتن خطاها
&lt;a class="anchor" href="#265-%d9%86%d8%a7%d8%af%db%8c%d8%af%d9%87-%da%af%d8%b1%d9%81%d8%aa%d9%86-%d8%ae%d8%b7%d8%a7%d9%87%d8%a7">#&lt;/a>
&lt;/h2>
&lt;p>شما در هرجای کد خود با استفاده از &lt;code>_&lt;/code> می توانید متغیر خطا را نادیده بگیرید و آن را مدیریت نکنید. هر چند در بالا گفتیم نادیده گرفتن خطاها عوارضی در بر دارد و ما همیشه، تاکید می‌کنیم تا جایی که ممکن است خطاها را مدیریت کنید.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"fmt"
"os"
)
func main() {
file, _ := os.Open("non-existing.txt")
fmt.Println(file)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در بالا ما خطای تابع Open را نادیده گرفتیم و مقدار file را چاپ کردیم مقدار چاپ شده &lt;code>nil&lt;/code> است چون تایپ خروجی با اشاره‌گر است و قطعا مقدار خالی بودش &lt;code>nil&lt;/code> است.&lt;/p>
&lt;h2 id="266-همپوشانی-wrapping-خطا">
2.6.6 هم‌پوشانی (Wrapping) خطا
&lt;a class="anchor" href="#266-%d9%87%d9%85%d9%be%d9%88%d8%b4%d8%a7%d9%86%db%8c-wrapping-%d8%ae%d8%b7%d8%a7">#&lt;/a>
&lt;/h2>
&lt;p>در زبان گو، شما می‌توانید خطا را با خطا و پیغام مشخصی &lt;span class="tooltip" data-tooltip="wrap" ontouchend="toggleTooltip(this)">هم پوشانی&lt;/span>
کنید. حالا &lt;span class="tooltip" data-tooltip="wrap" ontouchend="toggleTooltip(this)">هم‌پوشانی&lt;/span>
خطا چیست؟&lt;/p>
&lt;p>بزارید با یک مثال ساده توضیح دهیم، فرض کنید شما تو لایه دیتابیس خود یکسری خطاها از سمت دیتابیس دریافت می‌کنید به عنوان مثال اگر شما سندی را در دیتابیس monogdb پیدا نکنید با خطای &lt;code>no documents found&lt;/code> مواجه خواهید شد. شما در اینجا نمی‌توانید همان متن خطا را به کاربر نمایش دهید بلکه باید آن خطا را با یک متن خطای مناسب &lt;span class="tooltip" data-tooltip="wrap" ontouchend="toggleTooltip(this)">هم پوشانی&lt;/span>
کنید.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"fmt"
)
type notPositive struct {
num int
}
func (e notPositive) Error() string {
return fmt.Sprintf("checkPositive: Given number %d is not a positive number", e.num)
}
type notEven struct {
num int
}
func (e notEven) Error() string {
return fmt.Sprintf("checkEven: Given number %d is not an even number", e.num)
}
func checkPositive(num int) error {
if num &lt; 0 {
return notPositive{num: num}
}
return nil
}
func checkEven(num int) error {
if num%2 != 0 {
return notEven{num: num}
}
return nil
}
func checkPostiveAndEven(num int) error {
if num > 100 {
return fmt.Errorf("checkPostiveAndEven: Number %d is greater than 100", num)
}
err := checkPositive(num)
if err != nil {
return err
}
err = checkEven(num)
if err != nil {
return err
}
return nil
}
func main() {
num := 3
err := checkPostiveAndEven(num)
if err != nil {
fmt.Println(err)
} else {
fmt.Println("Givennnumber is positive and even")
}
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;h2 id="267-unwrap-خطاها">
2.6.7 Unwrap خطاها
&lt;a class="anchor" href="#267-unwrap-%d8%ae%d8%b7%d8%a7%d9%87%d8%a7">#&lt;/a>
&lt;/h2>
&lt;p>در بخش بالا شما با نحوه &lt;span class="tooltip" data-tooltip="wrap" ontouchend="toggleTooltip(this)">هم‌پوشانی&lt;/span>
کردن آشنا شدید، اما این امکان را داریم خطاها را unwrap کنیم با استفاده از یک تابع در پکیج errors به نام Unwrap.&lt;/p>
&lt;pre>&lt;code class="language-go">func Unwrap(err error) error
&lt;/code>&lt;/pre>
&lt;p>منظورمان از unwrap کردن این است که، اگر خطایی را &lt;span class="tooltip" data-tooltip="wrap" ontouchend="toggleTooltip(this)">هم پوشانی&lt;/span>
کرده باشیم با استفاده unwrap می‌توانیم آن خطا را ببینیم.&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">import (
"errors"
"fmt"
)
type errorOne struct{}
func (e errorOne) Error() string {
return "Error One happened"
}
func main() {
e1 := errorOne{}
e2 := fmt.Errorf("E2: %w", e1)
e3 := fmt.Errorf("E3: %w", e2)
fmt.Println(errors.Unwrap(e3))
fmt.Println(errors.Unwrap(e2))
fmt.Println(errors.Unwrap(e1))
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div>
&lt;p>در کد بالا متغیر e2 خطای داخل ساختار e1 را هم‌پوشانی کرده و سپس متغیر e3 خطای متغیر e2 را هم‌پوشانی می‌کند. در نهایت با تابع Unwrap متن خطای اصلی را چاپ کردیم.&lt;/p>
&lt;h2 id="268-بررسی-دو-خطا-اگر-برابر-هستند">
2.6.8 بررسی دو خطا اگر برابر هستند
&lt;a class="anchor" href="#268-%d8%a8%d8%b1%d8%b1%d8%b3%db%8c-%d8%af%d9%88-%d8%ae%d8%b7%d8%a7-%d8%a7%da%af%d8%b1-%d8%a8%d8%b1%d8%a7%d8%a8%d8%b1-%d9%87%d8%b3%d8%aa%d9%86%d8%af">#&lt;/a>
&lt;/h2>
&lt;p>در زبان گو شما می‌توانید ۲ اینترفیس را با هم مقایسه کنید و این مقایسه به وسیله اپراتور &lt;code>==&lt;/code> یا با استفاده از &lt;a href="https://pkg.go.dev/errors#Is">تابع Is در پکیج errors&lt;/a> صورت می‌گیرد. اساساً دو مقوله برای این مقایسه در نظر گرفته خواهد شد:&lt;/p>
&lt;pre>&lt;code class="language-go">func Is(err, target error) bool
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>هر دو این اینترفیس‌ها به یک نوع تایپ منصوب شده باشند.&lt;/li>
&lt;li>مقدار داخلی اینترفیس‌ها باید با هم برابر باشند یا اینکه هر دو (nil) باشند.&lt;/li>
&lt;/ul>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import (
"errors"
"fmt"
)
type errorOne struct{}
func (e errorOne) Error() string {
return "Error One happended"
}
func main() {
var err1 errorOne
err2 := do()
if err1 == err2 {
fmt.Println("Equality Operator: Both errors are equal")
}
if errors.Is(err1, err2) {
fmt.Println("Is function: Both errors are equal")
}
}
func do() error {
return errorOne{}
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div></description></item><item><author/><title>2.7 فرق casting با conversion</title><link>https://book.gofarsi.ir/chapter-2/casting-vs-conversion/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-2/casting-vs-conversion/</guid><description>&lt;h2 id="271-conversion">
2.7.1 conversion
&lt;a class="anchor" href="#271-conversion">#&lt;/a>
&lt;/h2>
&lt;p>conversion زمانی اتفاق می‌افتد که ما مقدار یک داده را به تایپ دیگری اختصاص دهیم.&lt;/p>
&lt;p>زبان‌هایی که Static Type هستند از این مقوله بطور &lt;span class="tooltip" data-tooltip="implicit" ontouchend="toggleTooltip(this)">ضمنی&lt;/span>
پشتیبانی می‌کنند ولی در زبان گو کمی متفاوت است. اگر شما بخواهید conversion انجام دهید باید بصورت دستی اینکار را انجام دهید. چون کامپایلر گو برخی از عناوین را بطور &lt;span class="tooltip" data-tooltip="explicit" ontouchend="toggleTooltip(this)">صریح&lt;/span>
در نظر می‌گیرد.&lt;/p>
&lt;h2 id="272-type-casting">
2.7.2 type casting
&lt;a class="anchor" href="#272-type-casting">#&lt;/a>
&lt;/h2>
&lt;p>در زبان گو، چیزی به نام type casting بطور کلی وجود ندارد. پس بهتر است در خصوص این مورد داخل داکیومنت‌ها یا سایت‌های مختلف نگردید. برای درک بهتر این موضوع بهتره &lt;a href="https://go.dev/ref/spec#Conversions">https://go.dev/ref/spec#Conversions&lt;/a> را مطالعه کنید.&lt;/p>
&lt;h2 id="273-مثال-conversion">
2.7.3 مثال conversion
&lt;a class="anchor" href="#273-%d9%85%d8%ab%d8%a7%d9%84-conversion">#&lt;/a>
&lt;/h2>
&lt;p>در زیر یک مثال در خصوص conversion زدیم تا با این مقوله آشنا شوید:&lt;/p>
&lt;div class="go-playground">
&lt;pre class="line-numbers">&lt;code class="language-go">package main
import "fmt"
func main() {
var totalsum int = 846
var number int = 19
var avg float32
avg = float32(totalsum) / float32(number)
fmt.Printf("Average = %f\n", avg)
}&lt;/code>&lt;/pre>
&lt;button class="run-code">▶ اجرای کد&lt;/button>
&lt;button class="copy-code">کپی&lt;/button>
&lt;button class="hide-output">✖ بستن خروجی&lt;/button>
&lt;pre class="run-output hidden">&lt;/pre>
&lt;/div></description></item></channel></rss>