---
title: '9.6.1 ضد الگو سینتکسی'
slug: go-anti-patterns-in-syntax
weight: 179001
---

ضد الگو سینتکسی

طبق تعریف، ضد الگو در مهندسی نرم افزار، مدیریت پروژه و یا فرایند کسب و کار پاسخ های متداول ما به مشکلات مکرری هستند که در ابتدا بنظر کارآمد و موثر میآیند، اما اینطور نیست و بی فایده و یا دارای عواقب مخرب اند.

ضد الگوها دقیقا متضاد الگوهای طراحی نرم افزار (design patterns) اند که روشها و راه حل های حل مشکلات متداول در فرایند توسعه نرم افزار هستند. در ادامه با 10 تا از این الگوها آشنا خواهیم شد.
1. GOD Class یا God Object

در برنامه نویسی شی گرا god class  یا god object به کلاسی گفته میشود که دارای متدهای زیادی باشد که کارهای متنوعی و زیادی انجام بدهد.  به عبارت دیگر کلاسی بزرگ تصور کنید که بسیاری از کارها درون آن انجام میشود و سازماندهی مناسبی ندارد. اما این تعریف شاید تعریف مناسبی نباشد و حتی شما تصور کنید که یک کلاس متمرکز ایده ی خیلی خوبی هم باشد. اما چرا باید از آن اجتناب کرد؟
God object ها اصول SOLID را نقض میکنند

اصول SOLID شامل مجموعه ای از دستورالعملهای مقبول برای توسعه نرم افزار است که تضمین کننده طراحی  خوب  در نرم افزار است. SOLID مخفف 5 اصل است که S در آن اشاره به اصل مسئولیت واحد (single responsibility principle) دارد و بدین معناست که هر ماژول، کلاس و یا متد باید فقط یک کار مشخص انجام دهد. پیروی از این اصل موجب میشود که مسائل بزرگ به بخشهای کوچکتری تقسیم شوند که هر بخش فقط یک کار بخصوص را انجام میدهد و استفاده مجدد و سازماندهی آنها آسان خواهد شد و باعث حذف کارهای تکراری و سایر بدهی های فنی (technical dept) دیگر میشود و همچنین باعث تسهیل در  فرایند تست ، نگهداری و توسعه آن خواهد شد. 

God object ها دقیقا بر خلاف این اصل هستند و  باعث ایجاد کلاسهای بزرگ و همه کاره ای خواهند شد که مسئولیتهای زیادی را به عهده دارد و غیر متمرکز میباشد که نگهداری و توسعه آن دشوار است، امکان تکرار و دیگر بدهی های فنی در آن بسیار محتمل است.
God Object ها باعث شکنندگی کدهای شما خواهد شد

اصلاح و تغییر مداوم در کلاس بزرگی که پر از متدهای مختلف است و که هرکدام کاری میکنند و به احتمال زیاد بعضی از آنها وابسته به یکدیگر هستند بسیار سخت و پر ریسک است و ممکن است موجب شکست کامل کلاس و یا ایجاد پاسخ های غیر قابل پیشبینی شود. 
God object ها باعث آسیب به آزمایش پذیری برنامه خواهند شد

تست پذیری یکی از نکات مهم است که مزایای آن بر کسی پوشید نیست. برای تست پذیری لازم است که کلاسها و کدها قابلیت تست داشته باشند و این بدان معناست که کدها بر اساس سبک مشخصی نوشته شوند که امکان ایجاد unit test برای آنها آسان، عملی و قابل اجرا باشد. یکی از خصوصیاتی که موجب تست پذیری کلاسها میشود این است که کلاس کوچک و متمرکز باشد که god object ها دقیقا بر خلاف این اصل هستند و نوشتن تست برای یک کلاس بزرگ با متدها و عملکردهای متنوع بسیار سخت و حتی غیر ممکن خواهد بود.
God object ها باعث کاهش کارایی یا performance خواهند شد

تا زمانی که یه شئ (object) قابل دسترسی باشد، در رم باقی میماند و فضای آن را اشغال میکند و چون garbage collector تصور میکند که شی در حال استفاده است، آن را حذف نمیکند. god object ها از منابع و شی های بسیار زیادی استفاده میکنند و آنها را در خود نگه میدارند که در نتیجه منابعی که دیگر استفاده نمیشوند چون هنوز قابل دسترس هستند فضای رم را اشغال خواهند کرد و باعث کاهش کارایی و عملکرد سیستم خواهند شد.
God class ها باعث کاهش قابل فهم بودن کدها میشوند

از آنجایی که این کلاسها کارهای متعددی انجام میدهند و مسئولیت های زیادی را به عهده دارند باعث افزایش پیچیدگی کد (complexity of code) خواهند شد که این امر توسعه و بروزرسانی و ایجاد تغییر در کدها را سخت و غیر ممکن خواهد کرد.
2. Spaghetti Code

این یک واژه رایج برای اشاره به کد های بدون ساختار  و نا منظم است که خواندن آن سخت و عیب یابی آن مشکل است. این کدها در ابتدا ممکن است مشکل ساز نباشند ولی اگر در زمان مناسب حل نشوند باعث هدر رفت منابع، زمان  و انرژی زیادی برای رفع آن در آینده خواهند شد.
3. Magic Numbers

استفاده از اعداد و یا مقادیر ثابت بدون ارائه توضیحات مناسب درمورد آن باعث نامفهوم شدن کد خواهد شد که نگهداری و توسعه کدها در آیند سخت و زمانبر خواهند شد.
4. Golden Hammer

این الگو اشاره به حالتی دارد که در آن وابستگی بیش از اندازه به یک ابزار ، تکنولوژی یا روش وجود دارد، حتی زمانی که برای مشکل موجود مناسب و پاسخگو نیست. در واقع این اصل اشاره به ضرب المثل " اگر تنها ابزارت چکش باشه، همه چیز رو شکل میخ میبی! " دارد. 
5. Blob or Big Ball of Mud

اشاره به ساختار و سیستم نرم افزاری دارد که ساختار مشخصی ندارد و فاقد معماری قابل درک است که معمولا ناشی از فشارهای تجاری، جایگزین شدن توسعه دهندگان و یا پوسیدگی نرم افزار (software rot) به علت عدم مراقبت و نگهداری و بروزرسانی های ساختار یافته و مناسب در کدها بوجود میآید.
6. Copy-Paste Programming

اشاره به حالتی دارد که به جای ایجاد انتزاع (abstraction) و استفاده مجدد از کد (reusing) اقدام به تکرار کدها و یا کپی پیست کردن آن ها در جاهای مختلف کنیم که موجب مشکل شدن فرایند نگهداری ، توسعه و بروزرسانی کدها  و سیستم خواهد شد.
7. Reinventing the Wheel

ایجاد راه حل  مجدد برای مسائلی که از پیش حل شده و موجود و در دسترس میبشاد باعث هدر رفت زمان، هزینه و انرژی خواهد شد و راه حل جدید ممکن است به خوبی راه حل موجود نباشد و همه جنبه ها را پوشش ندهد.
8. Shotgun Surgery

این ضد الگو زمانی رخ میدهد که برای ایجاد یک تغییر کوچک و یا افزودن یک ویژگی نیاز به تغییر در کلاسهای بسیاری باشد که این بر خلاف اصل انتزاع یا (Abstraction principle) است. هدف اصل انتزاع کاهش تکرار در برنامه است و به این صورت تعریف شده است که هر بخش و عملکرد برنامه فقط باید در یکجا نوشته شود و در جاهای دیگر فراخوانی شود.
9. Boat Anchor

کدها، ویژگیها و یا dependency های بلا استفاده و غیر ضروری باعث افزایش پیچیدگی و هزینه زیاد بر روی سیستم میشود که باید از آن اجتناب کرد .
10. Tight Coupling

این ضد الگو زمانی رخ میدهد که دو یا چند کامپوننت یا ماژول بشدن بهم وابسته باشند و تغییر آنها باعث شکست کد و از کار افتادن برنامه خواهد شد. این امر باعث ایجاد مشکل در نگهداری و توسعه نرم افزار و بروز رسانی آن خواهد شد.

این ضد الگوها ممکن است موجب مشکلات مختلفی در نرم افزار شوند مانند، کاهش قابلیت نگهداری، کاهش کیفیت کد یا (code quality) ، افزایش امکان ایجاد خطاهای منطقی و باگ ها و یا مانع توسعه پذیری آن شوند. برای توسعه نرم افزارهایی با قابلیت نگهداری ، توسعه پذیری ،شناسایی و اجتناب از آنها در فرایند توسعه نرم افزار بسیار مهم است.
