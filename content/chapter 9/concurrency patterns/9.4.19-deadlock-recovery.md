---
title: 9.4.19 الگو Deadlock Recovery
slug: go-concurrency-pattern-deadlock-recovery
weight: 177019
mermaid: "true"
---


## 9.4.19.1 توضیحات

الگوی **بازیابی از بن‌بست** (Deadlock Recovery) برای شناسایی و بازیابی از وضعیت‌های بن‌بست استفاده می‌شود، جایی که چندین گوروتین به طور نامحدود منتظر منابعی هستند که توسط یکدیگر نگه داشته شده‌اند. بن‌بست می‌تواند به دلیل همگام‌سازی نادرست یا رقابت برای منابع در برنامه‌های همزمان رخ دهد. این الگو شامل نظارت بر گوروتین‌ها، شناسایی بن‌بست‌های احتمالی و پیاده‌سازی مکانیزم‌های بازیابی مانند زمان‌بندی، تلاش مجدد یا خاتمه اجباری است.

## 9.4.19.2 دیاگرام


{{< mermaid >}}
flowchart TD
    A[شروع] --> B[چندین گوروتین]
    B --> C{منتظر منابع}
    C -->|بن‌بست شناسایی شد| D[فعال‌سازی مکانیزم بازیابی]
    D -->|بازیابی| E[ادامه اجرای برنامه]
    C -->|بدون بن‌بست| F[اجرای عادی]
{{< /mermaid >}}




## 9.4.19.3 نمونه کد

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

func deadlockRecoveryExample() {
	var mu1, mu2 sync.Mutex
	done := make(chan struct{})

	go func() {
		defer func() {
			if r := recover(); r != nil {
				fmt.Println("بن‌بست شناسایی و بازیابی شد:", r)
			}
		}()
		mu1.Lock()
		defer mu1.Unlock()

		time.Sleep(1 * time.Second) // شبیه‌سازی پردازش

		mu2.Lock()
		defer mu2.Unlock()
		done <- struct{}{}
	}()

	go func() {
		mu2.Lock()
		defer mu2.Unlock()

		time.Sleep(1 * time.Second) // شبیه‌سازی پردازش

		mu1.Lock()
		defer mu1.Unlock()
		done <- struct{}{}
	}()

	select {
	case <-done:
		fmt.Println("اجرا با موفقیت به پایان رسید")
	case <-time.After(5 * time.Second):
		fmt.Println("بن‌بست رخ داد، اجرا متوقف شد")
	}
}

func main() {
	deadlockRecoveryExample()
}
```

```shell
$ go run main.go
بن‌بست رخ داد، اجرا متوقف شد
```


در کد بالا، دو گوروتین برای دسترسی به منابع `mu1` و `mu2` با یکدیگر رقابت می‌کنند که می‌تواند باعث بن‌بست شود. با استفاده از کانال و تایمر، می‌توان بن‌بست را شناسایی و به طور مناسب مدیریت کرد.

## 9.4.19.4 کاربردها


- **مدیریت منابع در سیستم‌های همزمان:** برای جلوگیری از بن‌بست هنگام استفاده از منابع مشترک.
- **پایگاه داده‌های توزیع‌شده:** شناسایی و بازیابی تراکنش‌هایی که در وضعیت بن‌بست قرار گرفته‌اند.
- **سیستم‌های بلادرنگ:** برای اطمینان از اینکه بن‌بست‌ها باعث تأخیر غیرقابل قبول در اجرا نمی‌شوند.
- **اشکال‌زدایی:** استفاده از این الگو برای یافتن نقاط ضعف در طراحی همزمانی برنامه.
