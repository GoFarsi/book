---
title: 9.4.10 الگو Monitor
slug: go-concurrency-pattern-monitor
weight: 177010
mermaid: "true"
---


## 9.4.10.1 توضیحات

الگوی **مانیتور (Monitor Pattern)** یکی از مفاهیم کلیدی در طراحی سیستم‌های همزمان است که هدف آن فراهم کردن مکانیزمی برای مدیریت ایمن و هماهنگ دسترسی چندین goroutine به یک منبع یا وضعیت مشترک است. این الگو به گونه‌ای طراحی شده که goroutineها بتوانند زمانی که منتظر وقوع یک شرط خاص (مثلاً آماده شدن داده یا تغییر وضعیت یک منبع) هستند، بدون مصرف بیهوده منابع (مانند CPU) یا بلاک شدن کل برنامه، به حالت خواب بروند و به محض برقرار شدن شرط، از خواب بیدار شوند و ادامه اجرا دهند. این رفتار دقیقاً چیزی است که در زبان Go می‌توان با کمک ساختار **sync.Cond** پیاده‌سازی کرد.

ساختار **sync.Cond** در[ پکیج sync](https://pkg.go.dev/sync#Cond) زبان Go، ابزاری قدرتمند برای پیاده‌سازی این الگو است. یک شیء Cond روی یک lock (مانند sync.Mutex یا sync.RWMutex) ساخته می‌شود و سه متد کلیدی دارد:

- `Wait()` که goroutine جاری را به حالت خواب می‌برد تا زمانی که از طریق سیگنال بیدار شود؛
- `Signal()` که یکی از goroutineهای منتظر را بیدار می‌کند؛
- `Broadcast()` که همه‌ی goroutineهای منتظر را بیدار می‌کند.  

هنگامی که goroutine شرط مورد نظرش برقرار نشده، متد Wait را صدا می‌زند و lock را به طور موقت آزاد می‌کند تا دیگران هم بتوانند منبع مشترک را تغییر دهند. پس از دریافت سیگنال و بیدار شدن، دوباره lock را به دست می‌گیرد و شرط را بررسی می‌کند. این روش بسیار ایمن، سریع و idiomatic است و از busy waiting (حلقه‌ی بی‌پایان با مصرف CPU) جلوگیری می‌کند.

الگوی مانیتور با استفاده از sync.Cond معمولاً در سناریوهایی مانند صف‌های تولید-مصرف (زمانی که صف خالی است، مصرف‌کننده منتظر تولید داده می‌ماند)، پیاده‌سازی سیستم‌های صف انتظار (Waiting Queue)، کنترل منابع اشتراکی، یا هرجایی که نیاز به هماهنگی و همزمانی پیشرفته بین goroutineها وجود دارد، استفاده می‌شود. این الگو باعث افزایش پایداری و کارایی سیستم‌های concurrent می‌شود و پیاده‌سازی آن در Go هم ساده و هم بسیار قدرتمند است.

{{< hint info >}}
به نقل از ویکی پدیا :

در برنامه‌نویسی همروند (یا همان برنامه‌نویسی موازی)، **مانیتور** یک ساختار [همگام سازی](https://fa.wikipedia.org/wiki/%D9%87%D9%85%DA%AF%D8%A7%D9%85%E2%80%8C%D8%B3%D8%A7%D8%B2%DB%8C_(%D8%B9%D9%84%D9%88%D9%85_%D8%B1%D8%A7%DB%8C%D8%A7%D9%86%D9%87) "همگام‌سازی (علوم رایانه)") است که به ریسمان ها این امکان را می‌دهد که هم، [انحصار متقابل](https://fa.wikipedia.org/wiki/%D8%A7%D9%86%D8%AD%D8%B5%D8%A7%D8%B1_%D9%85%D8%AA%D9%82%D8%A7%D8%A8%D9%84 "انحصار متقابل") داشته باشند و هم، بتوانند برای یک وضعیت خاص منتظر بمانند (مسدود شوند) تا وضعیت غلط شود. مانیتورها همچنین دارای یک مکانیسم هستند که به ریسمان‌های دیگر، از طریق سیگنال می‌فهمانند که شرایط آنها برآورده شده‌است. یک مانیتور، حاوی یک شئ میوتکس (قفل) و متغیرهای وضعیت است. یک متغیر وضعیت اساساً، ظرفی از [ریسمان](https://fa.wikipedia.org/wiki/%D8%B1%DB%8C%D8%B3%D9%87_(%D8%B1%D8%A7%DB%8C%D8%A7%D9%86%D8%B4) "ریسه (رایانش)") ها است که منتظر یک وضعیت خاص هستند. مانیتورها برای ریسمان‌ها مکانیسمی را فراهم می‌کنند، تا به‌طور موقت، و با هدف منتظر ماندن برای برآورده شدن شرایط خاص، دسترسی انحصاری را رها کنند، و سپس دسترسی انحصاری را مجدداً به دست آورند و کار خود را از سر گیرند.
{{< /hint >}}

## 9.4.10.2 دیاگرام

{{< mermaid >}}
flowchart TD
    A[Goroutine] -->|Check Condition| B{Condition met?}
    B -- Yes --> C[Process / Continue]
    B -- No --> D[Wait sync.Cond]
    D -. Receive Signal .-> E[Wake Up Goroutine]
    E -->|Acquire lock| B
    F[Other Goroutines] -->|Signal/Broadcast| D
{{< /mermaid >}}

## 9.4.10.3 نمونه کد

```go
package main

import (
	"fmt"
	"sync"
)

type Item = int

type Queue struct {
	items  []Item
	closed bool
	*sync.Cond
}

// ایجاد صف جدید
func NewQueue() *Queue {
	return &Queue{
		Cond: sync.NewCond(&sync.Mutex{}),
	}
}

// قرار دادن یک آیتم در صف
func (q *Queue) Put(item Item) error {
	q.L.Lock()
	defer q.L.Unlock()
	if q.closed {
		return fmt.Errorf("queue is closed")
	}
	q.items = append(q.items, item)
	q.Signal() // فقط یکی از منتظرها را بیدار کن (بهینه‌تر)
	return nil
}

// گرفتن n آیتم از صف، یا برگشت آیتم‌های موجود در صورت بسته بودن صف
func (q *Queue) GetMany(n int) ([]Item, error) {
	q.L.Lock()
	defer q.L.Unlock()
	for len(q.items) < n && !q.closed {
		q.Wait()
	}
	if len(q.items) == 0 && q.closed {
		return nil, fmt.Errorf("queue closed and empty")
	}
	// اگر صف بسته شده و آیتم‌هایی باقی مانده است، همان‌ها را بازگردان
	m := n
	if len(q.items) < n {
		m = len(q.items)
	}
	items := q.items[:m:m]
	q.items = q.items[m:]
	return items, nil
}

// بستن صف و بیدار کردن همه goroutineهای منتظر
func (q *Queue) Close() {
	q.L.Lock()
	defer q.L.Unlock()
	q.closed = true
	q.Broadcast() // همه منتظرها را بیدار کن
}

func main() {
	q := NewQueue()
	var wg sync.WaitGroup

	// مصرف‌کننده‌ها
	for n := 10; n > 0; n-- {
		wg.Add(1)
		go func(n int) {
			defer wg.Done()
			for {
				items, err := q.GetMany(n)
				if err != nil {
					break
				}
				fmt.Printf("%2d: %v\n", n, items)
			}
		}(n)
	}

	// تولید داده
	for i := 0; i < 100; i++ {
		_ = q.Put(i)
	}
	q.Close() // صف را پس از تولید داده می‌بندیم

	wg.Wait()
	fmt.Println("All done!")
}
```

```shell
$ go run main.go
 1: [0]
 1: [1]
 1: [2]
 1: [3]
 1: [4]
 1: [5]
 1: [6]
 1: [7]
 1: [8]
 1: [9]
 1: [10]
 1: [11]
 1: [12]
 1: [13]
 7: [14 15 16 17 18 19 20]
 7: [43 44 45 46 47 48 49]
 7: [72 73 74 75 76 77 78]
 7: [79 80 81 82 83 84 85]
 7: [86 87 88 89 90 91 92]
 7: [93 94 95 96 97 98 99]
 5: [50 51 52 53 54]
 9: [55 56 57 58 59 60 61 62 63]
 8: [64 65 66 67 68 69 70 71]
 1: [21]
 2: [25 26]
 3: [22 23 24]
 6: [27 28 29 30 31 32]
10: [33 34 35 36 37 38 39 40 41 42]
All done!
```

در این مثال، یک **صف thread-safe (ایمن برای همزمانی)** با استفاده از الگوی مانیتور (Monitor Pattern) و ابزار قدرتمند `sync.Cond` پیاده‌سازی شده است. این صف، امکان قرار دادن آیتم (توسط تولیدکننده‌ها) و دریافت چند آیتم به صورت همزمان (توسط مصرف‌کننده‌ها) را به‌صورت هماهنگ و ایمن فراهم می‌کند.

در این معماری، متد `Put` برای افزودن آیتم جدید به صف استفاده می‌شود و با هر بار افزودن، یکی از goroutineهای منتظر (مصرف‌کننده‌ها) را با متد `Signal()` بیدار می‌کند تا در صورت آماده بودن شرط (یعنی تعداد آیتم کافی)، کار خود را ادامه دهد. در سمت مصرف‌کننده، هر goroutine با متد `GetMany(n)` منتظر می‌ماند تا حداقل n آیتم در صف موجود شود. اگر این شرط برقرار نباشد و صف همچنان باز باشد، مصرف‌کننده با متد `Wait()` به حالت خواب می‌رود تا زمانی که داده کافی توسط تولیدکننده وارد صف شود یا صف بسته شود.

نکته کلیدی اینجاست که بعد از اتمام تولید داده (در این مثال پس از افزودن ۱۰۰ آیتم)، با فراخوانی متد `Close()` صف بسته می‌شود و همه goroutineهای منتظر با `Broadcast()` بیدار می‌شوند. این کار تضمین می‌کند هیچ مصرف‌کننده‌ای به صورت بی‌نهایت در حالت انتظار نخواهد ماند و همگی graceful و تمیز به کار خود پایان می‌دهند. اگر صف بسته و خالی باشد، مصرف‌کننده‌ها پیام خطا دریافت و خارج می‌شوند.

در نهایت با استفاده از یک `sync.WaitGroup` اطمینان حاصل می‌شود که تمام goroutineها (مصرف‌کننده‌ها) پس از اتمام واقعی پردازش و بدون هیچ‌گونه goroutine leak یا بن‌بست (deadlock) خاتمه می‌یابند. این معماری، هم مقیاس‌پذیر، هم ایمن، و هم idiomatic در دنیای Go است و می‌تواند در سناریوهای تولید-مصرف، صف‌های پردازش موازی، و حتی سیستم‌های real-time به‌سادگی استفاده شود.

## 9.4.10.4 کاربردها

- **پردازش دسته‌ای داده (Batch Processing):** زمانی که نیاز دارید تعداد مشخصی داده (مثلاً ۱۰ آیتم) جمع‌آوری و سپس به صورت یکجا پردازش شوند، می‌توانید با استفاده از sync.Cond منتظر بمانید تا شرط "تعداد کافی آیتم در صف" برقرار شود. سپس با سیگنال به مصرف‌کننده‌ها اطلاع می‌دهید که اکنون دسته داده آماده پردازش است و می‌توانند ادامه دهند.
- **انتظار برای وقوع رویدادهای خارجی:** اگر لازم است goroutineها تا وقوع یک رویداد خاص (مثل تکمیل عملیات در سرویس خارجی، رسیدن پیام از سرور، پایان کار background یا حتی فشار یک دکمه توسط کاربر) متوقف بمانند، با Cond می‌توانید آن‌ها را به خواب بفرستید تا زمانی که سیگنال یا Broadcast داده شود و همه با هم یا یکی یکی بیدار شوند.
- **کنترل جریان و هماهنگی اجرای goroutineها (Flow Control & Synchronization):** در مواقعی که لازم است فقط تعداد مشخصی از goroutineها همزمان وارد بخش بحرانی شوند یا اجرای بخشی از کد فقط پس از رخداد شرایط خاص آغاز شود، می‌توانید با کمک sync.Cond و شرط‌های سفارشی، کنترل کامل اجرای concurrent را داشته باشید (مثلاً: شروع تمام همزمان، یا توقف گروهی هنگام رسیدن به نقطه sink).
- **همگام‌سازی و کنترل قفل‌های منابع مشترک:** اگر دسترسی به یک منبع (مثلاً یک بافر یا شیء مشترک) باید با شرایط خاصی صورت گیرد (مثلاً تا زمانی که منبع خالی/پر نشده، اجازه دسترسی داده نشود)، می‌توانید با Cond گوروتین‌های منتظر را تا زمان آزاد شدن قفل یا فراهم شدن شرط، به خواب ببرید و سپس با Signal/Broadcast آنها را بیدار کنید.
- **همگام‌سازی پایان و شروع عملیات چندگانه (Barrier Synchronization):** زمانی که چندین goroutine باید همگی یک مرحله کار را به اتمام برسانند تا مرحله بعدی آغاز شود (مانند الگوی barrier)، می‌توان با Cond به هر goroutine پس از اتمام کار سیگنال داد و منتظر ماند تا همه به نقطه هماهنگ برسند، سپس اجرای مرحله بعدی را شروع کرد.
- **انتظار پویا برای داده یا منبع:** در صف‌های message queue، اگر مصرف‌کننده‌ها به داده نیاز دارند اما صف خالی است، به جای busy waiting، می‌توانند تا زمان ورود داده با Wait منتظر بمانند و تولیدکننده با Signal مصرف‌کننده‌ها را بیدار کند. این کار کارایی و مصرف منابع را بهبود می‌دهد.
