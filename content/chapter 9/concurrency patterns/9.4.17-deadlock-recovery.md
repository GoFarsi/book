---
title: 9.4.17 الگو Deadlock Recovery
slug: go-concurrency-pattern-deadlock-recovery
weight: 177017
mermaid: "true"
---


## 9.4.17.1 توضیحات

الگوی **بازیابی از بن‌بست (Deadlock Recovery)** یکی از الگوهای مهم در طراحی سیستم‌های همزمان (concurrent systems) است که به ما کمک می‌کند از شرایطی خطرناک به نام _بن‌بست_ (deadlock) خارج شویم. در شرایط بن‌بست، دو یا چند گوروتین (یا نخ) در حالتی گیر می‌افتند که هر یک منتظر آزاد شدن منبعی است که توسط دیگری نگه داشته شده؛ در نتیجه هیچ‌کدام نمی‌توانند پیش بروند و کل سیستم در حالت توقف (freeze) باقی می‌ماند.

در زبان Go، به دلیل استفاده گسترده از `goroutine` و `channel`، احتمال وقوع بن‌بست در اثر طراحی نادرست بالا است. مثلاً اگر گوروتینی منتظر داده روی یک کانال بماند، در حالی که گوروتین ارسال‌کننده هرگز اجرا نشود یا مسدود شده باشد، بن‌بست اتفاق می‌افتد. در سیستم‌های واقعی، تشخیص و بازیابی از این وضعیت حیاتی است تا سیستم به‌صورت پیوسته و قابل اطمینان باقی بماند.

الگوی Deadlock Recovery معمولاً شامل سه مرحله است:  
۱. **نظارت (Monitoring):** سیستم باید به‌صورت مداوم وضعیت گوروتین‌ها یا منابع مشترک را بررسی کند. این کار می‌تواند با استفاده از تایم‌اوت، لاگ‌گیری، یا ابزارهای profiler مانند `pprof` انجام شود.  
۲. **تشخیص (Detection):** با تجزیه‌وتحلیل رفتار سیستم، مانند گوروتین‌هایی که برای مدت طولانی در حالت مسدود باقی مانده‌اند، می‌توان بن‌بست‌های احتمالی را شناسایی کرد.  
۳. **بازیابی (Recovery):** پس از تشخیص، می‌توان با یکی از روش‌های زیر اقدام به آزادسازی سیستم کرد:

- **تلاش مجدد با backoff** (بازگشت نمایی یا تصادفی)
- **بازتنظیم منابع یا صف‌ها**
- **خاتمه دادن به گوروتین‌های مسدودشده**
- **بازگردانی سیستم به حالت اولیه یا fail-safe**

این الگو به‌ویژه در برنامه‌های **distributed** یا دارای **state حساس** مانند تراکنش‌های مالی، سیستم‌های صف (queue-based systems)، یا پایگاه‌داده‌های درون‌حافظه‌ای اهمیت دارد. اجرای صحیح این الگو باعث حفظ پایداری سیستم در برابر شرایط غیرمنتظره می‌شود، در حالی که غفلت از آن ممکن است به اختلال جدی یا از دست رفتن داده‌ها منجر شود.

## 9.4.17.2 دیاگرام


{{< mermaid >}}
sequenceDiagram
    participant Main
    participant G1 as Goroutine 1
    participant G2 as Goroutine 2
    participant DeadlockChecker as Select with Timeout

    Main->>G1: Start
    Main->>G2: Start

    G1->>mu1: Lock(mu1)
    G2->>mu2: Lock(mu2)

    G1->>mu2: Try Lock(mu2) ❌
    G2->>mu1: Try Lock(mu1) ❌

    Note over G1,G2: بن‌بست (Deadlock) ایجاد شد: G1 منتظر mu2، G2 منتظر mu1

    DeadlockChecker->>DeadlockChecker: wait 3s...
    DeadlockChecker-->>Main: بن‌بست شناسایی شد ✅
{{< /mermaid >}}




## 9.4.17.3 نمونه کد

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

func deadlockRecoveryExample() {
	var mu1, mu2 sync.Mutex
	done := make(chan string, 2)

	// گوروتین اول: تلاش برای گرفتن mu1 سپس mu2
	go func() {
		mu1.Lock()
		fmt.Println("G1: mu1 locked")
		time.Sleep(1 * time.Second)

		mu2.Lock()
		fmt.Println("G1: mu2 locked")
		time.Sleep(500 * time.Millisecond)

		mu2.Unlock()
		mu1.Unlock()
		done <- "G1: done"
	}()

	// گوروتین دوم: تلاش برای گرفتن mu2 سپس mu1
	go func() {
		mu2.Lock()
		fmt.Println("G2: mu2 locked")
		time.Sleep(1 * time.Second)

		mu1.Lock()
		fmt.Println("G2: mu1 locked")
		time.Sleep(500 * time.Millisecond)

		mu1.Unlock()
		mu2.Unlock()
		done <- "G2: done"
	}()

	// انتظار برای پیام از گوروتین‌ها یا تشخیص بن‌بست
	select {
	case msg := <-done:
		fmt.Println("✅ موفقیت:", msg)
	case <-time.After(3 * time.Second):
		fmt.Println("❌ بن‌بست شناسایی شد: یکی از گوروتین‌ها قفل شده است")
	}
}

func main() {
	deadlockRecoveryExample()
}
```

```shell
$ go run main.go
G1: mu1 locked
G2: mu2 locked
❌ بن‌بست شناسایی شد: یکی از گوروتین‌ها قفل شده است
```


در این مثال، یک سناریوی کلاسیک از **بن‌بست (Deadlock)** در زبان Go شبیه‌سازی شده و با استفاده از مکانیزم `select` و `time.After`، وقوع آن تشخیص داده می‌شود. هدف این کد، نشان دادن چگونگی رخ دادن بن‌بست بین دو goroutine است که هر کدام سعی می‌کنند منابع مشترکی را قفل کنند، اما به دلیل ترتیب متفاوت در قفل‌گیری، در حالت انتظار دائمی قرار می‌گیرند.

در ابتدا، دو شیء قفل `mu1` و `mu2` از نوع `sync.Mutex` تعریف می‌شود. سپس دو goroutine راه‌اندازی می‌شوند. گوروتین اول (`G1`) ابتدا `mu1` را قفل کرده و پس از کمی توقف، سعی می‌کند `mu2` را نیز قفل کند. در مقابل، گوروتین دوم (`G2`) ابتدا `mu2` را قفل کرده و پس از کمی توقف، سعی در قفل کردن `mu1` دارد. به این ترتیب، هر کدام منتظر آزاد شدن قفلی هستند که در دست دیگری است و هیچ‌کدام نمی‌توانند ادامه دهند، در نتیجه **بن‌بست واقعی** رخ می‌دهد.

در بخش `main`، یک `select` برای خواندن پیام از کانال `done` تعریف شده که انتظار دارد یکی از goroutineها پس از انجام کار، پیامی ارسال کند. اما چون هر دو گوروتین در وضعیت قفل گیر افتاده‌اند و هیچ‌کدام به پایان نمی‌رسند، کانال `done` خالی می‌ماند. در نتیجه پس از ۳ ثانیه، بخش `select` وارد مسیر `time.After` می‌شود و پیام "بن‌بست شناسایی شد" چاپ می‌گردد.

این پیاده‌سازی ساده ولی گویا، نحوه وقوع بن‌بست، اهمیت ترتیب قفل‌گیری منابع، و روش تشخیص آن از طریق time-based watchdog را نشان می‌دهد. چنین مکانیزمی در سیستم‌های حساس به همزمانی بسیار ضروری است، چون بن‌بست می‌تواند کل سیستم را متوقف و ناپایدار کند. برای پیشگیری، طراحی قفل‌گیری منظم، استفاده از تایم‌اوت، context، و حتی الگوریتم‌هایی مانند TryLock یا timeout-based locking توصیه می‌شود.

## 9.4.17.4 کاربردها


- **مدیریت منابع در برنامه‌های همزمان (Concurrent Resource Management):**  
    در سیستم‌هایی که گوروتین‌ها یا نخ‌ها به منابع مشترکی مانند فایل‌ها، حافظه، یا کانکشن‌های شبکه دسترسی دارند، استفاده از این الگو برای جلوگیری یا بازیابی از بن‌بست هنگام قفل‌گذاری (locking) منابع حیاتی است. با استفاده از تشخیص زمان‌محور، تلاش مجدد یا اولویت‌بندی دسترسی می‌توان از توقف کامل سیستم جلوگیری کرد.
- **پایگاه‌داده‌های توزیع‌شده و سیستم‌های تراکنشی (Distributed Databases & Transactions):**  
    در محیط‌های توزیع‌شده مانند دیتابیس‌های چندگره‌ای یا سیستم‌های ACID، تراکنش‌هایی که منتظر منابع قفل‌شده توسط سایر تراکنش‌ها هستند، ممکن است در حالت بن‌بست باقی بمانند. این الگو با تشخیص بن‌بست‌ها و اعمال سیاست‌هایی مانند **abort و retry** یا **rollback**، پایداری و در دسترس بودن سیستم را تضمین می‌کند.
- **سیستم‌های بلادرنگ و حساس به زمان (Real-Time Systems):**  
    در سیستم‌های بلادرنگ (مانند سامانه‌های کنترل صنعتی یا رباتیک)، حتی تأخیر جزئی می‌تواند بحرانی باشد. استفاده از الگوی بازیابی از بن‌بست باعث می‌شود سیستم بتواند به‌جای توقف کامل، در زمان محدود وضعیت را تشخیص داده و به روش fail-safe ادامه دهد.
- **اشکال‌زدایی و تحلیل همزمانی (Concurrency Debugging & Analysis):**  
    این الگو به توسعه‌دهندگان کمک می‌کند تا طراحی همزمانی برنامه را زیر نظر بگیرند و نقاطی که امکان وقوع بن‌بست دارند را شناسایی کنند. با ابزارهایی مثل `pprof`, `trace` و تحلیل کانال‌ها می‌توان مسیرهای اجرای بن‌بست‌زا را شناسایی و بازطراحی کرد.
