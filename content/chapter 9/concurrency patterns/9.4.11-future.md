---
title: 9.4.11 الگو Future
slug: go-concurrency-pattern-future
weight: 177011
mermaid: "true"
---


## 9.4.11.1 توضیحات

الگوی **Future** (یا **Promise**) یکی از الگوهای مهم و کاربردی در طراحی سیستم‌های ناهمزمان (asynchronous) است که در زبان Go نیز، اگرچه به صورت مستقیم در کتابخانه استاندارد وجود ندارد، اما می‌توان با استفاده از ابزارهای زبان مانند goroutine و channel، به‌سادگی آن را پیاده‌سازی کرد. هدف این الگو این است که یک "آبجکت" یا واسط به برنامه‌نویس داده شود که نماینده نتیجه یک عملیات (مانند درخواست شبکه یا محاسبه سنگین) است—حتی اگر آن عملیات هنوز به پایان نرسیده باشد.

در عمل، وقتی عملیاتی به صورت asynchronous آغاز می‌شود، به جای اینکه فوراً منتظر نتیجه بمانیم (و اجرای برنامه را بلاک کنیم)، یک مقدار از نوع Future دریافت می‌کنیم. این Future به عنوان placeholder یا وعده‌ای برای تحویل نتیجه نهایی به کار می‌رود. در پس‌زمینه، عملیات اصلی (مثلاً دریافت داده از API یا خواندن از دیسک) با یک goroutine انجام می‌شود و زمانی که به پایان رسید، نتیجه در Future ذخیره و آماده دسترسی می‌شود. هر زمان که برنامه به نتیجه نیاز داشته باشد، می‌تواند روی Future فراخوانی انجام دهد (مثلاً با خواندن از یک channel یا متد Get/Result)؛ اگر نتیجه هنوز آماده نشده باشد، برنامه به طور بلاک تا تکمیل عملیات منتظر می‌ماند و بلافاصله پس از آماده‌شدن داده، ادامه اجرا انجام می‌شود.

مزیت کلیدی الگوی Future در Go، جداسازی منطق اجرای عملیات ناهمزمان از منطق مصرف‌کننده آن است. این کار خوانایی و مدیریت خطا را ساده‌تر، مدیریت منابع را بهینه‌تر و کد را مقیاس‌پذیرتر می‌کند. با استفاده از این الگو می‌توان معماری‌های مدرن با پردازش موازی و کارآمد ساخت، بدون آنکه درگیر callback hell یا کد پیچیده شوید. همچنین Future پایه بسیاری از فریمورک‌ها و ابزارهای concurrent در زبان‌های دیگر (مانند Java, Rust, JavaScript) نیز هست و در Go، idiomatic ترین پیاده‌سازی معمولاً مبتنی بر channel و goroutine است.

## 9.4.11.2 دیاگرام

{{< mermaid >}}
flowchart TD
    A[Start async operation] --> B[Return Future object]
    B -- "Do other work" --> C[Need result]
    C --> D[Wait for result from Future]
    D --> E[Receive final result and continue]
    A -- "Run in background" --> F[Async task completes]
    F -- "Set result in Future" --> D
{{< /mermaid >}}

## 9.4.11.3 نمونه کد

{{< play >}}
package main

import (
	"errors"
	"fmt"
	"sync"
	"time"
)

type FutureInt struct {
	once   sync.Once
	result int
	err    error
	done   chan struct{}
}

// Get با بلاک تا تکمیل شدن عملیات صبر می‌کند و نتیجه و خطا را برمی‌گرداند
func (f *FutureInt) Get() (int, error) {
	<-f.done
	return f.result, f.err
}

// GetWithTimeout با تایم‌اوت مشخص منتظر نتیجه می‌ماند
func (f *FutureInt) GetWithTimeout(timeout time.Duration) (int, error) {
	select {
	case <-f.done:
		return f.result, f.err
	case <-time.After(timeout):
		return 0, errors.New("timeout waiting for future")
	}
}

func longRunningTask() *FutureInt {
	f := &FutureInt{done: make(chan struct{})}
	go func() {
		defer close(f.done)
		// شبیه‌سازی کار زمان‌بر و گاهی بروز خطا
		time.Sleep(time.Second)
		if time.Now().Unix()%2 == 0 {
			f.result = 42
			f.err = nil
		} else {
			f.result = 0
			f.err = errors.New("unexpected error")
		}
	}()
	return f
}

func main() {
	f := longRunningTask()
	fmt.Println("Do something else while waiting for result...")
	// دریافت نتیجه با مدیریت خطا
	result, err := f.Get()
	if err != nil {
		fmt.Println("Future failed:", err)
		return
	}
	fmt.Println("The answer is:", result)

	// نمونه با timeout
	f2 := longRunningTask()
	result2, err2 := f2.GetWithTimeout(500 * time.Millisecond)
	if err2 != nil {
		fmt.Println("Timeout error:", err2)
	} else {
		fmt.Println("Result with timeout:", result2)
	}
}
{{< /play >}}

در این مثال از الگوی **Future** در Go، ما یک ساختار کامل و قابل اطمینان برای مدیریت نتیجه‌ی عملیات ناهمزمان (asynchronous) و دریافت امن و حرفه‌ای نتیجه، همراه با مدیریت خطا و قابلیت timeout پیاده‌سازی کرده‌ایم.

در ساختار `FutureInt`، یک کانال از نوع `chan struct{}` با نام `done` وجود دارد که سیگنال اتمام عملیات را ارسال می‌کند. مقدار نتیجه (`result`) و خطا (`err`) به صورت فیلدهای struct نگهداری می‌شوند. زمانی که عملیات ناهمزمان (در goroutine مربوط به تابع `longRunningTask`) به پایان می‌رسد، کانال `done` بسته می‌شود تا هر goroutine منتظر یا فراخوانی کننده‌ی Get یا GetWithTimeout متوجه آماده‌شدن نتیجه شود.

متد `Get` تا زمانی که عملیات کامل نشده منتظر می‌ماند و پس از اتمام، مقدار نهایی و خطا را بازمی‌گرداند. این کار با خواندن از کانال `done` انجام می‌شود، که هم thread-safe و هم idiomatic است. متد `GetWithTimeout` علاوه بر انتظار برای تکمیل، این امکان را می‌دهد که اگر نتیجه طی زمان معینی آماده نشد، با پیغام خطای timeout عملیات را مدیریت کنید—این قابلیت در سناریوهای real-time و حساس به تاخیر اهمیت زیادی دارد.

در تابع `main`، ابتدا یک Future ساخته می‌شود و قبل از فراخوانی نتیجه می‌توان هر کار دیگری انجام داد (این همان مزیت کلیدی Future است). سپس با صدا زدن Get، نتیجه و خطا را دریافت و مدیریت می‌کنیم. همچنین نمونه‌ای از دریافت نتیجه با timeout هم آورده شده است تا نحوه‌ی مدیریت عملیات طولانی یا گیر افتاده نیز مشخص باشد.

این معماری علاوه بر ایمنی همزمانی، جداسازی وظایف (تولید و مصرف نتیجه)، پشتیبانی از خطا و timeout، به سادگی قابل توسعه و استفاده در پروژه‌های واقعی و تولیدی است و تجربه برنامه‌نویسی concurrent را بسیار حرفه‌ای‌تر و قابل کنترل‌تر می‌کند.

## 9.4.11.4 کاربردها

- **درخواست‌های شبکه (Asynchronous Network Requests):**
    در زمانی که نیاز به ارسال درخواست به یک سرویس خارجی یا API دارید، الگوی Future کمک می‌کند که بتوانید درخواست را به صورت ناهمزمان ارسال و به محض آماده شدن پاسخ، آن را دریافت کنید. این کار باعث می‌شود بتوانید بدون مسدود کردن برنامه، کارهای دیگری انجام دهید تا زمانی که نتیجه آماده شود. این تکنیک برای توسعه کلاینت‌های HTTP، REST، GraphQL و حتی WebSocket بسیار کاربردی است.
- **کوئری‌های پایگاه داده (Async Database Querying):**
    هنگام اجرای کوئری‌های سنگین یا زمان‌بر روی دیتابیس، Future اجازه می‌دهد کوئری را به صورت ناهمزمان آغاز کنید و هر زمان که نتیجه واقعاً لازم بود، آن را دریافت کنید. این رویکرد برای برنامه‌هایی که باید همزمان چند کوئری مختلف را به دیتابیس ارسال کنند (مانند جمع‌آوری داده از چند جدول یا سرور متفاوت) بسیار مفید است و latency کلی برنامه را کاهش می‌دهد.
- **محاسبات سنگین و پردازش موازی:**
    اگر در برنامه نیاز به انجام محاسبات CPU-intensive (مانند تجزیه داده، پردازش تصویر، رمزنگاری و ...) دارید، می‌توانید هر task را در یک Future قرار دهید و نتایج را در صورت نیاز، به صورت همزمان و بدون بلاک شدن منتظر بمانید. این کار باعث بهبود performance و پاسخگویی سیستم خواهد شد.
- **ترکیب و همگام‌سازی عملیات مستقل (Composition and Synchronization):**
    می‌توانید چندین Future ایجاد کنید و به طور موازی آن‌ها را اجرا نمایید، سپس به صورت هماهنگ (مثلاً با WaitGroup یا channel) منتظر دریافت همه نتایج باشید (pattern معروف به Fan-In). این رویکرد برای جمع‌آوری نتایج عملیات‌های موازی (مانند دانلود چند فایل یا جمع‌آوری داده از چند سرویس) ایده‌آل است.
- **پردازش رویداد و message queue:**
    در معماری‌هایی مانند صف پیام یا پردازش رویداد (event-driven)، هر message را می‌توان به عنوان یک Future مدیریت کرد و پس از پایان پردازش، نتیجه یا پاسخ را برای ادامه کار استفاده نمود.
