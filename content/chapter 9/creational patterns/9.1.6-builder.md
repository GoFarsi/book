---
title: '9.1.6 الگو Builder'
slug: go-builder-pattern
weight: 172006
---

### توضیحات

در دنیای طراحی نرم‌افزار، یکی از چالش‌های رایج، **ساخت{{< tooltip text="اشیاء" note="Objects" >}} پیچیده با پارامترهای متعدد و متنوع** است. فرض کنید قصد دارید یک شیء پیکربندی برای اتصال به {{< tooltip text="پایگاه داده" note="Database" >}} بسازید. بسته به نوع پایگاه داده ای که می خواهید (MySQL، PostgreSQL، SQLite و …)، ممکن است به مجموعه‌ای متفاوت از پارامترها نیاز داشته باشید: نام کاربری و گذرواژه، میزبان و پورت، نام پایگاه داده یا حتی مسیر فایل. اگر بخواهیم همه‌ی این موارد را با یک {{< tooltip text="سازنده" note="Constructor" >}}  ساده مدیریت کنیم، به زودی با توابعی پر از پارامترهای اختیاری و ترتیب‌های گیج‌کننده مواجه خواهیم شد.

اینجاست که **الگوی Builder** وارد عمل می‌شود. این الگو با تفکیک فرآیند ساخت از شیء نهایی، به ما اجازه می‌دهد تا اشیاء را به صورت **گام به گام، خوانا و قابل انعطاف** بسازیم. با استفاده از این الگو نگهداری کد ساده‌تر است و آن را برای توسعه‌دهندگان دیگر قابل فهم‌تر می‌کند.

{{< hint info >}}
الگوی بیلدر وقتی کمک کننده است که بخواهید یک شیء پیچیده با پارامترهای زیاد را مرحله به مرحله و خواناتر بسازید، بدون اینکه درگیر سازنده‌های طولانی و گیج‌کننده بشوید.
{{< /hint >}}

### دیاگرام

{{< uml url="<https://viewer.diagrams.net/?tags=%7B%7D&lightbox=1&highlight=0000ff&edit=_blank&layers=1&nav=1&title=Untitled%20Diagram.drawio&dark=auto#R%3Cmxfile%3E%3Cdiagram%20name%3D%22Page-1%22%20id%3D%22ObbL-NJkyKtefCw91bFE%22%3E1VpZk5tIEv41HTH7MBGcbfdjSxxCqypaCITgjcsIxCFLSBy%2FfrMKkGi327Hu8cR4IqZHVNaVlfnlVa4Hfp436sk77lEZRtkDx4TNAy89cBzLCBz8EErbUx7ZgRCfknAYdCdski4aZw7USxJG51cDq7LMquT4mhiURREF1SuadzqV9ethX8rs9a5HL47eEDaBl72l2klY7XvqZ5G50xdREu%2FHnVlm6Mm9cfBAOO%2B9sKwnJF5%2B4Oensqz6r7yZRxkR3iiXfp7yTu%2BNsVNUVN%2BZYJ2jk%2B6nRCYck3k%2B6IUOGqZlXlFZeSZ5lTfQP80euMcHjm%2BeH3j4ZOh%2Fj18vhL9ZSMbdWg%2F886veB4E5V96puuTZgzgvvKAqTzAAeUlB2sBjlQTJEbYEqjSbXZIsjE7f65qXxZckJj3kjy7AMX%2FCTnHVc3WfDQxQNnBU34h%2FhKfkGp3%2B839P3kQVERQ9jdK3X7zzuS5P4ZS2KM8VrEmWJSPKUzXtlWbYy6MpRUmy6IUAYELbbFbEPMgaUz5%2BzB9t%2F%2FGfH08ahDbOOUXV5VS87qH6iMAeTv1St47pSoPE%2BlVALPD%2F27g%2FULtZr%2B7nWa%2BSKqJ8gfKjIhxUP8EEN%2F8Bnr6UJzCQ9xF1vsbTpe7rfOoxfDOD%2BiynQsXz213d5iyPzbmp%2FMnfzOtmNueqHU0aDPFIPpOc2v6sKFeDebDQAvgAIr3sOUviAmhVeQSqdz723uVL0kSw9YxOfh6pzEiBb2oq%2FHPf5BR6klkD4uHmLwvMue1M8O3mEnRM4i0MJpDK64oP%2BbAVedSK1yAPrih9rtH8qQvzINEW%2B8pXxU4v9mfPFk8vm2UZLoxaTz5fYRa%2FKoJulT%2B1bvu50c2DuOL7cVoyS31OZFxbZCzeEH11a0W7WQbzGXe3Z1Yc7oJWi11VYZwNe%2FBspQhypVrtDDFQrSctw4q13SrmASuwVunaWeEt1k9aihi8mwlAq4N827m7JedaSheo2zRUlvtQza6wxwX2zmBMFy6ys2uCvrjsEKrxIzYdLljEnzx1e3S5PaMP6%2Bnccu9wFfDwxPr5%2BlFjXNU4wF96Bhm4WVDgo88JsL98QRstDvMsC5nlNZKYBM2fa02yOJw8d1iyYHx4dBdG%2BbLRWJy6dTTX4ih%2FuvqWcnGV2d5PmcSH8%2Fp5lkcbDfTzohqZW6DrS9oUwx%2Fj7QzgXMSOnV1e5k9DW%2FgMp07D%2BSz37OYMO6RIAm3BH5yW0lb2U%2B3Y%2BBguDsDt82XoTzR1n3l2WIaEYzPmVulawNJ6yi2RqgC%2FjU44Bqnh7nDRzZjBc43wRjSbaQvMRHZDNAnSXV49znrUOlmANRtdqkZaNUoczQVW5zEDkj25oGlnh0tnt2yd3eERb4R6JVnAI5Fy3MDeLUpgb0kD3rUW%2BBHRaz6AL9oH0hYYnMbA82ciwfnTt5KT14clCxI5uDvt84o3jqEKXKdN69qY0VT36Kv1k5ag%2Bi4hSqt8fgZYyBgiAeC%2B74edR8xQCUnOBUs9R8NJgauYnIJilGDkH5IgYHB9wZtRioBvmP9XJYmvfu4e3a6%2BgoUxvmqRkYtl5vDr2M2zsw%2Bo0rrnm6wobc5eA1VJYRUR%2BKpX6Q2pE3uWBbK%2FLq0ZoPOebTAerEURCL%2FY1BrCO8zn9Y0g9uMon2pz9HMrDqh3AY9RDBIyy7SXpCxMpDasXAIX1ieY0%2Fpcla1sYx9w%2B31QLPeRWbLA4ZlIVG%2FJ7jJwZ7V3SQ7fJqEH4io9DPZzaAlucUoQ4Qg61XR9dTvhM3jb1FfBO4G3BUm0IDuQBniAYh1%2F064AXXt3fvOINWiY8cCOYdyF2KxpK0c%2Fod5iYWTR4j25P13COZs7Nnv0iQcoMKyOqoDbtp7tEIxfyW4Blz0Sv4hMOAHYhZ%2BHjCcrB6%2FYdmS3oLeBiwuSCNWtEMrDGOI9bjgnvo54mUBYpRR3ycuB3Xu2QOyN8Ej1tD37alYHnBU7fDzadUqty0QUqbeTMFZrmEuVnCQoRotaioNvunnzUX96gqieQd93ne56f6aD78PmOVmBHkCGjDefHcDiMEq1MwIvjjczRL7Bisk31jd1CwhjNbnu8O2bAX9UM%2Fqc0sWV5HSAn9g0tXYlrQX6LSF2oCc3r5KLYC9EOh%2Bw9PZj%2BAlVwMe%2FFD9g23OBRxJqtPQe8UieAF4o88HSgwXONBULY4RweDoPrE0QsYmaMfqRiAgIUtDBIX6mjQZfEhSHAU0f1UgDEjVKTQWfdaCoaHXTAV9qdWhAEuo0QMGBRZ0MCDlA%2B5m5tSlKUI1HfntkdShFtzUAgR3q4rGN36zZr9G9PfPbfOdnLWTFBdRWg9jhmn3AI9D8DPyicQQtQj4hMtridXtl7zPHJto3IOuSq2%2FwCFIy5utiC%2FZgZMGAu2%2FixcTaJ7G1Jecb4gHVH0po%2FGqpx%2Bi%2FP3TOSabD47aPL6AjbnXDoVUPseUfthCcojGTaFDbR2%2FCNaCxRR1IJn2T3YzedojeYCtnyBM6wMZrTzCffdNmGbC3M%2BwAeYWxX%2B1eaxnmT3dK3uZPGGwN9Jh%2Bk2Gm8S3P6D25Rj19b4fD9wci9zRHgApilFKNk5uUIBJbk0jcUD%2FyTr5HNeVC3QHnE4lPgDN3qx3OAsjNiX2RGgbaxyi3SK5CMHmGmqYI1f3MVY9swK8J%2FzTj9mm9RDRhoH4M4c3phqy6G6MdxXEaQ7YR1GDXEDMnlpKSDAvQIP1tNsk9XQDXhZa%2BrSUmnnOSoWnCPddZUg%2FcWwyNy8P3h7zqJHMO6kFKjG4%2B%2F27WaDoDztYi9Rs0j4bKiubWxLMZ8lICpIAcg7%2FdFodMvP3dPCoaM3bpUP%2Belmhxd4wFY%2BYhQL4%2FZh7f1DnvWmHOZgGP9y5nvWdpFam1hozr%2BxnZnGm%2F41trn2tEFyx0IqVRC8Dx7Ar1I0OyQQSZwkqSa%2BBeIH4W8gIGtXWDJKjvJLDWOckl0BmZMuQPMdE%2B5BKIJ3P0Yc7Pa13%2B9Jdqr%2BZeV9EaQEApPYk4VqfIfBYHbse6anKiX46h7ucxJHcjzlF6GDAkk%2BjT4g6RuKy7u3Cq1dJdLI9hvm3%2Fa%2F5LMMXgFiwidbgRU9iEaqkj9wQjpiwSu0jFO2KKRZt%2Bzu%2BIKasZuL1h6n6i3wFTWo021AfT2KqPGYKJoHqQBdxZyUuGs1Aht51avGpnprsz1iSihNxT686fr5oC%2FfL%2BCntN488vjZvoA3XeQXx7KlI1yzWCmNqfanYNoJodTgXYFfe%2BbY1tFaSeWbR6H06pYNOU2aurWj%2BOtJULv44dZu9F0xW5x3ldo%2FyMVX3sJs%2Bc3tKRvCkmeOx0icajhmKzO1xwugafMt7QyeTmi8PSM%2FerLAUJff2j3b%2FprdZ0J7AeYknmATI8h0GSQ%2BtEXwVdbz5i42CZRP%2FdmrtbaczfrfS%2Bz2iluqmNkrj%2BnB%2BzwHfJ5G6AnoX4MfBdk%2FXqDnI68GMHbtgT%2FJjVwhwRsqHx%2FB%2F1Y%2F%2Bw1QGuhttfKol2yMUAV84FgafGtBbvUb8uf01Ugvx3HkLm6qrb9n17097WH%2BrTObLDqz%2B5vRkRTP6Fx4czhgtEcjeog%2BsWvAbknRZEqJqF7PuMUnKrbLFYCs6YZDoS5JxQW2BzDVHJajCZQ3NVMuenK85muPn5lbbOAupGW3%2FF23Ab36KB%2F98DTRA9x6wZbEYbs%2BYGMh7wDwceMp4W%2FDQb5EI8qYJinwf%2BdssWfn%2BVnx5x80N80dvnn816AEdriLVrTpfic48rEqWGNu0H73DrP0z7f772HW7c%2FrInTYM7ptL1DVP0PruvuUZMkfvr6b%2Fw%2FOOYCtj%2B1oDe3Yi3alFaQ6a%2F7nRaU28hx9Lksdp9Ls1dZlpWTTMDy2qOoWod77fE%2FX25tmEqi11KL9tqY0mzL4i3BN80JLMwbNcOlXWnOKGkVBanXLbdWnDTgA0UZYuYahlJsyQoFNW2j8LW1hpbXrpRfuT9xf5LeGi%2BBpwgOtm%2BMCSnMzjxq53tM383mxt55mA%2B7hw27jbFcWPx2RKbxkw3l0K4c4tNqrSupHw1lGyvL4wKca6%2BMlHrK8fCl40MMw0GTyw69tHaSortzRnO7JZfPSvUYN%2FUOYgXxGucmVeZIZeVfah4195uDNZwI2XZWLIx82yFMdilixWX3yoBY3FPs11nfEFytTRtgdF3me0t9jtddhlcZLutdRRdZmvoalUb3VayrdAGedQ7kN8oyxWPOfgljxbIGwjy6oE8Toiadx8AsZN3D2pU5lF1amHI7THW8BJpeIrFj%2B36%2FrBJfHzsafvJoyZeEIcHVcNjqvi29v29EXwMjy3G5uQF0ki6v3aiwydvxnj5fw%3D%3D%3C%2Fdiagram%3E%3C%2Fmxfile%3E>" >}}

### نمونه کد: ساخت پیکربندی پایگاه داده با Builder

وقتش رسیده که یک نمونه‌ی واقعی را ببینیم. در کدی که در ادامه می‌آید، ما یک ساختار `DBConfig` داریم که تنظیمات اتصال به پایگاه داده را نگه می‌دارد. یک **Builder** به نام `DBBuilder` ایجاد کرده‌ایم که به ما اجازه می‌دهد با استفاده از متدهای زنجیره‌ای (`SetUser`, `SetHost`, …) تنها فیلدهای مورد نیاز خود را مقداردهی کنیم و در پایان با فراخوانی `Build()` شیء نهایی را تحویل بگیریم.

<!-- markdownlint-disable MD010 MD037 MD012 -->
{{< play >}}
package main

import (
	"fmt"
	"strings"
)

type DBConfig struct {
	Driver   string
	User     string
	Password string
	Host     string
	Port     int
	DBName   string
	FilePath string
	SSLMode  string
}

type DBBuilder struct {
	config DBConfig
	errs   []string
}

func NewDBBuilder(driver string) *DBBuilder {
	d := strings.ToLower(strings.TrimSpace(driver))
	return &DBBuilder{config: DBConfig{Driver: d}}
}

func (b *DBBuilder) SetUser(user string) *DBBuilder {
	b.config.User = user
	return b
}

func (b *DBBuilder) SetPassword(pass string) *DBBuilder {
	b.config.Password = pass
	return b
}

func (b *DBBuilder) SetHost(host string) *DBBuilder {
	b.config.Host = host
	return b
}

func (b *DBBuilder) SetPort(port int) *DBBuilder {
    b.config.Port = port
    return b
}

func (b *DBBuilder) SetDBName(db string) *DBBuilder {
	b.config.DBName = db
	return b
}

func (b *DBBuilder) SetFilePath(path string) *DBBuilder {
	b.config.FilePath = path
	return b
}

func (b *DBBuilder) SetSSLMode(mode string) *DBBuilder {
	b.config.SSLMode = mode
	return b
}

func (b *DBBuilder) Build() (DBConfig, error) {
    // reset previous validation state to avoid stale errors on repeated Build calls
    b.errs = b.errs[:0]

    switch b.config.Driver {
    case "mysql", "postgres", "postgresql":
        if b.config.User == "" {
            b.errs = append(b.errs, "user is required for SQL drivers")
        }
        if b.config.DBName == "" {
            b.errs = append(b.errs, "dbname is required for SQL drivers")
        }
    case "sqlite":
        if b.config.FilePath == "" {
            b.errs = append(b.errs, "file path is required for sqlite")
        }
    default:
        b.errs = append(b.errs, fmt.Sprintf("unknown driver: %s", b.config.Driver))
    }

    // general validation
    if b.config.Port != 0 && (b.config.Port < 1 || b.config.Port > 65535) {
        b.errs = append(b.errs, "port must be in [1, 65535]")
    }

    if len(b.errs) > 0 {
        return DBConfig{}, fmt.Errorf("invalid configuration: %s", strings.Join(b.errs, "; "))
    }
    return b.config, nil
}

func main() {

	// MySQL Example
	mysqlCfg, err := NewDBBuilder("mysql").
		SetUser("admin").
		SetPassword("s3cr3t").
		SetHost("127.0.0.1").
		SetPort(3306).
		SetDBName("shop").
		Build()

	if err != nil {
		fmt.Println("MySQL build error:", err)
	} else {
		fmt.Printf("MySQL config: %+v\n", mysqlCfg)
	}

	// SQLite example
	sqliteCfg, err := NewDBBuilder("sqlite").
		SetFilePath("/tmp/app.db").
		Build()

	if err != nil {
		fmt.Println("SQLite build error:", err)
	} else {
		fmt.Printf("SQLite config: %+v\n", sqliteCfg)
	}
}

{{< /play >}}
<!-- markdownlint-enable MD010 MD037 MD012 -->

این کد، مفهوم الگوی بیلدر را در Go به شکلی بسیار ساده و شفاف پیاده‌سازی کرده است.
ساختار `DBConfig` شامل تمام فیلدهای لازم اتصال به پایگاه داده مثل نوع درایور، نام کاربری، رمز عبور، هاست، پورت، نام پایگاه داده، مسیر فایل (برای SQLite) و SSLMode است. `DBBuilder` یک سازنده مرحله‌ای است که این فیلدها را به صورت زنجیروار مقداردهی می‌کند.

متدهای `SetUser`، `SetPassword`، `SetHost` و بقیه، امکان پر کردن فیلدها به شکل خوانا و زنجیروار را فراهم می‌کنند. متد `Build` در پایان پیکربندی را اعتبارسنجی می‌کند، برای SQL فیلدهای `User` و `DBName` باید پر شوند، برای SQLite مسیر فایل الزامی است و پورت باید بین ۱ تا ۶۵۵۳۵ باشد. اگر خطایی باشد، ارور باز می‌گردد و در غیر این صورت پیکربندی معتبر تحویل داده می‌شود.

در تابع `main` دو مثال واقعی وجود دارد: یکی برای MySQL که تمام فیلدهای مرتبط پر شده و دیگری برای SQLite که تنها مسیر فایل مشخص شده است. این روش باعث می‌شود کد خوانا، قابل گسترش و ایمن باشد و ساخت پیکربندی‌های مختلف پایگاه داده ساده و منعطف انجام شود. این پیاده‌سازی در عین سادگی نشان می‌دهد که چگونه می‌توان با استفاده از الگوی Builder از پیچیدگی‌های ایجاد اشیای بزرگ و متنوع کاست.

### کاربرد ها

در مواردی که اشیاء ما پارامترهای زیادی دارند و  پیچیده هستند، استفاده از الگوی سازنده به کمک ما می‌آید. در مواردی مثل:

1. کانکشن های دیتابیس
2. فرم یا UI‌های پیچیده
3. {{< tooltip text="لاگر" note="Logger" >}}

### چه زمانی نباید از الگوی Builder استفاده کنیم؟

1. **ساخت اشیاء ساده**

   + اگر شیء شما تنها چند پارامتر ساده دارد و ساخت آن راحت است، Builder پیچیدگی را زیاد می‌کند.

2. **ملاحظات عملکردی**

   + در برنامه‌هایی که {{< tooltip text="کارایی" note="Performance" >}} مهم است، فراخوانی‌های اضافی و ایجاد آبجکت‌های موقت در Builder ممکن است باعث کاهش کارایی شود، به‌ویژه وقتی ساخت شیء مکرر است.

3. **اشیاء immutable و ساده**

   + اگر شیء ثابت و با فیلدهای نهایی است و ساخت آن ساده است، می‌توان از سازنده‌های معمولی یا factory method استفاده کرد.

4. **افزایش پیچیدگی کد**

   + ایجاد یک Builder برای هر شیء پیچیده ممکن است کد را طولانی و پیچیده کند.  
   + اگر شیء نیاز به ساخت مرحله‌ای ندارد، Builder می‌تواند اضافه باشد.

5. **وابستگی زیاد به محصول**

   + اگر Builder و محصول خیلی به هم وابسته باشند، تغییر در محصول نیازمند تغییر در Builder است و انعطاف‌پذیری کاهش می‌یابد.
