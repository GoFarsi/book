---
title: '3.4 پکیج atomic'
slug: go-atomic
weight: 5004
---


**پکیج [sync/atomic](https://pkg.go.dev/sync/atomic)** در زبان Go مجموعه‌ای از توابع سطح پایین (low-level) را برای انجام عملیات خواندن و نوشتن **اتمی (atomic)** روی متغیرهای حافظه فراهم می‌کند. منظور از عملیات اتمیک، عملیاتی است که به طور کامل و یکپارچه توسط CPU انجام می‌شود؛ یعنی هیچ گوروتین، thread یا پردازش دیگری نمی‌تواند مقدار متغیر را بین شروع و پایان یک عملیات اتمیک مشاهده یا تغییر دهد. این ویژگی برای پیاده‌سازی **الگوهای همگام‌سازی سبک و بدون قفل (lock-free synchronization)** و **متغیرهای اشتراکی با دسترسی سریع و ایمن** ضروری است.

#### **مهم‌ترین کاربردها و عملیات:**

- **پیاده‌سازی شمارنده‌های اتمیک (atomic counters):**
    مثلاً افزایش شمارنده تعداد درخواست، جمع یا کم کردن بدون نیاز به Mutex.
- **فلگ‌ها یا وضعیت‌های اشتراکی:**
    تنظیم و خواندن یک فلگ مشترک بین چند goroutine به شکلی که دچار race condition نشود.
- **ساخت primitiveهای همگام‌سازی سفارشی:**
    مثل اسپین‌لاک، قفل ساده، lock-free queue، semaphore سطح پایین و…

#### **متدهای مهم atomic:**

- `atomic.AddInt32 / AddUint64` — جمع یا کم کردن مقدار به صورت اتمیک
- `atomic.LoadInt32 / LoadPointer` — خواندن مقدار به شکل اتمیک
- `atomic.StoreInt32 / StorePointer` — نوشتن مقدار به شکل اتمیک
- `atomic.CompareAndSwapInt32` — عمل مقایسه و جایگزینی اتمیک (CAS)، قلب الگوریتم‌های lock-free
- `atomic.Value` — یک ساختار wrapper برای نگهداری داده با خواندن و نوشتن اتمیک (ایده‌آل برای ساخت cacheهای ساده یا حافظه به اشتراک گذاشته شده)


به مثال زیر توجه کنید :

{{< play >}}
package main

import (
	"fmt"
	"sync"
	"sync/atomic"
)

type Cache struct {
	mu   sync.Mutex
	data map[string]string
}

func (c *Cache) Set(key, value string) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.data[key] = value
}

func (c *Cache) Get(key string) (value string, ok bool) {
	c.mu.Lock()
	defer c.mu.Unlock()
	value, ok = c.data[key]
	return
}

type AtomicCache struct {
	mu   sync.Mutex
	data atomic.Value
}

func (c *AtomicCache) Set(key, value string) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.data.Store(map[string]string{key: value})
}

func (c *AtomicCache) Get(key string) (value string, ok bool) {
	data := c.data.Load().(map[string]string)
	value, ok = data[key]
	return
}

func main() {
	cache := Cache{data: map[string]string{}}
	cache.Set("key", "value")
	fmt.Println(cache.Get("key")) // Output: value, true

	atomicCache := AtomicCache{data: atomic.Value{}}
	atomicCache.Set("key", "value")
	fmt.Println(atomicCache.Get("key")) // Output: value, true
}
{{< /play >}}


در مثال فوق ما یک ساختار به نام Cache داریم که داخلش یک فیلد از نوع map داریم و قصد داریم یکسری اطلاعات را داخل کش بریزیم حال زمانیکه Set/Get می کنیم با استفاده از Mutex اون بخش از عملیات را لاک میکنیم تا جلوی عملیات نوشتن چندین گوروتین برروی یک آدرس حافظه را بگیریم. حال این عملیات رو ما با استفاده از atomic انجام دادیم و همگام سازی داده را بردیم تو سطح خیلی پایین تر در حافظه و با استفاده از atomic.Value که یک اینترفیس است این عملیات را انجام دادیم و این عملیات Set/Get حالت atomic پیدا کرده است.

{{< hint info >}}
**آیا استفاده از atomic نیازمند mutex می باشد یا خیر؟**

در این کد، mutex در متد Set برای جلوگیری از رخ دادن race condition یا داده‌های نامنظم استفاده شده است. بدون mutex، چندین گوروتین ممکن است همزمان به دسترسی و تغییر داده‌های map data بپردازند که موجب رفتار نامنظم و فساد داده می‌شود. با گرفتن mutex قبل از تغییر map data، متد Set اطمینان حاصل می‌کند که تنها یک گوروتین در هر زمان می‌تواند به داده‌ها دسترسی پیدا کند و تداخل داده‌ها را جلوگیری می‌کند.

استفاده از mutex در متد Get نیز مهم است، زیرا این اطمینان را به ما می‌دهد که در هنگام دسترسی به map data، هیچ گوروتین دیگری دارای مجوز تغییر داده‌ها نیست. بدون mutex، یک race condition ممکن است ایجاد شود اگر یک گوروتین دیگر در حال تغییر داده‌های map باشد در حالی که یک گوروتین دیگر سعی در خواندن از آن دارد.

در پیاده‌سازی AtomicCache، یک atomic.Value برای ذخیره map استفاده شده است که به انجام عملیات اتمی روی آن اجازه می‌دهد. با این حال، حتی با استفاده از یک مقدار اتمی، همچنان نیاز به mutex وجود دارد تا فقط یک گوروتین در هر زمان به map دسترسی داشته باشد و تداخل داده‌ها را جلوگیری کند.
{{< /hint >}}

## 3.4.1 نکات و هشدارهای تولیدی (Production Caveats)

- **memory safety:** پکیج atomic از ویژگی‌های سطح پایین CPU استفاده می‌کند و bypass کردن حافظه امن زبان Go را ممکن می‌سازد؛ یعنی اگر به درستی از آن استفاده نکنید، به‌راحتی دچار bugهای عجیب و غیرقابل ردیابی خواهید شد. استفاده اشتباه می‌تواند باعث بروز race condition، memory corruption و مشکلات شدید تولیدی شود.

- **تراز حافظه (memory alignment):** متغیرهایی که به صورت اتمیک تغییر می‌کنند باید به درستی روی حافظه align شوند (مثلاً در ساختار struct کنار سایر داده‌ها قرار نگیرند). بی‌توجهی به این نکته ممکن است باعث crash برنامه در معماری‌های خاص شود.
- **مناسب برای عملیات ساده:** atomic برای primitive data types (int32, int64, pointer, ...)، عملیات ساده و سناریوهایی با هماهنگی حداقلی طراحی شده است؛ اگر منطق پیچیده‌تر دارید یا باید چندین متغیر را همزمان به شکل اتمیک تغییر دهید، از **sync.Mutex** یا سایر ابزارهای همزمانی ایمن Go استفاده کنید.
- **کاملاً lock-free نیست:** گرچه atomic سریع و سبک است، اما فقط برای primitiveها کاملاً lock-free است. برای کار با داده‌های پیچیده یا ساختارهای بزرگ، باید با احتیاط و دانش کافی عمل کنید.
- **atomic.Value** برای داده‌های ساختاری، اما فقط با خواندن و نوشتن کامل؛ عملیات mutate روی داده ذخیره‌شده (مثلاً map یا slice) اتمیک نیست مگر کل value جایگزین شود.
## 3.4.2 برخی از کاربردهای atomic

در زیر چندتا use case برای استفاده از پکیج atomic معرفی کردیم :

1. **پیاده سازی همگام سازی بدون مسدودیت :** پکیج atomic توابع سطح پایینی را برای انجام عملیات حافظه اتمی فراهم می کند که می تواند برای پیاده سازی الگوریتم های همگام سازی غیرمسدود مانند مقایسه و تعویض (CAS) یا بارگذاری لینک/ذخیره شرطی استفاده شود. LL/SC).

2. **پیاده سازی ساختارهای داده با همزمانی سطح (high-concurrency) بالا :** با پکیج atomic می توان برای پیاده سازی ساختارهای داده ای استفاده کرد که برای دسترسی همزمان و اصلاح توسط چندین گوروتین ایمن هستند. به عنوان مثال، می توانید از بسته اتمی برای پیاده سازی نقشه یا صف همزمان استفاده کنید.

3. **پیاده سازی شمارنده (counter) از نوع atomic :** شما با استفاده از پکیج atomic می توانید برای افزایش و کاهش شمارنده ها به صورت اتمی که می تواند برای اجرای مواردی مانند شمارش مرجع یا محدود کردن ratelimit استفاده شود.

## 3.4.3 compare and swap (CAS) در atomic

به مثال زیر توجه کنید :

{{< play >}}
package main

import (
	"fmt"
	"sync"
	"sync/atomic"
	"time"
)

type Server struct {
	active int32 // 0 = inactive, 1 = active
	wg     sync.WaitGroup
}

func (s *Server) Start() {
	if atomic.CompareAndSwapInt32(&s.active, 0, 1) {
		fmt.Println("Server starting...")
		s.wg.Add(1)
		go s.run()
	} else {
		fmt.Println("Server already running")
	}
}

func (s *Server) Stop() {
	if atomic.CompareAndSwapInt32(&s.active, 1, 0) {
		fmt.Println("Server stopping...")
		s.wg.Done()
	} else {
		fmt.Println("Server already stopped")
	}
}

func (s *Server) run() {
	defer fmt.Println("Server stopped")
	
	for atomic.LoadInt32(&s.active) == 1 {
		fmt.Println("Server processing...")
		time.Sleep(500 * time.Millisecond)
	}
}

func (s *Server) IsActive() bool {
	return atomic.LoadInt32(&s.active) == 1
}

func main() {
	server := &Server{}
	
	// Start the server
	server.Start()
	
	// Check status concurrently
	go func() {
		time.Sleep(100 * time.Millisecond)
		fmt.Printf("Server active: %v\n", server.IsActive())
	}()
	
	// Let it run for a bit
	time.Sleep(2 * time.Second)
	
	// Stop the server
	server.Stop()
	
	// Wait for graceful shutdown
	server.wg.Wait()
}
{{< /play >}}

مثال فوق یک نمونه از پیاده‌سازی سرور با قابلیت مدیریت وضعیت و graceful shutdown در زبان Go است. ساختار Server از یک پرچم اتمی active برای نشان دادن وضعیت سرور (فعال/غیرفعال) و یک WaitGroup برای هماهنگی بین گوروتین‌ها استفاده می‌کند. متد Start با استفاده از atomic.CompareAndSwapInt32 به صورت اتمی وضعیت سرور را بررسی و تغییر می‌دهد و از راه‌اندازی مجدد سرور در حال اجرا جلوگیری می‌کند. متد run در یک گوروتین مجزا اجرا شده و با حلقه‌ای که وضعیت active را به صورت اتمی بررسی می‌کند، کار می‌کند تا زمانی که سرور فعال باشد. متد Stop نیز به صورت اتمی وضعیت سرور را تغییر داده و با فراخوانی Done روی WaitGroup، خاتمه سرور را اطلاع می‌دهد. در تابع main، سرور راه‌اندازی شده، وضعیت آن به صورت همزمان بررسی می‌شود و پس از مدت مشخصی، سرور متوقف می‌شود و با Wait برای اتمام graceful shutdown منتظر می‌ماند.

