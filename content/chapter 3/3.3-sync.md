---
title: '3.3 پکیج sync'
slug: go-sync-package
weight: 5003
---

پکیج `sync` یکی از کاربردی ترین پکیج ها در زمینه همزمانی می باشد و یکسری تایپ و توابع برای{{< tooltip text="همگام سازی" note="synchronize" >}} و کنترل دسترسی همزمان به داده های مشترک ارائه می دهد. پرکاربرد ترین ویژگی های این پکیج شامل موارد زیر می شود :

- `Mutex` : با استفاده از این تایپ می توانید آن بخش از داده ای که گوروتین ها بطور همزمان قصد دارند دسترسی داشته باشند را قفل کنید.
- `RWMutex` : با استفاده از این تایپ می توانید به چندین گوروتین اجازه خواندن دهید اما فقط یک گوروتین قابلیت نوشتن در یک زمان مشخص را دارد.
- `WaitGroup`: یک هماهنگ کننده گوروتین می باشد، برای اینکه ترتیب عملیات ها در هنگام همزمانی رعایت شود.
- `Once`: این تایپ تضمین می کند که یک تابع فقط یک بار اجرا شود.
- `Pool`: مجموعه‌ای از آبجکت های موقت که امکان ذخیره و دریافت دارند بدون اینکه بخشی از حافظه را اشغال کنند.
- `Cond`:با استفاده از Cond می توانید چندین گوروتین ایجاد کنید و اجرای فرآیند آن ها را منتظر وقوع یک رویداد قرار دهید.

{{< hint info >}}
توجه کنید که پکیج `sync` فقط و فقط برای مدیریت و همگام سازی دسترسی های گوروتین ها به یک داده مشترک استفاده می شود.
{{< /hint >}}


## 3.3.1 Mutex

در پکیج `sync` یک تایپ به نام `Mutex` وجود دارد که به شما این امکان را می دهد دسترسی به داده های مشترک را  {{< tooltip text="همگام سازی" note="synchronize" >}} کنید. با استفاده از این قابلیت در واقع منابع مشترک محافظت شده و این اطمینان به شما داده می شود که تنها یک گوروتین در یک زمان مشخص، به دیتای مشترک بین گوروتین ها دسترسی دارد.
 تایپ Mutex شامل دو متد مهم Lock و Unlock است. وقتی Lock فراخوانی می شود فقط و فقط یک گوروتین می تواند برروی آن بخش از داده کار کند و تا زمانیکه شما Unlock نکنید سایر گوروتین ها نمی توانند به دیتای مورد نظر شما دسترسی داشته باشند و  تا زمانیکه Unlock صورت گیرد سایر گوروتین هادر حالت انتظار باقی می مانند.

به مثال زیر توجه کنید :

{{< play >}}
package main

import (
	"fmt"
	"sync"
	"time"
)

var count int

func main() {
	mu := new(sync.Mutex)

	go increment(mu)
	go increment(mu)
	go increment(mu)
	go increment(mu)

	time.Sleep(time.Second)
}

func increment(mu *sync.Mutex) {
	mu.Lock()
	defer mu.Unlock()
	count++
	fmt.Printf("Incrementing: %d\n", count)
}
{{< /play >}}

{{<img url="#" image="../../assets/img/content/chapter3/sync/1.jpg" alt="sync mutex">}}


در بالا ما یک تابع به نام increment ایجاد کردیم و به عنوان ورودی تایپ Mutex را بصورت پوینتر پاس دادیم. سپس با استفاده از توابع Lock و Unlock برای افزایش مقدار count یک قفل گذاشتیم.

حال ۴ تا گوروتین داریم که قصد دارند همزمان روی بخش مشترک از حافظه عملیاتی را انجام دهند در اینجا ما با استفاده Mutex جلوی دسترسی همزمان گوروتین ها به حافظه را گرفتیم و فقط یک گوروتین می تواند عملیات انجام دهد و تا زمانیکه شما Unlock نکنید سایر گوروتین ها منتظر می مانند.

### 3.3.1.1 سناریوهای استفاده

1. **همگام سازی دسترسی به متغیرهای مشترک:** یک mutex می تواند برای همگام سازی دسترسی به متغیرهای مشترک بین چندین گوروتین استفاده شود. این می تواند در مواردی مفید باشد که چندین گوروتین نیاز به خواندن یا به روز رسانی یک متغیر به طور همزمان دارند.

2. **هماهنگی دسترسی به حالت مشترک:** یک mutex می تواند برای هماهنگ کردن دسترسی به حالت مشترک بین چندین گوروتین استفاده شود. به عنوان مثال، ممکن است از یک mutex استفاده کنید تا اطمینان حاصل کنید که فقط یک گوروتین می تواند یک ساختار داده مشترک را در یک زمان تغییر دهد.

3. **پیاده سازی الگوهای تولیدکننده-مصرف کننده (producer-consumer):** یک mutex می تواند برای پیاده سازی الگوهای تولیدکننده-مصرف کننده استفاده شود، که در آن یک یا چند گوروتین داده تولید می کنند و یک یا چند گوروتین آن را مصرف می کنند. mutex می تواند برای همگام سازی دسترسی به ساختار داده مشترک که داده ها را نگه می دارد استفاده شود.

{{< hint warning >}}
**۲ نکته خیلی مهم**

1. سعی کنید پس از اینکه تابع Lock را فراخوانی میکنید تابع Unlock را داخل defer قرار دهید.
2. زمانیکه قصد دارید Mutex را به عنوان پارامتر ورودی برای توابع تعریف کنید بهتر است از نوع {{< tooltip text="اشاره گر" note="pointer" >}} باشد.
{{< /hint >}}

## 3.3.2 RWMutex

در پکیج `sync` یک تایپ به نام `RWMutex` وجود دارد که عملیات خواندن و نوشتن برروی یک داده مشترک را {{< tooltip text="همگام سازی" note="synchronize" >}} می کند. شما می توانید به چندین گوروتین اجازه خواندن یک داده مشترک را بدهید ولی فقط یک گوروتین می تواند عملیات نوشتن را برروی آن داده مشترک انجام دهد.

برخی مواقع ممکن است دسترسی به یک مقدار مشترک بین گوروتین ها‌را محدود کنیم اما بر اساس شرایط خاص. مثلا همه ی گورتونین ها بتوانند عملیات خواندن را انجام دهند، اما در آن واحد فقط یک گوروتین بتواند بنویسد.


در زیر یک مثال قرار دادیم توجه کنید :

{{< play >}}
package main

import (
	"fmt"
	"math/rand"
	"strings"
	"sync"
	"time"
)

func init() {
	rand.Seed(time.Now().Unix())
}
func sleep() {
	time.Sleep(time.Duration(rand.Intn(1000))*time.Millisecond)
}
func reader(c chan int, m *sync.RWMutex, wg *sync.WaitGroup) {
	sleep()
	m.RLock()
	c <- 1
	sleep()
	c <- -1
	m.RUnlock()
	wg.Done()
}
func writer(c chan int, m *sync.RWMutex, wg *sync.WaitGroup) {
	sleep()
	m.Lock()
	c <- 1
	sleep()
	c <- -1
	m.Unlock()
	wg.Done()
}
func main() {
	var m sync.RWMutex
	var rs, ws int
	rsCh := make(chan int)
	wsCh := make(chan int)
	go func() {
		for {
			select {
			case n := <-rsCh:
				rs += n
			case n := <-wsCh:
				ws += n
			}
			fmt.Printf("%s%s\n", strings.Repeat("R", rs),
				strings.Repeat("W", ws))
		}
	}()
	wg := sync.WaitGroup{}
	for i := 0; i < 10; i++ {
		wg.Add(1)
		go reader(rsCh, &m, &wg)
	}
	for i := 0; i < 3; i++ {
		wg.Add(1)
		go writer(wsCh, &m, &wg)
	}
	wg.Wait()
}
{{< /play >}}


## 3.3.3 WaitGroup

یک ساختاری داخل پکیج `sync` به نام `WaitGroup` وجود دارد. معمولا برای منتظر ماندن برای پایان اجرای گروهی از گوروتین ها استفاده می شود. این ساختار ۳ متد دارد که به شرح زیر می باشد:

- **Add:** این متد که به عنوان ورودی عدد می گیرد تعداد گوروتین هایی که قرار است منتظر بمانند را تعیین میکند.
- **Done:** این تابع زمانی استفاده می شود که فرآیند داخل هریک از گوروتین ها به اتمام برسد.
- **Wait:** این متد کد ما را بلاک می کند تا زمانیکه سیگنال Done از تمامی گوروتین ها دریافت کند.

بگذارید با یک مثال توضیح دهیم:

{{< play >}}
package main

import (
    "fmt"
    "sync"
    "time"
)

func main() {
    var wg sync.WaitGroup
    wg.Add(2)
    go sleep(&wg, time.Second*1)
    go sleep(&wg, time.Second*2)
    wg.Wait()
    fmt.Println("All goroutines finished")
}

func sleep(wg *sync.WaitGroup, t time.Duration) {
    defer wg.Done()
    time.Sleep(t)
    fmt.Println("Finished Execution")
}
{{< /play >}}

در بالا ما یک متغیر از ساختار WaitGroup ایجاد کردیم و پس از ایجاد متد **Add** را فراخوانی کردیم و تعداد گوروتین هایی که قرار است منتظر بماند را مشخص کردیم. سپس آدرس حافظه متغیر wg را به تابع sleep به عنوان ورودی پاس دادیم و در نهایت داخل تابع sleep با استفاده از **defer** متد **Done** را فراخوانی کردیم.

زمانیکه عملیات تابع sleep اتمام می شود متد Done فراخوانی می شود و یک گوروتین از لیست گوروتین های آبجکت WaitGroup کم می شود.

```go
// Done decrements the WaitGroup counter by one.
func (wg *WaitGroup) Done() {
   wg.Add(-1)
}
```

حال وقتی فرآیند ۲ تا گوروتین اتمام شود اون بخش از کد از حالت بلاک بودن خارج می شود.

{{< hint info >}}
**۳ نکته خیلی مهم**

1. ساختار WaitGroup یکی از پرکاربرد ترین قابلیت ها برای بحث همزمانی می باشد و برخی اوقات برای جلوگیری از Data race و همچنین برای ترتیب دهی عملیات همزمانی هم می توان از این استفاده کرد.
2. سعی کنید WaitGroup را بصورت اشاره گر به توابعی که داخل گوروتین قرار دارند پاس دهید.
3. هیچوقت تعداد گوروتین را بیشتر یا کمتر از اون تعدادی که دارید به متد Add ‌ندهید چون با خطای Panic مواجه خواهید شد.
{{< /hint >}}


## 3.3.4 Once

در پکیج `sync` ما یک تایپ داریم به نام `Once` که برای اطمینان از اینکه یک تابع فقط یکبار فراخوانی می شود استفاده می شود. شما فرض کنید قصد دارید در طول برنامه از یک آبجکت فقط یک instance داشته باشید می توانید با استفاده از Once این کار را انجام دهید (شما با استفاده از Once می توانید الگو طراحی [Singleton](https://book.gofarsi.ir/chapter-9/creational-patterns/go-singleton-pattern/) را پیاده سازی کنید.)

به مثال زیر توجه کنید:


{{< play >}}
package main

import (
	"fmt"
	"sync"
)

type singleton struct {
	data string
}

var instance *singleton
var once sync.Once

func GetInstance() *singleton {
	once.Do(func() {
		instance = &singleton{data: "some data"}
	})
	return instance
}

func main() {
	s1 := GetInstance()
	s2 := GetInstance()
	if s1 == s2 {
		fmt.Println("Same instance")
	} else {
		fmt.Println("Different instances")
	}
}
{{< /play >}}

در مثال فوق ما یک تابع داریم به نام GetInstance که به عنوان خروجی ساختار singleton را بصورت اشاره گر ارائه می دهد. قبل از تابع ۲ تا متغیر تعریف کردیم به نام once و instance که داخل تابع GetInstance از متد Do متغیر once یک تابع inline را قرار دادیم که فقط یک آبجکت از ساختار singleton می سازد و داخل متغیر instance قرار می دهد. در نهایت instance بازگشت داده می شود.


## 3.3.5 Pool

در نسخه ۱.۳ زبان گو امکانی تایپی به نام Pool در پکیج sync که امکان ایجاد استخر آبجکت ها بطور موقت بدون اینکه بخواهد بخشی از حافظه را اشتغال کند اضافه شد. هر آبجکتی که در Pool ذخیره شود بطور خودکار در هرزمانی بدون اینکه اطلاع رسانی کند حذف می شود. امکان استفاده مجدد از آبجکت هایی که داخل استخر می گیرند وجود دارد و این باعث می شود سربار استفاده حافظه کاهش یابد.

{{<img url="#" image="../../assets/img/content/chapter3/sync/2.gif" alt="sync pool">}}

{{< play >}}
package main

import (
	"bytes"
	"io"
	"os"
	"sync"
	"time"
)

var bufPool = sync.Pool{
	New: func() any {
		// The Pool's New function should generally only return pointer
		// types, since a pointer can be put into the return interface
		// value without an allocation:
		return new(bytes.Buffer)
	},
}

// timeNow is a fake version of time.Now for tests.
func timeNow() time.Time {
	return time.Unix(1136214245, 0)
}

func Log(w io.Writer, key, val string) {
	b := bufPool.Get().(*bytes.Buffer)
	b.Reset()
	// Replace this with time.Now() in a real logger.
	b.WriteString(timeNow().UTC().Format(time.RFC3339))
	b.WriteByte(' ')
	b.WriteString(key)
	b.WriteByte('=')
	b.WriteString(val)
	w.Write(b.Bytes())
	bufPool.Put(b)
}

func main() {
	Log(os.Stdout, "path", "/search?q=flowers")
}
{{< /play >}}

در بالا ما یک متغیر به نام bufPool ایجاد کردیم که یک آبجکت از نوع bytes.Buffer ایجاد می کند. سپس داخل تابع Log ما با استفاده از متد Get آبجکت مورد نظر را از Pool خارج و داخل متغیر b قرار دادیم و پس از آن عملیات لازم را برروی Buffer انجام و در نهایت با استفاده از متد Put آبجکت را به Pool اضافه کردیم. حالا اتفاقی که صورت گرفته ما عملیاتی که نیاز داشتیم را برروی آبجکت انجام دادیم بدون اینکه بخوایم بخشی از حافظه را درگیر کنیم.


### 3.3.5.1 بنچمارک در خصوص Pool

{{< play >}}
package main

import (
   "sync"
   "testing")

type Person struct {
   Age int
}

var personPool = sync.Pool{
   New: func() interface{} { return new(Person) },
}

func BenchmarkWithoutPool(b *testing.B) {
   var p *Person
   b.ReportAllocs()
   b.ResetTimer()
   for i := 0; i < b.N; i++ {
      for j := 0; j < 10000; j++ {
         p = new(Person)
         p.Age = 23
      }
   }
}

func BenchmarkWithPool(b *testing.B) {
   var p *Person
   b.ReportAllocs()
   b.ResetTimer()
   for i := 0; i < b.N; i++ {
      for j := 0; j < 10000; j++ {
         p = personPool.Get().(*Person)
         p.Age = 23
         personPool.Put(p)
      }
   }
}
{{< /play >}}

### 3.3.5.2 مثال های کاربردی

**مثال اول :**

فرض کنید شما می خواهید یک فایل csv را با کلی رکورد parse کنید. هر رکورد نیازمند این است که داخل یک ساختاری قرار بگیرد و ایجاد یک ساختار باعث می شود بخشی از حافظه اختصاص یابد به آن ساختار. حالا فکر کنید میلیون ها رکورد داشته باشید و این تخصیص حافظه می تواند باعث توقف برنامه شود.

حالا برای اینکه بخواهیم جلوی این اتفاق را بگیریم و سربار را کاهش دهیم بهتر است ما از sync.Pool استفاده کنیم و ساختارها را داخل استخر قرار دهیم. و زمانیکه هرکدام از ساختارها مورد نیاز نباشد می توانند داخل استخر قرار گیرند و مجدد استفاده شوند. اینکار باعث می شود بطور خیلی قابل توجهی تعداد تخصیص حافظه کاهش یابد و عملکرد برنامه چند برابر شود.

**مثال دوم :**

موارد استفاده دیگر از sync.Pool برای ذخیره کردن آبجکت های پرکاربرد نظیر کانکشن دیتابیس یا شبکه و همچنین آبجکت هایی که قصد داریم برروی آن عملیات serialize و deserialize انجام دهیم.

## 3.3.6 Cond


**پکیج `sync.Cond`** یکی از ابزارهای پیشرفته همزمانی در زبان Go است که امکان پیاده‌سازی الگوی "[مانیتور](../../chapter-9/concurrency-patterns/go-concurrency-pattern-monitor)" یا همان **شرط انتظاری (Condition Variable)** را فراهم می‌کند. Cond به شما اجازه می‌دهد تا مجموعه‌ای از goroutineها را تا زمانی که یک شرط یا رویداد خاص برقرار نشده، به صورت امن و کارآمد (بدون busy-waiting یا مصرف بی‌مورد CPU) منتظر نگه دارید. زمانی که شرط مورد نظر برقرار شد، می‌توانید یک یا همه goroutineهای منتظر را بیدار کنید تا کارشان را ادامه دهند. این تکنیک، در بسیاری از الگوهای معروف concurrency مانند producer-consumer، صف انتظار، صف پیام و کنترل منابع محدود کاربرد اساسی دارد.

#### **نحوه کار Cond و نقش قفل (Mutex / RWMutex)**

برای ساخت یک شیء Cond باید یک قفل (معمولاً از نوع `*sync.Mutex` یا `*sync.RWMutex`) به آن بدهید. این قفل به Cond اجازه می‌دهد تا وضعیت مشترک (shared state) را در میان چند goroutine به طور thread-safe بررسی و کنترل کند. قفل، تضمین می‌کند که هیچ دو goroutineای همزمان نتوانند وضعیت را تغییر دهند یا به متدهای Cond دسترسی پیدا کنند، که این برای جلوگیری از race condition کاملاً حیاتی است.

```go
lock := &sync.Mutex{}
cond := sync.NewCond(lock)
```

#### **عملکرد متدها**

- **Wait():**
    وقتی یک goroutine متد Wait را صدا می‌زند، دو اتفاق پشت‌سرهم رخ می‌دهد:
    1. قفل داده‌شده (مثلاً Mutex) به طور موقت آزاد می‌شود تا سایر goroutineها بتوانند وضعیت مشترک را تغییر دهند.
    2. goroutine تا زمان دریافت سیگنال (`Signal` یا `Broadcast`) به حالت تعلیق (sleep) می‌رود و هیچ پردازشی انجام نمی‌دهد (کاملاً غیرمسدودکننده).
        پس از دریافت سیگنال و بیدار شدن، Wait دوباره به صورت اتمیک قفل را در اختیار می‌گیرد و اجرا از همان خط ادامه پیدا می‌کند.
        معمولاً قبل از Wait باید شرط را داخل یک حلقه (for) بررسی کنید تا از **spurious wakeup** و رقابت داده‌ای جلوگیری شود:

    ```go
    cond.L.Lock()
    for !شرط_برقرار_است {
        cond.Wait()
    }
    // ادامه منطق ...
    cond.L.Unlock()
    ```

- **Signal():**
    این متد تنها **یکی از goroutineهای منتظر** را بیدار می‌کند (اگر کسی در صف انتظار باشد). انتخاب اینکه کدام goroutine بیدار شود به سیاست زمان‌بندی runtime وابسته است و تضمینی برای ترتیب خاصی وجود ندارد. Signal معمولاً زمانی به کار می‌رود که انتظار دارید فقط یک مصرف‌کننده با داده جدید یا تغییر وضعیت بیدار شود.

- **Broadcast():**
    این متد **همه goroutineهای منتظر روی آن Cond** را بیدار می‌کند تا شرط را دوباره بررسی کنند. Broadcast زمانی کاربرد دارد که یک رویداد می‌تواند برای همه‌ی منتظرها مهم باشد (مثلاً اتمام کار یا آزاد شدن منبع برای همه مصرف‌کننده‌ها).

به مثال زیر توجه کنید :

{{< play >}}
package main

import (
	"fmt"
	"sync"
)

var sharedResource = make(map[string]interface{})

func main() {
	var wg sync.WaitGroup
	wg.Add(2)
	locker := sync.Mutex{}
	condition := sync.NewCond(&locker)

	go waitForResourceUpdate(&wg, condition, "rsc1")
	go waitForResourceUpdate(&wg, condition, "rsc2")

	// this one writes changes to sharedResource
	condition.L.Lock()
	sharedResource["rsc1"] = "a string"
	sharedResource["rsc2"] = 123456
	condition.Broadcast()
	condition.L.Unlock()

	wg.Wait()
}

// waitForResourceUpdate waits for a signal that a resource changed and prints it.
func waitForResourceUpdate(wg *sync.WaitGroup, cond *sync.Cond, key string) {
	defer wg.Done()
	cond.L.Lock()
	for len(sharedResource) == 0 {
		cond.Wait()
	}
	fmt.Println("Resource", key, ":", sharedResource[key])
	cond.L.Unlock()
}
{{< /play >}}
