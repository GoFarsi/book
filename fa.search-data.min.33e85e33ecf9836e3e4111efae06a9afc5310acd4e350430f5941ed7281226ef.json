[{"id":0,"href":"/sponsors/","title":"اسپانسرهای کتاب","section":"صفحه اصلی","content":" سرویس ابری فینگ سکوی ابری\nبا سکوی ابری فینگ شما روی کد تمرکز کنید، فینگ آن را اجرا می‌کند.\nمشاهده سرویس\nسرویس ابری دارکوب سکوی ابری\nبا پلتفرم ابری دارکوب، سریع و آسان از مزایا و امکانات کوبرنتیز استفاده کنید.\nمشاهده سرویس\nاسپانسر کتاب شوید اسپانسر\nشما هم می توانید با ارایه خدمات خود اسپانسر کتاب شوید.\nدرخواست اسپانسر شدن\n"},{"id":1,"href":"/preface/","title":"پیشگفتار","section":"صفحه اصلی","content":" چرا از گو استفاده می‌کنیم؟\nوقتی در نوامبر سال ۲۰۰۹ رابرت گریسیمر، راب پایک و کن تامپسون برای اولین‌بار گو را بصورت عمومی انتشار دادند، خودشان مطمئن نبودند که به‌صورت گسترده مورد استفاده قرار می‌گیرد یا خیر. تا به تاریخ انتشار این مطلب، مشخص شده،‌گو بسیار فراگیرتر و رشد آن در صنعت وسیع‌تر از چیزی بوده‌است که ایجادکنندگان آن حدس می‌زدند. این‌ها نمونه‌هایی از کاربرد گو در دنیای امروز تکنولوژی هستند:\nGoogle’s Core Data Solutions Team Uses Go تیم راهکار هسته‌ی داده گوگل از گو استفاده می‌کند Chrome Content Optimization Service Runs on Go سرویس بهینه‌سازی محتوا در گوگل‌کروم توسط گو در حال اجراست Chrome’s user experience strategy, operating in the critical path for users is implemented in Go استراتژی حیاتی تجربه کاربری در کروم توسط گو پیاده‌سازی شده است Firebase Hosting Team Scaled With Go ابزار قدرتمند فایربیس توسط گو گسترش یافته است همچنین در صفحه رسمی گو می‌توانید لیستی از شرکت‌ها از Netflix و PayPal تا Uber و Microsoft رو به‌همراه خدماتی که از گو گرفته‌اند رو ملاحظه کنید. https://go.dev/solutions/#case-studies شناخت نیازمندی و ابزارهای پیاده‌سازی وابسته به آن.\nCloud \u0026amp; Network Services Command-line Interfaces Web Development DevOps \u0026amp; Site Reliability انواع منابع موجود جهت کسب اطلاعات و مقایسه‌ی آن‌ها.\nمنابع مکتوب. سایت رسمی زبان گو. https://go.dev در نسخه حال‌حاضر وب‌سایت رسمی گو، مستندات لازم برای شناخت انواع جزئیات وجود دارد. ضمن‌اینکه یک خودآموز مختصر، جهت آشنایی ابتدایی مفاهیم را می‌توانید پیدا کنید. کتاب‌ها. اصولاً استفاده از کتاب‌ها بدلیل اینکه عمدتاً توسط اساتید، متخصصین شناخته‌شده نگارش می‌شود، توصیه می‌گردد. ضمن اینکه کتاب‌ها معمولاً امکان اصلاحات مستمر و انتشار نسخه‌های جدید و به‌روزتر رو دارا هستند و توسط ناشران معتبر منتشر می‌شوند. مقالات. بدلیل راحت‌تر بودن نشر مقالات، طبیعتاً امکان وجود هرنوع مطلبی با هر سطح و کیفیتی از محتوا وجود دارد. بنابراین، در استفاده از این نوع منابع، احتیاط و حساسیت بالاتری مورد نیاز است. منابع صوتی و تصویری. مزیت بزرگ این نوع از منابع، سرعت و امکانات کافی در انتقال مطلب است. اما اشکالی که وجود دارد عدم امکان ساده‌ی اصلاح محتوا و به‌روزرسانی آن است. ضمن‌اینکه این نوع از منابع، مانند مقالات توسط افراد مختلف و با طیفی از انواع کیفیت‌های متفاوت، وجود دارد. بررسی وضعیت منابع فارسی زبان گو در زمان تهیه این کتاب. درحال‌حاضر منابع نگارشی با کیفیت مناسب به‌زبان فارسی بسیار محدود است. این یکی از دلایل «چرایی» نگارش این کتاب به‌زبان فارسی است. ما امیدواریم با مشارکت همه اساتید و متخصصین این حوزه، این کتاب منبع آموزشی باکیفیت، دردسترس عموم متقاضیان، جهت توسعه ابزارهای حرفه‌ای با زبان گو باشد.\nچرا به زبان فارسی می‌نویسیم. دوستان و همکاران بسیاری هستند،‌که این سوال را مطرح می‌کنند که وقتی نیاز به دانش زبان انگلیسی، برای کسب مهارت در این تخصص، یک «باید» محسوب می‌شود، چرا مطلب فارسی؟ جواب این سوال ساده‌تر از پیچیدگی‌هایی هست که بنظر می‌رسد: − ایجاد و رونق جامعه تخصصی فارسی‌زبان توسط موضوع «کتاب» − ایجاد فضایی جهت ایجاد پرسش و پاسخ فارسی‌زبان‌ها − ارائه یک ترجمه فارسی، از منابع اصلی تخصصی، با امکان مقایسه برداشت افراد مختلف از زبان تخصصی − سرعت دادن به یادگیری، حداقل در مفاهیم ابتدایی − برای نوجوانان و افرادی که به‌هر دلیل، درحال‌حاضر تسلط کافی روی زبان انگلیسی ندارند و ارائه راهکار جهت تمرین و شروع یادگیری منابع روی زبان تخصصی\nبرای چگونگی نگارش کتاب می‌توان به موارد زیر اشاره کرد:\nچگونه از جامعه تخصصی، می‌توان در آموزش،بهینه‌سازی و رشد دانش متقاضیان این تخصص استفاده کرد. یکی از وظایف هر استاد، تربیت «شاگرد» و توسعه دانش است. افراد تازه‌کار با دانش و تجربه پیشکسوتان، با سرعت و کیفیت بالاتر، تبدیل به متخصصین جدید خواهند شد. کیفیت جامعه متخصصین، امکان کنترل مصرف منابع و تولید ابزارهای مفید را تعیین خواهد کرد. کار تیمی، به فرهنگ «با هم کار کردن» نیازمند است.\nچرخ را از نو نسازیم، تجربه‌ها را از نو «تجربه» نکنیم، آموزش ببینیم و آموزش بدهیم. با کمی دقت و تجربه، کاملاً بدیهی‌ست در مقام قیاس بین چند جامعه تخصصی همسان، برتری از آن کسانی‌ست که در انتقال دانش-تجربه دست‌و‌دل‌بازتر هستند. جامعه تخصصی با دانش و تجربه عمیق، نیازمند وجود «مبتدیان» با پتانسیل حداکثری است و این میسر نیست مگر با جریان ساده و پایدار آموزش. دانش امروز، در هر رشته و هر سطح برآیند «انتقال» پیشینیان ما است. به جای غرور ناشی از آن می‌توان از انتقال آن به دیگران لذت برد.\n«کلمات» قدرت دارند. به درک و استفاده از کلمات احترام بگذاریم. در جامعه تخصصی حتی چند‌برابر !!! تا جای ممکن، در استفاده از کلمات تخصصی در محل درست خود دقت شده تا مفهوم نادرست منتقل نشود. از شما خواننده عزیز هم تقاضا داریم، هرکجا ایرادی هرچند کوچک ملاحظه فرمودید، به ما اطلاع دهید یا درخواست اصلاح آن را ارسال کنید.\n"},{"id":2,"href":"/history/","title":"تاریخچه","section":"صفحه اصلی","content":"زبان گو (Go) در سال ۲۰۰۷ (به شمسی: ۱۳۸۶) توسط «شرکت گوگل» با هدف افزایش بهره‌وری برنامه‌نویسی در محیط چندهسته‌ای، رایانه‌های شبکه‌ای و کدبیس‌های بزرگ طراحی شد [به نقل از ویکی پدیا] و سپس به عنوان یک زبان کامپایلری و تایپ استاتیک در نوامبر سال ۲۰۰۹ بصورت عمومی با هدف کامپایل کارآمد ، اجرای کارآمد وسهولت برنامه‌نویسی . بسیاری از اعضای تیم طراحی و توسعه زبان گو [Ken Thompson, Rob Pike, Robert Griesemer] سال‌ها تجربه در زمینه تحقیق و توسعه زبان برنامه‌نویسی دارند.\nتاریخچه زبان گولنگ به سال ۲۰۰۷ میلادی برمیگردد.وقتی که سه برنامه‌نویس تصمیم گرفتند یک زبان برنامه‌نویسی جدید با ترکیبی از ویژگی‌های مختلف را توسعه دهند. هدف آنها این بود که که زبانی سریع، ساده، قابل استفاده و موثر برای توسعه نرم‌افزارهای همزمان و مقیاس‌پذیر بسازند.\nگولنگ از زبان‌هایی چون pascal، c و oberon الهام گرفته است. هدف توسعه دهندگان گولنگ ساده‌تر کردن فرایند طراحی و ساخت نرم افزارهای مقایس‌پذیر بوده. آن‌ها در طراحی گولنگ تلاش کردند تا عملکرد زبان را بهبود بخشند و یک سینتکس ساده و خوانا ارائه دهند.\nاز آن زمان تا به امروز، گولنگ رشد و پیشرفت چشمگیری کرده است و استفاده از آن در صنعت نرم‌افزار روز به روز بیشتر می‌شود. شرکت‌های بزرگی مانند Google، Dropbox، YouTube و Docker از گولنگ به عنوان یکی از زبان‌های اصلی خود استفاده می‌کنند. همچنین جامعه برنامه‌نویسی گولنگ به طور فزاینده‌ای در حال رشد است و ابزارها و کتابخانه‌های زیادی با استقاده از گولنگ توسعه داده شده است.\nزبان گو دارای یک سری ویژگی‌های منحصر به فرد می‌باشد و برخی از ویژگی‌هایش از سایر زبان‌ها الهام گرفته شده است :\nپشتیبانی از برنامه‌نویسی همزمانی بصورت Built-in گوروتین ‌ها امکان اجرای همزمانی توابع را فراهم می‌کند و همچنین گوروتین‌ها واقعا خیلی سبک هستند به طوری که شما می‌توانید هزاران گوروتین را همزمان در سخت افزارهای مدرن بدون هیچ مشکل عملکردی اجرا کنید. کانال ‌ها برپایه مدل CSP می‌باشد که امکان همگام سازی داده‌ها بین گوروتین‌ها را فراهم می‌کند. پشتیبانی از تایپ‌های map و slice امکان پیاده سازی پلی مورفیسم با استفاده از اینترفیس ‌ها پوینترها کلوژر توابع (یک تابع معمولی که داخل یک تابع دیگر به عنوان بازگشت تعریف می‌شود) متدها امکان defer برای تعویق فراخوانی یک تابع قابلیت جاسازی تایپ‌ها ایمنی حافظه در زبان گو قابلیت زباله جمع کن خودکار سازگاری کامل با انواع پلتفرم‌ها نظیر [linux, windows, mac, AIX, android, freeBSD] جهت توسعه و کامپایل امکان Cross-compile با این امکان می‌توانید در هر پلتفرمی برای سایر پلتفرم‌ها کامپایل کنید پشتیبانی از جنریک یا تایپ پارامتر (از نسخه ۱.۱۸) تست نویسی آسان اینترفیس و رفلکشن زبان گو برخلاف زبان‌هایی نظیر c, cpp یا java نیاز به نقطه ویرگول (Semicolons) ندارد و به نسبت زبان‌هایی که معرفی کردیم پرانتز کمتری استفاده می‌کند و همچنین ظاهر سینتکس گو خیلی خواناتر و راحت‌تر می‌باشد. علاوه بر ویژگی‌هایی که در بالا معرفی کردیم یک سری نکات برجسته در خصوص زبان گو وجود دارد که به شرح زیر می‌باشند:\nسینتکس این زبان به گونه‌ای ساده و تمیز طراحی شده که فرآیند یادگیری آن را آسان‌تر می‌کند و از همه مهم‌تر توسعه پروژه‌های مقیاس‌پذیر با زبان گو به دلیل سادگی و آشکار بودن مفاهیم خیلی سریع‌تر صورت می‌گیرد.\nزبان گو دارای تعداد زیادی پکیج‌های استاندارد و کاربردی جهت توسعه می‌باشد که همه این پکیج‌ها در انواع پلتفرم‌ها جهت توسعه قابل استفاده است.\nزبان گو دارای یک جامعه بزرگ از توسعه دهندگان و انجمن‌های فعال می‌باشد که خیلی سریع می‌توانید به پاسخ سوالات خود برسید.\nبرنامه نویس‌های زبان گو را گوفر صدا می‌زنند. گوفر نام یک نوع موش و همچنین mascot گولنگ است. "},{"id":3,"href":"/installation/","title":"آموزش نصب","section":"صفحه اصلی","content":"جهت نصب زبان گو بر روی سیستم عامل مورد نظر خود در ابتدا باید نسخه مناسب با پلت‌فرم خود را دانلود کنید.\nلینوکس در اینجا نسخه مرتبط با لینوکس خود را دانلود کنید. 1$ wget -c https://go.dev/dl/go1.xx.x.linux-amd64.tar.gz سپس دستور زیر را بزنید تا اگر نسخه قبلی وجود دارد پاک شود و نسخه جدید در مسیر usr/local/go/ جایگزین شود. 1$ sudo rm -rf /usr/local/go \u0026amp;\u0026amp; sudo tar -C /usr/local -xzf go1.xx.x.linux-amd64.tar.gz افزودن مسیر usr/local/go/bin/ به متغیرهای محیطی 1export PATH=$PATH:/usr/local/go/bin بهتر است برای اینکه هر بار ترمینال را باز می‌کنید و فایل go توسط shell شناخته شود دستور فوق را به فایل home/{user}/.profile/ اضافه کنید. جهت اطمینان از اینکه زبان گو بدرستی بر روی سیستم عامل شما نصب شده است دستور زیر را داخل ترمینال بزنید. 1$ go version ویندوز روش اول # در اینجا نسخه مرتبط با ویندوز خود را دانلود کنید. سپس فایل go1.xx.x.windows-{arch}.msi را اجرا کنید. مراحل نصب را بصورت پیش فرض طی کنید تا زبان گو برروی ویندوز نصب شود. پس از نصب، جهت اطمینان از نصب بودن زبان گو، مراحل زیر را انجام دهید: وارد منو استارت شوید. در منو استارت کلمه cmd را جستجو کنید و سپس آن را اجرا کنید. داخل خط فرمان دستور زیر را بزنید تا از نصب بودن زبان گو اطمینان حاصل فرمایید. 1go version روش دوم # برای نصب گو می‌توانید از Chocolatey Package Manager استفاده کنید.\nخط فرمان PowerShell را به صورت Administrator باز کنید و دستور زیر را داخل PowerShell بزنید. 1Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString(\u0026#39;https://community.chocolatey.org/install.ps1\u0026#39;)) بعد از نصب می‌توانید از دستور choco برای نصب گو استفاده کنید. 1choco install golang جهت اطمینان از اینکه زبان گو بدرستی بر روی سیستم عامل شما نصب شده است دستور زیر را داخل ترمینال بزنید. 1$ go version دقت داشته باشید برای نصب برنامه‌های مختلف مثل git و یا ابزارهای دیگر در محیط Administrator باید از دستور choco استفاده کنید. مکینتاش روش اول # در اینجا نسخه مرتبط با مکینتاش خود را دانلود کنید. سپس فایل go1.xx.x.darwin-{arch}.pkg را اجرا کنید. مراحل نصب را بصورت پیش فرض طی کنید تا زبان گو برروی مکینتاش نصب شود. پس از نصب اگر ترمینال باز بود آن را کامل ببنید تا تغییرات صورت گیرد. جهت اطمینان از اینکه زبان گو بدرستی بر روی سیستم عامل شما نصب شده است دستور زیر را داخل ترمینال بزنید. 1$ go version روش دوم # برای نصب گو میتوانید از Homebrew Package Manager استفاده کنید.\nبرای نصب brew می‌توانید ترمینال خود را باز کنید و از دستور زیر استفاده کنید. 1$ /bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026#34; بعد از نصب brew از دستور زیر برای نصب گو داخل ترمینال استفاده کنید. 1$ brew update \u0026amp;\u0026amp; brew install golang جهت اطمینان از اینکه زبان گو بدرستی بر روی سیستم عامل شما نصب شده است دستور زیر را داخل ترمینال بزنید. 1$ go version "},{"id":4,"href":"/toolchain/","title":"ابزارها, دستورات گو و معرفی IDE","section":"صفحه اصلی","content":"پس از اینکه زبان گو را برروی سیستم خود نصب کردید از طریق ترمینال و یا خط فرمان ویندوز قابل دسترس است که می‌توانید با زدن کلمه go یکسری عملیات انجام دهید:\n1$ go 2Go is a tool for managing Go source code. 3 4Usage: 5 6\tgo \u0026lt;command\u0026gt; [arguments] 7 8The commands are: 9 10\tbug start a bug report 11\tbuild compile packages and dependencies 12\tclean remove object files and cached files 13\tdoc show documentation for package or symbol 14\tenv print Go environment information 15\tfix update packages to use new APIs 16\tfmt gofmt (reformat) package sources 17\tgenerate generate Go files by processing source 18\tget add dependencies to current module and install them 19\tinstall compile and install packages and dependencies 20\tlist list packages or modules 21\tmod module maintenance 22\twork workspace maintenance 23\trun compile and run Go program 24\ttest test packages 25\ttool run specified go tool 26\tversion print Go version 27\tvet report likely mistakes in packages 28 29Use \u0026#34;go help \u0026lt;command\u0026gt;\u0026#34; for more information about a command. 30 31Additional help topics: 32 33\tbuildconstraint build constraints 34\tbuildmode build modes 35\tc calling between Go and C 36\tcache build and test caching 37\tenvironment environment variables 38\tfiletype file types 39\tgo.mod the go.mod file 40\tgopath GOPATH environment variable 41\tgopath-get legacy GOPATH go get 42\tgoproxy module proxy protocol 43\timportpath import path syntax 44\tmodules modules, module versions, and more 45\tmodule-get module-aware go get 46\tmodule-auth module authentication using go.sum 47\tpackages package lists and patterns 48\tprivate configuration for downloading non-public code 49\ttestflag testing flags 50\ttestfunc testing functions 51\tvcs controlling version control with GOVCS 52 53Use \u0026#34;go help \u0026lt;topic\u0026gt;\u0026#34; for more information about that topic. جدول دستورات (Commands) # دستور توضیحات build با این دستور (go build main.go) می‌توانید فایل go را کامپایل کنید. clean با این دستور می‌توانید فایل‌های کش‌شده را پاکسازی کنید. doc با این دستور (go doc fmt.Println) می‌توانید داکیومنت هر یک از توابع عمومی را ببینید. env با این دستور می‌توانید متغیرهای محیطی تنظیم شده زبان گو را ببینید و آن‌ها را با دستور go env -w key=value مقداردهی کنید. fmt با این دستور می‌توانید کدهای خود را مرتب go fmt ./... کنید. install با استفاده از این دستور می‌توانید یکسری پکیج‌ها را گرفته و کامپایل کنید. list لیست پکیج‌ها و ماژول‌های دانلود شده. generate با این دستور می‌توانید از قابلیت Generator زبان گو استفاده کنید و فایل generate کنید. mod برای مدیریت و ایجاد فایل mod به ازای هر پروژه. get با این دستور می‌توانید پکیجی را دانلود یا بروزرسانی کنید و همچنین برای استفاده از این دستور نیاز به git دارید که نصب باشد. work با این دستور می‌توانید یک workspace ایجاد کنید و آن را مدیریت کنید. run با این دستور (go run main.go) می‌توانید فایل‌های گو یا پروژه را اجرا کنید. test با این دستور (go test example_test.go) می‌توانید فایل‌های تست را اجرا کنید. version با این دستور می‌توانید نسخه نصب شده زبان گو را ببینید. vet با این دستور می‌توانید اشتباهات کدهای خود را ببینید. اجرای کد ساده در زبان گو # در زیر یک نمونه کد ساده قرار دادیم که به سادگی می‌توانید با دستور go run main.go اجرا کنید و خروجی را ببینید.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 fmt.Println(\u0026#34;Hello world!!!\u0026#34;) 7} 1$ go run main.go 2Hello world!!! در کد فوق، ما یکسری کلید واژه نظیر package , import , func استفاده کردیم که در بخش 1.2 کلید واژه و شناسه‌ها با آن‌ها آشنا می‌شوید.\nانواع نرم‌افزارهای محیط توسعه (IDE) و ویرایشگر کد (Code Editor) # در زبان برنامه‌نویسی گو نیز مثل سایر زبان‌ها، می‌توان از ابزارهای کدنویسی مانند نرم‌افزارهای محیط توسعه و همچنین از ویرایشگرهای کد استفاده کرد که محبوب‌ترین‌ها معرفی می‌شوند:\nنرم‌افزار Jetbrains Goland اگر با سایر محصولات جت‌برینز آشنا باشید به‌راحتی می‌توانید از این نرم‌افزار محیط توسعه استفاده کنید. نرم‌افزار VsCode تقریباً همه برنامه‌نویس‌ها با آن آشنا هستند. یک ویرایشگر کد متن‌باز می‌باشد که بین برنامه‌نویس‌ها خیلی محبوب است و برای استفاده زبان گو در این نرم‌افزار می‌توان افزونه vscode-go را نصب کنید. نرم‌افزار Vim یک نرم‌افزار متن‌باز و معروف می‌باشد که داخل ترمینال قابل استفاده است و از آن می‌توانید جهت توسعه با زبان گو استفاده کنید و البته نیازمند نصب پلاگین می‌باشد. "},{"id":5,"href":"/roadmap/","title":"نقشه یادگیری زبان گو","section":"صفحه اصلی","content":"نقشه یادگیری زیر roadmap.sh به ترتیب مسیر توصیه شده ی یادگیری ابزارها و مفاهیم اولیه گو، سپس سمت سرور و در نهایت معماری نرم افزار را نشان می‌دهد.\n"},{"id":6,"href":"/changes-log/","title":"تغییرات نسخه های زبان گو","section":"صفحه اصلی","content":"\n2022-08-02 نسخه 1.21 بزودی تکمیل می شود\n2022-08-02 نسخه 1.20 بزودی تکمیل می شود\n2022-08-02 نسخه 1.19 بزودی تکمیل می شود\n2022-03-15 نسخه 1.18 بزودی تکمیل می شود\n2021-08-16 نسخه 1.17 بزودی تکمیل می شود\n2021-02-16 نسخه 1.16 بزودی تکمیل می شود\n2020-08-11 نسخه 1.15 بزودی تکمیل می شود\n2020-02-25 نسخه 1.14 بزودی تکمیل می شود\n2019-09-03 نسخه 1.13 بزودی تکمیل می شود\n2019-02-25 نسخه 1.12 بزودی تکمیل می شود\n2018-08-24 نسخه 1.11 بزودی تکمیل می شود\n2018-02-16 نسخه 1.10 بزودی تکمیل می شود\n2017-08-24 نسخه 1.9 بزودی تکمیل می شود\n2017-02-16 نسخه 1.8 بزودی تکمیل می شود\n2016-08-15 نسخه 1.7 بزودی تکمیل می شود\n2016-02-17 نسخه 1.6 بزودی تکمیل می شود\n2015-08-19 نسخه 1.5 بزودی تکمیل می شود\n2014-12-10 نسخه 1.4 بزودی تکمیل می شود\n2014-06-18 نسخه 1.3 بزودی تکمیل می شود\n2013-12-01 نسخه 1.2 بزودی تکمیل می شود\n2013-05-13 نسخه 1.1 بزودی تکمیل می شود\n2012-03-28 نسخه 1 گو 1 یک نسخه اصلی از زبان برنامه‌نویسی Go است که در طولانی مدت پایدار خواهد بود. برای کسب اطلاعات بیشتر، به یادداشت‌های انتشار Go 1 مراجعه کنید.\nهدف این است که برنامه‌های نوشته شده برای Go 1 بدون تغییر، در نسخه‌های آینده از Go 1 به درستی کامپایل و اجرا شوند. برای اطلاعات بیشتر درباره آینده Go 1، مستندات سازگاری Go 1 را مطالعه کنید.\n"},{"id":7,"href":"/interview/","title":"سوالات مصاحبه","section":"صفحه اصلی","content":"در این بخش ما یکسری سوالات مصاحبه به زبان فارسی و انگلیسی ارائه دادیم که برای یافتن ضعف‌ها کاربردی می‌باشد (منبع سوالات).\n۱: چه تایپ‌هایی مقدار zero آن‌ها nil است؟ interfaces slices channels maps pointers functions ۲: تایپ‌های نوع Reference؟ Pointers slices maps functions channels ۳: تایپ‌های نوع Aggregate؟ Array structs ۴: چه وقت باید از پوینتر استفاده کنیم؟ 1- تابعی که یکی از پارامترهای خود را تغییر می‌دهد\n-وقتی تابعی را فراخوانی می‌کنیم که یک پوینتر را به عنوان پارامتر می‌گیرد، انتظار داریم که متغیر ما تغییر داده شود. اگر شما متغیر را در تابع خود تغییر نمی‌دهید، پس احتمالا نباید از پوینتر استفاده کنید.\n2- عملکرد بهتر\n-اگر رشته‌ای داشته باشید که شامل یک رمان کامل در حافظه باشد، کپی کردن این متغیر هر بار که به یک تابع جدید ارسال می‌شود، کاری بسیار گران است. ممکن است ارزشمند باشد که به جای این کار یک پوینتر را ارسال کنید، که باعث صرفه‌جویی در پردازنده و حافظه می‌شود. با این حال انجام این کار به قیمت خوانا بودن است، بنابراین فقط در صورت لزوم این بهینه‌سازی را انجام دهید.\n3- به گزینه nil نیاز دارید\n-گاهی اوقات یک تابع باید بداند که مقدار یک چیزی چیست، همچنین باید وجود یا عدم وجود آن را بداند. معمولا هنگام خواندن JSON از این استفاده می‌کنیم تا بدانیم فیلدی وجود دارد یا خیر.\n۵: زبان گولنگ از موارد زیر پشتیبانی نمی‌کند؟ type inheritance operator overloading method overloading pointer arithmetic struct type in consts ۶: چه موقعی از channel و چه موقعی از mutex استفاده میشه برای گوروتین‌ها؟(بحث ارتباط)؟ معمولاً در مواقعی که Goroutines نیاز به برقراری ارتباط با یکدیگر دارند از channels استفاده کنید و درصورتی که فقط یک Goroutine دارید و باید به بخش مهم کد دسترسی داشته باشد از Mutexes استفاده کنید. ۷: چرا کپی کردن pointer کندتر از کپی کردن مقدار است؟ برای ارسال مقادیر کوچیکی که به مقدارشون فقط نیاز داریم از پوینتر استفاده نکنیم. توی متغیرهای کوچیک (کمتر از ۳۲کیلوبایت) کپی کردن یک پوینتر تقریبا به اندازه کپی کردن مقدار اون متغیر هزینه داره پس از این جهت سودی نمی‌بریم. کامپایلر چک‌هایی رو تولید می‌کنه که موقع ران‌تایم زمان dereferencing پوینتر اجرا میشن. پوینترها اکثرا توی Heap ذخیره میشن. برای این کار از ابزار های Go استفاده می‌کنیم ( go build -gcflags=\u0026quot;-m\u0026quot; main.go ). اما اگر به صورت مقداری برگردونیم در stack ذخیره میشه. همونطوری که می‌دونیم ذخیره در stack بسیار بهینه‌تر است. درواقع Garbage collector میاد heap رو چک می‌کنه و همونطوری که میدونیم هربار GC درحال بررسی است به مدت چند میلی‌ثانیه کل سرویس ما فریز میشه. و میتونه مشکل‌هایی مثل Memory Leak و \u0026hellip; بوجود بیاد. Race Condition یا شرط مسابقه چیست؟ در گولنگ زمانی که دو گوروتین تلاش می‌کنند روی یک متغیر مشترک بنویسند Race Condition یا شرط مسابقه ایجاد می‌شود که نتیجه آن یک خروجی غیر منتظره است. چگونه از Race Conditions یا شرط مسابقه جلوگیری کنیم؟ در گولنگ با استفاده از پکیچ sync می‌توانیم دسترسی گوروتین‌ها را به یک متغییر مدیریت کنیم. این مکانیسم شامل استفاده از روش‌های Lock and Unlock از پکیج sync است. متد Lock نشان می‌دهد که گوروتینی که این متد را فراخوانی می‌کند، به تازگی قفل را دریافت کرده است و هیچ گوروتین دیگری نمی‌تواند از قفل استفاده کند تا زمانی که آزاد شود. روش Unlock قفل را آزاد می‌کند تا دیگر گوروتین‌ها بتوانند از آن استفاده کنند. هنگامی که یک گوروتین از قفل استفاده می‌کند و دیگری سعی می‌کند قفل را نیز بدست آورد، گوروتین مسدود می‌شود تا زمانی که گوروتین دیگر قفل را آزاد کند. چه زمانی از panci یا os.Exit استفاده کنیم؟ زمانی از panic استفاده می‌کنیم که برنامه به نقطه غیر قابل بازیابی رسیده باشد و با استفاده از panic برنامه را متوقف می‌کنیم و متن خطا را به کاربر نشان می‌دهیم. تمام توابع defer شده بعد از پنیک اجرا می‌شوند. برای مثال در یک برنامه در خواندن یک فایل با خطا مواجه شده‌ایم و به مقادیر فایل دسترسی نداریم در این شرایط با استفاده از panic می‌توانیم برنامه را متوقف کنیم و متن خطا را به کاربر نمایش دهیم. اما os.Exit زمانی استفاده می‌شود که برنامه نیاز به اتمام فوری و برگشت به سیستم عامل دارد. همچنین این تابع یک کد وضعیت برمیگرداند که برای سیستم عامل و برنامه‌های دیگر قابل استفاده است. برای مثال زمانی که در یک برنامه با سروری ارتباط داریم و ارتباط قطع می‌شود ما قادر به ادامه دادن برنامه نیستیم و می‌توانیم از این تابع استفاده کنیم. "},{"id":8,"href":"/chapter-1/","title":"فصل اول: آشنایی با مفاهیم گو","section":"صفحه اصلی","content":"در فصل اول به مفاهیم پایه زبان برنامه‌نویسی گو بطور عمیق می‌پردازیم. این فصل شامل چندین بخش هست:\n1.1 ساختار کد گو 1.2 کلید واژه و شناسه‌ها 1.3 تایپ های پایه 1.4 عملگرها 1.5 متغیرها و constant 1.6 مقادیر صفر تایپ ها (zero values) 1.7 تابع (function) 1.8 آرایه و slice 1.9 حلقه ها (for) 1.10 نقشه map 1.11 شرط (if, switch) 1.12 اضافه کردن پکیج در کد (package) 1.13 defer, panic, recovery 1.14 لیست تایپ ها و توابع Builtin 1.15قالب بندی رشته ها "},{"id":9,"href":"/chapter-1/structure-of-go-code/","title":"1.1 ساختار کد گو","section":"فصل اول: آشنایی با مفاهیم گو","content":"همانطور که در تاریخچه زبان گو گفتیم, زبان گو سینتکس خیلی تمیز و ساده‌ای دارد که به راحتی می‌توانید کدهای زبان گو را بخوانید. در ادامه ما سعی می‌کنیم با مثال‌های ساده شما را با ساختار کد زبان گو آشنا کنیم.\nبه نقل از تاریخچه سینتکس زبان گو به گونه‌ای طراحی شده که خیلی ساده و تمیز است و این باعث می‌شود خیلی سریع زبان گو را یاد بگیرید و از همه مهم‌تر توسعه پروژه‌های مقیاس پذیر با زبان گو به دلیل سادگی و آشکار بودن مفاهیم خیلی سریع‌تر صورت‌ گیرد. 1.1.0 زبان برنامه‌نویسی # یک زبان برنامه‌نویسی یک زبان مصنوعی انگلیسی است که برای بیان محاسباتی که توسط یک ماشین (مخصوصاً رایانه) قابل انجام است، طراحی شده‌ است. زبان‌های برنامه‌نویسی برای ایجاد برنامه‌هایی به کار می‌روند که رفتار یک ماشین را مشخص می‌کنند، الگوریتم دقیق را بیان می‌کنند، یا روشی برای تعامل انسان و رایانه هستند. بسیاری از زبان‌های برنامه‌نویسی تعدادی قالب از ویژگی‌های نوشته شده دستوری یا نحو (syntax) و معناشناسی (semantics) دارند، چرا که رایانه‌ها دستورهای دقیقاً مشخص نیاز دارند. برخی توسط سند خصوصیات (specification document) تعیین شده‌اند (برای مثال یک استاندارد ISO)، در حالی که برخی دیگر دارای پیاده‌سازی غالبی هستند. [به نقل از ویکی پدیا].\n1.1.1 پکیج # هر برنامه‌ای که با ساختار گو ایجاد شده باشد، از پکیج(ها) ساخته شده است. درواقع زبان گو یک زبان بر پایه پکیج است. برخلاف برخی دیگر که بر پایه فایل هستند. این به‌ این‌ معنی است که به «مجموعه»ای از ابزارها اعم از ثابت‌ها، متغیرها و عملیات مختلف که زیرمجموعه یک نام تعریف می‌شوند، پکیج می‌گوئیم. تفاوتی ندارد در یک «فایل» یا «چند» فایل، بشرطی که ابتدای همگی package name باشند.\n1.1.2 یک نمونه کد ساده زبان گو # قبل از اینکه محتوای بدنه کد زیر را بررسی کنیم؛ بهتر است با نحوه کامنت‌گذاری کد در زبان گو آشنا شوید.\n1.1.2.1 کامنت گذاری # کامنت‌ها در زبان گو همانند زبان سی هستند که با قرار دادن ۲ اسلش در ابتدای خط یا قرار دادن یک یا چند خط ما بین /* و */ ایجاد می‌شود.\n1// کامنت عادی یک خطی 2 3/* 4بلاک کامنت برای نوشتن کامنت چند خطی 5*/ 1.1.2.2 نمونه کد # در پایین یک نمونه کد قرار دادیم که با کامنت هر کدام از بخش‌های بدنه کد گو را توضیح دادیم.\n1package main // نام پکیج فایل سورس را مشخص می کند 2 3import \u0026#34;math/rand\u0026#34; // یک پکیج استاندارد ایمپورت شده 4 5const MaxRnd = 16 // یک ثابت تعریف شده است 6 7// تابع 8func StatRandomNumbers(n int) (int, int) { 9\tvar a, b int 10\tfor i := 0; i \u0026lt; n; i++ { 11\tif rand.Intn(MaxRnd) \u0026lt; MaxRnd/2 { 12\ta = a + 1 13\t} else { 14\tb++ 15\t} 16\t} 17\treturn a, b 18} 19 20// تابع main اولین نقطه شروع اجرای کد شما می باشد که در این تابع سایر موارد تعریف می شود. 21func main() { 22\tvar num = 100 23\tx, y := StatRandomNumbers(num) 24\tprint(\u0026#34;Result: \u0026#34;, x, \u0026#34; + \u0026#34;, y, \u0026#34; = \u0026#34;, num, \u0026#34;? \u0026#34;) 25\tprintln(x+y == num) 26} سورس کد بالا را در فایلی با نام basic-code-element-demo.go ذخیره می‌کنیم و سپس با دستور زیر اجرا می‌کنیم تا خروجی کد فوق را ببینیم :\n1$ go run basic-code-element-demo.go 2Result: 46 + 54 = 100? true 1.1.3 تابع main # در زبان گو پکیج main به عنوان یک پکیج منحصر به فرد در نظر گرفته شده است، به شکلی که در هنگام اجرای برنامه مشخص می‌کند شروع کار و خواندن برنامه از کجا باید باشد. در نهایت داخل این پکیج ما تابع ()main را داریم که این تابع نقطه شروع اجرای برنامه ما خواهد بود. این تابع هیچ ارگومانی نمی‌گیرد و هیچ چیزی رو هم بازگشت نخواهد داد. زبان گو به صورت خودکار تابع ()main را فراخوانی می‌کند. برای همین نیازی به فراخوانی این تابع توسط شما وجود ندارد. برای همین باید دقت داشته باشید در هر برنامه‌ای که می‌نویسید حتما از پکیج و تابع main باید استفاده کنید.\n1// تعریف پکیج main 2package main 3 4// تعریف تابع main 5func main() { 6\tprintln(\u0026#34;Hello GoFarsi!\u0026#34;) 7} 1.1.4 اجرای کد # برای اجرای کدهای گو می‌توان از پارامتر run استفاده کرد.\n1$ go run main.go 2Result: Hello GoFarsi! دستور بالا ابتدا داخل پوشه temp سیستم شما یک فایل اجرایی را درست می‌کند و سپس آن فایل را اجرا می‌کند و در نهایت خروجی را به ما نشان می‌دهد. اگر شما بخواهید خروجی فایل اجرایی (executable) داشته باشید و سپس آن را اجرا کنید می‌توانید از دستور زیر استفاده کنید:\n1$ go build main.go 2$ ./main 3Result: Hello GoFarsi! اگر بخواهید برای خروجی فایل اجرایی اسمی در نظر بگیرید می‌توانید از دستور زیر با پارامتر o- استفاده کنید.\n1$ go build -o goFarsi main.go 2$ ./goFarsi 3Result: Hello GoFarsi! دقت کنید اگر از سیستم‌عامل ویندوز استفاده می‌کنید بعد از وارد کردن اسم، پسوند .exe را نیز اضافه کنید. برای راحتی و سرعت بخشیدن هنگام توسعه ما از دستور go run استفاده می‌کنیم. 1.1.5 بررسی syntax # برخلاف بیشتر زبان‌های برنامه نویسی در زبان گو شما نمی‌توانید از حالت‌های مختلف برای نوشتن کد خود استفاده کنید. مثلاً کد زیر هنگام کامپایل کردن خطا می‌دهد.\n1package main 2 3func main() 4{ 5\tprintln(\u0026#34;not compiled\u0026#34;) 6} خروجی کد بالا :\n1$ go run main.go 2Result: 3# command-line-arguments 4.\\main.go:4:1: syntax error: unexpected semicolon or newline before { صرفاً با تغییر براکت ما با خطا مواجه شدیم. شاید از دید شما این نوع نوشتن کد نباید خطا ایجاد کند. ولی وقتی شما داخل یک تیم هستید و مجبور هستید کدها را بازخوانی کنید تا بفهمید چه اتفاقی افتاده است، با حالت‌های مختلف سینتکس مواجه نخواهید شد، و همه کدها یک دست و از یک ساختار پیروی می‌کنند، که باعث خواندن سریع‌تر، درک بهتر و امکان توسعه سریع‌تر را برای ما و هم‌تیمی‌های ما ایجاد خواهد کرد.\n1.1.5.1 استفاده از go fmt # برای آن که بتوان از این نوع خطاها جلوگیری کرد و فرمت مناسب و یک نواختی داخل کدهای ما وجود داشته باشد، خود IDEها این خطاها را به ما نشان می‌دهد. خود توسعه‌دهندگان زبان گو پارامتر fmt یا به عبارتی فرمت را در اختیار ما قرار داده‌اند تا هر زمان که کدی می‌نویسم و ذخیره می‌کنیم بتوانیم با استفاده از این دستور ساختار کد خود را مرتب کنیم و اگر خطایی وجود داشته باشد قبل از کامپایل کردن برنامه آن را پیدا و رفع کنیم. مثلاً خروجی استفاده از پارامتر fmt\n1$ go fmt main.go 2Result: 3.\\main.go:4:1: unexpected semicolon or newline before { حالا فرض کنید کدی را نوشته‌اید و داخل کد شما فضای زیادی وجود دارد و اندازه tab‌ها و space‌ها مشخص نیست. به مثال زیر توجه کنید:\n1package main 2 3func main(){ 4 5 6 7\tprintln(\u0026#34;print line 1\u0026#34;) 8\t9\t10\t11\t12println(\u0026#34;print line 2\u0026#34;) 13\t14\t15} وقتی کدی شبیه کد بالا را دارید و از دستور go fmt استفاده می‌کنیم خروجی کد بالا به شکل زیر تغییر پیدا می‌کند:\n1package main 2 3func main() { 4 5\tprintln(\u0026#34;print line 1\u0026#34;) 6\t7\tprintln(\u0026#34;print line 2\u0026#34;) 8} در برنامه فوق ما یکسری کلمات کلیدی نظیر package, import, const, func, var , for, if, else, return استفاده کردیم و سایر کلماتی که داخل کد فوق دیدید به عنوان شناسه هستند. برای اطلاعات بیشتر در خصوص کلید واژه و شناسه لطفاً بخش کلید واژه و شناسه ها را مطالعه فرمایید. "},{"id":10,"href":"/chapter-1/go-built-in-keywords-identifiers/","title":"1.2 کلید واژه و شناسه‌ها","section":"فصل اول: آشنایی با مفاهیم گو","content":"در این بخش قصد داریم به کلید واژه و شناسه های زبان گو بپردازیم.\n1.2.1 کلید واژه # زبان گو تا نسخه فعلی فقط ۲۵ تا کلید واژه دارد که به شرح زیر ست:\n1 2 3 4 5 1 break default func interface select 2 case defer go map struct 3 chan else goto package switch 4 const fallthrough if range type 5 continue for import return var کلمات کلیدی فوق به ۴ دسته تقسیم می‌شوند که به شرح زیر است:\nکلمات کلیدی که بصورت گلوبال در بدنه قرار می‌گیرند «package, import, type, var, const, func» کلمات کلیدی کامپوزیت «struct, interface, map, chan» کلمات کلیدی که در جریان کنترل کد استفاده می‌شوند «break, case, continue, default, if, else, for, fallthrough, goto, range, return, switch, select» در بخش‌های دیگر کتاب ما بطور مفصل به مفاهیم کلمات کلیدی فوق می‌پردازیم. 1.2.2 شناسه‌ها # شناسه توکنی است که باید از حروف یونیکد, ارقام یونیکد (اعداد دسته‌بندی شده در استاندارد ۸.۰ یونیکد) و خط زیرین ـ تشکیل شده باشد.\nعلامت کاربرد ـ نادیده گرفتن \u0026amp; دسترسی به آدرس حافظه * دسترسی مقدار داخل یک خانه حافظه 1.2.2.1 قوانین شناسه‌ها # نامگذاری باید از حروف a-z یا A-Z و یا 0-9 باشد. نام شناسه‌ها نباید با اعداد شروع شود. نام شناسه‌ها به حروف بزرگ و کوچک حساس است. استفاده از کلید واژه ممنوع است. هیچ محدودیتی در تعداد حروف نام شناسه وجود ندارد و مطلوب‌ترین حالت ۴ الی ۱۵ حرف است. 1// شناسه‌های معتبر 2 3_geeks23 4geeks 5gek23sd 6Geeks 7geeKs 8geeks_geeks 9 10// شناسه‌های نامعتبر 11 12212geeks 13if 14default در زبان گو یکسری شناسه‌ها از قبل برای برخی از بخش‌های کد تعیین شده است که در زیر می‌توانید ببینید:\n1// Constant (ثابت ها) 2 3true, false, iota, nil 4 5// Types (تایپ ها) 6 7int, int8, int16, int32, int64, uint, 8uint8, uint16, uint32, uint64, uintptr, 9float32, float64, complex128, complex64, 10bool, byte, rune, string, error 11 12// Functions (توابع) 13 14make, len, cap, new, append, copy, close, 15delete, complex, real, imag, panic, recover "},{"id":11,"href":"/chapter-1/go-basic-types/","title":"1.3 تایپ‌های پایه","section":"فصل اول: آشنایی با مفاهیم گو","content":" 1.3.1 تایپ چیست؟ # یک تایپ مشخص کننده نوع داده است، که به کامپایلر می‌گوید قرار است چه نوع داده‌ای داخل یک متغیر ذخیره گردد. زبان‌ها انواع تایپ‌های مختلفی به صورت پیش‌فرض دارند که می‌توان از آن‌ها داخل برنامه خود استفاده کرد. ما می‌توانیم تایپ‌ها را به دو دسته کلی تعریف کنیم.\n1.3.1.1 تایپ ایستا (Static Type) # زبانی مثل زبان گو یک زبان تایپ ایستا است، یعنی وقتی ما یک داده‌ای از نوع عددی داخل یک متغیر تعریف می‌کنیم داخل همان متغیر امکان اضافه کردن داده‌ای، غیر داده عددی وجود ندارد.\n1.3.1.2 تایپ پویا (Dynamic Type) # زبان‌هایی مثل PHP، JavaScript و \u0026hellip; جزو زبان‌های تایپ پویا هستند. یعنی وقتی یک متغیری از نوع عددی تعریف می‌کنیم می‌توانیم به همان متغیر مقادیر دیگه‌ای مثل مقادیر رشته‌ای اضافه کنیم.\nتفاوت تایپ ایستا با پویا به نقل از آقای استقامت:\nدر زبان‌هایی مثل گو که جزو زبان‌های نوع ایستا هستند، وقتی بخوایم متغیر یا ثابتی ایجاد کنیم، حتما می بایست نوع متغیر یا ثابت را به صورت مستقیم و صریح اعلان کنیم تا کامپایلر متوجه بشه که درون این متغیر یا ثابت قراره چه نوع داده ای ذخیره بشه.\nبه عنوان مثال در زبان گو باید بنویسیم: ‎var a, b int = 1, 2\nو اگر نوع داده یا در این مثال(int) را مشخص نکنیم با ارور مواجه می‌شویم.\nاکنون که این دو متغیر از نوع int اعلان شدند، فقط و فقط می‌توان مقادیری از نوع اعداد صحیح را درون آن‌ها ذخیره کرد و نمی‌توان به عنوان مثال، یک رشته متنی یا اعداد اعشاری و \u0026hellip; را درون آن‌ها ذخیره نمود.\n▪️ اما در مورد زبان‌های نوع پویا مانند زبان پایتون، ما نیازی به اعلان صریح نوع متغیر نداریم. بلکه کافیست یک شناسه را به عنوان نام متغیر در نظر گرفته و مقداری را به آن انتساب دهیم. در اینجا، کامپایلر یا مفسر زبان به صورت خودکار نوع داده متغیر را بر اساس مقداری که به آن انتساب داده ایم شناسایی می کند: به عنوان مثال در زبان پایتون داریم: ‎n = 300\nدر این جا متغیر n دارای نوع int است که به صورت خودکار توسط زبان شناسایی می‌شود.\nاکنون ما می‌توانیم همین متغیر را در جاهای دیگری از کد استفاده کنیم و مقادیری از انواع داده‌ای دیگر به آن انتساب دهیم بدون اینکه هیچ مشکلی یا اروری پیش بیاید: \u0026quot;‎n = \u0026quot;Hello\nدر حال حاضر متغیر n از نوع string می باشد!\nبرای اطلاعات بیشتر می‌توانید تایپ سیستم را داخل ویکی‌پدیا مطالعه کنید.\n1.3.2 تایپ‌ها در زبان گو # زبان گو مثل سایر زبان‌ها یکسری تایپ‌های پایه دارد که در هر بخش از کد گو می‌توانید استفاده کنید. در ادامه این تایپ‌ها با مقادیر پیش‌فرض‌ معرفی شده است.\nتایپ محدوده مقدار پیش فرض یا مقدار صفر حجم استفاده از حافظه int بستگی به معماری سیستم عامل که ۳۲ بیت یا ۶۴ بیت باشد 0 ۴ یا ۸ بایت int8 128- تا 127 0 ۱ بایت int16 32768- تا 32767 0 ۲ بایت int32 2147483648- تا 2147483647 0 ۴ بایت int64 9223372036854775808- تا 9223372036854775807 0 ۸ بایت uint بستگی به معماری سیستم عامل که ۳۲ بیت یا ۶۴ بیت باشد 0 ۴ یا ۸ بایت uint8 0 تا 255 0 ۱ بایت uint16 0 تا 65535 0 ۲ بایت uint32 0 تا 6294967295 0 ۴ بایت uint64 0 تا 18446744073709551615 0 ۸ بایت uintptr عدد خیلی بزرگ 0 ۸ بایت float32 IEEE-754 0 ۴ بایت float64 IEEE-754 0 ۸ بایت complex64 - 0+0i ۸ بایت complex128 - 0+0i ۱۶ بایت bool - false ۱ بایت string - \u0026quot; \u0026quot; ۱۶ بایت زبان گو به‌طور پیش‌فرض از دو نوع تایپ با نام مستعار پشتیبانی می‌کند :\nتایپ byte این تایپ نام مستعار برای تایپ uint8 است. تایپ rune این تایپ نام مستعار برای تایپ int32 است. تفاوت int و uint در این است که نوع داده int به عنوان Signed Integer شناخته می‌شود و توانایی ذخیره اعداد منفی ، 0 و اعداد مثبت را دارد اما نوع داده uint به معنای Unsigned Integer بوده و فقط توانایی نگهداری اعداد مثبت و 0 را داراست.\nتایپ uintptr به نقل از آقای استقامت:\nدر مورد نوع داده uintptr که در متن بالا در مورد آن گفته شده \u0026ldquo;عدد خیلی بزرگ\u0026quot;، با بیان این مطلب که چنین توضیحی نادرست است، توجه شما رو به ادامه این یادداشت جلب می‌کنم:\nکلمه uintptr همان‌طور که قابل حدس زدن است کوتاه شده Unsigned Integer Pointer است.\nاز این نوع داده برای ذخیره و نگهداری آدرس‌های حافظه(RAM) استفاده می‌شود.\nفضایی که این نوع داده در سیستم اِشغال می‌کند، به نوع معماری سیستم عامل بستگی دارد.\nو در نهایت، به جای عبارت \u0026ldquo;عدد خیلی بزرگ\u0026rdquo; که مفهوم اشتباه و نادرستی می‌رساند، باید اینگونه بگوییم که این نوع داده به اندازه کافی بزرگ است تا بتواند اشاره گرهایی(Pointers) به هر آدرس از حافظه را درون خودش ذخیره کند.(منبع)\n1package main 2import \u0026#34;fmt\u0026#34; 3 4func main() { 5 var var1 uintptr = 0xc82000c290 6 fmt.Println(\u0026#34;Value of var1:\u0026#34;, var1) 7 fmt.Printf(\u0026#34;Type of var1: %T\u0026#34;, var1) 8 } 1$ go run main.go 2Value of var1: 859530379920 3⁦‎Type of var1: uintptr 1.3.3 سفارشی‌سازی تایپ‌(ها) # نام‌گذاری جدید : برای تایپ‌های رشته‌ای، عددی و بول، می‌توان نام سفارشی جدید انتخاب و در پروژه استفاده کرد: 1 2/* type alias */ 3 4// bul and bool define the same type. 5type bul = bool 6// content and string define the same type. 7type content = string 8// UI8, uint8 and byte define the same type. 9type UI8 = uint8 10// Word, rune and int32 define the same type. 11type Word = rune ایجاد تایپ جدید معادل یک تایپ موجود : همچنین می‌توان از تایپ‌های موجود، یک نمونه جدید ایجاد کرد: 1/* type definition */ 2 3// state and bool are two different types. 4type state bool 5// str and string are two different types. 6type str string 7// ID and uint64 are two different types. 8type ID uint64 9// decimal and float32 are two different types. 10type decimal float32 1.3.4 مقدار پیش فرض تایپ‌ها # مقدار پیش‌فرض تایپ‌ها در زبان گو به شرح زیر است :\nمقدار پیش‌فرض تایپ بولین false است. مقدار پیش‌فرض تمامی تایپ اعداد (int, uint, float) صفر است. مقدار پیش‌فرض تایپ string برابر با رشته تهی یا empty string است . رشته تهی معادل عبارت \u0026quot;\u0026quot; است (دو علامت نقل قول بدون هیچ کاراکتری در بین آن‌ها) و عبارت \u0026quot; \u0026ldquo; که دارای یک فاصله خالی(Space) در بین دو نقل قول است، یک رشته تهی نیست و بنابراین اشتباه است!\n1.3.5 انواع مقادیر تایپ‌ها # در زبان گو تایپ‌ها یکسری مقادیر مختلفی را دریافت می‌کنند که در زیر به این مقادیر می‌پردازیم.\n1.3.5.1 تایپ بولین # تایپ بولین فقط true و false را به عنوان مقدار دریافت می‌کند.\n1.3.5.2 تایپ Integer # تایپ اعداد ۴ نوع مقدار مختلف دریافت می‌کند که به ترتیب Decimal (پایه ۱۰), Octal (پایه ۸), Hex (پایه ۱۶) و Binrary (پایه ۲ یا دودویی) است.\n10xF // the hex form (starts with a \u0026#34;0x\u0026#34; or \u0026#34;0X\u0026#34;) 20XF 3 4017 // the octal form (starts with a \u0026#34;0\u0026#34;, \u0026#34;0o\u0026#34; or \u0026#34;0O\u0026#34;) 50o17 60O17 7 80b1111 // the binary form (starts with a \u0026#34;0b\u0026#34; or \u0026#34;0B\u0026#34;) 90B1111 10 1115 // the decimal form (starts without a \u0026#34;0\u0026#34;) 1package main 2 3func main() { 4\tprintln(15 == 017) // true 5\tprintln(15 == 0xF) // true 6} 1.3.5.3 تایپ Float # تایپ Float چند نوع مقدار را دریافت می‌کند که به ترتیب مقدار ممیز شناور اعشاری ممکن است شامل یک قسمت صحیح اعشاری، یک نقطه اعشاری، یک قسمت کسری اعشاری، و یک قسمت توانی عدد صحیح (مبتنی بر 10) باشد.\n11.23 201.23 // == 1.23 3.23 41. 5// An \u0026#34;e\u0026#34; or \u0026#34;E\u0026#34; starts the exponent part (10-based). 61.23e2 // == 123.0 7123E2 // == 12300.0 8123.E+2 // == 12300.0 91e-1 // == 0.1 10.1e0 // == 0.1 110010e-2 // == 0.1 120e+5 // == 0.0 1.3.5.4 تایپ rune # تایپ rune یک تایپ با نام مستعار int32 است که از تایپ‌های اعداد صحیح خاص هستند. از rune می‌توان برای ذخیره کاراکترهای یونیکد استفاده کرد که در مثال زیر چند نمونه قرار داده شده است:\n1\u0026#39;a\u0026#39; // an English character 2\u0026#39;π\u0026#39; 3\u0026#39;众\u0026#39; // a Chinese character 1// 141 is the octal representation of decimal number 97. 2\u0026#39;\\141\u0026#39; 3// 61 is the hex representation of decimal number 97. 4\u0026#39;\\x61\u0026#39; 5\u0026#39;\\u0061\u0026#39; 6\u0026#39;\\U00000061\u0026#39; 1package main 2 3func main() { 4\tprintln(\u0026#39;a\u0026#39; == 97) 5\tprintln(\u0026#39;a\u0026#39; == \u0026#39;\\141\u0026#39;) 6\tprintln(\u0026#39;a\u0026#39; == \u0026#39;\\x61\u0026#39;) 7\tprintln(\u0026#39;a\u0026#39; == \u0026#39;\\u0061\u0026#39;) 8\tprintln(\u0026#39;a\u0026#39; == \u0026#39;\\U00000061\u0026#39;) 9\tprintln(0x61 == \u0026#39;\\x61\u0026#39;) 10\tprintln(\u0026#39;\\u4f17\u0026#39; == \u0026#39;众\u0026#39;) 11} ◾️استاندارد یونیکد، مجموعه‌ای از تمام کاراکترهای موجود در جهان است (کاراکترهای زبان‌های لاتین، فارسی، عربی، چینی و \u0026hellip;، اموجی‌ها (مانند😊)، کاراکترهای غیرقابل نمایش و \u0026hellip;).\n◾️هر کدام از این کاراکترها در استاندارد یونیکد، توسط یک عدد یکتا و منحصر به فرد مشخص شده است. به این عدد Unicode Code Point می‌گویند.\n◾️به عنوان مثال، کد پوینت کاراکتر «😊» برابر است با U+1F60A یا کد پوینت کاراکتر «ن» در زبان فارسی برابر است با U+0646.\n◾️این کد پوینت‌ها دقیقا همان چیزهایی هستند که در runeها ذخیره می‌شوند.\n◾️از آنجا که زبان گو، از استاندارد UTF-8 (ارائه شده توسط کنسرسیوم یونیکد) برای encoding کاراکترها استفاده می‌کند و در این استاندارد، هر کاراکتر فضایی بین 1 تا 4 بایت(8 بیت تا 32 بیت) را در حافظه اِشغال می‌کند. به همین دلیل نوع داده rune یک نام مستعار برای نوع داده int32 در زبان گو است.\n1package main 2import \u0026#34;fmt\u0026#34; 3 4func main() { 5 var r rune = \u0026#39;k\u0026#39; 6 fmt.Printf(\u0026#34;%c %T %U\u0026#34;, r, r, r) 7} 1$ go run main.go 2k int32 U+006B 3Program exited. 1.3.5.5 byte، string و rune # مقادیر string و rune[] قابل تبدیل به یک دیگر هستند. اما تفاوت این دو در چیست؟ هر string از مجموعه ای از byte ها تشکیل شده که هر یک 8 بیت هستند. هر کاراکتر در UTF-8 از 1 تا 4 بایت تشکیل شده. مثلا حرف \u0026lsquo;a\u0026rsquo; از یک بایت و کاراکتر \u0026lsquo;你\u0026rsquo; از 3 بایت تشکیل میشه. به کد زیر توجه کنید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func stringAndRuneCompare() { 6 s := \u0026#34;hello你好\u0026#34; 7 fmt.Printf(\u0026#34;%s, type: %T, len: %d\\n\u0026#34;, s, s, len(s)) 8 9 rs := []rune(s) 10 fmt.Printf(\u0026#34;%v, type: %T, len: %d\\n\u0026#34;, rs, rs, len(rs)) 11 12} 13 14func main() { 15 stringAndRuneCompare() 16} خروجی:\nhello你好, type: string, len: 11 [104 101 108 108 111 20320 22909], type: []int32, len: 7 طول رشته در تایپ string یازده و در تایپ rune[] برابر 7 است. علت چیست؟ رشته در تایپ string یازده است، زیرا 5 نویسه اول هر کدام فقط 1 بایت می گیرند، در حالی که 2 نویسه چینی آخر هر کدام 3 بایت می گیرند. بنابراین، کل بایت 3 * 2 + 1 * 5 = 11 است.\nهنگام تبدیل رشته به rune[]، گو 7 کاراکتر 32 بیتی پیدا می کند. از انجایی که هر rune برابر 32 بیت است، کاراکتر های انگلیسی و چینی هر کدام یک rune را اشغال می کنند. در نتیجه مجموعا 7 rune وجود دارد.\n1.3.5.6 تایپ رشته (string) # در زبان گو مقدار تایپ رشته بطور پیش‌فرض از نوع یونیکد UTF-8 است.\n1// The interpreted form. 2\u0026#34;Hello\\nworld!\\n\\\u0026#34;你好世界\\\u0026#34;\u0026#34; 3 4// The raw form. 5`Hello 6world! 7\u0026#34;你好世界\u0026#34;` همچنین رشته از کارکترهای خاص یونیکد مانند 0x0D پشتیبانی می‌کند.\n1.3.6 خوانایی بهتر اعداد با _ # در زبان گو می‌توان برای خوانایی بهتر اعداد چند رقمی، از _ برای جداسازی استفاده کرد.\n1// Legal ones: 26_9 // == 69 30_33_77_22 // == 0337722 40x_Bad_Face // == 0xBadFace 50X_1F_FFP-16 // == 0X1FFFP-16 60b1011_0111 + 0xA_B.Fp2i 7 8// Illegal ones: 9_69 // _ can\u0026#39;t appear as the first character 1069_ // _ can\u0026#39;t appear as the last character 116__9 // one side of _ is a illegal character 120_xBadFace // \u0026#34;x\u0026#34; is not a legal octal digit 131_.5 // \u0026#34;.\u0026#34; is not a legal octal digit 141._5 // \u0026#34;.\u0026#34; is not a legal octal digit "},{"id":12,"href":"/chapter-1/go-operators/","title":"1.4 عملگرها","section":"فصل اول: آشنایی با مفاهیم گو","content":"زبان گو مثل سایر زبان‌ها دارای یکسری عملگرها مانند: عملگرهای حسابی, عملگرهای مقایسه‌ای, عملگرهای منطقی و عملگرهای بیتی است.\n1.4.1 عملگرهای حسابی # زبان گو دارای ۵ تا عملگر حسابی است که به ترتیب:\nعملگر نام + جمع - تفریق * ضرب / تقسیم % باقی مانده این ۵ تا عملگر اغلب به ترتیب مجموع, تفاوت, حاصل‌ضرب و ضریب نیز نامیده می‌شوند.\n1 a := 1 2 b := 2 3 4 c := a + b // 3 5 d := a - b // -1 6 e := a * b // 2 7 f := a / b // 0 8 g := a % b // 1 در نمونه کد بالا ما از عملگر := که شیوه تعریف متغیر به روش کوتاه است استفاده کردیم که در بخش 1.5 متغیرها و ثابت ها معرفی خواهیم کرد. 1.4.2 عملگرهای مقایسه‌ای # زبان گو دارای ۶ عملگر مقایسه‌ای است که به ترتیب:\nعملگر نام == مساوی بودن =! مساوی نبودن با \u0026gt; کوچکتر از =\u0026gt; کوچکتر یا مساوی \u0026lt; بزرگتر =\u0026lt; بزرگتر یا مساوی نتیجه استفاده از این عملگرهای مقایسه‌ای, یک نوع untyped بولین است. یعنی حاصل این مقایسه‌ها در واقع true یا false است.\n1 a := 1 2 b := 2 3 c := 1 4 5 println(a == b) // false 6 println(a == c) // true 7 println(a \u0026lt; b) // true 8 println(b \u0026gt; c) // true 9 println(c \u0026lt;= a) // true 10 println(c \u0026gt;= b) // false 11 println(b != a) // true 12 println(c != a) // false 1.4.3 عملگرهای منطقی # زبان گو دارای ۳ نوع عملگر منطقی است که به ترتیب:\nعملگر نام \u0026amp;\u0026amp; AND || OR ! NOT عملگر \u0026amp;\u0026amp; به انگلیسی AND به فارسی و , اگر هردو عملگر true باشد مقدار بازگشتی true و در غیر اینصورت false خواهد بود. عملگر || به انگلیسی OR به فارسی یا , اگر یکی از عملگرها true باشد مقدار بازگشتی true در غیر این صورت false خواهد بود. عملگر ! به انگلیسی NOT به فارسی ‍‍منفی یا نفی , زمانیکه شما از عملگر ! استفاده می کنید معکوس نتیجه عملوند را نیاز دارید. 1a := true 2b := true 3c := false 4 5fmt.Println(a \u0026amp;\u0026amp; b) //true 6fmt.Println(a || b) //true 7fmt.Println(!a) //false 8fmt.Println(!c) //true مثال زیر نتیجه مقادیر متفاوت و عملگرهای منطقی را نشان می‌دهد.\n1 // x y x \u0026amp;\u0026amp; y x || y !x !y 2 true true true true false false 3 true false false true false true 4 false true false true true false 5 false false false false true true 1.4.4 عملگرهای بیتی # زبان گو داری 5 عملگر بیتی است که به ترتیب:\nعملگر نام \u0026gt;\u0026gt; شیفت بیتی به چپ \u0026lt;\u0026lt; شیفت بیتی به راست \u0026amp; AND | OR ^ XOR ‍‍\nعملگر \u0026gt;\u0026gt; به انگلیسی Zero fill left shift یا به اختصار left shift که به فارسی اسم مناسبی نیافتیم به نقل از ویکی پدیا شیفت بیتی به چپ, مقدار باینری ما را با استفاده از انتقال یا اضافه کردن صفرها به سمت چپ انتقال می‌دهد. عملگر \u0026lt;\u0026lt; به انگلیسی Zero fill right shift یا به اختصار right shift که به فارسی اسم مناسبی نیافتیم به نقل از ویکی پدیا شیفت بیتی به راست, مقدار باینری ما را با به سمت راست انتقال می‌دهد. در زیر دو مثال رو مشاهده می‌کنید که از این دو عملگر استفاده شده:\n1//example 1 2a := 0b01000101 3b := a \u0026lt;\u0026lt; 1 4c := a \u0026gt;\u0026gt; 1 5fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, a, a) //binary:01000101,value:69 6fmt.Println(\u0026#34;\u0026#34;) 7fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, b, b) //binary:10001010,value:138 8fmt.Println(\u0026#34;\u0026#34;) 9fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, c, c) //binary:00100010,value:34 10 11fmt.Println(\u0026#34;\\n\\n---------------\\n\u0026#34;) 12//example 2 13d := 0b01010101 14e := d \u0026lt;\u0026lt; 3 15f := d \u0026gt;\u0026gt; 3 16fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, d, d) //binary:01010101,value:85 17fmt.Println(\u0026#34;\u0026#34;) 18fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, e, e) //binary:1010101000,value:680 19fmt.Println(\u0026#34;\u0026#34;) 20fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, f, f) //binary:00001010,value:10 21fmt.Println(\u0026#34;\u0026#34;) 22 */ در مثال دو همانطور که مشاهده کردید زمانی که از عملگر \u0026gt;\u0026gt; استفاده کردید در صورتی که اولین خانه باینری از سمت چپ مقدار 1 داشته باشد مابقی مقدار به صورت 0 به باینری اضافه می‌شود و در غیر این صورت 1 ها به همان مقدار به سمت چپ خواهد رفت.\nدر واقع 08b% یک شناساگر قالب (format specifier) برای نمایش باینری در هشت خانه است در اینجا می‌توانید بیشتر راجب شناساگرهای قالب بخوانید. عملگر \u0026amp; به انگلیسی AND به فارسی و دو مقدار باینری رو با یک دیگر مقایسه و اگر هر بیت مقدار 1 در هر دو طرف داشته باشد آن را 1 نگه می‌دارد و در غیر اینصورت آن بیت را 0 می‌کند. عملگر | به انگلیسی OR به فارسی یا دو مقدار باینری رو با یک دیگر مقایسه و اگر هر بیت مقدار 1 در یک طرف یا هر دوطرف داشته باشد آن را 1 نگه می‌دارد و در غیر اینصورت آن بیت را 0 می‌کند. عملگر ^ به انگلیسی XOR به فارسی نامی ندارد دو مقدار باینری رو با یک دیگر مقایسه و اگر هر بیت مقدار 1 در هر دوطرف داشته باشد آن را 0 می‌کند.\n1//\u0026amp; operator example 2a := 0b01000101 3b := 0b01010100 4c := a \u0026amp; b 5fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, a, a) //binary:01000101,value:69 6fmt.Println(\u0026#34;\u0026#34;) 7fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, b, b) //binary:01010100,value:84 8fmt.Println(\u0026#34;\u0026#34;) 9fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, c, c) //binary:01000100,value:68 10 11fmt.Println(\u0026#34;\\n\\n---------------\\n\u0026#34;) 12 13//| operator example 14d := 0b01000101 15e := 0b01010100 16f := d | e 17fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, d, d) //binary:01000101,value:69 18fmt.Println(\u0026#34;\u0026#34;) 19fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, e, e) //binary:01010100,value:84 20fmt.Println(\u0026#34;\u0026#34;) 21fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, f, f) //binary:01010101,value:85 22 23fmt.Println(\u0026#34;\\n\\n---------------\\n\u0026#34;) 24 25//^ operator example 26g := 0b01000101 27h := 0b01010100 28i := a ^ b 29fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, g, g) //binary:01000101,value:69 30fmt.Println(\u0026#34;\u0026#34;) 31fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, h, h) //binary:01010100,value:84 32fmt.Println(\u0026#34;\u0026#34;) 33fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, i, i) //binary:00010001,value:17 1.4.5 اولویت عملگرها # در زبان گو یکسری اولویت‌ها برای عملگرها وجود دارد و همچنین در زبان گو مثل سایر زبان‌ها پرانتز () ترویج دهنده اولویت‌ها است.\n1 * / % \u0026lt;\u0026lt; \u0026gt;\u0026gt; \u0026amp; \u0026amp;^ 2 + - | ^ 3 == != \u0026lt; \u0026lt;= \u0026gt; \u0026gt;= 4 \u0026amp;\u0026amp; 5 || توجه در زبان گو اولویت \u0026lt;\u0026lt; و \u0026gt;\u0026gt; بیشتر از + و - است. "},{"id":13,"href":"/chapter-1/go-variables-and-consts/","title":"1.5 متغیرها و constant","section":"فصل اول: آشنایی با مفاهیم گو","content":" 1.5.1 متغیر (Variable) # در برنامه‌نویسی رایانه، یک متغیر یک مکان در حافظه (آدرس حافظه) است که دارای یک نام نمادین با عنوان است و می‌تواند حاوی اطلاعات یا یک مقدار معلوم یا مجهول که به آن ارزش یا مقدار می‌گویند، باشد. به زبان دیگر، متغیر در برنامه‌نویسی به فضایی که برای ذخیره داده‌ها کنار گذاشته شده‌ است می‌گویند (به نقل از سایت ویکی پدیا)\nتعریف یک متغیر رشته # 1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7func main() { 8\tvar s string = \u0026#34;Hello World\u0026#34; 9\tfmt.Println(s) 10} 1$ go run main.go 2Hello World یک متغیر با استفاده از کلید واژه var ایجاد کردیم. نام متغیر را s گذاشتیم. تایپ متغیر را از نوع string تعیین کردیم. سپس با عملگر = مقدار متغیر را مشخص از نوع رشته تعیین کردیم. رشته \u0026quot;Hello World\u0026quot; به عنوان مقدار متغیر s است و این مقدار در خانه مشخصی از حافظه قرار داده شده است. از پکیج استاندارد fmt برای چاپ مقدار متغیر s استفاده کردیم که این پکیج یکسری توابع جهت انجام عملیات‌های مختلفی نظیر چاپ مقادیر را دارد که در کد بالا ما از تابع Println استفاده کردیم. 1.5.1.1 اختصاص مقدار جدید به متغیر از قبل ایجاد شده # در کد زیر ما یک متغیر از قبل تعریف کردیم و مقدار جدید را در خط ۹ به متغیر اختصاص دادیم.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7func main() { 8\tvar s string 9\ts = \u0026#34;Hello World\u0026#34; 10\tfmt.Println(s) 11} زمانی که شما یک متغیر بصورت var s string تعریف می‌کنید مقدار پیش‌فرض \u0026quot;\u0026quot; برای متغیر تعیین شده است. 1.5.1.2 اختصاص مقدار رشته به تایپ اشتباه # 1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7func main() { 8\tvar i int 9\ti = \u0026#34;One\u0026#34; 10\tfmt.Println(i) 11} 1$ go run main.go 2./main.go:cannot use \u0026#34;One\u0026#34; (type string) as type int in assignment در کد بالا ما یک متغیر از نوع int تعریف کردیم و در خط ۹ مقدار \u0026quot;One\u0026quot; را به آن تخصیص دادیم و پس از اجرا با خطای cannot use \u0026quot;One\u0026quot; (type string) as type int in assignment مواجه شدیم. این خطا یعنی اینکه شما یک مقدار رشته را به تایپ اشتباه اختصاص داده‌اید.\n1.5.1.3 تعریف متغیر به صورت خلاصه # زبان گو علاوه بر اینکه از کلید واژه var برای تعریف متغیر پشتیبانی می‌کند, از =: به انگلیسی short variable declaration نیز برای تعریف متغیرها پشتیبانی می‌کند. شما می‌توانید یک متغیر تعریف کنید و نیازی به مشخص کردن تایپ متغیر نیست، چون زبان گو بر اساس مقدار تعیین شده تایپ متغیر را تشخیص می‌دهد.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\ts := \u0026#34;Hello World\u0026#34; 7\tfmt.Println(s) 8} توجه کنید شما فقط داخل تابع می‌توانید به صورت مختصر متغیر تعریف کنید و جهت تعریف متغیر بصورت عمومی باید از کلید واژه var استفاده کنید.\nبهتر است برای تعریف متغیر داخل تابع از از روش مختصر استفاده کنید و متغیر با var بصورت عمومی در بدنه کد باشد.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7var s string = \u0026#34;Hello World\u0026#34; 8 9func main() { 10\tfmt.Println(s) 11} 1.5.1.4 تعریف چند متغیر در یک خط # در زبان گو شما می‌توانید همزمان چند متغیر را در یک خط تعریف کنید که در زیر یک نمونه کد مثال زدیم :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\ta, b, c := \u0026#34;hello\u0026#34;, 1, 1.5 7\tvar d, e, f = \u0026#34;world\u0026#34;, 13, 24 8\tfmt.Println(a, b, c, d, e, f) 9} 1$ go run main.go 2hello 1 1.5 world 13 24 1.5.1.5 تعریف متغیر با مقدار پیش‌فرض # در کد زیر ما یکسری متغیر با تایپ‌های مختلف تعریف کردیم که با مقدار پیش‌فرض ایجاد شده‌اند.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 var i int 7 var f float32 8 var b bool 9 var s string 10 fmt.Printf(\u0026#34;%v %v %v %q\\n\u0026#34;, i, f, b, s) //0 0 false \u0026#34;\u0026#34; 11} 1.5.2 مقدار ثابت (Constant) # ثابت (Constant)‌ها بر خلاف متغیر‌ها که با کلید واژه var تعریف می‌شود, با کلید واژه const تعریف می‌شوند با این تفاوت که ثابت‌ها در طول اجرای کد مقدارشان غیرقابل تغییر هست به انگلیسی Immutable, و تضمین می‌کنند هیچ چیزی در طول اجرای برنامه, باعث تغییر مقدار ثابت نشود.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7const s string = \u0026#34;Hello World\u0026#34; 8 9func main() { 10\tfmt.Println(s) 11} 1$ go run main.go 2Hello World همانطور که در مثال فوق گفتیم شما نمی‌توانید ثابت‌ها را مجددا مقدار دهی کنید. در مثال زیر خطایی که بعد از مقدار دهی دوباره یک ثابت در زمان اجرا رخ داده است را قرار دادیم :\n1package main 2 3func main() { 4 const a int = 8 5 a = 9 6} 1$ go run main.go 2main.go:5:cannot assign to a 1.5.2.1 تعریف Constant بدون نیاز به تعیین تایپ # در تعریف ثابت‌ها همانند متغییر ها شما می‌توانید یک ثابت بدون تعیین تایپ تعریف کنید و زبان گو در زمان اجرا با توجه به مقدار اختصاص داده شده به ثابت شما, تایپ را تشخیص می دهد.\n1const a = 1 //Default hidden type is int 2const b = \u0026#34;circle\u0026#34; //Default hidden type is string 3const c = 5.4 //Default hidden type is float64 4const d = true //Default hidden type is bool 5const e = \u0026#39;a\u0026#39; //Default hidden type is rune 6const f = 3+5i //Default hidden type is complex128 1.5.3 نحوه مشاهده تایپ متغیر یا Constant # در مثال زیر ما با استفاده از یکی از توابع پکیج fmt نوع و مقدار متغیر یا ثابت ها را چاپ کردیم.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5// Named untyped constant 6const a = 123 //Default hidden type is int 7const b = \u0026#34;circle\u0026#34; //Default hidden type is string 8const c = 5.6 //Default hidden type is float64 9const d = true //Default hidden type is bool 10const e = \u0026#39;a\u0026#39; //Default hidden type is rune 11const f = 3 + 5i //Default hidden type is complex8 12 13var u = 123 //Default hidden type is int 14var v = \u0026#34;circle\u0026#34; //Default hidden type is string 15var w = 5.6 //Default hidden type is float64 16var x = true //Default hidden type is bool 17var y = \u0026#39;a\u0026#39; //Default hidden type is rune 18var z = 3 + 5i //Default hidden type is complex128 19 20func main() { 21\tfmt.Println(\u0026#34;\u0026#34;) 22\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, a, a) 23\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, b, b) 24\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, c, c) 25\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, d, d) 26\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, e, e) 27\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, f, f) 28 29\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, u, u) 30\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, v, v) 31\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, w, w) 32\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, x, x) 33\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, y, y) 34\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, z, z) 35} 1.5.3.1 استفاده از iota در constant # شناسه iota فقط با ثابت‌ها قابل استفاده است و با آن می‌توانید اعداد auto increment ایجاد کنید.\nایجاد auto increment بدون iota :\n1const ( 2 a = 0 3 b = 1 4 c = 2 5) ایجاد auto increment با iota :\n1const ( 2 a = iota // 0 3 b // 1 4 c // 2 5) توجه کنید مقدار پیش‌فرض iota صفر, و ثابت ما از نوع int است. 1.5.3.2 نحوه ایجاد enum # از iota و ثابت برای ایجاد enum ها هم می‌توان استفاده کرد که در مثال زیر یک نمونه کد برای ایجاد enum را نیز قرار داده‌ایم.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type Size uint8 6 7const ( 8\tsmall Size = iota 9\tmedium 10\tlarge 11\textraLarge 12) 13 14func main() { 15\tfmt.Println(small) 16\tfmt.Println(medium) 17\tfmt.Println(large) 18\tfmt.Println(extraLarge) 19} 1$ go run main.go 20 31 42 53 1.5.3.3 نادیده گرفتن مقدار اول iota # وقتی که داریم از iota استفاده می‌کنیم شاید هنگام استفاده از auto increament نیاز باشد مقدار اول را نادیده بگیریم. برای اینکار می‌توان از _ استفاده کرد به شکل زیر :\n1const ( 2 _ = iota // ignore 3 a // 1 4 b // 2 5 c // 3 6) 1.5.3.4 خودآزمون iota # خروجی کد زیر را در ذهن محاسبه کنید و با اجرای کد صحت آن را بررسی کنید.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tconst ( 7\tA = iota 8\tB 9\tC 10\tD = B + C 11\tE 12\tF 13\tG = iota 14\tH 15\tI = H 16\tJ 17\tK 18\t) 19\tfmt.Println(A, B, C, D, E, F, G, H, I, J, K) 20} 1.5.4 قوانین نام‌گذاری متغیر و constant # در زیر ما یکسری قوانین جهت نام‌گذاری متغیر و تابت‌ها تعریف کرده‌ایم :\nنام متغیر یا ثابت باید با یک حرف انگلیسی یا _ شروع شود. نام‌ها می‌توانند ترکیبی از اعداد و حروف انگلیسی یا _ باشد. زبان گو به حروف بزرگ و کوچک در نام ها حساس است و اگر شما hello یا Hello را تعریف کنید, ۲ متغیر یا ثابت متفاوت محسوب می‌شوند. محدودیتی در تعداد حروف نام‌ها وجود ندارد ولی بهتر است از یک تعداد مطلوب و مشخصی برای نام‌ها استفاده کنید. توجه داشته باشید اصولا اسم ثابت‌ها را با حروف بزرگ و خارج از توابع تعریف می‌کنند.\nبا تعریف کردن ثابت‌ها با حروف بزرگ, هنگام استفاده مشخص‌تر خواهند بود. از آنجایی که ثابت‌ها فقط امکان read یا همان خواندن را می‌دهند ممکن است در قسمت‌های مختلف به آن مقادیر نیاز داشته باشیم. به دلیل اینکه با هر بار فراخوانی تابع, کامپایلر عملیات مقدار دهی ثابت را دوباره انجام می‌دهد, بهتر است آن را خارج از تابع تعریف کنیم. "},{"id":14,"href":"/chapter-1/go-zero-values/","title":"1.6 مقادیر صفر تایپ‌ها (zero values)","section":"فصل اول: آشنایی با مفاهیم گو","content":"در جدول زیر فهرست تمامی تایپ‌ها را با مقادیر صفرشان (پیش‌فرض) قرار دادیم:\nتایپ مقدار پیش فرض یا مقدار صفر int 0 int8 0 int16 0 int32 0 int64 0 uint 0 uint8 0 uint16 0 uint32 0 uint64 0 uintptr 0 float32 0 float64 0 complex64 0+0i complex128 0+0i bool false string \u0026quot;\u0026quot; interface nil slice nil channel nil map nil pointer nil function nil struct براساس مقدار پیش فرض فیلدها نمونه کد نمایش مقدار صفر تایپ‌ها:\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7func main() { 8\tvar ( 9\ta int 10\tb int8 11\tc int16 12\td int32 13\te int64 14\tf uint 15\tg uint8 16\th uint16 17\ti uint32 18\tj uint64 19\tk uintptr 20\tl float32 21\tm float64 22\tn complex64 23\to complex128 24\tp bool 25\tq string 26\tr interface{} 27\ts []int 28\tt chan int 29\tu map[string]int 30\tv *int 31\tw func() 32\tx struct{} 33\ty struct { 34\tya int 35\tyb bool 36\tyc rune 37\t} 38\t) 39 40\tfmt.Println(\u0026#34;int:\u0026#34;, a) 41\tfmt.Println(\u0026#34;int8:\u0026#34;, b) 42\tfmt.Println(\u0026#34;int16:\u0026#34;, c) 43\tfmt.Println(\u0026#34;int32:\u0026#34;, d) 44\tfmt.Println(\u0026#34;int64:\u0026#34;, e) 45\tfmt.Println(\u0026#34;uint:\u0026#34;, f) 46\tfmt.Println(\u0026#34;uint8:\u0026#34;, g) 47\tfmt.Println(\u0026#34;uint16:\u0026#34;, h) 48\tfmt.Println(\u0026#34;uint32:\u0026#34;, i) 49\tfmt.Println(\u0026#34;uint64:\u0026#34;, j) 50\tfmt.Println(\u0026#34;uintptr:\u0026#34;, k) 51\tfmt.Println(\u0026#34;float32:\u0026#34;, l) 52\tfmt.Println(\u0026#34;float64:\u0026#34;, m) 53\tfmt.Println(\u0026#34;complex64:\u0026#34;, n) 54\tfmt.Println(\u0026#34;complex128:\u0026#34;, o) 55\tfmt.Println(\u0026#34;bool:\u0026#34;, p) 56\tfmt.Println(\u0026#34;string:\u0026#34;, q) 57\tfmt.Println(\u0026#34;interface:\u0026#34;, r) 58\tfmt.Println(\u0026#34;slice:\u0026#34;, s) 59\tfmt.Println(\u0026#34;channel:\u0026#34;, t) 60\tfmt.Println(\u0026#34;map:\u0026#34;, u) 61\tfmt.Println(\u0026#34;pointer:\u0026#34;, v) 62\tfmt.Println(\u0026#34;function:\u0026#34;, w) 63\tfmt.Println(\u0026#34;struct:\u0026#34;, x) 64\tfmt.Println(\u0026#34;struct:\u0026#34;, y) 65} "},{"id":15,"href":"/chapter-1/go-function/","title":"1.7 تابع (function)","section":"فصل اول: آشنایی با مفاهیم گو","content":" 1.7.1 تابع چیست؟ # در برنامه‌نویسی، تابع به تکه کدهایی گفته می‌شود که برای انجام عملی خاص استفاده می‌شوند. به کمک توابع می‌توانیم تکه کدها را از یکدیگر جدا کنیم و از تکرار کدها جلوگیری کنیم.\nهمانند شکل زیر تابع مانند یک جعبه (یا قطعه کد) است. که یک مقدار ورودی گرفته و روی آن پردازش‌هایی انجام می‌دهد و یک خروجی تولید می‌کند. تابع می‌تواند هر چندتا ورودی یا خروجی داشته باشد. 1.7.1.1 چرا از توابع در برنامه نویسی استفاده می‌کنیم؟ # با استفاده از توابع، می‌توانیم یک قطعه کد را یک بار بنویسیم و چندین بار از آن استفاده کنیم. با استفاده از توابع، حجم کدنویسی ما کم‌تر می‌شود و سرعت توسعه نرم‌افزار بیشتر می‌شود. توابع به ما کمک می‌کنند تا کد خود را به تکه‌هایی کوچک‌تر تقسیم کنیم تا برنامه ی ما خوانا و قابل درک‌تر باشد. همچنین نگهداری و اشکال زدایی کد را آسان‌تر می‌کند. 1.7.2 توابع در زبان گولنگ # توابع یکی از قابلیت‌های مهم هر زبانی محسوب می‌شوند. توابع در گولنگ داری سینتکس ساده‌ای هستند.\n1.7.2.1 تعریف یک تابع # 1func function_name( [Parameter-list] ) [return_types] { 2 3 // body of the function 4 5} func - با این کلید واژه یک تابع تعریف می‌کنیم. function_name - نام تابع باید یکتا و در طول برنامه منحصر به فرد باشد. Parameter-list - پارامترهای ورودی در این قسمت تعریف می‌شوند. پارامترها اختیاری هستند یعنی ممکن است یک تابع هیچ پارامتری نداشته باشد. Return_type - نوع داده‌های بازگشتی را در این قسمت مشخص می‌کنیم و در برخی توابع عملیات موردنظر را بدون بازگرداندن مقداری انجام می‌دهند در این توابع نیازی به تعیین return_type نیست. Function Body - این قسمت شامل کدهایی است که نشان می‌دهد تابع چه کارهایی انجام می‌دهد. 1.7.2.1.1 مثال # 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func plus(a int, b int) int { 6\treturn a + b 7} 8 9func main() { 10\tfmt.Println(plus(4, 13)) 11} 1$ go run func.go 217 در اینجا یک تابع با نام plus تعریف کردیم که دو پارامتر a, b را با نوع داده int دریافت می‌کند و جمع این دو عدد را حساب می‌کند. توجه کنید که همیشه باید نوع داده را مشخص کنیم. بعد از تعریف پارامترهای ورودی و قبل از قرار دادن کد داخل براکت int را می‌بینید که نوع خروجی داده را مشخص می‌کند، یعنی خروجی این تابع باید از نوع int باشد. برای صدا زدن توابع کافی است نام تابع رو همراه با پرانتز باز و بسته تایپ کنید, برای مثال ()plus. در صورتی که نوع پارامترهای ورودی از یک نوع باشند بجای تعریف تک تک نوع داده‌ها می‌توانیم نوع داده را در آخر همه پارامترهای هم نوع مشخص کنیم.\n1func plus(a, b int) 2// or 3func name(a string, b,c int) 1.7.2.1.2 الگو دیگر تعریف تابع: # 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tplus := func (a int, b int) int { 7\treturn a + b 8\t} 9\tfmt.Println(plus(3, 4)) 10} 1$ go run main.go 27 1.7.3 قوانین نام گذاری تابع در گولنگ # نام تابع باید با یک حرف شروع شود. نام تابع فقط می‌تواند شامل حروف-عدد و underscores باشد. (A-z, 0-9, _ ) نام تابع به حروف کوچک و بزرگ حساس است. در نام‌گذاری تابع از فاصله نمی‌توانیم استفاده کنیم. ‬1.7.4 توابع چند بازگشتی در گولنگ (Multiple results) # همچنین در گولنگ توابع می‌توانند چندین مقادیر را برگردانند.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func vals() (int, int) { 6 return 3, 7 7} 8 9func main() { 10 11 a, b := vals() 12 fmt.Println(a) 13 fmt.Println(b) 14 15 _, c := vals() 16 fmt.Println(c) 17} 1$ go run main.go 23 37 47 در کد بالا تابعی ساختیم با اسم vals که دو خروجی از نوع int دارد بنابراین نوع تعریف توابع چندبازگشتی متفاوت است و بصورت (data-type, data-type, \u0026hellip; ) است. در مثال اول ما با کمک دو متغیر a,b دو خروجی تابع vals را دریافت کردیم. در مثال دوم ما با استفاده از _ blank identifier از دریافت یا استخراج خروجی اول صرف نظر کردیم و فقط خروجی دوم با متغیر c را دریافت کردیم. در توابع چند بازگشتی خروجی آنها را باید با , از هم جدا کرد 1.7.4.1 مقادیر بازگشتی نام گذاری شده (Named Return Values) # در گولنگ می‌توانیم مقدار بازگشتی یک تابع را نامگذاری کنیم. به مثال زیر توجه کنید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func split(sum int) (x, y int) { 6\tx = sum * 4 / 9 7\ty = sum - x 8\treturn 9} 10 11func main() { 12\tfmt.Println(split(17)) 13} 1$ go run main.go 27 10 ما در این تابع مقدار بازگشتی را x, y از نوع int نام گذاری می‌کنیم. در اینجا یک دستور return بدون تعیین آرگومان بازگشتی، مقادیر نام گذاری شده را باز می‌گرداند، که به عنوان Naked return شناخته می‌شود. از naked return باید در توابع کوتاه مانند مثال بالا استفاده شود. استفاده آن در تابع طولانی منجر به کاهش خوانایی کد می شود. 1.7.5 توابع متنوع در گولنگ (Variadic Functions) # یکی از قابلیت‌های گو وجود توابع متنوع است. منظور از توابع متنوع توابعی هستند که بدون محدودیت پارامتر دریافت می‌کنند (این نکته رو در نظر بگیرین که نباید تایپ ورودی‌ها با یکدیگر فرق کند، برای مثال همه باید int باشند). ‍‍\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func sum(nums ...int) { 6 fmt.Print(nums, \u0026#34; \u0026#34;) 7 total := 0 8 9 for _, num := range nums { 10 total += num 11 } 12 fmt.Println(total) 13} 14 15func main() { 16 17 sum(1, 2) 18 sum(1, 2, 3) 19 20 nums := []int{1, 2, 3, 4} 21 sum(nums...) 22} 1$ go run variadic-functions.go 2[1 2] 3 3[1 2 3] 6 4[1 2 3 4] 10 در اینجا تابعی تعریف کردیم که تعداد دلخواهی از آرگومان‌ها از نوع int را به کمک \u0026hellip; (بهش میگن Ellipsis) که قبل از نوع داده قرار گرفته به داخل تابع منتقل می‌کند. برای صدا زدن این توابع می‌توان به روش sum(num1, num2, \u0026hellip;) عمل کرد. اگر شما داده‌ای با نوع slice دارید می‌توانید آن را به کمک اپراتور \u0026hellip;(Ellipsis) به صورت sum(nums\u0026hellip;) به داخل تابع انتقال بدید. 1.7.6 توابع ناشناس در گولنگ (Anonymous Functions) # در زبان گولنگ می‌توانیم تابع بدون نام تعریف کنیم، که به عنوان توابع ناشناس شناخته می‌شوند.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 7 // anonymous function 8 var sum = func(n1, n2 int) int { 9 sum := n1 + n2 10 11 return sum 12 } 13 14 // function call 15 result := sum(5, 3) 16 17 fmt.Println(\u0026#34;Sum is:\u0026#34;, result) 18 19} 1$ go run main.go 2Sum is: 8 از آنجایی که توابع ناشناس نامی ندارد ما در بعضی اوقات آن‌ها را به یک متغیر اختصاص می‌دهیم سپس از نام متغیر برای فراخوانی تابع استفاده می‌کنیم. در این مثال می‌بینید که ما از sum برای فراخوانی تابع استفاده می‌کنیم. مانند توابع معمولی ما می‌توانیم برای تابع ناشناس پارامتر تعریف کنیم و همچنین مقداری را از تابع برگردانیم در این مثال تابع دو مقدار با نوع داده int دریافت می‌کنید و یک خروجی با نوع int دارد. تابع ناشناس را می‌توان برای عملکردهایی که نیازی به نام‌گذاری ندارند و معمولا برای استفاده کوتاه مدت هست، استفاده کرد. اما یکی از موارد کاربردی توابع ناشناس در گولنگ پاس دادن آن‌ها به توابعی هستند که تابعی را تحت عنوان پارامتر ورودی دریافت میکنند. در مثال زیر ما یک تابع تعریف کردیم که در پارامتر سوم یک تابع دریافت می‌کند که باید دو ورودی int و یک خروجی int داشته باشد.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func add10AndSum(num1 int, num2 int, sum func(n1, n2 int) int) { 6 result := sum(num1+10, num2+10) 7 fmt.Println(\u0026#34;Sum by adding 10 is:\u0026#34;, result) 8} 9 10func main() { 11 add10AndSum(5, 3, func(n1, n2 int) int { 12 sum := n1 + n2 13 14 return sum 15 }) 16} 1$ go run main.go 2Sum by adding 10 is: 28 1.7.7 توابع از پیش تعریف شده (Built-in Function) # در گولنگ علاوه بر تابع‌هایی که توسط کابر تعریف می‌شود یکسری توابع وجود دارد که از قبل تعریف شده‌اند که طراحان این زبان برای سهولت کار برنامه‌نویسان این توابع را نوشته‌اند و آن را همراه زبان گولنگ ارائه می‌دهند.\nhttps://book.gofarsi.ir/chapter-1/go-builtins/\n"},{"id":16,"href":"/chapter-1/go-array/","title":"1.8 آرایه و slice","section":"فصل اول: آشنایی با مفاهیم گو","content":"آرایه و slice دو نوع تایپ با یک وجه اشتراک در زبان گو هستند ولی این دو نوع تایپ یکسری تفاوت‌هایی نیز با هم دارند که در ادامه به آن‌ها می‌پردازیم.\n1.8.1 تعریف آرایه # آرایه یکی از عمومی‌ترین تایپ‌ها در زبان‌های برنامه‌نویسی آرایه‌ها هستند که برای نگه داری گروهی مقادیر از یک نوع تایپ استفاده می‌شود. برای دسترسی به هر کدام از مقادیر درون آرایه باید از اندیس استفاده کرد. معمولا برای تعریف آرایه تعداد مشخص و ثابتی را برای تعداد مقادیر مشخص میکنید. یعنی این آرایه قرار است چند تا مقدار نگه داری کند.\nدر مثال زیر یک نمونه کد در خصوص چگونگی تعریف آرایه قرار داده‌ایم :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tarrayInts := [5]int{1, 25, 12354, 654, 32} 7\tfmt.Println(arrayInts) 8} 1$ go run array.go 2[1 25 12354 654 32] یک متغیر کوتاه از نوع آرایه با نام arrayInts تعریف کردیم. ظرفیت آرایه را با عدد ۵ تعیین کردیم (یعنی این آرایه فقط ۵ تا مقدار بیشتر نگه داری نمی‌کند) سپس تایپ آرایه را از نوع int مشخص کردیم. در نهایت در همانجا آرایه را مقدار دهی کردیم. در زبان گو مقدار دهی با باز کردن {} به انگلیسی curly bracket انجام می‌شود. 1.8.2 مفهوم اندازه و ظرفیت (size, capacity) # در آرایه ما ۲ تا مفهوم داریم: اندازه و ظرفیت که از عنوان این مفهوم مشخص است آرایه دارای یک اندازه و ظرفیت مشخصی است و اگر شما بیشتر از ظرفیت و اندازه تعیین شده مقدار دهی کنید با خطا مواجه خواهید شد.\nدر آرایه ظرفیت به نسبت اندازه تعیین می‌شود. 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tarrayString := [3]string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;} 7\tfmt.Println(arrayString) 8} 1$ go run array.go 2./prog.go:6:42: index 3 is out of bounds (\u0026gt;= 3) در کد فوق ما یک آرایه با اندازه ۳ تعریف کردیم و ۴ تا مقدار داخلش قرار دادیم و پس از اجرا, با خطای تعداد مقادیر بیشتر از اندازه و ظرفیت می باشد مواجه شدیم.\n1.8.2.1 تابع len و cap # برای آرایه و slice ما ۲ تا تابع داریم که می‌توانیم اندازه و ظرفیت یک آرایه یا slice را بگیریم.\nتابع len یکی از توابع بسیار کاربردی و پراستفاده هنگام کار با آرایه یا slice است که می‌توانید اندازه آرایه یا slice را بگیرید. تابع cap ظرفیت آرایه و slice را نمایش می‌دهد. 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tarrayString := [3]string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;} 7\tfmt.Printf(\u0026#34;array %v, len %d, cap %d\u0026#34;, arrayString, len(arrayString), cap(arrayString)) 8} 1$ go run main.go 2array [a b c], len 3, cap 3 1.8.3 تعریف آرایه و مقدارهی # در مثال زیر ما یک آرایه با مقدار 5 تعریف کردیم و قصد داریم در ادامه کد، آرایه رو مقداردهی کنیم.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tnums := [5]int{} 7\tfmt.Printf(\u0026#34;array nums values %v, len %d, cap %d\u0026#34;, nums, len(nums), cap(nums)) 8 9\tnums[0] = 1 10\tnums[1] = 2 11\tnums[2] = 10 12\tnums[4] = 999 13\t14\tfmt.Println(\u0026#34;\u0026#34;) 15\tfmt.Printf(\u0026#34;array nums values %v, len %d, cap %d\u0026#34;, nums, len(nums), cap(nums)) 16} 1$ go run main.go 2array nums values [0 0 0 0 0], len 5, cap 5 3array nums values [1 2 10 0 999], len 5, cap 5 در کد فوق در ابتدا ما یک آرایه بدون مقدار تعریف کردیم. سپس با استفاده از اندیس مقدار را در خانه مشخص قرار دادیم. 1.8.3.1 تعریف آرایه با اندازه تعیین شده توسط کامپایلر (شما اندازه رو بهش نمیدین.) # شما در زبان گو می‌توانید با استفاده از ... (Ellipsis) یک آرایه با اندازه مشخص شده توسط کامپایلر تعریف کنید.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tnums := [...]int{1, 25, 45, 8797, 78, 879, 541, 11} 7\tfmt.Printf(\u0026#34;array nums values %v, len %d, cap %d\u0026#34;, nums, len(nums), cap(nums)) 8} 1$ go run main.go 2array nums values [1 25 45 8797 78 879 541 11], len 8, cap 8 توجه کنید زمانی که ... (Ellipsis) برای تعریف آرایه استفاده می‌کنید فقط در همان لحظه تعریف می‌توانید آرایه رو مقدار دهی کنید. 1.8.3.2 تعریف آرایه دو بعدی یا چند بعدی # در زبان گو همانند سایر زبان‌ها می‌توانید آرایه دو بعدی یا چند بعدی تعریف کنید. این نوع آرایه‌ها برای پیاده‌سازی ماتریس یا یکسری سناریوهای توسعه کاربردی مناسب هستند.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tnums := [2][2][2]int{{{1, 2}, {2, 3}}, {{4, 5}, {6, 7}}} 7\tfmt.Printf(\u0026#34;array nums values %v, len %d, cap %d\u0026#34;, nums, len(nums), cap(nums)) 8} 1$ go run main.go 2array nums values [[[1 2] [2 3]] [[4 5] [6 7]]], len 2, cap 2 1.8.3.3 مقایسه آرایه‌ها # در کد زیر ما یک نمونه از مقایسه آرایه‌ها را قرار داده‌ایم که این مقایسه براساس تایپ، اندازه و مقادیر در نظر گرفته شده است.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tnums := [2]int{1, 2} 7\tnums2 := [2]int{1, 3} 8\tnums3 := [2]int{1, 2} 9\tnums4 := [3]int{1, 2, 3} 10\tchars := [2]string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;} 11 12\tfmt.Println(nums == nums2) // false 13\tfmt.Println(nums == nums3) // true 14\tfmt.Println(nums == nums4) // error: invalid operation: nums == nums4 (mismatched types [2]int and [3]int) 15\tfmt.Println(nums == chars) // error: invalid operation: nums == chars (mismatched types [2]int and [2]string) 16} 1.8.4 برش (slice) # همانطور که می‌دانید آرایه یکی از مهم‌ترین عناوین در زبان‌های برنامه‌نویسی است، اما در زبان گو slice نسبت به آرایه بسیار پر استفاده و کاربردی‌تر است. اگر بخواهیم خیلی ساده slice را توصیف کنیم در واقع \u0026ldquo;یک slice به عنوان یک بخش بهم پیوسته از یک آرایه تعریف می‌شود که شما می‌توانید المنت‌ها را در حال اجرا افزایش یا کاهش دهید بدون آنکه ظرفیت و اندازه آن را مشخص کنید.\u0026rdquo;\nاما این سوال پیش می‌آید علت اینکه slice به نسبت آرایه کاربرد بیشتری دارد چیست؟ آرایه دارای برخی از محدودیت‌ها علی الخصوص، اندازه ثابت می‌باشد اما در slice شما این محدودیت‌ها را نخواهید داشت و خیلی ساده می‌توانید المنت‌ها را افزایش، حذف و حتی کپی کنید.\nدر زبان گو slice‌ها یک پارچگی آرایه را حفظ می‌کنند و کار با آرایه خیلی ساده و آسان‌تر خواهد شد. 1.8.4.1 تعریف یک slice با اندازه مشخص # شما می توانید با استفاده از تابع make یک slice با اندازه مشخص تعریف کنید.\n1slice := make([]int, 5) 2 3fmt.Println(len(slice)) // Print 5 4 5fmt.Println(cap(slice)) // Print 5 1.8.4.2 تعریف یک slice با اندازه و ظرفیت مشخص # شما می‌توانید با استفاده از تابع make یک slice با ظرفیت و اندازه مشخص تعریف کنید.\n1slice := make([]int, 3, 5) 2 3fmt.Println(len(slice)) // Print 3 4 5fmt.Println(cap(slice)) // Print 5 توجه کنید مقدار ظرفیت نباید کمتر از مقدار اندازه باشد.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\ttest := make([]int, 5, 4) 7\tfmt.Println(test) 8} 1$ go run main.go 2./main.go:6:22: invalid argument: length and capacity swapped 1.8.4.3 تعریف یک slice با متغیر کوتاه short variable declaration # شما خیلی ساده می‌توانید یک slice را توسط متغیر کوتاه ایجاد کنید.\n1slice := []string{\u0026#34;Red\u0026#34;, \u0026#34;Blue\u0026#34;, \u0026#34;Green\u0026#34;, \u0026#34;Yellow\u0026#34;, \u0026#34;Pink\u0026#34;} 2 3fmt.Println(len(slice)) //Print 5 4 5fmt.Println(cap(slice)) //Print 5 6 7intSlice:= []int{10, 20, 30} 8 9fmt.Println(len(intSlice)) //Print 3 10 11fmt.Println(cap(intSlice)) //Print 3 1.8.4.4 تعریف یک slice با موقعیت‌های شاخص # شما می‌توانید یک slice را با موقعیت‌های شاخص ایجاد کنید که n تا المنت با مقدار پیش‌فرض ایجاد می‌کند و در آخر x را به آخر slice اضافه می‌کند. (در مثال زیر ۹۹ تا المنت با مقدار 0 و در اخر یک المنت با مقدار 88) درست می‌کند.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\ttest := []int{99: 88} 7\tfmt.Println(len(test), cap(test)) 8} 1.8.4.5 تعریف یک slice خالی # شما می‌توانید خیلی ساده یک slice خالی ایجاد کنید.\n1sliceOne := make([]int, 0) 2 3sliceTwo := []int{} 4 5fmt.Println(sliceOne == nil) // print false 6 7fmt.Println(len(sliceOne)) // print 0 8 9fmt.Println(cap(sliceOne)) // print 0 10 11fmt.Println(sliceTwo == nil) // print false 12 13fmt.Println(len(sliceTwo)) // print 0 14 15fmt.Println(cap(sliceTwo)) // print 0 1.8.5 مقدار دهی مجدد یکی از المنت های slice یا آرایه # شما خیلی راحت می‌توانید مقدار یکی از المنت‌های slice یا آرایه را مقدار دهی کنید.\n1slice := []int{10, 20, 30, 40} 2 3fmt.Println(slice) //print [10 20 30 40] 4 5slice[1] = 25 6 7fmt.Println(slice) // print [10 25 30 40] 1.8.6 ایجاد یک slice جدید بر اساس یک slice از پیش تعریف شده # شما می‌توانید یک slice جدید را بر اساس یک slice از پیش تعریف شده ایجاد کنید.\n1x := []int{10, 20, 30, 40, 50} 2 3fmt.Println(x) // Print [10 20 30 40 50] 4 5fmt.Println(len(x)) // Print 5 6 7fmt.Println(cap(x)) // Print 5 8 9y := x[1:3] 10 11fmt.Println(y) //Print [20 30] 12 13fmt.Println(len(y)) //Print 2 14 15fmt.Println(cap(y)) //Print 4 ما یک متغیر با نام x با ۵ تا المنت مقدار دهی شده تعریف کردیم. سپس یک متغیر کوتاه با نام y تعریف کردیم که متغیر x را داخلش قرار دادیم. سپس به متغیر x گفتیم از اندیس ۱ تا ۳ را به y اختصاص بدهد. توجه کنید اتفاقی که مثال بالا رخ داد این بود که ما اندازه و ظرفیت جدیدی برای متغیر y تعیین کردیم.\nLen: 3 - 1 = 2 Cap: 5 - 1 = 4\n1.8.7 خطای index out of range در slice # یک slice فقط با توجه به اندازه و اندیس‌هایش امکان دسترسی و مقدار دهی مجدد المنت هایش را می‌دهد، اما اگر شما بخواهید خارج از اندازه تعیین شده جهت مقداری دهی و یا دسترسی به slice اقدام کنید با خطای index out of range مواجه خواهید شد.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tslice := []int{10, 20, 30, 40, 50} 7\tnewSlice := slice[1:3] 8\tnewSlice[3] = 45 9\tfmt.Println(newSlice) 10} 1$ go run main.go 2panic: runtime error: index out of range [3] with length 2 3 4goroutine 1 [running]: 5main.main() 6\t/tmp/sandbox548843089/prog.go:8 +0x5b 1.8.8 افرودن (append) المنت‌های یک slice # شما خیلی ساده می‌توانید با استفاده از تابع append به المنت‌های یک slice بیفزایید.\n1slice := []int{10, 20, 30, 40, 50} 2 3newSlice := slice[1:3] 4 5fmt.Println(len(newSlice)) // Print 2 6 7fmt.Println(cap(newSlice)) // Print 4 8 9newSlice = append(newSlice, 60) 10 11fmt.Println(len(newSlice)) // Print 3 12 13fmt.Println(cap(newSlice)) // Print 4 در کد زیر اتفاقی که صورت گرفته است این است که اگر شما ... Ellipsis را بعد از کلمه slice بزارید یعنی دارید می‌گید تمامی المنت‌های داخل slice به newSlice اضافه شود.\n1slice := []int{10, 20, 30, 40, 50} 2 3newSlice := []int{} 4 5newSlice = append(newSlice, slice...) 1.8.9 نحوه حذف یک المنت در slice # برای حذف یک المنت در slice باید بصورت تکنیکی اینکار را انجام دهید چون زبان گو یک روش built-in برای این کار ندارد.\nدر این روش شما باید در ابتدا آخرین المنت را به المنت مورد نظر با استفاده از اندیس کپی کنید. سپس آخرین المنت را از slice حذف کنید. 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tslice := []int{10, 20, 30, 40, 50} 7\tslice[1] = slice[len(slice)-1] 8\tslice = slice[:len(slice)-1] 9\tfmt.Println(slice) 10} یک روش دیگر برای حذف یک المنت از slice استفاده از تابع append است. به مثال زیر توجه کنید. 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tslice := []int{1, 2, 3, 4, 5} 7\tindex := 2 // ایندکس المنتی که میخاییم حذفش کنیم 8\tslice = append(slice[:index], slice[index+1:]...) 9\tfmt.Println(slice) // خروجی: [1 2 4 5] 10} 1.8.10 تابع copy در slice # شما با استفاده از تابع copy می‌توانید یک slice را به slice دیگری کپی کنید.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tsrc := []int{1, 2, 3, 4, 5} 7\tdst := make([]int, 5) 8\tnumberOfElementsCopied := copy(dst, src) 9\tfmt.Println(numberOfElementsCopied, dst) 10} 1$ go run main.go 25 [1 2 3 4 5] 1.8.11 نحوه مرتب کردن (sort) یک slice # برای مرتب کردن یک slice می‌توانید از توابع کتابخانه sort در زبان گو استفاده کنید.\nsort.Ints sort.Float64s sort.Strings 1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;sort\u0026#34; 6) 7 8func main() { 9\ts := []int{4, 2, 3, 1} 10\tsort.Ints(s) 11\tfmt.Println(s) 12} 1$ go run main.go 2[1 2 3 4] 1.8.12 فرق بین آرایه و slice # فرق نوع تعریف آرایه و slice برای تعریف آرایه شما باید داخل براکت [] یک مقداری را قرار دهید. برای تعریف slice هیچ مقداری را داخل براکت [] نباید قرار دهید. 1array := [3]int{10, 20, 30} 2 3slice := []int{10, 20, 30} فرق بین مقدار صفر آرایه و slice مقدار خالی slice ها nil است. مقدار خالی یک آرایه، همان آرایه با المنت‌های مقدار پیش‌فرض است. 1var slice []int32 2var array [2]int32 3 4fmt.Println(slice == nil) // print true 5fmt.Println(len(slice)) // print 0 6fmt.Println(cap(slice)) // print 0 7 8fmt.Println(array) // print [0 0] "},{"id":17,"href":"/chapter-1/go-for/","title":"1.9 حلقه‌ها (for)","section":"فصل اول: آشنایی با مفاهیم گو","content":" 1.9.1 حلقه # حلقه‌ها را در زبان گو به ساده‌ترین شکل ممکن و فقط با استفاده از کلید واژه for و در مدل‌های مختلف (سه‌بخشی، بی نهایت، foreach و \u0026hellip;) می‌توان پیاده‌سازی کرد.\n1.9.2 حلقه سه بخشی # این نمونه که متداول‌ترین نوع حلقه for نیز هستند با استفاده از سه‌ بخش:\nمقداردهی شرط شمارنده ایجاد می‌شوند.\n1for initialization ; condition ; counter { 2\t//loop codes 3} در مثال زیر نمونه‌ای از این حلقه‌ قابل مشاهده و اجرا است.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tsum := 0 7\tfor i := 1; i \u0026lt; 10; i++ { 8\tsum += i 9\t} 10 11\tfmt.Println(sum) 12} 1$ go run main.go 245 1.9.3 حلقه while # این مدل حلقه شبیه while در بیشتر زبان ها مثل پایتون و C است. با این تفاوت که پیاده‌سازی آن، تنها با کلیدواژه‌ی for و با حذف بخش مقداردهی و شمارنده حلقه سه‌بخشی انجام می‌گیرد. در واقع در این حلقه تنها یک شرط تعریف می‌شود و تا برقرار بودن آن شرط حلقه اجرا می‌شود. به مثال زیر توجه کنید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\ti := 0 7\tfor i \u0026lt; 10 { 8\tfmt.Println(i) 9\ti++ 10\t} 11} 1$ go run main.go 20 31 42 53 64 75 86 97 108 119 1.9.4 حلقه بی‌نهایت # اگر از حلقه‌ی while که در مثال بالا تعریف کردیم بخش شرط را حذف کنیم چه اتفاقی می‌افتد؟ در این حالت ما یک شرط بی نهایت ساخته‌ایم (شبیه به while(1)) که تا زمانی‌ که برنامه متوقف نشود و یا کدهای داخل حلقه، فرمان خروج از حلقه را ندهند، چرخه ی اجرای حلقه ادامه خواهد یافت.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tsum := 0 7\tfor { 8\tsum++ 9\t} 10 11\tfmt.Println(\u0026#34;this line will never execute\u0026#34;) 12} با اجرای کد بالا خطای تایم‌اوت دریافت خواهید کرد (اگر در playground سایت گو اجراش کنین)، به‌ دلیل اینکه حلقه هیچ‌گاه تمام نمی‌شود.\n1.9.5 حلقه for-range # حلقه for-range یکی از پرکاربردترین حلقه‌ها در زبان گو می‌باشد که شما می‌توانید برای slice، آرایه و map یا رشته از این حلقه استفاده کنید.\n1for index, value := range slice/array {} 1for key, value := range map {} 1.9.5.1 حلقه for-range برای slice و آرایه # شما با استفاده از حلقه for-range می‌توانید به المنت‌های آرایه یا slice و همچنین اندیس‌شان (Index) دسترسی پیدا کنید. دقت کنید ۲ حالت وجود دارد:\n1.9.5.1.1 دسترسی با استفاده از یک کپی از المنت # در کد زیر ما با استفاده از for-range به یک کپی از المنت‌های اسلایس letter دسترسی پیدا کردیم.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 letters := []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;} 7 8 //With index and value 9 fmt.Println(\u0026#34;Both Index and Value\u0026#34;) 10 for i, letter := range letters { 11 fmt.Printf(\u0026#34;Index: %d Value:%s\\n\u0026#34;, i, letter) 12 } 13 14\t//Only value 15 fmt.Println(\u0026#34;\\nOnly value\u0026#34;) 16 for _, letter := range letters { 17 fmt.Printf(\u0026#34;Value: %s\\n\u0026#34;, letter) 18 } 19} 1$ go run main.go 2Both Index and Value 3Index: 0 Value:a 4Index: 1 Value:b 5Index: 2 Value:c 6 7Only value 8Value: a 9Value: b 10Value: c 1.9.5.1.2 دسترسی مستقیم به خانه حافظه المنت # شما با استفاده از اندیس (index) می‌توانید مستقیماً به خانه حافظه المنت دسترسی پیدا کنید و آن المنت رو با استفاده از اندیس (Index) نمایش بدید. به مثال زیر توجه کنید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 letters := []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;} 7 8 fmt.Println(\u0026#34;\\nOnly letter\u0026#34;) 9 for i := range letters { 10 fmt.Printf(\u0026#34;letter: %s\\n\u0026#34;, letters[i]) 11 } 12} 1$go run main.go 2Only letter 3letter: a 4letter: b 5letter: c 1.9.1.2 حلقه for-range برای map # شما با استفاده از حلقه for-range برروی map, میتوانید به کلید و مقدار هر یک از مقادیر map دسترسی پیدا کنید.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 sample := map[string]string{ 7 \u0026#34;a\u0026#34;: \u0026#34;x\u0026#34;, 8 \u0026#34;b\u0026#34;: \u0026#34;y\u0026#34;, 9 } 10 11 //Iterating over all keys and values 12 fmt.Println(\u0026#34;Both Key and Value\u0026#34;) 13 for k, v := range sample { 14 fmt.Printf(\u0026#34;key :%s value: %s\\n\u0026#34;, k, v) 15 } 16 17 //Iterating over only keys 18 fmt.Println(\u0026#34;\\nOnly keys\u0026#34;) 19 for k := range sample { 20 fmt.Printf(\u0026#34;key :%s\\n\u0026#34;, k) 21 } 22 23 //Iterating over only values 24 fmt.Println(\u0026#34;\\nOnly values\u0026#34;) 25 for _, v := range sample { 26 fmt.Printf(\u0026#34;value :%s\\n\u0026#34;, v) 27 } 28} 1$go run main.go 2Both Key and Value 3key :a value: x 4key :b value: y 5 6Only keys 7key :a 8key :b 9 10Only values 11value :x 12value :y 1.9.1.3 حلقه for-range برای رشته (string) # شما با استفاده از حلقه for-range می توانید به هرکدام از کارکترهای رشته دسترسی پیدا کنید.\n1for index, character := range string { 2 //Do something with index and character 3} به کد نمونه زیر توجه کنید :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 sample := \u0026#34;a£b\u0026#34; 7 8 //With index and value 9 fmt.Println(\u0026#34;Both Index and Value\u0026#34;) 10 for i, letter := range sample { 11 fmt.Printf(\u0026#34;Start Index: %d Value:%s\\n\u0026#34;, i, string(letter)) 12 } 13 14 //Only value 15 fmt.Println(\u0026#34;\\nOnly value\u0026#34;) 16 for _, letter := range sample { 17 fmt.Printf(\u0026#34;Value:%s\\n\u0026#34;, string(letter)) 18 } 19 20 //Only index 21 fmt.Println(\u0026#34;\\nOnly Index\u0026#34;) 22 for i := range sample { 23 fmt.Printf(\u0026#34;Start Index: %d\\n\u0026#34;, i) 24 } 25} 1$ go run main.go 2Both Index and Value 3Start Index: 0 Value:a 4Start Index: 1 Value:£ 5Start Index: 3 Value:b 6 7Only value 8Value:a 9Value:£ 10Value:b 11 12Only Index 13Start Index: 0 14Start Index: 1 15Start Index: 3 1.9.6 کلید واژه break # با استفاده از break می‌توان چرخه‌ی اجرای یک حلقه را پایان داد. به عنوان مثال در حلقه بی‌نهایتی که در بخش 1.9.4 مشاهده کردید، می‌توان با تعریف یک شرط خاص از حلقه خارج شد. کد زیر نمونه استفاده از break را نمایش می‌دهد.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tsum := 0 7\tfor { 8\tsum++ 9\tif sum == 10 { 10\tbreak 11\t} 12\t} 13 14\tfmt.Println(sum) 15\tfmt.Println(\u0026#34;now this line will execute\u0026#34;) 16} 1$ go run main.go 210 3now this line will execute 1.9.7 lable در حلقه ها # شما با قابلیت lable در زبان گو می‌توانید لیبلی را به یک حلقه خاص اختصاص دهید و بعد از چند حلقه تو در تو حلقه مورد نظر را break کنید.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 letters := []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;} 7 8\tfor i := 1; i \u0026lt; 10; i++ { 9 // define a lable with name \u0026#39;second\u0026#39; for this loop 10 second: 11 for i := 2; i \u0026lt; 9; i++ { 12 for _, l := range letters { 13 if l == \u0026#34;b\u0026#34; { 14 // break the loop with second lable 15 break second 16 } 17 } 18 } 19\t} 20} در کد بالا زمانی که از لیبل استفاده نشود سومین حلقه درونی break خواهد شد. اما با استفاده از لیبل‌ها هرکدام از حلقه‌های مورد نظر را می‌توان break کرد.\n1.9.8 کلیدواژه continue # این کلید‌واژه چرخه‌ اجرای حلقه را یک مرحله جلو می‌برد. به این‌ معنی که اگر در حلقه از این کلید‌واژه استفاده شود، کدهای بعد از continue اجرا نشده و چرخه بعدی (گام بعدی) اجرا خواهد شد.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 7\tfor i := 1; i \u0026lt; 10; i++ { 8\tif i%2 == 0 { 9\tcontinue 10\t} 11\tfmt.Println(i) 12\t} 13} 1$ go run main.go 21 33 45 57 69 قابل ذکر است که continue و break در حلقه‌های تو در تو، فقط روی اولین حلقه درونی تاثیر خواهند گذاشت. 1.9.9 خودآزمون حلقه # سوال با استفاده از زبان گو برنامه‌ای بنویسید که سری‌ زیر را ایجاد کند:\n11 222 3333 455555 588888888 613131313131313131313131313 7212121212121212121212121212121212121212121 الگوریتم پاسخ ‍1 + 0 = 1 1 + 1 = 2 2 + 1 = 3 3 + 2 = 5 5 + 3 = 8 8 + 5 = 13 13 + 8 = 21 a + b = c b = a a = c کد پاسخ 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 var ( 7 n = 6 // can define any result count ... 8 a, b, c = 1, 0, 0 9 ) 10 for i := 0; i \u0026lt;= n; i++ { 11 c = a + b 12 for j := 1; j \u0026lt;= c; j++ { 13 fmt.Print(c) 14 } 15 fmt.Println() 16 b, a = a, c 17 } 18} "},{"id":18,"href":"/chapter-1/go-map/","title":"1.10 نقشه map","section":"فصل اول: آشنایی با مفاهیم گو","content":" 1.10.1 مقدمه # نقشه ، یک نوع ساختار داده است. نقشه ها جهت جمع‌آوری و نگهداری مجموعه‌ای از داده‌ها استفاده می‌گردند. نقشه ، از نوع داده‌های انجمنی (هش) بصورت «کلید-مقدار» است. نقشه ، مجموعه‌ای از داده‌ها بصورت جفت‌‌های مرتب‌نشده است. 1.10.2 تعریف # یک مپ شبیه به فرمت زیر است:\nmap[KeyType]ValueType کلمه کلیدی map و بعد نوع کلید و در آخر هم نوع مقدار تعریف می‌شود.\nکلید: برای اشاره به یک مقدار ذخیره شده، نیاز به یک نام‌ داریم و این یعنی «کلید» آن مقدار.\nمحدودیت: برای تعریف کلید، از انواع تایپ‌هایی که قابل مقایسه هستند، می‌توان استفاده کرد: Boolean(s) Number(s) String(s) Array(s) Pointer(s) Struct(s) Interface(s) (تا زمانی که از مقادیر مقایسه‌پذیر استفاده می‌کند) از Slice(s) Map(s) Function(s) نمی‌توان برای تعریف «کلید» مپ استفاده کرد. در مپ می‌توان برای کلید از مقدار داخل یک متغیر بهره برد. 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tmyMap := make(map[int]string) 7\tmyKey := 13 8\tmyMap[myKey] = \u0026#34;thirteen\u0026#34; 9\tfmt.Println(myMap) //map[13:thirteen] 10\tfmt.Println(myMap[myKey]) //thirteen 11} مقدار: حاوی داده‌ای است که کلید به آن اشاره می‌کند و برخلاف کلید، هیچ محدودیت برای انتخاب «نوع» آن وجود ندارد، به‌عنوان نمونه می‌توان از یک مپ دیگر برای مقدار استفاده کرد. (مپ‌های تودرتو )\nmap[string]map[int]string 1.10.3 ایجاد و مقداردهی اولیه # مقدار پیش‌فرض برای یک مپ nil است. برای مقداردهی مپ‌(ها) از روش‌های زیر استفاده می‌شود:\nاستفاده از کلمه کلیدی var 1var sampleMap = map[keyType]valueType{keyName1:value1, keyName2:value2, ...} 2var sampleMap map[keyType]valueType = map[keyType]valueType{} استفاده از علامت =: short variable declaration 1sampleMap := map[keyType]valueType{keyName1:value1, keyName2:value2, ...} استفاده از تابع make 1var sampleMap = make(map[keyType]valueType) 2sampleMap := make(map[keyType]valueType) 1.10.4 مپ با مقدار nil # درصورت تعریف اولیه مپ توسط دستور var sampleMap map[keyType]valueType یک مپ با مقدار nil ساخته می‌شود که نمی‌توان بدون مقداردهی اولیه، روی آن عملیات ارسال و دریافت داده‌ انجام داد:\n1 var sampleMap map[uint8]int 2 sampleMap[13] = 9999999 3 //panic: assignment to entry in nil map برای مقداردهی یک مپ nil که به روش زیر ساخته اید:\n1var m map[string]string از روش‌های زیر می‌توان بهره گرفت:\n1var m map[string]string = map[string]string{} 2m := make(map[string]string) 3m := map[string]string{} 1.10.5 توابع مربوط به مپ # تابع (len): برای برگشت تعداد عناصر داخل مپ از len استفاده می‌شود: 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tvar sampleMap = map[string]bool{} 7\tvar otherMap = make(map[string]uint) 8\tvar nilMap map[bool]bool 9 10\tsampleMap[\u0026#34;condition#1\u0026#34;] = true 11\tsampleMap[\u0026#34;condition#2\u0026#34;] = false 12 13\totherMap[\u0026#34;foo\u0026#34;] = 1 14 15\tfmt.Println(len(sampleMap))\t//2 16\tfmt.Println(len(otherMap))\t//1 17\tfmt.Println(len(nilMap))\t//0 (len nil is zero) 18} مقدار برگشتی برای تابع len روی مپ‌ nil برابر صفر (۰) است.\n1.10.6 عملیات CRUD روی مپ # C : Create برای ایجاد مپ، اغلب از تابع make استفاده می شود:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 animals := make(map[int]string) // nil map of string-int pairs 7 animals[1] = \u0026#34;Gopher\u0026#34; 8 animals[2] = \u0026#34;owl\u0026#34; 9 animals[3] = \u0026#34;cheetah\u0026#34; 10 animals[4] = \u0026#34;eagle\u0026#34; 11 animals[5] = \u0026#34;lion\u0026#34; 12 13 fmt.Println(animals) //map[1:Gopher 2:owl 3:cheetah 4:eagle 5:lion] 14 15} R : Read جهت خواندن مقادیر مپ می‌توان از الگوی زیر استفاده کرد: mapName[\u0026quot;keyName\u0026quot;] مثال:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 animals := make(map[int]string) // nil map of string-int pairs 7 animals[1] = \u0026#34;Gopher\u0026#34; 8 animals[2] = \u0026#34;owl\u0026#34; 9 animals[3] = \u0026#34;cheetah\u0026#34; 10 animals[4] = \u0026#34;eagle\u0026#34; 11 animals[5] = \u0026#34;lion\u0026#34; 12 13 fmt.Println(animals[2]) //owl 14} U : Update برای بروزرسانی مقادیر مپ، از الگوی mapName[keyName] = newValue استفاده می‌شود. مثال:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 animals := make(map[int]string) // nil map of string-int pairs 7 animals[1] = \u0026#34;Gopher\u0026#34; 8 animals[2] = \u0026#34;owl\u0026#34; 9 animals[3] = \u0026#34;cheetah\u0026#34; 10 animals[4] = \u0026#34;eagle\u0026#34; 11 animals[5] = \u0026#34;lion\u0026#34; 12 13 fmt.Println(animals[2]) //owl 14 15 animals[2] = \u0026#34;wolf\u0026#34; 16 17 fmt.Println(animals[2]) //wolf 18} D : Delete جهت حذف مقادیر در مپ، از تابع delete متعلق به پکیج builtin استفاده می‌شود.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 animals := make(map[int]string) // nil map of string-int pairs 7 animals[1] = \u0026#34;Gopher\u0026#34; 8 animals[2] = \u0026#34;owl\u0026#34; 9 animals[3] = \u0026#34;cheetah\u0026#34; 10 animals[4] = \u0026#34;eagle\u0026#34; 11 animals[5] = \u0026#34;lion\u0026#34; 12 13 fmt.Println(animals) //map[1:Gopher 2:owl 3:cheetah 4:eagle 5:lion] 14 fmt.Println(len(animals)) //5 15 delete(animals, 4) 16 17 fmt.Println(animals) //map[1:Gopher 2:owl 3:cheetah 5:lion] 18 fmt.Println(len(animals)) //4 19} نکته: اگر کلید مورد استفاده در فانکشن delete() پیدا نشود، هیچ اتفاقی نخواهد افتاد. علت عدم بازگشت ارور در فانکشن delete() است\n1// The delete built-in function deletes the element with the specified key 2// (m[key]) from the map. If m is nil or there is no such element, delete 3// is a no-op. 4func delete(m map[Type]Type1, key Type) 1.10.7 بررسی وجود کلید # به کد زیر توجه کنید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 x := make(map[string]int) 7 a := x[\u0026#34;num\u0026#34;] 8 fmt.Println(a) // 0 9 10 x[\u0026#34;num\u0026#34;] = 0 11 b := x[\u0026#34;num\u0026#34;] 12 fmt.Println(b) // 0 13} در حالت اول کلید \u0026rsquo;num\u0026rsquo; وجود نداشت و مقدار 0 چاپ شد. در حالت دوم مقدار 0 به کلید \u0026rsquo;num\u0026rsquo; نسبت داده شده و همان مقدار 0 چاپ شد. حال ممکن است موقعیتی پیش بیاید که لازم باشد بدانیم که آیا یک کلید وجود دارد یا نه. در این صورت به جای یک متغیر، از دو متغیر برای جستوجو در مپ استفاده می‌کنیم:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 x := make(map[string]int) 7 a, ok := x[\u0026#34;num\u0026#34;] 8 fmt.Println(a, ok) // 0 false 9 10 x[\u0026#34;num\u0026#34;] = 0 11 b, ok := x[\u0026#34;num\u0026#34;] 12 fmt.Println(b, ok) // 0 true 13} 1.10.8 مپ، یک جدول، یک منبع # وقتی یک مپ تعریف می‌شود، اگر مپ(های) دیگری از روی آن ساخته شود، دارای یک منبع (بهش میگن reference type) برای ذخیره و دریافت اطلاعات خواهند بود. در مثال زیر، مپ editorMap از مپ companyProfile ایجاد و وقتی ویرایش می‌شود، مپ اصلی نیز،‌ ویرایش می‌شود.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 7\tvar companyProfile = map[string]string{ 8\t\u0026#34;name\u0026#34;: \u0026#34;companyName\u0026#34;, 9\t\u0026#34;address\u0026#34;: \u0026#34;sampleAddress\u0026#34;, 10\t} 11\tvar editorMap = companyProfile // == editorMap := companyProfile 12 13\tfmt.Println(companyProfile[\u0026#34;name\u0026#34;], \u0026#34;\\t\u0026#34;, companyProfile[\u0026#34;address\u0026#34;]) 14\t//companyName sampleAddress 15\tfmt.Println(editorMap[\u0026#34;name\u0026#34;], \u0026#34;\\t\u0026#34;, editorMap[\u0026#34;address\u0026#34;]) 16\t//companyName sampleAddress 17 18\teditorMap[\u0026#34;name\u0026#34;] = \u0026#34;new name\u0026#34; 19\teditorMap[\u0026#34;address\u0026#34;] = \u0026#34;new address\u0026#34; 20 21\t//reference map also edited when editor map edit 22\tfmt.Println(companyProfile[\u0026#34;name\u0026#34;], \u0026#34;\\t\u0026#34;, companyProfile[\u0026#34;address\u0026#34;]) 23\t//new name new address 24\tfmt.Println(editorMap[\u0026#34;name\u0026#34;], \u0026#34;\\t\u0026#34;, editorMap[\u0026#34;address\u0026#34;]) 25\t//new name new address 26} 1.10.9 پیمایش روی مپ # یکی از اصلی‌ترین اهداف ایجاد و نگهداری انواع تایپ‌های مربوط به مجموعه داده‌ها ... map and ، امکان دسترسی به اجزای آن‌ها با استفاده از لوپ‌ها در گولنگ فقط for-loop است. با استفاده از for-range می‌توان به اجزای یک داده‌ از نوع کلید-مقدار دسترسی داشت. به مثال زیر توجه کنید:\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7func main() { 8\tanimals := make(map[int][]string) // nil map of string-int pairs 9\tanimals[0] = []string{\u0026#34;Gopher\u0026#34;, \u0026#34;running\u0026#34;, \u0026#34;rodent\u0026#34;} 10\tanimals[1] = []string{\u0026#34;owl\u0026#34;, \u0026#34;flying\u0026#34;, \u0026#34;carnivorous\u0026#34;} 11\tanimals[2] = []string{\u0026#34;cheetah\u0026#34;, \u0026#34;running\u0026#34;, \u0026#34;carnivorous\u0026#34;} 12\tanimals[3] = []string{\u0026#34;eagle\u0026#34;, \u0026#34;flying\u0026#34;, \u0026#34;carnivorous\u0026#34;} 13\tanimals[4] = []string{\u0026#34;lion\u0026#34;, \u0026#34;running\u0026#34;, \u0026#34;carnivorous\u0026#34;} 14 15\tfor index, animal := range animals { 16\tfmt.Printf(\u0026#34;%v- %s is %s animal and can %s \\n\u0026#34;, index, animal[0], animal[2], animal[1]) 17\t} 18} خروجی کد بالا:\n1user@system:~/go/src/temp❇ GO[1.19.3] 22:29:00 2→ go run main.go 30- Gopher is rodent animal and can running 41- owl is carnivorous animal and can flying 52- cheetah is carnivorous animal and can running 63- eagle is carnivorous animal and can flying 74- lion is carnivorous animal and can running 8user@system:~/go/src/temp❇ GO[1.19.3] 22:29:00 9→ go run main.go 104- lion is carnivorous animal and can running 110- Gopher is rodent animal and can running 121- owl is carnivorous animal and can flying 132- cheetah is carnivorous animal and can running 143- eagle is carnivorous animal and can flying 15user@system:~/go/src/temp❇ GO[1.19.3] 22:29:02 16→ go run main.go 172- cheetah is carnivorous animal and can running 183- eagle is carnivorous animal and can flying 194- lion is carnivorous animal and can running 200- Gopher is rodent animal and can running 211- owl is carnivorous animal and can flying به نحوه چیدمان خروجی‌ها دقت کنید، درباره علت یکسان نبودن خروجی‌ها در اجراهای متعدد تحقیق کنید تقلب کوچیک بهتون بدم :). مپ ها unordered هستن.\n1.10.10 تبدیل اطلاعات رشته − مپ − اسلایس # نمونه کد زیر یک رشته را به مپ و یک مپ را به اسلایس تبدیل می‌کند.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7func seriesStringToMap(inputs ...string) map[int]string { 8\tresult := make(map[int]string) 9\tfor index, input := range inputs { 10\tresult[index] = input 11\t} 12\treturn result 13} 14 15func mapToSlice(inputs map[int]string) []string { 16\tresult := make([]string, len(inputs)) 17\tfor index, input := range inputs { 18\tresult[index] = input 19\t} 20\treturn result 21} 22 23func main() { 24\tmyAnimal := \u0026#34;Eagle Cheetah Owl Lion Gopher\u0026#34; 25 26\tmyMappedAnimal := seriesStringToMap(myAnimal) 27\tfmt.Println(myMappedAnimal) 28\t//map[0:Eagle Cheetah Owl Lion Gopher] 29 30\tmySlicedAnimal := mapToSlice(myMappedAnimal) 31\tfmt.Println(mySlicedAnimal) 32\t//[Eagle Cheetah Owl Lion Gopher] 33} 1.10.11 خودآزمون # کد زیر را بررسی کنید و خروجی(های) آن را با در ذهن محاسبه کنید. سپس صحت آن(ها) را بررسی و درباره آن تحقیق کنید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 var myMap map[string]int 7 fmt.Println(myMap) 8 9 var otherMap = map[string]int{} 10 fmt.Println(otherMap) 11 12 myMap[\u0026#34;foo\u0026#34;] = 13 13 fmt.Println(myMap) 14 15 otherMap[\u0026#34;bar\u0026#34;] = 99 16 fmt.Println(otherMap) 17} "},{"id":19,"href":"/chapter-1/go-if-switch/","title":"1.11 شرط (if, switch)","section":"فصل اول: آشنایی با مفاهیم گو","content":" 1.11.1 شرط (if-else) # زبان گو همانند سایر زبان‌ها دارای شرط است که شما خیلی ساده می‌توانید از آن استفاده کنید. در مثال زیر ما فرمت استاندارد شرط در زبان گو را قرار دادیم:\n1if condition { 2 //Do something 3} else if condition { 4 //Do something 5} else { 6 //Do something 7} در بالا condition عبارتی است که قرار است وضعیت شرط را مشخص کند و در صورت true شدن شرط بر قرار می‌شود و در صورت برقرار نشدن شرط اول، برنامه وارد else if می‌شود و مجدد یک condition دیگری را چک می‌کند که وضعیتش true می‌شود یا خیر و در نهایت منتهی می‌شود به else.\nدر شرط ما یک یا چندتا condition می‌توانیم داشته باشیم که این condition‌ ها برای تعیین وضعیت از یکسری عملگرها نظیر \u0026amp;\u0026amp; , || , \u0026gt; , \u0026lt; , \u0026lt;= , =\u0026gt; , ! و \u0026hellip; استفاده می کنند.\nزبان گو از فرمت‌های زیر برای ایجاد شرط استفاده می‌کند:\nفقط if if-else تو در تو (nested) شرط کوتاه با if 1.11.2 کلمه if به تنهایی # شما می‌توانید به تنهایی از if استفاده و یک condition را بررسی کنید:\n1if condition { 2 //Do something 3} برای نمونه کد زیر را ببینید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 a := 6 7 if a \u0026gt; 5 { 8 fmt.Println(\u0026#34;a is greater than 5\u0026#34;) 9 } 10} 1$ go run main.go 2a is greater than 5 در مثال بالا ما مقدار a را با عدد ۵ مقایسه کردیم، شرط ما به این صورت بود که آیا a از ۵ بزرگتر است یا خیر؟ جواب true است. a بزرگتر از 5 است و شرط برقرار میشود.\nدر مثال زیر ما چند condition را داخل یک شرط بررسی کردیم. آیا a بزرگتر از 3 و a کوچک تر از 6 است؟\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 a := 4 7 if a \u0026gt; 3 \u0026amp;\u0026amp; a \u0026lt; 6 { 8 fmt.Println(\u0026#34;a is within range\u0026#34;) 9 } 10} 1$ go run main.go 2a is within range 1.11.3 کلمه else # فرمت شرط همراه با else مانند مثال زیر است:\n1if condition { 2 //Do something 3} else { 4 //Do something 5} در مثال بالا اگر condition برقرار نشود، کدهای داخل else اجرا خواهند شد. به مثال زیر توجه کنید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 a := 1 7 b := 2 8 9 if a \u0026gt; b { 10 fmt.Println(\u0026#34;a is greater than b\u0026#34;) 11 } else { 12 fmt.Println(\u0026#34;b is greater than a\u0026#34;) 13 } 14} 1$ go run main.go 2b is greater than a 1.11.4 ادامه شرط با else if # شما با استفاده از کلید واژه else if دقیقا به همین فرمت که اینجا نوشته شده می‌توانید condition دیگری را بررسی کرده و در صورت برقرار شدن شرط، عملیات را انجام دهید.\n1if condition1 { 2 //Do something 3} else if condition2 { 4 //Do something 5} else { 6 //Do something 7} به مثال زیر توجه کنید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 age := 29 7 if age \u0026lt; 18 { 8 fmt.Println(\u0026#34;Kid\u0026#34;) 9 } else if age \u0026gt;= 18 \u0026amp;\u0026amp; age \u0026lt; 40 { 10 fmt.Println(\u0026#34;Young\u0026#34;) 11 } else { 12 fmt.Println(\u0026#34;Old\u0026#34;) 13 } 14} 1$ go run main.go 2Young 1.11.5 شرط تو در تو (nested) # در زبان گولنگ شما می‌توانید شرط‌های تو در تو (nested) داشته باشید (برای توسعه بهتر پروژه، بهتر است کمتر از شرطهای تو در تو استفاده کنید، زیرا این گونه شرط نویسی خوانایی کد را پایین می‌آورد)\n1if condition { 2 //Do something 3 if condition2 { 4 //Do something 5 } 6 //Do something 7} در مثال زیر یک نمونه شرط تو در تو به همراه else قرار دادیم:\n1if condition1 { 2 //... 3} else { 4 //... 5 if condition2 { 6 //... 7 } else { 8 //.... 9 } 10 //.... 11} در کد زیر مثالی برای شروط تو در تو زدیم:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 a := 1 7 b := 2 8 c := 3 9 if a \u0026gt; b { 10 if a \u0026gt; c { 11 fmt.Println(\u0026#34;Biggest is a\u0026#34;) 12 } else if b \u0026gt; c { 13 fmt.Println(\u0026#34;Biggest is b\u0026#34;) 14 } 15 } else if b \u0026gt; c { 16 fmt.Println(\u0026#34;Biggest is b\u0026#34;) 17 } else { 18 fmt.Println(\u0026#34;Biggest is c\u0026#34;) 19 } 20} 1$ go run main.go 2Biggest is c 1.11.6 تعریف شرط و قرار دادن condition در متغیر کوتاه # در زبان گو شرط‌ها, امکان تعریف متغیر به روش کوتاه در شرط برای condition را دارند و شما می‌توانید قبل از بررسی کردن condition اون رو در همان خط مقدار دهی کنید.\n1if statement; condition { 2 //Do something 3} به مثال زیر توجه کنید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 if a := 6; a \u0026gt; 5 { 7 fmt.Println(\u0026#34;a is greater than 5\u0026#34;) 8 } 9} 1$ go run main.go 2a is greater than 5 در مثال بالا ما یک متغیر کوتاه با نام a را داخل شرط تعریف کردیم و مقدار 6 را بهش دادیم، سپس با قرار دادن ; semi-colon برقراری وضعیت شرط را بررسی کردیم.\n1.11.7 Switch # زبان گو ‌مانند برخی از زبان‌ها از switch پشتیبانی می‌کند. switch یک روش بسیار ساده‌تر و همچنین روشی برای جلوگیری از else if های مکرر در شرط است.\n1switch statement; expression { 2case expression1: 3 //Dosomething 4case expression2: 5 //Dosomething 6default: 7 //Dosomething 8} زمانیکه switch رو تعریف می‌کنیم, هم می‌توانیم مقداری که قبلا تعریف کردیم رو برای بررسی بهش بدیم و هم می‌توانیم از روش (تعریف متغیر به روش کوتاه) یک مقدار جدید تعریف کنیم و ازش استفاده کنیم. بعد از کلمه switch باید یک مقدار رو بهش بدیم و داخل switch با استفاده از case بررسی کنیم که مقداری که داده شده با اون چیزی که مد نظر ما هست برابر هست یا خیر. اگر هیج کدام از شرط ها برقرار نبود، کد های بعد از default اجرا میشن. استفاده از شرط default اجباری نیست.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 switch ch := \u0026#34;b\u0026#34;; ch { 7 case \u0026#34;a\u0026#34;: 8 fmt.Println(\u0026#34;a\u0026#34;) 9 case \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;: 10 fmt.Println(\u0026#34;b or c\u0026#34;) 11 default: 12 fmt.Println(\u0026#34;No matching character\u0026#34;) 13 } 14} 1$ go run main.go 2b or c در مثال بالا ما یک متغیر با نام ch رو به روش تعریف متغیر به روش کوتاه مقدار دهی کردم و همون متغیر را برای بررسی به switch دادیم. سپس با استفاده از کلید واژه case بررسی کردیم که آیا ch برابر است با اون مقادیری که ما تعریف کردیم یا خیر. اگر برابر بود کدهای درون اون case اجرا خواهند شد و اگر برابر نبود ما با استفاده از کلید واژه default مقدار پیش‌فرضی را در خروجی چاپ می‌کنیم.\n1.11.8 fallthrough # اگر در آخر یک case از این keyword استفاده شود، case بعدی بدون هیچ شرطی اجرا می‌شود:\n1func main() { 2 i := 50 3 switch { 4 case i \u0026lt; 10: 5 fmt.Println(\u0026#34;i is less than 10\u0026#34;) 6 case i \u0026lt; 100: 7 fmt.Println(\u0026#34;i is less than 50\u0026#34;) 8 fallthrough 9 case i \u0026lt; 150: 10 fmt.Println(\u0026#34;i is less than 100\u0026#34;) 11 } 12} 1i is less than 50 2i is less than 100 نکته ای که بسیاری از منابع انگلیسی هم اشاره ای بهش ندارن اینه که شرط بعدی حتی اگر اشتباه هم باشه، اجرا میشه:\n1func main() { 2 i := 50 3 switch { 4 case i \u0026lt; 10: 5 fmt.Println(\u0026#34;i is less than 10\u0026#34;) 6 case i \u0026lt; 100: 7 fmt.Println(\u0026#34;i is less than 50\u0026#34;) 8 fallthrough 9 case false: 10 fmt.Println(\u0026#34;i is less than 100\u0026#34;) 11 } 12} 1i is less than 50 2i is less than 100 1.11.9 Switch خودآزمون # تفاوت ساختار و خروجی چهار فرمت مشابه زیر را بررسی کنید:\nحالت اول 1switch f(); { 2case true: 3 println(1) 4case false: 5 println(0) 6} حالت دوم 1switch f() 2{ 3case true: 4 println(1) 5case false: 6 println(0) 7} حالت سوم 1switch f() { 2case true: 3 println(1) 4case false: 5 println(0) 6} حالت چهارم 1switch f(); true { 2case true: 3 println(1) 4case false: 5 println(0) 6} کدها در زمان اجرا یا پیش از آن، در برخی IDE یا Code Editor(ها) فرمت می‌شوند. هدف این خودآزمون دقت به ساختار ابزار switch است. "},{"id":20,"href":"/chapter-1/go-package/","title":"1.12 اضافه کردن پکیج در کد (package)","section":"فصل اول: آشنایی با مفاهیم گو","content":"زبان برنامه‌نویسی گو به شکلی طراحی شده است تا بتوانیم شیو‌ه‌های خوب مهندسی نرم‌افزار را به سادگی پیاده‌سازی کنیم. یکی از الگوهای مهم برای ارتقای کیفیت یک نرم افزار استفاده از DRY principle است. کلمه DRY مخفف Don’t Repeat Yourself همون چرخ رو دوباره اختراع نکن خودمون است, که اگر به صورت خیلی ساده بیانش کنیم یعنی، کدی که خواهید نوشت را دوبار تکرار نکنید. تا جایی که امکان دارد باید بتوانید از کدهای قبلی که نوشته اید استفاده کنید. پکیج‌ها امکاناتی از جمله:\nقابلیت استفاده مجدد از کد را به ما میدهند. امکان ماژولار، و قابل نگهداری بودن کد را فراهم می‌کنند. امکان مدیریت بهتر فایل‌ها را در یک واحد ایجاد می‌کنند. 1.12.1 پکیج‌ها در زبان گو # پکیج در اصل یک یا مجموعه‌ای از سورس فایل‌های شما است که ممکن است داخل یک فولدر قرار بگیرد. هر سورس فایلی که در زبان گو دارید متعلق به یک پکیج است. برای تعریف یک پکیج از دستور زیر استفاده می‌کنیم:\n1package \u0026lt;packagename\u0026gt; برای تعریف پکیج باید در اولین خط فایل، آن را با کلید واژه package تعریف کنید. داخل این پکیج شما می‌توانید کد‌هایی که لازم دارید را بنویسید و تصمیم بگیرید کدام متغییر، فانکشن یا تایپ باید به صورت عمومی باشد و یا باید به صورت خصوصی فقط داخل پکیج مورد استفاده قرار بگیرد.\nقطعا می‌دانیم بعد از نوشتن پکیج اگر بخواهیم از آن پکیج داخل پکیج‌های دیگر استفاده کنیم باید از کلید واژه import استفاده کنیم.\n1.12.2 اضافه کردن پکیج # برای اضافه کردن پکیج‌های مختلف ما از کلید واژه import استفاده می‌کنیم.\n1import \u0026#34;fmt\u0026#34; برای مثال, در کد بالا ما از پکیج fmt که در کتابخانه استاندارد گو وجود دارد استفاده کردیم. این به این معنی است همراه با تعریف کلمه fmt میتوانیم از توابعی که داخل این پکیج نوشته شده است استفاده کنیم. در مثال زیر ما از تابع Println برای چاپ مقدارHello GoFarsi!‍ استفاده کردیم.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tfmt.Println(\u0026#34;Hello GoFarsi!\u0026#34;) 7} تعریف کردن توابع به این شکل مزایای زیادی دارد از جمله:\nاگر اسم‌های مشابهی داشته باشید، داخل پکیج‌های مختلف می‌توانید از آن‌ها استفاده کنید، همچنین خوانایی برنامه افزایش پیدا می‌کند و باعث می‌شود از نام‌های طولانی استفاده نکنیم. مجموعه کدهایی که مربوط به هم هستن را در یک پکیج می‌توانیم قرار دهیم, که باعث می‌شود پیدا کردن و استفاده مجدد از کد را برای ما راحت‌تر کند. فرایند تغییر و کامپایل را می‌تواند به حداقل برساند. 1.12.2.1 اضافه کردن چندین پکیج # ما می‌توانیم برای اضافه کردن هر پکیج از کلید واژه import به شکل زیر استفاده کنیم:\n1import \u0026#34;fmt\u0026#34; 2import \u0026#34;time\u0026#34; 3import \u0026#34;math\u0026#34; 4import \u0026#34;math/rand\u0026#34; اما با تشکر از زبان گو, ما می‌توانیم چندین پکیج رو به صورت زیر و فقط با یک بار نوشتن کلید واژه import فراخوانی کنیم:\n1import ( 2\t\u0026#34;fmt\u0026#34; 3\t\u0026#34;time\u0026#34; 4\t\u0026#34;math\u0026#34; 5 \u0026#34;math/rand\u0026#34; 6) یعنی یک بار از کلید واژه import استفاده کنیم و بعد اسم پکیج‌ها را به ترتیب داخل آن بنویسیم.\nهمینطور ما می‌توانیم به پکیج هایی که import کردیم یک alias هم بدیم، یعنی همون اسم مستعار, به مثال زیر توجه کنید:\n1import ( 2\tformat \u0026#34;fmt\u0026#34; 3) و مانند مثال زیر از آن ها استفاده کنیم:‌\n1package main 2 3import format \u0026#34;fmt\u0026#34; 4 5func main() { 6\tformat.Println(\u0026#34;Hello from Gofarsi\u0026#34;) 7} 1.12.3 اسم‌های عمومی و خصوصی (Export و Unexport) # همه توابع، متغیر‌ها، ثابت ها و تایپ‌هایی که با حروف کوچک شروع می‌شوند، فقط در همان پکیج قابل دسترس هستند. برای عمومی کردن آنها، حرف اول آنها را به صورت Capital می‌نویسیم. برای مثال به کد زیر نگاه کنید:\n1package main 2 3import \u0026#34;encoding/json\u0026#34; 4 5type jSON struct { 6 Name string `json:\u0026#34;name\u0026#34;` 7} 8 9func main() { 10 var data []byte 11 json.Unmarshal(data, \u0026amp;jSON{}) 12} چون پکیج json نیاز داره تا فیلد Name رو تغییر بده پس در نتیجه در کد بالا حتما باید این فیلد رو با حرف بزرگ می‌نوشتیم.\n1.12.4 اضافه کردن پکیج‌های 3rd party # فرض کنید می‌خواهیم از پکیج Gin (github.com) استفاده کنیم، برای اضافه کردن این پکیج ما ‌می‌توانیم به دو شکل زیر آن را اضافه کنیم.\nداخل پروژه خود از دستور زیر استفاده کنید:\n1$ go get -u github.com/gin-gonic/gin بعدا می‌توانید وارد پروژه خود شوید و با کلید واژه import از آن استفاده کنید. به مثال زیر نگاه کنید:\n1package main 2 3import ( 4 \u0026#34;net/http\u0026#34; 5 6 \u0026#34;github.com/gin-gonic/gin\u0026#34; 7) 8 9func main() { 10 r := gin.Default() 11 r.GET(\u0026#34;/ping\u0026#34;, func(c *gin.Context) { 12 c.JSON(http.StatusOK, gin.H{ 13 \u0026#34;message\u0026#34;: \u0026#34;pong\u0026#34;, 14 }) 15 }) 16 r.Run() // listen and serve on 0.0.0.0:8080 (for windows \u0026#34;localhost:8080\u0026#34;) 17} حالت دیگر استفاده از go mod tidy است, به این شکل که ما از دستور go get استفاده نمی‌کنیم و به صورت مستقیم داخل پروژه آدرس gin را import می‌کنیم.\nو همان ابتدا داخل کد یک فانکشن را از همان پکیج فراخوانی می‌کنیم (اینکار لازم است چون همانطور که می‌دانید خود go tool وقتی بداند شما پکیجی را تعریف کردید و استفاده نکردید آن را خودکار پاک می‌کند. البته که کد ادیتورهای معروف هم مانند goland,vsCode و \u0026hellip;، همین کارو رو در حین نوشتن کد برای شما انجام می‌دهند.)\nسپس از دستور زیر استفاده میکنیم:\n1$ go mod tidy این دستور کل کدهای شما را بررسی می‌کند و اگر ببینید پکیجی تعریف شده است و شما آن را ندارید سعی میکند آن پکیج را برای شما دانلود و به پروژه شما اضافه کند.\n"},{"id":21,"href":"/chapter-1/go-defer-panic-recovery/","title":"1.13 defer, panic, recovery","section":"فصل اول: آشنایی با مفاهیم گو","content":" 1.13.1 تعویق (defer) # کلمه کلیدی defer یکی از کاربردی‌ترین امکانات زبان گو را برای ما فراهم می‌سازد. شما می‌توانید اجرای یک تابع را به تعویق بندازید‍‍. عموماً defer برای توابعی کاربرد دارد که قصد پاک‌سازی یا بستن عملیات‌های صورت گرفته را دارند، نظیر توابع Close در برخی از جاها.\nبه مثال زیر توجه کنید:\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7func main() { 8\tdefer fmt.Println(\u0026#34;world\u0026#34;) 9\tfmt.Println(\u0026#34;hello\u0026#34;) 10} 1$ go run main.go 2hello 3world 1.13.1.1 تعویق (defer) در توابع (Anonymous) # شما خیلی ساده می‌توانید با استفاده از توابع Anonymous توابع بینام یا گمنام :) اجرای قسمتی از برنامه خودتان را به تعویق بندازید. به مثال زیر توجه کنید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 defer func() { fmt.Println(\u0026#34;In inline defer\u0026#34;) }() 7 fmt.Println(\u0026#34;Executed\u0026#34;) 8} 1$ go run main.go 2Executed 3In inline defer به این نکته توجه کنید که defer قبل از return صدا زده می‌شود. یعنی قبل از اینکه تابع شما خروجی را برگشت بدهد اگه تابع خروجی داشته باشه defer اجرا خواهد شد.\n1.13.1.2 تعویق (defer) چندین تابع درون یک تابع # در کد زیر, ما داخل یک تابع چند تابع را با استفاده از (defer) به تعویق انداختیم. به مثال زیر توجه کنید:\n1package main 2import \u0026#34;fmt\u0026#34; 3func main() { 4 i := 0 5 i = 1 6 defer fmt.Println(i) 7 i = 2 8 defer fmt.Println(i) 9 i = 3 10 defer fmt.Println(i) 11} 1$ go run main.go 23 32 41 دقت داشته باشید که مقداردهی پارامترهای ورودی، برای تابعی که آن را defer کردیم در همان لحظه call شدن آن انجام می‌شود. به مثال زیر توجه کنید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\ti:=1 7\tdefer fmt.Println(i) 8\ti++ 9\tfmt.Println(i) 10\tfmt.Println(\u0026#34;First\u0026#34;) 11} 1$ go run main.go 22 3First 41 در این مرحله شما باید پی برده باشید که defer در همان خطی که نوشته شده است صدا زده می‌شود، ولی اجرای آن دقیقاً به قبل از return در تابع موکول می‌شود.\n1.13.2 پنیک (panic) # در زبان گو panic همانند exception به معنای خروج از برنامه در شرایط غیر عادی است. panic در ۲ حالت زیر پیش می‌آید:\nخطاهای در زمان اجرای برنامه فراخوانی تابع panic توسط برنامه نویس در بخش های مختلف برنامه 1func panic(v interface{}) شما می‌توانید با استفاده از تابع داخلی فوق، panic ایجاد کنید و به عنوان ورودی دلیل panic را در قالب یک رشته به تابع ارسال کنید.\n1.13.2.1 خطای panic در زمان اجرا (runtime) # خطاهای panic در زمان اجرا به دلایل زیر می‌تواند رخ دهد:\nخطای Out of bounds/range array/slice فراخوانی متغیری که nil pointer باشد یعنی به هیچ آدرسی از حافظه memory اشاره نمی‌کند ارسال داده برروی کانال‌های بسته شده type assertion نادرست 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 7\ta := []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;} 8\tprint(a, 2) 9} 10 11func print(a []string, index int) { 12\tfmt.Println(a[index]) 13} 1$ go run main.go 2panic: runtime error: index out of range [2] with length 2 3 4goroutine 1 [running]: 5main.checkAndPrint(...) 6 main.go:12 7main.main() 8 /main.go:8 +0x1b 9exit status 2 در تابع فوق ما یک تابع نوشتیم که به عنوان ورودی یک اسلایس از نوع رشته و یک ایندکس از نوع عدد از ما دریافت می‌کند و المنت ایندکسم‌ اون اسلایس را برای ما چاپ میکند در مثال بالا یعنی اندیس شماره 2. این کار ما باعث بروز یک panic میشود, فکر میکنید به چه دلیل ؟ بله به این دلیل که اسلایس ما اندیس شماره 2 ندارد و دلیل آن هم این است که اسلایس, لیست و \u0026hellip;. از 0 شروع می‌شوند.\nپنیک یک سری اطلاعات در مورد چرایی بوجود آمدنش به ما می‌دهد که در ادامه آن‌ها را توضیح دادیم:\nپنیک رخ داده شامل متن خطا محل رخ دادن panic در قالب stacktrace 1.13.2.2 خطای panic از قبل تعیین شده توسط برنامه‌نویس # همانطور که گفتیم شما می‌توانید هرجایی از بدنه توابع خود، تابع panic را فراخوانی کنید البته این روش پیشنهاد نمی‌شود و روش پیشنهادی استفاده از شیوه ارور هندلینگ خود گولنگ است و فقط در صورت لزوم بهتر است از پنیک استفاده شود. همینطور شما باید در داکیومنت برنامه ذکر کنید که کدام قسمت برنامه امکان پنیک را دارد تا دیگران بتوانند در صورت لزوم آن را recover کنند. recover را در ادمه توضیح خواهم داد. تا برنامه در آن محل خطایی را نمایش داده و متوقف شود.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 7\ta := []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;} 8\tcheckAndPrint(a, 2) 9} 10 11func checkAndPrint(a []string, index int) { 12\tif index \u0026gt; (len(a) - 1) { 13\tpanic(\u0026#34;Out of bound access for slice\u0026#34;) 14\t} 15\tfmt.Println(a[index]) 16} 1$ go run main.go 2panic: Out of bound access for slice 3 4goroutine 1 [running]: 5main.checkAndPrint(0xc000104f58, 0x2, 0x2, 0x2) 6 main.go:13 +0xe2 7main.main() 8 main.go:8 +0x7d 9exit status 2 توجه کنید استفاده از تابع panic در برخی مواقع مفید می‌باشد. به عنوان مثال قصد دارید هنگام اجرای برنامه، یکسری تنظیمات از سمت کاربر دریافت کنید و در صورتی‌که تنظیمات دارای مشکل بودند، می‌توانید با استفاده panic جلوی ادامه روند برنامه را بگیرید تا کاربر خطا را رفع کند. 1.13.3 بازیابی (recovery) # برخی اوقات panic‌ها غیرقابل پیش‌ بینی می‌شوند. ممکن است برنامه شما بدون هیچ خطایی اجرا شود و به روند خود ادامه دهد، اما این هم ممکن است که به یک دلیل نامعلوم یا بهتر است بگوییم پیش بینی نشده، panic رخ دهد و برنامه شما کاملاً متوقف و باعث از دست دادن وضعیت استیبل برنامه شود.\nبه همین منظور در گولنگ یک تابع به نام recover وجود دارد که پس از رخ دادن panic در برنامه، این قابلیت را به ما می‌دهد تا بتوانیم برنامه را به وضعیت قبلی خود بازگردانیم تا بعداً خطای panic رخ داده را بررسی و رفع کنیم.\n1func recover() interface{} همینطور که شما هم میبینید، تابع ریکاور هیچ ورودی نمی‌گیرد و یک خروجی از تایپ interface را برمی‌گرداند.\nبه مثالی که در مورد تابع recover زدیم نگاه کنید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 7\ta := []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;} 8\tcheckAndPrint(a, 2) 9\tfmt.Println(\u0026#34;Exiting normally\u0026#34;) 10} 11 12func checkAndPrint(a []string, index int) { 13\tdefer handleOutOfBounds() 14\tif index \u0026gt; (len(a) - 1) { 15\tpanic(\u0026#34;Out of bound access for slice\u0026#34;) 16\t} 17\tfmt.Println(a[index]) 18} 19 20func handleOutOfBounds() { 21\tif r := recover(); r != nil { 22\tfmt.Println(\u0026#34;Recovering from panic:\u0026#34;, r) 23\t} 24} 1$ go run main.go 2Recovering from panic: Out of bound access for slice 3Exiting normally در کد فوق ما یک تابع داریم که در این تابع یک المنت از یک اسلایس را چاپ می‌کند، اما اگر این اندیس خارج از تعداد المنت‌های اسلایس باشد یک خطای panic رخ می‌دهد. ما برای جلوگیری از خطای panic تابع handleOutOfBounds را با استفاده defer درون تابع checkAndPrint قرار دادیم که پس از رخ دادن panic بصورت خودکار بازیابی صورت بگیرد تا برنامه ما متوقف نشود.\n1.13.4 چاپ اطلاعات stacktrace پس از بازیابی # شما می‌توانید پس از اینکه بازیابی را انجام دادید، جزئیات بیشتری در خصوص خطای panic رخ داده بدست آوردید. به مثال زیر توجه کنید:\n1package main 2import ( 3 \u0026#34;fmt\u0026#34; 4 \u0026#34;runtime/debug\u0026#34; 5) 6func main() { 7 a := []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;} 8 checkAndPrint(a, 2) 9 fmt.Println(\u0026#34;Exiting normally\u0026#34;) 10} 11func checkAndPrint(a []string, index int) { 12 defer handleOutOfBounds() 13 if index \u0026gt; (len(a) - 1) { 14 panic(\u0026#34;Out of bound access for slice\u0026#34;) 15 } 16 fmt.Println(a[index]) 17} 18func handleOutOfBounds() { 19 if r := recover(); r != nil { 20 fmt.Println(\u0026#34;Recovering from panic:\u0026#34;, r) 21 fmt.Println(\u0026#34;Stack Trace:\u0026#34;) 22 debug.PrintStack() 23 } 24} 1$ go run main.go 2Recovering from panic: Out of bound access for slice 3Stack Trace: 4goroutine 1 [running]: 5runtime/debug.Stack(0xd, 0x0, 0x0) 6 stack.go:24 +0x9d 7runtime/debug.PrintStack() 8 stack.go:16 +0x22 9main.handleOutOfBounds() 10 main.go:27 +0x10f 11panic(0x10ab8c0, 0x10e8f60) 12 /Users/slohia/Documents/goversion/go1.14.1/src/runtime/panic.go:967 +0x166 13main.checkAndPrint(0xc000104f58, 0x2, 0x2, 0x2) 14 main.go:18 +0x111 15main.main() 16 main.go:11 +0x81 17Exiting normally برای چاپ اطلاعات stacktrace همانطور که می‌بینید ما از پکیج runtime که در کتابخانه استاندارد گولنگ وجود دارد استفاده کردیم\n"},{"id":22,"href":"/chapter-1/go-builtins/","title":"1.14 لیست تایپ‌ها و توابع Builtin","section":"فصل اول: آشنایی با مفاهیم گو","content":"در مثال زیر لیست تایپ‌ها و توابع Builtin تا نسخه ۱.۲۱ را با توضیحات قرار دادیم.\n1// bool is the set of boolean values, true and false. 2type bool bool 3 4// true and false are the two untyped boolean values. 5const ( 6 true = 0 == 0 // Untyped bool. 7 false = 0 != 0 // Untyped bool. 8) 9 10// uint8 is the set of all unsigned 8-bit integers. 11// Range: 0 through 255. 12type uint8 uint8 13 14// uint16 is the set of all unsigned 16-bit integers. 15// Range: 0 through 65535. 16type uint16 uint16 17 18// uint32 is the set of all unsigned 32-bit integers. 19// Range: 0 through 4294967295. 20type uint32 uint32 21 22// uint64 is the set of all unsigned 64-bit integers. 23// Range: 0 through 18446744073709551615. 24type uint64 uint64 25 26// int8 is the set of all signed 8-bit integers. 27// Range: -128 through 127. 28type int8 int8 29 30// int16 is the set of all signed 16-bit integers. 31// Range: -32768 through 32767. 32type int16 int16 33 34// int32 is the set of all signed 32-bit integers. 35// Range: -2147483648 through 2147483647. 36type int32 int32 37 38// int64 is the set of all signed 64-bit integers. 39// Range: -9223372036854775808 through 9223372036854775807. 40type int64 int64 41 42// float32 is the set of all IEEE-754 32-bit floating-point numbers. 43type float32 float32 44 45// float64 is the set of all IEEE-754 64-bit floating-point numbers. 46type float64 float64 47 48// complex64 is the set of all complex numbers with float32 real and 49// imaginary parts. 50type complex64 complex64 51 52// complex128 is the set of all complex numbers with float64 real and 53// imaginary parts. 54type complex128 complex128 55 56// string is the set of all strings of 8-bit bytes, conventionally but not 57// necessarily representing UTF-8-encoded text. A string may be empty, but 58// not nil. Values of string type are immutable. 59type string string 60 61// int is a signed integer type that is at least 32 bits in size. It is a 62// distinct type, however, and not an alias for, say, int32. 63type int int 64 65// uint is an unsigned integer type that is at least 32 bits in size. It is a 66// distinct type, however, and not an alias for, say, uint32. 67type uint uint 68 69// uintptr is an integer type that is large enough to hold the bit pattern of 70// any pointer. 71type uintptr uintptr 72 73// byte is an alias for uint8 and is equivalent to uint8 in all ways. It is 74// used, by convention, to distinguish byte values from 8-bit unsigned 75// integer values. 76type byte = uint8 77 78// rune is an alias for int32 and is equivalent to int32 in all ways. It is 79// used, by convention, to distinguish character values from integer values. 80type rune = int32 81 82// any is an alias for interface{} and is equivalent to interface{} in all ways. 83type any = interface{} 84 85// comparable is an interface that is implemented by all comparable types 86// (booleans, numbers, strings, pointers, channels, arrays of comparable types, 87// structs whose fields are all comparable types). 88// The comparable interface may only be used as a type parameter constraint, 89// not as the type of a variable. 90type comparable interface{ comparable } 91 92// iota is a predeclared identifier representing the untyped integer ordinal 93// number of the current const specification in a (usually parenthesized) 94// const declaration. It is zero-indexed. 95const iota = 0 // Untyped int. 96 97// nil is a predeclared identifier representing the zero value for a 98// pointer, channel, func, interface, map, or slice type. 99var nil Type // Type must be a pointer, channel, func, interface, map, or slice type 100// Type is here for the purposes of documentation only. It is a stand-in// for any Go type, but represents the same type for any given function 101// invocation. 102type Type int 103 104// Type1 is here for the purposes of documentation only. It is a stand-in// for any Go type, but represents the same type for any given function 105// invocation. 106type Type1 int 107 108// IntegerType is here for the purposes of documentation only. It is a stand-in// for any integer type: int, uint, int8 etc. 109type IntegerType int 110 111// FloatType is here for the purposes of documentation only. It is a stand-in// for either float type: float32 or float64. 112type FloatType float32 113 114// ComplexType is here for the purposes of documentation only. It is a// stand-in for either complex type: complex64 or complex128. 115type ComplexType complex64 116 117// The append built-in function appends elements to the end of a slice. If 118// it has sufficient capacity, the destination is resliced to accommodate the 119// new elements. If it does not, a new underlying array will be allocated. 120// Append returns the updated slice. It is therefore necessary to store the 121// result of append, often in the variable holding the slice itself: 122// 123// slice = append(slice, elem1, elem2) 124// slice = append(slice, anotherSlice...) 125// 126// As a special case, it is legal to append a string to a byte slice, like this: 127// 128// slice = append([]byte(\u0026#34;hello \u0026#34;), \u0026#34;world\u0026#34;...) 129func append(slice []Type, elems ...Type) []Type 130 131// The copy built-in function copies elements from a source slice into a 132// destination slice. (As a special case, it also will copy bytes from a 133// string to a slice of bytes.) The source and destination may overlap. Copy 134// returns the number of elements copied, which will be the minimum of 135// len(src) and len(dst). 136func copy(dst, src []Type) int 137 138// The delete built-in function deletes the element with the specified key 139// (m[key]) from the map. If m is nil or there is no such element, delete 140// is a no-op. 141func delete(m map[Type]Type1, key Type) 142 143// The len built-in function returns the length of v, according to its type: 144// 145// Array: the number of elements in v. 146// Pointer to array: the number of elements in *v (even if v is nil). 147// Slice, or map: the number of elements in v; if v is nil, len(v) is zero. 148// String: the number of bytes in v. 149// Channel: the number of elements queued (unread) in the channel buffer; 150// if v is nil, len(v) is zero. 151// 152// For some arguments, such as a string literal or a simple array expression, the 153// result can be a constant. See the Go language specification\u0026#39;s \u0026#34;Length and 154// capacity\u0026#34; section for details. 155func len(v Type) int 156 157// The cap built-in function returns the capacity of v, according to its type: 158// 159// Array: the number of elements in v (same as len(v)). 160// Pointer to array: the number of elements in *v (same as len(v)). 161// Slice: the maximum length the slice can reach when resliced; 162// if v is nil, cap(v) is zero. 163// Channel: the channel buffer capacity, in units of elements; 164// if v is nil, cap(v) is zero. 165// 166// For some arguments, such as a simple array expression, the result can be a 167// constant. See the Go language specification\u0026#39;s \u0026#34;Length and capacity\u0026#34; section for 168// details. 169func cap(v Type) int 170 171// The make built-in function allocates and initializes an object of type 172// slice, map, or chan (only). Like new, the first argument is a type, not a 173// value. Unlike new, make\u0026#39;s return type is the same as the type of its 174// argument, not a pointer to it. The specification of the result depends on 175// the type: 176// 177// Slice: The size specifies the length. The capacity of the slice is 178// equal to its length. A second integer argument may be provided to 179// specify a different capacity; it must be no smaller than the 180// length. For example, make([]int, 0, 10) allocates an underlying array 181// of size 10 and returns a slice of length 0 and capacity 10 that is 182// backed by this underlying array. 183// Map: An empty map is allocated with enough space to hold the 184// specified number of elements. The size may be omitted, in which case 185// a small starting size is allocated. 186// Channel: The channel\u0026#39;s buffer is initialized with the specified 187// buffer capacity. If zero, or the size is omitted, the channel is 188// unbuffered. 189func make(t Type, size ...IntegerType) Type 190 191// The new built-in function allocates memory. The first argument is a type, 192// not a value, and the value returned is a pointer to a newly 193// allocated zero value of that type. 194func new(Type) *Type 195 196// The complex built-in function constructs a complex value from two 197// floating-point values. The real and imaginary parts must be of the same 198// size, either float32 or float64 (or assignable to them), and the return 199// value will be the corresponding complex type (complex64 for float32, 200// complex128 for float64). 201func complex(r, i FloatType) ComplexType 202 203// The real built-in function returns the real part of the complex number c. 204// The return value will be floating point type corresponding to the type of c. 205func real(c ComplexType) FloatType 206 207// The imag built-in function returns the imaginary part of the complex 208// number c. The return value will be floating point type corresponding to 209// the type of c. 210func imag(c ComplexType) FloatType 211 212// The close built-in function closes a channel, which must be either 213// bidirectional or send-only. It should be executed only by the sender, 214// never the receiver, and has the effect of shutting down the channel after 215// the last sent value is received. After the last value has been received 216// from a closed channel c, any receive from c will succeed without 217// blocking, returning the zero value for the channel element. The form 218// 219// x, ok := \u0026lt;-c 220// 221// will also set ok to false for a closed and empty channel. 222func close(c chan\u0026lt;- Type) 223 224// The panic built-in function stops normal execution of the current 225// goroutine. When a function F calls panic, normal execution of F stops 226// immediately. Any functions whose execution was deferred by F are run in 227// the usual way, and then F returns to its caller. To the caller G, the 228// invocation of F then behaves like a call to panic, terminating G\u0026#39;s 229// execution and running any deferred functions. This continues until all 230// functions in the executing goroutine have stopped, in reverse order. At 231// that point, the program is terminated with a non-zero exit code. This 232// termination sequence is called panicking and can be controlled by the 233// built-in function recover. 234func panic(v any) 235 236// The recover built-in function allows a program to manage behavior of a 237// panicking goroutine. Executing a call to recover inside a deferred 238// function (but not any function called by it) stops the panicking sequence 239// by restoring normal execution and retrieves the error value passed to the 240// call of panic. If recover is called outside the deferred function it will 241// not stop a panicking sequence. In this case, or when the goroutine is not 242// panicking, or if the argument supplied to panic was nil, recover returns 243// nil. Thus the return value from recover reports whether the goroutine is 244// panicking. 245func recover() any 246 247// The print built-in function formats its arguments in an 248// implementation-specific way and writes the result to standard error. 249// Print is useful for bootstrapping and debugging; it is not guaranteed 250// to stay in the language. 251func print(args ...Type) 252 253// The println built-in function formats its arguments in an 254// implementation-specific way and writes the result to standard error. 255// Spaces are always added between arguments and a newline is appended. 256// Println is useful for bootstrapping and debugging; it is not guaranteed 257// to stay in the language. 258func println(args ...Type) 259 260// The error built-in interface type is the conventional interface for 261// representing an error condition, with the nil value representing no error. 262type error interface { 263 Error() string 264} "},{"id":23,"href":"/chapter-1/go-string-formatting/","title":"1.15 قالب بندی رشته‌ها","section":"فصل اول: آشنایی با مفاهیم گو","content":"در زبان گو مانند سایر زبان‌ها یکسری عناوین برای قالب‌بندی رشته وجود دارد که برخی از این عناوین مشترک بین همه زبان‌ها هست و برخی مختص زبان گو.\n1.15.1 قالب بندی با توابع Printf و Sprintf # زمانیکه شما از تابع Printf یا Sprintf استفاده می‌کنید می‌توانید رشته خروجی را با استفاده از پارامترهای بعد از رشته قالب‌بندی کنید، و در نهایت بصورت یک رشته نمایش دهید.\n1fmt.Printf(\u0026#34;{{Verb}}\u0026#34;, value1, value2, value3, ..., valueN) 1fmt.Sprintf(\u0026#34;{{Verb}}\u0026#34;, value1, value2, value3, ..., valueN) توجه کنید هر دو تابع فوق خیلی کاربردی و پر استفاده هستند. این ۲ تابع کارکردشان مشترک است ولی خروجی متفاوتی دارند.\nبه عنوان مثال :\nشما با استفاده از Printf می‌توانید یک رشته را قالب‌بندی کنید و در نهایت به عنوان خروجی چاپ کنید. ولی با استفاده از Sprintf می‌توانید یک رشته را قالب‌بندی کنید و در نهایت به جای اینکه مقدار خروجی را چاپ کنید، اون رو داخل یک متغیر قرار بریزید. به مثال زیر توجه کنید: 1x := fmt.Sprintf(\u0026#34;age %s is %d years\u0026#34;, \u0026#34;Javad\u0026#34;, 30) 1.15.1.1 قالب‌بندی یک slice # Verb fmt.Printf(\u0026quot;{{Verb}}\u0026quot;, []int64{0, 1}) خروجی توضیحات %v [0 1] فرمت پیش‌فرض %#v []int64{0, 1} قالب‌بندی کد گو %T []int64 تایپ مقدار توجه کنید v% یکی از پرکاربرد‌ترین Verb‌ها در گولنگ است و مواقعی مورد استفاده قرار می‌گیرد که شما قصد دارید یک مقدار را داخل رشته بزارید، ولی از تایپ اون مقدار خبر ندارید. 1.15.1.2 قالب‌بندی اعداد صحیح # Verb fmt.Printf(\u0026quot;{{Verb}}\u0026quot;, 15) خروجی توضیحات %d 15 عدد پایه ۱۰ %+d +15 نمایش + در کنار عدد %4d ␣␣15 ۴ کارکتر با فاصله از راست %-4d 15␣␣ ۴ کارکتر با فاصله از چپ %04d 0015 نمایش عدد با پیشوند صفر %b 1111 عدد با پایه باینری %o 17 عدد با پایه ۸ اکتال %x f عدد با پایه ۱۶ هگز حروف کوچک %X F عدد با پایه ۱۶ هگز حروف بزرگ %#x 0xf عدد با پایه ۱۶ هگز به همراه 0x 1.15.1.3 قالب‌بندی اعداد اعشاری # Verb fmt.Printf(\u0026quot;{{Verb}}\u0026quot;, 123.456) خروجی توضیحات %e 1.234560e+02 نمایش بصورت نماد عملی %f 123.456000 نقطه اعشاری، بدون نما. دقت پیش فرض 6 است %.2f 123.46 عرض پیش فرض، دقت 2 رقم بعد از نقطه اعشار %8.2f ␣␣123.46 عرض 8 کاراکتر، دقت 2 رقم بعد از نقطه اعشار. کاراکتر پیش‌فرض padding space است %08.2f 00123.46 عرض 8 کاراکتر، دقت 2 رقم بعد از نقطه اعشار. لایه سمت چپ با نویسه مشخص شده (اینجا، 0) %g 123.456 نما در صورت نیاز، فقط ارقام ضروری 1.15.1.4 قالب‌بندی کارکترها # Verb fmt.Printf(\u0026quot;{{Verb}}\u0026quot;, 'A') خروجی توضیحات %c A کارکتر %q 'A' کارکتر به همراه تک کوتیشن %U U+0041 یونیکد %#U U+0041 'A' یونیکد به همراه کارکتر 1.15.1.5 قالب‌بندی رشته (string) و slice بایت # Verb fmt.Printf(\u0026quot;{{Verb}}\u0026quot;, \u0026quot;gophers\u0026quot;) خروجی توضیحات %s gophers رشته ساده %8s ␣␣gophers با ۸ پدینگ راست چین شده %-8s gophers␣␣ با ۸ پدینگ چپ چین شده %q \u0026quot;gophers\u0026quot; رشته به همراه دابل کوتیشن %x 676f7068657273 خروجی هگز مقدار % x 67 6f 70 68 65 72 73 خروجی هگز مقدار با فاصله 1.15.1.6 قالب‌بندی بولین # Verb fmt.Printf(\u0026quot;{{Verb}}\u0026quot;, true) خروجی توضیحات %t true نمایش مقدار بولین در رشته 1.15.1.6 قالب‌بندی اشاره‌گر (pointer) # Verb fmt.Printf(\u0026quot;{{Verb}}\u0026quot;, new(int)) خروجی توضیحات %p 0xc0000b2000 نمایش آدرس حافظه با پایه ۱۶ به همراه 0x 1.15.2 مقادیر خاص در رشته # همانطور که گفتیم زبان گو یکسری کارکترهای خاص دارد که باعث تغییراتی در خروجی رشته خواهد شد و این کارکترهای خاص بین همه زبان‌ها مشترک هستند. در ادامه لیست این کاراکتر‌ها را آورده‌ایم:\nVerb توضیحات \\a U+0007 هشدار یا زنگ \\b U+0008 بک اسپیس backspace \\\\ U+005c بک اسلش backslash \\t U+0009 تب بصورت افقی \\n U+000A خط جدید \\f U+000C حالت فرم \\r U+000D حالت برگشت \\v U+000b تب بصورت عمودی %% نمایش درصد برای حالت‌های خاص نظیر fmt.Printf(\u0026quot;%05.2f%%\u0026quot;, math.Pi) "},{"id":24,"href":"/chapter-2/","title":"فصل دوم: مکانیزم‌های زبان","section":"صفحه اصلی","content":"در این فصل به مکانیزیم‌های زبان گو می‌پردازیم و برخی از اصطلاحات زبان گو را با هم برسی می‌کنیم.\nدر بخش 2.1 در خصوص اشاره‌گر آموزش خواهیم داد. در بخش 2.2 به مهم‌ترین تایپ در زبان گو، یعنی ساختار می‌پردازیم و آموزش می‌دهیم چطور با استفاده از ساختار دیتامدل‌های پروژه‌های خود را پیاده سازی کنید. در بخش 2.3 به بحث متدها می‌پردازیم و برسی می‌کنیم که چطور این نوع توابع را پیاده سازی کنیم. در بخش 2.4 در خصوص اینترفیس در زبان گو توضیح می‌دهیم. دقیقا چی هستند و چطور میشه ازشون استفاده کرد. در بخش 2.5 به جاسازی ساختار و اینترفیس می‌پردازیم. در بخش 2.6 به مدیریت خطاها در زبان گو می‌پردازیم و برسی می‌کنیم که چه ویژگی‌هایی دارد. 2.7 تفاوت castin با conversion را آموزش می‌دهیم. "},{"id":25,"href":"/chapter-2/pointer/","title":"2.1 اشاره‌گر (Pointer)","section":"فصل دوم: مکانیزم‌های زبان","content":"اشاره‌گر در واقع متغیری است که، آدرس حافظه یک مقدار را نگه می‌دارد.\n1var ex *T در مثال بالا ما شیوه تعریف یک متغیر اشاره‌گر را توضیح دادیم. اول کلید واژه ی var بعد اسم متغیر و در آخر هم *T یعنی تایپ متغیر. به مثال زیر توجه کنید:\n1var ptr *string در تعریف اشاره‌گر ‌ها, ما ۲ تا اپراتور داریم که کارکرد هر کدام از این اپراتورها رو در ادامه توضیح میدم:\n\u0026amp; بهش میگن ampersand با استفاده از این می‌توانیم آدرس حافظه متغیر فرضا x را به متغیر دیگری بدهیم (y := \u0026amp;x) * بهش میگن asterisk با استفاده از این می‌توانیم به مقدار داخل حافظه متغیر فرضا x دسترسی پیدا کنیم (x*) برای اینکه یک اشاره گر تعریف کنیم ۲ روش وجود دارد:\nاستفاده از تابع new استفاده از اپراتور \u0026amp; (آمپرسند) 2.1.1 استفاده از تابع new # یک اشاره‌گر با استفاده از تابع new بصورت مثال زیر تعریف شده است:\n1a := new(int) 2*a = 10 3fmt.Println(*a) //Output will be 10 در مثال بالا ما متغیر a را از نوع int اشاره‌گر pointer a تعریف کردیم و سپس داخل آدرس حافظه a مقدار ۱۰ را قرار دادیم.\nتوجه کنید مقدار پیش‌فرض یک متغیر از نوع اشاره‌گر nil است. اگر جایی شما متغیر از نوع اشاره‌گر را بصورت nil بفرستید ممکن است به panic از نوع nil pointer بر بخورید و اجرای برنامه شما کاملا متوقف شود. 2.1.2 استفاده از اپراتور \u0026lsquo;\u0026amp;\u0026rsquo; # برای دریافت آدرس حافظه یک متغیر از \u0026amp; می‌توان استفاده کرد:\n1a := 2 2b := \u0026amp;a 3fmt.Println(*b) //Output will be 2 به مثال زیر توجه کنید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 var b *int 7 a := 2 8 b = \u0026amp;a 9 10 fmt.Println(b) 11 fmt.Println(*b) 12 b = new(int) 13 *b = 10 14 fmt.Println(*b) 15} 1$ go run main.go 20xc0000b0018 32 410 در خروجی بالا 0xc0000b0018 آدرس حافظه متغیر a است. در واقع متغیر a ساخته شد و ما آدرس حافظه آن را به متغیر b دادیم. یعنی هر دو متغیر به یک آدرس از حافظه اشاره می‌کنند.\n2.1.3 اپراتور * اشاره‌گر # ما می‌توانیم اپراتور * را برای عملیات‌های زیر به کار ببریم:\nگرفتن مقدار یک آدرس حافظه که با استفاده از اشاره‌گر ذخیره شده است. تغییر مقدار یک آدرس حافظه. به مثال زیر توجه کنید: # 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\ta := 2 7\tb := \u0026amp;a 8\tfmt.Println(a) 9\tfmt.Println(*b) 10 11\t*b = 3 12\tfmt.Println(a) 13\tfmt.Println(*b) 14 15\ta = 4 16\tfmt.Println(a) 17\tfmt.Println(*b) 18} 1$ go run main.go 22 32 43 53 64 74 در مثال بالا a و b* هر دو دارند به یک آدرس از حافظه اشاره می‌کنند. بنابرین تغییر مقدار یکی از آن‌ها، روی هر دو متغیر تاثیر می‌گذارد.\n2.1.4 اشاره‌گر به یک اشاره‌گر (Double Pointers) # شما می‌‌توانید یک متغیر اشاره‌گر تعریف کنید و متغیر اشاره‌گر دیگری را بهش اختصاص دهید.\n1a := 2 2b := \u0026amp;a 3c := \u0026amp;b همانطور که در مثال و عکس بالا می‌بینید، متغیر a مقدارش ۲ و آدرسش در حافظه 0xXXXXXX است. در مقدار متغیر b ما اشاره کردیم به آدرس حافظه متغیر a و در ادامه در متغیر c به آدرس حافظه متغیر b اشاره کردیم.\nزمانیکه شما بخواهید مقدار c را چاپ کنید کافیست از c** استفاده کنید تا مقدار ۲ را چاپ کند.\nبه مثال زیر توجه کنید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\ta := 2 7\tb := \u0026amp;a 8\tc := \u0026amp;b 9 10\tfmt.Printf(\u0026#34;a: %d\\n\u0026#34;, a) 11\tfmt.Printf(\u0026#34;b: %x\\n\u0026#34;, b) 12\tfmt.Printf(\u0026#34;c: %x\\n\u0026#34;, c) 13 14\tfmt.Println() 15\tfmt.Printf(\u0026#34;a: %d\\n\u0026#34;, a) 16\tfmt.Printf(\u0026#34;*\u0026amp;a: %d\\n\u0026#34;, *\u0026amp;a) 17\tfmt.Printf(\u0026#34;*b: %d\\n\u0026#34;, *b) 18\tfmt.Printf(\u0026#34;**c: %d\\n\u0026#34;, **c) 19 20\tfmt.Println() 21\tfmt.Printf(\u0026#34;\u0026amp;a: %d\\n\u0026#34;, \u0026amp;a) 22\tfmt.Printf(\u0026#34;b: %d\\n\u0026#34;, b) 23\tfmt.Printf(\u0026#34;\u0026amp;*b: %d\\n\u0026#34;, \u0026amp;*b) 24\tfmt.Printf(\u0026#34;*\u0026amp;b: %d\\n\u0026#34;, *\u0026amp;b) 25\tfmt.Printf(\u0026#34;*c: %d\\n\u0026#34;, *c) 26 27\tfmt.Println() 28\tfmt.Printf(\u0026#34;\u0026amp;b: %d\\n\u0026#34;, \u0026amp;b) 29\tfmt.Printf(\u0026#34;c: %d\\n\u0026#34;, c) 30\tfmt.Printf(\u0026#34;*c: %d\\n\u0026#34;, *c) 31\tfmt.Printf(\u0026#34;**c: %d\\n\u0026#34;, **c) 32\t33} 1$ go run main.go 2a: 2 3b: c000018078 4c: c00000e028 5 6a: 2 7*\u0026amp;a: 2 8*b: 2 9**c: 2 10 11\u0026amp;a: 824633819256 12b: 824633819256 13\u0026amp;*b: 824633819256 14*\u0026amp;b: 824633819256 15*c: 824633819256 16 17\u0026amp;b: 824633778216 18c: 824633778216 19*c:824633819256 20**c:2 توجه کنید در زبان گو علی رغم زبان c استفاده از اشاره‌گر حسابی (Pointer Arithmetic) امکان پذیر نمی‌باشد و در صورت استفاده با خطای زیر مواجه خواهید شد:\n1package main 2func main() { 3 a := 1 4 b := \u0026amp;a 5 b = b + 1 6} 1$ go run main.go 2invalid operation: b + 1 (mismatched types *int and int) "},{"id":26,"href":"/chapter-2/struct/","title":"2.2 ساختار (struct)","section":"فصل دوم: مکانیزم‌های زبان","content":"در زبان گو ساختار کالکشنی از فیلدها با تایپ‌های مختلف است. شما با استفاده ساختار می‌توانید یک مدل کلی از بدنه پروژه خود را تعریف کنید. برای نمونه ما در مثال زیر یک نمونه از ساختار employee کارمند را مثال زدیم تا شما کمی با مفهوم ساختار آشنا شوید.\n1type employee struct { 2 name string 3 age int 4 salary int 5} نکته: ساختار می‌تواند بصورت خالی جهت برخی اهداف ایجاد گردد. به مثال زیر دقت کنید:‌\n1type sample struct {} اگر می‌خواهید در مورد متودها اطلاعات کسب کنید به بخش متدها روی ساختار سر بزنید، هر چند توصیه می‌کنم اول این قسمت رو بخونید و تمرین کنید و بعد به قسمت متودها بروید.\nبرای ایجاد ساختار باید از کلمه کلیدی type اسم ساختار و در ادامه کلمه کلیدی struct استفاده کنید.\nسپس داخل بدنه ساختار فیلدها را تعریف کنید.\nفیلد name از نوع string فیلد age از نوع int فیلد salary از نوع int ساختار را در زبان گو، با class در سایر زبان‌ها مقایسه می‌کنند. هرچند زبان گو یک زبان شی‌گرا محسوب نمی‌شود. 2.2.1 تعریف تایپ struct # به مثال زیر توجه کنید:\n1type point struct { 2 x float64 3 y float64 4} در مثال بالا ما ۲ تا فیلد برای ساختار تعریف کردیم که هر دو فیلد از نوع float64 هستند.\n2.2.2 ایجاد یک متغیر ساختار (struct) # برای ایجاد یک متغیر ساختار می‌توانید یک متغیر تعریف کنید و ساختار را به عنوان مقدار به آن بدهید. به مثال زیر توجه کنید:\n1emp := employee{} در مثال بالا ما یک متغیر با مقدار پیش‌فرض صفر ساختار employee تعریف کردیم.\nزمانیکه یک متغیر ساختار خالی، مانند مثال بالا تعریف می‌کنید مقدار استفاده شده از حافظه 0 بایت است. ایجاد متغیر ساختار و مقدار دهی فیلدها در یک خط: 1emp := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} ایجاد متغیر ساختار و مقدار دهی فیلد در خط‌های مختلف (این روش برای خوانایی و درک بهتر توصیه می‌شود) : 1emp := employee{ 2 name: \u0026#34;Sam\u0026#34;, 3 age: 31, 4 salary: 2000, 5} توجه کنید هیچ اجباری نیست که حتماً شما باید فیلدی را مقدار دهی کنید، شما می‌توانید هر زمانیکه نیاز داشتید ساختار خودتان رو مقدار دهی کنید.\n1emp := employee{ 2 name: \u0026#34;Sam\u0026#34;, 3 age: 31, 4} در مثال بالا ما فیلد salary را مقدار دهی نکردیم. کامپایلر بطور پیش‌فرض با توجه به تایپ فیلد، مقدار پیش‌فرض صفر را برای اون تایپ در نظر می‌گیرد. در ادامه به مثالی که از نحوه ساختن ساختارها دقت کنید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type employee struct { 6 name string 7 age int 8 salary int 9} 10 11func main() { 12 emp1 := employee{} 13 fmt.Printf(\u0026#34;Emp1: %+v\\n\u0026#34;, emp1) 14 15 emp2 := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} 16 fmt.Printf(\u0026#34;Emp2: %+v\\n\u0026#34;, emp2) 17 18 emp3 := employee{ 19 name: \u0026#34;Sam\u0026#34;, 20 age: 31, 21 salary: 2000, 22 } 23 fmt.Printf(\u0026#34;Emp3: %+v\\n\u0026#34;, emp3) 24 25 emp4 := employee{ 26 name: \u0026#34;Sam\u0026#34;, 27 age: 31, 28 } 29 fmt.Printf(\u0026#34;Emp4: %+v\\n\u0026#34;, emp4) 30} 1$ go run main.go 2Emp1: {name: age:0 salary:0} 3Emp2: {name:Sam age:31 salary:2000} 4Emp3: {name:Sam age:31 salary:2000} 5Emp4: {name:Sam age:31 salary:0} ایجاد متغیر ساختار و مقدار دهی فیلدها بدون نام فیلد: شما می‌توانید فیلدها را بدون اینکه نام فیلد را قرار دهید مقدار دهی کنید اما از نظر تکنیکی این کار توصیه نمی‌شود، دلیل این توصیه هم این است که اگر شما فیلدها رو به این روش مقدار دهی کنید، باید ترتیب رو در نظر بگیرید یعنی 1: باید نام باشد، 2: باید سن باشد، 3: باید درآمد باشد و اگر این ترتیب رعایت نشود شما دیتای اشتباهی خواهید داشت.\n1emp := employee{\u0026#34;Sam\u0026#34;, 31, 2000} 2 3{Sam 31 2000} // حروجی در مثال بالا ترتیب رعایت شده. به مثال زیر توجه کنید:\n1emp := employee{\u0026#34;Sam\u0026#34;, 2000, 31} 2 3{Sam 2000 31} // حروجی همانطور که در مثال بالا دیدین الان با ترتیب اشتباه سن کارمند و درآمدش جابه جا شدن و ما دیتای اشتباهی از کارمند خواهیم داشت.\n2.2.3 دسترسی و تنظیم فیلدهای ساختار (struct) # زمانیکه شما یک متغیر ساختار تعریف می‌کنید، می‌توانید خیلی آسان با استفاده از همان متغیر به فیلدهای ساختار دسترسی پیدا کنید و مقدار هر کدام از فیلدها را تغییر دهید. به مثال زیر توجه کنید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type employee struct { 6 name string 7 age int 8 salary int 9} 10 11func main() { 12 emp := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} 13 14 //Accessing a struct field 15 fmt.Printf(\u0026#34;Current name is: %s\\n\u0026#34;, emp.name) 16 17 //Assigning a new value to name field 18 emp.name = \u0026#34;John\u0026#34; 19 fmt.Printf(\u0026#34;New name is: %s\\n\u0026#34;, emp.name) 20} 1$ go run main.go 2Current name is: Sam 3New name is: John 2.2.4 کار با اشاره‌گر (Pointer) در ساختار (struct) # شما برای ایجاد یک struct از نوع اشاره‌گر می‌توانید از دو حالت زیر استفاده کنید:\nبا استفاده از عملگر \u0026amp; که اشاره به خانه حافظه دارد با استفاده از تابع new 2.2.4.1 ایجاد ساختار با استفاده از عملگر \u0026amp; # برای اینکه بتوانید یک ساختار از نوع اشاره گر ایجاد کنید می‌توانید از عملگر \u0026amp; استفاده کنید. به مثال زیر توجه کنید:\n1emp := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} 2empP := \u0026amp;emp حتی شما می‌توانید یک ساختار اشاره‌گر را مستقیماً ایجاد کنید این روش پیشنهاد می‌شود. به مثال زیر توجه کنید:\n1empP := \u0026amp;employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} در مثال زیر هر دو روش رو برای شما توضیح دادیم. با دقت به کد و خروجی کد نگاه کنید:‌\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type employee struct { 6 name string 7 age int 8 salary int 9} 10 11func main() { 12 emp := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} 13 empP := \u0026amp;emp 14 fmt.Printf(\u0026#34;Emp: %+v\\n\u0026#34;, empP) 15 empP = \u0026amp;employee{name: \u0026#34;John\u0026#34;, age: 30, salary: 3000} 16 fmt.Printf(\u0026#34;Emp: %+v\\n\u0026#34;, empP) 17} 1$ go run main.go 2Emp: \u0026amp;{name:Sam age:31 salary:2000} 3Emp: \u0026amp;{name:John age:30 salary:3000} 2.2.4.2 ایجاد ساختار با استفاده تابع new # 1func new(Type) *Type همینطور که در تعریف تابع new هم می‌بینید، این تابع یک تایپ از ما می‌گیرد و مقدار دهی می‌کند، و در آخر هم تایپ را از نوع اشاره‌گر برای ما بر می‌گرداند.\nبا استفاده از تابع new :\nشما یک ساختار ایجاد می‌کنید. سپس فیلدها، با مقدار پیش‌فرض صفر مقدار دهی اولیه می‌شوند. در نهایت ساختار شما از نوع اشاره‌گر بازگشت داده می‌شود. به مثال زیر توجه کنید:\n1empP := new(employee) برای اینکه آدرس خانه حافظه ساختار، از نوع اشاره‌گر را ببینید کافی است با استفاده از p% اون ساختار رو چاپ کنید. به مثال زیر توجه کنید:\n1fmt.Printf(\u0026#34;Emp Pointer: %p\\n\u0026#34;, empP) برای اینکه مقدار کلی فیلدها را ببینید کافی است با استفاده از v+% اون رو چاپ کنید. به مثال زیر توجه کنید:\n1fmt.Printf(\u0026#34;Emp Value: %+v\\n\u0026#34;, *empP) در مثال زیر خروجی آنچه در بالا گفته شد رو قرار دادیم. لطفاً با دقت به مثال زیر نگاه کنید و در آخر هم مثال‌های مشابهی رو برای خودتان بنویسید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type employee struct { 6 name string 7 age int 8 salary int 9} 10 11func main() { 12 empP := new(employee) 13 fmt.Printf(\u0026#34;Emp Pointer Address: %p\\n\u0026#34;, empP) 14 fmt.Printf(\u0026#34;Emp Pointer: %+v\\n\u0026#34;, empP) 15 fmt.Printf(\u0026#34;Emp Value: %+v\\n\u0026#34;, *empP) 16} 1$ go run main.go 2Emp Pointer Address: 0xc000130000 3Emp Pointer: \u0026amp;{name: age:0 salary:0} 4Emp Value: {name: age:0 salary:0} 2.2.5 چاپ یک متغیر ساختار (struct) # برای اینکه بتوانید یک متغیر ساختار struct را چاپ کنید، از دو روش زیر می‌توانید استفاده کنید. توجه کنید متغیر ساختار بصورت key/value هست.\nبا استفاده از پکیج fmt با استفاده از پکیج json/encoding 2.2.5.1 چاپ با استفاده از fmt # در پکیج fmt ما 2 تا تابع کاربردی جهت چاپ داریم که اکثر اوقات از این دو تابع استفاده می‌کنیم:\nتابع Println ورودی را با فرمت پیش‌فرض چاپ می‌کند. تابع Printf ورودی را با فرمت مشخص شده چاپ می‌کند فرمت رو خود ما مشخص می‌کنیم. در مثال زیر ما یک نمونه از ساختار employee را ایجاد کردیم:\n1emp := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} حال با استفاده از تابع Printf ساختار را با فرمت دلخواه خودمان چاپ کردیم:\n1fmt.Printf(\u0026#34;%v\u0026#34;, emp) - {Sam 31 2000} 1fmt.Printf(\u0026#34;%+v\u0026#34;, emp) - {name:Sam age:31 salary:2000} %v - مقدار value هر کدام از فیلدهای ساختار را چاپ می‌کند. %+v - مقدار هرکدام از فیلدها به همراه اسم فیلد key-value را چاپ می‌کند. در مثال زیر ما با استفاده از از تابع Println ساختار را چاپ کردیم:\n1fmt.Println(emp) - {Sam 31 2000} در نهایت کد زیر یک مثال کلی از چاپ با استفاده از پکیج fmt است‌:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type employee struct { 6 name string 7 age int 8 salary int 9} 10 11func main() { 12 emp := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} 13 fmt.Printf(\u0026#34;Emp: %v\\n\u0026#34;, emp) 14 fmt.Printf(\u0026#34;Emp: %+v\\n\u0026#34;, emp) 15 fmt.Printf(\u0026#34;Emp: %#v\\n\u0026#34;, emp) 16 fmt.Println(emp) 17} 1$ go run main.go 2Emp: {Sam 31 2000} 3Emp: {name:Sam age:31 salary:2000} 4Emp: main.employee{name:\u0026#34;Sam\u0026#34;, age:31, salary:2000} 5{Sam 31 2000} 2.2.5.2 چاپ ساختار با استفاده از پکیج JSON # در این روش ما با استفاده از ۲ تابع Marshal و MarshalIndent پکیج json، ساختار را encode می‌کنیم و در نهایت خروجی encode شده را چاپ می‌کنیم.\nMarshal - در این تابع ما به عنوان ورودی‌، ساختار را پاس می‌دهیم و در نهایت ۲ خروجی از نوع بایت و خطا دریافت می‌کنیم. 1Marshal(v interface{}) ([]byte, error) MarhsalIndent - در این تابع ما ۳ تا ورودی به تابع می‌فرستیم, به ترتیب ساختار، پیشوند و indent و در نهایت ۲ خروجی از نوع بایت و خطا دریافت می‌کنیم. 1MarshalIndent(v interface{}, prefix, indent string) ([]byte, error) حالا با استفاده از توابع فوق یک کد نمونه مثال می‌زنیم و به شما یاد می‌دیم که چطور از این توابع استفاده کنید. به مثال زیر دقت کنید:\n1package main 2 3import ( 4 \u0026#34;encoding/json\u0026#34; 5 \u0026#34;fmt\u0026#34; 6 \u0026#34;log\u0026#34; 7) 8 9type employee struct { 10 Name string 11 Age int 12 salary int 13} 14 15func main() { 16 emp := employee{Name: \u0026#34;Sam\u0026#34;, Age: 31, salary: 2000} 17 //Marshal 18 empJSON, err := json.Marshal(emp) 19 if err != nil { 20 log.Fatalf(err.Error()) 21 } 22 fmt.Printf(\u0026#34;Marshal funnction output %s\\n\u0026#34;, string(empJSON)) 23 24 //MarshalIndent 25 empJSON, err = json.MarshalIndent(emp, \u0026#34;\u0026#34;, \u0026#34; \u0026#34;) 26 if err != nil { 27 log.Fatalf(err.Error()) 28 } 29 fmt.Printf(\u0026#34;MarshalIndent funnction output %s\\n\u0026#34;, string(empJSON)) 30} 1$ go run main.go 2Marshal funnction output {\u0026#34;Name\u0026#34;:\u0026#34;Sam\u0026#34;,\u0026#34;Age\u0026#34;:31} 3 4MarshalIndent funnction output { 5 \u0026#34;Name\u0026#34;: \u0026#34;Sam\u0026#34;, 6 \u0026#34;Age\u0026#34;: 31 7} برای اطلاعات بیشتر در خصوص پکیج json می‌توانید به بخش آموزش کار با json مراجعه کنید. 2.2.6 کار با تگ ها در ساختار (struct) # ساختار زبان گو، به شما امکان اضافه کردن metadata به هر یک از فیلدها را می‌دهد و ما این قابلیت را به عنوان تگ می‌شناسیم. تگ‌ها برای انجام یکسری عملیات خاص نظیر encode/decode، اعتبارسنجی مقادیر فیلدها و \u0026hellip; به ما کمک می‌کند و یکی از کاربردی‌ترین عناوین در ساختار هستند.\nدر مثال زیر ما یک نمونه ساختار به همراه تگ تعریف کردیم:\n1type strutName struct{ 2 fieldName type `key:\u0026#34;value\u0026#34; key2:\u0026#34;value2\u0026#34;` 3} 1type employee struct { 2 Name string `json:\u0026#34;n\u0026#34;` // n به عنوان کلید در نظر گرفته خواهد شد 3 Age int `json:\u0026#34;a\u0026#34;` // a به عنوان کلید در نظر گرفته خواهد شد 4 Salary int `json:\u0026#34;s\u0026#34;` // s به عنوان کلید در نظر گرفته خواهد شد 5} به مثال زیر دقت کنید:\n1package main 2 3import ( 4 \u0026#34;encoding/json\u0026#34; 5 \u0026#34;fmt\u0026#34; 6 \u0026#34;log\u0026#34; 7) 8 9type employee struct { 10 Name string `json:\u0026#34;n\u0026#34;` 11 Age int `json:\u0026#34;a\u0026#34;` 12 Salary int `json:\u0026#34;s\u0026#34;` 13} 14 15func main() { 16 emp := employee{Name: \u0026#34;Sam\u0026#34;, Age: 31, Salary: 2000} 17 //Converting to jsonn 18 empJSON, err := json.MarshalIndent(emp, \u0026#39;\u0026#39;, \u0026#39; \u0026#39;) 19 if err != nil { 20 log.Fatalf(err.Error()) 21 } 22 fmt.Println(string(empJSON)) 23} خروجی :\n1$ go run main.go 2{ 3 \u0026#34;n\u0026#34;: \u0026#34;Sam\u0026#34;, 4 \u0026#34;a\u0026#34;: 31, 5 \u0026#34;s\u0026#34;: 2000 6} فکر می‌کنم خروجی بالا کاملاً برای ما روشن کرد که دقیقاً اون تگ‌هایی که قرار دادیم، برای ما چه کاری انجام دادند. بله کلید-key‌های ما را به اون نام‌هایی که در تگ‌ها نوشته بودیم تغییر دادند.\n2.2.7 تعریف فیلد ناشناس در ساختار (struct) # شما در ساختار struct امکان تعریف فیلدهای ناشناس را دارید و همینطور می‌توانید فیلدهای ناشناس را نیز مقدار دهی کنید.\n1type employee struct { 2 string 3 age int 4 salary int 5} در کد زیر یک مثال ساده در خصوص تعریف و مقدار دهی فیلدهای ناشناس زده‌ایم:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type employee struct { 6 string 7 age int 8 salary int 9} 10 11func main() { 12 emp := employee{string: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} 13 //Accessing a struct field 14 n := emp.string 15 fmt.Printf(\u0026#34;Current name is: %s\\n\u0026#34;, n) 16 //Assigning a new value 17 emp.string = \u0026#34;John\u0026#34; 18 fmt.Printf(\u0026#34;New name is: %s\\n\u0026#34;, emp.string) 19} 1$ go run main.go 2Current name is: Sam 3New name is: John 2.2.8 تعریف ساختار تو در تو (nested) # یکی دیگر از امکانات ساختار در زبان گو بحث ساختار تو در تو است. در مثالی که در ادامه زدیم ساختار address را داخل employee قرار دادیم:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type employee struct { 6 name string 7 age int 8 salary int 9 address address 10} 11 12type address struct { 13 city string 14 country string 15} 16 17func main() { 18 address := address{city: \u0026#34;London\u0026#34;, country: \u0026#34;UK\u0026#34;} 19 emp := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000, address: address} 20 fmt.Printf(\u0026#34;City: %s\\n\u0026#34;, emp.address.city) 21 fmt.Printf(\u0026#34;Country: %s\\n\u0026#34;, emp.address.country) 22} 1$ go run main.go 2City: London 3Country: UK توجه کنید شما طبق روش زیر می‌توانید به فیلدهای تو در تو دسترسی داشته باشید:\n1emp.address.city 2emp.address.country 2.2.9 تعریف یک ساختار عمومی یا خصوصی (Public/Private) # در زبان گو، چیزی به عنوان کلمه کلیدی public یا private جهت تعیین وضعیت دسترسی struct به بیرون وجود ندارد، در عوض کامپایلر گو بر اساس حرف بزرگ یا کوچک عنوان ساختار یا سایر تایپ‌ها، تشخیص می‌دهد تایپ شما عمومی است یا خصوصی. در صورتیکه شما حرف اول را کوچک قرار دهید تایپ شما بیرون از پکیج قابل دسترس نخواهد بود مثل مثال‌های بالا و اگر حرف اول تایپ رو بزرگ قرار دهید، تایپ یا تابع شما بیرون از پکیج نیز در دسترس خواهد بود. مثال تابع fmt.Println.\n1type Person struct { 2 Name string 3 age int 4} 5 6type company struct { 7 Name string 8} برای اطلاعات بیشتر بهتر است به بخش کپسوله سازی مراجعه کنید. 2.2.10 مقایسه ساختارها # شما در زبان گو می‌توانید ساختارها را بر اساس عنوان فیلد، تایپ و مقدارشان مقایسه کنید. اما باید توجه کنید ساختارها فقط براساس تایپ‌هایی که در ادامه معرفی کردیم, امکان مقایسه را خواهند داشت:\nboolean numeric string pointer channel interface types structs array و اما ۳ تایپ زیر امکان مقایسه را به شما نمی‌دهند:\nSlice Map Function 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type employee struct { 6 name string 7 age int 8 salary int 9} 10 11func main() { 12 emp1 := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} 13 emp2 := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} 14 if emp1 == emp2 { 15 fmt.Println(\u0026#34;emp1 annd emp2 are equal\u0026#34;) 16 } else { 17 fmt.Println(\u0026#34;emp1 annd emp2 are not equal\u0026#34;) 18 } 19} 1$ go run main.go 2emp1 annd emp2 are equal "},{"id":27,"href":"/chapter-2/method/","title":"2.3 متد (Method)","section":"فصل دوم: مکانیزم‌های زبان","content":"متد در واقع یک تابع گیرنده (receiver) است که به واسطه یک تایپ در دسترس خواهد بود. توجه کنید برای تعریف متد باید قبل از اسم تابع، داخل پرانتز یک نام و یک تایپ قرار دهید. برای درک بهتر این موضوع فکر کنید نامی که داخل پرانتز قرار می‌دید یه متغیر هست که به تایپ شما اشاره می‌کند. به مثال زیر توجه کنید:\n1func (receiver receiver_type) some_func_name(arguments) return_values برای درک بهتر این مفهوم، می‌توانید متد را دقیقاً یک تابع در نظر بگیرید. نحوه تعریف به صورت متد صرفاً برای راحتی در زمان توسعه نرم افزار است و به برنامه‌نویس امکان توسعه بهتر بدون نیاز به حفظ کردن زیاد عملکرد‌های سیستم را می‌دهد.\n1func (r receiver_T) some_func_name(arg1 arg1_T, ...) return_values 2func some_func_name(r receiver_T, arg1 arg1_T, ...) return_values نکته قابل ذکر دیگر در خصوص این مفهوم این است که متد در زبان گو از رویکرد static method به صورت مستقیم پشتیبانی نمی‌‌کند، یعنی تا زمانیکه شما یک متغیر از نوع تایپی که دارای متد است را راه اندازی نکنید، به متدهایش دسترسی نخواهید داشت.\nاکثراً متد را یکی از عناوین شی‌گرایی در زبان گو می‌شناسند که مزایای خوبی دارد، بخصوص اگر متدها برای تایپ struct تعریف شوند شما می‌توانید برای هر یک از فیلدهای ساختار، توابع بخصوصی در قالب متد بنویسید، ولی اگر بخوایم کمی دقیق‌تر بگیم مفهوم متد برگرفته از الگوی Encapsulation است که بر خلاف تصور رایج صرفاً محدود به رویکرد OOP نیست و یک الگوی پذیرفته شده حتی در زبان‌های Functional programming languages نیز است.\n2.3.1 متدها برای ساختار (struct) # زبان گو یک زبان شی گرا نیست ولی برخی از مفاهیم شی‌گرایی را بصورت قرار دادی دارد. ساختار در زبان گو یک تایپ نیست که این تایپ نیز کالکشنی از تایپ‌های مختلف را در بر می‌گیرد که ما در بخش قبلی بهش پرداختیم.\nبه مثالی که در مورد پیاده‌سازی متد‌ها زده‌ایم توجه کنید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type employee struct { 6 name string 7 age int 8 salary int 9} 10 11func (e employee) details() { 12 fmt.Printf(\u0026#34;Name: %s\\n\u0026#34;, e.name) 13 fmt.Printf(\u0026#34;Age: %d\\n\u0026#34;, e.age) 14} 15 16func (e employee) getSalary() int { 17 return e.salary 18} 19 20func main() { 21 emp := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} 22 emp.details() 23 fmt.Printf(\u0026#34;Salary %d\\n\u0026#34;, emp.getSalary()) 24} 1$ go run main.go 2Name: Sam 3Age: 31 4Salary 2000 در کد بالا ما یک ساختار با نام employee ایجاد کردیم و سپس ۲ متد با نام‌های details و getSalary برای آن تعریف کردیم. حال برای اینکه بتوانیم از این متدها استفاده کنیم داخل تابع main، یک متغیر از نوع employee تعریف کردیم و سپس با استفاده از نقطه . پس از نام متغیر به متدها دسترسی پیدا کردیم همانند دسترسی به فیلدهای ساختار.\nآیا با استفاده از متد می‌توانیم مقدار یکی از فیلدهای داخل ساختار را تغییر دهیم ؟ این سوال ۲ جواب دارد هم بله و هم خیر\nحال به مثال زیر توجه کنید تا توضیح دهیم:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type employee struct { 6 name string 7 age int 8 salary int 9} 10 11func (e employee) setNewName(newName string) { 12 e.name = newName 13} 14 15func main() { 16 emp := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} 17 emp.setNewName(\u0026#34;John\u0026#34;) 18 fmt.Printf(\u0026#34;Name: %s\\n\u0026#34;, emp.name) 19} 1$ go run main.go 2Name: Sam علت اینکه می‌گوییم خیر : به خاطر اینکه ما داریم با یک کپی از فیلدهای ساختار کار می‌کنیم و با تغییر مقدار هر یک از فیلدها تغییر بر روی کپی آن اعمال خواهد شد. اما علت اینکه می‌گوییم بله : اگر ما با استفاده از اشاره‌گر pointer به فیلدهای داخل ساختار دسترسی پیدا کنیم می‌توانیم مستقیماً به داخل خانه حافظه تایپ دسترسی داشته باشیم و مقدار فیلد مورد نظر را در هر جایی از پروژه تغییر دهیم. 2.3.2 استفاده از اشاره‌گر (pointer) در متدها # در مثال بالا ما به این اشاره کردیم که آیا می‌شود مقدار هر یک از فیلدهای ساختار را با استفاده از متد تغییر داد یا خیر و در پاسخ گفتیم بله و خیر و علت آره را توضیح دادیم. حال می‌خواهیم با یک مثال این مورد را توضیح دهیم. به مثال زیر توجه کنید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type employee struct { 6 name string 7 age int 8 salary int 9} 10 11func (e *employee) setNewName(newName string) { 12 e.name = newName 13} 14 15func main() { 16 emp := \u0026amp;employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} 17 emp.setNewName(\u0026#34;John\u0026#34;) 18 fmt.Printf(\u0026#34;Name: %s\\n\u0026#34;, emp.name) 19} 1$ go run main.go 2Name: John در مثال بالا متد setNewName یک نوع متد گیرنده از نوع اشاره‌گر است که ما داخل این متد به مقدار فیلدهای داخل خانه حافظه ساختار employee دسترسی داریم و می‌توانیم آن‌ها را مقدار دهی کنیم.\nآیا استفاده از گیرنده اشاره‌گر واقعا ضروری است؟ خیر، ضروری نیست زیرا ما وقتی به متدها دسترسی داریم که یک نمونه (instance) از تایپ مورد نظر ایجاد کنیم تا به متدهایش دسترسی داشته باشیم و همچنین اگر فرضاً نیاز داشته باشیم که یکی از فیلدهای ساختار را مقدار دهی کنیم، باز هم می‌توانیم به آدرس خانه متغیری که ساختار را نگه داری می‌کند اشاره کنیم و مقدارش را تغییر دهیم. به مثال زیر توجه کنید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type employee struct { 6 name string 7 age int 8 salary int 9} 10 11func (e *employee) setNewName(newName string) { 12 e.name = newName 13} 14 15func main() { 16 emp := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} 17 emp.setNewName(\u0026#34;John\u0026#34;) 18 19 fmt.Printf(\u0026#34;Name: %s\\n\u0026#34;, emp.name) 20 21 (\u0026amp;emp).setNewName(\u0026#34;Mike\u0026#34;) 22 fmt.Printf(\u0026#34;Name: %s\\n\u0026#34;, emp.name) 23} 1$ go run main.go 2Name: John 3Name: Mike 2.3.2.1 چه موقع باید از گیرنده اشاره‌گر برای متد استفاده کنیم؟ # زمانیکه قصد داریم متدهایی بنویسیم که برروی مقدار فیلدهای ساختار در زمان اجرا تغییراتی انجام میدهند. زمانیکه ساختار خیلی بزرگ است و فیلدهای زیادی دارد. در این سناریو بهتر است از گیرنده اشاره‌گر استفاده کنیم تا هر بار با یکی کپی از ساختار مواجه نشویم. 2.3.4 تعریف متد برای فیلدهای ساختار تو در تو (nested) # شما می‌توانید برای فیلدهایی که ساختار تو در تو دارند نیز متد بنویسید. به مثال زیر توجه کنید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type employee struct { 6\tname string 7\tage int 8\tsalary int 9\taddress address 10} 11 12type address struct { 13\tcity string 14\tcountry string 15} 16 17func (a address) details() { 18\tfmt.Printf(\u0026#34;City: %s\\n\u0026#34;, a.city) 19\tfmt.Printf(\u0026#34;Country: %s\\n\u0026#34;, a.country) 20} 21 22func main() { 23\taddress := address{city: \u0026#34;London\u0026#34;, country: \u0026#34;UK\u0026#34;} 24 25\temp := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000, address: address} 26 27\temp.address.details() 28} 1$ go run main.go 2City: London 3Country: UK در مثال بالا ما یک متد برای ساختار address تعریف کردیم و سپس ساختار address را داخل ساختار employee گذاشتیم. در نهایت شما با استفاده از employee می‌توانید به متدهای address هم دسترسی داشته باشید و از آن‌ها استفاده کنید.\n"},{"id":28,"href":"/chapter-2/interface/","title":"2.4 اینترفیس (Interface)","section":"فصل دوم: مکانیزم‌های زبان","content":"اینترفیس در زبان گو مجموعه‌ای از متدها است. این مجموعه متدها با توجه به ورودی و خروجی که دارند دارای رفتارهای خاصی هستند. زمانیکه شما یک اینترفیس به همراه یکسری از متدها تعریف می‌کنید باید در جایی این متدها را پیاده سازی کنید.\nاینترفیس‌ها به شما اجازه می‌دهد تا از Duck typing استفاده کنید. حالا این duck typing چیست؟\nduck typing روشی در برنامه‌نویسی کامپیوتری است که به شما امکان می‌دهد تست اردک را انجام دهید، جایی که ما نوع را بررسی نمی‌کنیم، بلکه تنها وجود برخی ویژگی‌ها یا روش‌ها را بررسی می‌کنیم. بنابراین آنچه واقعاً اهمیت دارد این است که آیا یک شی دارای ویژگی‌ها و روش‌های خاصی است و نه نوع آن.\nبرگردیم به بحث اینترفیس, در زیر ما یک نمونه اینترفیس را قرار دادیم:\n1type name_of_interface interface{ 2//Method signature 1 3//Method signature 2 4} برای درک بهتر مفهوم ارائه شده، بیایید از یک مثال ساده استفاده کنیم. فرض کنید ما یک شی به نام «animal» داریم که شامل یکسری رفتارها است، مانند نفس کشیدن و راه رفتن. این رفتارها باید به یک حیوان خاص اختصاص یابند تا بتوانیم ویژگی‌ها و رفتارهای دقیق آن حیوان را مشخص و تعریف کنیم.\n1type animal interface { 2 breathe() 3 walk() 4} در بالا ما یک اینترفیس تعریف کردیم ۲ تا متد دارد حالا بیاید یک متغیر از نوع اینترفیس animal درست کنیم و چاپ کنیم.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type animal interface { 6 breathe() 7 walk() 8} 9 10func main() { 11 var a animal 12 fmt.Println(a) 13} 1$ go run main.go 2nil در بالا وقتی اینترفیس را چاپ کردیم، خروجی nil بود. توجه کنید اینترفیس مقدار پیش‌فرض یا خالی بودنش nil هست.\n2.4.1 پیاده‌سازی اینترفیس # در بالا ما یک اینترفیس animal تعریف کردیم که ۲ متد داشت حالا قصد داریم یک شی (منظور ساختار در گو) به نام lion تعریف کنیم و متدهای اینترفیس animal را پیاده‌سازی کنیم.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type animal interface { 6 breathe() 7 walk() 8} 9 10type lion struct { 11 age int 12} 13 14func (l lion) breathe() { 15 fmt.Println(\u0026#34;Lion breathes\u0026#34;) 16} 17 18func (l lion) walk() { 19 fmt.Println(\u0026#34;Lion walk\u0026#34;) 20} 21 22func main() { 23 var a animal 24 a = lion{age: 10} 25 a.breathe() 26 a.walk() 27} 1$ go run main.go 2Lion breathes 3Lion walk در بالا ما یک متغیر با تایپ animal تعریف کردیم:\n1var a animal سپس ما یک نمونه از ساختار lion را بهش اختصاص دادیم:\n1a = lion{} اختصاص یک نمونه از ساختار lion به متغیر a که با تایپ lion بود موفقیت آمیز بود زیرا ما برای lion متدهای مربوط به animal را که breathe و walk بود، پیاده سازی کردیم. این مفهوم کاملاً شبیه به ducking typing هست که در بالا گفتیم. یک شیر می‌تواند نفس بکشد و راه برود از این رو او یک حیوان است.\nتوجه کنید اگر شما متد جدیدی را اضافه یا کم کنید و همچنین اگر تغییر ایجاد کنید باید این تغییرات بر روی اشیایی که با اینترفیس شما در ارتباط هستند صورت بگیرید.\nبه عنوان مثال شما اگر به اینترفیس animal یک متد جدیدی اضافه کنید حتما باید برای ساختار lion هم پیاده سازی کنید.\n2.4.2 اینترفیس‌ها بطور ضمنی (implicitly) پیاده سازی می‌شود # برای اینترفیس هیچ حالت صریح (explicit) هنگام تعریف وجود ندارد و همه چی بصورت ضمنی است تا زمانیکه یک اینترفیس برای یک شی (ساختار) متدهایش پیاده سازی نشود هیچ کاربردی نخواهد داشت.\nتوجه کنید هیچ حالت صریحی وجود ندارد که بگوید شما تمامی متدهای اینترفیس animal را برای ساختار lion پیاده سازی کردید یا خیر و فقط در زمان کامپایل اگر ایرادی وجود داشته باشد کامپایلر به شما خطا می‌دهد و البته IDE هایی مانند: Goland , Vscode به شما هنگام نوشتن کد در خصوص این مورد کمک می‌کنند قبل از کامپایل متوجه خطاهای مرتبط با پیاده سازی اینترفیس شوید.\nخب بزارید یک مثال پیچیده برای اینترفیس animal بزنیم و یک شی (ساختار) دیگر به نام dog اضافه کنیم و متدهای اینترفیس animal را برای این شی پیاده سازی کنیم.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type animal interface { 6 breathe() 7 walk() 8} 9 10type lion struct { 11 age int 12} 13 14func (l lion) breathe() { 15 fmt.Println(\u0026#34;Lion breathes\u0026#34;) 16} 17 18func (l lion) walk() { 19 fmt.Println(\u0026#34;Lion walk\u0026#34;) 20} 21 22type dog struct { 23 age int 24} 25 26func (l dog) breathe() { 27 fmt.Println(\u0026#34;Dog breathes\u0026#34;) 28} 29 30func (l dog) walk() { 31 fmt.Println(\u0026#34;Dog walk\u0026#34;) 32} 33 34func main() { 35 var a animal 36 37 a = lion{age: 10} 38 a.breathe() 39 a.walk() 40 41 a = dog{age: 5} 42 a.breathe() 43 a.walk() 44} 1$ go run main.go 2Lion breathes 3Lion walk 4Dog breathes 5Dog walk در مثال بالا ما یک ساختار با نام dog تعریف کردیم و سپس متدهای animal را برای ساختار dog پیاده سازی کردیم و در نهایت ساختار dog را به متغیر اینترفیس a اختصاص دادیم. همانطور که می‌بینیم dog هم همانند lion نفس می‌کشد و راه می‌رود.\nتوجه کنید در بالا ما برای ۲ تا شی lion و dog یک وجه مشترک به نام animal به همراه رفتار مشترک تعریف کردیم که به اینکار پلی مورفیسم می‌گویند و یکی از عناوین پر کاربرد در شی‌گرایی می باشد که در بخش شی گرایی زبان گو بیشتر می‌پردازیم. دو نکته مهم در خصوص اینترفیس‌:\nاینترفیس‌ها فقط زمان کامپایل مشخص می‌شود که برای اشیا به درستی پیاده سازی شده‌اند یا خیر و اگر فرضاً ما برای ساختار lion در کد بالا متد walk را حذف کنیم با خطای زیر رو به رو خواهیم شد: 1cannot use lion literal (type lion) as type animal in assignment: ورود و خروجی‌های هر متدی که پیاده سازی می‌کنید برای اشیا (ساختارها) بستگی به تعریف ضمنی متد داخل اینترفیس دارد و اگر شما متدی را داخل اینترفیس تغییر دهید حتما باید آن متد در اشیایی که قبلا پیاده سازی شده تغییر یابد. حالا فرض کنید ما برای اینترفیس animal یک متد جدیدی به نام speed تعریف کردیم که این متد به عنوان خروجی مقداری با تایپ int بر می‌گرداند:\n1type animal interface { 2 breathe() 3 walk() 4 speed() int 5} حالا ساختار lion باید متد speed را مانند کد زیر پیاده سازی کرده باشد :\n1func (l lion) speed() اگر دقت کنید ما داخل اینترفیس animal گفتیم متد speed یک مقدار خروجی از نوع int دارد ولی ما برای ساختار lion متد speed را بدون خروجی نوشتیم. اتفاقی که می‌افتد هنگام کامپایل با خطای زیر مواجه خواهیم شد :\n1cannot use lion literal (type lion) as type animal in assignment: 2 lion does not implement animal (wrong type for speed method) 3 have speed() 4 want speed() int با توجه به اتفاقی که افتاد ما نتیجه میگریم متدی که داخل اینترفیس به همراه ورودی و خروجی اضافه می‌شود باید به همان شکل برای ساختارهامون پیاده سازی کنیم.\n2.4.3 استفاده از اینترفیس به عنوان پارامتر ورودی تابع # توابع، تایپ‌های اینترفیس را به عنوان ورودی قبول می‌کنند و هر ساختار یا تایپی متدهای اینترفیس را پیاده سازی کرده باشد می‌تواند به عنوان پارامتر ورودی به تابع ارسال شود.\nبه عنوان مثال ما در کد زیر ۲ تا تابع داریم به نام های callBreathe و callWalk که به عنوان ورودی اینترفیس animal را قبول می‌کند و ما ۲ نمونه از ساختارهای lion و dog را که متدهای اینترفیس animal را پیاده سازی کرده‌اند را به این ۲ تابع پاس دادیم.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type animal interface { 6\tbreathe() 7\twalk() 8} 9 10type lion struct { 11 age int 12} 13 14func (l lion) breathe() { 15\tfmt.Println(\u0026#34;Lion breathes\u0026#34;) 16} 17 18func (l lion) walk() { 19\tfmt.Println(\u0026#34;Lion walk\u0026#34;) 20} 21 22type dog struct { 23 age int 24} 25 26func (l dog) breathe() { 27\tfmt.Println(\u0026#34;Dog breathes\u0026#34;) 28} 29 30func (l dog) walk() { 31\tfmt.Println(\u0026#34;Dog walk\u0026#34;) 32} 33 34func main() { 35\tl := lion{age: 10} 36\tcallBreathe(l) 37\tcallWalk(l) 38 39\td := dog{age: 5} 40\tcallBreathe(d) 41\tcallWalk(d) 42} 43 44func callBreathe(a animal) { 45\ta.breathe() 46} 47 48func callWalk(a animal) { 49\ta.breathe() 50} 1$ go run main.go 2Lion breathes 3Lion walk 4Dog breathes 5Dog walk 2.4.4 چرا اینترفیس؟ # شاید برای شما این سوال پیش بیاد چرا باید از اینترفیس استفاده کنیم و مزایای آن چیست؟ ما در زیر مزایای استفاده از اینترفیس و علت اینکه چرا باید از اینترفیس باید استفاده کنیم را توضیح خواهیم داد.\nاینترفیس به ما در نوشتن کدهای ماژولارتر و جدا شده‌‌تر بین بخش‌های مختلف کد کمک می‌کند و همچنین می‌تواند باعث کاهش وابستگی بین بخش‌های مختلف کد شود. بزارید یک مثال کاربردی بزنیم:\nفرض کنید شما یک برنامه نوشتید که یک لایه دیتابیس دارد و داده‌ها، با توجه به کانفیگ، در یکی از دو دیتابیس mongodb یا arangodb ذخیره ‌می‌شود. حالا اگر ما بیایم در لایه دیتابیس یک اینترفیس قرار دهیم و متدهای مربوط به تعاملات با دیتابیس را ایجاد کنیم، در برنامه‌ای که نوشتیم فقط کافیست متودهای ایترفیس استفاده شود تا با توجه به نوع کانفینگ دیتابیس، پیاده سازی متود اجرا شود. یعنی اگر ما بیایم داخل کانفیگ پروژه تنظیمات arangodb را به mongodb تغییر دهیم بدون هیچ تغییری در لایه برنامه می‌توانیم به واسطه اینترفیسی که قرار دادیم با دیتابیس mongodb تعامل داشته باشیم.\nاز اینترفیس‌ها می‌توان برای پیاده‌سازی مفهوم پلی مورفیسم در زمان اجرا استفاده کرد. که به این مفهوم RunTime Polymorphism می‌گویند. بزارید یک مثال برای توضیح فوق بزنیم:\nفرض کنید کشورهای مختلف روش‌های مختلفی برای محاسبه مالیات دارند که شما می‌توانید با استفاده از یک اینترفیس این عملیات محاسبه را انجام دهید.\n1type taxCalculator interface{ 2 calculateTax() 3} در بالا ما یک اینترفیس با نام taxCalculator داریم که یک متد به نام calculateTax برای محاسبه مالیات دارد. حالا ما باید به ازای هر کشور یک ساختار داشته باشیم که این ساختارها باید متد calculateTax را با توجه شیوه محاسباتی خود پیاده سازی کرده باشند.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type taxSystem interface { 6 calculateTax() int 7} 8type indianTax struct { 9 taxPercentage int 10 income int 11} 12func (i *indianTax) calculateTax() int { 13 tax := i.income * i.taxPercentage / 100 14 return tax 15} 16type singaporeTax struct { 17 taxPercentage int 18 income int 19} 20func (i *singaporeTax) calculateTax() int { 21 tax := i.income * i.taxPercentage / 100 22 return tax 23} 24type usaTax struct { 25 taxPercentage int 26 income int 27} 28func (i *usaTax) calculateTax() int { 29 tax := i.income * i.taxPercentage / 100 30 return tax 31} 32func main() { 33 indianTax := \u0026amp;indianTax{ 34 taxPercentage: 30, 35 income: 1000, 36 } 37 singaporeTax := \u0026amp;singaporeTax{ 38 taxPercentage: 10, 39 income: 2000, 40 } 41 42 43 taxSystems := []taxSystem{indianTax, singaporeTax} 44 totalTax := calculateTotalTax(taxSystems) 45 46 47 fmt.Printf(\u0026#34;Total Tax is %d\\n\u0026#34;, totalTax) 48} 49 50func calculateTotalTax(taxSystems []taxSystem) int { 51 totalTax := 0 52 for _, t := range taxSystems { 53 totalTax += t.calculateTax() // در اینجا runtime polymorphism رخ می دهد 54 } 55 return totalTax 56} 1$ go run main.go 2Total Tax is 300 در خط زیر RunTime Polymorphism رخ داده است.\n1 totalTax += t.calculateTax() //This is where runtime polymorphism happens 2.4.5 استفاده از اشاره‌گر هنگام پیاده‌سازی اینترفیس # متدها تایپ‌های گیرنده خود را به دو صورت اشاره‌گر یا مقدار می‌توانند دریافت کنند. در بالا مثال animal را داشتیم که با حالت گیرنده مقدار بود. حالا می‌خواهیم بصورت گیرنده اشاره‌گر تعریف کنیم.\n2 نکته با توجه مثالی که خواهیم زد وجود دارد:\nاگر شما برای یک تایپ تمامی متدهای اینترفیس را بصورت گیرنده مقدار تعریف کرده باشید، هر دو متغیری که یک نمونه از تایپ را بصورت اشاره‌گر و بدون اشاره‌گر تعریف کرده باشد، می‌تواند به اینترفیس animal انتصاب شود و بدون هیچ مشکلی کار کند.\nاگر شما برای یک تایپی تمامی متدهای اینترفیس را بصورت گیرنده اشاره‌گر تعریف کرده باشید فقط متغیری که یک نمونه از تایپ که با اشاره‌گر تعریف کرده باشد می‌تواند به اینترفیس انتصاب یابد.\nمثال با حالت اولی که توضیح دادیم:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type animal interface { 6\tbreathe() 7\twalk() 8} 9 10type lion struct { 11\tage int 12} 13 14func (l lion) breathe() { 15\tfmt.Println(\u0026#34;Lion breathes\u0026#34;, l) 16} 17 18func (l lion) walk() { 19\tfmt.Println(\u0026#34;Lion walk\u0026#34;, l) 20} 21 22func main() { 23\tvar a animal 24 25\ta = lion{age: 10} 26\ta.breathe() 27\ta.walk() 28 29\ta = \u0026amp;lion{age: 5} 30\ta.breathe() 31\ta.walk() 32} 1$ go run main.go 2Lion breathes {10} 3Lion walk {10} 4Lion breathes {5} 5Lion walk {5} در بالا ما یک نمونه از ساختار lion با اشاره‌گر ایجاد کردیم و مقدار age را ۵ قرار دادیم و به اینترفیس animal انتصابش کردیم و بدون هیچ مشکلی کار کرد.\nحالا برای حالت دوم به مثال زیر توجه کنید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type animal interface { 6\tbreathe() 7\twalk() 8} 9 10type lion struct { 11\tage int 12} 13 14func (l *lion) breathe() { 15\tfmt.Println(\u0026#34;Lion breathes\u0026#34;) 16} 17 18func (l *lion) walk() { 19\tfmt.Println(\u0026#34;Lion walk\u0026#34;) 20} 21 22func main() { 23\tvar a animal 24 25\ta = lion{age: 10} 26\ta.breathe() 27\ta.walk() 28 29\ta = \u0026amp;lion{age: 5} 30\ta.breathe() 31\ta.walk() 32} 1$ go run main.go 2cannot use lion literal (type lion) as type animal in assignment: 3 lion does not implement animal (breathe method has pointer receiver) در واقع شما فقط در صورت استفاده از اشاره‌گر، می‌توانید یک نمونه از ساختار lion بسازید در غیر این صورت با خطا مواجه خواهید شد.\n2.4.6 پیاده سازی اینترفیس برای تایپ‌های غیر ساختار # همانطور که قبلاً گفتیم شما می‌توانید برای هر تایپی متد تعریف کنید و در اینجا هم می‌توانید متدهای یک اینترفیس را برای هر تایپی پیاده سازی کنید.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type animal interface { 6\tbreathe() 7\twalk() 8} 9 10type cat string 11 12func (c cat) breathe() { 13\tfmt.Println(\u0026#34;Cat breathes\u0026#34;) 14} 15 16func (c cat) walk() { 17\tfmt.Println(\u0026#34;Cat walk\u0026#34;) 18} 19 20func main() { 21\tvar a animal 22 23\ta = cat(\u0026#34;smokey\u0026#34;) 24\ta.breathe() 25\ta.walk() 26} 1$ go run main.go 2Cat breathes 3Cat walk در بالا ما یک تایپ با نام cat از نوع رشته تعریف کردیم و سپس متدهای اینترفیس animal را برای این تایپ پیاده‌سازی کردیم.\n2.4.7 پیاده‌سازی چندتایی اینترفیس برای تایپ # شما می‌توانید برای تایپ‌های خود چندین اینترفیس مختلف استفاده کنید و متدهای این اینترفیس‌ها را پیاده سازی کنید.\nدر کد زیر ما ۲ تا اینترفیس animal و mammal داریم که داخل اینترفیس mammal یک متد با نام feed وجود دارد حالا می‌خواهیم برای ساختار lion از این اینترفیس استفاده کنیم.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type animal interface { 6 breathe() 7 walk() 8} 9 10type mammal interface { 11 feed() 12} 13 14type lion struct { 15 age int 16} 17func (l lion) breathe() { 18 fmt.Println(\u0026#34;Lion breathes\u0026#34;) 19} 20func (l lion) walk() { 21 fmt.Println(\u0026#34;Lion walk\u0026#34;) 22} 23func (l lion) feed() { 24 fmt.Println(\u0026#34;Lion feeds young\u0026#34;) 25} 26func main() { 27 var a animal 28 l := lion{} 29 a = l 30 a.breathe() 31 a.walk() 32 var m mammal 33 m = l 34 m.feed() 35} 1$ go run main.go 2Lion breathes 3Lion walk 4Lion feeds young 2.4.8 مقدار صفر یا پیش‌فرض اینترفیس # اینترفیس هم همانند سایر تایپ‌ها یک مقدار پیش‌فرض دارد که این مقدار پیش‌فرض nil هست.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4type animal interface { 5 breathe() 6 walk() 7} 8 9func main() { 10 var a animal 11 fmt.Println(a) 12} 1$ go run main.go 2nil 2.4.9 بدنه اینترفیس # اینترفیس دارای یک بدنه است که از دو بخش تشکیل شده تایپ و مقدار وقتی شما یک تایپی را به اینترفیس منتصب می‌کنید در بخش مقدار نوع و مقدار تایپی که منتصب کردید به اینترفیس در دسترس است.\ngraph TD A[Interface Variable] --\u003e B(Interface Type) \u0026 C(Interface Value) C --\u003e D(تایپ داخلی) \u0026 E(مقدار داخلی) اگر بخواهیم با توجه به مثال ساختار lion توجه کنیم به شکل زیر می‌شود:\ngraph TD A[Interface Variable] --\u003e B(Interface Type) \u0026 C(Interface Value) C --\u003e D(lion) \u0026 E(\"{age: 10}\") حالا در زیر مثالی زدیم با استفاده از T% و v% نوع و مقدار را می‌توانید چاپ کنیم.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type animal interface { 6 breathe() 7 walk() 8} 9 10type lion struct { 11 age int 12} 13 14func (l lion) breathe() { 15 fmt.Println(\u0026#34;Lion breathes\u0026#34;) 16} 17 18func (l lion) walk() { 19 fmt.Println(\u0026#34;Lion walk\u0026#34;) 20} 21 22func main() { 23 var a animal 24 a = lion{age: 10} 25 fmt.Printf(\u0026#34;Underlying Type: %T\\n\u0026#34;, a) 26 fmt.Printf(\u0026#34;Underlying Value: %v\\n\u0026#34;, a) 27} 1$ go run main.go 2Concrete Type: main.lion 3Concrete Value: {10} 2.4.10 دسترسی به مقادیر داخلی اینترفیس # برای اینکه بتوانید به مقادیر داخلی اینترفیس دسترسی پیدا کنید ۲ تا روش وجود دارد‌:\nبا استفاده از Type Assertion با استفاده از Switch 2.4.10.1 با استفاده از Type Assertion # برای اینکه بتوانید به مقدار داخلی یک اینترفیس دسترسی پیدا کنید باید جلوی متغیر از نوع اینترفیس یک نقطه . و در ادامه داخل پرانتز تایپ مورد نظری که قصد دارید تشخیص دهید را باید قرار دهید.\n1val, ok := i.({type}) در بالا زمانیکه Type Assertion انجام می‌دهید ۲ تا متغیر دارید که اولیش مقدار است و دومیش تایید می‌کند تایپی که به اینترفیس دادید همان است (منظور متغیر ok است که مقدار آن از نوع bool است)\nاگر هنگام Type Assertion شما وضعیت متغیر ok را بررسی نکنید با خطای panic مواجه خواهید شد. 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type animal interface { 6\tbreathe() 7\twalk() 8} 9 10type lion struct { 11\tage int 12} 13 14func (l lion) breathe() { 15\tfmt.Println(\u0026#34;Lion breathes\u0026#34;) 16} 17 18func (l lion) walk() { 19\tfmt.Println(\u0026#34;Lion walk\u0026#34;) 20} 21 22type dog struct { 23\tage int 24} 25 26func (d dog) breathe() { 27\tfmt.Println(\u0026#34;Dog breathes\u0026#34;) 28} 29 30func (d dog) walk() { 31\tfmt.Println(\u0026#34;Dog walk\u0026#34;) 32} 33 34func main() { 35\tvar a animal 36 37\ta = lion{age: 10} 38\tprint(a) 39 40} 41 42func print(a animal) { 43\tl, ok := a.(lion) 44\tif ok { 45\tfmt.Printf(\u0026#34;Age: %d\\n\u0026#34;, l.age) 46\t} 47} 1$ go run main.go 2Age: 10 در بالا ما تایپ lion را به اینترفیس animal پاس دادیم و بررسی کردیم آیا تایپ lion از نوع تایپ داخلی اینترفیس animal هست یا خیر.\n1l := a.(lion) 2.4.10.2 با استفاده از Switch # شما با استفاده از switch می‌توانید تایپ اینترفیس را تشخیص دهید.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type animal interface { 6\tbreathe() 7\twalk() 8} 9 10type lion struct { 11\tage int 12} 13 14func (l lion) breathe() { 15\tfmt.Println(\u0026#34;Lion breathes\u0026#34;) 16} 17 18func (l lion) walk() { 19\tfmt.Println(\u0026#34;Lion walk\u0026#34;) 20} 21 22type dog struct { 23\tage int 24} 25 26func (d dog) breathe() { 27\tfmt.Println(\u0026#34;Dog breathes\u0026#34;) 28} 29 30func (d dog) walk() { 31\tfmt.Println(\u0026#34;Dog walk\u0026#34;) 32} 33 34func main() { 35\tvar a animal 36 37\tx = lion{age: 10} 38\tprint(x) 39 40} 41 42func print(a animal) { 43\tswitch v := a.(type) { 44\tcase lion: 45\tfmt.Println(\u0026#34;Type: lion\u0026#34;) 46\tcase dog: 47\tfmt.Println(\u0026#34;Type: dog\u0026#34;) 48\tdefault: 49\tfmt.Printf(\u0026#34;Unknown Type %T\u0026#34;, v) 50\t} 51} 1$ go run main.go 2Type: lion 2.4.11 اینترفیس خالی # شما می‌توانید اینترفیس بصورت خالی و بدون متد در هرجایی از کد خود استفاده کنید و هر تایپی را می‌توانید به این اینترفیس انتصاب دهید. به عنوان مثال در زیر یک تابع نوشتیم که به عنوان پارامتر ورودی یک اینترفیس خالی می‌گیرد و مقدار این پارامتر را چاپ می‌کند.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 test(\u0026#34;thisisstring\u0026#34;) 7 test(\u0026#34;10\u0026#34;) 8 test(true) 9} 10 11func test(a interface{}) { 12 fmt.Printf(\u0026#34;(%v, %T)\\n\u0026#34;, a, a) 13} 1$ go run main.go 2(thisisstring, string) 3(10, string) 4(true, bool) توجه کنید اینترفیس خالی خیلی کاربردی هست و usecase‌های مختلفی دارد.\n"},{"id":29,"href":"/chapter-2/type-embedding/","title":"2.5 جاسازی تایپ (type embedding)","section":"فصل دوم: مکانیزم‌های زبان","content":"در زبان گو برای ساختار و اینترفیس امکان جاسازی تایپ وجود دارد. یعنی شما می‌توانید یک ساختار یا یک اینترفیس را داخل ساختار دیگر جاسازی کنید و یا داخل اینترفیس یک اینترفیس دیگر را جاسازی کنید.\n1 2type animal interface { 3 breathe() 4 walk() 5} 6 7type human interface { 8 animal 9 speak() 10} 11 12type base struct { 13 num int 14} 15 16type container struct { 17\thuman 18 base 19 str string 20} در بالا ما اینترفیس animal را در اینترفیس human جاسازی کردیم و در ادامه داخل ساختار container اینترفیس human و ساختار base را جاسازی کردیم.\nبا اینکار ما به متدهای اینترفیس human و animal و همچنین به فیلدهای ساختار base دسترسی داریم و می توانیم از متدها و فیلدهای جاسازی با استفاده از ساختار container استفاده کنیم.\nتوجه کنید شما نمی‌توانید یک ساختار را داخل اینترفیس جاسازی کنید. 2.5.1 جاسازی ساختار # شما می‌توانید هر چندتا ساختاری که دارید داخل یک ساختاری جاسازی و به هرکدام از فیلدهای ساختارهای جاسازی شده دسترسی دارید.\nبه مثال زیر توجه کنید :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type base struct { 6 num int 7} 8 9func (b base) describe() string { 10 return fmt.Sprintf(\u0026#34;base with num=%v\u0026#34;, b.num) 11} 12 13type container struct { 14 base 15 str string 16} 17 18func main() { 19 20 co := container{ 21 base: base{ 22 num: 1, 23 }, 24 str: \u0026#34;some name\u0026#34;, 25 } 26 27 fmt.Printf(\u0026#34;co={num: %v, str: %v}\\n\u0026#34;, co.num, co.str) 28 29 fmt.Println(\u0026#34;also num:\u0026#34;, co.base.num) 30 31 fmt.Println(\u0026#34;describe:\u0026#34;, co.describe()) 32 33 type describer interface { 34 describe() string 35 } 36 37 var d describer = co 38 fmt.Println(\u0026#34;describer:\u0026#34;, d.describe()) 39} 1$ go run main.go 2co={num: 1, str: some name} 3also num: 1 4describe: base with num=1 5describer: base with num=1 2.5.1.1 جاسازی اینترفیس در ساختار # همانطور که گفتیم یک اینترفیس می‌‌تواند داخل یک ساختار جاسازی شود و همه متدهای اینترفیس به واسطه ساختار مورد قابل دسترس است و می‌توانید هر یک از متدها را استفاده کنید.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type animal interface { 6 breathe() 7 walk() 8} 9 10type dog struct { 11 age int 12} 13 14func (d dog) breathe() { 15 fmt.Println(\u0026#34;Dog breathes\u0026#34;) 16} 17 18func (d dog) walk() { 19 fmt.Println(\u0026#34;Dog walk\u0026#34;) 20} 21 22type pet1 struct { 23 a animal 24 name string 25} 26 27type pet2 struct { 28 animal 29 name string 30} 31 32func main() { 33 d := dog{age: 5} 34 p1 := pet1{name: \u0026#34;Milo\u0026#34;, a: d} 35 36 fmt.Println(p1.name) 37 // p1.breathe() 38 // p1.walk() 39 p1.a.breathe() 40 p1.a.walk() 41 42 p2 := pet2{name: \u0026#34;Oscar\u0026#34;, animal: d} 43 fmt.Println(p1.name) 44 p2.breathe() 45 p2.walk() 46 p1.a.breathe() 47 p1.a.walk() 48} 1$ go run main.go 2Milo 3Dog breathes 4Dod walk 5 6Oscar 7Dog breathes 8Dog walk 9Dog breathes 10Dog walk 2.5.2 جاسازی اینترفیس # شما همانند ساختارها می‌توانید اینترفیس‌ها را جاسازی کنید و فقط کافیه اینترفیس‌ها را داخل دیگر اینترفیس‌ها جاسازی کنید تا متدهای اینترفیس‌های جاسازی شده دسترسی داشته باشید.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type animal interface { 6\tbreathe() 7\twalk() 8} 9 10type human interface { 11\tanimal 12\tspeak() 13} 14 15type employee struct { 16\tname string 17} 18 19func (e employee) breathe() { 20\tfmt.Println(\u0026#34;Employee breathes\u0026#34;) 21} 22 23func (e employee) walk() { 24\tfmt.Println(\u0026#34;Employee walk\u0026#34;) 25} 26 27func (e employee) speak() { 28\tfmt.Println(\u0026#34;Employee speaks\u0026#34;) 29} 30 31func main() { 32\tvar h human 33 34\th = employee{name: \u0026#34;John\u0026#34;} 35\th.breathe() 36\th.walk() 37\th.speak() 38} 1$ go run main.go 2Employee breathes 3Employee walk 4Employee speaks یکی دیگه از مثال‌هایی که می‌توانیم بزنیم پکیج io اینترفیس ReadWriter هست که ۲ تا اینترفیس Reader و Writer داخل این اینترفیس جاسازی شده است.\n"},{"id":30,"href":"/chapter-2/error-handling/","title":"2.6 مدیریت خطاها","section":"فصل دوم: مکانیزم‌های زبان","content":"در این بخش قصد داریم به مقوله مدیریت خطاها در زبان گو بپردازیم و اینکه چطور می‌توانید خیلی ساده خطاها را مدیریت کنید. مدیریت خطا در زبان گو با سایر زبان‌ها متفاوت هست و شما با چیزی به نام try-catch یا try-except سروکار ندارید.\nمدیریت خطاها در زبان گو به دو روش صورت می گیرد:\nبا استفاده از پیاده سازی اینترفیس error که یک روش مرسوم جهت مدیریت و نمایش خطا است. با استفاده از panic/recover که در فصل اول توضیح دادیم. 2.6.1 مدیریت خطا با اینترفیس error # روش زبان گو برای مقابله با خطا این است که به صراحت، شما خطا را به عنوان خروجی تابع برگردانید. برای این کار کافیست اگر میخواهید خطای هر تابع را مدیریت کنید، اینترفیس error را در خروجی تابع بگذارید.\nhttps://pkg.go.dev/builtin#error\n1type error interface { 2 Error() string 3} به مثال زیر توجه کنید:\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;os\u0026#34; 6) 7 8func main() { 9\tfile, err := os.Open(\u0026#34;non-existing.txt\u0026#34;) 10\tif err != nil { 11\tfmt.Println(err) 12\t} else { 13\tfmt.Println(file.Name() + \u0026#34;opened succesfully\u0026#34;) 14\t} 15} 1$ go run main.go 2open non-existing.txt: no such file or directory در کد بالا ما با استفاده از تابع Open که در پکیج os وجود دارد فایل non-existing.txt را باز کرده‌ایم. اگر دقت کنید این تابع ۲ تا خروجی دارد یکی ساختار File هست و دیگری خطا هست. در ادامه ما با استفاده شرط آمدیم چک کردیم اینترفیس err آیا خالی است یا خیر؟ در کد بالا این اینترفیس خالی nil نیست و ما خطا را چاپ کردیم.\nاین روش به طور گسترده در پکیج‌های داخلی و شخص ثالث گو استفاده می‌شود.\nدقت کنید اینترفیس error یک متد دارد به نام ()Error که این متد متن خطا را بصورت رشته بر می‌گرداند.\nآیا همیشه نیاز است خطاها را مدیریت کنیم؟\nشاید بپرسید آیا واقعا نیاز هست ما همیشه خطاها را مدیریت کنیم؟ در جواب این سوال می توانیم بگیم هم بله و هم خیر\nعلت اینکه می‌گوییم بله از این بابت هست اگر خطاها بدرستی مدیریت نشود احتمال اینکه با panic در هر جا مواجه شویم خیلی زیاد است. بخصوص خطای nil pointer . پس بهتر است تا جایی که می‌توانید خطاها را بدرستی مدیریت کنید و همچنین اگر جایی احتمال می‌دهید panic پیش میاد بهتر است از recover استفاده کنید تا پایداری برنامه را بالا ببرید. علت اینکه می‌گوییم خیر از این بابت هست که در زبان گو، هیچ اجباری برای مدیریت خطاها وجود ندارد و گاهی اوقات می‌توانید خطاها را نادیده بگیرید که با استفاده از ـ امکان پذیر است. 2.6.2 مزایای استفاده از error به عنوان یک تایپ در زبان گو # به شما این امکان را می‌دهد کنترل بیشتری رو خطاها داشته باشید و تو هر قدم می‌توانید خطاها را بررسی کنید. جلوگیری از try-catch جهت مدیریت خطا (دقت کنید در سایر زبان ها باید تا جایی که ممکن است از try-catch کمتر استفاده کنید) 2.6.3 روش‌های مختلف برای ایجاد یک خطا # در زبان گو شما می‌توانید در هرجای کد خود یک خطا با محتوای مناسب ایجاد کنید و یا اینکه برخی از خطاهای برخی از کتابخانه‌ها را هم‌پوشانی کنید.\n1. با استفاده (\u0026ldquo;متن خطا\u0026rdquo;)errors.New\n1package main 2 3import ( 4 \u0026#34;errors\u0026#34; 5 \u0026#34;fmt\u0026#34; 6) 7 8func main() { 9 sampleErr := errors.New(\u0026#34;error occured\u0026#34;) 10 fmt.Println(sampleErr) 11 } 1$ go run main.go 2error occured در بالا ما با استفاده از تابع New پکیج errors یک خطا با متن مشخص ایجاد کردیم و متغیر sampleErr از نوع اینترفیس error می‌باشد که می‌توانید در هر جای کد خود مدیریتش کنید.\n2. با استفاده از (\u0026ldquo;error is %s\u0026rdquo;, \u0026ldquo;some error message\u0026rdquo;)fmt.Errorf\nشما با استفاده از تابع Errorf در پکیج fmt می‌توانید یک خطا ایجاد کنید و توجه کنید این متن خطا قابل فرمت است و حتی شما می‌توانید متن خطا را داینامیک کنید.\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5) 6 7func main() { 8\tmsg := \u0026#34;database connection issue\u0026#34; 9 sampleErr := fmt.Errorf(\u0026#34;Err is: %s\u0026#34;, msg) 10 fmt.Println(sampleErr) 11} 1$ go run main.go 2Err is: database connection issue 2.6.4 ایجاد خطا پیشرفته # در مثال زیر ما قصد داریم یک خطای پیشرفته ایجاد کنیم و آن را به آسانی مدیریت کنیم.\nویژگی‌های خطای پیشرفته :\nدر زیر inputError یک نوع ساختار است که داخلش ۲ تا فیلد message و missingField دارد و همچنین دارای یک متد ()Error است. شما می‌توانید به این ساختار خطای پیشرفته، متدهای بیشتری اضافه کنید و همچنین گسترش دهید که به عنوان مثال ما متد getMissingFields را برای گرفتن محتوای missingField اضافه کردیم. ما با استفاده از type assertion می‌توانیم اینترفیس error را به inputError تبدیل کنیم. 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type inputError struct { 6 message string 7 missingField string 8} 9 10func (i *inputError) Error() string { 11 return i.message 12} 13 14func (i *inputError) getMissingField() string { 15 return i.missingField 16} 17 18func main() { 19 err := validate(\u0026#34;\u0026#34;, \u0026#34;\u0026#34;) 20 if err != nil { 21 if err, ok := err.(*inputError); ok { 22 fmt.Println(err) 23 fmt.Printf(\u0026#34;Missing Field is %s\\n\u0026#34;, err.getMissingField()) 24 } 25 } 26} 27 28func validate(name, gender string) error { 29 if name == \u0026#34;\u0026#34; { 30 return \u0026amp;inputError{message: \u0026#34;Name is mandatory\u0026#34;, missingField: \u0026#34;name\u0026#34;} 31 } 32 if gender == \u0026#34;\u0026#34; { 33 return \u0026amp;inputError{message: \u0026#34;Gender is mandatory\u0026#34;, missingField: \u0026#34;gender\u0026#34;} 34 } 35 return nil 36} 1$ go run main.go 2Name is mandatory 3Missing Field is name 2.6.5 نادیده گرفتن خطاها # شما در هرجای کد خود با استفاده از _ می توانید متغیر خطا را نادیده بگیرید و آن را مدیریت نکنید. هر چند در بالا گفتیم نادیده گرفتن خطاها عوارضی در بر دارد و ما همیشه، تاکید می‌کنیم تا جایی که ممکن است خطاها را مدیریت کنید.\n1package main 2import ( 3 \u0026#34;fmt\u0026#34; 4 \u0026#34;os\u0026#34; 5) 6func main() { 7 file, _ := os.Open(\u0026#34;non-existing.txt\u0026#34;) 8 fmt.Println(file) 9} 1$ go run main.go 2{nil} در بالا ما خطای تابع Open را نادیده گرفتیم و مقدار file را چاپ کردیم مقدار چاپ شده nil است چون تایپ خروجی با اشاره‌گر است و قطعا مقدار خالی بودش nil است.\n2.6.6 هم‌پوشانی (Wrapping) خطا # در زبان گو، شما می‌توانید خطا را با خطا و پیغام مشخصی هم پوشانی کنید. حالا هم‌پوشانی خطا چیست؟\nبزارید با یک مثال ساده توضیح دهیم، فرض کنید شما تو لایه دیتابیس خود یکسری خطاها از سمت دیتابیس دریافت می‌کنید به عنوان مثال اگر شما سندی را در دیتابیس monogdb پیدا نکنید با خطای no documents found مواجه خواهید شد. شما در اینجا نمی‌توانید همان متن خطا را به کاربر نمایش دهید بلکه باید آن خطا را با یک متن خطای مناسب هم پوشانی کنید.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7type notPositive struct { 8\tnum int 9} 10 11func (e notPositive) Error() string { 12\treturn fmt.Sprintf(\u0026#34;checkPositive: Given number %d is not a positive number\u0026#34;, e.num) 13} 14 15type notEven struct { 16\tnum int 17} 18 19func (e notEven) Error() string { 20\treturn fmt.Sprintf(\u0026#34;checkEven: Given number %d is not an even number\u0026#34;, e.num) 21} 22 23func checkPositive(num int) error { 24\tif num \u0026lt; 0 { 25\treturn notPositive{num: num} 26\t} 27\treturn nil 28} 29 30func checkEven(num int) error { 31\tif num%2 == 1 { 32\treturn notEven{num: num} 33\t} 34\treturn nil 35} 36 37func checkPostiveAndEven(num int) error { 38\tif num \u0026gt; 100 { 39\treturn fmt.Errorf(\u0026#34;checkPostiveAndEven: Number %d is greater than 100\u0026#34;, num) 40\t} 41 42\terr := checkPositive(num) 43\tif err != nil { 44\treturn err 45\t} 46 47\terr = checkEven(num) 48\tif err != nil { 49\treturn err 50\t} 51 52\treturn nil 53} 54 55func main() { 56\tnum := 3 57\terr := checkPostiveAndEven(num) 58\tif err != nil { 59\tfmt.Println(err) 60\t} else { 61\tfmt.Println(\u0026#34;Givennnumber is positive and even\u0026#34;) 62\t} 63 64} 1$ go run main.go 2checkEven: Given number 3 is not an even number 2.6.7 Unwrap خطاها # در بخش بالا شما با نحوه هم‌پوشانی کردن آشنا شدید، اما این امکان را داریم خطاها را unwrap کنیم با استفاده از یک تابع در پکیج errors به نام Unwrap.\n1func Unwrap(err error) error منظورمان از unwrap کردن این است که، اگر خطایی را هم پوشانی کرده باشیم با استفاده unwrap می‌توانیم آن خطا را ببینیم.\n1import ( 2 \u0026#34;errors\u0026#34; 3 \u0026#34;fmt\u0026#34; 4) 5type errorOne struct{} 6func (e errorOne) Error() string { 7 return \u0026#34;Error One happened\u0026#34; 8} 9func main() { 10 e1 := errorOne{} 11 e2 := fmt.Errorf(\u0026#34;E2: %w\u0026#34;, e1) 12 e3 := fmt.Errorf(\u0026#34;E3: %w\u0026#34;, e2) 13 fmt.Println(errors.Unwrap(e3)) 14 fmt.Println(errors.Unwrap(e2)) 15 fmt.Println(errors.Unwrap(e1)) 16} 1$ go run main.go 2E2: Error One happended 3Error One happended در کد بالا متغیر e2 خطای داخل ساختار e1 را هم‌پوشانی کرده و سپس متغیر e3 خطای متغیر e2 را هم‌پوشانی می‌کند. در نهایت با تابع Unwrap متن خطای اصلی را چاپ کردیم.\n2.6.8 بررسی دو خطا اگر برابر هستند # در زبان گو شما می‌توانید ۲ اینترفیس را با هم مقایسه کنید و این مقایسه به وسیله اپراتور == یا با استفاده از تابع Is در پکیج errors صورت می‌گیرد. اساساً دو مقوله برای این مقایسه در نظر گرفته خواهد شد:\n1func Is(err, target error) bool هر دو این اینترفیس‌ها به یک نوع تایپ منصوب شده باشند. مقدار داخلی اینترفیس‌ها باید با هم برابر باشند یا اینکه هر دو (nil) باشند. 1package main 2import ( 3 \u0026#34;errors\u0026#34; 4 \u0026#34;fmt\u0026#34; 5) 6type errorOne struct{} 7func (e errorOne) Error() string { 8 return \u0026#34;Error One happended\u0026#34; 9} 10func main() { 11 var err1 errorOne 12 err2 := do() 13 if err1 == err2 { 14 fmt.Println(\u0026#34;Equality Operator: Both errors are equal\u0026#34;) 15 } 16 if errors.Is(err1, err2) { 17 fmt.Println(\u0026#34;Is function: Both errors are equal\u0026#34;) 18 } 19} 20func do() error { 21 return errorOne{} 22} 1$ go run main.go 2Equality Operator: Both errors are equal 3Is function: Both errors are equal "},{"id":31,"href":"/chapter-2/casting-vs-conversion/","title":"2.7 فرق casting با conversion","section":"فصل دوم: مکانیزم‌های زبان","content":" 2.7.1 conversion # conversion زمانی اتفاق می‌افتد که ما مقدار یک داده را به تایپ دیگری اختصاص دهیم.\nو اگر زبان‌هایی که Static Type هستند از این مقوله بطور ضمنی پشتیبانی می‌کنند ولی در زبان گو کمی متفاوت است. اگر شما بخواهید conversion انجام دهید باید بصورت دستی اینکار را انجام دهید. چون کامپایلر گو روی برخی از عناوین بطور صریح در نظر می‌گیرد.\n2.7.2 type casting # در زبان گو، چیزی به نام type casting بطور کلی وجود ندارد. پس بهتر است در خصوص این مورد داخل داکیومنت‌ها یا سایت‌های مختلف نگردید. برای درک بهتر این موضوع بهتره https://go.dev/ref/spec#Conversions را مطالعه کنید.\n2.7.3 مثال conversion # در زیر یک مثال در خصوص conversion زدیم تا با این مقوله آشنا شوید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 7\tvar totalsum int = 846 8\tvar number int = 19 9\tvar avg float32 10 11\tavg = float32(totalsum) / float32(number) 12 13\tfmt.Printf(\u0026#34;Average = %f\\n\u0026#34;, avg) 14} 1$ go run main.go 2Average = 44.526318 "},{"id":32,"href":"/chapter-3/","title":"فصل سوم: همزمانی (concurrency)","section":"صفحه اصلی","content":"در این فصل به صورت عمیق به مباحث همزمانی در زبان گو پرداخته شده است که شامل عناوین زیر می‌باشد.\n۳.۱ آشنایی با مبحث همزمانی. ۳.۲ گوروتین چیست. ۳.۳ کالبدشکافی پکیج sync و تشریح انواع و توابع کاربردی آن برای مباحث همگام‌سازی همزمانی. ۳.۴ آشنایی با پکیج atomic و کاربردهای آن. ۳.۵ آشنایی با Data Race و روش‌های پیشگیری از آن. ۳.۶ کانال‌ها و روش‌ اشتراک‌گذاری داده از طریق آن. ۳.۷ آشنایی با کلید‌واژه select و بررسی کاربردهای متنوع آن. ۳.۸ پکیج context و اهمیت آن. ۳.۹ تکنیک‌های مورد استفاده در همزمانی. ۳.۱۰ الگوهای متداول همزمانی و کاربردهای آن. "},{"id":33,"href":"/chapter-3/go-concurrency/","title":"3.1 آشنایی با همزمانی","section":"فصل سوم: همزمانی (concurrency)","content":"\nنرم‌افزارهای بزرگ به منظور توسعه راحت‌تر و قابلیت نگهداری بیشتر و همچنین پرهیز از تکرار از ده‌ها زیر برنامه کوچک‌تر تشکیل می‌شوند که به آنها توابع می‌گوییم و تمامی این زیربرنامه‌های کوچک در کنار هم اما به صورت مستقل عملکرد کلی برنامه بزرگتر را شکل می‌دهند. به عنوان مثال یک وب سرور درخواست‌های ارسال شده از سمت مرورگرها را مدیریت می کند و در پاسخ صفحات وب HTML را آماده کرده و ارائه می‌دهد و هر در خواست از طریق فراخوانی چندین برنامه کوچک رسیدگی می شود تا نتیجه را به مرورگر برگردانده شود.\nدر طول آماده‌سازی نتیجه‌‌ی هر یک از این زیربرنامه‌ها، به دلایل گوناگون از جمله تاخیر(های) شبکه، IO و \u0026hellip; اجرای زیربرنامه‌ها برای مدتی هرچند کوتاه متوقف می‌شود و این وقفه‌ها، زمان پاسخگویی نرم‌افزارها را طولانی‌تر می‌کنند؛ گاهی‌اوقات اولویت ترتیب اجرا و وابستگی/استقلال زیربرنامه‌ها، به توسعه‌دهنده این اجازه را می‌دهد که اجرای بعضی از زیربرنامه‌ها را از حالت «صف/ترتیبی» به حالت «موازی» تغییر دهد، لذا به منظور استفاده بهینه‌ از منابع و افزایش عملکرد کلی نرم‌افزار از مقوله‌ای به نام همزمانی استفاده می کنند.\nیکی از نقاط قوت در زبان Go سهولت و امنیت استفاده از همزمانی با کمک گوروتین و کانال‌هاست که در ادامه‌ی این فصل به‌طور جامع، مباحث مربوط به آن را بررسی کرده و روش پیاده‌سازی همزمانی در برنامه‌های زبان Go را آموزش خواهیم داد.\n۳.۱.۱ فرق بین همزمانی (concurrency) و موازی (parallelism) # موازی‌سازی (parallelism) یعنی چندین فرآیند به‌طور همزمان توسط چند threads یا به طور دقیق‌تر هسته پردازشی انجام شود و این هسته‌ها می‌توانند از طریق حافظه اشتراکی با هم ارتباط برقرار کنند و در نهایت نتایج فرآیندها پس از پایان با هم ترکیب می‌شوند. لذا داشتن حداقل دو یا چند هسته پردازش فیزیکی از الزامات پیاده‌سازی موازی است.\nدر مقابل برنامه‌های همزمان الزاماً به‌صورت موازی اجرا نمی‌شوند و بیشتر در مورد ساختار یک برنامه است تا شیوه دقیق اجرای آن برنامه یا زیربرنامه. همزمانی به گونه‌ای است که دو یا چند کار مختلف ممکن است به طور همزمان در حال پیشرفت و انجام باشند. و در نهایت این فرآیندهای همزمان به نتایج مختلفی ختم می شوند.\nحال می‌خواهیم با یک مثال ملموس این دو مبحث را باز کنیم تا به درکی دقیق‌تر از تفاوت این‌ دو برسیم.\nتصور کنید که برنامه بزرگ ما یک کافی‌شاپ است که صفی از مشتریان سفارش خود را داده و منتظر دریافت آن می‌شوند.\nهمانطور که از تصویر بالا متوجه می‌شوید مشتری دوم تا پایان آماده‌سازی سفارش مشتری اول باید منتظر بماند لذا به منظور بالا بردن کارایی کلی سیستم می‌توان از پردازش موازی بهره برد به این منظور با استخدام یک فرد دیگر و یک دستگاه قهوه سازی دیگر پردازش مشتریان را به صورت موازی انجام خواهیم داد.\nچنانچه پیشتر هم گفته شد ما با محدودیت منابع روبرو هستیم و برای بالا بردن تعداد پردازش‌های موازی نیازمند خرید دستگاه قهوه ساز جدید و استخدام نیروی جدید هستیم. تا به اینجا هدف این بود که مشکل انتظار طولانی مدت مشتریان در صف را از طریق پردازش موازی حل کنیم اما این کار بسیار پرهزینه است راه حل دیگری هم وجود دارد که همان همزمانی است. بدیهی است وقفه ایجاد شده برای آماده‌سازی سفارش تنها محدود به دستگاه قهوه‌ساز نیست و بخشی از آن مربوط به زمان سپری شده برای دریافت سفارش از مشتریان توسط باریستا و مراجعه به دستگاه برای آماده‌سازی آن می‌شود لذا می‌توان با استخدام یک نیروی جدید بدون خرید دستگاه قهوه‌ساز جدید سفارش مشتریان را به صورت جداگانه پردازش کرده و به‌جای صف سفارش یک صف انتظار آماده‌سازی تشکیل داد به این ترتیب مدت زمان انتظار افراد برای دریافت سفارش کوتاه تر شده و عملکر کلی سیستم افزایش می‌یابد.\nالبته هیچ چیز ما را محدود به پردازش سریال در حالت همزمانی نمی‌کند یعنی در صورت تشکیل صف طولانی می توانیم عملکرد موازی را اینجا هم اعمال کنیم به تصویر پایین دقت کنید.\nهمانطور که مشاهده می‌شود در پردازش همزمان ما با تغییر ساختار به صورت موازی یا غیرموازی عملکرد کلی سیستم را افزایش داده‌ایم.\nنکته: تا به اینجا بارها برروی عملکرد کلی سیستم تأکید نموده‌ایم. این مسئله از آنجا حائز اهمیت است که خواننده باید به درکی درست از مقوله همزمانی برسد. ما در همزمانی سرعت پردازش یک درخواست را افزایش نمی‌دهیم در حقیقت به دلیل پیچیده‌تر شدن پیاده‌سازی و روند اجرا، زمان پردازش یک درخواست منحصر به فرد طولانی‌تر هم می‌شود اما آنچه در مبحث همزمانی بهبود می‌یابد عملکرد کلی سیستم است. لذا استفاده از همزمانی تنها در صورتی می‌تواند به بهبود کارایی یک سیستم نرم‌افزاری منجر شود که صفی از درخواست‌ها تشکیل شده باشد و تأخیرات مختلف مانع از پردازش بی‌درنگ درخواست‌ها در اکثر مواقع نشود لذا با استفاده از پیاده‌سازی همزمانی از منابع سیستم در زمان انتظار درخواست‌ها به صورت بهینه استفاده خواهد شد.\nدر زبان Go با استفاده از متغیرهای محیطی GOMAXPROCS در کنار همزمانی از موازی‌سازی (parallelism) هم استفاده می‌شود. هرچند بطور پیش فرض برنامه‌ای که با زبان گو نوشته می‌شود از تمامی هسته‌های CPU استفاده می‌کند ولی شما می‌توانید با GOMAXPROCS تعداد هسته‌ها را محدود کنید. لازم به ذکر است که در زبان Go شما به طور مستقیم نمی‌توانید اجرای موازی زیربرنامه‌ای را به کامپایلر دیکته کنید و تصمیم‌گیری در این مورد به عهده Go Runtime Scheduler است.\n"},{"id":34,"href":"/chapter-3/goroutine/","title":"3.2 گوروتین (goroutine)","section":"فصل سوم: همزمانی (concurrency)","content":"گوروتین ها را می توان به عنوان یک thread سبک در نظر گرفت که بصورت مستقل می توانند همزمان با سایر گوروتین های دیگر کارها را انجام دهند. و همچنین گوروتین ها می توانند به واسطه کانال داده ها را بین هم به اشتراک گذاشته و منتقل کنند.\nحداکثر اندازه stack یک گوروتین در زبان گو ۱ گیگابایت می باشد.\n1var maxstacksize uintptr = 1 \u0026lt;\u0026lt; 20 // enough until runtime.main sets it for real 2 3\tif newsize \u0026gt; maxstacksize || newsize \u0026gt; maxstackceiling { 4\tif maxstacksize \u0026lt; maxstackceiling { 5\tprint(\u0026#34;runtime: goroutine stack exceeds \u0026#34;, maxstacksize, \u0026#34;-byte limit\\n\u0026#34;) 6\t} else { 7\tprint(\u0026#34;runtime: goroutine stack exceeds \u0026#34;, maxstackceiling, \u0026#34;-byte limit\\n\u0026#34;) 8\t} 9\tprint(\u0026#34;runtime: sp=\u0026#34;, hex(sp), \u0026#34; stack=[\u0026#34;, hex(gp.stack.lo), \u0026#34;, \u0026#34;, hex(gp.stack.hi), \u0026#34;]\\n\u0026#34;) 10\tthrow(\u0026#34;stack overflow\u0026#34;) 11\t} در زیر با استفاده از کلمه کلیدی go یک نمونه گوروتین ایجاد کردیم و توجه کنید شما فقط توابع را می توانید به صورت همزمان اجرا کنید.\n1go functionName(parameters) به عنوان مثال :\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;time\u0026#34; 6) 7 8func main() { 9 go start() 10 fmt.Println(\u0026#34;Started\u0026#34;) 11 time.Sleep(1 * time.Second) 12 fmt.Println(\u0026#34;Finished\u0026#34;) 13} 14 15func start() { 16 fmt.Println(\u0026#34;In Goroutine\u0026#34;) 17} 1$ go run main.go 2Started 3In Goroutine 4Finished در کد فوق ما تابع ()start را توسط کلمه کلیدی go داخل گوروتین قرار دادیم و این تابع بصورت مستقل از تابع main اجرا شد. اما این وسط یک نکته ای وجود دارد. همانطور که گفتیم تابع اصلی جهت اجرا برنامه های زبان گو تابع main می باشد و اگر شما تابعی را توسط گوروتین از main جدا کنید ممکن است فرآیندهای داخل تابع main زود اتمام شود و شما خروجی تابعی که داخل گوروتین گذاشتید را نبینید.\nما در کد بالا با استفاده از تابع Sleep پکیج time یک وقفه ۱ ثانیه گذاشتیم و این وقفه باعث شد تا عملیات داخل تابع ()start تمام شود و خروجی نمایش داده شود.\nخب حالا بزارید مثال فوق را بدون وقفه تست کنیم :\n1package main 2import ( 3 \u0026#34;fmt\u0026#34; 4) 5func main() { 6 go start() 7 fmt.Println(\u0026#34;Started\u0026#34;) 8 fmt.Println(\u0026#34;Finished\u0026#34;) 9} 10func start() { 11 fmt.Println(\u0026#34;In Goroutine\u0026#34;) 12} 1$ go run main.go 2Started 3Finished در خروجی بالا هرگز پیغام داخل تابع ()start چاپ نمی شود.\n1In Goroutine علت اصلی این اتفاق این است که تابع main خودش داخل یک گوروتین اجرا می شود و زمانیکه شما یک تابع دیگری را داخل گوروتین قرار می دهید تا لحظه ای که تابع برای اجرا برنامه ریزی شود برنامه اتمام می شود.\n3.2.1 گوروتین تابع main # تابع main را وقتی می توانید ایجاد کنید که نام پکیج شما main و گوروتین اصلی شما main باشد. همه گوروتین ها از تابع main شروع می شوند و گوروتین ها بطور همزمان باز می توانند سایر گوروتین ها را اجرا کنند.\nزمانیکه شما تابع main را فراخوانی می کنید بخش اصلی و شروع برنامه شما است. و اگر تابع main شما به هر دلیلی متوقف شود یا اتمام شود سایر گوروتین ها از بین می روند.\nگوروتین ها چیزی به نام parent یا child ندارند. زمانیکه شما یک گوروتین را اجرا می کنید این گوروتین در کنار سایر گوروتین ها اجرا می شود و کارش را انجام می دهد. زمانی کار یک گوروتین تمام می شود که تابع بازگشت (return) داشته باشد.\nبزارید یک مثال بزنیم تا ببینید چیزی به نام parent یا child برای گوروتین نداریم :\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;time\u0026#34; 6) 7 8func main() { 9 go start() 10 fmt.Println(\u0026#34;Started\u0026#34;) 11 time.Sleep(1 * time.Second) 12 fmt.Println(\u0026#34;Finished\u0026#34;) 13} 14 15func start() { 16 go start2() 17 fmt.Println(\u0026#34;In Goroutine\u0026#34;) 18} 19func start2() { 20 fmt.Println(\u0026#34;In Goroutine2\u0026#34;) 21} 1$ go run main.go 2Started 3In Goroutine 4In Goroutine2 5Finished در کد بالا داخل تابع main ما تابع start را با گوروتین اجرا کردیم و داخل تابع start تابع start2 را با گوروتین اجرا کردیم. این ۲ تابع start و start2 در کنار هم اجرا می شود و در نهایت کارشان اتمام می شود و هیچ کدام منتظر دیگری نخواهد بود.\n3.2.2 ایجاد گوروتین چندتایی # شما می توانید n تا گوروتین بطور همزمان در کنار هم اجرا کنید, در زیر یک مثال زدیم ببینید :\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;time\u0026#34; 6) 7 8func execute(id int) { 9 fmt.Printf(\u0026#34;id: %d\\n\u0026#34;, id) 10} 11 12func main() { 13 fmt.Println(\u0026#34;Started\u0026#34;) 14 for i := 0; i \u0026lt; 10; i++ { 15 go execute(i) 16 } 17 time.Sleep(time.Second * 2) 18 fmt.Println(\u0026#34;Finished\u0026#34;) 19} 1$ go run main.go 2Started 3id: 4 4id: 9 5id: 1 6id: 0 7id: 8 8id: 2 9id: 6 10id: 3 11id: 7 12id: 5 13Finished در کد فوق ما یک حلقه قرار دادیم از i برابر ۰ تا ۱۰ که داخلش تابع execute را ۱۰ بار اجرا می کند. و هربار اجرا می شود خروجی های مختلفی دارد و ترتیبی درست نخواهید علت این اتفاق این است بطور همزمان اجرا می شوند در کنار هم و هرکدام از گوروتین ها زودتر کارش تمام شود خروجی را نمایش می دهد. به همین دلیل ترتیب درستی نخواهد داشت.\n3.2.3 زمانبندی گوروتین ها # زمانیکه یک برنامه گو اجرا می شود. go runtime رشته های (threads) سیستم عامل را راه اندازی می کند که معادل تعداد CPU های logical قابل استفاده برای فرآیند فعلی است. هر یک از logical CPU ها یک هسته مجازی دارد.\n1virtual_cores = x*number_of_physical_cores در کد بالا x برابر است با تعداد thread ها به ازای هر هسته از CPU\nدر گو ما یک تابع به نام NumCPU داخل پکیج runtime داریم که می توانید تعداد logical Proccessors موجود برای برنامه گو را ببینید.\n1package main 2import ( 3 \u0026#34;fmt\u0026#34; 4 \u0026#34;runtime\u0026#34; 5) 6func main() { 7 fmt.Println(runtime.NumCPU()) 8} روی سیستم من عدد 8 را چاپ کرد یعنی سیستم من ۴ هسته که هر هسته دارای ۲ threads است. که قابل استفاده برای برنامه گو روی سیستم من می باشد.\n"},{"id":35,"href":"/chapter-3/go-sync-package/","title":"3.3 پکیج sync","section":"فصل سوم: همزمانی (concurrency)","content":"پکیج sync یکی از کاربردی ترین پکیج ها در زمینه همزمانی می باشد و یکسری تایپ و توابع برایهمگام سازی و کنترل دسترسی همزمان به داده های مشترک ارائه می دهد. پرکاربرد ترین ویژگی های این پکیج شامل موارد زیر می شود :\nMutex : با استفاده از این تایپ می توانید آن بخش از داده ای که گوروتین ها بطور همزمان قصد دارند دسترسی داشته باشند را می توانید قفل کنید. RWMutex : با استفاده از این تایپ می توانید به چندین گوروتین اجازه خواندن دهید اما فقط یک گوروتین قابلیت نوشتن در یک زمان مشخص را دارد. WaitGroup: یک هماهنگ کننده گوروتین می باشد، برای اینکه ترتیب عملیات ها در هنگام همزمانی رعایت شود. Once: این تایپ اجازه می دهد یک تابع حداکثر یک بار اجرا شود. Pool: مجموعه‌ای از آبجکت های موقت که امکان ذخیره و دریافت دارند بدون اینکه بخشی از حافظه را اشتغال کنند. Cond:با استفاده از Cond می توانید چندین گوروتین ایجاد کنید و اجرای فرآیند آن ها را منتظر وقوع یک رویداد قرار دهید. توجه کنید که پکیج sync فقط و فقط برای مدیریت و همگام سازی دسترسی های گوروتین ها به یک داده مشترک استفاده می شود. 3.3.1 Mutex # در پکیج sync یک تایپ به نام Mutex وجود دارد که به شما این امکان را می دهد دسترسی به داده های مشترک را همگام سازی کنید. با استفاده از این قابلیت در واقع منابع مشترک را محافظت شده و این اطمینان به شما داده می شود که تنها یک گوروتین در یک زمان مشخص، به دیتای مشترک بین گوروتین ها دسترسی دارد. تایپ Mutex شامل دو متد مهم Lock یا Unlock است. وقتی Lock فراخوانی می شود فقط و فقط یک گوروتین می تواند برروی آن بخش از داده کار کند و تا زمانیکه شما Unlock نکنید سایر گوروتین ها نمی توانند به دیتای مورد نظر شما دسترسی داشته باشند و تا زمانیکه Unlock صورت گیرد سایر گوروتین هادر حالت انتظار باقی می مانند.\nبه مثال زیر توجه کنید :\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;sync\u0026#34; 6\t\u0026#34;time\u0026#34; 7) 8 9var count int 10 11func main() { 12\tmu := new(sync.Mutex) 13\t14\tgo increment(mu) 15\tgo increment(mu) 16\tgo increment(mu) 17\tgo increment(mu) 18 19\ttime.Sleep(time.Second) 20} 21 22func increment(mu *sync.Mutex) { 23\tmu.Lock() 24\tdefer mu.Unlock() 25\tcount++ 26\tfmt.Printf(\u0026#34;Incrementing: %d\\n\u0026#34;, count) 27} 1$ go run main.go 2 3Incrementing: 1 4Incrementing: 2 5Incrementing: 3 6Incrementing: 4 در بالا ما یک تابع به نام increment ایجاد کردیم و به عنوان ورودی تایپ Mutex را بصورت پوینتر پاس دادیم. سپس با استفاده از توابع Lock و Unlock برای افزایش مقدار count یک قفل گذاشتیم.\nحال ۴ تا گوروتین داریم که قصد دارند همزمان روی بخش مشترک از حافظه عملیاتی را انجام دهند در اینجا ما با استفاده Mutex جلوی دسترسی همزمان گوروتین ها به حافظه را گرفتیم و فقط یک گوروتین می تواند عملیات انجام دهد و تا زمانیکه شما Unlock نکنید سایر گوروتین ها منتظر می مانند.\n3.3.1.1 سناریوهای استفاده # همگام سازی دسترسی به متغیرهای مشترک: یک mutex می تواند برای همگام سازی دسترسی به متغیرهای مشترک بین چندین گوروتین استفاده شود. این می تواند در مواردی مفید باشد که چندین گوروتین نیاز به خواندن یا به روز رسانی یک متغیر به طور همزمان دارند.\nهماهنگی دسترسی به حالت مشترک: یک mutex می تواند برای هماهنگ کردن دسترسی به حالت مشترک بین چندین گوروتین استفاده شود. به عنوان مثال، ممکن است از یک mutex استفاده کنید تا اطمینان حاصل کنید که فقط یک گوروتین می تواند یک ساختار داده مشترک را در یک زمان تغییر دهد.\nپیاده سازی الگوهای تولیدکننده-مصرف کننده (producer-consumer): یک mutex می تواند برای پیاده سازی الگوهای تولیدکننده-مصرف کننده استفاده شود، که در آن یک یا چند گوروتین داده تولید می کنند و یک یا چند گوروتین آن را مصرف می کنند. mutex می تواند برای همگام سازی دسترسی به ساختار داده مشترک که داده ها را نگه می دارد استفاده شود.\n۲ نکته خیلی مهم\nسعی کنید پس از اینکه تابع Lock را فراخوانی میکنید تابع Unlock را داخل defer قرار دهید. زمانیکه قصد دارید Mutex را به عنوان پارامتر ورودی برای توابع تعریف کنید بهتر است از نوع اشاره گر باشد. 3.3.2 RWMutex # در پکیج sync یک تایپ به نام RWMutex وجود دارد که عملیات خواندن و نوشتن برروی یک داده مشترک را همگام سازی می کند. شما می توانید به چندین گوروتین اجازه خواندن یک داده مشترک را بدهید ولی فقط یک گوروتین می تواند عملیات نوشتن را برروی آن داده مشترک را انجام دهد.\nدر زیر یک مثال قرار دادیم توجه کنید :\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;math/rand\u0026#34; 6\t\u0026#34;strings\u0026#34; 7\t\u0026#34;sync\u0026#34; 8\t\u0026#34;time\u0026#34; 9) 10 11func init() { 12\trand.Seed(time.Now().Unix()) 13} 14func sleep() { 15\ttime.Sleep(time.Duration(rand.Intn(1000))*time.Millisecond) 16} 17func reader(c chan int, m *sync.RWMutex, wg *sync.WaitGroup) { 18\tsleep() 19\tm.RLock() 20\tc \u0026lt;- 1 21\tsleep() 22\tc \u0026lt;- -1 23\tm.RUnlock() 24\twg.Done() 25} 26func writer(c chan int, m *sync.RWMutex, wg *sync.WaitGroup) { 27\tsleep() 28\tm.Lock() 29\tc \u0026lt;- 1 30\tsleep() 31\tc \u0026lt;- -1 32\tm.Unlock() 33\twg.Done() 34} 35func main() { 36\tvar m sync.RWMutex 37\tvar rs, ws int 38\trsCh := make(chan int) 39\twsCh := make(chan int) 40\tgo func() { 41\tfor { 42\tselect { 43\tcase n := \u0026lt;-rsCh: 44\trs += n 45\tcase n := \u0026lt;-wsCh: 46\tws += n 47\t} 48\tfmt.Printf(\u0026#34;%s%s\\n\u0026#34;, strings.Repeat(\u0026#34;R\u0026#34;, rs), 49\tstrings.Repeat(\u0026#34;W\u0026#34;, ws)) 50\t} 51\t}() 52\twg := sync.WaitGroup{} 53\tfor i := 0; i \u0026lt; 10; i++ { 54\twg.Add(1) 55\tgo reader(rsCh, \u0026amp;m, \u0026amp;wg) 56\t} 57\tfor i := 0; i \u0026lt; 3; i++ { 58\twg.Add(1) 59\tgo writer(wsCh, \u0026amp;m, \u0026amp;wg) 60\t} 61\twg.Wait() 62} 1$ go run main.go 2R 3RR 4R 5RR 6R 7W 8R 9RR 10RRR 11RRRR 12RRRRR 13RRRRRR 14RRRRRRR 15RRRRRR 16RRRRR 17RRRR 18RRR 19RR 20R 21W 22W 3.3.3 WaitGroup # یک ساختاری داخل پکیج sync به نام WaitGroup وجود دارد. معمولا برای منتظر ماندن برای پایان اجرای گروهی از گوروتین ها استفاده می شود. این ساختار ۳ متد دارد که به شرح زیر می باشد:\nAdd: این متد که به عنوان ورودی عدد می گیرد تعداد گوروتین هایی که قرار است منتظر بمانند را تعیین میکند. Done: این تابع زمانی استفاده می شود فرآیند داخل هریک از گوروتین ها اتمام شود. Wait: این متد گوروتین ها را بلاک می کند تا زمانیکه سیگنال Done از تمامی گوروتین ها دریافت کند. بگذارید با یک مثال توضیح دهیم:\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;sync\u0026#34; 6 \u0026#34;time\u0026#34; 7) 8 9func main() { 10 var wg sync.WaitGroup 11 wg.Add(2) 12 go sleep(\u0026amp;wg, time.Second*1) 13 go sleep(\u0026amp;wg, time.Second*2) 14 wg.Wait() 15 fmt.Println(\u0026#34;All goroutines finished\u0026#34;) 16} 17 18func sleep(wg *sync.WaitGroup, t time.Duration) { 19 defer wg.Done() 20 time.Sleep(t) 21 fmt.Println(\u0026#34;Finished Execution\u0026#34;) 22} 1$ go run main.go 2Finished Execution 3Finished Execution 4All goroutines finished در بالا ما یک متغیر از ساختار WaitGroup ایجاد کردیم و پس از ایجاد متد Add را فراخوانی کردیم و تعداد گوروتین هایی که قرار است منتظر بماند را مشخص کردیم. سپس آدرس حافظه متغیر wg را به تابع sleep به عنوان ورودی پاس دادیم و در نهایت داخل تابع sleep با استفاده از defer متد Done را فراخوانی کردیم.\nزمانیکه عملیات تابع sleep اتمام می شود متد Done فراخوانی می شود و یک گوروتین از لیست گوروتین های آبجکت WaitGroup کم می شود.\n1// Done decrements the WaitGroup counter by one. 2func (wg *WaitGroup) Done() { 3 wg.Add(-1) 4} حال وقتی فرآیند ۲ تا گوروتین اتمام شود اون بخش از کد از حالت بلاک بودن خارج می شود.\n۳ نکته خیلی مهم\nساختار WaitGroup یکی از پرکاربرد ترین قابلیت ها برای بحث همزمانی می باشد و برخی اوقات برای جلوگیری از Data race و همچنین برای ترتیب دهی عملیات همزمانی هم می توان از این استفاده کرد. سعی کنید WaitGroup را بصورت اشاره گر به توابعی که داخل گوروتین قرار دارند پاس دهید. هیچوقت تعداد گوروتین را بیشتر یا کمتر از اون تعدادی که دارید به متد Add ‌ندهید چون با خطای Panic مواجه خواهید شد. 3.3.4 Once # در پکیج sync ما یک تایپ داریم به نام Once که برای اطمینان از اینکه یک تابع فقط یکبار فراخوانی می شود استفاده می شود. شما فرض کنید قصد دارید در طول برنامه از یک آبجکت فقط یک instance داشته باشید می توانید با استفاده از Once این کار را انجام دهید (شما با استفاده از Once می توانید الگو طراحی Singleton را پیاده سازی کنید.)\nبه مثال زیر توجه کنید:\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;sync\u0026#34; 6) 7 8type singleton struct { 9\tdata string 10} 11 12var instance *singleton 13var once sync.Once 14 15func GetInstance() *singleton { 16\tonce.Do(func() { 17\tinstance = \u0026amp;singleton{data: \u0026#34;some data\u0026#34;} 18\t}) 19\treturn instance 20} 21 22func main() { 23\ts1 := GetInstance() 24\ts2 := GetInstance() 25\tif s1 == s2 { 26\tfmt.Println(\u0026#34;Same instance\u0026#34;) 27\t} else { 28\tfmt.Println(\u0026#34;Different instances\u0026#34;) 29\t} 30} 1$ go run main.go 2Same instance در مثال فوق ما یک تابع داریم به نام GetInstance که به عنوان خروجی ساختار singleton را بصورت اشاره گر ارائه می دهد. قبل از تابع ۲ تا متغیر تعریف کردیم به نام once و instance که داخل تابع GetInstance از متد Do متغیر once یک تابع inline را قرار دادیم که فقط یک آبجکت از ساختار singleton می سازد و داخل متغیر instance قرار می دهد. در نهایت instance بازگشت داده می شود.\n3.3.5 Pool # در نسخه ۱.۳ زبان گو امکانی تایپی به نام Pool در پکیج sync که امکان ایجاد استخر آبجکت ها بطور موقت بدون اینکه بخواهد بخشی از حافظه را اشتغال کند اضافه شد. هر آبجکتی که در Pool ذخیره شود بطور خودکار در هرزمانی بدون اینکه اطلاع رسانی کند حذف می شود. امکان استفاده مجدد از آبجکت هایی که داخل استخر می گیرند وجود دارد و این باعث می شود سربار استفاده حافظه کاهش یابد.\n1package main 2 3import ( 4\t\u0026#34;bytes\u0026#34; 5\t\u0026#34;io\u0026#34; 6\t\u0026#34;os\u0026#34; 7\t\u0026#34;sync\u0026#34; 8\t\u0026#34;time\u0026#34; 9) 10 11var bufPool = sync.Pool{ 12\tNew: func() any { 13\t// The Pool\u0026#39;s New function should generally only return pointer 14\t// types, since a pointer can be put into the return interface 15\t// value without an allocation: 16\treturn new(bytes.Buffer) 17\t}, 18} 19 20// timeNow is a fake version of time.Now for tests. 21func timeNow() time.Time { 22\treturn time.Unix(1136214245, 0) 23} 24 25func Log(w io.Writer, key, val string) { 26\tb := bufPool.Get().(*bytes.Buffer) 27\tb.Reset() 28\t// Replace this with time.Now() in a real logger. 29\tb.WriteString(timeNow().UTC().Format(time.RFC3339)) 30\tb.WriteByte(\u0026#39; \u0026#39;) 31\tb.WriteString(key) 32\tb.WriteByte(\u0026#39;=\u0026#39;) 33\tb.WriteString(val) 34\tw.Write(b.Bytes()) 35\tbufPool.Put(b) 36} 37 38func main() { 39\tLog(os.Stdout, \u0026#34;path\u0026#34;, \u0026#34;/search?q=flowers\u0026#34;) 40} 1$ go run main.go 22006-01-02T15:04:05Z path=/search?q=flowers در بالا ما یک متغیر به نام bufPool ایجاد کردیم که یک آبجکت از نوع bytes.Buffer ایجاد می کند. سپس داخل تابع Log ما با استفاده از متد Get آبجکت مورد نظر را از Pool خارج و داخل متغیر b قرار دادیم و پس از آن عملیات لازم را برروی Buffer انجام و در نهایت با استفاده از متد Put آبجکت را به Pool اضافه کردیم. حالا اتفاقی که صورت گرفته ما عملیاتی که نیاز داشتیم را برروی آبجکت انجام دادیم بدون اینکه بخوایم بخشی از حافظه را درگیر کنیم.\n3.3.5.1 بنچمارک در خصوص Pool # 1package main 2 3import ( 4 \u0026#34;sync\u0026#34; 5 \u0026#34;testing\u0026#34;) 6 7type Person struct { 8 Age int 9} 10 11var personPool = sync.Pool{ 12 New: func() interface{} { return new(Person) }, 13} 14 15func BenchmarkWithoutPool(b *testing.B) { 16 var p *Person 17 b.ReportAllocs() 18 b.ResetTimer() 19 for i := 0; i \u0026lt; b.N; i++ { 20 for j := 0; j \u0026lt; 10000; j++ { 21 p = new(Person) 22 p.Age = 23 23 } 24 } 25} 26 27func BenchmarkWithPool(b *testing.B) { 28 var p *Person 29 b.ReportAllocs() 30 b.ResetTimer() 31 for i := 0; i \u0026lt; b.N; i++ { 32 for j := 0; j \u0026lt; 10000; j++ { 33 p = personPool.Get().(*Person) 34 p.Age = 23 35 personPool.Put(p) 36 } 37 } 38} 1$ go test -bench=. -benchmem 2 3goos: linux 4goarch: amd64 5pkg: pool 6cpu: Intel(R) Core(TM) i5-3570 CPU @ 3.40GHz 7BenchmarkWithoutPool-4 5262 213177 ns/op 80000 B/op 10000 allocs/op 8BenchmarkWithPool-4 7699 152788 ns/op 0 B/op 0 allocs/op 9PASS 10ok pool 2.343s 3.3.5.2 مثال های کاربردی # مثال اول :\nفرض کنید شما می خواهید یک فایل csv را با کلی رکورد parse کنید. هر رکورد نیازمند این است که داخل یک ساختاری قرار بگیرد و ایجاد یک ساختار باعث می شود بخشی از حافظه اختصاص یابد به آن ساختار. حالا فکر کنید میلیون ها رکورد داشته باشید و این تخصیص حافظه می تواند باعث توقف برنامه شود.\nحالا برای اینکه بخواهیم جلوی این اتفاق را بگیریم و سربار را کاهش دهیم بهتر است ما از sync.Pool استفاده کنیم و ساختارها را داخل استخر قرار دهیم. و زمانیکه هرکدام از ساختارها مورد نیاز نباشد می توانند داخل استخر قرار گیرند و مجدد استفاده شوند. اینکار باعث می شود بطور خیلی قابل توجهی تعداد تخصیص حافظه کاهش یابد و عملکرد برنامه چند برابر شود.\nمثال دوم :\nموارد استفاده دیگر از sync.Pool برای ذخیره کردن آبجکت های پرکاربرد نظیر کانکشن دیتابیس یا شبکه و همچنین آبجکت هایی که قصد داریم برروی آن عملیات serialize و deserialize انجام دهیم.\n3.3.6 Cond # با استفاده از Cond می توانید چندین گوروتین ایجاد کنید و گوروتین ها تا زمان وقوع یک رویداد منتظر می مانند و هیچ فرآیندی را اجرا نمیکنند. هر Cond که ایجاد میکنید داخلش یک قفل از نوع (Mutex یا RWMutex) وجود دارد که می توانید گوروتین ها را منتظر نگه دارید.\nزمانیکه شما یک Cond میسازید به عنوان ورودی یک قفل از نوع (Mutex یا RWMutex) یه عنوان ورودی می دهید. حال شما ۳ تا متد درخصوص Cond خواهید داشت که به شرح زیر است :\nBroadcast: با استفاده از این متد می توانید تمامی گوروتین هایی که در حالت منتظر هستند را آزاد کنید تا به فرآیند خود ادامه دهند. Signal: با استفاده از این متد می توانید به گوروتین سیگنال بفرستید تا از حالت منتظر خارج شود و به فرآیند خود ادامه دهد. Wait: این متد بصورت atomic منتظر می ماند تا زمانیکه unlocks صورت گیرد و تا اون موقع گوروتین ها را در حالت تعلیق نگه می دارد. به مثال زیر توجه کنید :\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;sync\u0026#34; 6) 7 8var sharedRsc = make(map[string]interface{}) 9 10func main() { 11\tvar wg sync.WaitGroup 12\twg.Add(2) 13\tm := sync.Mutex{} 14\tc := sync.NewCond(\u0026amp;m) 15\tgo func() { 16\t// this go routine wait for changes to the sharedRsc 17\tc.L.Lock() 18\tfor len(sharedRsc) == 0 { 19\tc.Wait() 20\t} 21\tfmt.Println(\u0026#34;goroutine1\u0026#34;, sharedRsc[\u0026#34;rsc1\u0026#34;]) 22\tc.L.Unlock() 23\twg.Done() 24\t}() 25 26\tgo func() { 27\t// this go routine wait for changes to the sharedRsc 28\tc.L.Lock() 29\tfor len(sharedRsc) == 0 { 30\tc.Wait() 31\t} 32\tfmt.Println(\u0026#34;goroutine2\u0026#34;, sharedRsc[\u0026#34;rsc2\u0026#34;]) 33\tc.L.Unlock() 34\twg.Done() 35\t}() 36 37\t// this one writes changes to sharedRsc 38\tc.L.Lock() 39\tsharedRsc[\u0026#34;rsc1\u0026#34;] = \u0026#34;foo\u0026#34; 40\tsharedRsc[\u0026#34;rsc2\u0026#34;] = \u0026#34;bar\u0026#34; 41\tc.Broadcast() 42\tc.L.Unlock() 43\twg.Wait() 44} 1$ go run main.go 2goroutine2 bar 3goroutine1 foo "},{"id":36,"href":"/chapter-3/go-atomic/","title":"3.4 پکیج atomic","section":"فصل سوم: همزمانی (concurrency)","content":"پکیج atomic یک حافظه atomic سطح پایین برای پیاده سازی الگوریتم های همگام سازی شده است. از مواردی که خیلی قابل اهمیت است با این پکیج شما می توانید یکسری الگوهای همگام سازی را پیاده سازی کنید. سعی کنید با دقت بیشتری از این پکیج استفاده کنید چون کارکردش خارج از safe memory هست.\nبه مثال زیر توجه کنید :\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;sync\u0026#34; 6\t\u0026#34;sync/atomic\u0026#34; 7) 8 9type Cache struct { 10\tmu sync.Mutex 11\tdata map[string]string 12} 13 14func (c *Cache) Set(key, value string) { 15\tc.mu.Lock() 16\tdefer c.mu.Unlock() 17\tc.data[key] = value 18} 19 20func (c *Cache) Get(key string) (value string, ok bool) { 21\tc.mu.Lock() 22\tdefer c.mu.Unlock() 23\tvalue, ok = c.data[key] 24\treturn 25} 26 27type AtomicCache struct { 28\tmu sync.Mutex 29\tdata atomic.Value 30} 31 32func (c *AtomicCache) Set(key, value string) { 33\tc.mu.Lock() 34\tdefer c.mu.Unlock() 35\tc.data.Store(map[string]string{key: value}) 36} 37 38func (c *AtomicCache) Get(key string) (value string, ok bool) { 39\tdata := c.data.Load().(map[string]string) 40\tvalue, ok = data[key] 41\treturn 42} 43 44func main() { 45\tcache := Cache{data: map[string]string{}} 46\tcache.Set(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;) 47\tfmt.Println(cache.Get(\u0026#34;key\u0026#34;)) // Output: value, true 48 49\tatomicCache := AtomicCache{data: atomic.Value{}} 50\tatomicCache.Set(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;) 51\tfmt.Println(atomicCache.Get(\u0026#34;key\u0026#34;)) // Output: value, true 52} 1$ go run main.go 2value true 3value true در مثال فوق ما یک ساختار به نام Cache داریم که داخلش یک فیلد از نوع map داریم و قصد داریم یکسری اطلاعات را داخل کش بریزیم حال زمانیکه Set/Get می کنیم با استفاده از Mutex اون بخش از عملیات را لاک میکنیم تا جلوی عملیات نوشتن چندین گوروتین برروی یک آدرس حافظه را بگیریم. حال این عملیات رو ما با استفاده از atomic انجام دادیم و همگام سازی داده را بردیم تو سطح خیلی پایین تر در حافظه و با استفاده از atomic.Value که یک اینترفیس است این عملیات را انجام دادیم و این عملیات Set/Get حالت atomic پیدا کرده است.\nآیا استفاده از atomic نیازمند mutex می باشد یا خیر؟\nدر این کد، mutex در متد Set برای جلوگیری از رخ دادن race condition یا داده‌های نامنظم استفاده شده است. بدون mutex، چندین گوروتین ممکن است همزمان به دسترسی و تغییر داده‌های map data بپردازند که موجب رفتار نامنظم و فساد داده می‌شود. با گرفتن mutex قبل از تغییر map data، متد Set اطمینان حاصل می‌کند که تنها یک گوروتین در هر زمان می‌تواند به داده‌ها دسترسی پیدا کند و تداخل داده‌ها را جلوگیری می‌کند.\nاستفاده از mutex در متد Get نیز مهم است، زیرا این اطمینان را به ما می‌دهد که در هنگام دسترسی به map data، هیچ گوروتین دیگری دارای مجوز تغییر داده‌ها نیست. بدون mutex، یک race condition ممکن است ایجاد شود اگر یک گوروتین دیگر در حال تغییر داده‌های map باشد در حالی که یک گوروتین دیگر سعی در خواندن از آن دارد.\nدر پیاده‌سازی AtomicCache، یک atomic.Value برای ذخیره map استفاده شده است که به انجام عملیات اتمی روی آن اجازه می‌دهد. با این حال، حتی با استفاده از یک مقدار اتمی، همچنان نیاز به mutex وجود دارد تا فقط یک گوروتین در هر زمان به دسترسی به map دسترسی داشته باشد و تداخل داده‌ها را جلوگیری کند.\n3.4.1 برخی از کاربردهای atomic # در زیر چندتا use case برای استفاده از پکیج atomic معرفی کردیم :\nپیاده سازی همگام سازی بدون مسدودیت : پکیج atomic توابع سطح پایینی را برای انجام عملیات حافظه اتمی فراهم می کند که می تواند برای پیاده سازی الگوریتم های همگام سازی غیرمسدود مانند مقایسه و تعویض (CAS) یا بارگذاری لینک/ذخیره شرطی استفاده شود. LL/SC).\nپیاده سازی ساختارهای داده با همزمانی سطح (high-concurrency) بالا : با پکیج atomic می توان برای پیاده سازی ساختارهای داده ای استفاده کرد که برای دسترسی همزمان و اصلاح توسط چندین گوروتین ایمن هستند. به عنوان مثال، می توانید از بسته اتمی برای پیاده سازی نقشه یا صف همزمان استفاده کنید.\nپیاده سازی شمارنده (counter) از نوع atomic : شما با استفاده از پکیج atomic می توانید برای افزایش و کاهش شمارنده ها به صورت اتمی که می تواند برای اجرای مواردی مانند شمارش مرجع یا محدود کردن ratelimit استفاده شود.\n"},{"id":37,"href":"/chapter-3/goroutine-data-race/","title":"3.5 آموزش مقابله با data race","section":"فصل سوم: همزمانی (concurrency)","content":"معمولا تو بحث همزمانی یکی از اتفاقاتی که خیلی ممکن است رخ دهد بحث data race است و data race زمانی رخ می دهد که ۲ یا چند گوروتین قصد دارند به یک آدرس حافظه در یک زمان دسترسی داشته باشند. حال اگر ما جلوی data race را نگیریم ممکن است تغییرات نادرست برروی مقادیر داخل خانه حافظه صورت گیرد.\nراه هایی برای مقابله با data race وجود دارد که به شرح زیر است :\nاستفاده از Mutex داخل پکیج sync برای قفل گذاشتن/برداشتن یک بخش دیتا. استفاده RWMutex داخل پکیج sync می توانید داده اشتراک گذاری شده را قفل کنید فقط یک گوروتین عملیات نوشتن داشته باشد. استفاده از پکیج atomic برای عملیات بصورت atomic برروی مقادیر. 3.5.1 تشخیص Data Race # به لطف امکان جانبی زبان گو شما می توانید خیلی راحت بخش هایی که data race رخ داده را تشخیص دهید. کافیه سوییچ race- را هنگام build اضافه کنید تا در زمان data race ها را تشخیص دهید.\n1$ go run -race main.go 2 3================== 4WARNING: DATA RACE 5Write at 0x00c000522c20 by goroutine 29: 6 git.ramooz.org/ramooz/golang-components/event-driven/rabbitmq.(*Connection).handleReconnect() 7 /home/user/Project/go/ramooz.org/medx/software-builder/vendor/git.ramooz.org/ramooz/golang-components/event-driven/rabbitmq/rabbit.go:86 +0x89 8 git.ramooz.org/ramooz/golang-components/event-driven/rabbitmq.NewConnection.func1() 9 /home/user/Project/go/ramooz.org/medx/software-builder/vendor/git.ramooz.org/ramooz/golang-components/event-driven/rabbitmq/rabbit.go:35 +0x58 10 11Previous read at 0x00c000522c20 by main goroutine: 12 git.ramooz.org/ramooz/golang-components/event-driven/rabbitmq.NewConnection() 13 /home/user/Project/go/ramooz.org/medx/software-builder/vendor/git.ramooz.org/ramooz/golang-components/event-driven/rabbitmq/rabbit.go:37 +0x324 14 git.ramooz.org/ramooz/golang-components/logger.initializeRabbitMQ() 15 /home/user/Project/go/ramooz.org/medx/software-builder/vendor/git.ramooz.org/ramooz/golang-components/logger/rabbit.conn.go:11 +0x226 16 git.ramooz.org/ramooz/golang-components/logger.NewLogger() 17 /home/user/Project/go/ramooz.org/medx/software-builder/vendor/git.ramooz.org/ramooz/golang-components/logger/logger.go:37 +0x456 18 ramooz.org/ramooz/user-service/configs.initNewLogger() 19 /home/user/Project/go/ramooz.org/medx/software-builder/configs/configs.go:158 +0x938 20 ramooz.org/ramooz/user-service/configs.ConfigServer() 21 /home/user/Project/go/ramooz.org/medx/software-builder/configs/configs.go:54 +0x15a 22 main.main() 23 /home/user/Project/go/ramooz.org/medx/software-builder/main.go:17 +0x29 24 25Goroutine 29 (running) created at: 26 git.ramooz.org/ramooz/golang-components/event-driven/rabbitmq.NewConnection() 27 /home/user/Project/go/ramooz.org/medx/software-builder/vendor/git.ramooz.org/ramooz/golang-components/event-driven/rabbitmq/rabbit.go:35 +0x2da 28 git.ramooz.org/ramooz/golang-components/logger.initializeRabbitMQ() 29 /home/user/Project/go/ramooz.org/medx/software-builder/vendor/git.ramooz.org/ramooz/golang-components/logger/rabbit.conn.go:11 +0x226 30 git.ramooz.org/ramooz/golang-components/logger.NewLogger() 31 /home/user/Project/go/ramooz.org/medx/software-builder/vendor/git.ramooz.org/ramooz/golang-components/logger/logger.go:37 +0x456 32 ramooz.org/ramooz/user-service/configs.initNewLogger() 33 /home/user/Project/go/ramooz.org/medx/software-builder/configs/configs.go:158 +0x938 34 ramooz.org/ramooz/user-service/configs.ConfigServer() 35 /home/user/Project/go/ramooz.org/medx/software-builder/configs/configs.go:54 +0x15a 36 main.main() 37 /home/user/Project/go/ramooz.org/medx/software-builder/main.go:17 +0x29 38================== در خروجی بالا یک هشدار data race داده است که در فلان خط کد شما فلان گوروتین ها در یک زمان دسترسی برروی یک داده را دارند. و شما با توجه به خروجی می توانید سناریو های جلوگیری را انجام دهید.\n"},{"id":38,"href":"/chapter-3/go-channel/","title":"3.6 کانال (channel)","section":"فصل سوم: همزمانی (concurrency)","content":" کانال یک نوع تایپ است که داده از نوع خاصی را نگه داری میکند و امکان برقراری ارتباط و همگام سازی داده بین گوروتین ها را فراهم می کند. شما می توانید کانال ها را به عنوان خط لوله های در نظر بگیرید که این خط لوله ها به گوروتین ها متصل می شود و باعث برقراری ارتباط بین گوروتین ها می شود. این ارتباط بین گوروتین ها به هیچ قفل صریحی نیاز ندارد (منظورم mutex و \u0026hellip;) چون کانال ها بصورت داخلی قفل ها را مدیریت میکند و در زمان های مناسب و مشخص Lock و UnLock می کند.\nبه نقل از رابرت گریزمر که یکی از توسعه دهنده های اصلی زبان برنامه نویسی گو می باشد در خصوص کانال ها می گوید : با برقراری ارتباط حافظه را به اشتراک بزارید ولی با اشتراک گذاری حافظه ارتباط برقرار نکنید.\nمنظور از نقل فوق این است شما برای اینکه بخوای بین گوروتین ها ارتباط برقرار کنی این کار را با اشتراک گذاری حافظه نکنید. بلکه باید بواسطه کانال ها حافظه را بین گوروتین ها به اشتراک بزارید.\nزبان گو برای بحث همزمانی ۲ تا مقوله خیلی مهم دارد که این دو با هم در ارتباط هستند :\nگوروتین ها : یک thread مستقل و سبک وزن در زبان گو که قابلیت برنامه نویسی همزمان (concurrency) را فراهم می کند. کانال ها : فراهم کننده ارتباط و همگام سازی داده ها بین گوروتین ها. 3.6.1 تعریف کانال ها # همانطور که گفتیم کانال یک نوع تایپ است که داده از نوع خاصی را نگه داری میکند و شما باید این تایپ را برای متغیری تعریف کنید تا بتوانید بواسطه آن متغیر می توانیم بین گوروتین ها ارتباط برقرار کنیم.\n1var \u0026lt;variable_name\u0026gt; chan \u0026lt;type\u0026gt; به مثال زیر توجه کنید :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 var a chan int 7 fmt.Println(a) 8} 1$ go run main.go 2{nil} در بالا ما یک متغیر با نام a تعریف کردیم که از نوع کانال با تایپ int می باشد و این کانال فقط انتقال داده از نوع int را انجام می دهد. و مقدار پیش فرض کانال nil می باشد که در خروجی می توانید ببینید.\nتوجه کنید همیشه سعی کنید کانال را با استفاده از تابع make ایجاد کنید. 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 a := make(chan int) 7 fmt.Println(a) 8} 1$ go run main.go 20xc0000240c0 در خروجی کد بالا همانطور که مشاهده می کنید به جای nil آدرس حافظه داده را نمایش می دهد.\nزمانیکه شما یک کانال را به واسطه make ایجاد می کنید در واقع دارید یک instance از ساختار hchan ایجاد می کنید و تمامی فیلدهای این ساختار مقدار پیش فرض میگیرند.\n1type hchan struct { 2 qcount uint // total data in the queue 3 dataqsiz uint // size of the circular queue 4 buf unsafe.Pointer // points to an array of dataqsiz elements 5 elemsize uint16 6 closed uint32 // denotes weather channel is closed or not 7 elemtype *_type // element type 8 sendx uint // send index 9 recvx uint // receive index 10 recvq waitq // list of recv waiters 11 sendq waitq // list of send waiters 12 lock mutex 13} 3.6.2 عملیات ها برروی کانال # زمانیکه شما یک کانال ایجاد می کنید، دو عملیات اصلی بر روی کانال می توانید انجام دهید :\nارسال : ارسال داده به داخل کانال دریافت : دریافت داده از کانال 3.6.2.1 عملیات ارسال # برای ارسال داده به داخل کانال یک اپراتور استاندارد وجود دارد که بهتر است همیشه به خاطر بسپارید :\n1ch \u0026lt;- val متغیر ch همان کانالی است که با استفاده از تایپ chan ساخته شده است. متغیر val هم مقداری است که توسط اپراتور \u0026lt;- به کانال ارسال شده است. توجه کنید تایپ val باید با تایپی که برای کانال مشخص کردید حتما یکی باشد. 3.6.2.2 عملیات دریافت # عملیات دریافت در کانال صرفا جهت خواندن داده از طریق کانال می باشد که یک قالب استاندارد همانند عملیات ارسال دارد :\n1val := \u0026lt;- ch در اینجاهم ch همان متغیر کانال می باشد. متغیر val هم منتظر دریافت داده به واسطه \u0026gt;- از طریق کانال ch می باشد. 3.6.2.3 مثال عملیات ارسال و دریافت # در زیر یک مثال میزنیم که داده ای را بواسطه کانال ارسال/دریافت می کنیم بین گوروتین ها.\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;time\u0026#34; 6) 7 8func main() { 9 ch := make(chan int) 10 11 fmt.Println(\u0026#34;Sending value to channel\u0026#34;) 12 go send(ch) 13 14 fmt.Println(\u0026#34;Receiving from channel\u0026#34;) 15 go receive(ch) 16 17 time.Sleep(time.Second * 1) 18} 19 20func send(ch chan int) { 21 ch \u0026lt;- 1 22} 23 24func receive(ch chan int) { 25 val := \u0026lt;-ch 26 fmt.Printf(\u0026#34;Value Received=%d in receive function\\n\u0026#34;, val) 27} 1$ go run main.go 2Sending value to channel 3Receiving from channel 4Value Received=1 in receive function در کد فوق ما یک کانال با نام ch از نوع int ایجاد کردیم. سپس ۲ تابع send و received را داخل گوروتین قرار دادیم که هر دو تابع به عنوان پارامتر ورودی تایپ int را بصورت کانال میگیرد. حال متغیر کانال ch را به هر دو تابع پاس دادیم. و در هر دو تابع ۲ تا عملیات صورت گرفته :\nتابع send مقدار عدد ۱ را به داخل کانال ارسال کرده تابع recived مقدار را از کانال ch دریافت کرده و داخل متغیر val قرار داده است و در نهایت متغیر val را چاپ کرده است. در انتهای تابع main ما یک sleep به مدت ۱ ثانیه قرار دادیم که بتوانید خروجی برنامه را ببینیم و اگر اینکار را نکنیم برنامه متوقف می شود و ممکن دو گوروتین برای اجرا برنامه ریزی نشوند.\nیک نکته بسیار مهمی که وجود دارد در مورد عملیات دریافت باید توجه کنید که یک مقدار خاص از نوع int به داخل کانال فقط یک بار ارسال شده است و فقط یکبار مقدار قابل دریافت از کانال. همانطور که می بینید هیچ قفلی در گوروتین ها موقع ارسال و دریافت استفاده نشده است و قفل ها توسط خود کانال مدیریت می شود و نیازی به استفاده از قفل ها در کد نیست.\nبزارید یک مثال ساده برای اینکه ببینید چطور کانال ها Lock و UnLock می شود بزنیم :\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;time\u0026#34; 6) 7 8func main() { 9 ch := make(chan int) 10 go send(ch) 11 12 go receive(ch) 13 time.Sleep(time.Second * 2) 14} 15 16func send(ch chan int) { 17 time.Sleep(time.Second * 1) 18 fmt.Println(\u0026#34;Timeout finished\u0026#34;) 19 ch \u0026lt;- 1 20} 21 22func receive(ch chan int) { 23 val := \u0026lt;-ch 24 fmt.Printf(\u0026#34;Receiving Value from channel finished. Value received: %d\\n\u0026#34;, val) 25} 1$ go run main.go 2Timeout finished 3Receiving Value from channel finished. Value received: 1 در کد فوق ما داخل تابع send یک sleep به مدت ۱ ثانیه قرار دادیم. و پس از اینکه ۱ ثانیه تمام شد مقدار را داخل کانال ch ارسال کردیم و سپس مقدار داخل تابع recived دریافت شد.\nاتفاقی که در کد فوق رخداد زمانیکه شما عملیات دریافت را انجام می دهید تا زمانیکه مقداری از کانال دریافت نشود اون بخش از کد شما Lock می شود و پس از اینکه دریافت شد مقدار از کانال آن بخش Unlock خواهد شد.\n3.6.3 ایجاد کانال بافر شده # در زبان گو شما می توانید کانال های بافر شده ایجاد کنید. یک کانال بافر دارای مقداری ظرفیت برای نگه داری داده برای کانال بافر است.\nبزارید کمی ساده تر توضیح دهیم شما برای کانال همانند آرایه و slice می توانید یک ظرفیت مشخصی تعیین کنید که این کانال فقط می تواند این مقدار از داده را نگه داری کند و تا زمانیکه مقادیر از کانال خارج نشود ظرفیت کانال پرخواهد بود و مقدار جدیدی را نمی توانید به کانال ارسال کنید.\nبرای ایجاد یک کانال بافر شده با از قالب زیر استفاده کنید :\n1a := make(chan , capacity) مقدار capacity که بصورت عدد هست تعداد بافر کانال را مشخص می کند که این کانال فقط می تواند این حجم از داده را داخل کانال نگه داری کند.\nبه مثال زیر توجه کنید :\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5) 6 7func main() { 8 ch := make(chan int, 1) 9 ch \u0026lt;- 1 10 fmt.Println(\u0026#34;Sending value to channnel complete\u0026#34;) 11 val := \u0026lt;-ch 12 fmt.Printf(\u0026#34;Receiving Value from channel finished. Value received: %d\\n\u0026#34;, val) 13} 1$ go run main.go 2Sending value to channnel complete 3Receiving Value from channel finished. Value received: 1 در کد فوق ما یک کانال بافر شده با ظرفیت ۱ ایجاد کردیم و مقدار ۱ را به کانال ارسال کردیم و در ادامه از این مقدار را از کانال دریافت کردیم.\n1ch := make(chan int, 1) 3.6.3.1 ارسال داده برروی کانال با ظرفیت پر # حالا فرض کنید می خواهیم به کانال بافر شده کد فوق یک مقدار دیگری را ارسال کنیم :\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7func main() { 8\tch := make(chan int, 1) 9\tch \u0026lt;- 1 10\tch \u0026lt;- 2 11\tfmt.Println(\u0026#34;Sending value to channnel complete\u0026#34;) 12\tval := \u0026lt;-ch 13\tfmt.Printf(\u0026#34;Receiving Value from channel finished. Value received: %d\\n\u0026#34;, val) 14} 1$ go run main.go 2fatal error: all goroutines are asleep - deadlock! 3 4goroutine 1 [chan send]: 5main.main() 6\t/tmp/sandbox2390960160/prog.go:10 +0x4b در کد فوق اتفاقی که افتاد ما یک کانال بافر شده با ظرفیت ۱ ایجاد کردیم ولی به این کانال ۲ تا مقدار ارسال کردیم:\n1ch \u0026lt;- 1 2ch \u0026lt;- 2 در ادامه اتفاقی که صورت گرفت کانال ما به خاطر پر شدن ظرفیتش بلاک شده بود و داده دیگه ای را نمی توانست نگه داری کند. در نتیجه با خطای deadlock مواجه شد و برنامه کاملا متوقف شد :\n1fatal error: all goroutines are asleep - deadlock! دریافت مجدد داده از کانال خالی شده # به مثال زیر توجه کنید :\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5) 6 7func main() { 8 ch := make(chan int, 1) 9 ch \u0026lt;- 1 10 fmt.Println(\u0026#34;Sending value to channnel complete\u0026#34;) 11 val := \u0026lt;-ch 12 val = \u0026lt;-ch 13 fmt.Printf(\u0026#34;Receiving Value from channel finished. Value received: %d\\n\u0026#34;, val) 14} 1$ go run main.go 2Sending value to channnel complete 3fatal error: all goroutines are asleep - deadlock! 4 5goroutine 1 [chan receive]: 6main.main() 7\t/tmp/sandbox3239418330/prog.go:12 +0xad در کد فوق ما یک کانال بافر شده با ظرفیت ۱ ایجاد کردیم و یک مقدار را به کانال ارسال کردیم و در نهایت ۲ بار دریافت از کانال را فرخوانی کردیم. اما اتفاقی که افتاده بازم با خطای deadlock مواجه شدیم چون کانال خالی شده است و هیچ داده ای بیشتر از بافر اش ندارد.\n3.6.4 جهت های کانال # شما می توانید کانال را جهت های مختلفی تعریف کنید که به شرح زیر است :\nدو طرفه : کانال با جهت دوطرفه مانند مثال های قبلی می باشد که شما chan int به این شکل تعریف می کنید. یک طرفه فقط ارسال : شما می توانید یک کانال ایجاد کنید که فقط عملیات ارسال chan\u0026lt;- int را انجام می دهد. یک طرفه فقط دریافت : شما می توانید یک کانال ایجاد کنید که فقط عملیات دریافت \u0026lt;-chan int را انجام می دهد. حالا این سوال پیش می آید چرا باید ما یک کانال ایجاد کنیم که عملیات فقط ارسال یا عملیات فقط دریافت را انجام می دهد. این کار وقتی مفید است که شما بخواهید برای پارامترهای ورودی یا خروجی توابع خود را محدود به یک عملیات در کانال کنید.\nکانال حالت های مختلفی دارد که شما پارامترهای ورودی و خروجی تابع استفاده کنید :\nchan کانال دوطرفه chan \u0026lt;- کانال فقط ارسال \u0026lt;-chan کانال فقط دریافت 3.6.4.1 کانال فقط ارسال # برای ایجاد کانال فقط ارسال شما می توانید به شکل زیر برای ورودی یا خروجی تابع تعریف کنید :\n1func process(ch chan\u0026lt;- int){ doSomething } زمانیکه شما تلاش کنید کانال با جهت های مختلف به پارامتر ورودی تابع فقط ارسال کانالی را پاس دهید با خطای زیر مواجه خواهید شد :\n1invalid operation: \u0026lt;-ch (receive from send-only type chan\u0026lt;- int) به مثال ساده زیر توجه کنید :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tch := make(chan int, 3) 7\tgo process(ch) 8\tfmt.Println(\u0026lt;-ch) 9} 10func process(ch chan\u0026lt;- int) { 11\tch \u0026lt;- 2 12} 1$ go run main.go 22 در کد فوق ما یک تابع به نام process ایجاد کردیم که کانال فقط ارسال به عنوان پارامتر ورودی دارد و در ادامه ما کانال ch را که دو طرفه است به این تابع پاس دادیم و مقدار دریافتی را چاپ کردیم.\n3.6.4.2 کانال فقط دریافت # برای ایجاد کانال فقط دریافت شما می توانید به شکل زیر برای ورودی یا خروجی تابع تعریف کنید :\n1func process(ch \u0026lt;-chan int){ doSomething } زمانیکه شما تلاش کنید کانال با جهت های مختلف به پارامتر ورودی تابع فقط دریافت پاس دهید با خطای زیر مواجه خواهید شد :\n1invalid operation: ch \u0026lt;- 2 (send to receive-only type \u0026lt;-chan int) به مثال ساده زیر توجه کنید :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tch := make(chan int, 3) 7\tch \u0026lt;- 2 8\tprocess(ch) 9} 10func process(ch \u0026lt;-chan int) { 11\ts := \u0026lt;-ch 12\tfmt.Println(s) 13} 1$ go run main.go 22 3.6.5 گرفتن ظرفیت یک کانال # شما می توانید همانند slice یا آرایه ظرفیت یک کانال را با استفاده از تابع ()cap ببینید.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 ch := make(chan int, 3) 7 fmt.Printf(\u0026#34;Capacity: %d\\n\u0026#34;, cap(ch)) 8} 1$ go run main.go 2Capacity: 3 توجه کنید ظرفیت کانال بافر نشده همیشه صفر است. 3.6.6 گرفتن طول یک کانال # شما با استفاده از تابع ()len می توانید طول و اندازه یک کانال را بگیرید و ببینید چه مقدار داده داخل کانال قرار دارد.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tch := make(chan int, 3) 7\tch \u0026lt;- 5 8\tfmt.Printf(\u0026#34;Len: %d\\n\u0026#34;, len(ch)) 9 10\tch \u0026lt;- 6 11\tfmt.Printf(\u0026#34;Len: %d\\n\u0026#34;, len(ch)) 12\tch \u0026lt;- 7 13\tfmt.Printf(\u0026#34;Len: %d\\n\u0026#34;, len(ch)) 14} 1$ go run main.go 2Len: 1 3Len: 2 4Len: 3 3.6.7 عملیات بستن (close) یک کانال # در زبان گو ما یک تابع Built-in به نام close داریم که می توانیم برای بستن یک کانال استفاده کنیم و زمانیکه که یک کانال بسته شود دیگر نمی توانیم داده ای را به آن کانال ارسال کنیم. کانال معمولا زمانی بسته می شود که همه داده ها ارسال شده است و داده دیگری برای ارسال نداریم و باید کانال را ببندیم.\nبه مثال زیر توجه کنید :\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;time\u0026#34; 6) 7 8func main() { 9 ch := make(chan int) 10 go sum(ch, 3) 11 ch \u0026lt;- 2 12 ch \u0026lt;- 2 13 ch \u0026lt;- 2 14 close(ch) 15 time.Sleep(time.Second * 1) 16} 17 18func sum(ch chan int, len int) { 19 sum := 0 20 for i := 0; i \u0026lt; len; i++ { 21 sum += \u0026lt;-ch 22 } 23 fmt.Printf(\u0026#34;Sum: %d\\n\u0026#34;, sum) 24} 1$ go run main.go 2Sum: 6 در کد فوق ما یک کانال بافر شده با ظرفیت ۳ ایجاد کردیم و سپس ۳ تا مقدار را به کانال ارسال کردیم و پس از آن کانال را با تابع close بستیم چون دیگر نمیخواهیم داده دیگری را ارسال کنیم.\nتوجه کنید ارسال داده برروی کانال بسته شده ممکن است برنامه شما با خطای panic مواجه و کاملا متوقف شود.\n1package main 2func main() { 3 ch := make(chan int) 4 close(ch) 5 ch \u0026lt;- 2 6} 1$ go run main.go 2panic: send on closed channel اما برای اینکه بتوانیم جلوی این panic رخ داده را بگیریم می توانیم زمانیکه داریم از کانال مقدار دریافت می کنیم می توانیم assertion انجام دهیم تا متوجه بسته بودن کانال شویم :\n1package main 2import ( 3 \u0026#34;fmt\u0026#34; 4) 5func main() { 6 ch := make(chan int, 1) 7 ch \u0026lt;- 2 8 val, ok := \u0026lt;-ch 9 fmt.Printf(\u0026#34;Val: %d OK: %t\\n\u0026#34;, val, ok) 10 11 close(ch) 12 val, ok = \u0026lt;-ch 13 fmt.Printf(\u0026#34;Val: %d OK: %t\\n\u0026#34;, val, ok) 14} 1$ go run main.go 2Val: 2 OK: true 3Val: 0 OK: false اگر مقدار ok از کانال دریافتی true باشد یعنی کانال بسته نشده است و اگر مقدار false دریافت کنیم یعنی کانال بسته شده است.\n3.6.8 استفاده از حلقه for-range برروی کانال # یکی از کاربردی ترین حالت های دریافت داده از کانال استفاده از حلقه for-range است که می توانید تا زمان بسته شدن کانال مقدار دریافت کنید.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;time\u0026#34; 6) 7 8func main() { 9\tch := make(chan int, 3) 10\tch \u0026lt;- 2 11\tch \u0026lt;- 2 12\tch \u0026lt;- 2 13\tclose(ch) 14\tgo sum(ch) 15\ttime.Sleep(time.Second * 1) 16} 17 18func sum(ch chan int) { 19\tsum := 0 20\tfor val := range ch { 21\tsum += val 22\t} 23\tfmt.Printf(\u0026#34;Sum: %d\\n\u0026#34;, sum) 24} 1$ go run main.go 2Sum: 6 در کد فوق ما یک کانال بافر شده با ظرفیت ۳ ایجاد کردیم سپس ۳ تا مقدار به کانال ارسال کردیم و داخل تابع sum مقادیر را با استفاده از حلقه for-range دریافت و پس از آن چاپ کردیم.\nحالا یک سوال پیش می آید آیا ما اگر کانال را در تابع main نبندیم چه اتفاقی می افتد؟ اگر شما کانال را نبندید بطور حتمی با خطا deadlock مواجه خواهید شد. حلقه ای که داخل تابع sum قرار دادید برای دریافت داده هیچوقت متوقف نخواهد شد.\nپس سعی کنید همیشه و همه جا در جای درست بستن کانال را انجام دهید تا دچار مشکلات مختلف نشوید.\n3.6.9 کانال nil # همانطور که در اوایل این بخش گفتیم مقدار پیش فرض یک کانال nil است و زمانیکه ما یک کانال بدون تابع make تعریف می کنیم مقدار پیش فرضش nil خوهد بود.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 var a chan int 7 fmt.Print(\u0026#34;Default zero value of channel: \u0026#34;) 8 fmt.Println(a) 9} 1$ go run main.go 2nil یکسری نکات در خصوص کانال nil وجود دارد :\nارسال داده به یک کانالی که nil است باعث بلاک شدن همیشگی کد شما در آن خط خواهد شد. دریافت داده به یک کانالی که nil است باعث بلاک شدن همیشگی کد شما در آن خط خواهد شد. بستن یک کانالی که nil باشد باعث panic برنامه شما خواهد شد. "},{"id":39,"href":"/chapter-3/go-select/","title":"3.7 آموزش استفاده از select","section":"فصل سوم: همزمانی (concurrency)","content":"در زبان گو select همانند switch می باشد که دارای case و default هستش اما یک فرق کلی دارد که به عملکردش برمیگردد. case های select برای عملیات ارسال و دریافت از کانال منتظر می ماند. در کل شما با استفاده از select می توانید از کانال های مختلف اطلاعات ارسال و دریافت کنید و پس از آن برروی آن اطلاعات عملیات انجام دهید.\nselect تا زمانی که یکی از case ها آماده شود بلاک می شود. اگر همزمان چندتا case برای انجام عملیات آماده شود select بصورت تصادفی یکی را انتخاب میکند تا عملیات تکمیل شود. 1select { 2case channel_send_or_receive: 3 //Dosomething 4case channel_send_or_receive: 5 //Dosomething 6default: 7 //Dosomething 8} select از بین case ها موردی را انتخاب می کند که در آن عملیات ارسال یا دریافت کانال بلاک نشده باشد و آماده اجرا باشد. اگر چند مورد از case ها آماده باشد یکی از آنها بصورت تصادفی انتخاب می شود تا فرآیند را تکمیل کند.\nبزارید یک مثال ساده بزنیم :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 ch1 := make(chan string) 7 ch2 := make(chan string) 8 9 go goOne(ch1) 10 go goTwo(ch2) 11 12 select { 13 case msg1 := \u0026lt;-ch1: 14 fmt.Println(msg1) 15 case msg2 := \u0026lt;-ch2: 16 fmt.Println(msg2) 17 } 18} 19 20func goOne(ch chan string) { 21 ch \u0026lt;- \u0026#34;From goOne goroutine\u0026#34; 22} 23 24func goTwo(ch chan string) { 25 ch \u0026lt;- \u0026#34;From goTwo goroutine\u0026#34; 26} 1$ go run main.go 2From goOne goroutine در کد فوق ما ۲ تا کانال تعریف کردیم و کانال ها را به توابع goOne و goTwo پاس دادیم سپس داخل تابع به هرکدام از کانال مقداری ارسال شد. حالا در ادامه بدنه main یک select قرار دادیم که هر یک از case ها منتظر دریافت اطلاعات از کانال مشخص شده براش است.\nپس از اینکه یکی یا هر دو از کانال داده را آماده کردند بصورت تصادفی یکی از case ها انتخاب می شود تا عملیات را تکمیل کند.\nکه در خروجی مقداری که از ch1 آماده را نمایش می دهد. اما اگر بخواهیم خروجی هر دو کانال را ببینیم می توانیم از حلقه استفاده کنیم. به مثال زیر توجه کنید :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 ch1 := make(chan string) 7 ch2 := make(chan string) 8 go goOne(ch1) 9 go goTwo(ch2) 10 for i := 0; i \u0026lt; 2; i++ { 11 select { 12 case msg1 := \u0026lt;-ch1: 13 fmt.Println(msg1) 14 case msg2 := \u0026lt;-ch2: 15 fmt.Println(msg2) 16 } 17 } 18} 19 20func goOne(ch chan string) { 21 ch \u0026lt;- \u0026#34;From goOne goroutine\u0026#34; 22} 23 24func goTwo(ch chan string) { 25 ch \u0026lt;- \u0026#34;From goTwo goroutine\u0026#34; 26} 1$ go run main.go 2From goOne goroutine 3From goTwo goroutine در کد فوق ما select را داخل یک حلقه for قرار دادیم و گفتیم اگر مقدار i کوچکتر از ۲ بود ++i شود. که در هر دو تایم مقدار دریافتی از کانال ها را توانستیم به عنوان خروجی چاپ کنیم.\nهمانطور که قبلا گفتیم اگر شما داخل select یک case را بزارید که هیچ اطلاعات از کانال دریافت نکند ممکن است برنامه شما کاملا بلاک شود و با خطای deadlock مواجه شوید.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 ch1 := make(chan string) 7 select { 8 case msg := \u0026lt;-ch1: 9 fmt.Println(msg) 10 } 11} 1$ go run main.go 2fatal error: all goroutines are asleep - deadlock! اتفاقی که در کد فوق رخ داد ما یک کانال ایجاد کردیم و سپس داخل select یک case قرار دادیم که منتظر دریافت داده از کانال می باشد. اما چون هیچ داده به کانال ارسال نمی شود برنامه بطور کلی در همان تیکه از کد بلاک می شود و در نهایت شما با خطای داخل خروجی مواجه خواهید شد.\n3.7.1 نحوه کنترل عملیات های کانال با select # در بالا در خصوص select توضیح دادیم که چه کاربردی هایی دارد اما بزارید توضیحات را تکمیل کنیم. وقتی شما قصد دارید از گوروتین و کانال استفاده کنید در اینجا select نقش خیلی پررنگی در کنترل عملیات کانال ها دارد. اینجاست که بحث همزمانی در زبان گو خیلی زیبا می شود. select می تواند بطور همزمان داده را از کانال دریافت کند و برای اجرا سایر عملیات آماده کند. بنابراین select همراه با کانال و گوروتین خیلی ابزار قدرتمندی برای کنترل و مدیریت همگام سازی و همزمانی می شود.\n3.7.1.1 عملیات ارسال با select # در زیر یک مثالی زدیم که با استفاده از select داده ای را به کانال میریزیم و سپس آن داده را از کانال دیگر دریافت می کنیم :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 ch1 := make(chan string) 7 ch2 := make(chan string) 8 go goOne(ch1) 9 go goTwo(ch2) 10 select { 11 12 case msg1 := \u0026lt;-ch1: 13 fmt.Println(msg1) 14 case ch2 \u0026lt;- \u0026#34;To goTwo goroutine\u0026#34;: 15 } 16} 17 18func goOne(ch chan string) { 19 ch \u0026lt;- \u0026#34;From goOne goroutine\u0026#34; 20} 21 22func goTwo(ch chan string) { 23 msg := \u0026lt;-ch 24 fmt.Println(msg) 25} 1$ go run main.go 2To goTwo goroutine در کد فوق ما با استفاده از یکی از case های select داده‌ای را داخل کانال ریختیم و آن داده را داخل گوروتین تابع goTwo دریافت کردیم و پس آن مقدار دریافتی را چاپ کردیم.\n3.7.2 استفاده از default در select # در زبان گو switch و select می توانند یک default داشته باشند. در اینجا default مربوط select رفتارش همانند default داخل switch می باشد. حالا اگر هر یک از case ها عملیات دریافت یا ارسالی برای اجرا نداشته باشند می توانید با استفاده از default از بلاک شدن برای همیشه جلوگیری کنید. و خیلی مهمه که بدانید وقتی دارید داخل select از default استفاده می کنید select از نوع non-blocking می شود. اگر شما داخل select از default استفاده نکنید ممکن است آن بخش کد شما مسدود شود تا زمانیکه یکی از case ها از کانال داده ای را دریافت کند تا ادامه عملیات صورت گیرد.\nبه مثال زیر توجه کنید :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 ch1 := make(chan string) 7 select { 8 case msg := \u0026lt;-ch1: 9 fmt.Println(msg) 10 default: 11 fmt.Println(\u0026#34;Default statement executed\u0026#34;) 12 } 13} 1$ go run main.go 2Default statement executed در کد فوق ما یک کانال ایجاد کردیم و دریافت داده از کانال را داخل یکی از case های select قرار دادیم و پس از آن default را قرار دادیم که از مسدود شدن برنامه جلوگیری کند.\n3.7.3 مسدود سازی select با استفاده از timeout # شما می توانید یک select را با استفاده از timeout بطور موقت تا یک بازه زمانی مسدود کنید. که اینکار توسط تابع After داخل پکیج time صورت میگیرد.\n1func After(d Duration) \u0026lt;-chan Time تابع After یک مدت زمان میگیرد و سپس به عنوان خروجی یک کانال فقط دریافت از نوع Time برمیگرداند.\nبه مثال زیر توجه کنید :\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;time\u0026#34; 6) 7 8func main() { 9\tch1 := make(chan string) 10\tgo goOne(ch1) 11 12\tselect { 13\tcase msg := \u0026lt;-ch1: 14\tfmt.Println(msg) 15\tcase \u0026lt;-time.After(time.Second * 1): 16\tfmt.Println(\u0026#34;Timeout\u0026#34;) 17\t} 18} 19 20func goOne(ch chan string) { 21\ttime.Sleep(time.Second * 2) 22\tch \u0026lt;- \u0026#34;From goOne goroutine\u0026#34; 23} 1$ go run main.go 2Timeout کد کد فوق ما در یکی از case های select تابع After را به عنوان کانال دریافت کننده قرار دادیم و سپس مقدار ۱ ثانیه به تابع After پاس دادیم و پس از ۱ ثانیه select از مسدودی خارج شد.\n3.7.4 select خالی # یک select خالی و بدون case می تواند برنامه شما بطور کلی بلاک کند و باعث بروز خطای deadlock شود. اگر select خالی داخل یک گوروتین دیگری قرار گیرد آن گوروتین بطور کلی برای همیشه بلاک خواهد شد اما اگر داخل تابع main قرار دهید باعث بروز deadlock خواهد شد.\n1package main 2 3func main() { 4 select {} 5} 1$ go run main.go 2fatal error: all goroutines are asleep - deadlock! 3.7.5 استفاده از select در حلقه بینهایت # ما می توانیم select را داخل یک حلقه بینهایت قرار دهیم تا برای همیشه از case ها چندتا داده را بواسطه کانال دریافت کنیم و عملیاتی را انجام دهیم یا اینکه اگر قصد داریم که از هر یک از case ها داده‌ای را دریافت کردیم حلقه را متوقف کنیم اینکار را هم بواسطه return می توانیم انجام دهیم.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;time\u0026#34; 6) 7 8func main() { 9\tnews := make(chan string) 10\tgo newsFeed(news) 11 12\tprintAllNews(news) 13} 14 15func printAllNews(news chan string) { 16\tfor { 17\tselect { 18\tcase n := \u0026lt;-news: 19\tfmt.Println(n) 20\tcase \u0026lt;-time.After(time.Second * 1): 21\tfmt.Println(\u0026#34;Timeout: News feed finished\u0026#34;) 22\treturn 23\t} 24\t} 25} 26 27func newsFeed(ch chan string) { 28\tfor i := 0; i \u0026lt; 2; i++ { 29\ttime.Sleep(time.Millisecond * 400) 30\tch \u0026lt;- fmt.Sprintf(\u0026#34;News: %d\u0026#34;, i+1) 31\t} 32} 1$ go run main.go 2News: 1 3News: 2 4Timeout: News feed finished در کد فوق ما یک کانال بافر نشده با نام news ایجاد کردیم و این کانال را داخل گوروتین newsFeed و تابع printAllNews قرار داده‌ایم. تابع newsFeed یک مقداری را به کانال ارسال می کند. و ما داخل تابع printAllNews بواسطه حلقه بینهایت و select دریافت می کنیم و یکی از case های select عملیات timeout را دارد که بعد ۱ ثانیه حلقه را کاملا متوقف کند.\n3.7.6 select با یک کانال nil # معمولا اگر یک کانال nil را برای ارسال یا دریافت داخل case قرار دهید برنامه شما همیشه بلاک می شود. اگر شما داخل یکی از case ها بیاید پس از انجام عملیات مقدار یک کانال را nil بزارید case ای که مقدار داخل کانال را دریافت می کند غیرفعال می شود و به هیچ عنوان دیگر قابل استفاده نخواهد بود. و توسط select آن case کاملا نادیده گرفته خواهد شد و select منتظر دریافت و ارسال داده از سایر case ها خواهد بود.\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;time\u0026#34; 6) 7 8func main() { 9 news := make(chan string) 10 go newsFeed(news) 11 printAllNews(news) 12} 13 14func printAllNews(news chan string) { 15 for { 16 select { 17 case n := \u0026lt;-news: 18 fmt.Println(n) 19 news = nil 20 case \u0026lt;-time.After(time.Second * 1): 21 fmt.Println(\u0026#34;Timeout: News feed finished\u0026#34;) 22 return 23 } 24 } 25} 26 27func newsFeed(ch chan string) { 28 for i := 0; i \u0026lt; 2; i++ { 29 time.Sleep(time.Millisecond * 400) 30 ch \u0026lt;- fmt.Sprintf(\u0026#34;News: %d\u0026#34;, i+1) 31 } 32} 1$ go run main.go 2News: 1 3Timeout: News feed finished در کد فوق ما داخل case n := \u0026lt;-news پس از اینکه مقدار دریافتی را چاپ کردیم اومدیم مقدار کانال news را برابر nil قرار دادیم. حالا اگر داده‌ای به اون کانال ارسال شود دیگر نمی توانیم دریافت کنیم و select آن case را بطور کلی نادیده میگیرد.\n1case n := \u0026lt;-news: 2 fmt.Println(n) 3 news = nil 3.7.7 استفاده از break در select # شما می توانید break داخل هر یک از case های select استفاده کنید.\n1import \u0026#34;fmt\u0026#34; 2 3func main() { 4\tch := make(chan string, 1) 5\tch \u0026lt;- \u0026#34;Before break\u0026#34; 6 7\tselect { 8\tcase msg := \u0026lt;-ch: 9\tfmt.Println(msg) 10\tbreak 11\tfmt.Println(\u0026#34;After break\u0026#34;) 12\tdefault: 13\tfmt.Println(\u0026#34;Default case\u0026#34;) 14\t} 15} 1$ go run main.go 2Before break در کد فوق ما با استفاده از break توانستیم select را کاملا متوقف کنیم و برنامه اتمام شود و اگر دقت کرده باشید بعد از break کلمات After break چاپ نشده.\n1fmt.Println(\u0026#34;After break\u0026#34;) "},{"id":40,"href":"/chapter-3/go-context/","title":"3.8 پکیج context","section":"فصل سوم: همزمانی (concurrency)","content":" پکیج context یک پکیج built-in است که یکی از پرکاربرد ترین پکیج های زبان گو می باشد. کار اصلی این پکیج فراهم کردن بستری است که بتوان به داده های مشترک دسترسی داشت و یا بتوان آنها را به اشتراک گذاشت و مدیریت کرد. حتی اگر شما نخواسته باشید سمت این پکیج بروید به مرور زمان که جلوتر می روید با این پکیج رو به رو خواهید شد و مجبور خواهید بود این پکیج را یاد بگیرید.\nاین پکیج چندان بزرگ نیست و شاید بتوانید توابع و مفاهیم آن را حیلی زود یاد بگیرید اما دقت کنید یک روزی این پکیج میشه تبدیل به بنیادی ترین قسمت از کدهایتان خواهد شد.\nدر این بخش از کتاب سعی خواهد شد مفاهیم context به صورت ساده و قابل درکی بیان شود.\n3.8.1 context چیست؟ # در واقع context مانند یک درخت می باشد که کلی شاخه دارد و هر شاخه به شاخه های ریزتری تقسیم شده و در نهایت به برگ ها و میوه های درخت منتهی می شوند. حال شما می توانید در هر ناحیه شاخه والد را قطع کنید تا شاخه های فرزند از بین برود. در زبان گو context یک اینترفیس است که یکسری متد دارد که هریک از متدها می تواند عملیاتی را انجام دهد و این امکان را فراهم می کند هر وقت یک درخواست از سمت کلاینت به سرور می آید این درخواست می تواند در لایه های مختلف منتهی شود و داخل context می تواند یکسری key/value های مهم باشد که شما بتوانید در هر لایه، به آنها دسترسی داشته باشید و همچنین در صورت لزوم می توانید سیگنال cancel بفرستید که درخواستی که تا هرجا رفته است کنسل شود.\nدر ادامه با یک طرح یم مثال ساده به درک بهتر این موضوع کمک می کنیم :\nفرض کنید یک سرور http راه اندازی کردید (در فصل ۵ آشنا خواهید شد) که یکسری آدرس API دارد که کلاینت می تواند با استفاده از این آدرس ها با سرور شما ارتباط برقرار کند و عملیات مشخصی را انجام دهد. حال وقتی کلاینت درخواست می دهد. درخواست تا زمانیکه کامل شود و خروجی به کاربر نمایش داده شود می توانید این درخواست را بواسطه context در لایه های مختلف پروژه خود منتهی کنید و یکسری عملیات یا اطلاعات را در هر لایه از context بگیرید. اگر به دیاگرام فوق نگاه کنید اگر کلاینت درخواستش را لغو کند و درخواست کاربر به واسط context تا لایه Manager رفته باشد می تواند این درخواست در همان لایه متوقف شود و عملیات تکمیل نشود.\nبرای درک بهتر مثال فوق بهتره فایل صوتی زیر را گوش دهید تا بهتر بتوانید درک کنید :\nدانلود فایل صوت 3.8.1.1 کاربردهای context # لغو یک درخواستی که منتهی شده به لایه های مختلف پروژه بواسطه تابع cancel در پکیج context انتقال داده های حساس به لایه های مختلف بواسطه تابع WithValue در پکیج context گذاشتن timeout برروی context جهت لغو درخواستی که خیلی باعث منتظر ماندن می شود بواسطه تابع WithTimeout در پکیج context 3.8.1.2 معرفی اینترفیس context # بدنه اصلی یک context از اینترفیس تشکیل شده که یکسری متدها برای مدیریت یک درخواست برروی لایه های مختلف را دارد.\n1type Context interface { 2 //It retures a channel when a context is cancelled, timesout (either when deadline is reached or timeout time has finished) 3 Done() \u0026lt;-chan struct{} 4 5 //Err will tell why this context was cancelled. A context is cancelled in three scenarios. 6 // 1. With explicit cancellation signal 7 // 2. Timeout is reached 8 // 3. Deadline is reached 9 Err() error 10 11 //Used for handling deallines and timeouts 12 Deadline() (deadline time.Time, ok bool) 13 14 //Used for passing request scope values 15 Value(key interface{}) interface{} 16} متد Done : بواسطه این متد که یک کانال فقط دریافت است شما می توانید سیگنال توقف درخواست را دریافت کنید و خطا برگردانید. متد Err : داخل این متد اینترفیس خطا وجود دارد که خطاهای مربوط به context را می توانید دریافت و مدیریت کنید. متد Deadline : با استفاده از این متد می توانید context هایی که از نوع Deadline هستند را مدیریت کنید. متد Value : با استفاده از این می توانید مقادیری که بصورت key/value داخل context ذخیره شده را دریافت کنید که بصورت اینترفیس یک key میگیرد و به صورت اینترفیس مقدار داخل key را برمیگرداند. 3.8.2 ایجاد یک context # شما با استفاده از ۲ تابع داخل پکیج context می توانید اولین context خام را ایجاد کنید و در واقع این context ایجاد شده می تواند والد تمامی context هایی که در لایه مختلف ایجاد کردید باشد.\nبرای ایجاد context گفتیم ۲ تابع وجود دارد که به شرح زیر می باشد :\ncontext.Background() : # داخل پکیج context ما یک تابع داریم به نام Background یک اولین context خام و والد را میسازد و به شما یک اینترفیس از نوع Context می دهد.\nاین context ایجاد شده هیچ مقداری داخلش ندارد. هیچ وقت نمی تواند کنسل شود. و هیچ deadline ندارد. در هر صورت بدانید ریشه اصلی context شما با این تابع ایجاد می شود و نقطه شروع انتقال یک درخواست بین لایه هایتان با این context والد خواهد بود.\n1func Background() Context context.ToDo() : # داخل پکیج context ما یک تابع داریم به نام ToDo که یک context خالی ایجاد می کند و هدف از این context ایجاد شده با ToDo این است هنوز برایمان مشخص نیست چکار میخوایم انجام بدیم با context می توانیم از این تابع استفاده کنیم. و معمولا برای تست ها و اعتبارسنجی و آنالیز کد خیلی کاربردی هست.\nو دقت کنید در پایه اصلی پروژه اتون بهتره از Background همیشه استفاده کنید.\n1func TODO() Context 3.8.3 درخت Context # در واقع context خام یا ریشه که بواسطه تابع Background یا ToDo ایجاد می شود همانند یک درخت است که قرار است این درخت به شاخه های ریزتری تقسیم شود و هر یک از شاخه ها عملیات مختلفی کنترل شود و به شاخه های دیگر منتقل شود.\n3.8.3.1 ایجاد یک فرزند برای context # شما خیلی ساده مانند کد زیر می توانید یک فرزند برای درخت خود ایجاد کنید :\n1rootCtx := context.Background() 2childCtx := context.WithValue(rootCtx, \u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;) در کد فوق ما یک rootCtx ایجاد کردیم که همان درخت است و سپس اومدیم با استفاده از تابع WithValue یک شاخه ایجاد کردیم که داخل این شاخه یک key/value قرار دارد. که این key/value در لایه های دیگر که منتقل می شود قرار دارد.\n3.8.3.2 ایجاد دو فرزند برای context # 1rootCtx := context.Background() 2childCtx := context.WithValue(rootCtx, \u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;) 3childOfChildCtx, cancelFunc := context.WithCancel(childCtx) در کد فوق :\nrootCtx درخت است childCtx فرزند اول است که با استفاده از WithValue ایجاد شده و یک مقدار key/value را نگه داری می کند. childOfChildCtx برای فرزند اول context ما یک فرزند دیگری ایجاد کردیم با استفاده از تابع WithCancel که این تابع به شما یک context و یک تابع از نوع cancelFunc برمیگرداند. 3.8.3.3 درخت چند سطحی # 1rootCtx := context.Background() 2childCtx1 := context.WithValue(rootCtx, \u0026#34;key1\u0026#34;, \u0026#34;value1\u0026#34;) 3childCtx2, cancelFunc := context.WithCancel(childCtx1) 4childCtx3 := context.WithValue(rootCtx, \u0026#34;user_id\u0026#34;, \u0026#34;some_user_id\u0026#34;) در کد فوق :\nrootCtx درخت است childCtx1 فرزند اول است که با استفاده از WithValue ایجاد شده و یک مقدار key/value را نگه داری می کند. childCtx2 برای فرزند اول context ما یک فرزند دیگری ایجاد کردیم با استفاده از تابع WithCancel که این تابع به شما یک context و یک تابع از نوع cancelFunc برمیگرداند. childCtx3 با استفاده از WithValue از rootCtx که درخت است تشکیل شده حالا اگر ما برای childCtx1 بیایم یک فرزند دیگر با نام childCtx4 اضافه کنیم بصورت زیر خواهد شد :\n1childCtx4 := context.WithValue(childCtx1, \u0026#34;current_time\u0026#34;, \u0026#34;some_time) 3.8.4 تابع context.WithValue # همانطور که گفتیم شما با استفاده از تابع WithValue می توانید مقادیری را بصورت key/value به context اضافه کنید و سپس این مقادیر را با استفاده از context به لایه های مختلف منتقل کنید.\n1withValue(parent Context, key, val interface{}) (ctx Context) دقت کنید شما می توانید بواسطه context.WithValue مقادیر خیلی مهم و حساس نظیر توکن ها و \u0026hellip; را به لایه های مختلف خود منتقل کنید و این مورد خیلی قابل اهمیت است با استفاده از context انجام دهید. 1// Root Context 2ctxRoot := context.Background() 3 4// Below ctxChild has acess to only one pair {\u0026#34;a\u0026#34;:\u0026#34;x\u0026#34;} 5ctxChild := context.WithValue(ctxRoot, \u0026#34;a\u0026#34;, \u0026#34;x\u0026#34;) 6 7// Below ctxChildofChild has access to both pairs {\u0026#34;a\u0026#34;:\u0026#34;x\u0026#34;, \u0026#34;b\u0026#34;:\u0026#34;y\u0026#34;} as it is derived from ctxChild 8ctxChildofChild := context.WithValue(ctxChild, \u0026#34;b\u0026#34;, \u0026#34;y\u0026#34;) در بالا ما یک ctxRoot ایجاد کردیم و سپس یک فرزند با استفاده از تابع WithValue ایجاد کردیم که یک مقدار از نوع key/value با نام a را داخل context فرزند قرار دادیم. حالا برای context فرزند مجدد با استفاده از WithValue یک فرزند دیگری ایجاد کردیم که یک مقدار دیگر از نوع key/value با نام b قرار دادیم حالا اگر دقت کنید ctxChildofChild دارای ۲ مقدار a و b هستش.\nبزارید یک مثال ساده بزنیم :\n1package main 2 3import ( 4\t\u0026#34;context\u0026#34; 5\t\u0026#34;fmt\u0026#34; 6) 7 8func main() { 9\tctx := context.WithValue(context.Background(), \u0026#34;language\u0026#34;, \u0026#34;Go\u0026#34;) 10 11\tfmt.Println(manager(ctx, \u0026#34;language\u0026#34;)) 12} 13 14func manager(ctx context.Context, key string) string { 15\tif v := ctx.Value(key); v != nil { 16\treturn v.(string) 17\t} 18\treturn \u0026#34;not found value\u0026#34; 19} 1$ go run main.go 2Go در کد فوق ما یک context ایجاد کردیم و داخلش با استفاده از WithValue مقدار key/value قرار دادیم و سپس این context را تابع manager پاس دادیم و داخل تابع manager ما با استفاده از متد Value که داخل اینترفیس ctx هست مقدار کلید language را گرفتیم.\nنکته کاربردی و مهم همیشه سعی کنید context را به عنوان اولین پارامتر برای توابع تعریف کنید. و بهتر است برای نام پارامتر ctx یا c بزارید. 3.8.5 تابع context.WithCancel # زمانیکه شما با استفاده از تابع WithCancel یک context فرزند ایجاد می کنید ۲ تا خروجی به شما می دهد اولی context و دومی تابع cancel می باشد. که شما می توانید تابع cancel را برای لغو درخواستی که از سمت کلاینت یا لایه های بالاتر اومده را انجام دهید.\n1type CancelFunc func() 2 3func WithCancel(parent Context) (ctx Context, cancel CancelFunc) حالا با استفاده از مثال زیر میتوانید بحث لغو کردن را بهتر درک کنید :\n1package main 2 3import ( 4 \u0026#34;context\u0026#34; 5 \u0026#34;fmt\u0026#34; 6 \u0026#34;time\u0026#34; 7) 8 9func main() { 10 ctx := context.Background() 11 cancelCtx, cancelFunc := context.WithCancel(ctx) 12 go task(cancelCtx) 13 time.Sleep(time.Second * 3) 14 cancelFunc() 15 time.Sleep(time.Second * 1) 16} 17 18func task(ctx context.Context) { 19 i := 1 20 for { 21 select { 22 case \u0026lt;-ctx.Done(): 23 fmt.Println(\u0026#34;Gracefully exit\u0026#34;) 24 fmt.Println(ctx.Err()) 25 return 26 default: 27 fmt.Println(i) 28 time.Sleep(time.Second * 1) 29 i++ 30 } 31 } 32} 1$ go run main.go 21 32 43 5Gracefully exit 6context canceled در کد فوق ما یک context فرزند با استفاده از WithCancel ایجاد کردیم که به عنوان خروجی cancelCtx و cancelFunc را داد. سپس cancelCtx را به تابع task منتقل کردیم تا عملیاتی را انجام دهد. حال در ادامه کد تابع main ما یک Sleep در حد ۳ ثانیه گذاشتیم و گفتیم تابع cancelFunc اجرا شود. اگر دقت کنید پس ۳ ثانیه سیگنال لغو به تابع task ارسال شده و خطای Gracefully exit را چاپ کردیم و پس از آن خطای context چاپ کردیم.\nنکته کاربردی و مهم همیشه سعی کنید تابع cancelFunc را پس از اینکه context فرزند را با WithCancel ایجاد کردید داخل defer قرار دهید.\n1ctx := context.Background() 2cancelCtx, cancelFunc := context.WithCancel(ctx) 3defer cancelFunc() 3.8.6 تابع context.WithTimeout # تابع WithTimeout یکی از کاربردی ترین context ها را برای ما ایجاد میکند و باعث می شود جلوی طول کشیدن یک درخواست خارجی یا عملیاتی را بگیرد و درخواست را لغو کند. این تابع همانند تابع WithCancel به شما تابع cancelFunc را می دهد و در عوض از شما یک مدت زمان را میگیرد.\n1func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) بزارید یک مثال ساده بزنیم :\n1package main 2 3import ( 4 \u0026#34;context\u0026#34; 5 \u0026#34;fmt\u0026#34; 6 \u0026#34;time\u0026#34; 7) 8 9func main() { 10 ctx := context.Background() 11 cancelCtx, cancel := context.WithTimeout(ctx, time.Second*3) 12 defer cancel() 13 go task1(cancelCtx) 14 time.Sleep(time.Second * 4) 15} 16 17func task1(ctx context.Context) { 18 i := 1 19 for { 20 select { 21 case \u0026lt;-ctx.Done(): 22 fmt.Println(\u0026#34;Gracefully exit\u0026#34;) 23 fmt.Println(ctx.Err()) 24 return 25 default: 26 fmt.Println(i) 27 time.Sleep(time.Second * 1) 28 i++ 29 } 30 } 31} 1$ go run main.go 21 32 43 5Gracefully exit 6context deadline exceeded در کد فوق ما یک context فرزند با استفاده از تابع WithTimeout ایجاد کردیم و مدت زمان ۳ ثانیه به این تابع پاس دادیم و پس از آن context فرزند به همراه تابع cancelFunc دریافت کردیم. حالا تابع cancel را داخل defer قرار دادیم و cancelCtx را به تابع task1 که داخل گوروتین است پاس داده ایم سپس و یک Sleep به مدت ۴ ثانیه گذاشتیم تا، تابع main کارش تمام نشود. حال پس از اینکه ۳ ثانیه گذشت داخل select سیگنال cancel را دریافت کردیم و خطای context deadline exceeded که نشان دهنده اتمام شدن مدت زمان هست را چاپ کرده ایم. همانطور که متوجه شدید درخواست کلی ما لغو شده.\n3.8.7 تابع context.WithDeadline # تابع WithDeadline تا حدی شبیه به WithTimeout است اما با این تفاوت که پارامتر زمانی که میگیرد از نوع time.Time است و مدت زمانی که میگیرد براساس تایم هست مثلا شما میگید ۵ ثانیه بعد از زمان الان درخواست را لغو کند در صورتیکه withTimeout مدت زمان میگیرد که درخواست ۵ ثانیه مهلت دارد کارش را انجام دهد.\n1func WithDeadline(parent Context, d time.Time) (Context, CancelFunc) به مثال زیر توجه کنید :\n1package main 2 3import ( 4 \u0026#34;context\u0026#34; 5 \u0026#34;fmt\u0026#34; 6 \u0026#34;time\u0026#34; 7) 8 9func main() { 10 ctx := context.Background() 11 cancelCtx, cancel := context.WithDeadline(ctx, time.Now().Add(time.Second*5)) 12 defer cancel() 13 go task(cancelCtx) 14 time.Sleep(time.Second * 6) 15} 16 17func task(ctx context.Context) { 18 i := 1 19 for { 20 select { 21 case \u0026lt;-ctx.Done(): 22 fmt.Println(\u0026#34;Gracefully exit\u0026#34;) 23 fmt.Println(ctx.Err()) 24 return 25 default: 26 fmt.Println(i) 27 time.Sleep(time.Second * 1) 28 i++ 29 } 30 } 31} 1$ go run main.go 21 32 43 54 65 7Gracefully exit 8context deadline exceeded در کد فوق یک context فرزند با استفاده از تابع WithDeadline ایجاد کردیم و سپس با توجه به زمان فعلی مدت زمان ۵ ثانیه بعد را درنظر گرفتیم که مثلا اگر الان ساعت است 10:45:30 درخواست را در 10:45:35 لغو کند.\n3.8.8 نکات کاربردی # هیچوقت سعی نکنید اینترفیس context را داخل یک ساختار ذخیره کنید اما می توانید embed کنید. همیشه context باید بین لایه‌های خود منتقل کنید تا بتوانید کنترل بهتری برروی درخواست ها داشته باشید. همیشه سعی کنید context را به عنوان اولین پارامتر توابع قرار دهید. نام context به عنوان پارامتر توابع بهتر است ctx یا c باشد. اگر هنوز مطمئن نیستید که با context چکاری میخواهید انجام دهید بهتر است context را با context.ToDo ایجاد کنید. توجه کنید فقط تابعی که context والد را ایجاد کرده می تواند درخواست را لغو کند پس سعی نکنید تابع cancelFunc را به توابع زیرین پاس دهید. "},{"id":41,"href":"/chapter-3/go-concurrency-teqniques/","title":"3.9 تکنیک های همزمانی","section":"فصل سوم: همزمانی (concurrency)","content":" 3.9.1 ارسال سیگنال انجام شدن با کانال ساختار # شما می توانید با استفاده از کانال struct سیگنالی برای تکمیل شدن انجام یک کار را بفرستید.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;time\u0026#34; 6) 7 8func task1(done chan struct{}) { 9\t// Do some work here 10\tfmt.Println(\u0026#34;doing task 1\u0026#34;) 11 12\ttime.Sleep(2 * time.Second) 13 14\tfmt.Println(\u0026#34;task 1 has been completed\u0026#34;) 15\tdone \u0026lt;- struct{}{} 16} 17 18func task2(done \u0026lt;-chan struct{}) { 19\tselect { 20\tcase \u0026lt;-done: 21\t// Do some work here 22\tfmt.Println(\u0026#34;doing task 2\u0026#34;) 23\ttime.Sleep(2 * time.Second) 24\tfmt.Println(\u0026#34;task 2 has been completed\u0026#34;) 25\t} 26} 27 28func main() { 29\tdone := make(chan struct{}) 30 31\tgo task1(done) 32\tgo task2(done) 33 34\ttime.Sleep(5 * time.Second) 35\tfmt.Println(\u0026#34;all tasks has been completed\u0026#34;) 36} 1$ go run main.go 2doing task 1 3task 1 has been completed 4doing task 2 5task 2 has been completed 6all tasks has been completed در کد فوق ما دو تابع به نام task1 و task2 داریم که داخل گوروتین هستند و به عنوان پارامتر ورودی یک کانال ساختار خالی میگیرد حال کانال ساختار را به هر دو تابع پاس دادیم در ابتدا task1 فرآیند خود را انجام می دهد و سپس سیگنال انجام شدن را می فرستد و در ادامه تابع task2 سیگنال را دریافت می کند و فرآیندهای خود را انجام می دهد.\nدر زبان گو شما وقتی یک struct کاملا خالی و بدون فیلد میسازید هیچ تخصیص حافظه‌ای برایش صورت نمیگیرد. 3.9.2 بررسی یک سرویس یا فرآیند با heartbeat # شما با استفاده از همزمانی می توانید یک heartbeat پیاده سازی کنید تا یک سرویس یا فرآیند را بطور مداوم طی بازه زمانی مشخصی زیر نظر داشته باشد و از وضعیت آن سرویس یا فرآیند به شما اطلاع دهد.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;time\u0026#34; 6) 7 8func heartbeat(interval time.Duration, c chan\u0026lt;- struct{}) { 9 ticker := time.NewTicker(interval) 10\tfor { 11\tselect { 12\tcase \u0026lt;-ticker.C: 13\tc \u0026lt;- struct{}{} 14\t} 15\t} 16} 17 18func task() { 19\t// Do some work here 20\tfmt.Println(\u0026#34;Task running...\u0026#34;) 21} 22 23func main() { 24\tc := make(chan struct{}) 25\tgo heartbeat(1*time.Second, c) 26 27\tfor { 28\tselect { 29\tcase \u0026lt;-c: 30\ttask() 31\t} 32\t} 33} 1$ go run main.go 2Task running... 3Task running... 4Task running... 5Task running... در کد فوق ما یک تابع به نام heartbeat ایجاد کردیم که طی مدت زمانی یک سیگنال می فرستد تا تابع task اجرا شود که وضعیت فرآیند یا سرویس را گزارش دهد. ما مدت زمان را ۱ ثانیه گذاشتیم و یک کانال ساختار ایجاد کردیم و به تابع heartbeat که داخل یک گوروتین هست پاس دادیم سپس هر ۱ ثانیه از طریق کانال c ما سیگنال اجرای task برای بررسی وضعیت سرویس یا فرآیند را دریافت میکنیم.\n3.9.3 ارسال درخواست‌های تکراری به سرور یا سرویسی # فرض کنید شما نیاز دارید به یک سرور یا سرویسی چندین درخواست تکراری را بصورت موازی بفرستید که به اینکار replicated requests می گویند.\nبه مثال زیر توجه کنید :\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;net/http\u0026#34; 6) 7 8func makeRequest(url string, c chan\u0026lt;- *http.Response) { 9 resp, err := http.Get(url) 10 if err != nil { 11 c \u0026lt;- nil 12 } else { 13 c \u0026lt;- resp 14 } 15} 16 17func main() { 18 urls := []string{\u0026#34;http://example.com\u0026#34;, \u0026#34;http://example.org\u0026#34;, \u0026#34;http://example.net\u0026#34;} 19 20 c := make(chan *http.Response) 21 defer close(c) 22 for _, url := range urls { 23 go makeRequest(url, c) 24 } 25 26 for i := 0; i \u0026lt; len(urls); i++ { 27 resp := \u0026lt;-c 28 if resp == nil { 29 fmt.Println(\u0026#34;Error making request\u0026#34;) 30 } else { 31 fmt.Println(resp.Status) 32 } 33 } 34} 1$ go run main.go 2200 OK 3200 OK 4200 OK در کد فوق ما یک تابع makeRequest داریم که ۲ تا پارامتر ورودی دارد اولین پارامتر url میگیرد و دومین پارامتر یک کانال فقط ارسال از نوع http.Response* میگیرد. سپس یک ریکوئست با متد GET ایجاد میکند و خروجی را داخل کانال میفرستد. در تابع main ما یک لیست url داریم که قرار است بصورت موازی به این آدرس ها درخواست بفرستیم و خروجی را دریافت کنیم در اینجا یک کانال از نوع http.Response* ایجاد کردیم و سپس یک حلقه for-range قرار دادیم و به ازای هر یک از url ها تابع makeRequest را فراخوانی کرده‌ایم و سپس داخل گوروتین قرار داده‌ایم، در نهایت یک حلقه for-i داریم که به تعداد url ها شمارش میکند و از طریق کانال ریسپانس را دریافت می کند.\n3.9.4 بازیابی سلامتی یک گوروتین # در برنامه نویسی همزمانی خیلی مهم است شما به سلامتی یک گوروتین رسیدگی کنید که اگر گوروتین قادر به انجام کاری نیست مجدد بتوانید سلامتی گوروتین را بازیابی کنید. در زبان گو شما می توانید با استفاده از پکیج context گوروتین هایی که وضعیت سالمی ندارد را با راه اندازی مجدد سلامتی آنها را بازیابی کنید.\n1package main 2 3import ( 4\t\u0026#34;context\u0026#34; 5\t\u0026#34;fmt\u0026#34; 6\t\u0026#34;time\u0026#34; 7) 8 9func unhealthyGoroutine(ctx context.Context) { 10\tfor { 11\tselect { 12\tcase \u0026lt;-ctx.Done(): 13\tfmt.Println(\u0026#34;Goroutine is unhealthy, exiting\u0026#34;) 14\treturn 15\tdefault: 16\t// Do some work here 17\tfmt.Println(\u0026#34;Goroutine running...\u0026#34;) 18\ttime.Sleep(500 * time.Millisecond) 19\t} 20\t} 21} 22 23func main() { 24\tctx, cancel := context.WithTimeout(context.Background(), 3*time.Second) 25\tdefer cancel() 26 27\tfor { 28\tgo unhealthyGoroutine(ctx) 29\t\u0026lt;-time.After(4 * time.Second) 30\t} 31} 1$ go run main.go 2Goroutine running... 3Goroutine running... 4Goroutine running... 5Goroutine running... 6Goroutine running... 7Goroutine running... 8Goroutine is unhealthy, exiting 9Goroutine is unhealthy, exiting 10Goroutine is unhealthy, exiting 11Goroutine is unhealthy, exiting 12Goroutine is unhealthy, exiting 13Goroutine is unhealthy, exiting در کد فوق ما یک تابع به نام unhealthyGoroutine داریم که بصورت جداگانه در گوروتین های مختلف اجرا می شود و کاری را انجام می دهد. داخل تابع ما یک select داریم که در یکی از case هایش context.Done را بررسی میکنیم آیا فرآیند لغو شده است یا خیر. داخل تابع main ما یک context از نوع Timeout با مدت زمان ۳ ثانیه‌ای ایجاد کردیم و در ادامه داخل یک حلقه بینهایت تابع unhealthyGoroutine داخل گوروتین قرار دادیم و هر ۴ ثانیه یک نمونه از این تابع داخل گوروتین های مختلف اجرا می شود.\nدر اینجا کارهای داخل تابع unhealthyGoroutine انجام شود پس از ۳ ثانیه بواسطه context فرآیندها لغو می شود و از گوروتین خارج می شود. حال ما داخل تابع main اجازه دادیم یک گوروتین جدید و سالم را اجرا کند و جایگزین گوروتین ناسالم شود.\n3.9.5 پیاده سازی الگوریتم فیبوناچی با همزمانی # دنباله فیبوناچی مجموعه‌ای از اعداد است که در آن هر عدد حاصل جمع دو عدد قبلی است که معمولا با 0 و 1 شروع می شود. ، 55، 89، 144 و غیره. دنباله فیبوناچی به نام ریاضیدان ایتالیایی، لئوناردو پیزا، که به فیبوناچی نیز معروف بود، نامگذاری شده است. الگوریتم فیبوناچی روشی برای محاسبه عدد n در دنباله فیبوناچی است. روش‌های مختلفی برای پیاده‌سازی الگوریتم فیبوناچی وجود دارد، اما رایج‌ترین روش استفاده از بازگشت است.\nدر علوم و مهندسی کامپیوتر، از دنباله فیبوناچی برای تحلیل عملکرد الگوریتم هایی مانند برج هانوی و تکنیک جستجوی فیبوناچی استفاده می شود.\nدر زیر ما برای اینکه بتوانید در سریعترین حالت ممکن محاسبات را انجام دهیم خیلی ساده می توانیم از همزمانی و کانال استفاده کنیم و در کسری از ثانیه محاسبه کنیم.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7func fibo(n int) \u0026lt;-chan int { 8\tresult := make(chan int) 9\tgo func() { 10\tdefer close(result) 11 12\tif n \u0026lt;= 2 { 13\tresult \u0026lt;- 1 14\treturn 15\t} 16 17\tresult \u0026lt;- \u0026lt;-fibo(n-1) + \u0026lt;-fibo(n-2) 18 19\t}() 20 21\treturn result 22} 23 24func main() { 25\tfmt.Println(\u0026lt;-fibo(25)) 26} 1$ go run main.go 275025 "},{"id":42,"href":"/chapter-3/go-concurrency-patterns/","title":"3.10 الگو های همزمانی","section":"فصل سوم: همزمانی (concurrency)","content":"الگو های همزمانی را در فصل ۹ در کنار سایر الگوهای طراحی قرار دادیم یک مرجع کامل از الگوهای طراحی برای زبان گو داشته باشیم. در این بخش فقط ما خلاصه توضیحی در خصوص الگوها قرار دادیم و شما را ارجاع می دهیم به صفحه الگو :\nعنوان توضیحات وضعیت Wait For Result با استفاده از الگو Wait For Result می توانید یک عملیاتی را بصورت همزمانی انجام دهید و سپس منتظر نتیجه عملیات صورت گرفته بمانید. برای اینکار از کانال استفاده می شود. ✅ Fan Out/In الگو Fan Out/In یک تکنیک همزمانی در زبان گو می باشد که به شما اجازه می دهد چندین کار را با گوروتین همزمان انجام دهید و در نتیجه خروجی این کارها را با هم ترکیب کنید و به عنوان نتیجه نهایی دریافت کنید. ✅ Wait For Task الگو wait for task یکی از الگوهای رایج در زبان گو می باشد و انتظار برای تکمیل یک تسک یا فرآیند استفاده می شود. یک تسک با استفاده از گوروتین اجرا می شود و پس اتمامش کار تسک از طریق کانال سیگنال انجام می فرستد. ✅ Drop الگو Drop یک الگو مهم برای انجام خدمات سنگین می باشد. خدماتی که مواقعی باعث می شود حجم درخواست هایش بیش از ظرفیت موجود باشد و این درخواست ها بواسطه این الگو می تواند Drop شود. به عنوان مثال سرویس های DNS باید از این الگو استفاده کنند. ✅ Cancellation الگو cancellation که حرکت تکنیکی هست برای ارسال سینگال به گوروتین ها استفاده می شود که باید اجرای کاری را متوقف کند و ایده اصلی این کار با استفاده بستن کانال صورت میگیرد. ✅ Semaphore الگو Semaphore برای مدیریت کنترل دسترسی به منابع مشترک در همزمانی استفاده می شود. فرض کنید بصورت موازی ۱۰۰ درخواست HTTP سمت سرور میاد و I/O شبکه برای پردازش همزمان این ۱۰۰ درخواست درگیر میشود و به مرور عملکرد کاهش می یابد. حال اگر ما بیایم این ۱۰۰ درخواست موازی را تقسیم کنیم به ۵ دسته ۲۰ تایی که بصورت همزمانی انجام شود باعث می شود I/O شبکه کاهش یابد و عملکرد بهتری را خواهیم داشت. ✅ Bounded Work Pooling با استفاده از الگو Bounded Work Pooling امکان محدود سازی تعداد گوروتین ها را براساس کار مشخصی دارید و گوروتین ها را محدود به تعداد دفعات کار مشخص شده محدود می شود. این الگو برای وقت مفید است که شما می خواهید منابع را به یک کار خاص محدود کنید. ✅ Retry Timeout شما از الگو Retry Timeout برای تلاش مجدد یکسری عملیات استفاده کنید. برای اینکار شما می توانید از حلقه و تابع After در پکیج time کمک بگیرید و برای هرتلاش یک timeout مشخص کنید. ✅ Channel Cancellation از کانال ها برای ارتباط بین گوروتین ها و هماهنگ کردن اجرا استفاده می شود. حال گاهی اوقات نیاز است که ما یکسری فرآیند را داخل گوروتین لغو کنیم. در اینجا می توانیم با استفاده از کانال سیگنال لغو کردن بفرستید تا عملیات هایی که گوروتین مورد نظر انجام می داد لغو شود. ✅ Producer-Consumer الگو producer-consumer یکی از کاربردی ترین الگوها در زبان گو می باشد که با استفاده از الگو می توانید بطور همزمان یکسری اطلاعات تولید کنید و بفرستید داخل کانال و این اطلاعات توسط مصرف کننده بواسطه کانال دریافت شود. ✅ Monitor الگوی مانیتور به گروتین‌ ها اجازه می‌دهد هنگام ورود به حالت خواب بدون مسدود کردن اجرا یا مصرف منابع، منتظر شرایط خاصی باشند. ✅ Future در زبان گو الگو Future راهی برای نمایش نتیجه یک عملیات ناهمزمان (asynchronous) است که ممکن است آن عملیات هنوز تکمیل نشده باشد اما این الگو به شما این امکان را می دهد کدی بنویسید که طوری رفتار کند که گویی نتیجه یک عملیات فورا در دسترس است. حتی اگر عملیات در پس زمینه در حال اجرا باشد. ✅ Pipeline الگو خط لوله (Pipeline) یکی از پرکاربردی ترین الگوها در همزمانی می باشد شما با استفاده از این الگو می توانید تسک های بزرگ را به تسک های کوچکتر و مستقل تقسیم کنید که می توانند بطور همزمان کار کنند. هر stage داخل یک گوروتین انجام می شود و بواسطه کانال داده ها بین stage های مختلف منتقل می شود. ✅ Subscription الگو Subscription یکی از الگوهای کاربردی برای پیاده سازی consumer می باشد که به یک آدرسی مشترک شوید و در بازده زمانی مختلف درخواست دهید و یکسری اطلاعات دریافت کنید. ✅ Bridge Channel با استفاده از الگو Bridge Channel می توانید بین ۲ کانال داده ای را منتقل کنید فرض کنید یک داده را به کانال input میفرستید و از دریافت داده آن را می توانید به کانال دیگری منتقل کنید و عملا شما یک پل برای انتقال داده ایجاد کردید. ✅ Queuing الگوی \u0026ldquo;صف\u0026rdquo; در زبان گو الگویی است که در آن از یک گوروتین برای بافر کردن و مدیریت ترتیب مقادیر ارسال شده و دریافت شده از یک کانال استفاده می شود. ✅ "},{"id":43,"href":"/chapter-4/","title":"فصل چهارم: مباحث پیشرفته","section":"صفحه اصلی","content":"در این بخش به مباحث پیشرفته تری از زبان گو می پردازیم که شامل بخش های زیر می باشد.\n۴.۱ پروژه Build آموزش ‌. ۴.۲ Debuggingآموزش کار با. ۴.۳ go mod آموزش کار با . ۴.۴ workspace آموزش کار با. ۴.۵ Vendor آموزش کار با. ۴.۶ command line آموزش نوشتن برنامه. آموزش کار با فایل ۴.۷. ۴.۸ json آموزش کار با. ۴.۹ toml آموزش کار با. ۴.۱۰ yaml آموزش کار با. ۴.۱۱ CSV آموزش کار با. ۴.۱۲ ini آموزش کار با. ۴.۱۳ enviroment variable آموزش کار با. ۴.۱۴ regexp آموزش کار با. ۴.۱۵ reflection آموزش. ۴.۱۶ generator آموزش. ۴.۱۷ stringerآموزش. تکنیک های کد نویسی زبان گو ۴.۱۸. اصول کامنت نویسی ۴.۱۹. قوانین کد نویسی در زبان گو ۴.۲۰. ۴.۲۱ (garbage collector)زباله جمع کن. ۴.۲۲ Plugin کتابخانه. ۴.۲۳ شی گرایی در زبان گو. "},{"id":44,"href":"/chapter-4/build-go-file/","title":"4.1 آموزش Build پروژه","section":"فصل چهارم: مباحث پیشرفته","content":"برای build یک پروژه شما باید از کامند go build استفاده کنید که این کامند دارای یکسری سوییچ می باشد که در زیر ما معرفی خواهیم کرد.\n4.1.1 نحوه build یک فایل گو # معمولا شما باید برای build فایلی که دارای package main هست را برای build استفاده کنید مانند مثال زیر :\n1$ go build main.go پس از build در محل همان فایل یک فایل با نام main ایجاد می شود.\nاگر فایل main شما در روت پروژه باشد نیازی نیست به دستور go build نام فایل را بدهید کافیه مانند دستور زیر پروژه را build کنید.\n1$ go build . خروجی یک فایل با نام پروژه ایجاد می شود.\n4.1.2 استفاده از gcflags برای build # همانطور که گفتیم کامند build دارای یکسری سوییچ می باشد که یکی از سوییچ هایش gcflags می باشد که می توانید هنگام build یکسری اطلاعات مربوط به دیباگ به فایل خروجی اضافه می شود.\n1$ go build -gcflags \u0026#34;-N -l\u0026#34; main.go توجه کنید این نوع build گرفتن برای انجام Remote Debugging که در بخش بعدی آموزش می دهیم خیلی کاربردی می باشد.\n4.1.3 تعیین نام خروجی فایل, معماری و سیستم عامل # اگر یادتان باشد در بخش تاریخچه زبان گو یکی از ویژگی های بارزی که در خصوص زبان گو گفتیم بحث Cross-Platform Build بود که شما می توانید در همان سیستم عاملی که هستید برای سایر پلت فرم ها و سیستم عامل ها خروجی بگیرید.\n1$ GOOS=linux GOARCH=amd64 go build -o myproject main.go کامند فوق در لینوکس و سیستم عامل های یونیکسی کاربردی است که شما می توانید قبل از فرمان اصلی یکسری environment variables تعیین کنید. که در کامند فوق ما ۲ تا environment قرار دادیم اولی برای تعیین سیستم عامل هست و دومی معماری هست که ۳۲ بیت یا ۶۴ بیت و همچنین از نوع arm باشد. سپس فرمان go build را قرار دادیم حال خروجی فایل مناسب برای هر سیستم عامل لینوکس با معماری amd64 (۶۴ بیت) می باشد. و در انتهای کامند یک سوییچ o- قرار دادیم که نام خروجی فایل build شده چی باشد.\n4.1.4 گرفتن build به همراه race detector # در فصل سوم یک بخشی داشتیم به نام data race که در خصوصش توضیح دادیم چطور جلوی این اتفاق را در همزمانی بگیریم. حال یک سوییچ در کامند build داریم به نام race- برای تشخیص data race کمک می کند.\n1$ go build -race 4.1.5 مقدار دهی متغیر هنگام build # اما یکی از سوییچ های خیلی جالب در زبان گو هست که هنگام build پروژه می تواند متغیری را در هرجای پروژه مقدار دهی کند و از کاربردهای آن می توان برای تعیین ورژن پروژه و\u0026hellip; می باشد.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5var ( 6\tVersion string 7\tBuildTime string 8) 9 10func main() { 11\tfmt.Printf(\u0026#34;version %s, build time %s\u0026#34;, Version, BuildTime) 12} 1$ go build -ldflags \u0026#34;-X main.Version=1.0.0 -X main.BuildTime=`date -u +%Y-%m-%dT%H:%M:%SZ`\u0026#34; main.go 1$ ./main 2version 1.0.0, build time 2023-01-27T14:19:23Z در کد فوق ما ۲ متغیر ایجاد کردیم که هنگام build مقدار دهی کنیم و به کامند build ما یک سوییچ ldflags- اضافه کردیم و آدرس متغیرها را جهت مقدار دهی به این کامند داده‌ایم.\nتوجه کنید اگر متغیرهایتان داخل پکیج (پوشه ای) مانند configs بود آدرس متغییر بصورت زیر می شود :\n1$ go build -ldflags \u0026#34;-X configs.Version=1.0.0 -X configs.BuildTime=`date -u +%Y-%m-%dT%H:%M:%SZ`\u0026#34; main.go "},{"id":45,"href":"/chapter-4/debugging-go-code/","title":"4.2 آموزش کار با Debugging","section":"فصل چهارم: مباحث پیشرفته","content":"برای بحث debugging در زبان گو روش های مختلفی وجود دارد که محبوبترین روش ها به شرح زیر می باشد :\nبا استفاده پکیج fmt : شما با استفاده از تابع fmt.Println می توانید مقادیر برخی از متغیرها را چاپ کنید و یکی از روش های ساده برای بحث دیباگ هستش. با استفاده از پکیج log : یکی از کاربردی ترین روش ها بحث لاگ کردن هستش که شما می توانید هر بخش از کدهای خود را لاگ کنید و بصورت زنده در console یا داخل فایل ببینید و از همه مهمتر شما می توانید لاگ های خود را سطح بندی کنید تا بهتر بتوانید دیباگ کنید. استفاده از پکیج pprof : پکیج pprof به شما کمک می کند تا راحتر مشکلات عملکردی برنامه خود را بیابید و همچنین خروجی profile از عملکرد برنامه با CPU و Memory را آنالیز کنید. با استفاده از IDE ها: اکثر IDE هایی (Goland, Vscode) که قبلا معرفی کردیم دارای دیباگر داخلی می باشند که شما می توانید در هر بخش از کد خود breakpoint بزارید و خط به خط کد را دیباگ کنید و مشکلات را برطرف کنید. با استفاده از دیباگر dlv : یکی از محبوبترین دیباگرهایی بصورت متن باز در حال توسعه است delve می باشد که به شما برای دیباگ کردن بصورت تعاملی هنگام اجرا کمک می کند. حال در ادامه ما با مثال هایی نحوه کار با این شیوه هایی که معرفی کردیم آموزش می دهیم.\n4.2.1 نحوه دیباگ با fmt # شما با استفاده از تابع fmt.Println می توانید مقادیر برخی از متغیرها را چاپ کنید و برای اینکار به مثال ساده زیر توجه کنید :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func fibonacci(n uint) uint { 6\tif n \u0026lt; 2 { 7\treturn n 8\t} 9 10\tvar a, b uint 11 12\tb = 1 13 14\tfor n--; n \u0026gt; 0; n-- { 15\ta += b 16\ta, b = b, a 17\tfmt.Println(\u0026#34;this is example debugging value a is \u0026#34;, a, \u0026#34; value b is \u0026#34;, b) 18\t} 19 20\treturn b 21} 22 23func main() { 24\tfmt.Println(fibonacci(100)) 25} 1$ go run main.go 2this is example debugging value a is 1 value b is 1 3this is example debugging value a is 1 value b is 2 4this is example debugging value a is 2 value b is 3 5this is example debugging value a is 3 value b is 5 6this is example debugging value a is 5 value b is 8 7... 8this is example debugging value a is 6174643828739884737 value b is 16008811023750101250 9this is example debugging value a is 16008811023750101250 value b is 3736710778780434371 103736710778780434371 در کد فوق برای اینکه مقدار a, b را ببینیم از تابع Println استفاده کردیم تا مقدار داخل این دو متغیر را ببینیم.\n4.2.2 نحوه دیباگ با استفاده log # یکی از کاربردی ترین روش ها بحث لاگ کردن هستش که شما می توانید هر بخش از کدهای خود را لاگ کنید و بصورت زنده در console یا داخل فایل ببینید و از همه مهمتر شما می توانید لاگ های خود را سطح بندی کنید تا بهتر بتوانید دیباگ کنید. حال برای اینکه با log دیباگ کنید یک پکیج استاندارد به نام log داریم که می توانید بسته به نیازتان تغییرات دهید و هچنین پکیج هایی نظیر zap, logrus و \u0026hellip; هست برای بحث لاگ به شما خیلی کمک می کنند.\n1package main 2 3import ( 4\t\u0026#34;log\u0026#34; 5\t\u0026#34;os\u0026#34; 6) 7 8func main() { 9\t// Set the log level to Info 10\tlog.SetFlags(0) 11\tlog.SetPrefix(\u0026#34;[Info] \u0026#34;) 12\tlog.SetOutput(os.Stdout) 13\tlog.Println(\u0026#34;This is an informational message\u0026#34;) 14 15\t// Set the log level to Warning 16\tlog.SetPrefix(\u0026#34;[Warn] \u0026#34;) 17\tlog.SetOutput(os.Stdout) 18\tlog.Println(\u0026#34;This is a warning message\u0026#34;) 19 20\t// Set the log level to Error 21\tlog.SetPrefix(\u0026#34;[Error] \u0026#34;) 22\tlog.SetOutput(os.Stderr) 23\tlog.Println(\u0026#34;This is an error message\u0026#34;) 24} 1$ go run main.go 2[Info] This is an informational message 3[Warn] This is a warning message 4[Error] This is an error message در کد فوق ما با استفاده از تابع SetPrefix یک پیشوند برای لاگ ها اضافه کردیم تا بتوانیم لاگ با سطح های مختلف ایجاد کنیم. و با استفاده از log.Println لاگ را چاپ کردیم. در ادامه این فصل به بحث آموزش کار به log میپردازیم.\n4.2.3 دیباگ عملکرد با استفاده از pprof # زبان گو یک ابزار داخلی دارد جهت آنالیز و دیباگ عملکرد به نام pprof که با استفاده از آن می توانید یکسری اطلاعات در خصوص عملکرد برنامه تهیه کنید و براساس آنالیز اطلاعات مشکلات عملکردی را می توانید برطرف کنید.\n1package main 2 3import ( 4\t\u0026#34;log\u0026#34; 5\t\u0026#34;net/http\u0026#34; 6\t_ \u0026#34;net/http/pprof\u0026#34; 7) 8 9func main() { 10\tlog.Println(http.ListenAndServe(\u0026#34;localhost:6060\u0026#34;, nil)) 11} 1$ go run main.go در کد فوق ما از پکیج مسیر net/http/pprof استفاده کردیم تا عملکرد برنامه را در وب سرور زبان گو را آنالیز و دیباگ کنیم. حال اگر به آدرس http://localhost:6060/debug/pprof/ بروید می توانید وضعیت عملکرد وب سرور را در لحظه ببینید و آنالیز کنید.\n4.2.3.1 آنالیز وضعیت CPU # برای آنالیز وضعیت CPU کافیه کامند زیر را بزنید :\n1go tool pprof http://localhost:6060/debug/pprof/profile 4.2.3.2 آنالیز وضعیت heap memory # برای آنالیز حافظه heap کافیه کامند زیر را بزنید :\n1go tool pprof http://localhost:6060/debug/pprof/heap 2 3Fetching profile over HTTP from http://localhost:6060/debug/pprof/heap 4Saved profile in /home/javad/pprof/pprof.main.alloc_objects.alloc_space.inuse_objects.inuse_space.001.pb.gz 5File: main 6Type: inuse_space 7Time: Jan 27, 2023 at 6:46pm (+0330) 8Entering interactive mode (type \u0026#34;help\u0026#34; for commands, \u0026#34;o\u0026#34; for options) 9(pprof) pdf زمانیکه کامند فوق را بزنید وارد شل pprof خواهید شد که می توانید با زدن help کامندهای کاربردی را جهت آنالیز ببینید. به عنوان مثال pdf را بزنید یک خروجی pdf بصورت گراف از وضعیت حافظه heap ارائه می دهد که می توانید وضعیت را آنالیز کنید (جهت خواندن گراف این آموزش را مطالعه کنید).\n4.2.4 دیباگ با استفاده از GDB # این قسمت با استفاده از مستندات رسمی GO در مورد 1. Debugging Go Code with GDB نوشته شده است. دستورالعمل های زیر برای استاندارد toolchain (کامپایلر و ابزارهای gc Go) اعمال می شود. Gccgo دارای پشتیبانی از native gdb به صورت پیش فرض است.\nتوجه داشته باشید که هنگام اشکال زدایی برنامه های Go که باstandard toolchain ساخته شده اند، Delve جایگزین بهتری برای GDB است. زیرا Go runtime را بهتر تشخیص می‌دهد و ساختارهای داده و عبارات را بهتر از GDB درک می کند. Delve در حال حاضر از Linux، OSX و Windows در amd64 پشتیبانی می کند. برای به روزترین لیست پلتفرم های پشتیبانی شده، لطفاً به Delve documentation مراجعه کنید.\nGDB برنامه های Go را به خوبی درک نمی کند. مدیریت stack و threading و runtime شامل جنبه هایی هستند که به اندازه کافی با مدل اجرایی متفاوت است که GDB انتظار دارد که می توانند debugger را اشتباه گرفته و نتایج نادرستی را حتی زمانی که برنامه با gccgo کامپایل می شود ایجاد کنند. در نتیجه، اگرچه GDB می‌تواند در برخی موقعیت‌ها مفید باشد (به عنوان مثال، اشکال‌زدایی کد Cgo، یا اشکال‌زدایی خود زمان اجرا)، اما برای برنامه‌های Go، به‌ویژه برنامه‌های به‌شدت همزمان هستند، اشکال‌زدایی با این روش چندان قابل اعتمادی نیست. علاوه بر این، پرداختن به این مسائل که دشوار هستند، برای پروژه Go در اولویت نیست.\nبه طور خلاصه، دستورالعمل‌های زیر باید تنها به‌عنوان راهنمای نحوه استفاده از GDB در هنگام کارکرد آن در نظر گرفته شود، نه به عنوان تضمین موفقیت اجرای درست برنامه. علاوه بر این نمای کلی، ممکن است بخواهید به GDB manual مراجعه کنید.\n4.2.4.1 مقدمه اولیه GDB # وقتی برنامه‌های Go را با toolchain مربوط gc در Linux، macOS، FreeBSD یا NetBSD کامپایل و link می‌دهید، باینری‌های به دست آمده حاوی اطلاعات اشکال‌زدایی DWARFv4 هستند که نسخه‌های اخیر (≥7.5) اشکال‌زدای GDB می‌توانند از آن برای بازرسی یک live process یا یک core dump استفاده کنند. .\nپرچم \u0026lsquo;-w\u0026rsquo; را به linker ارسال کنید تا اطلاعات debug را حذف کنید (به عنوان مثال، go build -ldflags=-w prog.go).\nکد تولید شده توسط کامپایلر gc شامل درون خطی کردن فراخوانی تابع و ثبت متغیرها است. این بهینه سازی ها گاهی اوقات می تواند اشکال زدایی با gdb را سخت تر کند. اگر متوجه شدید که باید این بهینه سازی ها را غیرفعال کنید، برنامه خود را با استفاده از go build -gcflags=all=-N -l بسازید.\nاگر می‌خواهید از gdb برای بررسی یک core dump استفاده کنید، می توانید یک Dump را در یک program crash راه اندازی کنید و برای این کار باید GOTRACEBACK=crash در environment تنظیم کنید (برای اطلاعات بیشتر به runtime package documentation مراجعه کنید).\n4.2.4.2 Common Operations # نمایش فایل و شماره خط برای کد، تعیین breakpoints و disassemble:\n1(gdb) list 2(gdb) list _line_ 3(gdb) list _file.go_:_line_ 4(gdb) break _line_ 5(gdb) break _file.go_:_line_ 6(gdb) disas نمایش backtraces و باز کردن stack frames:\n1(gdb) bt 2(gdb) frame _n_ نمایش نام، type و location در stack frame و local variables، آرگومان ها و مقادیر بازگشتی:\n1(gdb) info locals 2(gdb) info args 3(gdb) p variable 4(gdb) whatis variable نمایش نام، type و location و global variables:\n1(gdb) info variables _regexp_ 4.2.4.3 Go Extensions # اخیرا یک نوع extension به GDB اجازه می دهد تا extension scripts را برای یک باینری معین load کند. این toolchain برای extend GDB با تعداد انگشت شماری از command ها برای بررسی داخلی runtime code (مانند گوروتین ها) و pretty print the built-in map و slice وchannel types استفاده می کند.\n1Pretty printing a string, slice, map, channel or interface:(gdb) p var 2A $len() and $cap() function for strings, slices and maps: (gdb) p $len(var) 3A function to cast interfaces to their dynamic types: 4(gdb) p $dtype(var) 5(gdb) iface var مشکلات شناخته شده: GDB نمی تواند به طور خودکار dynamic type یک interface value را پیدا کند اگر نام طولانی آن با نام کوتاه آن متفاوت باشد (در هنگام printing stacktraces آزاردهنده است، pretty printer به نمایش نام short type و اشاره گر بازمی گردد).\nبررسی گوروتین ها:\n1(gdb) info goroutines 2(gdb) goroutine _n_ _cmd_ 3(gdb) help goroutine به عنوان مثال:\n1(gdb) goroutine 12 bt می توانید همه گوروتین ها را با pass کردن همه به جای goroutine\u0026rsquo;s ID خاص بررسی کنید. مثلا:\n1 (gdb) goroutine all bt اگر می‌خواهید ببینید که این حالت چگونه کار می‌کند یا می‌خواهید آن را گسترش دهید، به src/runtime/runtime-gdb.py در توزیع Go source نگاهی بیندازید. این به برخی از type های جادویی خاص (hash\u0026lt;T,U\u0026gt;) و متغیرهایی (runtime.m و runtime.g) بستگی دارد کهlinker (src/cmd/link/internal/ld/dwarf.go) اطمینان حاصل می کند که در کد DWARF توضیح داده شده اند.\nاگر به debugging information علاقه دارید، objdump -W a.out را اجرا کنید و در بخش های مرتبط با .debug_* مرور کنید.\nمشکلات شناخته شده: # ۱- حالت String pretty printing فقط برای type string فعال می شود، نه برای انواع مشتق شده از آن. ۲-Type information برای قسمت های C که در runtime library هستند، وجود ندارد.\n۳- GDB شرایط Go’s name را نمی‌فهمد و «fmt.Print» را به‌عنوان یک کلمه بدون ساختار با یک «» در نظر می‌گیرد. که باید نقل شود. حتی با شدت بیشتری به method names فرم pkg.(*MyType).Meth. برخورد می کند.\n۴- از Go 1.11، قسمت debug information به طور پیش فرض فشرده شده است. نسخه‌های قدیمی‌تر gdb، مانند نسخه‌ای که به‌طور پیش‌فرض در MacOS موجود است، فشرده‌سازی را درک نمی‌کنند. شما می توانید با استفاده از go build -ldflags=-compressdwarf=false‍ اطلاعات اشکال زدایی فشرده نشده تولید کنید. (برای راحتی می توانید گزینه -ldflags را در GOFLAGS environment variable قرار دهید تا مجبور نباشید هر بار آدرس آن را مشخص کنید.)\n4.2.4.4 مثال های GDB # در این آموزش ما باینری unit tests پکیج regexp را بررسی می کنیم. برای ساخت باینری، به GOROOT/src/regexp$ تغییر دهید و go test -c را اجرا کنید. این باید یک فایل اجرایی به نام regexp.test تولید کند.\nشروع دیباگ # Launch GDB, debugging regexp.test:\n1$ gdb regexp.test 2GNU gdb (GDB) 7.2-gg8 3Copyright (C) 2010 Free Software Foundation, Inc. 4License GPLv 3+: GNU GPL version 3 or later \u0026lt;http://gnu.org/licenses/gpl.html\u0026gt; 5Type \u0026#34;show copying\u0026#34; and \u0026#34;show warranty\u0026#34; for licensing/warranty details. 6This GDB was configured as \u0026#34;x86_64-linux\u0026#34;. 7 8Reading symbols from /home/user/go/src/regexp/regexp.test... 9done. 10Loading Go Runtime support. 11(gdb) پیام \u0026lsquo;Loading Go Runtime Support\u0026rsquo; به این معنی است که GDB برنامه extension را از مسیر GOROOT/src/runtime/runtime-gdb.py$ بارگیری کرده است.\nبرای کمک به GDB در یافتن آدرس Go runtime sources و سایر اسکریپت‌های همراه، $GOROOT را با پرچم \u0026lsquo;-d\u0026rsquo; ارسال کنید:\ngdb regexp.test -d $GOROOT$ اگر به دلایلی هنوز GDB نمی تواند آن دایرکتوری یا آن اسکریپت را پیدا کند، می توانید آن را دستی load کنید (با فرض اینکه go sources در آدرس ~/go/ باشد):\n1(gdb) source ~/go/src/runtime/runtime-gdb.py 2Loading Go Runtime support. بررسی کردن source # از دستور \u0026rsquo;l\u0026rsquo; یا \u0026rsquo;list\u0026rsquo; برای بررسی source code استفاده کنید.\n1(gdb) l بخش خاصی از منبع را که \u0026rsquo;list\u0026rsquo; را پارامتر می کند با نام تابع فهرست کنید (باید با نام بسته آن مرتبط باشد).\n1(gdb) l main.main یک file خاص و line number را فهرست کنید:\n1(gdb) l regexp.go:1 2(gdb) _# Hit enter to repeat last command. Here, this lists next 10 lines._ Naming # نام متغیرها و توابع باید با نام package هایی که به آنها تعلق دارند قابل بازیابی باشند. به عنوان مثال تابع Compile از بسته regexp برای GDB به عنوان \u0026lsquo;regexp.Compile\u0026rsquo; شناخته می شود.\nمتدها باید با نام receiver types خود قابل بازیابی باشند. به عنوان مثال، *Regexp type’s String به عنوان 'regexp.(*Regexp).String' شناخته می شود.\nمتغیرهایی که سایر متغیرها را تحت shadow قرار می دهند، به صورت جادویی با یک عدد در debug info پسوند می شوند. متغیرهایی که توسط بسته‌ها ارجاع می‌شوند به‌عنوان اشاره‌گرهایی با پیشوند جادویی «\u0026amp;» ظاهر می‌شوند.\nقراردادن breakpoints # یک breakpoint در تابع TestFind تنظیم کنید: ‍‍\n1(gdb) b \u0026#39;regexp.TestFind\u0026#39; 2Breakpoint 1 at 0x424908: file /home/user/go/src/regexp/find_test.go, line 148. اجرا کردن برنامه:\n1(gdb) run 2Starting program: /home/user/go/src/regexp/regexp.test 3 4Breakpoint 1, regexp.TestFind (t=0xf8404a89c0) at /home/user/go/src/regexp/find_test.go:148 5148\tfunc TestFind(t *testing.T) { اجرا در breakpoint متوقف شده است. ببینید کدام گوروتین ها در حال اجرا هستند و چه کار می کنند:\n1(gdb) info goroutines 2 1 waiting runtime.gosched 3* 13 running runtime.goexit موردی که با * مشخص شده است، گوروتین فعلی است.\nبررسی کردن stack # به خروجی از stack برای جایی که برنامه را متوقف کرده ایم نگاه کنید:\n1(gdb) bt _# backtrace_ 2#0 regexp.TestFind (t=0xf8404a89c0) at /home/user/go/src/regexp/find_test.go:148 3#1 0x000000000042f60b in testing.tRunner (t=0xf8404a89c0, test=0x573720) at /home/user/go/src/testing/testing.go:156 4#2 0x000000000040df64 in runtime.initdone () at /home/user/go/src/runtime/proc.c:242 5#3 0x000000f8404a89c0 in ?? () 6#4 0x0000000000573720 in ?? () 7#5 0x0000000000000000 in ?? () گوروتین دیگر، شماره 1، در runtime.gosched گیر کرده و در channel receive مسدود شده است:\n1(gdb) goroutine 1 bt 2#0 0x000000000040facb in runtime.gosched () at /home/user/go/src/runtime/proc.c:873 3#1 0x00000000004031c9 in runtime.chanrecv (c=void, ep=void, selected=void, received=void) 4 at /home/user/go/src/runtime/chan.c:342 5#2 0x0000000000403299 in runtime.chanrecv1 (t=void, c=void) at/home/user/go/src/runtime/chan.c:423 6#3 0x000000000043075b in testing.RunTests (matchString={void (struct string, struct string, bool *, error *)} 7 0x7ffff7f9ef60, tests= []testing.InternalTest = {...}) at /home/user/go/src/testing/testing.go:201 8#4 0x00000000004302b1 in testing.Main (matchString={void (struct string, struct string, bool *, error *)} 9 0x7ffff7f9ef80, tests= []testing.InternalTest = {...}, benchmarks= []testing.InternalBenchmark = {...}) 10at /home/user/go/src/testing/testing.go:168 11#5 0x0000000000400dc1 in main.main () at /home/user/go/src/regexp/_testmain.go:98 12#6 0x00000000004022e7 in runtime.mainstart () at /home/user/go/src/runtime/amd64/asm.s:78 13#7 0x000000000040ea6f in runtime.initdone () at /home/user/go/src/runtime/proc.c:243 14#8 0x0000000000000000 in ?? () همانطور که stack frame نشان می دهد، انتظار می رود الان باید در حال اجرای تابع regexp.TestFind باشیم.\n1(gdb) info frame 2Stack level 0, frame at 0x7ffff7f9ff88: 3 rip = 0x425530 in regexp.TestFind (/home/user/go/src/regexp/find_test.go:148); 4 saved rip 0x430233 5 called by frame at 0x7ffff7f9ffa8 6 source language minimal. 7 Arglist at 0x7ffff7f9ff78, args: t=0xf840688b60 8 Locals at 0x7ffff7f9ff78, Previous frame\u0026#39;s sp is 0x7ffff7f9ff88 9 Saved registers: 10 rip at 0x7ffff7f9ff80 دستور info locals همه متغیرهای محلی تابع و مقادیر آنها را فهرست می‌کند، اما استفاده از آن کمی خطرناک است، زیرا سعی می‌کند متغیرهای اولیه را نیز چاپ کند. برش‌های بدون مقدار اولیه ممکن است باعث شوند که gdb سعی کند آرایه‌های بزرگ دلخواه را چاپ کند.\nآرگومان های تابع:\n1(gdb) info args 2t = 0xf840688b60 هنگام چاپ آرگومان، توجه کنید که نشانگر یک مقدار Regexp است. توجه داشته باشید که GDB به اشتباه * را در سمت راست نام تایپ قرار داده و یک کلمه کلیدی \u0026lsquo;struct\u0026rsquo; به سبک سنتی C ساخته است.\n1(gdb) p re 2(gdb) p t 3$1 = (struct testing.T *) 0xf840688b60 4(gdb) p t 5$1 = (struct testing.T *) 0xf840688b60 6(gdb) p *t 7$2 = {errors = \u0026#34;\u0026#34;, failed = false, ch = 0xf8406f5690} 8(gdb) p *t-\u0026gt;ch 9$3 = struct hchan\u0026lt;*testing.T\u0026gt; که ساختار hchan\u0026lt;*testing.T\u0026gt; نمایش runtime-internal یک کانال است و در حال حاضر خالی است، وگرنه gdb محتویات آن را به زیبایی چاپ می کرد.\nحالا به قسمت مهم پیمایش دیباگر میرسیم که با حرف n صورت می‌گیرد.\nپیمایش دیباگر :\n1(gdb) n _# execute next line_ 2149 for _, test := range findTests { 3(gdb) _# enter is repeat_ 4150 re := MustCompile(test.pat) 5(gdb) p test.pat 6$4 = \u0026#34;\u0026#34; 7(gdb) p re 8$5 = (struct regexp.Regexp *) 0xf84068d070 9(gdb) p *re 10$6 = {expr = \u0026#34;\u0026#34;, prog = 0xf840688b80, prefix = \u0026#34;\u0026#34;, prefixBytes = []uint8, prefixComplete = true, 11 prefixRune = 0, cond = 0 \u0026#39;\\000\u0026#39;, numSubexp = 0, longest = false, mu = {state = 0, sema = 0}, 12 machine = []*regexp.machine} 13(gdb) p *re-\u0026gt;prog 14$7 = {Inst = []regexp/syntax.Inst = {{Op = 5 \u0026#39;\\005\u0026#39;, Out = 0, Arg = 0, Rune = []int}, {Op = 15 6 \u0026#39;\\006\u0026#39;, Out = 2, Arg = 0, Rune = []int}, {Op = 4 \u0026#39;\\004\u0026#39;, Out = 0, Arg = 0, Rune = []int}}, 16 Start = 1, NumCap = 2} می توانیم با حرف \u0026rsquo;s\u0026rsquo; وارد فراخوانی Stringfunction شویم:\n1(gdb) s 2regexp.(*Regexp).String (re=0xf84068d070, noname=void) at /home/user/go/src/regexp/regexp.go:97 397 func (re *Regexp) String() string { یک stack trace بگیرید تا ببینید کجا هستیم:\n1(gdb) bt 2#0 regexp.(*Regexp).String (re=0xf84068d070, noname=void) 3 at /home/user/go/src/regexp/regexp.go:97 4#1 0x0000000000425615 in regexp.TestFind (t=0xf840688b60) 5 at /home/user/go/src/regexp/find_test.go:151 6#2 0x0000000000430233 in testing.tRunner (t=0xf840688b60, test=0x5747b8) 7 at /home/user/go/src/testing/testing.go:156 8#3 0x000000000040ea6f in runtime.initdone () at /home/user/go/src/runtime/proc.c:243 9.... به source code نگاه کنید:\n1(gdb) l 292 mu sync.Mutex 393 machine []*machine 494 } 595 696 // String returns the source text used to compile the regular expression. 797 func (re *Regexp) String() string { 898 return re.expr 999 } 10100 11101 // Compile parses a regular expression and returns, if successful, Pretty Printing\nمکانیسم چاپ زیبا GDB توسط regexp matches به صورت زیر می‌باشد:\n1(gdb) p utf 2$22 = []uint8 = {0 \u0026#39;\\000\u0026#39;, 0 \u0026#39;\\000\u0026#39;, 0 \u0026#39;\\000\u0026#39;, 0 \u0026#39;\\000\u0026#39;} از آنجایی که slice ها، آرایه ها و رشته ها اصلا اشاره‌گرهای C نیستند در نتیجه GDB نمی تواند عملیات subscripting را برای شما تفسیر کند، اما می توانید برای انجام این کار به نمایش runtime نگاه کنید (tab completion در اینجا کاربرد دارد):\n1(gdb) p slc 2$11 = []int = {0, 0} 3(gdb) p slc-\u0026gt;* _\u0026lt;TAB\u0026gt;_ 4array slc len 5(gdb) p slc-\u0026gt;array 6$12 = (int *) 0xf84057af00 7(gdb) p slc-\u0026gt;array[1] 8$13 = 0 توابع extension یا افزونه $len و $cap روی strings, arrays , slices کار می‌کنند:\n1(gdb) p $len(utf) 2$23 = 4 3(gdb) p $cap(utf) 4$24 = 4 Channelها و mapها در واقع typeهایی از جنس «reference» هستند که gdb آن‌ها را به‌عنوان اشاره‌گر به C++ like types مانند \u0026lt;hash\u0026lt;int,string\u0026gt;* نشان می‌دهد. Interface ها در runtime به عنوان یک اشاره گر به یک توصیفگر(descriptor) و یک اشاره گر به یک مقدار نشان داده می شوند. پسوند Go GDB در runtime این را رمزگشایی می کند و به طور خودکار pretty printing را برای runtime type ایجاد می کند. تابع افزونه dtype$ درنهایت یک dynamic type را برای شما رمزگشایی می‌کند (مثال‌هایی از یک breakpoint در خط 293 regexp.go گرفته شده‌اند.)\n1(gdb) p i 2$4 = {str = \u0026#34;cbb\u0026#34;} 3(gdb) whatis i 4type = regexp.input 5(gdb) p $dtype(i) 6$26 = (struct regexp.inputBytes *) 0xf8400b4930 7(gdb) iface i 8regexp.input: struct regexp.inputBytes * 4.2.5 معرفی دیباگر DELVE # delve یک debugger برای زبان برنامه نویسی GO است. هدف این پروژه ارائه یک ابزار ساده و کامل debugger برای GO است. DeLve باید به راحتی استفاده می‌شود و استفاده از آن آسان بسیار آسان می‌باشد.\n4.2.5.1 راهنمای نصب DELVE # دستورالعمل های زیر برای کار بر روی Linux، macOS، Windows و FreeBSD مورد استفاده قرار می‌گیرد.\nبرای Clone و build دستورات زیر رو داریم\n1 git clone https://github.com/go-delve/delve 2 cd delve 3 go install github.com/go-delve/delve/cmd/dlv برای Go version 1.16 و بالاتر هم داریم:\n1# Install the latest release: 2$ go install github.com/go-delve/delve/cmd/dlv@latest 3 4# Install at tree head: 5$ go install github.com/go-delve/delve/cmd/dlv@master 6 7# Install at a specific version or pseudo-version: 8$ go install github.com/go-delve/delve/cmd/dlv@v1.7.3 9$ go install github.com/go-delve/delve/cmd/dlv@v1.7.4-0.20211208103735-2f13672765fe برای جزئیات در مورد محل ذخیره فایل اجرایی dlv به راهنمای نصب یا دستور go help install مراجعه کنید.\nاگر در مرحله نصب با خطای مشابه زیر مواجه شدید: 2\n1found packages native (proc.go) and your_operating_system_and_architecture_combination_is_not_supported_by_delve (support_sentinel.go) in /home/pi/go/src/github.com/go-delve/delve/pkg/proc/native یعنی از سیستم عامل یا معماری CPU شما پشتیبانی نمی شود، خروجی go version را بررسی کنید.\nبرای نصب در macOS از لینک macOS استفاده کنید.\n4.2.5.2 شروع استفاده از DELVE # هدف Delve یک ابزار بسیار ساده و قدرتمند است، اما اگر به استفاده از source level debugger در یک زبان کامپایل شده عادت ندارید این ابزار می‌تواند گیج‌کننده باشد. البته این سند تمام اطلاعاتی را که برای شروع اشکال زدایی برنامه های Go خود نیاز دارید را ارائه می دهد.\n4.2.5.3 Debugging \u0026lsquo;main\u0026rsquo; packages # اولین CLI subcommand که بررسی خواهیم کرد کلیدواژه debug است. این subcommand را می توان بدون آرگومان اجرا کرد اگر شما در همان دایرکتوری main package خود هستید، در غیر این صورت به صورت اختیاری یک package path را می پذیرد.\nبه عنوان مثال با توجه به این project layout داریم:\n1github.com/me/foo 2├── cmd 3│ └── foo 4│ └── main.go 5└── pkg 6 └── baz 7 ├── bar.go 8 └── bar_test.go اگر در دایرکتوری github.com/me/foo/cmd/foo هستید، می توانید به سادگی dlv debug را از command line اجرا کنید. از هر جای دیگری، مثلاً project root، می توانید به سادگی package را معرفی کنید، به عنوان مثال: dlv debug github.com/me/foo/cmd/foo . برای ارسال flag‌ها به برنامه خود، آنها را به صورت زیر جدا سازی کنید:\n--: dlv debug github.com/me/foo/cmd/foo -- -arg1 value\nفراخوانی آن دستور باعث می شود که Delve برنامه را به روشی مناسب برای اشکال زدایی کامپایل کند و سپس برنامه اجرا شده و دیباگر به برنامه attach می شود و debug session را شروع می کند. حالا، هنگامی که جلسه debug session برای اولین بار شروع شده است، شما در ابتدای شروع اولیه برنامه هستید. برای رسیدن به جایی که مورد نظر هست باید یک یا دو breakpoint تعیین کنید و اجرا را تا آن نقطه ادامه دهید.\nبه عنوان مثال، برای ادامه اجرا به تابع main برنامه:\n1$ dlv debug github.com/me/foo/cmd/foo 2Type \u0026#39;help\u0026#39; for list of commands. 3(dlv) break main.main 4Breakpoint 1 set at 0x49ecf3 for main.main() ./test.go:5 5(dlv) continue 6\u0026gt; main.main() ./test.go:5 (hits goroutine(1):1 total:1) (PC: 0x49ecf3) 7 1:\tpackage main 8 2:\t9 3:\timport \u0026#34;fmt\u0026#34; 10 4:\t11=\u0026gt; 5:\tfunc main() { 12 6:\tfmt.Println(\u0026#34;delve test\u0026#34;) 13 7:\t} 14(dlv) 4.2.5.4 Debugging tests # با توجه به ساختار دایرکتوری مشابه با بالا، می توانید کد خود را با اجرای مجموعه آزمایشی خود اشکال زدایی کنید. برای این کار می توانید از subcommand یا دستور dlv test استفاده کنید، که همان package path اختیاری را به عنوان dlv debug طی می کند و در صورت عدم ارائه آرگومان، package فعلی را نیز می سازد.\n1$ dlv test github.com/me/foo/pkg/baz 2Type \u0026#39;help\u0026#39; for list of commands. 3(dlv) funcs test.Test* 4/home/me/go/src/github.com/me/foo/pkg/baz/test.TestHi 5(dlv) break TestHi 6Breakpoint 1 set at 0x536513 for /home/me/go/src/github.com/me/foo/pkg/baz/test.TestHi() ./test_test.go:5 7(dlv) continue 8\u0026gt; /home/me/go/src/github.com/me/foo/pkg/baz/test.TestHi() ./bar_test.go:5 (hits goroutine(5):1 total:1) (PC: 0x536513) 9 1:\tpackage baz 10 2:\t11 3:\timport \u0026#34;testing\u0026#34; 12 4:\t13=\u0026gt; 5:\tfunc TestHi(t *testing.T) { 14 6:\tt.Fatal(\u0026#34;implement me!\u0026#34;) 15 7:\t} 16(dlv) همانطور که می بینید، ما شروع به دیباگ کردن یک test binary کردیم، تابع تست خود را از طریق دستور funcs پیدا کردیم که یک regexp برای فیلتر کردن لیست توابع می گیرد، حالا یک breakpoint تعیین می کنیم و سپس اجرا را ادامه می دهیم تا زمانی که به آن breakpoint رسیدیم.\nبرای اطلاعات بیشتر در مورد subcommands که می‌توانید استفاده کنید، dlv help را تایپ کنید، و یک بار در debug session می‌توانید با تایپ help در هر زمانی، تمام دستورات موجود را مشاهده کنید.\n4.2.5.5 Synopsis و گزینه های Command line options # Delve شما را قادر می سازد تا با کنترل اجرای فرآیند، ارزیابی متغیرها و ارائه اطلاعات state thread / goroutine، همینطور CPU register state و موارد دیگر، با برنامه خود تعامل داشته باشید.\nهدف این ابزار ارائه یک رابط ساده و در عین حال قدرتمند برای اشکال زدایی برنامه های Go است. flagبرای استفاده از قابلیت های delve باید flagها را به برنامه‌ای که با استفاده از آن اشکال‌زدایی می‌کنید ارسال کنید، به کمک دستور -- برای مثال:\ndlv exec ./hello -- server --config conf/config.toml\nدر سایر گزینه ها داریم:\n1 2 3 --accept-multiclient Allows a headless server to accept multiple client connections via JSON-RPC or DAP. 4 --allow-non-terminal-interactive Allows interactive sessions of Delve that don\u0026#39;t have a terminal as stdin, stdout and stderr 5 --api-version int Selects JSON-RPC API version when headless. New clients should use v2. Can be reset via RPCServer.SetApiVersion. See Documentation/api/json-rpc/README.md. (default 1) 6 --backend string Backend selection (see \u0026#39;dlv help backend\u0026#39;). (default \u0026#34;default\u0026#34;) 7 --build-flags string Build flags, to be passed to the compiler. For example: --build-flags=\u0026#34;-tags=integration -mod=vendor -cover -v\u0026#34; 8 --check-go-version Exits if the version of Go in use is not compatible (too old or too new) with the version of Delve. (default true) 9 --disable-aslr Disables address space randomization 10 --headless Run debug server only, in headless mode. Server will accept both JSON-RPC or DAP client connections. 11 -h, --help help for dlv 12 --init string Init file, executed by the terminal client. 13 -l, --listen string Debugging server listen address. (default \u0026#34;127.0.0.1:0\u0026#34;) 14 --log Enable debugging server logging. 15 --log-dest string Writes logs to the specified file or file descriptor (see \u0026#39;dlv help log\u0026#39;). 16 --log-output string Comma separated list of components that should produce debug output (see \u0026#39;dlv help log\u0026#39;) 17 --only-same-user Only connections from the same user that started this instance of Delve are allowed to connect. (default true) 18 -r, --redirect stringArray Specifies redirect rules for target process (see \u0026#39;dlv help redirect\u0026#39;) 19 --wd string Working directory for running the program. همینطور دستورات زیر را داریم:\ndlv attach - Attach to running process and begin debugging.\ndlv connect - Connect to a headless debug server with a terminal client.\ndlv core - Examine a core dump.\ndlv dap - Starts a headless TCP server communicating via Debug Adaptor Protocol (DAP).\ndlv debug - Compile and begin debugging main package in current directory, or the package specified.\ndlv exec - Execute a precompiled binary, and begin a debug session.\ndlv replay - Replays a rr trace.\ndlv run - Deprecated command. Use \u0026lsquo;debug\u0026rsquo; instead.\ndlv test - Compile test binary and begin debugging program.\ndlv trace - Compile and begin tracing program.\ndlv version - Prints version.\ndlv log - Help about logging flags\ndlv backend - Help about the --backend flag\n"},{"id":46,"href":"/chapter-4/go-mod/","title":"4.3 آموزش کار با go mod","section":"فصل چهارم: مباحث پیشرفته","content":"از نسخه 1.11 زبان گو مفهوم جدیدی برای مدیریت وابستگی ها آمد و جایگزین GOPATH شد. ماژول های گو این امکان را می دهد خیلی راحت ماژول های مختلف را به پروژه اضافه کنید و نسخه های هر ماژول را مدیریت کنید. با استفاده از ماژول گو برنامه نویسان گو محدود به GOPATH برای توسعه نخواهد بود و در جایی می توانند پروژه خود را ایجاد و ماژول های پروژه را به آسانی مدیریت کند.\nدر زیر یک نمونه از محتوای داخل فایل go.mod را قرار دادیم :\n1module github.com/user/repo 2 3go 1.20 4 5require ( 6 github.com/sirupsen/logrus v1.8.1 7 github.com/spf13/cobra v1.2.1 8) در خط اول نام ماژول می باشد که داخل کد هرجایی که import انجام می دهید نام ماژول اولش قرار می گیرد مانند : 1package cmd 2 3import \u0026#34;github.com/user/repo/internal/app\u0026#34; علت اینکه نام ماژول را آدرس یک مخزن گیت را قرار می دهیم جهت قابل استفاده بودن ماژول می باشد که خیلی ساده بتوانید به پروژه های دیگر ماژولی که نوشتید را اضافه کنید.\nدر خط سوم نسخه زبان گو وجود دارد که شما هر نسخه ای را که تعیین میکنید فقط از ویژگی های همان نسخه به قبل را می توانید استفاده کنید. مثلا شما اگر نسخه 1.17 را گذاشته باشید و قصد داشته باشید از ویژگی جنریک که مربوط به نسخه 1.18 است استفاده کنید, هنگام کامپایل خطا می خورید.\nپس توجه کنید در اینجا سعی کنید از نسخه متناسب با نیاز خود را تعیین کنید هرچند هنگام ایجاد فایل go.mod زبان گو پیش فرض نسخه ای که نصب کرده اید را قرار می دهد.\nدر قسمت require ماژول های خارجی قرار میگیرد که داخل پروژه استفاده کردید. نظیر : github.com/sirupsen/logrus github.com/spf13/cobra به همراه نسخه مشخص اون ماژول.\nاما ماژول گو یک خوبی دارد خیلی راحت می توانید نسخه ماژول ها را به آسانی مدیریت کنید و ارتقا دهید.\nبرای مدیریت ماژول های گو یک کامند داریم به نام mod که یک سری دستورات کمکی برای مدیریت ماژول ها دارد که در ادامه آموزش می دهیم :\n1$ go mod 2Go mod provides access to operations on modules. 3 4Note that support for modules is built into all the go commands, 5not just \u0026#39;go mod\u0026#39;. For example, day-to-day adding, removing, upgrading, 6and downgrading of dependencies should be done using \u0026#39;go get\u0026#39;. 7See \u0026#39;go help modules\u0026#39; for an overview of module functionality. 8 9Usage: 10 11\tgo mod \u0026lt;command\u0026gt; [arguments] 12 13The commands are: 14 15\tdownload download modules to local cache 16\tedit edit go.mod from tools or scripts 17\tgraph print module requirement graph 18\tinit initialize new module in current directory 19\ttidy add missing and remove unused modules 20\tvendor make vendored copy of dependencies 21\tverify verify dependencies have expected content 22\twhy explain why packages or modules are needed 23 24Use \u0026#34;go help mod \u0026lt;command\u0026gt;\u0026#34; for more information about a command. برای اینکه اطلاعات بیشتری در خصوص کامند های go mod کسب کنید کافیه go help mod را قبل از کامند بزارید تا توضیحات بیشتری را ببینید.\n4.3.1 ایجاد go.mod # برای ایجاد فایل go.mod کافیه دستور زیر را در ریشه پروژه بزنید :\n1$ go mod init github.com/user/repo پس از اینکه دستور فوق را زدید یک فایل go.mod ایجاد می شود داخلش محتوای زیر بدون ماژول خارجی می باشد :\n1module github.com/user/repo 2 3go 1.20 4.3.2 افزودن ماژول خارجی به go.mod # برای افزودن یک ماژول خارجی به پروژه کافیه دستور زیر را در محل فایل go.mod بزنید :\n1$ go get github.com/spf13/cobra زمانیکه دستور فوق را می زنید آخرین نسخه ماژول github.com/spf13/cobra را دریافت و به پروژه اضافه می کند.\nدقت کنید وقتی ماژول جدیدی را دریافت می کنید یک فایل go.sum در کنار فایل go.mod ایجاد می شود که داخل این فایل اطلاعات ماژول های خارجی به همراه ساب ماژول ها قرار دارد. که برای اطمینان از یکپارچگی و امنیت وابستگی های مورد استفاده در پروژه Go طراحی شده است. این فایل بصورت خودکار ایجاد و بروز می شود پس بهتر است تغییری در این فایل ندهید. 4.3.3 افزودن ماژول خارجی با تعیین نسخه # با دستور زیر می توانید یک ماژول خارجی با تعیین نسخه به پروژه خود اضافه کنید :\n1$ go get github.com/spf13/cobra@v1.8.1 زمانیکه دستور فوق را می زنید نسخه v1.8.1 ماژول github.com/spf13/cobra را دریافت خواهید کرد.\n4.3.4 آپدیت یک ماژول خارجی به آخرین نسخه # برای آپدیت یک ماژول خارجی به آخرین نسخه کافیه دستور زیر را بزنید :\n1$ go get -u github.com/spf13/cobra در دستور فوق ما سوییچ u- را اضافه کردیم تا آخرین نسخه ماژول github.com/spf13/cobra به پروژه اضافه و جایگزین نسخه های قدیمی شود.\n4.3.5 دستور go mod tidy # یک کامند پر کاربرد به نام tidy داریم که هر زمانی که اجرا می کنید کدهایی که در محل فایل go.mod قرار دارد بررسی می کند و ماژول های ایمپورت شده را به پروژه اضافه می کند و در صورتیکه شما ماژولی را حذف کردید و به هیچ عنوان در پروژه خود استفاده نکردید را از go.mod حذف می کند.\n1$ go mod tidy اگر ماژول خارجی را استفاده کرده باشید در کدهای خود و هنوز به فایل go.mod اضافه نکرده باشید کامند tidy بصورت خودکار آخرین نسخه ماژول خارجی را دریافت و به فایل go.mod اضافه میکند.\n4.3.6 دستور go mod download # با استفاده از این کامند می توانید ماژول های خارجی داخل فایل go.mod را دریافت کرده و در لوکال خود کش کنید. تا بعدا از آن ماژول استفاده کنید.\n1$ go mod download زمانیکه این دستور را بزنید شروع به دانلود ماژول های خارجی می شود و در لوکال شما این ماژول ها ذخیره می شود.\nبرای اینکه بتوانید ببینید وضعیت دانلود تا چه پیشرفته است می توانید سوییچ x- را اضافه کنید تا به شما وضعیت ماژول های در حال دریافت را نمایش دهد :\n1$ go mod download -x 4.3.7 دستور go mod verify # با این دستور شما می توانید وضعیت ماژول ها را بررسی کنید که مورد تایید هست یا نه.\n1$ go mod verify "},{"id":47,"href":"/chapter-4/workspace/","title":"4.4 آموزش کار با workspace","section":"فصل چهارم: مباحث پیشرفته","content":"با استفاده از workspace می توانید همزمان چندین ماژول در یک محل داشته باشید و هر ماژول را به راحتی مدیریت کنید و همچنین همزمان به آسانی این ماژول ها را build و اجرا کنید.\n1$ go help work 2Work provides access to operations on workspaces. 3 4Note that support for workspaces is built into many other commands, not 5just \u0026#39;go work\u0026#39;. 6 7See \u0026#39;go help modules\u0026#39; for information about Go\u0026#39;s module system of which 8workspaces are a part. 9 10See https://go.dev/ref/mod#workspaces for an in-depth reference on 11workspaces. 12 13See https://go.dev/doc/tutorial/workspaces for an introductory 14tutorial on workspaces. 15 16A workspace is specified by a go.work file that specifies a set of 17module directories with the \u0026#34;use\u0026#34; directive. These modules are used as 18root modules by the go command for builds and related operations. A 19workspace that does not specify modules to be used cannot be used to do 20builds from local modules. 21 22go.work files are line-oriented. Each line holds a single directive, 23made up of a keyword followed by arguments. For example: 24 25\tgo 1.18 26 27\tuse ../foo/bar 28\tuse ./baz 29 30\treplace example.com/foo v1.2.3 =\u0026gt; example.com/bar v1.4.5 31 32The leading keyword can be factored out of adjacent lines to create a block, 33like in Go imports. 34 35\tuse ( 36\t../foo/bar 37\t./baz 38\t) 39 40The use directive specifies a module to be included in the workspace\u0026#39;s 41set of main modules. The argument to the use directive is the directory 42containing the module\u0026#39;s go.mod file. 43 44The go directive specifies the version of Go the file was written at. It 45is possible there may be future changes in the semantics of workspaces 46that could be controlled by this version, but for now the version 47specified has no effect. 48 49The replace directive has the same syntax as the replace directive in a 50go.mod file and takes precedence over replaces in go.mod files. It is 51primarily intended to override conflicting replaces in different workspace 52modules. 53 54To determine whether the go command is operating in workspace mode, use 55the \u0026#34;go env GOWORK\u0026#34; command. This will specify the workspace file being 56used. 57 58Usage: 59 60\tgo work \u0026lt;command\u0026gt; [arguments] 61 62The commands are: 63 64\tedit edit go.work from tools or scripts 65\tinit initialize workspace file 66\tsync sync workspace build list to modules 67\tuse add modules to workspace file 68 69Use \u0026#34;go help work \u0026lt;command\u0026gt;\u0026#34; for more information about a command. پیش نیاز ها\nبرای استفاده از workspace حتما باید از نسخه 1.18 گو استفاده کنید. یک ابزار ادیت برای کار باید داشته باشید یک ترمینال مناسب جهت اجرا دستورات 4.4.1 ایجاد workspace # برای ایجاد یک workspace کافیه دستور زیر را بزنید تا در محل پروژه یک فایل go.work ایجاد شود.\n1$ go work init 4.4.2 افزودن ماژول به workspace # در محل workspace یک پوشه ایجاد کنید و دستور go mod init را بزنید تا ماژول ایجاد شود و داخل این محل کدهای ماژول خود را قرار دهید. سپس با دستور go work use می توانید ماژول خود را به workspace اضافه کنید.\n1go work use ./module1 زمانیکه دستور فوق را بزنید پوشه module1 که داخلش ماژول از قبل ایجاد شده به فایل go.work اضافه می شود.\nحال اگر دستور زیر را بزنید می توانید آن ماژول را اگر پکیج main داشته باشد را می تواند اجرا کند :\n1$ go run ./module1 "},{"id":48,"href":"/chapter-4/vendor/","title":"4.5 آموزش کار با Vendor","section":"فصل چهارم: مباحث پیشرفته","content":"در زبان گو یک کامند کاربردی در go mod به نام vendor داریم که ماژول هایی که داخل پروژه استفاده شده و مورد نیاز برای اجرا و بیلد می باشد را در محل پروژه کش می کند و به شما این امکان را می دهد خیلی سریع و راحت بدون نیاز به دانلود مجدد ماژول پروژه را بیلد و اجرا کنید.\n1$ go help mod vendor 2usage: go mod vendor [-e] [-v] [-o outdir] 3 4Vendor resets the main module\u0026#39;s vendor directory to include all packages 5needed to build and test all the main module\u0026#39;s packages. 6It does not include test code for vendored packages. 7 8The -v flag causes vendor to print the names of vendored 9modules and packages to standard error. 10 11The -e flag causes vendor to attempt to proceed despite errors 12encountered while loading packages. 13 14The -o flag causes vendor to create the vendor directory at the given 15path instead of \u0026#34;vendor\u0026#34;. The go command can only use a vendor directory 16named \u0026#34;vendor\u0026#34; within the module root directory, so this flag is 17primarily useful for other tools. 18 19See https://golang.org/ref/mod#go-mod-vendor for more about \u0026#39;go mod vendor\u0026#39;. 4.5.1 ایجاد vendor # با دستور زیر می توانید در محل پروژه خود پوشه vendor ایجاد کنید و ماژول های استفاده شده را داخل این پوشه کش کنید.\n1$ go mod vendor 4.5.2 افزودن ماژول های جدید به vendor # در صورتیکه ماژول جدیدی را به پروژه اضافه کردید حتما باید بصورت دستی vendor را بروز کنید و کافیه دستور زیر را بزنید :\n1$ go mod vendor 4.5.3 اجرا و بیلد پروژه با vendor # شما می توانید پروژه خود را با ماژول های کش شده داخل vendor اجرا و بیلد کنید و دیگر نیازی به دریافت ماژول ها و کش کردن محلی نمی باشد.\nنحوه بیلد\n1$ go build -mod vendor -o main cmd/main.go نحوه اجرا\n1$ go run -mod vendor main.go 4.5.4 نکات کاربردی # یکسری نکات در خصوص استفاده از vendor قرار دادم که به شما می کند تا از vendor به درستی استفاده کنید.\nاز vendor فقط برای پروژه ای استفاده کنید که می خواهد در محیط های مختلف اجرا شود. استفاده از vendor باعث افزایش سریع روند CI/CD هنگام بیلد و تست می شود. زمانیکه vendor ایجاد می کنید فایل بخش های استفاده شده هر ماژول خارجی قرار میگیرد و باعث می شود حجم vendor خیلی کم باشد (پس نگران اینکه vendor مانند npm_module است نباشید) استفاده vendor به IDE گولند کمک می کند در زمان باز کردن پروژه با سرعت بیشتری ماژول ها را index کرده و کدها را سریعتر اسکن کند "},{"id":49,"href":"/chapter-4/command-line-go/","title":"4.6 آموزش نوشتن برنامه command line","section":"فصل چهارم: مباحث پیشرفته","content":" 4.6.1 مقدمه # هنگامی که می‌خواهید نرم‌افزاری بنویسید، ممکن است بخواهید از محیط Command Line یا خط فرمان استفاده کنید. خط فرمان، رابط کاربری ساده‌تری نسبت به محیط گرافیکی دارد و در برخی موارد، سرعت بخش بسیار قابل توجهی است. برای آموزش نوشتن برنامه در خط فرمان، شما به یک زبان برنامه‌نویسی نیاز دارید که از بسیاری از کانسپت‌هایی که در برنامه‌نویسی استفاده می‌شوند، پشتیبانی کند. ما به شما پیشنهاد می‌دهیم که از زبان برنامه‌نویسی Go استفاده کنید زیرا برای کار با Command Line بسیار مناسب است.\nآموزش نوشتن برنامه Command Line به کمک زبان برنامه‌نویسی گو:\nدر اینجا، ما یک مثال ساده از برنامه Hello World با استفاده از Go و Command Line ارائه می‌دهیم. این برنامه، یک پیام ساده را به صفحه نمایش خط فرمان چاپ می‌کند.\nاولین چیزی که شما باید در نظر داشته باشید این است که برنامه‌ی شما باید یک فایل با پسوند .go باشد. برای مثال، می‌توانید یک فایل با نام helloworld.go ایجاد کنید.\nبعد از ایجاد فایل، شما باید کد زیر را به فایل خود اضافه کنید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tfmt.Println(\u0026#34;Hello, World!\u0026#34;) 7} 1$ go run helloworld.go 2Hello, World! اگر کد بالا را به فایل helloworld.go اضافه کردید، می‌توانید با استفاده از Command Line، فایل را اجرا کنید. برای اجرای فایل، ابتدا باید به دایرکتوری فایل برید. سپس می‌توانید دستور برای اجرای فایل را وارد کنید.\nبرای مثال، فرض کنید فایل helloworld.go در دایرکتوری Documents قرار دارد. به عنوان نوشته، این دستورات را در Command Line وارد کنید:\n$ cd Documents\n$ go run helloworld.go\nبا اجرای دستور بالا، برنامه شما اجرا خواهد شد و پیام \u0026ldquo;Hello, World!\u0026rdquo; را در Command Line چاپ می‌کند.\nنتیجه‌گیری:\nاستفاده از خط فرمان برای نوشتن برنامه‌های شما می‌تواند بسیار مفید باشد، اگر یادگیری زبان برنامه‌نویسی Go و چگونگی کار با Command Line را یاد بگیرید. در این مقاله، به شما یک مثال ساده از نوشتن برنامه Command Line با استفاده از Go برای شروع ارائه شد. با ادامه‌ی یادگیری زبان برنامه نویسی Go، شما می‌توانید برنامه‌های پیچیده‌تر را با استفاده از Command Line بسازید.\n4.6.2 نحوه گرفتن arguments به عنوان ورودی از ترمینال # برای گرفتن ورودی از Command Line به عنوان Argument در یک برنامه Go، شما می‌توانید از پایگاه‌داده os در Go استفاده کنید. برای دسترسی به Argumentها، شما می‌توانید متغیرهای os.Args را استفاده کنید. آرایه‌ی os.Args شامل تمامی Argumentهایی است که در Command Line به برنامه شما داده شده است. در زیر، یک مثال ساده از گرفتن دو Argument از Command Line در یک برنامه Go آورده شده است:\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;os\u0026#34; 6) 7 8func main() { 9\targs := os.Args 10\tfmt.Println(\u0026#34;First Argument:\u0026#34;, args[1]) 11\tfmt.Println(\u0026#34;Second Argument:\u0026#34;, args[2]) 12} 1$ go run main.go hello world 2First Argument: hello 3Second Argument: world در کد بالا، ابتدا، ما متغیر os.Args را به متغیر args اختصاص داده‌ایم. سپس، با استفاده از این متغیر، ما مقادیر دو Argument اول را چاپ کرده‌ایم. در اینجا، args[0] نام برنامه Go در Command Line است، بنابراین اولین Argument بعد از آن در args[1] و دومین Argument در args[2] قرار دارد. با تغییر این شماره‌ها، شما می‌توانید به Argument‌های دیگر در Command Line دسترسی داشته باشید.\n4.6.3 کار با flag در زبان گو # در زبان Go، شما می‌توانید از پکیج flag برای ایجاد و مدیریت Flagها در Command Line استفاده کنید. با استفاده از قابلیت Flag، شما می‌توانید به آرگومان های اختیاری و پارامترهای Command Line برنامه خود دسترسی پیدا کنید.\nدر پکیج flag، سه نوع Flag مختلف وجود دارند: string، bool و int. برای ایجاد یک Flag از هر نوع، می‌توانید از توابع flag.String، flag.Bool و flag.Int استفاده کنید.\nدر مثال زیر، ما به کمک Flag یک رشته، یک boolean و یک integer را تعریف و مقداردهی اولیه آن‌ها را انجام می‌دهیم:\n1package main 2 3import ( 4\t\u0026#34;flag\u0026#34; 5\t\u0026#34;fmt\u0026#34; 6) 7 8func main() { 9\t// تعریف یک Flag رشته برای نام کاربری 10\tuserName := flag.String(\u0026#34;username\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;نام کاربری\u0026#34;) 11 12\t// تعریف یک Flag boolean برای پرینت نتیجه 13\tprintResult := flag.Bool(\u0026#34;print\u0026#34;, false, \u0026#34;پرینت نتیجه؟\u0026#34;) 14 15\t// تعریف یک Flag integer برای تعداد تکرار 16\trepeatCount := flag.Int(\u0026#34;count\u0026#34;, 1, \u0026#34;تعداد تکرار\u0026#34;) 17 18\tflag.Parse() 19 20\t// استفاده از Flag ها 21\tfmt.Println(\u0026#34;نام کاربری:\u0026#34;, *userName) 22\tfmt.Println(\u0026#34;پرینت نتیجه؟\u0026#34;, *printResult) 23\tfmt.Println(\u0026#34;تعداد تکرار:\u0026#34;, *repeatCount) 24} 1$ go run main.go -username=John -print=true -count=5 2نام کاربری: john 3پرینت نتیجه؟true 4تعداد تکرار:5 در مثال بالا، ما سه Flag ایجاد کرده‌ایم: username، print و count که به ترتیب متناظر با یک رشته، یک boolean و یک integer هستند. پارامتر اول تابع هر Flag نام آن است، پارامتر دوم مقدار پیش‌فرض و پارامتر سوم توضیحاتی در مورد Flag است.\nدر انتهای برنامه، با استفاده از تابع flag.Parse()، مقدار داده‌شده به Flagها از Command Line دریافت و مقداردهی به متغیرهای var استفاده شده در Flagها انجام می‌گیرد. در مثال بالا، ما با استفاده از اپراتور * به مقدار داده‌شده به هر Flag دریافت شده از Command Line دسترسی پیدا می‌کنیم.\nبا اجرای برنامه و وارد کردن یک Command Line مخصوص مثل زیر، می‌توانید مقدارهای مختلفی به Flagهای برنامه خود اختصاص دهید.\nدر این مثال، مقدار Flag username برابر با \u0026ldquo;John\u0026rdquo;، print برابر با true و count برابر با ۵ می‌باشد.\n"},{"id":50,"href":"/chapter-4/work-with-file-in-go/","title":"4.7 آموزش کار با فایل","section":"فصل چهارم: مباحث پیشرفته","content":" 4.7.1 مقدمه # توسعه دهندگان Go می‌توانند از پکیج‌های built-in مانند \u0026ldquo;os\u0026rdquo; و \u0026ldquo;io\u0026rdquo; برای کار با فایل‌ها استفاده کنند. همچنین، پکیج‌های دیگری نیز برای کار با فایل وجود دارند که می‌توان به عنوان پکیج استاندارد نامید. نمونه ای از این پکیج‌ها، پکیج \u0026ldquo;bufio\u0026rdquo; است که برای کار با بافرهای ورودی/خروجی استفاده شده و به توسعه دهندگان اجازه می‌دهد تا برنامه‌هایی با عملکرد بهتر و با کارایی بالاتر ایجاد کنند.\n4.7.2 باز کردن فایل و خواندن محتوای فایل با پکیج os # برای باز کردن یک فایل متنی و خواندن محتوای آن، می‌توانیم از پکیج \u0026ldquo;os\u0026rdquo; و متد \u0026ldquo;Open\u0026rdquo; استفاده کنیم. در کد زیر، ما یک فایل به نام \u0026ldquo;example.txt\u0026rdquo; باز می‌کنیم و محتوای آن را به صورت خط به خط خوانده و به صفحه کنسول چاپ می‌کنیم:\n1package main 2 3import ( 4\t\u0026#34;bufio\u0026#34; 5\t\u0026#34;fmt\u0026#34; 6\t\u0026#34;log\u0026#34; 7\t\u0026#34;os\u0026#34; 8) 9 10func main() { 11\t// باز کردن فایل برای خواندن 12\tfile, err := os.Open(\u0026#34;example.txt\u0026#34;) 13\tif err != nil { 14\tlog.Fatal(err) 15\t} 16\tdefer file.Close() 17 18\t// خواندن خط به خط از فایل 19\tscanner := bufio.NewScanner(file) 20\tfor scanner.Scan() { 21\tfmt.Println(scanner.Text()) 22\t} 23 24\tif err := scanner.Err(); err != nil { 25\tlog.Fatal(err) 26\t} 27} در کد بالا، با استفاده از متد \u0026ldquo;os.Open\u0026rdquo;، فایل \u0026ldquo;example.txt\u0026rdquo; برای خواندن به صورت فایل شیء باز می‌شود. سپس، با استفاده از متد \u0026ldquo;bufio.NewScanner\u0026rdquo; محتوای فایل به شیء \u0026ldquo;scanner\u0026rdquo; انتقال داده می‌شود و در نهایت با استفاده از حلقه، محتوای فایل خوانده شده خط به خط و به صورت متنی چاپ می‌شود.\nدر نهایت، با استفاده از \u0026ldquo;scanner.Err\u0026rdquo;، خطاهایی که در پروسه خواندن ممکن است بوجود آیند، بررسی شده و مورد احتیاط قرار می‌گیرند.\n4.7.3 نحوه ایجاد فایل و نوشتن محتوا داخل فایل با os # برای ایجاد یک فایل جدید و نوشتن محتوای دلخواه در آن، می‌توانیم از پکیج \u0026ldquo;os\u0026rdquo; و متدهای آن استفاده کنیم. در کد زیر، یک فایل با نام \u0026ldquo;example.txt\u0026rdquo; ساخته شده و پس از باز شدن، متن \u0026ldquo;Hello, World!\u0026rdquo; در داخل آن نوشته می‌شود:\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;os\u0026#34; 6) 7 8func main() { 9\t// ساخت فایل با نام example.txt 10\tfile, err := os.Create(\u0026#34;example.txt\u0026#34;) 11\tif err != nil { 12\tfmt.Println(err) 13\treturn 14\t} 15\tdefer file.Close() 16 17\t// نوشتن محتوا در فایل 18\tfmt.Fprintln(file, \u0026#34;Hello, World!\u0026#34;) 19} در کد بالا، با استفاده از متد \u0026ldquo;os.Create\u0026rdquo;، یک فایل با نام \u0026ldquo;example.txt\u0026rdquo; ایجاد شده و به عنوان یک فایل شیء باز شده است. سپس با استفاده از متد \u0026ldquo;fmt.Fprintln\u0026rdquo;، متن \u0026ldquo;Hello, World!\u0026rdquo; در داخل فایل نوشته می‌شود.\nدر نهایت، با استفاده از \u0026ldquo;file.Close\u0026rdquo;، فایل بسته شده و تمام تغییرات آن ذخیره می‌شود.\n4.7.4 خواندن و نوشتن فایل با استفاده از پکیج io # برای خواندن و نوشتن فایل‌ها می‌توان از پکیج \u0026ldquo;io\u0026rdquo; استفاده کرد. این پکیج امکانات بسیاری را برای کار با بیت‌ها و داده‌های ورودی/خروجی فراهم می‌کند. در کد زیر، یک فایل با نام \u0026ldquo;example.txt\u0026rdquo; باز شده و محتوای آن خوانده شده و به فایل دیگری با نام \u0026ldquo;output.txt\u0026rdquo; کپی می‌شود:\n1package main 2 3import ( 4\t\u0026#34;io\u0026#34; 5\t\u0026#34;log\u0026#34; 6\t\u0026#34;os\u0026#34; 7) 8 9func main() { 10\t// باز کردن فایل برای خواندن 11\tinputFile, err := os.Open(\u0026#34;example.txt\u0026#34;) 12\tif err != nil { 13\tlog.Fatal(err) 14\t} 15\tdefer inputFile.Close() 16 17\t// باز کردن فایل برای نوشتن 18\toutputFile, err := os.Create(\u0026#34;output.txt\u0026#34;) 19\tif err != nil { 20\tlog.Fatal(err) 21\t} 22\tdefer outputFile.Close() 23 24\t// کپی کردن اطلاعات از فایل ورودی به فایل خروجی 25\t_, err = io.Copy(outputFile, inputFile) 26\tif err != nil { 27\tlog.Fatal(err) 28\t} 29} در کد بالا، با استفاده از متدهای \u0026ldquo;os.Open\u0026rdquo; و \u0026ldquo;os.Create\u0026rdquo;، فایل‌های ورودی و خروجی باز شده و به عنوان فایل شیء به برنامه اضافه شده‌اند. سپس با استفاده از متد \u0026ldquo;io.Copy\u0026rdquo;، اطلاعات از فایل ورودی، به فایل خروجی کپی شده‌اند.\nدر نهایت، با استفاده از \u0026ldquo;defer\u0026rdquo; و \u0026ldquo;Close\u0026rdquo;، فایل‌ها بسته شده‌اند و تغییرات آن‌ها ذخیره شده‌اند.\n"},{"id":51,"href":"/chapter-4/work-with-json-file-in-go/","title":"4.8 آموزش کار با json","section":"فصل چهارم: مباحث پیشرفته","content":" 4.8.1 مقدمه # JSON یک فرمت متنی است که برای مبادله و ذخیره داده‌ها استفاده می‌شود. نام JSON مخفف عبارت JavaScript Object Notation است و در ابتدا به عنوان یک زبان مبتنی بر جاوااسکریپت توسعه یافته است. با این حال، در حال حاضر JSON به راحتی با بیشتر زبان‌های برنامه‌نویسی سازگار است.\nJSON یک مجموعه از جفت‌های «key: value» است که با کاما از یکدیگر جدا شده‌اند و بین آنها با «:» ارتباط دارند. JSON در بین برنامه‌نویسان به عنوان یک ساختار داده‌ای محبوب است و به راحتی داده‌ها را به صورت ساختاردهی شده در برنامه‌های کاربردی مختلف به کار می‌رود. این فرمت دیتا استاندارد و مستقل از زبان‌ها و پلتفرم‌های برنامه‌نویسی است و برای برنامه‌های تحت وب، موبایل، دسکتاپ و سرور قابل استفاده است.\nساختار یک فایل JSON شامل تعدادی از آبجکت‌ها و آرایه‌ها می‌باشد. به عبارتی داده‌های JSON می‌توانند در سه نوع اصلی “جسم آرکی”(object) ، “کالکشن آرای”(array) و “مقادیر اولیه”(values) تعریف شوند. آبجکت یک گروه از خصوصیات است که دارای یک کلید منحصر به فرد به عنوان “عنوان شی” می‌باشد. همچنین، آرایه نیز به مشابه یک لیست یا آرایه از خصوصیات است.\nیک مثال ساده JSON:\n1{ 2 \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, 3 \u0026#34;age\u0026#34;: 30, 4 \u0026#34;email\u0026#34;: \u0026#34;johndoe@example.com\u0026#34;, 5 \u0026#34;address\u0026#34;: { 6 \u0026#34;street\u0026#34;: \u0026#34;123 Main St\u0026#34;, 7 \u0026#34;city\u0026#34;: \u0026#34;Anytown\u0026#34;, 8 \u0026#34;state\u0026#34;: \u0026#34;CA\u0026#34;, 9 \u0026#34;zip\u0026#34;: \u0026#34;12345\u0026#34; 10 }, 11 \u0026#34;phone\u0026#34;: [ 12 { 13 \u0026#34;type\u0026#34;: \u0026#34;home\u0026#34;, 14 \u0026#34;number\u0026#34;: \u0026#34;555-555-1234\u0026#34; 15 }, 16 { 17 \u0026#34;type\u0026#34;: \u0026#34;work\u0026#34;, 18 \u0026#34;number\u0026#34;: \u0026#34;555-555-5678\u0026#34; 19 } 20 ] 21} در این مثال، یک شیء با عنوان \u0026ldquo;John Doe\u0026rdquo; تعریف شده است. این شیء دارای خصوصیاتی همچون نام، سن، ایمیل، آدرس و تلفن است. آدرس نیز یک شیء است که شامل خصوصیاتی همچون خیابان، شهر، ایالت و کد پستی است. همچنین، تلفن به عنوان یک آرایه از شیء‌ها تعریف شده است که شامل نوع تلفن و شماره تلفن است.\n4.8.2 کار با marshal و unmarshal پکیج json # در زبان برنامه‌نویسی Go، پکیج \u0026ldquo;encoding/json\u0026rdquo; برای کار با داده‌های JSON بسیار مفید است. این پکیج امکاناتی برای تبدیل داده‌های Go به فرمت JSON (marshal) و برعکس (unmarshal) در اختیار برنامه‌نویسان قرار می‌دهد.\n4.8.2.1 کار با marshal # با استفاده از تابع \u0026ldquo;Marshal\u0026rdquo;، برای مثال، می‌توان یک شیء با فرمت JSON تولید کرد. در کد زیر، یک شیء از نوع \u0026ldquo;person\u0026rdquo; تعریف شده است و با استفاده از تابع \u0026ldquo;Marshal\u0026rdquo; به فرمت JSON تبدیل شده است:\n1package main 2 3import ( 4 \u0026#34;encoding/json\u0026#34; 5 \u0026#34;fmt\u0026#34; 6) 7 8type person struct { 9 Name string `json:\u0026#34;name\u0026#34;` 10 Age int `json:\u0026#34;age\u0026#34;` 11 Email string `json:\u0026#34;email\u0026#34;` 12} 13 14func main() { 15 p := \u0026amp;person{Name: \u0026#34;John Doe\u0026#34;, Age: 30, Email: \u0026#34;john.doe@example.com\u0026#34;} 16 17 b, err := json.Marshal(p) 18 if err != nil { 19 fmt.Println(\u0026#34;error:\u0026#34;, err) 20 } 21 22 fmt.Println(string(b)) 23} 1$ go run main.go 2{\u0026#34;name\u0026#34;:\u0026#34;John Doe\u0026#34;,\u0026#34;age\u0026#34;:30,\u0026#34;email\u0026#34;:\u0026#34;john.doe@example.com\u0026#34;} در کد بالا، ابتدا یک شیء از نوع \u0026ldquo;person\u0026rdquo; با مقادیر مشخص تعریف شده است. سپس از تابع \u0026ldquo;Marshal\u0026rdquo; برای تبدیل این شیء به فرمت JSON استفاده شده است. خروجی تابع \u0026ldquo;Marshal\u0026rdquo; یک بایت‌آرایه است که به عنوان یک رشته و با استفاده از تبدیل به \u0026ldquo;string\u0026rdquo; چاپ شده است.\n4.8.2.2 کار با unmarshal # با استفاده از تابع \u0026ldquo;Unmarshal\u0026rdquo; نیز می‌توان یک رشته JSON را به شیء Go تبدیل کرد. در کد زیر، یک رشته JSON با نام \u0026ldquo;data\u0026rdquo; تعریف شده است و با استفاده از تابع \u0026ldquo;Unmarshal\u0026rdquo; به یک شیء از نوع \u0026ldquo;person\u0026rdquo; تبدیل شده است:\n1package main 2 3import ( 4 \u0026#34;encoding/json\u0026#34; 5 \u0026#34;fmt\u0026#34; 6) 7 8type person struct { 9 Name string `json:\u0026#34;name\u0026#34;` 10 Age int `json:\u0026#34;age\u0026#34;` 11 Email string `json:\u0026#34;email\u0026#34;` 12} 13 14func main() { 15 data := `{\u0026#34;name\u0026#34;:\u0026#34;John Doe\u0026#34;,\u0026#34;age\u0026#34;:30,\u0026#34;email\u0026#34;:\u0026#34;john.doe@example.com\u0026#34;}` 16 17 var p person 18 err := json.Unmarshal([]byte(data), \u0026amp;p) 19 if err != nil { 20 fmt.Println(\u0026#34;error:\u0026#34;, err) 21 } 22 23 fmt.Println(p.Name, p.Age, p.Email) 24} 1$ go run main.go 2John Doe 30 john.doe@example.com در کد بالا، ابتدا یک رشته JSON با نام \u0026ldquo;data\u0026rdquo; تعریف شده است. سپس یک شیء از نوع \u0026ldquo;person\u0026rdquo; با استفاده از تابع \u0026ldquo;Unmarshal\u0026rdquo; و با این رشته JSON به شکل مقداردهی شده است. خروجی تابع \u0026ldquo;Unmarshal\u0026rdquo;، شیء \u0026ldquo;person\u0026rdquo; است که بعداً در کد چاپ شده است. توجه داشته باشید که در اینجا از \u0026ldquo;[]byte\u0026rdquo; برای تبدیل رشته به بایت‌آرایه استفاده شده است.\n4.8.3 تبدیل آرایه و slice به json # در Go، می‌توان آرایه‌ها و slice‌ها را به فرمت JSON تبدیل کرد. برای این کار، از تابع \u0026ldquo;Marshal\u0026rdquo; پکیج \u0026ldquo;encoding/json\u0026rdquo; استفاده می‌شود.\nبرای مثال، فرض کنید یک slice‌ از اعداد صحیح داشته باشیم. برای تبدیل این slice به فرمت JSON، کد زیر نمونه‌ای از چگونگی استفاده از تابع \u0026ldquo;Marshal\u0026rdquo; را نشان می‌دهد:\n1package main 2 3import ( 4 \u0026#34;encoding/json\u0026#34; 5 \u0026#34;fmt\u0026#34; 6) 7 8func main() { 9 numbers := []int{1, 2, 3, 4, 5} 10 11 data, err := json.Marshal(numbers) 12 if err != nil { 13 fmt.Println(\u0026#34;error:\u0026#34;, err) 14 } 15 16 fmt.Println(string(data)) 17} 1$ go run main.go 2[1,2,3,4,5] در این کد، ابتدا یک slice‌ از اعداد صحیح تعریف شده است. سپس با استفاده از تابع \u0026ldquo;Marshal\u0026rdquo; این slice‌ به فرمت JSON تبدیل شده و در متغیر \u0026ldquo;data\u0026rdquo; ذخیره شده است. در نهایت، با استفاده از تبدیل به \u0026ldquo;string\u0026rdquo;، خروجی تابع \u0026ldquo;Marshal\u0026rdquo; به صورت یک رشته چاپ شده است.\nهمچنین، می‌توان آرایه‌های چند بعدی را نیز به فرمت JSON تبدیل کرد. در کد زیر، یک آرایه دوبعدی از اعداد صحیح تعریف شده است و به فرمت JSON تبدیل می‌شود:\n1package main 2 3import ( 4 \u0026#34;encoding/json\u0026#34; 5 \u0026#34;fmt\u0026#34; 6) 7 8func main() { 9 var matrix [2][3]int = [2][3]int{{1, 2, 3}, {4, 5, 6}} 10 11 data, err := json.Marshal(matrix) 12 if err != nil { 13 fmt.Println(\u0026#34;error:\u0026#34;, err) 14 } 15 16 fmt.Println(string(data)) 17} 1$ go run main.go 2[[1,2,3],[4,5,6]] در این کد نیز، بعد از تعریف یک آرایه دوبعدی از اعداد صحیح، با استفاده از تابع \u0026ldquo;Marshal\u0026rdquo; آن را به فرمت JSON تبدیل شده و در متغیر \u0026ldquo;data\u0026rdquo; ذخیره شده است. خروجی تابع \u0026ldquo;Marshal\u0026rdquo; نیز به صورت یک رشته چاپ می‌شود.\n4.8.4 تبدیل map به json # در Go، می‌توان map را به فرمت JSON تبدیل کرد با استفاده از تابع \u0026ldquo;Marshal\u0026rdquo; در پکیج \u0026ldquo;encoding/json\u0026rdquo; میتوان این کار را انجام داد.\nبرای مثال، فرض کنید یک map از داده‌های شخصی داشته باشیم که شامل نام، سن و ایمیل است. برای تبدیل این map به فرمت JSON، کد زیر نمونه‌ای از چگونگی استفاده از تابع \u0026ldquo;Marshal\u0026rdquo; را نشان می‌دهد:\n1package main 2 3import ( 4 \u0026#34;encoding/json\u0026#34; 5 \u0026#34;fmt\u0026#34; 6) 7 8func main() { 9 data := map[string]interface{}{ 10 \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, 11 \u0026#34;age\u0026#34;: 30, 12 \u0026#34;email\u0026#34;: \u0026#34;john.doe@example.com\u0026#34;, 13 } 14 15 output, err := json.Marshal(data) 16 if err != nil { 17 fmt.Println(\u0026#34;error:\u0026#34;, err) 18 } 19 20 fmt.Println(string(output)) 21} 1$ go run main.go 2{\u0026#34;age\u0026#34;:30,\u0026#34;email\u0026#34;:\u0026#34;john.doe@example.com\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;John Doe\u0026#34;} در کد بالا، یک map از داده‌های شخصی با نام \u0026ldquo;data\u0026rdquo; تعریف شده است و سپس با استفاده از تابع \u0026ldquo;Marshal\u0026rdquo; به فرمت JSON تبدیل شده است. خروجی تابع \u0026ldquo;Marshal\u0026rdquo; نیز به صورت یک رشته چاپ شده است.\nتوجه داشته باشید که در این نمونه، نوع داده‌ی مقدارهای مپ از نوع خاصی استفاده نشده است و به جای آن، از نوع \u0026ldquo;interface{}\u0026rdquo; برای مقادیر استفاده شده است. این به این دلیل است که ممکن است مقادیر مختلفی در map وجود داشته باشد ولی نوعشان کاملاً شناخته شده نباشد. با استفاده از \u0026ldquo;interface{}\u0026quot;، مقادیر به صورت پویا تعریف شده و برنامه قادر است به درستی تبدیل را انجام دهد.\n4.8.5 کتابخانه GJSON # استفاده از فرمت json در زبان برنامه نویسی گو به راحتی استفاده از این فرمت در سایر زبان های برنامه نویسی دیگر مثل پایتون نیست و برای اینکه این مورد ساده‌تر شود توصیه میشود از کتابخانه GJSON استفاده شود.\nکتابخانه GJSON یک بسته Go است که راهی سریع و ساده برای دریافت مقادیر از یک سند json ارائه می دهد. دارای ویژگی هاییone line retrieval, dot notation paths, iteration,، و parsing json lines است.\nاین توضیحات یک نمای کلی از نحوه استفاده از GJSON است، برای اطلاعات بیشتر،GJSON Syntax را بررسی کنید.\n4.8.5.1 راه اندازی و نصب GJSON # برای نصب می توانیم از کد زیر استفاده کنیم.\n1go get -u github.com/tidwall/gjson با این کار کتابخانه نصب می شود.\n4.8.5.2 خواندن مقادیر با GJSON # برای جستجوی مقدار مورد نظر json را برای آدرس یا فایل مشخص شده دریافت کنید. کافیست کلید های تو در تو را تنها توسط یک نقطه، مانند \u0026rsquo;name.last\u0026rsquo; یا \u0026lsquo;age\u0026rsquo; فراخوانی کرده و مقدار درون آن را بدست آورید. به عنوان مثال در کد زیر:\n1package main 2 3import \u0026#34;github.com/tidwall/gjson\u0026#34; 4 5const json = `{\u0026#34;name\u0026#34;:{\u0026#34;first\u0026#34;:\u0026#34;Janet\u0026#34;,\u0026#34;last\u0026#34;:\u0026#34;Prichard\u0026#34;},\u0026#34;age\u0026#34;:47}` 6 7func main() { 8\tvalue := gjson.Get(json, \u0026#34;name.last\u0026#34;) 9\tprintln(value.String()) 10} خروجی به صورت زیر خواهد بود:\n1Prichard همچنین تابع GetMany برای دریافت چندین مقدار در یک زمان و GetBytes برای کار با slices بایت JSON وجود دارد.\n4.8.5.3 Path Syntax # در زیر یک نمای کلی از path syntax ارائه شده است، برای اطلاعات کامل تر لطفاً GJSON Syntax را بررسی کنید.\nیک path مجموعه ای از کلیدها است که با یک نقطه از هم جدا شده اند. یک کلید ممکن است حاوی کاراکترهای ویژه \u0026lsquo;*\u0026rsquo; و \u0026lsquo;؟\u0026rsquo; باشد. برای دسترسی به مقدار آرایه از شاخص به عنوان کلید استفاده کنید. برای به دست آوردن تعداد عناصر در یک آرایه یا دسترسی به یک path فرزند، از کاراکتر \u0026lsquo;#\u0026rsquo; استفاده کنید. کاراکترهای dot و wildcard را می توان با \u0026rsquo;\u0026rsquo; escape کرد.\n‍‍\n1{ 2 \u0026#34;name\u0026#34;: {\u0026#34;first\u0026#34;: \u0026#34;Tom\u0026#34;, \u0026#34;last\u0026#34;: \u0026#34;Anderson\u0026#34;}, 3 \u0026#34;age\u0026#34;:37, 4 \u0026#34;children\u0026#34;: [\u0026#34;Sara\u0026#34;,\u0026#34;Alex\u0026#34;,\u0026#34;Jack\u0026#34;], 5 \u0026#34;fav.movie\u0026#34;: \u0026#34;Deer Hunter\u0026#34;, 6 \u0026#34;friends\u0026#34;: [ 7 {\u0026#34;first\u0026#34;: \u0026#34;Dale\u0026#34;, \u0026#34;last\u0026#34;: \u0026#34;Murphy\u0026#34;, \u0026#34;age\u0026#34;: 44, \u0026#34;nets\u0026#34;: [\u0026#34;ig\u0026#34;, \u0026#34;fb\u0026#34;, \u0026#34;tw\u0026#34;]}, 8 {\u0026#34;first\u0026#34;: \u0026#34;Roger\u0026#34;, \u0026#34;last\u0026#34;: \u0026#34;Craig\u0026#34;, \u0026#34;age\u0026#34;: 68, \u0026#34;nets\u0026#34;: [\u0026#34;fb\u0026#34;, \u0026#34;tw\u0026#34;]}, 9 {\u0026#34;first\u0026#34;: \u0026#34;Jane\u0026#34;, \u0026#34;last\u0026#34;: \u0026#34;Murphy\u0026#34;, \u0026#34;age\u0026#34;: 47, \u0026#34;nets\u0026#34;: [\u0026#34;ig\u0026#34;, \u0026#34;tw\u0026#34;]} 10 ] 11} 1\u0026#34;name.last\u0026#34; \u0026gt;\u0026gt; \u0026#34;Anderson\u0026#34; 2\u0026#34;age\u0026#34; \u0026gt;\u0026gt; 37 3\u0026#34;children\u0026#34; \u0026gt;\u0026gt; [\u0026#34;Sara\u0026#34;,\u0026#34;Alex\u0026#34;,\u0026#34;Jack\u0026#34;] 4\u0026#34;children.#\u0026#34; \u0026gt;\u0026gt; 3 5\u0026#34;children.1\u0026#34; \u0026gt;\u0026gt; \u0026#34;Alex\u0026#34; 6\u0026#34;child*.2\u0026#34; \u0026gt;\u0026gt; \u0026#34;Jack\u0026#34; 7\u0026#34;c?ildren.0\u0026#34; \u0026gt;\u0026gt; \u0026#34;Sara\u0026#34; 8\u0026#34;fav\\.movie\u0026#34; \u0026gt;\u0026gt; \u0026#34;Deer Hunter\u0026#34; 9\u0026#34;friends.#.first\u0026#34; \u0026gt;\u0026gt; [\u0026#34;Dale\u0026#34;,\u0026#34;Roger\u0026#34;,\u0026#34;Jane\u0026#34;] 10\u0026#34;friends.1.last\u0026#34; \u0026gt;\u0026gt; \u0026#34;Craig\u0026#34; همچنین می‌توانید با استفاده از #(...), آرایه‌ای را برای پیدا کردن اولین match یا تطابق مورد نظر بررسی کنید، یا همه موارد مورد نظر را با #(...)# را پیدا کنید. کوئری ها از عملگرهای مقایسه ==, !=, \u0026lt;, \u0026lt;=, \u0026gt;, \u0026gt;= و الگوی ساده تطبیق عملگرهای % (like) و !% (not like) پشتیبانی می کنند.\n‍‍‍‍‍\n1friends.#(last==\u0026#34;Murphy\u0026#34;).first \u0026gt;\u0026gt; \u0026#34;Dale\u0026#34; 2friends.#(last==\u0026#34;Murphy\u0026#34;)#.first \u0026gt;\u0026gt; [\u0026#34;Dale\u0026#34;,\u0026#34;Jane\u0026#34;] 3friends.#(age\u0026gt;45)#.last \u0026gt;\u0026gt; [\u0026#34;Craig\u0026#34;,\u0026#34;Murphy\u0026#34;] 4friends.#(first%\u0026#34;D*\u0026#34;).last \u0026gt;\u0026gt; \u0026#34;Murphy\u0026#34; 5friends.#(first!%\u0026#34;D*\u0026#34;).last \u0026gt;\u0026gt; \u0026#34;Craig\u0026#34; 6friends.#(nets.#(==\u0026#34;fb\u0026#34;))#.first \u0026gt;\u0026gt; [\u0026#34;Dale\u0026#34;,\u0026#34;Roger\u0026#34;] لطفاً توجه داشته باشید که قبل از نسخه 1.3.0، کوئری ها از براکت های #[\u0026hellip;] استفاده می کردند. این در نسخه 1.3.0 تغییر کرد تا از سردرگمی با سینتکس چند مسیری جدید جلوگیری شود. برای backwards compatibility ، #[\u0026hellip;] تا نسخه اصلی بعدی به کار خود ادامه خواهد داد.\n4.8.5.4 Result Type # کتابخانه GJSON از انواع json string، number، bool و null پشتیبانی می کند. آرایه ها و اشیاء به عنوان نوع خام json خود برگردانده می شوند.\nنوع Result یکی از این موارد را دارد:\n‍‍‍\n1bool, for JSON booleans 2float64, for JSON numbers 3string, for JSON string literals 4nil, for JSON null برای دسترسی مستقیم به مقدار مورد نظر:\n1result.Type // can be String, Number, True, False, Null, or JSON 2result.Str // holds the string 3result.Num // holds the float64 number 4result.Raw // holds the raw json 5result.Index // index of raw value in original json, zero means index unknown 6result.Indexes // indexes of all the elements that match on a path containing the \u0026#39;#\u0026#39; query character. انواع مختلفی از توابع مفید وجود دارد که بر روی یک نتیجه کار می کنند:\n1result.Exists() bool 2result.Value() interface{} 3result.Int() int64 4result.Uint() uint64 5result.Float() float64 6result.String() string 7result.Bool() bool 8result.Time() time.Time 9result.Array() []gjson.Result 10result.Map() map[string]gjson.Result 11result.Get(path string) Result 12result.ForEach(iterator func(key, value Result) bool) 13result.Less(token Result, caseSensitive bool) bool تابع result.Value() یک interface{} را برمی‌گرداند که به type assertion نیاز دارد و که یکی از type های Go به صورت زیر است:\n1boolean \u0026gt;\u0026gt; bool 2number \u0026gt;\u0026gt; float64 3string \u0026gt;\u0026gt; string 4null \u0026gt;\u0026gt; nil 5array \u0026gt;\u0026gt; []interface{} 6object \u0026gt;\u0026gt; map[string]interface{} تابع result.Array() آرایه ای از مقادیر را برمی گرداند. اگر نتیجه یک مقدار غیر موجود را نشان دهد، یک آرایه خالی برگردانده می شود. اگر نتیجه یک آرایه JSON نباشد، مقدار بازگشتی یک آرایه حاوی یک نتیجه خواهد بود.\n64-bit integers # فراخوانی های result.Int() و result.Uint() قادر به خواندن تمام 64 بیت هستند و امکان کار با اعداد صحیح JSON را فراهم می کنند.\n1result.Int() int64 // -9223372036854775808 to 9223372036854775807 2result.Uint() uint64 // 0 to 18446744073709551615 4.8.5.5 Modifiers and path chaining # اصلاح کننده یک جزء مسیر است که پردازش custom شده‌ای را روی json انجام می دهد.\nچندین مسیر را می توان با استفاده از pipe character به هم «chained» کرد. این برای دریافت نتایج از یک query اصلاح شده مفید است.\nبه عنوان مثال، با استفاده از اصلاح‌کننده @reverse داخلی در سند json بالا، آرایه فرزندان را دریافت می‌کنیم و ترتیب را برعکس می‌کنیم:\n‍\n1\u0026#34;children|@reverse\u0026#34; \u0026gt;\u0026gt; [\u0026#34;Jack\u0026#34;,\u0026#34;Alex\u0026#34;,\u0026#34;Sara\u0026#34;] 2\u0026#34;children|@reverse|0\u0026#34; \u0026gt;\u0026gt; \u0026#34;Jack\u0026#34; در حال حاضر اصلاح کننده های داخلی زیر وجود دارد:\n@reverse: یک آرایه یا اعضای یک شی را معکوس کنید. @ugly: تمام فضای خالی را از یک سند json حذف کنید. @pretty: سند json را برای انسان قابل خواندن تر کنید. @this: عنصر فعلی را برمی‌گرداند. می توان از آن برای بازیابی عنصر ریشه استفاده کرد. @valid: مطمئن شوید که سند json معتبر است. @flatten: یک آرایه را صاف می کند. @join: چندین شی را به یک شیء متصل می کند. @keys: آرایه ای از کلیدها را برای یک شی برمی گرداند. @values: آرایه ای از مقادیر را برای یک شی برمی گرداند. @tostr: json را به یک رشته تبدیل می کند. یک رشته json را می پیچد. @fromstr: یک رشته را از json تبدیل می کند. یک رشته json را باز می کند. @group: آرایه های اشیاء را گروه بندی می کند. e4fc67c. را ببینید. Modifier arguments\nیک اصلاح کننده ممکن است یک آرگومان اختیاری را بپذیرد. آرگومان می تواند یک سند JSON معتبر یا فقط کاراکتر باشد.\nبه عنوان مثال، اصلاح کننده @pretty یک شی json را به عنوان آرگومان خود می گیرد.\n@pretty:{\u0026#34;sortKeys\u0026#34;:true} که json را زیبا می کند و تمام کلیدهای آن را سفارش می دهد.\n1{ 2 \u0026#34;age\u0026#34;:37, 3 \u0026#34;children\u0026#34;: [\u0026#34;Sara\u0026#34;,\u0026#34;Alex\u0026#34;,\u0026#34;Jack\u0026#34;], 4 \u0026#34;fav.movie\u0026#34;: \u0026#34;Deer Hunter\u0026#34;, 5 \u0026#34;friends\u0026#34;: [ 6 {\u0026#34;age\u0026#34;: 44, \u0026#34;first\u0026#34;: \u0026#34;Dale\u0026#34;, \u0026#34;last\u0026#34;: \u0026#34;Murphy\u0026#34;}, 7 {\u0026#34;age\u0026#34;: 68, \u0026#34;first\u0026#34;: \u0026#34;Roger\u0026#34;, \u0026#34;last\u0026#34;: \u0026#34;Craig\u0026#34;}, 8 {\u0026#34;age\u0026#34;: 47, \u0026#34;first\u0026#34;: \u0026#34;Jane\u0026#34;, \u0026#34;last\u0026#34;: \u0026#34;Murphy\u0026#34;} 9 ], 10 \u0026#34;name\u0026#34;: {\u0026#34;first\u0026#34;: \u0026#34;Tom\u0026#34;, \u0026#34;last\u0026#34;: \u0026#34;Anderson\u0026#34;} 11} لیست کامل گزینه های @pretty عبارتند از sortKeys, indent, prefix, و width. لطفاً برای اطلاعات بیشتر به _Pretty Options_مراجعه کنید.\nCustom modifiers # همچنین می توانید اصلاح کننده های سفارشی اضافه کنید. به عنوان مثال، در اینجا ما یک اصلاح کننده ایجاد می کنیم که کل سند json را upper case یا lower case می کند.\n1gjson.AddModifier(\u0026#34;case\u0026#34;, func(json, arg string) string { 2 if arg == \u0026#34;upper\u0026#34; { 3 return strings.ToUpper(json) 4 } 5 if arg == \u0026#34;lower\u0026#34; { 6 return strings.ToLower(json) 7 } 8 return json 9}) \u0026#34;children|@case:upper\u0026#34; \u0026gt;\u0026gt; [\u0026#34;SARA\u0026#34;,\u0026#34;ALEX\u0026#34;,\u0026#34;JACK\u0026#34;] \u0026#34;children|@case:lower|@reverse\u0026#34; \u0026gt;\u0026gt; [\u0026#34;jack\u0026#34;,\u0026#34;alex\u0026#34;,\u0026#34;sara\u0026#34;] 4.8.5.6 JSON Lines # پشتیبانی از JSON Lines با استفاده از پیشوند .. وجود دارد که یک سند چند خطی را به عنوان یک آرایه در نظر می گیرد.\nبه عنوان مثال:\n{\u0026#34;name\u0026#34;: \u0026#34;Gilbert\u0026#34;, \u0026#34;age\u0026#34;: 61} {\u0026#34;name\u0026#34;: \u0026#34;Alexa\u0026#34;, \u0026#34;age\u0026#34;: 34} {\u0026#34;name\u0026#34;: \u0026#34;May\u0026#34;, \u0026#34;age\u0026#34;: 57} {\u0026#34;name\u0026#34;: \u0026#34;Deloise\u0026#34;, \u0026#34;age\u0026#34;: 44} تابع ForEachLines از طریق خطوط JSON تکرار می شود.\n1gjson.ForEachLine(json, func(line gjson.Result) bool{ 2 println(line.String()) 3 return true 4}) 4.8.5.7 خواندن مقدارهای تو در تو یا nested # فرض کنید همه نام‌های خانوادگی را از json زیر می‌خواهید:\n‍‍\n1{ 2 \u0026#34;programmers\u0026#34;: [ 3 { 4 \u0026#34;firstName\u0026#34;: \u0026#34;Janet\u0026#34;, 5 \u0026#34;lastName\u0026#34;: \u0026#34;McLaughlin\u0026#34;, 6 }, { 7 \u0026#34;firstName\u0026#34;: \u0026#34;Elliotte\u0026#34;, 8 \u0026#34;lastName\u0026#34;: \u0026#34;Hunter\u0026#34;, 9 }, { 10 \u0026#34;firstName\u0026#34;: \u0026#34;Jason\u0026#34;, 11 \u0026#34;lastName\u0026#34;: \u0026#34;Harold\u0026#34;, 12 } 13 ] 14} شما می توانید از مسیر \u0026lsquo;programmers.#.lastName\u0026rsquo; مانند این استفاده کنید:\n‍‍\n1result := gjson.Get(json, \u0026#34;programmers.#.lastName\u0026#34;) 2for _, name := range result.Array() { 3\tprintln(name.String()) 4} همچنین می توانید یک شی در داخل یک آرایه را پرس و جو کنید:\n1name := gjson.Get(json, `programmers.#(lastName=\u0026#34;Hunter\u0026#34;).firstName`) 2println(name.String()) // prints \u0026#34;Elliotte\u0026#34; 4.8.5.8 پیمایش یک شی یا آرایه # تابع ForEach امکان تکرار سریع از طریق یک شی یا آرایه را فراهم می کند. کلید و مقدار برای اشیا به تابع تکرار کننده ارسال می شود. فقط مقدار برای آرایه ها ارسال می شود. برگرداندن false از یک تکرار کننده، تکرار را متوقف می کند.\n1result := gjson.Get(json, \u0026#34;programmers\u0026#34;) 2result.ForEach(func(key, value gjson.Result) bool { 3\tprintln(value.String()) 4\treturn true // keep iterating 5}) 4.8.5.9 Simple Parse and Get # یک تابع Parse(json) وجود دارد که یک تجزیه ساده را انجام می دهد و result.Get(path) که یک نتیجه را جستجو می کند. به عنوان مثال، همه اینها نتیجه یکسانی را نشان می دهند:\n1gjson.Parse(json).Get(\u0026#34;name\u0026#34;).Get(\u0026#34;last\u0026#34;) 2gjson.Get(json, \u0026#34;name\u0026#34;).Get(\u0026#34;last\u0026#34;) 3gjson.Get(json, \u0026#34;name.last\u0026#34;) 4.8.5.10 بررسی جهت وجود یک value خاص # گاهی اوقات فقط می خواهیم بدانیم که آیا یک مقدار وجود دارد یا خیر.\n1value := gjson.Get(json, \u0026#34;name.last\u0026#34;) 2if !value.Exists() { 3\tprintln(\u0026#34;no last name\u0026#34;) 4} else { 5\tprintln(value.String()) 6} 7 8// Or as one step 9if gjson.Get(json, \u0026#34;name.last\u0026#34;).Exists() { 10\tprintln(\u0026#34;has a last name\u0026#34;) 11} 4.8.5.11 اعتبار سنجی JSON # توابع Get* و Parse* انتظار دارند که فایل حاوی json به سالم و استاندارد باشد. خطا در فایل json باعث حالت panic نمی‌شود، اما ممکن است نتایج غیرمنتظره را بازگرداند.\nاگر JSON را از یک منبع غیرقابل نامشخص استفاده کنید، ممکن است بخواهید قبل از استفاده از GJSON اعتبار سنجی کنید.\n‍\n1if !gjson.Valid(json) { 2\treturn errors.New(\u0026#34;invalid json\u0026#34;) 3} 4value := gjson.Get(json, \u0026#34;name.last\u0026#34;) 4.8.5.12 Unmarshal به یک map # برای unmarshal به مپ به صورت map[string]interface{}:\n‍‍\n1m, ok := gjson.Parse(json).Value().(map[string]interface{}) 2if !ok { 3\t// not a map 4} 4.8.5.13 کار با byte ها # اگر درJSON فایل مورد نظر شما []byte slice وجود دارد، تابع GetBytes برای این حالت وجود دارد. این تابع در استفاده از Get(string(data), path) ترجیح داده می شود.\n‍‍\n1var json []byte = ... 2result := gjson.GetBytes(json, path) اگر از تابع gjson.GetBytes(json, path) استفاده می کنید و می خواهید از تبدیل result.Raw به []byte اجتناب کنید، می توانید از این الگو استفاده کنید:\n1var json []byte = ... 2result := gjson.GetBytes(json, path) 3var raw []byte 4if result.Index \u0026gt; 0 { 5 raw = json[result.Index:result.Index+len(result.Raw)] 6} else { 7 raw = []byte(result.Raw) 8} این روش از فیلد result.Index استفاده می‌کند که موقعیت داده‌های خام در json فایل است. ممکن است که مقدار result.Index برابر با صفر باشد، در این صورت result.Raw به یک []byte تبدیل می‌شود.\n4.8.5.14 خواندن چندین value # تابع GetMany می تواند برای دریافت چندین مقدار به طور همزمان استفاده شود.\n‍‍\n1results := gjson.GetMany(json, \u0026#34;name.first\u0026#34;, \u0026#34;name.last\u0026#34;, \u0026#34;age\u0026#34;) مقدار بازگشتی یک []Result است، که همیشه دارای دقیقاً همان تعداد آیتم‌هایی است که مسیرهای ورودی دارند.\n4.8.6 کتابخانه SJSON # در واقع SJSON یک کتابخانه‌ای است که یک راه بسیار سریع و ساده برای تنظیم یک value در یک سند json ارائه می دهد. در بخش قبلی فقط می‌توانستیم مقادیر موجود در یک سند json بازخوانی کنیم ولی به کمک sjson می توانیم مقادیر مورد نظر را در یک سند json وارد کرده یا به روزرسانی و حذف دهیم.\n4.8.6.1 راه اندازی و نصب SJSON # برای شروع استفاده از SJSON باید آن را نصب کنید و go get را اجرا کنید:\n1$ go get -u github.com/tidwall/sjson با این کار کتابخانه نصب می شود.\n4.8.6.2 Set a value # دستور Set مقدار یا value ای را برای path مشخص شده اجرا می کند. یک path در یک dot syntax مشخص می‌شود، مانند \u0026rsquo;name.last\u0026rsquo; یا \u0026lsquo;age\u0026rsquo;. در این عملکرد انتظار می‌رود که ساختار کلی json صحیح و valid باشد. در صورت اشکال در ساختار json فایل و Invalid بودن آن، حالت panic رخ نمی‌دهد، اما ممکن است نتایج غیرمنتظره‌ای را برگرداند. البته pathهای نامعتبر ممکن است ایجاد خطا کند. به عنوان مثال کد زیر:\n1package main 2 3import \u0026#34;github.com/tidwall/sjson\u0026#34; 4 5const json = `{\u0026#34;name\u0026#34;:{\u0026#34;first\u0026#34;:\u0026#34;Janet\u0026#34;,\u0026#34;last\u0026#34;:\u0026#34;Prichard\u0026#34;},\u0026#34;age\u0026#34;:47}` 6 7func main() { 8\tvalue, _ := sjson.Set(json, \u0026#34;name.last\u0026#34;, \u0026#34;Anderson\u0026#34;) 9\tprintln(value) 10} خروجی به شکل زیر خواهد بود:\n1{\u0026#34;name\u0026#34;:{\u0026#34;first\u0026#34;:\u0026#34;Janet\u0026#34;,\u0026#34;last\u0026#34;:\u0026#34;Anderson\u0026#34;},\u0026#34;age\u0026#34;:47} 4.8.6.3 Path syntax # در واقع path یا مسیر مجموعه ای از کلیدها است که با یک نقطه از هم جدا شده اند. کاراکترهای dot و colon را می توان با کاراکتر \\ به راحتی escape کرد.\n1{ 2 \u0026#34;name\u0026#34;: {\u0026#34;first\u0026#34;: \u0026#34;Tom\u0026#34;, \u0026#34;last\u0026#34;: \u0026#34;Anderson\u0026#34;}, 3 \u0026#34;age\u0026#34;:37, 4 \u0026#34;children\u0026#34;: [\u0026#34;Sara\u0026#34;,\u0026#34;Alex\u0026#34;,\u0026#34;Jack\u0026#34;], 5 \u0026#34;fav.movie\u0026#34;: \u0026#34;Deer Hunter\u0026#34;, 6 \u0026#34;friends\u0026#34;: [ 7\t{\u0026#34;first\u0026#34;: \u0026#34;James\u0026#34;, \u0026#34;last\u0026#34;: \u0026#34;Murphy\u0026#34;}, 8\t{\u0026#34;first\u0026#34;: \u0026#34;Roger\u0026#34;, \u0026#34;last\u0026#34;: \u0026#34;Craig\u0026#34;} 9 ] 10} \u0026#34;name.last\u0026#34; \u0026gt;\u0026gt; \u0026#34;Anderson\u0026#34; \u0026#34;age\u0026#34; \u0026gt;\u0026gt; 37 \u0026#34;children.1\u0026#34; \u0026gt;\u0026gt; \u0026#34;Alex\u0026#34; \u0026#34;friends.1.last\u0026#34; \u0026gt;\u0026gt; \u0026#34;Craig\u0026#34; از کلید -1 می توان برای افزودن یک مقدار به آرایه موجود استفاده کرد:\n\u0026#34;children.-1\u0026#34; \u0026gt;\u0026gt; appends a new value to the end of the children array معمولاً از کلیدهای عددی برای اصلاح آرایه ها استفاده می شود، اما می توان با استفاده از کاراکتر دو نقطه، یک کلید شی عددی را اجرا کرد:\n1{ 2 \u0026#34;users\u0026#34;:{ 3 \u0026#34;2313\u0026#34;:{\u0026#34;name\u0026#34;:\u0026#34;Sara\u0026#34;}, 4 \u0026#34;7839\u0026#34;:{\u0026#34;name\u0026#34;:\u0026#34;Andy\u0026#34;} 5 } 6} همینطور colon path به صورت زیر است:\n\u0026#34;users.:2313.name\u0026#34; \u0026gt;\u0026gt; \u0026#34;Sara\u0026#34; 4.8.6.4 Supported types # در کتابخانه SJSON تقریباً هر نوع متغیر یا type ای پشتیبانی می شود:\n1sjson.Set(`{\u0026#34;key\u0026#34;:true}`, \u0026#34;key\u0026#34;, nil) 2sjson.Set(`{\u0026#34;key\u0026#34;:true}`, \u0026#34;key\u0026#34;, false) 3sjson.Set(`{\u0026#34;key\u0026#34;:true}`, \u0026#34;key\u0026#34;, 1) 4sjson.Set(`{\u0026#34;key\u0026#34;:true}`, \u0026#34;key\u0026#34;, 10.5) 5sjson.Set(`{\u0026#34;key\u0026#34;:true}`, \u0026#34;key\u0026#34;, \u0026#34;hello\u0026#34;) 6sjson.Set(`{\u0026#34;key\u0026#34;:true}`, \u0026#34;key\u0026#34;, []string{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}) 7sjson.Set(`{\u0026#34;key\u0026#34;:true}`, \u0026#34;key\u0026#34;, map[string]interface{}{\u0026#34;hello\u0026#34;:\u0026#34;world\u0026#34;}) هنگامی که یک type شناسایی نمی شود، SJSON به رمزگذاری encoding/json باز می گردد.\n4.8.6.5 مثال SJSON # در این بخش به بررسی چند مثال از SJSON می پردازیم:\nوارد کردن یک مقدار در یک json document خالی.\n1value, _ := sjson.Set(\u0026#34;\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;Tom\u0026#34;) 2println(value) 3 4// Output: 5// {\u0026#34;name\u0026#34;:\u0026#34;Tom\u0026#34;} وارد کردن یک مقادیر تو در تو یا nested در یک json document خالی.\n1value, _ := sjson.Set(\u0026#34;\u0026#34;, \u0026#34;name.last\u0026#34;, \u0026#34;Anderson\u0026#34;) 2println(value) 3 4// Output: 5// {\u0026#34;name\u0026#34;:{\u0026#34;last\u0026#34;:\u0026#34;Anderson\u0026#34;}} وارد کردن مقدار جدید در سند:\n1value, _ := sjson.Set(`{\u0026#34;name\u0026#34;:{\u0026#34;last\u0026#34;:\u0026#34;Anderson\u0026#34;}}`, \u0026#34;name.first\u0026#34;, \u0026#34;Sara\u0026#34;) 2println(value) 3 4// Output: 5// {\u0026#34;name\u0026#34;:{\u0026#34;first\u0026#34;:\u0026#34;Sara\u0026#34;,\u0026#34;last\u0026#34;:\u0026#34;Anderson\u0026#34;}} بروزرسانی و آپدیت یک سند:\n1value, _ := sjson.Set(`{\u0026#34;name\u0026#34;:{\u0026#34;last\u0026#34;:\u0026#34;Anderson\u0026#34;}}`, \u0026#34;name.last\u0026#34;, \u0026#34;Smith\u0026#34;) 2println(value) 3 4// Output: 5// {\u0026#34;name\u0026#34;:{\u0026#34;last\u0026#34;:\u0026#34;Smith\u0026#34;}} وارد کردن مقدار آرایه جدید:\n1value, _ := sjson.Set(`{\u0026#34;friends\u0026#34;:[\u0026#34;Andy\u0026#34;,\u0026#34;Carol\u0026#34;]}`, \u0026#34;friends.2\u0026#34;, \u0026#34;Sara\u0026#34;) 2println(value) 3 4// Output: 5// {\u0026#34;friends\u0026#34;:[\u0026#34;Andy\u0026#34;,\u0026#34;Carol\u0026#34;,\u0026#34;Sara\u0026#34;] اضافه کردن مقدار جدید به انتهای آرایه با استفاده از گزینه 1- :\n1value, _ := sjson.Set(`{\u0026#34;friends\u0026#34;:[\u0026#34;Andy\u0026#34;,\u0026#34;Carol\u0026#34;]}`, \u0026#34;friends.-1\u0026#34;, \u0026#34;Sara\u0026#34;) 2println(value) 3 4// Output: 5// {\u0026#34;friends\u0026#34;:[\u0026#34;Andy\u0026#34;,\u0026#34;Carol\u0026#34;,\u0026#34;Sara\u0026#34;] اضافه کردن مقدار جدید به انتهای آرایه و null کردن سایر سلول‌های آرایه که بین انتهای آرایه و آخرین سلولی که دارای مقدار مشخص بوده است :\n1value, _ := sjson.Set(`{\u0026#34;friends\u0026#34;:[\u0026#34;Andy\u0026#34;,\u0026#34;Carol\u0026#34;]}`, \u0026#34;friends.4\u0026#34;, \u0026#34;Sara\u0026#34;) 2println(value) 3 4// Output: 5// {\u0026#34;friends\u0026#34;:[\u0026#34;Andy\u0026#34;,\u0026#34;Carol\u0026#34;,null,null,\u0026#34;Sara\u0026#34;] حذف کردن یک مقدار:\n1value, _ := sjson.Delete(`{\u0026#34;name\u0026#34;:{\u0026#34;first\u0026#34;:\u0026#34;Sara\u0026#34;,\u0026#34;last\u0026#34;:\u0026#34;Anderson\u0026#34;}}`, \u0026#34;name.first\u0026#34;) 2println(value) 3 4// Output: 5// {\u0026#34;name\u0026#34;:{\u0026#34;last\u0026#34;:\u0026#34;Anderson\u0026#34;}} حذف کردن مقادیر آرایه ای:\n1value, _ := sjson.Delete(`{\u0026#34;friends\u0026#34;:[\u0026#34;Andy\u0026#34;,\u0026#34;Carol\u0026#34;]}`, \u0026#34;friends.1\u0026#34;) 2println(value) 3 4// Output: 5// {\u0026#34;friends\u0026#34;:[\u0026#34;Andy\u0026#34;]} حذف کردن انتهای آرایه:\n1value, _ := sjson.Delete(`{\u0026#34;friends\u0026#34;:[\u0026#34;Andy\u0026#34;,\u0026#34;Carol\u0026#34;]}`, \u0026#34;friends.-1\u0026#34;) 2println(value) 3 4// Output: 5// {\u0026#34;friends\u0026#34;:[\u0026#34;Andy\u0026#34;]} "},{"id":52,"href":"/chapter-4/work-with-toml-file-in-go/","title":"4.9 آموزش کار با toml","section":"فصل چهارم: مباحث پیشرفته","content":" 4.9.1 مقدمه # فایل‌های TOML یک نمونه از فایل‌های پیکربندی هستند که در سیستم‌های مدرن مورد استفاده قرار می‌گیرند، این فایل‌ها به صورت متنی و قابل خواندن برای انسان و در عین حال قابل پردازش برای ماشین طراحی شده‌اند.\nTOML مخفف کلمات (Tom\u0026rsquo;s Obvious, Minimal Language) می‌باشد. جمعیت بزرگتری از افراد آن را مفسرند به این شکل که TOML ابزاری ساده برای پیکربندی بسیار درون‌فرمانی است. این فرمت فایل متنی دارای مقادیر شبیه به دیکشنری بوده و در بسیاری از نرم‌افزارها، به‌طور خاص در نرم‌افزارهای ساخته شده با golang بسیار به‌کار می‌رود.\nمثال زیر یک فایل TOML معتبر را نمایش می‌دهد:\n1[database] 2server = \u0026#34;localhost\u0026#34; 3port = 3306 4user = \u0026#34;username\u0026#34; 5password = \u0026#34;password\u0026#34; 6database = \u0026#34;myDB\u0026#34; در این مثال، تمام اطلاعات پیکربندی مربوط به یک پایگاه‌داده وجود دارد (server، port، user و غیره)، و به صورت مشخصی تعریف شده‌اند، به طوری که برای برنامه‌نویسی با استفاده از این پیکربندی بسیار سرعت‌بخش خواهد بود. از آنجا که فایل TOML قابل‌خواندی و ویرایش توسط انسان است، برنامه‌نویسی با این نوع فایل‌ها آسان و قابل فهم خواهد بود.\n4.9.2 کار با marshal و unmarshal پکیج toml # پکیج toml در زبان Go، حاوی توابع Marshal و Unmarshal برای تبدیل داده‌های Go به فرمت TOML و برعکس می‌باشد.\n4.9.2.1 Marshal # تابع Marshal برای تبدیل یک متغیر ساخته شده در Go به فرمت TOML مورد استفاده قرار می‌گیرد. برای استفاده از این تابع، باید داده‌های خود را به یک متغیر با نوع interface{} تبدیل کنید و سپس این متغیر را به تابع Marshal بدهید.\nبه عنوان مثال، برای تبدیل داده‌های map[string]interface{} به فرمت TOML، می‌توانید این کد را به کار ببرید:\n1package main 2 3import ( 4 \u0026#34;github.com/BurntSushi/toml\u0026#34; 5 \u0026#34;fmt\u0026#34; 6) 7 8func main() { 9 data := map[string]interface{}{ 10 \u0026#34;name\u0026#34;: \u0026#34;John\u0026#34;, 11 \u0026#34;email\u0026#34;: \u0026#34;john@example.com\u0026#34;, 12 \u0026#34;age\u0026#34;: 22, 13 } 14 tomlData, err := toml.Marshal(data) 15 if err != nil { 16 panic(err) 17 } 18 fmt.Println(string(tomlData)) 19} این کد یک دیکشنری ساده را تعریف می‌کند و سپس آن را به فرمت TOML تبدیل می‌کند. خروجی به صورت زیر خواهد بود:\n1$ go run main.go 2age = 22 3email = \u0026#34;john@example.com\u0026#34; 4name = \u0026#34;John\u0026#34; 4.9.2.2 Unmarshal # تابع Unmarshal، برای تبدیل یک رشته فرمت TOML به داده‌های Go استفاده می‌شود. برای استفاده از این تابع، باید با استفاده از تابع ioutil.ReadFile، فایل TOML مورد نظر را بخوانید و سپس رشته خوانده‌شده را به تابع Unmarshal بدهید.\nبه عنوان مثال، برای خواندن یک فایل TOML و تبدیل آن به یک دیکشنری در Go، می‌توانید این کد را به کار ببرید:\n1package main 2 3import ( 4 \u0026#34;github.com/BurntSushi/toml\u0026#34; 5 \u0026#34;fmt\u0026#34; 6 \u0026#34;io/ioutil\u0026#34; 7) 8 9type Person struct { 10 Name string 11 Email string 12 Age int 13} 14 15func main() { 16 data, err := ioutil.ReadFile(\u0026#34;file.toml\u0026#34;) 17 if err != nil { 18 panic(err) 19 } 20 21 var person Person 22 if _, err := toml.Decode(string(data), \u0026amp;person); err != nil { 23 panic(err) 24 } 25 26 fmt.Printf(\u0026#34;%#v\\n\u0026#34;, person) 27} این کد یک فایل TOML با فرمت زیر را می‌خواند و مقادیر موجود در آن را به داده‌های Go مناسب تبدیل می‌کند:\n1name = \u0026#34;John\u0026#34; 2email = \u0026#34;john@example.com\u0026#34; 3age = 22 خروجی به صورت زیر خواهد بود:\n1$ go run main.go 2main.Person{Name:\u0026#34;John\u0026#34;, Email:\u0026#34;john@example.com\u0026#34;, Age:22} 4.9.3 تبدیل struct به toml و بلعکس # برای تبدیل یک struct به فرمت TOML و بلعکس، می‌توان از تابع‌های Marshal و Unmarshal پکیج toml استفاده کرد. در این روش، فیلدهای struct بر اساس نام آن‌ها و به صورت حروف کوچک در فایل TOML با نام فیلد متناظر ذخیره می‌شوند.\nهمچنین می‌توان از تگ‌ها در داخل struct برای تعیین نام فیلد در فایل TOML استفاده کرد. با استفاده از تگ toml:\u0026quot;name\u0026quot; می‌توان نامی دلخواه برای فیلد در فایل TOML مشخص کرد. همچنین می‌توان از تگ‌های دیگری مانند toml:\u0026quot;omitempty\u0026quot; برای اجباری نبودن یک فیلد در فایل TOML استفاده کرد.\nبه عنوان مثال، فرض کنید یک struct به نام Person با فیلدهای Name، Emailو Age داریم. با استفاده از تگ‌ها، نام فیلدها در فایل TOML و پیش‌فرض برای آن‌ها مشخص می‌شود.\n1package main 2 3import ( 4 \u0026#34;github.com/BurntSushi/toml\u0026#34; 5 \u0026#34;fmt\u0026#34; 6) 7 8type Person struct { 9 Name string `toml:\u0026#34;name\u0026#34;` 10 Email string `toml:\u0026#34;email,omitempty\u0026#34;` 11 Age int `toml:\u0026#34;age\u0026#34;` 12} 13 14func main() { 15 // Marshaling from struct to TOML 16 person := Person{Name: \u0026#34;John\u0026#34;, Age: 30} 17 tomlData, err := toml.Marshal(person) 18 if err != nil { 19 panic(err) 20 } 21 fmt.Println(string(tomlData)) 22 23 // Unmarshaling from TOML to struct 24 var p Person 25 if _, err := toml.Decode(string(tomlData), \u0026amp;p); err != nil { 26 panic(err) 27 } 28 fmt.Printf(\u0026#34;%#v\\n\u0026#34;, p) 29} در این مثال، struct با نام Person تعریف شده و از تگ برای نام‌گذاری فیلدها استفاده شده است. در تابع main، ابتدا از متد Marshal پکیج toml برای تبدیل یک شیء Person به فرمت TOML استفاده شده است. سپس با استفاده از متد Decode از پکیج toml، فایل TOML به داخل شیء Person تبدیل می‌شود.\nخروجی کد بالا به صورت زیر است:\n1$ go run main.go 2name = \u0026#34;John\u0026#34; 3age = 30 4 5main.Person{Name:\u0026#34;John\u0026#34;, Email:\u0026#34;\u0026#34;, Age:30} همان‌طور که مشاهده می‌کنید، نام فیلدها در فایل TOML با تگ‏های تعیین‌شده در struct مطابقت می‌کند. همچنین با توجه به تگ omitempty که در فیلد Email وجود دارد، این فیلد در فایل TOML نمایش داده نشده است، چرا که در شی person مقداری برای آن تعریف نشده بود.\n"},{"id":53,"href":"/chapter-4/work-with-yaml-file-in-go/","title":"4.10 آموزش کار با yaml","section":"فصل چهارم: مباحث پیشرفته","content":" 4.10.1 مقدمه # YAML یک زبان فراهم کننده ساختار پذیر برای نمایش اطلاعات است که در قالب متن موجود می‌باشد. این زبان ابتدا برای نوشتن سند‌های XML توسعه یافت که با پیشرفت کاربردهای آن به محل جایگزینی برای فرمت‌های رایجی همچون JSON و اقلیتاً TOML تبدیل شده است.\nاین فرمت در صنعت‌های مختلف مورد استفاده و ستوده شده ‌است، مانند ذخیره سازی تنظیمات سیستمی، فایل‌های کانفیگ مختلف، فایل‌های داده و \u0026hellip; . همچنین به خاطر قابل خواندن بودن برای انسان، استفاده از YAML در فایل‌هایی که باید توسط بشر خوانده شوند مانند فایل‌های خودرو، پروژه و\u0026hellip; صورت گرفته است.\nیکی از نمونه‌های کاربردی YAML، استفاده از آن در فایل‌های کانفیگ ‌Docker است. در فایل docker-compose.yaml، بخش‌های مختلفی از یک سرویس در قالب Block mapping و با کلید‌های خاصی مانند version، services، ports و غیره تعریف شده است. این فرمت به طور کل شرکت‌های بزرگی مانند مایکروسافت، ای‌بی‌ای و گوگل، در محصولات خود به صورت فایل‌های YAML استفاده می‌کنند.\nبنابراین، می‌توان گفت YAML یک فرمت متنی ساده و پذیرفتنی است که در بسیاری از پروژه‌های نرم‌افزاری استفاده می‌شود، به خاطر پشتیبانی از انواع داده‌ها و ساختارهای مختلف، قابلیت خواندن و نوشتن آسان برای انسان و قابل استفاده در زبان‌های مختلفی استفاده از YAML در صنایع مختلفی از جمله فناوری‌های اطلاعات، اینترنت اشیا و\u0026hellip; رایج است.\n4.10.2 کار با marshal و unmarshal پکیج yaml # پکیج YAML در زبان Go شامل توابع Marshal و Unmarshal برای تبدیل داده‌های Go به فرمت YAML و بالعکس می‌شود. استفاده از این توابع بسیار ساده است و می‌توان به سرعت با استفاده از ویژگی‌های زبان Go به داده‌ها دسترسی پیدا کرد.\nبرای مثال، فرض کنید یک پرونده YAML با محتوای زیر داریم:\n1name: John 2age: 25 3isStudent: true 4.10.2.1 Marshal # همچنین، می‌توان از تابع Marshal برای تبدیل ساختار داده‌ای Go به فرمت YAML استفاده کرد. به عنوان مثال، برای تبدیل ساختار Person به فرمت YAML می‌توان از کد زیر استفاده کرد:\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;gopkg.in/yaml.v2\u0026#34; 6\t\u0026#34;log\u0026#34; 7) 8 9func main() { 10\tperson := Person{ 11\tName: \u0026#34;John\u0026#34;, 12\tAge: 25, 13\tIsStudent: true, 14\t} 15 16\tyamlData, err := yaml.Marshal(\u0026amp;person) 17\tif err != nil { 18\tlog.Fatalf(\u0026#34;error: %v\u0026#34;, err) 19\t} 20 21\tfmt.Printf(\u0026#34;%s\u0026#34;, string(yamlData)) 22} در این کد، یک شیء از ساختار Person را ایجاد می کنیم و سپس از تابع Marshal برای تبدیل آن به فرمت YAML استفاده می کنیم. سپس محتوای YAML را به کمک تابع Printf چاپ می کنیم.\nبه این ترتیب پکیج YAML از امکانات و قابلیت بالایی برای کد نویسی و کار با فرمت YAML در زبان Go برخوردار می‌باشد.\n4.10.2.2 Unmarshal # می‌توانیم این پرونده را به کمک تابع Unmarshal به یک ساختار Go تبدیل کنیم. برای این کار، ابتدا نیاز است که یک ساختار داده‌ای برای ذخیره اطلاعات YAML تعریف کنیم. در این حالت، می‌توانیم از ساختار زیر استفاده کنیم:\n1type Person struct { 2\tName string `yaml:\u0026#34;name\u0026#34;` 3\tAge int `yaml:\u0026#34;age\u0026#34;` 4\tIsStudent bool `yaml:\u0026#34;isStudent\u0026#34;` 5} حالا می توانیم از تابع Unmarshal برای تبدیل داده‌ی YAML به ساختار Go استفاده کنیم:\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;gopkg.in/yaml.v2\u0026#34; 6\t\u0026#34;log\u0026#34; 7) 8 9type Person struct { 10\tName string `yaml:\u0026#34;name\u0026#34;` 11\tAge int `yaml:\u0026#34;age\u0026#34;` 12\tIsStudent bool `yaml:\u0026#34;isStudent\u0026#34;` 13} 14 15func main() { 16\tyamlData := ` 17name: John 18age: 25 19isStudent: true 20` 21 22\tvar person Person 23 24\terr := yaml.Unmarshal([]byte(yamlData), \u0026amp;person) 25\tif err != nil { 26\tlog.Fatalf(\u0026#34;error: %v\u0026#34;, err) 27\t} 28 29\tfmt.Printf(\u0026#34;Name: %s\\nAge: %d\\nIsStudent: %v\u0026#34;, person.Name, person.Age, person.IsStudent) 30} این کد پرونده YAML را به متغیر yamlData منتسب کرده، از تابع Unmarshal برای تجزیه و تحلیل داده‌های YAML استفاده و ساختار Person را با مقادیر معادل پر کرده‌است. سپس جزئیات این ساختار را چاپ می‌کنیم.\n"},{"id":54,"href":"/chapter-4/work-with-csv-file-in-go/","title":"4.11 آموزش کار با csv","section":"فصل چهارم: مباحث پیشرفته","content":" 4.11.1 مقدمه # CSV یکی از فرمت‌های متداول برای ذخیره داده‌های جدولی است. خروجی اکثر برنامه‌های قابلیت دستکاری داده، همراه با نرم‌افزار‌های آفیس، به فرمت CSV تولید می‌شود. فرمت CSV چندین ستون در یک ردیف را با استفاده از کاما (,) جدا کرده و هر ردیف را با استفاده از عبارت جدید (newline) جدا می‌کند.\nدر زبان برنامه‌نویسی Go نیز پکیج encoding/csv وجود دارد که در آن، توابع مربوط به خواندن و نوشتن داده‌های CSV به صورت دستی یا از طریق پرونده‌ها فراهم شده است. با استفاده از این پکیج، می‌توان داده‌های CSV را به داده‌های جدولی تبدیل کرد و برعکس.\nبه عنوان مثال، در ادامه یک فایل CSV به نام \u0026ldquo;data.csv\u0026rdquo; حاوی اطلاعات چند شخص را در نظر بگیرید:\nName,Age,City John,25,New York Jane,30,San Francisco Bob,40,Los Angeles 4.11.2 نحوه خواندن فایل csv # برای خواندن فایل csv می‌توان با استفاده از پکیج encoding/csv پرونده CSV را باز کرد:\n1package main 2 3import ( 4 \u0026#34;encoding/csv\u0026#34; 5 \u0026#34;fmt\u0026#34; 6 \u0026#34;os\u0026#34; 7) 8 9func main() { 10 f, err := os.Open(\u0026#34;data.csv\u0026#34;) 11 if err != nil { 12 panic(err) 13 } 14 15 r := csv.NewReader(f) 16 records, err := r.ReadAll() 17 if err != nil { 18 panic(err) 19 } 20 21 for _, row := range records { 22 for _, col := range row { 23 fmt.Print(col, \u0026#34;\\t\u0026#34;) 24 } 25 fmt.Println() 26 } 27} در این کد، تابع os.Open برای باز کردن پرونده CSV استفاده می‌شود. یک رابط csv.Reader ایجاد شده و یک رشته ساختارمند، پرونده CSV را می‌خواند. سپس با استفاده از یک حلقه، داده‌های جدولی چاپ می‌شود.\nفراداده‌های CSV بسیار گسترده هستند و می‌توانند شامل شماره دسته، توضیحات، یادداشت‌های شخصی و غیره باشند. برای کار با این نوع داده‌ها، پکیج encoding/csv امکاناتی مانند تنظیمات csv.Reader را فراهم می‌کند، که در آن، می‌توانیم تنظیماتی مانند علامت‌گذاری مناسب فایل CSV و دیگر علامت‌گذاری‌ها را بهبود ببخشیم.\n4.11.3 ReadAll فایل csv # تابع ReadAll تمام رکوردهای باقی مانده را از reader می خواند. هر رکورد یک قسمتی از fieldها است.\nfirst_name,last_name,occupation John,Doe,gardener Lucy,Smith,teacher Brian,Bethamy,programmer نام این فایل users.csv است. خط اول نام ستون ها هستند.\n1package main 2 3import ( 4 \u0026#34;encoding/csv\u0026#34; 5 \u0026#34;fmt\u0026#34; 6 \u0026#34;log\u0026#34; 7 \u0026#34;os\u0026#34; 8) 9 10type User struct { 11 firstName string 12 lastName string 13 occupation string 14} 15 16func main() { 17 18 records, err := readData(\u0026#34;users.csv\u0026#34;) 19 20 if err != nil { 21 log.Fatal(err) 22 } 23 24 for _, record := range records { 25 26 user := User{ 27 firstName: record[0], 28 lastName: record[1], 29 occupation: record[2], 30 } 31 32 fmt.Printf(\u0026#34;%s %s is a %s\\n\u0026#34;, user.firstName, user.lastName, 33 user.occupation) 34 } 35} 36 37func readData(fileName string) ([][]string, error) { 38 39 f, err := os.Open(fileName) 40 41 if err != nil { 42 return [][]string{}, err 43 } 44 45 defer f.Close() 46 47 r := csv.NewReader(f) 48 49 // skip first line 50 if _, err := r.Read(); err != nil { 51 return [][]string{}, err 52 } 53 54 records, err := r.ReadAll() 55 56 if err != nil { 57 return [][]string{}, err 58 } 59 60 return records, nil 61} اسم فایل بالا read_all.go می‌باشد و این مثال فایل users.csv را می خواند. هر line به یک User type را بر می‌گرداند.\n1// skip first line 2if _, err := r.Read(); err != nil { 3 return [][]string{}, err 4} در اینجا از خط اول که شامل نام ستون هاست می گذریم.\n1records, err := r.ReadAll() در نهایت همه رکوردها را یک جا با ReadAll دریافت می کنیم.\n1$ go run read_all.go 2John Doe is a gardener 3Lucy Smith is a teacher 4Brian Bethamy is a programmer 4.11.4 delimiter CSV دلخواه # علیرغم نام CSV ، CSV ممکن است دارای جداکننده های دیگری غیر از کاما باشد. این به دلیل استاندارد نبودن قالب CSV است.\n# user.csv # this is users.csv file John;Doe;gardener Lucy;Smith;teacher Brian;Bethamy;programmer در فایل users.csv فیلدها با نقطه ویرگول از هم جدا شده اند. این فایل حاوی یک comment نیز می‌باشد.\n1//different_delimiter.go// 2 3package main 4 5import ( 6 \u0026#34;encoding/csv\u0026#34; 7 \u0026#34;fmt\u0026#34; 8 \u0026#34;log\u0026#34; 9 \u0026#34;os\u0026#34; 10) 11 12func main() { 13 14 f, err := os.Open(\u0026#34;users.csv\u0026#34;) 15 16 if err != nil { 17 18 log.Fatal(err) 19 } 20 21 r := csv.NewReader(f) 22 r.Comma = \u0026#39;;\u0026#39; 23 r.Comment = \u0026#39;#\u0026#39; 24 25 records, err := r.ReadAll() 26 27 if err != nil { 28 log.Fatal(err) 29 } 30 31 fmt.Print(records) 32} این مثال تمام داده های این فایل را می خواند.\n1r := csv.NewReader(f) 2r.Comma = \u0026#39;;\u0026#39; 3r.Comment = \u0026#39;#\u0026#39; در اینجا separator و کاراکتر comment را تنظیم می کنیم تا package بداند چگونه فایل را parse یا تجریه تحلیل کند.\n4.11.5 نوشتن CSV # تابع Write یک رکورد CSV را برای writer می نویسد. رکورد برشی از strings است که هر string یک فیلد است. write ها buffer شده هستند، بنابراین باید Flush فراخوانی شود تا اطمینان حاصل شود که رکورد برای writer اصلی نوشته شده است.\n1//write_fun.go// 2package main 3 4import ( 5 \u0026#34;encoding/csv\u0026#34; 6 \u0026#34;log\u0026#34; 7 \u0026#34;os\u0026#34; 8) 9 10func main() { 11 12 records := [][]string{ 13 {\u0026#34;first_name\u0026#34;, \u0026#34;last_name\u0026#34;, \u0026#34;occupation\u0026#34;}, 14 {\u0026#34;John\u0026#34;, \u0026#34;Doe\u0026#34;, \u0026#34;gardener\u0026#34;}, 15 {\u0026#34;Lucy\u0026#34;, \u0026#34;Smith\u0026#34;, \u0026#34;teacher\u0026#34;}, 16 {\u0026#34;Brian\u0026#34;, \u0026#34;Bethamy\u0026#34;, \u0026#34;programmer\u0026#34;}, 17 } 18 19 f, err := os.Create(\u0026#34;users.csv\u0026#34;) 20 defer f.Close() 21 22 if err != nil { 23 24 log.Fatalln(\u0026#34;failed to open file\u0026#34;, err) 25 } 26 27 w := csv.NewWriter(f) 28 defer w.Flush() 29 30 for _, record := range records { 31 if err := w.Write(record); err != nil { 32 log.Fatalln(\u0026#34;error writing record to file\u0026#34;, err) 33 } 34 } 35} در مثال بالا، چند رکورد را با تابع Write در فایل users.csv نوشتیم.\n4.11.6 نوشتن WriteAll CSV # تابع WriteAll چندین رکورد CSV را با استفاده از Write برای writer می‌نویسد و سپس Flush را فراخوانی می‌کند.\n1 2//write_all.go// 3 4package main 5 6import ( 7 \u0026#34;encoding/csv\u0026#34; 8 \u0026#34;log\u0026#34; 9 \u0026#34;os\u0026#34; 10) 11 12func main() { 13 14 records := [][]string{ 15 {\u0026#34;first_name\u0026#34;, \u0026#34;last_name\u0026#34;, \u0026#34;occupation\u0026#34;}, 16 {\u0026#34;John\u0026#34;, \u0026#34;Doe\u0026#34;, \u0026#34;gardener\u0026#34;}, 17 {\u0026#34;Lucy\u0026#34;, \u0026#34;Smith\u0026#34;, \u0026#34;teacher\u0026#34;}, 18 {\u0026#34;Brian\u0026#34;, \u0026#34;Bethamy\u0026#34;, \u0026#34;programmer\u0026#34;}, 19 } 20 21 f, err := os.Create(\u0026#34;users.csv\u0026#34;) 22 defer f.Close() 23 24 if err != nil { 25 26 log.Fatalln(\u0026#34;failed to open file\u0026#34;, err) 27 } 28 29 w := csv.NewWriter(f) 30 err = w.WriteAll(records) // calls Flush internally 31 32 if err != nil { 33 log.Fatal(err) 34 } 35} در نهایت ما چند رکورد را در یک لحظه با WriteAll می نویسیم.\n"},{"id":55,"href":"/chapter-4/work-with-ini-file-in-go/","title":"4.12 آموزش کار با ini","section":"فصل چهارم: مباحث پیشرفته","content":"بطور خلاصه فایل های ini.* جهت ذخیره تنظیمات مختلف استفاده می شود تنظیماتی مثل: آدرس خاص در شبکه، اطلاعات ورود به سیستم های مختلف و موارد از این قبیل.\nبرای شروع ساختار پروژه ما به این شکل است\n1$ mkdir -p /tmp/ini 2$ cd /tmp/ini 3$ touch my.ini main.go 4$ tree . . 5├── main.go 6└── my.ini در پروژه دو فایل ایجاد کردیم یکی فایل اصلی برنامه main.go و دیگری my.ini که می خواهیم تنظیمات برنامه را در آن نگهداری کنیم. محتوای داخل فایل ini را بصورت ذیل تعریف کرده ایم\n1# possible values : production, development 2app_mode = development 3 4[paths] 5# Path to where grafana can store temp files, sessions, and the sqlite3 db (if that is used) 6data = /home/git/grafana 7 8[server] 9# Protocol (http or https) 10protocol = http 11 12# The http port to use 13http_port = 9999 14# Redirect to correct domain if host header does not match domain # Prevents DNS rebinding attacks 15enforce_domain = true همانطور که در توصیف کد آمده است 5 مقدار مختلف داخل فایل آمده است برخی را توضیح می دهیم\nمقدار app_mode که در واقع میخواهیم جهت تشخیص مود توسعه استفاده کنیم برای مثال به کمک این مقدار میخواهیم لاگ های برنامه در پروداکشن نمایش داده نشود ولی در زمان توسعه دهنده بتوانیم لاگ هایم مختلف را مشاهده کنیم. قسمت بعد protocol است که کاملا مشخص می باشد و در واقع میخواهیم پروتکل استفاده شده را مشخص کنیم حط بعد شماره پورت مورد استفاده برنامه است که مقدار 9999 می باشد مقادیر وارد شده صرفا برای مثال می باشد و می توان هر مقداری را که در برنامه نیاز دارید ایجاد کنید.\n1package main 2import ( 3\u0026#34;fmt\u0026#34; 4\u0026#34;os\u0026#34; 5\u0026#34;gopkg.in/ini.v1\u0026#34; 6) 7 8func main() { 9cfg, err := ini.Load(\u0026#34;my.ini\u0026#34;) 10 11if err != nil { 12fmt.Printf(\u0026#34;Fail to read file: %v\u0026#34;, err) 13os.Exit(1) 14} 15 16// Classic read of values, default section can be represented as empty string 17fmt.Println(\u0026#34;App Mode:\u0026#34;, cfg.Section(\u0026#34;\u0026#34;).Key(\u0026#34;app_mode\u0026#34;).String()) 18fmt.Println(\u0026#34;Data Path:\u0026#34;, cfg.Section(\u0026#34;paths\u0026#34;).Key(\u0026#34;data\u0026#34;).String()) 19 20// Let\u0026#39;s do some candidate value limitation 21fmt.Println(\u0026#34;Server Protocol:\u0026#34;, 22cfg.Section(\u0026#34;server\u0026#34;).Key(\u0026#34;protocol\u0026#34;).In(\u0026#34;http\u0026#34;, []string{\u0026#34;http\u0026#34;, \u0026#34;https\u0026#34;})) 23 24// Value read that is not in candidates will be discarded and fall back to given default value 25fmt.Println(\u0026#34;Email Protocol:\u0026#34;, cfg.Section(\u0026#34;server\u0026#34;).Key(\u0026#34;protocol\u0026#34;).In(\u0026#34;smtp\u0026#34;, []string{\u0026#34;imap\u0026#34;, \u0026#34;smtp\u0026#34;})) 26 27// Try out auto-type conversion 28fmt.Printf(\u0026#34;Port Number: (%[1]T) %[1]d\\n\u0026#34;, cfg.Section(\u0026#34;server\u0026#34;).Key(\u0026#34;http_port\u0026#34;).MustInt(9999)) 29 30fmt.Printf(\u0026#34;Enforce Domain: (%[1]T) %[1]v\\n\u0026#34;, cfg.Section(\u0026#34;server\u0026#34;).Key(\u0026#34;enforce_domain\u0026#34;).MustBool(false)) 31 32// Now, make some changes and save it 33cfg.Section(\u0026#34;\u0026#34;).Key(\u0026#34;app_mode\u0026#34;).SetValue(\u0026#34;production\u0026#34;) cfg.SaveTo(\u0026#34;my.ini.local\u0026#34;) 34 35} خروجی اجرای کد بالا به این شکل است\n1$ go run main.go 2App Mode: development 3Data Path: /home/git/grafana 4Server Protocol: http 5Email Protocol: smtp Port Number: (int) 9999 6Enforce Domain: (bool) true 7 8$ cat my.ini.local 9# possible values : production, development 10app_mode = production [paths] 11# Path to where grafana can store temp files, sessions, and the sqlite3 db (if that is used) data = /home/git/grafana 12... کد بالا به اندازه کافی شفاف و ساده است که نیازی به توضیح بیشتر ندارد در ابتدا نیاز است تا بسته \u0026ldquo;gopkg.in/ini.v1\u0026rdquo; را به برنامه اضافه کنیم سپس با متد load فایل کانفیگ موجود را به حافظه بارگذاری می کنیم تا محتوای آن را بخوانیم و خط های بعد مقادیر آن را میخوانیم در خط پایانی نیز مقدار app_mode را به production تغییر دادیم و در فایل جدیدی به نام my.ini.local ذخیره کردیم .\nمی توانیم به شکل های مختلف یک فایل را بارگذاری یا ایجاد کنیم به مثال ذیل توجه کنید:\n1cfg, err := ini.Load( []byte(\u0026#34;raw data\u0026#34;), // Raw data 2\t\u0026#34;filename\u0026#34;, // File 3\tioutil.NopCloser(bytes.NewReader([]byte(\u0026#34;some other data\u0026#34;))), 4) در این قطعه کد ما تنظیمات خود را به 3 شکل می توانیم فراخوانی کنیم رشته، فایل و io.ReadCloser البته در صورت نیاز می توانیم یک فایل خالی در فضای حافظه بشکل ذیل نیز ایجاد کنیم.\n1cfg := ini.Empty() در ابتدا می توانید هر تعداد فایل ini را بارگذاری و یا فرخوانی کنید ولیکن مواقعی نیاز دارید که یک منبع دیگر به آنها اضافه کنید که برای این منظور می توانید از دستور Append استفاده نمائید\n1err := cfg.Append(\u0026#34;other file\u0026#34;, []byte(\u0026#34;other raw data\u0026#34;)) و یا مواقعی از چند منبع اقدام به بارگذاری می نمائید که احتمال دارد برخی از آن منابع خطا در بارگذاری دهد در این شرایط بهتر از تابع ()LooseLoadd استفاده کنید\n1cfg, err := ini.LooseLoad(\u0026#34;filename\u0026#34;, \u0026#34;filename_404\u0026#34;) و در نهایت می توانید پس از تغییرات دلخواه فایل را بصورت ذیل ذخیره نمائید\n1// ... 2err = cfg.SaveTo(\u0026#34;my.ini\u0026#34;) 3err = cfg.SaveToIndent(\u0026#34;my.ini\u0026#34;, \u0026#34;\\t\u0026#34;) همانطور که در بالا دید برای دسترسی به یک قسمت از فایل ما از تابع Section بصورت ذیل استفاده می کنیم\n1sec, err := cfg.GetSection(\u0026#34;section name\u0026#34;) که در اینجا \u0026ldquo;section name\u0026rdquo; نام قطعه کد ما در فایل تنظیمات است. برخی از توابع مهم این بسته عبارت اند از : 1.\n1err := cfg.NewSection(\u0026#34;new section\u0026#34;) جهت ایجاد قطعه جدید 2.\n1secs := cfg.Sections() 2names := cfg.SectionStrings() برای بدست آوردن تمامی قطعات داخل فایل 3.\n1key, err := cfg.Section(\u0026#34;\u0026#34;).GetKey(\u0026#34;app_mode\u0026#34;) برای بدست آوردن key یک section بطور مثال \u0026ldquo;app_mode\u0026rdquo; 4. ```go key, err := cfg.Section(\u0026quot;\u0026quot;).HasKey(\u0026ldquo;app_mode\u0026rdquo;)\nبرای بررسی وجود یک key 5. ```go key, err := cfg.Section(\u0026#34;\u0026#34;).NewKey(\u0026#34;name\u0026#34;, \u0026#34;value\u0026#34;) برای ایجاد یک key جدید\n"},{"id":56,"href":"/chapter-4/work-with-environment-variable/","title":"4.13 آموزش کار با environment variable","section":"فصل چهارم: مباحث پیشرفته","content":"Environment Variables یا متغیرهای محیطی، متغیرهایی هستند که در فضای محیطی سیستم عامل مشخص شده‌اند. این متغیرها، شامل اطلاعاتی مانند مسیر فایل‌ها، تنظیمات سیستم، ترجیحات و تعیینات ساده و دیگر اطلاعات مورد استفاده توسط برنامه‌ها هستند.\nبه عنوان مثال، در سیستم عامل لینوکس، PATH یک متغیر محیطی است که شامل یک فهرست از دایرکتوری‌هایی است که سیستم به دنبال فایل‌ها و برنامه‌ها می‌گردد. برای دسترسی به این متغیر، می‌توان از دستور زیر در خط فرمان استفاده کرد:\necho $PATH همچنین، در زبان برنامه‌نویسی Go نیز استفاده از Environment Variables بسیار رایج است. برای نمونه، تنظیمات پایگاه داده را می‌توان با استفاده از Environment Variables در برنامه اصلی تنظیم کرد. در این مثال بسیار کوتاه، متصل شدن به پایگاه داده با استفاده از متغیرهای محیطی بیان شده است:\n1package main 2 3import ( 4 \u0026#34;database/sql\u0026#34; 5 \u0026#34;os\u0026#34; 6) 7 8func main() { 9 db, err := sql.Open(\u0026#34;postgres\u0026#34;, os.Getenv(\u0026#34;DATABASE_URL\u0026#34;)) 10 if err != nil { 11 panic(err) 12 } 13 defer db.Close() 14 15 // Do something with the database 16} در این مثال، پایگاه داده PostgreSQL از طریق پارامتر DATABASE_URL قابل تنظیم است. با استفاده از os.Getenv مقدار متغیر محیطی با همین نام به دست می‌آید و سپس به عنوان آرگومان به sql.Open ارائه می‌شود.\nاستفاده از Environment Variables یک روش مدیریتی عالی برای محیط برنامه است. این روش، به برنامه‌ها امکان می‌دهد که بدون اینکه برای هر برنامه یک سری تنظیمات خاص وجود داشته باشد، با یک سری تنظیمات کلی کار کنند و به صورت پویا و گسترده پاسخگو باشند.\n4.13.1 نحوه set کردن # در زبان برنامه‌نویسی Go، برای set کردن Environment Variables می‌توان از پکیج os استفاده کرد. برای مثال، برای تعیین متغیر محیطی با نام \u0026ldquo;DATABASE_URL\u0026rdquo; به مقدار \u0026ldquo;postgresql://localhost/mydb\u0026rdquo; می‌توانید از تابع os.Setenv استفاده کنید:\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;os\u0026#34; 6) 7 8func main() { 9 err := os.Setenv(\u0026#34;DATABASE_URL\u0026#34;, \u0026#34;postgresql://localhost/mydb\u0026#34;) 10 if err != nil { 11 panic(err) 12 } 13 fmt.Println(\u0026#34;Environment variable set successfully\u0026#34;) 14} در این مثال، با استفاده از تابع os.Setenv، متغیر محیطی با نام DATABASE_URL و مقدار postgresql://localhost/mydb تنظیم شده است. اگر خطا رخ دهد، با استفاده از تابع panic خطا ثبت می‌شود. سپس یک پیام تاییدی برای نشان دادن موفقیت set کردن متغیر محیطی نمایش داده می‌شود.\nاگر بخواهید یک Environment Variable را به یک مقدار خالی تنظیم کنید، می‌توانید از تابع os.Unsetenv استفاده کنید. برای مثال، برای حذف متغیر محیطی DATABASE_URL، کد زیر را می‌توانید استفاده کنید:\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;os\u0026#34; 6) 7 8func main() { 9 err := os.Unsetenv(\u0026#34;DATABASE_URL\u0026#34;) 10 if err != nil { 11 panic(err) 12 } 13 fmt.Println(\u0026#34;Environment variable unset successfully\u0026#34;) 14} در این مثال، با استفاده از تابع os.Unsetenv، متغیر محیطی با نام DATABASE_URL حذف شده است. اگر خطا رخ دهد، با استفاده از تابع panic خطا ثبت می‌شود. سپس یک پیام تاییدی برای نشان دادن موفقیت unset کردن متغیر محیطی نمایش داده می‌شود.\n4.13.2 نحوه get کردن # در زبان برنامه‌نویسی Go، برای get کردن Environment Variables می‌توان از پکیج os استفاده کرد. برای مثال، برای به دست آوردن مقدار متغیر محیطی با نام \u0026ldquo;DATABASE_URL\u0026rdquo; می‌توانید از تابع os.Getenv استفاده کنید:\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;os\u0026#34; 6) 7 8func main() { 9 dbUrl := os.Getenv(\u0026#34;DATABASE_URL\u0026#34;) 10 fmt.Printf(\u0026#34;Database URL: %s\\n\u0026#34;, dbUrl) 11} در این مثال، با استفاده از تابع os.Getenv، متغیر محیطی با نام DATABASE_URL به عنوان پارامتر به تابع ارسال شده و مقدار آن در یک متغیر به نام dbUrl ذخیره شده است. سپس با استفاده از تابع fmt.Printf، مقدار dbUrl به همراه یک پیام مشابه \u0026ldquo;Database URL: postgresql://localhost/mydb\u0026rdquo; نمایش داده می‌شود.\nاگر مقدار متغیر محیطی مورد نظر وجود نداشته باشد، تابع os.Getenv مقدار خالی برمی‌گرداند. لذا برای اطمینان از وجود مقدار متغیر محیطی، می‌توانید از تابع os.LookupEnv استفاده کنید. برای مثال، کد زیر چک می‌کند که آیا متغیر محیطی EMAIL تنظیم شده است یا خیر:\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;os\u0026#34; 6) 7 8func main() { 9 email, ok := os.LookupEnv(\u0026#34;EMAIL\u0026#34;) 10 if ok { 11 fmt.Printf(\u0026#34;Email address: %s\\n\u0026#34;, email) 12 } else { 13 fmt.Println(\u0026#34;Email address is not set\u0026#34;) 14 } 15} در این مثال، با استفاده از تابع os.LookupEnv، متغیر محیطی با نام EMAIL برای وجود مقدار بررسی شده است. اگر مقدار موجود بود، با استفاده از تابع fmt.Printf، مقدار این متغیر به همراه یک پیام مشابه \u0026ldquo;Email address: user@example.com\u0026rdquo; نمایش داده می‌شود. در صورتی که مقداری برای این متغیر وجود نداشته باشد، با استفاده از تابع fmt.Println، یک پیام مشابه \u0026ldquo;Email address is not set\u0026rdquo; نمایش داده می‌شود.\n4.13.3 کار با فایل env. # فایل .env یک فایل متنی است که حاوی متغیرهای محیطی برای برنامه شما است. در Go، می‌توانیم از پکیج godotenv استفاده کنیم تا مقادیر متغیرهای محیطی را از فایل .env بخوانیم و در متغیرهای خود بارگذاری کنیم.\nبرای استفاده از پکیج godotenv، ابتدا باید آن را با استفاده از دستور زیر نصب کنید:\ngo get github.com/joho/godotenv سپس می‌توانید از تابع godotenv.Load() استفاده کنید تا متغیرهای محیطی از فایل .env خوانده شود. در زیر یک مثال برای استفاده از پکیج godotenv به همراه فایل .env نشان داده شده است:\nفرض کنید فایل .env شما به شکل زیر باشد:\nDATABASE_URL=postgresql://localhost/mydb API_KEY=AbCdEfGhIjKlMnOp حال در کد Go خود، پکیج godotenv را import کرده و با استفاده از تابع godotenv.Load()، متغیرهای محیطی از فایل .env خوانده شده و در متغیرهای خود بارگذاری کنید:\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;github.com/joho/godotenv\u0026#34; 6 \u0026#34;os\u0026#34; 7) 8 9func main() { 10 // Load environment variables from .env file 11 err := godotenv.Load() 12 if err != nil { 13 fmt.Println(\u0026#34;Error loading .env file\u0026#34;) 14 os.Exit(1) 15 } 16 17 // Get values of environment variables 18 dbUrl := os.Getenv(\u0026#34;DATABASE_URL\u0026#34;) 19 apiKey := os.Getenv(\u0026#34;API_KEY\u0026#34;) 20 21 // Print the values 22 fmt.Printf(\u0026#34;Database URL: %s\\n\u0026#34;, dbUrl) 23 fmt.Printf(\u0026#34;API Key: %s\\n\u0026#34;, apiKey) 24} در این مثال، با استفاده از تابع godotenv.Load()، متغیرهای محیطی از فایل .env خوانده شده و در متغیرهای خود بارگذاری شده‌اند. سپس با استفاده از تابع os.Getenv()، مقادیر این متغیرها به دست آمده و با استفاده از تابع fmt.Printf نمایش داده شده‌اند.\nبا استفاده از این روش، مقادیری که در فایل .env تعریف شده‌اند، در زمان اجرای برنامه به راحتی قابل دسترس خواهند بود و این اجازه را به شما می‌دهد که مقادیر مورد نیاز را به راحتی تغییر دهید و حتی بدون تغییر کد، برنامه خود را در محیط‌های مختلف اجرا کنید.\n"},{"id":57,"href":"/chapter-4/go-regular-expressions/","title":"4.14 آموزش کار با regexp","section":"فصل چهارم: مباحث پیشرفته","content":"مواقعی در کد نویسی دارید که نیاز هست تا یک عبارتی مثل شماره تلفن،کد پستی و یا شماره پاسپورت وارد شده را بصورت قاعده مند بررسی کنید به عبارتی کاربر نتواند برای فیلد شماره تلفن، کاراکتر غیر عددی وارد کند. در این مواقع بهتر است داده وارد شده بصورت قاعده مند بررسی شود. برای درک بهتر موضوع به رشته وارد شده توسط کاربر که می تواند سهوا باشد دقت کنید\n+989121234#566 در این رشته کاربر مرتکب دو اشتباه شده است.\nشماره موبایل یک رقم بیشتر وارد شده است کاربر بجای رقم از علامت # استفاده کرده است در چنین شرایطی روش های بررسی مرسوم داده پاسخگو نیست و بهتر است از عبارات با قاعده استفاده کنیم.\nدر زبان برنامه نویسی Go بسته از پیش تعریف شده regexp برای اینکار وجود دارد.\n1import ( 2 \u0026#34;regexp\u0026#34; 3) برای شروع و درک بهتر مطلب اجازه دهید از یک مثال ساده شروع کنیم. میخواهیم بررسی کنیم آیا کاربر کارکتر نقطه [.] را وارد کرده است یا خیر .\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;regexp\u0026#34; 6) 7 8func main() { 9 sampleRegex := regexp.MustCompile(\u0026#34;[.]\u0026#34;) 10 match := sampleRegex.Match([]byte(\u0026#34;.\u0026#34;)) 11 fmt.Println(match) 12} در کد فوق به کمک تابع MustCompile عبارت قاعده مند را دریافت می کنیم در صورتیکه عبارت وارد شده قابل قبول یا معتبر نباشد panic اتفاق خواهد افتاد . دقت داشته باشید که خود عبارت قاعده مند دارای استاندارد و چارچوب های مشخص است که بهتر است درصورت عدم اطلاع از ابتدا آن را بیاموزید.\nدقت کنید که در کد فوق عبارت مد نظر خود را داخل [] قرار داده ایم و در خط بعد با تابع Match که مقدار مورد نظر را بصورت رشته ای از بایت ها به آن معرفی کرده ایم بررسی می کنیم که \u0026ldquo;.\u0026rdquo; در رشته وجود دارد یا خیر که خروجی این بررسی یک مقدار بولین بصورت ذیل است.\ntrue در واقع می توانید رشته های ساده را نیز با این روش مقایسه کنید بطور مثال :\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;regexp\u0026#34; 6) 7func main() { 8 first := \u0026#34;abc\u0026#34; 9 second := \u0026#34;xyz\u0026#34; 10 third := \u0026#34;123\u0026#34; 11 sampleRegex := regexp.MustCompile(first + second + third) 12 13 match := sampleRegex.Match([]byte(\u0026#34;abcxyz123\u0026#34;)) 14 fmt.Println(match) 15} خروجی بررسی بالا\n1$go run main.go 2true اگر به کد فوق دقت کنید متوجه خواهید شد که مقادیر بررسی شده بصورت کامل بوده و چنانچه بررسی شما شامل بخشی از عبارت وارد شده باشد باز نتیجه بررسی اشتباه خواهد بود برای مثال ما قسمتی از کد را تغییر می دهیم\n1package main 2... 3func main() { 4 5\t... 6 match := sampleRegex.Match([]byte(\u0026#34;abcxyz\u0026#34;)) 7 8 fmt.Println(match) 9 10} در اینجا نتیجه بررسی برای عبارت \u0026ldquo;abcxyz\u0026rdquo; که در عبارت اصلی یعنی \u0026ldquo;abcxyz123\u0026rdquo; قرار دارد مقدار false نمایش داده خواهد شد که این به معنای بررسی کل عبارت است. برای رفع این اشتباه می بایست از ساختار عبارات قاعده مند بهر بگیریم و به این شکل به برنامه اطلاع دهیم که عبارت مد نظر ما می تواند بخشی از عبارت وارد شده باشد.\n1package main 2import ( 3 \u0026#34;fmt\u0026#34; 4 \u0026#34;regexp\u0026#34; 5) 6func main() { 7 sampleRegex := regexp.MustCompile(\u0026#34;[abc]\u0026#34;) 8 match := sampleRegex.Match([]byte(\u0026#34;abcd\u0026#34;)) 9 10 fmt.Printf(\u0026#34;For abcd: %t\\n\u0026#34;, match) 11 match = sampleRegex.Match([]byte(\u0026#34;1abc23\u0026#34;)) 12 fmt.Printf(\u0026#34;For 1abc23: %t\\n\u0026#34;, match) 13 14 match = sampleRegex.Match([]byte(\u0026#34;abc\u0026#34;)) 15 fmt.Printf(\u0026#34;For abc: %t\\n\u0026#34;, match) 16} خروجی کد\n1$go run main.go 2For abcd: true 3For 1abc23: true 4For abc: true در کد فوق کارکترهای [] به این معنا است که عبارت مورد نظر می تواند شامل عبارت مورد مقایسه نیز باشد. به چند تا از علائم و معانی پرکاربرد در عبارات قاعده مند توجه کنید.\n\\w فقط شامل حروف باشد \\W شامل حروف نباشد \\d شامل اعداد باشد \\Dشامل اعداد نباشد \\s شامل فضای خالی باشد \\S شامل فضای خالی نباشد \\+ شامل حداقل یک یا بیشتر باشد \\* شامل صفر یا بیشتر باشد \\| شامل عبارت مورد نظر و یا مورد دیگر باشد لیست کامل این عبارات را می توانید در اینجا مشاهده کنید.\nدر مواقعی مایل هستیم که عبارت مورد نظر در رشته را جستجو و نمایش دهیم بطور مثال:\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;regexp\u0026#34; 6) 7 8func main() { 9\tsampleRegexp := regexp.MustCompile(`(ab){2}`) 10 11\tmatches := sampleRegexp.FindString(\u0026#34;abab\u0026#34;) 12\tfmt.Println(matches) 13 14\tmatches = sampleRegexp.FindString(\u0026#34;ababbc\u0026#34;) 15\tfmt.Println(matches) 16} در اینجا از برنامه خواسته ایم که به دنبال ترکیبی از ab با تکرار دوبار متوالی باشد و در انتها عبارت پیدا شده توسط تابع FindString را نمایش دهد که علامت () تاکید روی عبارت مورد نظر است و {2} به معنی تکرار حداقل دوبار متوالی است.\nخروجی کد بالا\n1$go run main.go 2abab 3abab در پایان می خواهیم یک مثال سختر را که در ابتدا به آن اشاره کردیم بنویسیم و آن بررسی شماره تلفن است.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;regexp\u0026#34; 6) 7 8func main() { 9\tsampleRegexp := regexp.MustCompile(`^\\+989(1[0-9]|3[1-9]|2[1-9])?[0-9]{7}$`) 10 11\tmatches := sampleRegexp.Match([]byte(\u0026#34;+989121234#566\u0026#34;)) 12\tfmt.Println(matches) 13 14\tmatches = sampleRegexp.Match([]byte(\u0026#34;+989121234567\u0026#34;)) 15\tfmt.Println(matches) 16} خروجی کد بالا\n1$ go run main.go 2false 3true در کد فوق علامت ^ در عبارات با قاعده به معنی شروع ساختار عبارت است و علامت $ به معنای پایان عبارت. درواقع تمامی رشته های که قرار است عتبار سنجی شوند باید در ساختار بین این تو کاراکتر تطبیق شوند. در ادامه نیاز است تا با کمک کاراکتر \\ اثر کارکتر + را خنثی کنیم به این معنی که تمامی شماره های وارد شده باید علامت + در ابتدا داشته باشند سپس قید شده است که 989 که پیش شمار ایران و موبایل است را قید کرده ایم . از آنجا که شماره موبایلهای ایران 911|912|913 شروع می شود با این عبارت \u0026ldquo;(1[0-9]|3[1-9]|2[1-9])\u0026rdquo; مشخص کرده ایم. علامت ؟ به معنی حداقل یکبار تکرار شده عبارت قبل خودش است و در انتها کاربر می بایست هفت رقم وارد که به این صورت مشخص شده است \u0026ldquo;[0-9]{7}\u0026rdquo;. همانطور مشاهده می کنید رشته اول معتبر نبوده ولی رشته دوم صحیح است.\n"},{"id":58,"href":"/chapter-4/go-reflection/","title":"4.15 آموزش reflection","section":"فصل چهارم: مباحث پیشرفته","content":"پکیج reflect در زبان Go، امکانات reflection زمان اجرا را فراهم می‌کند که به یک برنامه اجازه می‌دهد تا با اشیاءی با انواع دلخواه کار کند. استفاده اصلی این پکیج، گرفتن اطلاعات نوع پویای یک مقدار با نوع استاتیک interface{} با فراخوانی تابع TypeOf است که یک مقدار Type را برمی‌گرداند.\nبا فراخوانی تابع ValueOf، یک شیء Value که حاوی دادهٔ زمان اجراست، برمی‌گرداند. تابع Zero یک مقدار Type دریافت کرده و یک شیء Value را که مقدار صفر برای آن نوع است، برمی‌گرداند.\n4.15.1 تعریف reflection و metaprogramming # قبل از شروع آموزش، باید مفاهیم metaprogramming و reflection زمان اجرا را بفهمیم. می‌توانیم کدهای منبع خود را به دو شکل کد و داده در نظر بگیریم.\nاگر کدهای منبع را به عنوان کد در نظر بگیریم، می‌توانیم آن‌ها را روی CPU اجرا کنیم.\nاز طرف دیگر، اگر کدهای منبع را به عنوان داده در نظر بگیریم، می‌توانیم مانند داده‌های معمولی فرآیند برنامه را برای آن‌ها بررسی و به‌روزرسانی کنیم. به عنوان مثال، می‌توانید تمام خصوصیات یک ساختار را بدون داشتن همه خصوصیات آن بدانید.\nmetaprogramming به تکنیکی از برنامه نویسی گفته می‌شود که برنامه را به عنوان داده مورد بررسی قرار می‌دهد. تکنیک‌های metaprogramming می‌توانند برنامه‌های دیگر را بررسی و پردازش کنند، یا حتی در حین اجرای برنامه به خود برنامه دسترسی داشته باشند.\nreflection زمان اجرا زیر مجموعه‌ای از الگوی metaprogramming است. تقریباً تمام زبان‌های محبوب، API داخلی را برای مدیریت metaprogramming برای زبان برنامه‌نویسی خود ارائه می‌دهند. این API ها به عنوان امکانات reflection زمان اجرا شناخته می‌شوند و به عنوان قابلیت زبان برنامه‌نویسی خاصی برای بررسی، تغییر و اجرای ساختار کد عمل می‌کنند.\nبنابراین، ما می‌توانیم کارهایی مانند:\nبررسی خصوصیات یک ساختار بررسی وجود یک تابع در یک نمونه ساختار بررسی نوع اتمی یک متغیر ناشناخته با API های reflection زمان اجرا را انجام دهیم. حال به بررسی بیشتر اینکه این چگونه در زبان برنامه نویسی Go کار می‌کند، می‌پردازیم.\n4.15.2 کاربردهای reflection # مفهوم reflection به طور معمول یک API اصلی را برای بررسی یا تغییر برنامه فعلی ارائه می‌دهد. ممکن است فکر کنید که در مورد کد منبع برنامه خود آگاه هستید، پس چرا نیاز به بررسی کد نوشته شده خود با استفاده از reflection دارید؟ اما reflection دارای موارد کاربرد مفید زیادی است، که در زیر ذکر شده است:\nبرنامه‌نویسان می‌توانند از reflection استفاده کنند تا با کمترین کد، مشکلات برنامه‌نویسی را حل کنند. به عنوان مثال، اگر از یک نمونه ساختاری برای ساخت یک پرس و جوی SQL استفاده می‌کنید، می‌توانید با استفاده از reflection، فیلدهای ساختار را بدون هاردکد کردن نام هر فیلد ساختاری استخراج کنید. با توجه به اینکه reflection یک روش برای بررسی ساختار برنامه ارائه می‌دهد، ممکن است با استفاده از آن، تحلیلگرهای کد استاتیکی ساخته شود. با استفاده از API reflection، ما می‌توانیم کد را به صورت پویا اجرا کنیم. به عنوان مثال، شما می‌توانید متدهای موجود یک ساختار را پیدا کرده و با نام آن‌ها تماس بگیرید. بخش آموزشی زیر همه اصول مورد نیاز برای پیاده‌سازی موارد کاربرد فوق را پوشش خواهد داد. همچنین، به شما نشان خواهم داد که چگونه می‌توانید یک برنامه shell ساده با API reflection بسازید.\nاکنون که مفهوم reflection را پوشش دادیم، با مثال‌های عملی شروع کنیم.\nپکیج reflection Go به ما reflect در زمان اجرا را ارائه می‌دهد، لذا این مثال‌ها ساختار برنامه را در طول زمان اجرا بررسی یا تغییر می‌دهند. با توجه به اینکه Go یک زبان کامپایل شده با نوع استاتیک است، API reflection آن بر اساس دو عنصر کلیدی، نوع reflection و مقدار reflection، ساخته شده است.\n5.15.3 بررسی تایپ های متغیرها # در ابتدا، می‌توانیم با پکیج reflect، از بررسی نوع متغیرها برای شروع استفاده کنیم. کد زیر را ببینید که نوع چندین متغیر را چاپ می‌کند.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;reflect\u0026#34; 6) 7 8func main() { 9\tx := 10 10\tname := \u0026#34;Go Lang\u0026#34; 11\ttype Book struct { 12\tname string 13\tauthor string 14\t} 15\tsampleBook := Book{\u0026#34;Reflection in Go\u0026#34;, \u0026#34;John\u0026#34;} 16\tfmt.Println(reflect.TypeOf(x)) // int 17\tfmt.Println(reflect.TypeOf(name)) // string 18\tfmt.Println(reflect.TypeOf(sampleBook)) // main.Book 19} 1$ go run main.go 2int 3string 4main.Book کد بالا نوع داده‌های متغیرها را با استفاده از تابع reflect.TypeOf چاپ می‌کند. تابع TypeOf یک نمونه reflection Type بازگردانده می‌کند که توابعی برای دسترسی به اطلاعات بیشتر درباره نوع فعلی فراهم می‌کند. برای مثال، می‌توانیم از تابع Kind برای بدست آوردن نوع ابتدایی یک متغیر استفاده کنیم. به خاطر داشته باشید که کد بالا نوع داده ساختار اختصاصی main.Book برای متغیر sampleBook را نشان می‌دهد - نه نوع ساختار ابتدایی.\nبرای بدست آوردن نوع ابتدایی، کد بالا را به صورت زیر تغییر دهید:\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;reflect\u0026#34; 6) 7 8func main() { 9\tvar ( 10\tstr = \u0026#34;Hello, world!\u0026#34; 11\tnum = 42 12\tflt = 3.14 13\tboo = true 14\tslice = []int{1, 2, 3} 15\tmymap = map[string]int{\u0026#34;foo\u0026#34;: 1, \u0026#34;bar\u0026#34;: 2} 16\tstructure = struct{ Name string }{Name: \u0026#34;John Doe\u0026#34;} 17\tinterface1 interface{} = \u0026#34;hello\u0026#34; 18\tinterface2 interface{} = \u0026amp;structure 19\t) 20 21\tfmt.Println(reflect.TypeOf(str).Kind()) 22\tfmt.Println(reflect.TypeOf(num).Kind()) 23\tfmt.Println(reflect.TypeOf(flt).Kind()) 24\tfmt.Println(reflect.TypeOf(boo).Kind()) 25\tfmt.Println(reflect.TypeOf(slice).Kind()) 26\tfmt.Println(reflect.TypeOf(mymap).Kind()) 27\tfmt.Println(reflect.TypeOf(structure).Kind()) 28\tfmt.Println(reflect.TypeOf(interface1).Kind()) 29\tfmt.Println(reflect.TypeOf(interface2).Kind()) 30} 1$ go run main.go 2string 3int 4float64 5bool 6slice 7map 8struct 9string 10ptr دلیلی که در کد بالا برای سومین دستور چاپ، struct چاپ می‌شود، این است که تابع Kind reflection Type یک reflection Kind بازگردانده که اطلاعات نوع اولیه را نگه می‌دارد. در این حالت، reflection Kind نوع اولیه ساختار است.\n5.15.3.1 اندازه تایپ های مقداردهی شده # همچنین می‌توانیم از تابع Size reflection Type استفاده کنیم تا تعداد بایت‌های مورد نیاز برای ذخیره نوع فعلی را بدست آوریم. کد زیر را ببینید:\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;reflect\u0026#34; 6) 7 8func main() { 9\tvar ( 10\tstr = \u0026#34;Hello, world!\u0026#34; 11\tnum = 42 12\tflt = 3.14 13\tboo = true 14\tslice = []int{1, 2, 3} 15\tmymap = map[string]int{\u0026#34;foo\u0026#34;: 1, \u0026#34;bar\u0026#34;: 2} 16\tstructure = struct{ Name string }{Name: \u0026#34;John Doe\u0026#34;} 17\t) 18 19\tfmt.Printf(\u0026#34;Size of str: %d\\n\u0026#34;, reflect.TypeOf(str).Size()) 20\tfmt.Printf(\u0026#34;Size of num: %d\\n\u0026#34;, reflect.TypeOf(num).Size()) 21\tfmt.Printf(\u0026#34;Size of flt: %d\\n\u0026#34;, reflect.TypeOf(flt).Size()) 22\tfmt.Printf(\u0026#34;Size of boo: %d\\n\u0026#34;, reflect.TypeOf(boo).Size()) 23\tfmt.Printf(\u0026#34;Size of slice: %d\\n\u0026#34;, reflect.TypeOf(slice).Size()) 24\tfmt.Printf(\u0026#34;Size of mymap: %d\\n\u0026#34;, reflect.TypeOf(mymap).Size()) 25\tfmt.Printf(\u0026#34;Size of structure: %d\\n\u0026#34;, reflect.TypeOf(structure).Size()) 26} این کد، با استفاده از تابع Size reflection Type، تعداد بایت‌های مورد نیاز برای ذخیره هر نوع را چاپ می‌کند. با اجرای این کد، خروجی زیر را خواهید داشت:\n1$ go run main.go 2Size of str: 16 3Size of num: 8 4Size of flt: 8 5Size of boo: 1 6Size of slice: 24 7Size of mymap: 8 8Size of structure: 0 در این کد، تعداد بایت‌های مورد نیاز برای نوع string 16 بایت، برای نوع int 8 بایت، برای نوع float64 8 بایت، برای نوع bool 1 بایت، برای نوع slice 24 بایت و برای نوع map 8 بایت است. برای نوع ساختاری structure بایتی نیاز نیست و برابر با صفر است.\n5.15.4 بررسی مقدار یک متغیر # قبلاً، اطلاعات نوع داده‌ها را بررسی کردیم. همچنین با استفاده از پکیج reflect، می‌توانیم مقادیر متغیرها را استخراج کنیم. کد زیر، مقادیر متغیرها را با استفاده از تابع reflect.ValueOf چاپ می‌کند:\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;reflect\u0026#34; 6) 7 8func main() { 9\tvar ( 10\tstr = \u0026#34;Hello, world!\u0026#34; 11\tnum = 42 12\tflt = 3.14 13\tboo = true 14\tslice = []int{1, 2, 3} 15\tmymap = map[string]int{\u0026#34;foo\u0026#34;: 1, \u0026#34;bar\u0026#34;: 2} 16\tstructure = struct{ Name string }{Name: \u0026#34;John Doe\u0026#34;} 17\t) 18 19\tfmt.Printf(\u0026#34;Value of str: %v\\n\u0026#34;, reflect.ValueOf(str)) 20\tfmt.Printf(\u0026#34;Value of num: %v\\n\u0026#34;, reflect.ValueOf(num)) 21\tfmt.Printf(\u0026#34;Value of flt: %v\\n\u0026#34;, reflect.ValueOf(flt)) 22\tfmt.Printf(\u0026#34;Value of boo: %v\\n\u0026#34;, reflect.ValueOf(boo)) 23\tfmt.Printf(\u0026#34;Value of slice: %v\\n\u0026#34;, reflect.ValueOf(slice)) 24\tfmt.Printf(\u0026#34;Value of mymap: %v\\n\u0026#34;, reflect.ValueOf(mymap)) 25\tfmt.Printf(\u0026#34;Value of structure: %v\\n\u0026#34;, reflect.ValueOf(structure)) 26} این کد، با استفاده از تابع reflect.ValueOf، مقادیر متغیرها را چاپ می‌کند. با اجرای این کد، خروجی زیر را خواهید داشت:\n1$ go run main.go 2Value of str: Hello, world! 3Value of num: 42 4Value of flt: 3.14 5Value of boo: true 6Value of slice: [1 2 3] 7Value of mymap: map[bar:2 foo:1] 8Value of structure: {John Doe} در این کد، مقادیر متغیرها با استفاده از تابع reflect.ValueOf چاپ می‌شوند. به خاطر داشته باشید که تابع ValueOf یک نمونه reflection Value بازگردانده می‌کند، که اطلاعات مربوط به مقدار و نوع متغیر را نگه‌داری می‌کند. برای چاپ مقدار واقعی، باید از توابع مربوط به reflection Value استفاده کنیم.\n5.15.5 تغییر مقدار یک متغیر # قبلاً، ساختار کد را با استفاده از چندین تابع در پکیج reflect بررسی کردیم. همچنین با استفاده از API بازتاب Go، امکان تغییر کد در حین اجرا وجود دارد. در کد زیر، نحوه به‌روزرسانی یک فیلد رشته‌ای در یک ساختار را مشاهده می‌کنید:\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;reflect\u0026#34; 6) 7 8type Person struct { 9\tName string 10\tAge int 11} 12 13func main() { 14\tp := Person{Name: \u0026#34;John\u0026#34;, Age: 30} 15\tfmt.Println(\u0026#34;Before update:\u0026#34;, p) 16 17\tv := reflect.ValueOf(\u0026amp;p) 18\tif v.Kind() == reflect.Ptr { 19\tv = v.Elem() 20\t} 21 22\tf := v.FieldByName(\u0026#34;Name\u0026#34;) 23\tif f.IsValid() \u0026amp;\u0026amp; f.CanSet() { 24\tf.SetString(\u0026#34;Jane\u0026#34;) 25\t} 26 27\tfmt.Println(\u0026#34;After update:\u0026#34;, p) 28} در این کد، یک ساختار به نام Person تعریف شده است که دو فیلد Name و Age دارد. در تابع main، یک نمونه از ساختار Person با مقدار پیش‌فرض Name: \u0026ldquo;John\u0026rdquo; و Age: 30 ایجاد شده است. سپس با استفاده از تابع reflect.ValueOf، نمونه ساختار Person به یک reflection Value تبدیل شده و با استفاده از تابع Kind، نوع آن بررسی می‌شود. اگر نوع نمونه یک اشاره‌گر باشد، با استفاده از تابع Elem، به مقدار اشاره شده تبدیل می‌شود.\nدر ادامه، با استفاده از تابع FieldByName، فیلد Name در نمونه ساختار Person بدست آورده می‌شود. سپس با استفاده از تابع IsValid بررسی می‌شود که آیا فیلد موجود است یا خیر. در صورت وجود، با استفاده از تابع CanSet بررسی می‌شود که آیا می‌توان آن را تغییر داد یا خیر. در صورت امکان تغییر، با استفاده از تابع SetString، مقدار فیلد Name به \u0026ldquo;Jane\u0026rdquo; تغییر می‌یابد.\nدر نهایت، با چاپ دوباره مقدار نمونه ساختار Person، تغییر در فیلد Name را مشاهده می‌کنیم. با اجرای این کد، خروجی زیر را خواهید داشت:\n1$ go run main.go 2Before update: {John 30} 3After update: {Jane 30} در این حالت، با استفاده از پکیج reflect، می‌توانیم برنامه را در حین اجرا تغییر داده و به داده‌های موجود در حافظه دسترسی پیدا کنیم.\n5.15.6 بررسی اطلاعات یک struct # بیایید یک کد نمونه برای بررسی همه فیلدهای یک ساختار بنویسیم. در طول بررسی، می‌توانیم نام و مقدار هر فیلد ساختار را نمایش دهیم. کد زیر این کار را انجام می‌دهد:\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;reflect\u0026#34; 6) 7 8type Person struct { 9\tName string 10\tAge int 11\tAddress string 12} 13 14func main() { 15\tp := Person{Name: \u0026#34;John\u0026#34;, Age: 30, Address: \u0026#34;123 Main St.\u0026#34;} 16 17\tv := reflect.ValueOf(p) 18\tif v.Kind() == reflect.Ptr { 19\tv = v.Elem() 20\t} 21 22\tfor i := 0; i \u0026lt; v.NumField(); i++ { 23\tfield := v.Field(i) 24\tfmt.Printf(\u0026#34;Field %d: %s = %v\\n\u0026#34;, i, v.Type().Field(i).Name, field.Interface()) 25\t} 26} در این کد، یک ساختار به نام Person تعریف شده است که دارای سه فیلد Name، Age و Address است. در تابع main، یک نمونه از ساختار Person با مقدار پیش‌فرض Name: \u0026ldquo;John\u0026rdquo;، Age: 30 و Address: \u0026ldquo;123 Main St.\u0026rdquo; ایجاد شده است.\nسپس با استفاده از تابع reflect.ValueOf، نمونه ساختار Person به یک reflection Value تبدیل شده و با استفاده از تابع Kind، نوع آن بررسی می‌شود. اگر نوع نمونه یک اشاره‌گر باشد، با استفاده از تابع Elem، به مقدار اشاره شده تبدیل می‌شود.\nدر ادامه، با استفاده از تابع NumField، تعداد فیلدهای موجود در نمونه ساختار Person بدست آورده می‌شود. سپس در یک حلقه، با استفاده از تابع Field، مقدار هر فیلد به همراه نام آن چاپ می‌شود. با استفاده از تابع Type، نوع نمونه ساختار Person به دست می‌آید، و با استفاده از تابع Field(i).Name، نام فیلد در ایندکس i بدست می‌آید. در نهایت، با استفاده از تابع Interface، مقدار فیلد به صورت یک interface{} برگردانده می‌شود و چاپ می‌شود.\nبا اجرای این کد، خروجی زیر را خواهید داشت:\n1$ go run main.go 2Field 0: Name = John 3Field 1: Age = 30 4Field 2: Address = 123 Main St. در این حالت، با استفاده از پکیج reflect، می‌توانیم برای هر ساختار، همه فیلدها را بررسی کرده و نام و مقدار هر فیلد را چاپ کنیم.\n5.15.7 بررسی متدها (Methods) # فرض کنید شما یک موتور دستور سفارشی برای یک برنامه شل پیاده‌سازی می‌کنید و برای اجرای توابع Go بر اساس دستورات ورودی کاربر، نیاز دارید دستورات را به توابع مرتبط تخصیص دهید. اگر تعداد توابع کم باشد، می‌توانید از یک switch-case statement استفاده کنید. اما اگر تعداد توابع صد‌ها نفر باشد؟ در این صورت، ما می‌توانیم توابع Go را براساس نام آن‌ها به صورت پویا فراخوانی کنیم. برنامه شل پایه‌ای زیر با استفاده از بازتاب این کار را انجام می‌دهد:\n1package main 2import ( 3 \u0026#34;fmt\u0026#34; 4 \u0026#34;reflect\u0026#34; 5 \u0026#34;bufio\u0026#34; 6 \u0026#34;os\u0026#34; 7) 8type NativeCommandEngine struct{} 9func (nse NativeCommandEngine) Method1() { 10 fmt.Println(\u0026#34;INFO: Method1 executed!\u0026#34;) 11} 12func (nse NativeCommandEngine) Method2() { 13 fmt.Println(\u0026#34;INFO: Method2 executed!\u0026#34;) 14} 15func (nse NativeCommandEngine) callMethodByName(methodName string) { 16 method := reflect.ValueOf(nse).MethodByName(methodName) 17 if !method.IsValid() { 18 fmt.Println(\u0026#34;ERROR: \\\u0026#34;\u0026#34; + methodName + \u0026#34;\\\u0026#34; is not implemented\u0026#34;) 19 return 20 } 21 method.Call(nil) 22} 23func (nse NativeCommandEngine) ShowCommands() { 24 val := reflect.TypeOf(nse) 25 for i := 0; i \u0026lt; val.NumMethod(); i++ { 26 fmt.Println(val.Method(i).Name) 27 } 28} 29func main() { 30 nse := NativeCommandEngine{} 31 fmt.Println(\u0026#34;A simple Shell v1.0.0\u0026#34;) 32 fmt.Println(\u0026#34;Supported commands:\u0026#34;) 33 nse.ShowCommands() 34 scanner := bufio.NewScanner(os.Stdin) 35 fmt.Print(\u0026#34;$ \u0026#34;) 36 for scanner.Scan() { 37 nse.callMethodByName(scanner.Text()) 38 fmt.Print(\u0026#34;$ \u0026#34;) 39 } 40} 1$ go run main.go 2A simple Shell v1.0.0 3Supported commands: 4Method1 5Method2 6ShowCommands 7$ برنامه شلی که پیشتر نوشتیم، ابتدا تمام دستورات پشتیبانی شده را نشان می‌دهد. سپس کاربر می‌تواند دستورات را به دلخواه خود وارد کند. هر دستور شل یک متد متناظر دارد، و اگر یک متد خاص وجود نداشته باشد، شل پیام خطا چاپ می‌کند.\n5.15.8 نوشتن custom tag برای فیلد های ساختار # تگ سفارشی مانند json:\u0026quot;name\u0026quot; در گو، برای اتصال متاداده به فیلدهای یک ساختار استفاده می‌شود. بسته reflect در گو، یک راه برای دسترسی به این تگ‌ها در زمان اجرا فراهم می‌کند. برای ایجاد یک تگ سفارشی در گو، می‌توان از بسته reflect برای دسترسی به تگ‌ها بر روی یک فیلد ساختار استفاده کرد.\nدر ادامه مثالی از چگونگی ایجاد یک تگ سفارشی با بسته reflect در گو آورده شده است:\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;reflect\u0026#34; 6) 7 8type Person struct { 9\tName string `customtag:\u0026#34;myname\u0026#34;` 10\tAge int `customtag:\u0026#34;myage\u0026#34;` 11} 12 13func main() { 14\tp := Person{\u0026#34;John\u0026#34;, 30} 15 16\tt := reflect.TypeOf(p) 17\tv := reflect.ValueOf(p) 18 19\tfor i := 0; i \u0026lt; t.NumField(); i++ { 20\tfield := t.Field(i) 21\tvalue := v.Field(i) 22 23\ttag := field.Tag.Get(\u0026#34;customtag\u0026#34;) 24 25\tfmt.Printf(\u0026#34;Field: %s, Value: %v, Tag: %s\\n\u0026#34;, field.Name, value.Interface(), tag) 26\t} 27} در این مثال، یک ساختار Person با دو فیلد Name و Age تعریف شده است. هر یک از این فیلدها با استفاده از کلید customtag یک تگ سفارشی دارند.\nبرای دسترسی به تگ‌ها در زمان اجرا، از بسته reflect استفاده می‌شود. با استفاده از reflect.TypeOf و reflect.ValueOf نوع و مقدار ساختار Person بدست می‌آیند. سپس با استفاده از حلقه for و توابع t.NumField() و t.Field(i) بر روی فیلدهای ساختار حرکت می‌کنیم. برای هر فیلد، با استفاده از v.Field(i) مقدار آن را و با استفاده از field.Tag.Get(\u0026quot;customtag\u0026quot;) تگ سفارشی آن را بدست می‌آوریم.\nدر نهایت با استفاده از fmt.Printf نام فیلد، مقدار آن و تگ سفارشی آن را چاپ می‌کنیم. خروجی این برنامه به شکل زیر خواهد بود:\n1$ go run main.go 2Field: Name, Value: John, Tag: myname 3Field: Age, Value: 30, Tag: myage این نشان می‌دهد که چگونه می‌توان با استفاده از بسته reflect در گو تگ‌های سفارشی را ایجاد کرد.\n"},{"id":59,"href":"/chapter-4/go-generator/","title":"4.16 آموزش generator","section":"فصل چهارم: مباحث پیشرفته","content":"کد generator در گو، یک ابزار است که برای تولید کد خودکار استفاده می‌شود. برای ایجاد یک کد generator در گو، می‌توان از قابلیت‌هایی که در زبان گو موجود است، مانند بسته‌های go/ast و go/parser استفاده کرد.\nبا استفاده از بسته go/ast می‌توانید ساختار داده‌های AST (Abstract Syntax Tree) را برای کد خود بسازید. AST، ساختار درختی از کدهای گو است که به طور معمول برای بررسی و تحلیل کد استفاده می‌شود.\nبا استفاده از بسته go/parser می‌توانید کد منبع گو را به عنوان ورودی بگیرید و برای آن AST بسازید.\nبا استفاده از این دو بسته، می‌توانید یک کد generator بسازید که برای تولید کد خودکار، کد منبع گو را تحلیل کرده و براساس آن، کد جدیدی را ایجاد کند. برای مثال، می‌توانید یک کد generator بسازید که برای تولید کد تست، کد منبع گو را تحلیل کرده و برای هر تابع یا متد، تست مربوطه را بسازد.\nبا توجه به این که کد generator‌ها برای تولید کد خودکار استفاده می‌شوند، باید دقت شود که کد تولید شده باید قابل خواندن و تصحیح باشد. همچنین، باید از بهبود کیفیت کد تولید شده نیز اطمینان حاصل شود.\nدر کل، با استفاده از بسته‌های go/ast و go/parser می‌توانید یک کد generator قدرتمند در گو بسازید که برای تولید کد خودکار بسیار مفید است.\nاین بخش ادامه دارد\u0026hellip;\n"},{"id":60,"href":"/chapter-4/go-stringer/","title":"4.17 آموزش stringer","section":"فصل چهارم: مباحث پیشرفته","content":"Stringer به طور کلی برای پیاده‌سازی مفهوم شمارشی (enumeration) استفاده می‌شود در حالی که از برنامه‌نویسی ثابت رشته‌های مقدار استفاده نمی‌کند. شمارشی یا enum زمانی استفاده می‌شود که می‌خواهید مجموعه‌ای متناهی و ثابتی از مقادیر یک نوع داده‌ای را تعریف کنید. به عنوان مثال، انواع غذا در منو (پیش غذا، اصلی، دسر)، انواع پوکمون (گیاهی، آبی، آتشی، و غیره).\nبنابراین، زمانی که می‌خواهیم از این مجموعه‌های تعریف شده استفاده کنیم، باید از برنامه‌نویسی ثابت رشته‌های مقدار استفاده کنیم زیرا ممکن است به خطاهای انسانی مانند اشتباهات املایی منجر شود. اگر از Stringer استفاده کنیم، مقادیر را یکبار تولید می‌کنیم و مطمئن می‌شویم که هیچ خطایی ایجاد نمی‌شود. پس از آن، می‌توانیم از آن‌ها بدون نگرانی از خطاهای انسانی استفاده کنیم.\n4.17.1 پیاده سازی متد String برای آبجکت ها # شما می توانید برای هر یک از آبجکت ها متد String را پیاده سازی کنید و یک خروجی استرینگ در خصوص مقادیر آبجکت داشته باشید.\nبه مثال کاربردی زیر توجه کنید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type Age int 6 7const ( 8\tCHILDERN Age = iota 9\tADOLESCENTS 10\tADULTS 11) 12 13func (a Age) String() string { 14\tswitch a { 15\tcase CHILDERN: 16\treturn \u0026#34;childern\u0026#34; 17\tcase ADOLESCENTS: 18\treturn \u0026#34;adolescents\u0026#34; 19\tcase ADULTS: 20\treturn \u0026#34;adults\u0026#34; 21\tdefault: 22\treturn \u0026#34;\u0026#34; 23\t} 24} 25 26func main() { 27\tfmt.Println(CHILDERN.String()) 28} 1$ go run main.go 2childern در مثال فوق ما یک تایپ Age تعریف کردیم و سپس یکسری enum با همان تایپ قرار دادیم پس از آن متد String را پیاده سازی کردیم که بتوانیم رشته هرکدام از enum ها را بگیریم.\n4.17.2 استفاده از ابزار stringer # شما با استفاده از ابزار stringer می توانید به راحتی برای enum های خود رشته را بصورت خودکار ایجاد کنید.\nبرای نصب این ابزار در ابتدا باید دستور زیر را بزنید تا داخل go bin نصب شود:\n1$ go install golang.org/x/tools/cmd/stringer@latest اکنون بخواهیم با استفاده از ابزار stringer متد استرینگ جنریت کنیم کافیه مثال زیر توجه کنید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5//go:generate stringer -type=Age 6 7type Age int 8 9const ( 10\tCHILDERN Age = iota 11\tADOLESCENTS 12\tADULTS 13) 14 15func main() { 16\tfmt.Println(CHILDERN.String()) 17} در کد فوق ما یک directive comment اضافه کردیم حال کافیه با استفاده از دستور go generate متد استرینگ تایپ را جنریت کنیم.\ngo generate ./... "},{"id":61,"href":"/chapter-4/effective-go/","title":"4.18 تکنیک های کدنویسی زبان گو","section":"فصل چهارم: مباحث پیشرفته","content":"در این بخش به موارد زیر می پردازیم.\nکارآمدی (effective) استایل اوبر تکنیک ها نکات فنی بهینه سازی 4.18.1 کارآمدی (Effective) # در زیر به کارآمدی زبان گو می پردازیم.\n4.18.1.1 نام پکیج ها # زمانیکه شما یک پکیج را ایمپورت میکنید نام پکیج در بالای بدنه فایل گو قرار میگیرد مانند :\n1import \u0026#34;bytes\u0026#34; حال وقتی که پکیج ایمپورت می شود و نام اش در بالای بدنه فایل کد شما قرار میگیرد می توانید در ادامه نام پکیج توابع, تایپ ها و یا متغیر و const ها را مانند bytes.Buffer فراخوانی کنید.\nانتخاب یک نام خوب برای پکیج خیلی قابل اهمیت است و شما برای انتخاب یک نام خوب بهتر است موارد زیر را رعایت کنید :\nنام کوتاه باشد. مختصر باشد. نام پکیج طوری باشد که به آسانی بتوان بهش دسترسی داشت نام پکیج باشد تماما حروف کوچک باشد. تک کلمه ای باشد. 4.18.1.2 پیاده سازی Getter/Setter # در زبان گو هیچ Getter یا Setter خودکاری وجود ندارد. به همین منظور شما باید Getter/Setter را در قالب متد یک آبجکت پیاده سازی کنید.\n1owner := obj.GetOwner() 2if owner != user { 3 obj.SetOwner(user) 4} 4.18.1.3 نام اینترفیس # نام اینترفیس یک حالت قراردادی دارد که بهتر است این حالت قرار دادی را رعایت کنید. نام اینترفیس با مشخصه یک رفتار کلی باشد که برپایه متدهای اینترفیس تعیین می شود و در نهایت در انتهای نام اینترفیس دو حرف er اضافه می شود. مانند : Reader , Writer, Formmater\n1type Writer interface { 2\tWrite([]byte) error 3} 4.18.1.4 نوع نام گذاری متغیر, تابع, تایپ و \u0026hellip; # در زبان گو نام گذاری حالت قراردادی دارد که کامپایلر نسبت به نوع نام گذاری شما رفتار نشان می دهد. بطوری که شما می توانید نام ها را بصورت MixedCaps یا mixedCaps بنویسید که این حالت نام گذاری را camleCase و PascalCase می گویند.\nزمانیکه شما نام را بصورت PascalCase می نویسید در واقع حالت شما آن متغیر, تابع, تایپ و \u0026hellip; را بصورت Public در نظر گرفتید. اگر شما نام را بصورت camleCase بنویسید در واقع شما متغیر, تابع, تایپ و \u0026hellip; را بصورت Private در نظر گرفتید وفقط در پکیج لول شما در دسترس می باشد. 4.18.1.5 نقطه ویرگول (Semicolons) # مانند C، گرامر رسمی Go از نقطه ویرگول برای پایان دادن به عبارات استفاده می کند، اما برخلاف C، این نقطه ویرگول ها در منبع ظاهر نمی شوند. در عوض، lexer از یک قانون ساده برای درج خودکار نقطه ویرگول ها در حین اسکن استفاده می کند، بنابراین متن ورودی عمدتاً فاقد آنها است.\n4.18.1.6 ساختارهای کنترلی if, for, switch # در زبان گو همانند سایر زبان ها ساختارهای کنترلی نظیر if, for, switch داریم که در زیر می توانید با حالت های کارآمد استفاده از این کنترل ها آن ها آشنا شوید.\nif\nدر زبان گو حالت ساده شرط به شکل زیر است :\n1if x \u0026gt; 0 { 2 return y 3} حال اگر شما یک تابعی داشته باشید که یک مقدار مانند خطا برگرداند می توانید داخل عبارت شرط یک متغییر راه اندازی کنید و تابع را داخلش قرار دهید سپس با قرار دادن نقطه ویرگول شرط را بررسی کرده.\n1if err := file.Chmod(0664); err != nil { 2 log.Print(err) 3 return err 4} اما اگر تابع شما ۲ تا خروجی داشته باشد بهتر است داخل دو متغییر خروجی را بگیرید و در خط بعدی شرط را جهت بررسی هریک از متغیرها قرار دهید:\n1f, err := os.Open(name) 2if err != nil { 3 return err 4} 5codeUsing(f) 4.18.2 استایل اوبر (Uber) # در زیر استایل کدنویسی که تیم مهندسی شرکت اوبر تهیه کردند می پردازیم.\n4.18.3 تکنیک ها # در زیر به تکنیک های زبان گو می پردازیم.\n4.18.4 نکات فنی # در زیر چندین نکات فنی قرار دادم که کاربردی می باشد.\n4.18.4.1 مقدار صفر تایپ ها و مقادیر # همانطور در فصل های قبل اشاره کردیم تایپ ساختار (struct) بدون فیلد مقدارش در حافظه کاملا صفر است. اندازه تایپ آرایه بدون هیچ المنتی صفر است. حال در زیر یک مثال میزنیم تا ببینید:\n1package main 2 3import \u0026#34;unsafe\u0026#34; 4 5type A [0][256]int 6type S struct { 7\tx A 8\ty [1 \u0026lt;\u0026lt; 30]A 9\tz [1 \u0026lt;\u0026lt; 30]struct{} 10} 11type T [1 \u0026lt;\u0026lt; 30]S 12 13func main() { 14\tvar a A 15\tvar s S 16\tvar t T 17\tprintln(unsafe.Sizeof(a)) // 0 18\tprintln(unsafe.Sizeof(s)) // 0 19\tprintln(unsafe.Sizeof(t)) // 0 20} 1$ go run main.go 20 30 40 در Go، اندازه ها اغلب به عنوان مقادیر int نشان داده می شوند. این به این معنی است که بزرگترین طول ممکن یک آرایه MaxInt است که مقدار آن در سیستم عامل های 64 بیتی 2^63-1 است. با این حال، طول آرایه با اندازه عناصر غیر صفر به سختی توسط کامپایلر استاندارد رسمی Go و زمان اجرا محدود می شود.\n1var x [1\u0026lt;\u0026lt;63 - 1]struct{} // okay 2var y [2000000000 + 1]byte // compilation error 3var z = make([]byte, 1\u0026lt;\u0026lt;49) // panic: runtime error: makeslice: len out of range 4.18.4.2 نحوه تخصیص مقادیر اندازه صفر به کامپایلر بستگی دارد # در اجرای استاندارد رسمی فعلی کامپایلر Go (نسخه 1.20)، همه مقادیر محلی صفر تخصیص داده شده روی heap و آدرس یکسانی دارند. به عنوان مثال، موارد زیر دو بار false را چاپ می کنند، سپس دو بار true را چاپ می کنند.\n1package main 2 3var g *[0]int 4var a, b [0]int 5 6//go:noinline 7func f() *[0]int { 8\treturn new([0]int) 9} 10func main() { 11\t// x and y are allocated on stack. 12\tvar x, y, z, w [0]int 13\t// Make z and w escape to heap. 14\tg = \u0026amp;z 15\tg = \u0026amp;w 16\tprintln(\u0026amp;b == \u0026amp;a) // false 17\tprintln(\u0026amp;x == \u0026amp;y) // false 18\tprintln(\u0026amp;z == \u0026amp;w) // true 19\tprintln(\u0026amp;z == f()) // true 20} 1$ go run main.go 2false 3false 4true 5true لطفا توجه داشته باشید که خروجی های برنامه فوق به کامپایلرهای خاصی بستگی دارد. خروجی ها ممکن است برای نسخه های کامپایلر استاندارد رسمی Go در آینده متفاوت باشند. 4.18.4.3 فیلد با اندازه صفر را به عنوان فیلد نهایی یک نوع ساختار قرار ندهید # در کد زیر اندازه تایپ Tz از تایپ Ty بزرگتر است.\n1package main 2 3import \u0026#34;unsafe\u0026#34; 4 5type Ty struct { 6\t_ [0]func() 7\ty int64 8} 9type Tz struct { 10\tz int64 11\t_ [0]func() 12} 13 14func main() { 15\tvar y Ty 16\tvar z Tz 17\tprintln(unsafe.Sizeof(y)) // 8 18\tprintln(unsafe.Sizeof(z)) // 16 19} 1$ go run main.go 28 316 چرا اندازه نوع Tz بیشتر است؟\nدر پیاده‌سازی runtime Go استاندارد کنونی، تا زمانی که یک بلوک حافظه توسط حداقل یک اشاره‌گر زنده مشارکت شود، آن بلوک حافظه به عنوان زباله در نظر گرفته نمی‌شود و جمع‌آوری نمی‌شود. همه فیلدهای یک مقدار ساختار قابل دسترسی می‌توانند آدرس‌گرفته شوند. اگر اندازه فیلد نهایی در یک مقدار ساختار با اندازه غیر صفر صفر باشد، آنگاه گرفتن آدرس فیلد نهایی در مقدار ساختاری، آدرسی را که خارج از بلوک حافظه اختصاص داده شده برای مقدار ساختاری است باز خواهد گرداند. آدرس بازگردانده شده ممکن است به بلوک حافظه دیگری که به طور نزدیکی پس از بلوک حافظه اختصاص داده شده برای مقدار ساختاری با اندازه غیر صفر قرار دارد، اشاره کند. تا زمانی که آدرس بازگردانده شده در یک مقدار اشاره‌گر زنده ذخیره شود، بلوک حافظه دیگری که به جمع‌آوری زباله می‌روید جمع‌آوری نخواهد شد که ممکن است باعث نشت حافظه شود. برای جلوگیری از این نوع مشکلات نشت حافظه، کامپایلر Go استاندارد تضمین می‌کند که دریافت آدرس فیلد نهایی در یک ساختار با اندازه غیر صفر هرگز آدرسی را که خارج از بلوک حافظه اختصاص داده شده برای ساختار نیست را بازنخواهد گرداند. کامپایلر Go استاندارد این کار را با وارد کردن برخی بایت‌ها پس از فیلد صفر آخرین انجام می‌دهد. بنابراین، حداقل یک بایت پس از فیلد نهایی (صفر) نوع Tz وجود دارد. به همین دلیل اندازه نوع Tz بزرگتر از Ty است. در واقع، در سیستم عامل‌های ۶۴ بیتی، ۸ بایت پس از فیلد نهایی (صفر) Tz وجود دارد. برای توضیح این موضوع، باید دو حقیقت را در پیاده‌سازی کامپایلر استاندارد رسمی بدانیم:\nتضمین ترازبندی یک نوع ساختاری، بزرگترین تضمین ترازبندی فیلدهای آن است. اندازه یک نوع همیشه یک ضریبی از تضمین ترازبندی آن است. حقیقت اول، علت برابری تضمین ترازبندی نوع Tz با ۸ (که تضمین ترازبندی نوع int64 است) را توضیح می‌دهد. حقیقت دوم، علت برابری اندازه نوع Tz با ۱۶ را توضیح می‌دهد. منبع : https://github.com/golang/go/issues/9401\n4.18.5 بهینه سازی # در زیر به بهینه سازی در زبان گو می پردازیم.\n"},{"id":62,"href":"/chapter-4/go-commentry/","title":"4.19 اصول کامنت نویسی","section":"فصل چهارم: مباحث پیشرفته","content":"اصول کامنت‌نویسی در زبان گو\n4.19.1 تعریف # «کامنت» به توضیحات‌ی گفته می‌شود که داخل کد، به‌قصد «یادآوری»، «جلب‌توجه مخاطب به موضوع‌(ها)ی خاص»، کمک به onboard شدن اعضاء جدید تیم و مانند اون نگارش می‌شود. در زبان گو، به شیوه‌های زیر کامنت می‌گذاریم:\nقرار دادن // در ابتدای سطر.\n1// defined to store multi string (see below why this is not a good comment) 2var sliceVar []string قراردادن متن کامنت داخل یک بلوک که با */ شروع می‌شود و /* تمام می‌شود.\n1for index, row := range sliceVar { 2 row /* for loop lifetime */ = \u0026#34;new_val\u0026#34; 3 sliceVar[index] /* apply to sliceVar out of loop */ = \u0026#34;new_val\u0026#34; 4 fmt.Println(row) // hint to sliceVar large len 5} دستور ‍gofmt کامنت‌ها را مانند سایر فرمت‌ها، مرتب می‌نماید. اما روش بهتر درصورت امکان، نظم آنها توسط خود توسعه‌دهنده جهت رعایت الگوها و ساختار خاص هر پروژه است.\n1gofmt -w main.go 4.19.2 دیدگاه‌ها درباره «کامنت» # با توجه به این موضوع که در جوامع‌تخصصی توسعه نرم‌افزار، درارتباط با اصل وجود کامنت، مزایا/معایب و چگونگی استفاده از آن، مطالب گوناگون و بعضاً متضادی، حتی از جانب متخصصین، وجود دارد، در این قسمت سعی خواهیم کرد، تاجای‌ممکن پاسخ حساب‌شده‌ای به نیازمندی‌های مختلف در ارتباط با «کامنت‌گذاری» بدهیم.\n4.19.3 کامنت؛ خوب، بد، زشت # در کدهایی که بارها نسخه‌های متفاوتی از آن ایجاد شده و در طول زمان، نیازمندی‌ها عوض شده، کیفیت، کارایی و سرعت اجرا بهبود پیدا کرده، «کامنت» گزارش «چرایی» کد هست برای این: نیاز/کیفیت/کارایی/سرعت اجرا، برای اینکه همه این‌ها رو دوباره تجربه نکنند ... یک کد خوب، هیچ نیازی به کامنت ندارد، به‌زبان‌دیگر، اگر نیاز می‌بینید که برای کدی «کامنت» بنویسید، احتمالاً، کد خوبی ننوشتید ... یک ساختار جدید، ناشناخته و احتمالاً حجیم، به‌قدر‌کافی ماهیتاً اینقدر پیچیدگی دارد که اضافه شدن، یک توضیح به زبان کاملاً انسانی (داخل زبان کامپایلر/مفسری برای زبان ماشین)، نه‌تنها باعث روشن‌تر شدن آن نمی‌شود بلکه مسئله‌ی فهم منظور نگارنده «کامنت» به مجموعه مسائل قبلی اضافه می‌گردد. هیچ‌چیز بیشتر از یک کد پیچیده با کلی «کامنت‌های» پیچیده برای مخاطبی که انتظار روشن بودن چرایی و چگونگی کد را دارد، عذاب‌آور نیست ... همه این‌ها پاسخ‌های متفاوت‌ی است که توسعه‌دهندگان به موضوع «کامنت» می‌دهند. اما «اصولاً» کامنت پرفایده است یا بی‌فایده؟\n4.19.4 آنالیز محصول و محیط توسعه # وقتی در ارتباط با کامنت صحبت می‌کنیم این خیلی مهم است که ما به‌تنهایی مشغول توسعه یک محصول هستیم یا در یک دپارتمان کوچک یا در یک ابَرپروژه \u0026hellip; آیا ما مجبور به تبعیت از یک‌سری دستورالعمل‌های کدنویسی هستیم یا می‌توانیم سلیقه‌شخصی خود را داشته باشیم؟ \u0026hellip;\nشرایط تیم توسعه. نحوه مدیریت(افراد/روش‌ها) پروژه در فرآیند توسعه کد. تعداد زیرمجموعه‌ها و تعداد توسعه‌دهندگان در بخش‌های مختلف. میزان ارتباط و حساسیت کدها بین واحدها و توسعه‌دهندگان. سرعت تغییرات جابجایی توسعه‌دهندگان در پروژه. و موارد مشابه دیگر. تحلیل نیازمندی‌های محصول. مقیاس پروژه. زمان توسعه پروژه. زمان تغییرات همزمان با نسخه‌های ریلیز شده. پیچیدگی و ماهیت نیازهای محصول. و موارد مانند این‌ها. نتیجه اینکه: ابتدا نیازمندی، توانایی و شرایط تیم/محصول را مشخص کنیم، و بعد تصمیم به چرایی و چگونگی کامنت‌نویسی اصولی بگیریم. 4.19.5 انواع کامنت # کامنت فایل/پکیج (Doc Comment) این‌نوع کامنت‌ها درباره «چیستی» کل فایل یا پکیج توضیح دارد.\n1// Copyright 2011 The Go Authors. All rights reserved. 2// Use of this source code is governed by a BSD-style 3// license that can be found in the LICENSE file. 4 5/* 6Package builtin provides documentation for Go\u0026#39;s predeclared identifiers. 7The items documented here are not actually in package builtin 8but their descriptions here allow godoc to present documentation 9for the language\u0026#39;s special identifiers. 10*/ 11package builtin مثال بالا از پکیج builtin درباره حق‌چاپ / تعریف اولیه پکیج و اینکه مستندات در godoc ارائه می‌شود، توضیح داده است.\nکامنت داخلی فانکشن/متد/بلوک/تایپ/متغیر/دستور و مانند آن (Ordinary Comments) این‌نوع کامنت درباره «چرایی» آن قسمتِ خاص اشاره دارد. 1// The delete built-in function deletes the element with the specified key 2// (m[key]) from the map. If m is nil or there is no such element, delete 3// is a no-op. 4func delete(m map[Type]Type1, key Type) در مثال بالا، توسط کامنت توضیح داده شده که وظیفه فانکشن-داخلی delete حذف المنت با کلید مشخص هست، و توضیح دقیق‌تر اینکه اگر المنت مربوط به کلید nil باشد یا وجود نداشته باشد، فانکشن delete هیچ عملیاتی انجام نمی‌دهد. (مثلاً خطا باز نمی‌گرداند − گزارش نمی‌کند و \u0026hellip;)\n4.19.6 اصول کامنت‌نویسی # یک کامنت خوب:\nتوضیح واضحات را نمی‌دهد. در حداقل مقدار «لازم» و «کافی» نگارش می‌شود. بیشتر درباره «چیستی/چرایی» اشاره دارد و نه «چگونگی». دارای یک الگو و دستورالعمل نگارشی واحد برای نظم و سرعت ارتباط مخاطب است. وجودش آگاه‌کننده موضوع بااهمیت بالاست. مربوط به موضوعی است که اکنون وجود دارد (بروزرسانی کامنت‌ها-حذف کامنت‌های اضافی) ادبیات کامنت، بسته به تیم و دستورالعمل‌ها، بهتر است رسمی نگارش شود تا عمومی بماند. البته گاهی کمی شوخ‌طبعی هم اگر کنترل‌شده باشد، باعث انتقال‌مطلب بهتر می‌شود. درصورت لازم بودن یک یا چند منبع مرتبط با کد، حاوی لینک url خواهد بود. 1 // flip the buffer for this connection if we need to drain it. 2 // note that for a successful query (i.e. one where rows.next() 3 // has been called until it returns false), `rows.mc` will be nil 4 // by the time the user calls `(*Rows).Close`, so we won\u0026#39;t reach this 5 // see: https://github.com/golang/go/commit/651ddbdb5056ded455f47f9c494c67b389622a47 6 mc.buf.flip() 4.19.7 به پرتگاه نزدیک می‌شوید! # زامبی کد: به کدی می‌گویند که به دلیل عدم کارایی، اصلاح با کد جدید، و یا مشابه این موارد، بجای «حذف»، «کامنت» می‌شوند. کامنت اسپاگتی کد: به کامنت‌های دنباله‌داری گفته می‌شود که برای توضیح یک کدی که ساختار منظم و مشخصی ندارد، نگارش می‌شود. یکی دیگر از استفاده‌های کامنت، وظیفه‌ی برنامه‌ریزی‌شده می‌باشد که اگر کنترل نشود، یکی دیگر از عذاب‌های عظیم خواهد بود. جای کلمات عبور و مقادیر امنیتی در کامنت نیست. اگر دائماً نیاز می‌بینید که در مراحل مختلف به همکاران بصورت کامنت «هشدار» بنویسید، شاید باید به‌فکر اصلاح معماری نرم‌افزار باشید. کامنت‌های شما، نباید تبدیل به «نویز» درکدنویسی دیگران شود. تعدد کامنت‌ها کد را تبدیل به کد کثیف می‌کند که خوانایی ضعیفی خواهد داشت. کامنت، جای دردل کردن، شکایت از مدیرپروژه، تعریف از خود و گفتگو نیست. 4.19.8 انواع directive comment # //go:generate: این کامنت برای مشخص کردن یک دستور است که باید توسط ابزار go generate اجرا شود. این کامنت معمولاً قبل از یک دستور تولید کد قرار داده می‌شود که به شما اجازه می‌دهد کد Go را به صورت خودکار تولید کنید.\n//go:binary-only-package: این کامنت برای اعلام این استفاده می‌شود که یک بسته باید به عنوان یک بسته فقط دودویی در کامنت گرفته شود، به معنای این است که کد منبع بسته در دسترس نیست. این برای بسته‌هایی استفاده می‌شود که شامل کد‌های محصولی یا بسته‌های مشخص سیستم‌عامل هستند.\n//go:build: این کامنت برایمحدودیت‌های ساخت استفاده می‌شود. این به شما امکان می‌دهد که کنترل کنید که یک فایل باید بر اساس شرایط خاصی مانند سیستم عامل، معماری یا برچسب ساخت، در ساخت شامل شود یا خیر.\n//go:cgo_\u0026hellip;: چندین کامنت دستوری وجود دارد که با cgo_ شروع می‌شوند، مانند //go:cgo_import_dynamic و //go:cgo_export_dynamic. این کامنتات همراه با cgo استفاده می‌شوند، ابزاری که به کد Go اجازه می‌دهد تا به کد C و بالعکس برای فراخوانی دستورات استفاده شود. آن‌ها دستوراتی را به ابزار cgo ارائه می‌دهند که نحوه برخورد کد C را مشخص می‌کنند.\n//go:noinline: این کامنت برای مشخص کردن این استفاده می‌شود که یک تابع توسط کامپایلر به صورت inline نباید درج شود. Inline کردن یک تابع یک تکنیک بهینه‌سازی است که کد یک تابع به طور مستقیم در کد فراخواننده آن قرار می‌گیرد و هزینه فراخوانی تابع را حذف می‌کند. استفاده از این کامنت از کامپایلر جلوگیری می‌کند تا برای تابع مشخص شده inline کردن انجام دهد.\n//go:nosplit: این کامنت برای مشخص کردن این استفاده می‌شود که یک تابع باید توسط برنامه‌ریز Go runtime اجرا شده (split) نشود. این معمولاً برای توابع سطح پایین استفاده می‌شود که نیاز به کنترل دقیق بر روی اجرای آن‌ها دارند و نباید وقفه داده شوند.\n//go:linkname: این کامنت برای برقراری ارتباط بین کد Go و نمادهای خارجی یا کد غیر Go استفاده می‌شود. این به شما اجازه می‌دهد تا به یک نماد با نام متفاوت یا از بسته‌ای دیگر ارجاع دهید.\n//go:noescape: این کامنت برای مشخص کردن این استفاده می‌شود که آرگومان‌های اشاره گر تابع escape نمی‌کنند، به معنایی که در طول عمر تابع ذخیره یاستفاده نمی‌شوند یا استفاده نمی‌شوند. این اطلاعات به کامپایلر اجازه می‌دهند که بهینه‌سازی‌های حافظه تابع را انجام دهد.\n//go:embed: این کامنت برای اضافه کردن فایل‌های استاتیک یا دایرکتوری‌ها به طور مستقیم به باینری Go در زمان کامپایل استفاده می‌شود. این فرآیند از جمله فرآیند بسته‌بندی و توزیع منابع با برنامه‌های Go خود است.\n//go:generate go run: این کامنت یک نوع دیگر از کامنت //go:generate است. این کامنت مشخص می‌کند که دستور زیر کامنت باید توسط اجرای برنامه Go با استفاده از دستور go run اجرا شود.\n//go:build \u0026hellip;: این کامنت یک فرم گسترده‌تر از کامنت build است. این به شما امکان می‌دهد شرایط ساخت را با استفاده از اپراتورهای منطقی بولی، پرانتز و نفی مشخص کنید. این امکانات بیشتری در کنترل کردن فایل‌هایی که در ساخت شامل می‌شوند، فراهم می‌کند.\n//go:protofile: این کامنت برای مشخص کردن پروتوباف فایل مرتبط با یک فایل منبع Go استفاده می‌شود. این معمولاً در کد Go استفاده می‌شود که شامل کد پروتوباف تولید شده است، اجازه می‌دهد که کامپایلر فایل‌های Go و پروتوباف رابه درستی به هم پیوند دهد.\n//go:nowritebarrier: این کامنت برای مشخص کردن این استفاده می‌شود که یک تابع بدون write barrier باید اجرا شود. Write barrier برای تعقیب و به‌روزرسانی اشاره‌گرها در زمان تخصیص و آزادسازی حافظه توسط garbage collector استفاده می‌شود. استفاده از این کامنت ممکن است خطرناک باشد و تنها در موارد خاصی که مدیریت دستی حافظه لازم است، باید استفاده شود.\n//go:norace: این کامنت دستوری برای غیرفعال کردن ردیابی race برای یک تابع خاص است. ردیاب race یک ابزار در Go است که به شناسایی دسترسی همزمان به متغیرهای مشترک که ممکن است منجر به دور زدن داده‌ها (race condition) بشود، کمک می‌کند. این دستور می‌تواند هنگامی استفاده شود که از عدم وجود شرایط race برای یک تابع خاص اطمینان دارید.\n//go:buildignore: این کامنت دستوری برای حذف یک فایل از فرآیند ساخت استفاده می‌شود. این به سیستم ساخت Go می‌گوید که این فایل را نادیده بگیرد و در هنگام کامپایل بسته، شامل نشود.\n//go:generate goimports: این کامنت دستوری برای استفاده در ارتباط با دستور //go:generate استفاده می‌شود تا به صورت خودکار ابزار goimports اجرا شود. goimports به طور خودکار import statements را به روزرسانی و فرمت دهی می‌کند، اطمینان حاصل می‌کند که import های بسته درست هستند و import های بی‌استفاده را حذف می‌کند.\n//go:embed pattern: این کامنت دستوری یک فرم گسترده‌تر از //go:embed است و به شما اجازه می‌دهد الگویی را برای تطبیق با فایل‌ها یا دایرکتوری‌ها برای جاسازی در حالت تعبیه شده مشخص کنید. این امکانات، در انتخاب فایل‌ها یا دایرکتوری‌های خاص بیشتری ارائه می‌دهد.\n//go:nolint: این کامنت دستوری برای سرکوب خطاها و هشدارهای خاص لینتر برای یک خط کد خاص استفاده می‌شود. این اغلب هنگامی استفاده می‌شود که یک قانون لینتر یک false positive را سیگنال می‌دهد یا وقتی دلیل معتبری برای نادیده گرفتن یک مسئله لینتینگ موقتا وجود دارد.\n//go:generate go test: این کامنت دستوری برای استفاده در ارتباط با دستور //go:generate استفاده می‌شود تا به صورت خودکار دستور go test اجرا شود. این دستور معمولاً برای تولید و اجرای کد آزمایشی برای یک بسته استفاده می‌شود.\n//go:uintptrescapes: این کامنت دستوری برای نشان دادن این است که یک مقدار uintptr ممکن است به حافظه heap فرار کند. به طور پیش فرض، کامپایلر فرض می‌کند که مقدارهای uintptr فرار نمی‌کنند، اما استفاده از این دستور اجازه تجزیه و تحلیل فرار دقیق‌تر را می‌دهد.\n//go:build !constraint: این کامنت دستوری برای حذف یک فایل از فرآیند ساخت بر اساس شرط ساخت خاص استفاده می‌شود. این به شما اجازه می‌دهد یک شرط را مشخص کنید که برای شامل شدن فایل در فرآیند ساخت باید برآورده نشود.\n//go:checkptr: این کامنت دستوری برای فعال کردن بررسی‌های ایمنی اضافی برای اشاره‌گرها در کد استفاده می‌شود. این دستور به کامپایلر دستور می‌دهد تا بررسی‌های رانتایم اضافی را برای شناسایی عملیات اشاره‌گر ناموفق و مسائل امنیتی حافظه انجام دهد.\n//go:nosplitcheck: این کامنت دستوری برای غیرفعال کردن بررسی nosplit برای یک تابع استفاده می‌شود. بررسی nosplit بررسی می‌کند که یک تابع بدون پیش‌بینی از برنامه‌ای که در آینده اجرا می‌شود، بدون توقف توسط برنامه اجرا شود.استفاده از این دستور ممکن است خطرناک باشد و فقط در صورت ضرورت باید استفاده شود.\n//go:noruntime: این کامنت دستوری برای نشان دادن این است که یک بسته به Go runtime وابسته نیست. این به کامپایلر اطلاع می‌دهد که بسته می‌تواند در یک محیط استفاده شود که Go runtime در دسترس نیست یا نیاز نیست.\nمثال استفاده از directive comment:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5//go:generate stringer -type=Age 6 7type Age int 8 9const ( 10\tCHILDERN Age = iota 11\tADOLESCENTS 12\tADULTS 13) 14 15func main() { 16\tfmt.Println(CHILDERN.String()) 17} در کد فوق ما یک directive comment اضافه کردیم حال کافیه با استفاده از دستور go generate متد استرینگ تایپ را جنریت کنیم.\n1$ go generate ./... "},{"id":63,"href":"/chapter-4/go-code-rules/","title":"4.20 قوانین کدنویسی در گو","section":"فصل چهارم: مباحث پیشرفته","content":"قوانین در زبان گو همانند دیگر زبان های برنامه نویسی به دو دسته تقسیم می شود. بخشی از قوانین در سطح سینتکس زبان مطرح می شوند، لذا رعایت آنها مهم هست، در غیر اینصورت کامپایلر قادر به کامپایل درست کدهای شما نخواهد بود و در بعضی شرایط ممکن است به صورت خاموش خطا به محیط اجرا (runtime) نیز برده شود. بخشی از قوانین به عنوان پیشنهاد و ترجیح مطرح هستند که عموما توسط لینتر بررسی می شوند و تاثیر اصلی بر خوانایی منطق کدها دارند. یعنی رعایت آنها الزام قطعی ندارد. به طور مثال استفاده از _ در نام گذاری ها در گو توصیه نمی شود ولی در کتابخانه استاندارد (الحاقی به زبان گو) به وفور عدم رعایت این موضوع دیده می شود.\nلازم به ذکر است که سازمان ها می توانند قوانین پیشنهادی خود را توسعه دهند و با توسعه لینتر اختصاصی در فرآیند توسعه نرم افزار خود با روش هایی مانند CI/CD از رعایت قوانین خود توسط توسعه دهندگان پروژه های نرم‌افزاری خود اطمینان حاصل نمایند.\n4.20.1 قوانین نام گذاری # در زبان برنامه‌نویسی Go برای نامگذاری توابع، همان گونه که در بالا نیز توضیح داده شد دو مدل قوانین (اجباری و اختیاری) وجود دارد. قوانین اجباری باید رعایت شوند و قوانین اختیاری بهتر است رعایت شوند تا کد هم خوانایی بیشتری داشته باشد و هم از نظر تعاریف و نام‌گذاری مطابق رویه های (پروتکل های) معرفی شده توسط تیم توسعه زبان، به صورت استاندارد باشند.\n4.20.1.1 نام توابع # نام توابع باید با حروف بزرگ یا کوچک شروع شود. توابعی که با حروف بزرگ شروع می‌شوند، به عنوان public تلقی می‌شوند و از سمت بیرون پکیج برای دیگران قابل دسترس هستند. توابعی که با حروف کوچک شروع می‌شوند، به عنوان private تلقی می‌شوند و فقط در داخل پکیج موجود هستند.\nنام توابع public بصورت Pascal Case هستند مانند: ()CalculateInterestRate نام توابع private بصورت camel Case هستند مانند: ()calculateInterestRate برای اطلاعات بیشتر درخصوص public یا private میتوانید به بخش Encapsulation مراجعه کنید.\n4.20.1.2 نام فایل های پسوند go. # نام فایل باید با حرف کوچک شروع شود. نام فایل باید از حروف بزرگ و خط تیره (-) استفاده نکند. نام فایل باید با نام پکیج مطابقت داشته باشد. نام فایل باید از جمله معانی آن و بخشی از توضیح فایل باشد. برای مثال: database_connection.go، calculator_test.go 4.20.1.3 نام interface # نام اینترفیس باید با I شروع نشود. نام اینترفیس باید با camelCase باشد. نام اینترفیس باید صفت یا اسم باشد و معمولاً با حرف I شروع نمی‌شود. برای مثال: Reader، Writer در انتهای نام حتما er داشته باشد. 4.20.1.4 نام پارامترهای توابع # نام پارامترها باید با حروف کوچک شروع شود. نام پارامترها باید با camelCase باشد. برای مثال، تابع زیر درست نام‌گذاری شده است:\n1func CalculateInterestRate(principal float64, interestRate float64, termInYears int) float64 { 2 // function code here 3} در این مثال، تمامی پارامترهای تابع با حروف کوچک، با CamelCase نام‌گذاری شده‌اند.\nبه طور کلی، هدف از این قوانین نام‌گذاری، رعایت استانداردهایی برای نام‌گذاری است تا کد خواناتر و قابل فهم باشد و همچنین قابلیت نگهداری و توسعه را بهتری داشته باشد.\n4.20.1.5 نام پکیج # نام پکیج در Go باید با حرف کوچک شروع شود و نام پکیج باید شامل تنها حروف کوچک انگلیسی، اعداد و خط فاصله (-) باشد. همچنین در نام پکیج از حروف بزرگ استفاده نشود، همچنین اسم پکیج باید توصیفی از محتوای آن باشد. برای نام‌گذاری پکیج، معمولاً از نام اصلی محصول یا سرویسی که پیاده‌سازی می‌شود، یا نام ماژول یا قسمتی از نرم‌افزار استفاده می‌شود.\nمثلاً اگر یک پروژه برای پردازش تصویر داریم، نام پکیج می‌تواند \u0026ldquo;imageprocessing\u0026rdquo; باشد. همچنین اگر می‌خواهیم یک کتابخانه بخشی از پروژه خود را به اشتراک بگذاریم، می‌توانیم از نام پروژه یا نام ماژول استفاده کنیم.\nتوجه داشته باشید که نام پکیج باید با نام پوشه‌ای که فایل‌های پروژه در آن هستند همخوانی داشته باشد. برای مثال، اگر فایل‌های پروژه در پوشه imageprocessing قرار دارند، نام پکیج باید imageprocessing باشد.\n4.20.1.6 نام متغیر و const # برای متغیرها و ثابت‌ها در زبان برنامه‌نویسی Go نیز نام‌های خاصی وجود دارد که برای آن‌ها پیشنهاد می‌شود. در ادامه به برخی از قوانین نام‌گذاری برای متغیرها و ثابت‌ها در Go اشاره می‌شود:\nمتغیر\nنام متغیر باید با حرف کوچک شروع شود. نام متغیر باید جهت نمایش نوع متغیر در نام آن و حاوی توضیح مختصر در مورد نام متغیر باشد. نام متغیر باید با camelCase باشد. نام متغیر باید کاملاً توصیفی باشد و نیازی به توضیحات اضافی در مورد آن نباشد. برای مثال، به جای تعریف متغیر x برای نگهداری مقدار سن، می‌توان از نام age استفاده کرد:\n1var age int // تعریف متغیر برای سن شخص const\nنام ثابت باید با حروف بزرگ شروع شود. نام ثابت باید جهت نمایش نوع ثابت در نام آن و حاوی توضیح مختصر در مورد مقدار ثابت باشد. نام ثابت باید با Snake_case باشد. نام ثابت باید کاملاً توصیفی باشد و نیازی به توضیحات اضافی در مورد آن نباشد. برای مثال، برای تعریف ثابت مقدار پاییز در فصل های سال، می‌توانیم از نام SEASON_AUTUMN استفاده کنیم:\n1const SEASON_AUTUMN = \u0026#34;پاییز\u0026#34; توجه داشته باشید که برای نام‌گذاری متغیرها و ثابت‌ها در Go، پیشنهاد می‌شود از نام‌هایی استفاده کنید که بهره بیشتری از خوانایی و قابلیت نگهداری کد برداشته شود. و نام‌هایی که توصیف کننده‌تر و صحیح‌تر هستند برای این منظور بهتر استفاده می‌شوند.\n"},{"id":64,"href":"/chapter-4/go-garbage-collector/","title":"4.21 زباله جمع کن (garbage collector)","section":"فصل چهارم: مباحث پیشرفته","content":"یکی از جذابیت های زبان های برنامه نویسی جدید قابلیت زباله جمع کن (garbage collector) ایجاد شده در آنها است. بطور خلاصه مدیریت و آزاد سازی منابع اختصاص داده شده از حافظه را که بصورت خودکار در زبان های برنامه نویسی مدرن انجام می شود را garbage collector می شناسیم.\nمدیریت منابع حافظه که بسیار حساس و در مواقعی زمان بر است توسط برخی زبان ها بصورت توکار پشتیبانی می شود و این کار به افزایش سرعت و همچنین کاهش خطا در زمان و پروسه تولید نرم افزار می شود. با تمام این تفاسیر مواقعی است که برنامه نویس می باید خودش مدیریت حافظه را در دست گرفته و پیش از بروز شرایط بحرانی اقدام به آزاد سازی حافظه و یا منابع اختصاص یافته نماید. خبر خوب اینکه در زبان Go مدیریت منابع حافظه نسبت به زبان های دیگر ساده تر و راحتر است ولی در این نوشته سعی می کنیم تا درک خوبی از مدیریت منابع و نحوه عملکرد آن داشته باشید بنابر این در ادامه با یک مثال که نیاز به بررسی کد در سطوح پایین دارد می پردازیم.\nاستفاده از uprobes # برای بررسی وضعیت حافظه ما از uprobes استفاده می کنیم این بسته امکان بسیاری در اختیارمان قرار می دهد برای مثال نیازی به تغییر کد برنامه نمی باشد و برای برنامه های درحال اجرا نیز می توان استفاده نمود.\nمراحل garbage collection # مکانیزم garbage collection در زبان go بصورت هم رونده یا concurrent در کنار برنامه ما اجرا می شود که همین قابلیت دلیل عدم توقف یا مکث برنامه در زمان پاکسازی حافظه است و دو مرحله کلی را برای پاکسازی حافظه اجرا می کند.\n1- مرحله Mark phase در این مرحله GC اشیاء و متغیرهای مرده دربرنامه که بخشی از حافظه را اشغال کرده‌اند را جستجو و شناسایی می کند.\n2- مرحله Sweep phase در این مرحله اشیائی که در فاز قبل نشانه گذاری شده‌اند بصورت فیزیکی از حافظه دور ریخته می شود.\nتصویر بالا مراحل مختلف شناسایی و پاکسازی را نشان می دهد\nدر ادامه قطعه کد ذیل را داریم که در واقع یک عمل ساده درخواست و پاسخ به یک آدرس وب است\n1http.HandleFunc(\u0026#34;/allocate-memory-and-run-gc\u0026#34;, func(w http.ResponseWriter, r *http.Request) { 2 3 arrayLength, bytesPerElement := parseArrayArgs(r) 4 5 arr := generateRandomStringArray(arrayLength, bytesPerElement) 6 7 fmt.Fprintf(w, fmt.Sprintf(\u0026#34;Generated string array with %d bytes of data\\n\u0026#34;, len(arr) * len(arr[0]))) 8 9 runtime.GC() 10 11 fmt.Fprintf(w, \u0026#34;Ran garbage collector\\n\u0026#34;) 12 13 }) در این قطعه کد یک متغیر که محتوای آن آرایه‌ای از رشته ها است تولید می شود و در پایان با صدا زدن تابع runtime.GC از GC درخواست می کنیم که حافظه را پاکسازی کند دقت کنید که در این قسمت از کد شی arr دیگر مورد استفاده قرار نمی گیرد و از نظر طول عمر مرده به حساب می آید و GC اقدام به پاکسازی فظای اشغال شده توسط این متغیر را می کند.\nاما داستان به این سادگی هم نیست برای مثال مهمترین ویژگی GC این است که بصورت خودکار در زمان های مناسب وارد عمل می شود و اقدام به رها سازی حافظه می نماید باید توجه داشته باشیم که خود عملیات GC بدون سربار به سیستم نیست و شامل موارد ذیل است\nGC Pause Time: عملیات پاکسازی بصورت همزمان با اجرای برنامه انجام می شود ولیکن در برنامه های سنگین بصورت لحظه ای می شود متوجه سربار زمان توقف برنامه برای عملیات پاکسازی شد. هرچند که برای کاربران عادی مشهود نباشد.\nMemory Allocation: جهت نشانه گذاری اشیاء مرده نیز نیاز به تخصیص حافظه است.\nCPU usage: تمامی فعالیت های انجام شده نیاز به پردازش دارد که قاعدتا به پردازنده سربار اضافی تحمیل خواهد کرد.\nGC trigger threshold این قابلیت در زبان go قابل تنظیم است و اجازه می دهد تا یک آستانه برای عملیات پاکسازی در نظر بگیریم که به بصورت درصد مشخص می شود. چنانچه درصد استفاده از حافظه از مقدار تعیین شده در متغیر آستانه بیشتر شود عملیات پاکسازی اجرا خواهد شد که این به نوبه خود چالش برانگیز است برای مثال اگر مقدار آستانه را زیاد تعریف کنیم ممکن است برنامه با کمبود منابع روبرو شود و یا درصورت تعیین مقدار پایین منابعی مانند پردازنده بیش از حد درگیر خواهند شد. Memory Pressure: مواقعی که برنامه به لحاظ منابع حافظه تحت فشار و محدودیت است در این زمان GC بطور متوالی اجرا خواهد شد که می تواند دلیل توقف برنامه اصلی شود\nمانیتور نحوه کار GC # در ادامه میخواهیم توابع ذیل که در runtime موجود است را به کمک uprobes زیر نظر بگیریم تا علاوه بر مقادیر تولید شده در آنها، فرآیند آنها نیز برایمان قابل درک باشد.\nGC تابع اجرای عملیات پاکسازی gcWaitOnMark تابع تشخیص اشیا جهت رها سازی gcSweep تابع رها سازی منابع دقت داشته باشید که تنظیم و اجرا uprobes نیاز به اطلاع بیشتر دارد که در حوصله این نوشتار نیست و متوانید با جستجو در اینترنت به منابع مورد نیاز دسترسی داشته باشید\n1$ curl \u0026#39;127.0.0.1/allocate-memory-and-run-gc?arrayLength=10\u0026amp;bytesPerElement=20\u0026#39; 2 3Generated string array with 200 bytes of data 4 5Ran garbage collector پس از اجرای کوئری بالا بر روی آدرس برنامه خود نتایج ذیل حاصل می شود نکته قابل توجه اینجاست که تابع gcWaitOnMark دو بار در طول عملیات پاکسازی اجار می شود که بار اول جهت اعتبار سنجی منابع نشانه گذاری شده قسمت قبل است.\nبا این توضیحات حال می خواهیم به بررسی چند مثال ساده بپردازیم تا ببینیم در چه مواقعی بهتر است برنامه نویس در بخش های مناسب خود اقدام به پاکسازی حافظه نماید\n1 2package main 3 4import ( 5\t\u0026#34;fmt\u0026#34; 6\t\u0026#34;runtime\u0026#34; 7) 8 9func main() { 10\t// Allocate some memory for the program to use 11\ts := make([]string, 0, 100000) 12\tfor i := 0; i \u0026lt; 100000; i++ { 13\ts = append(s, \u0026#34;hello, world\u0026#34;) 14\t} 15 16\t// Print the initial memory usage 17\tvar m runtime.MemStats 18\truntime.ReadMemStats(\u0026amp;m) 19\tfmt.Println(\u0026#34;Initial HeapAlloc: \u0026#34;, m.HeapAlloc) 20 21\t// Trigger the garbage collector 22\truntime.GC() 23 24\t// Print the memory usage after the garbage collector has run 25\truntime.ReadMemStats(\u0026amp;m) 26\tfmt.Println(\u0026#34;After GC HeapAlloc: \u0026#34;, m.HeapAlloc) 27 28\t// Release the memory 29\ts = nil 30\t// Trigger the garbage collector 31\truntime.GC() 32\t// Print the memory usage after the garbage collector has run 33\truntime.ReadMemStats(\u0026amp;m) 34\tfmt.Println(\u0026#34;After release HeapAlloc: \u0026#34;, m.HeapAlloc) 35} خروجی برنامه :\n1# go run main.go 2Initial HeapAlloc: 1654512 3After GC HeapAlloc: 37872 4After release HeapAlloc: 37872 در کد بالا به کمک یک حلقه در هربار اجرای آن مقداری را به رشته قبلی خود اضافه نموده ایم و بعد از آن مقدار فضای اشغال شده توسط رشته ما در حافظه را نمایش می دهیم در ادامه به کمک runtime.GC حافظه را تخلیه می کنیم و در انتها بررسی می کنیم که آیا مقدار متغیر ما بصورت واقعی تخلیه شده است که نتایج خروجی موارد فوق را تائید می نماید. به یاد داشته باشید که منابع سیستم همواره محدود می باشد و در شرایط این چنینی می بایست خود برنامه نویس با تشخیص درست اقدام به تخلیه حافظه نماید.\nاستفاده از GODEBUG # در مواقعی نیاز است تا GC را بدونه کتابخانه و ابزار اضافی و فقط با قابلیت‌های داخلی خود زبان go بررسی نمائیم که در چنین شرایطی بهتر است از GODEBUG استفاده کنیم.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;runtime\u0026#34; 6\t\u0026#34;time\u0026#34; 7) 8 9func printStats(mem runtime.MemStats) { 10\truntime.ReadMemStats(\u0026amp;mem) 11\tfmt.Println(\u0026#34;mem.Alloc:\u0026#34;, mem.Alloc) 12\tfmt.Println(\u0026#34;mem.TotalAlloc:\u0026#34;, mem.TotalAlloc) 13\tfmt.Println(\u0026#34;mem.HeapAlloc:\u0026#34;, mem.HeapAlloc) 14\tfmt.Println(\u0026#34;mem.NumGC:\u0026#34;, mem.NumGC) 15\tfmt.Println(\u0026#34;-----\u0026#34;) 16} 17 18func main() { 19\tvar mem runtime.MemStats 20\tprintStats(mem) 21 22\tfor i := 0; i \u0026lt; 10; i++ { 23\ts := make([]byte, 100000000) 24\tif s == nil { 25\tfmt.Println(\u0026#34;Operation failed!\u0026#34;) 26\t} 27\t} 28\tprintStats(mem) 29 30\tfor i := 0; i \u0026lt; 10; i++ { 31\ts := make([]byte, 100000000) 32\tif s == nil { 33\tfmt.Println(\u0026#34;Operation failed!\u0026#34;) 34\t} 35\ttime.Sleep(5 * time.Second) 36\t} 37\tprintStats(mem) 38 39} خروجی کد:\n1# go run main.go 2mem.Alloc: 48256 3mem.TotalAlloc: 48256 4mem.HeapAlloc: 48256 5mem.NumGC: 0 6----- 7mem.Alloc: 100045200 8mem.TotalAlloc: 1000128496 9mem.HeapAlloc: 100045200 10mem.NumGC: 9 11----- 12^Csignal: interrupt در کد فوق برنامه بدون دیباگ خروجی فوق را تولید نموده است که مقدار منابع مصرف شده در هر چرخه را نمایش می دهد اما اگر بخواهیم برنامه را با دستور GODEBUG اجرا کنیم خروجی متفاوت خواهد بود به یاد داشته باشید ما در اینجا میخواهیم مقادیر تولید شده که بصورت key-value است و با علامت کاما از هم جدا شده اند و فقط برای GC را بررسی کنیم درحالی که می توان بخش های دیگر برنامه را نیز با سوئیچ های مختلف دیباگ کرد بنابراین اینبار برنامه را با دستور ذیل اجرا می کنیم\n1# GODEBUG=gctrace=1 go run main.go a 2gc 1 @0.019s 1%: 0.014+2.4+0.001 ms clock, 0.014+0.33/0/0+0.001 ms cpu, 4-\u0026gt;4-\u0026gt;0 MB, 5 MB goal, 1 P 3gc 2 @0.050s 3%: 0.027+5.1+0.002 ms clock, 0.027+0.37/1.0/0+0.002 ms cpu, 4-\u0026gt;4-\u0026gt;1 MB, 5 MB goal, 1 P 4gc 3 @0.089s 2%: 0.067+3.3+0.002 ms clock, 0.067+0.66/0/0+0.002 ms cpu, 4-\u0026gt;4-\u0026gt;1 MB, 5 MB goal, 1 P 5gc 4 @0.128s 2%: 0.032+2.6+0.003 ms clock, 0.032+0.82/0/0+0.003 ms cpu, 4-\u0026gt;4-\u0026gt;1 MB, 5 MB goal, 1 P 6gc 5 @0.153s 2%: 0.046+5.1+0.002 ms clock, 0.046+0.81/0/0+0.002 ms cpu, 4-\u0026gt;5-\u0026gt;1 MB, 5 MB goal, 1 P 7gc 6 @0.175s 3%: 0.030+11+0.002 ms clock, 0.030+1.4/0.16/0+0.002 ms cpu, 4-\u0026gt;5-\u0026gt;1 MB, 5 MB goal, 1 P 8gc 7 @0.224s 2%: 0.027+2.4+0.003 ms clock, 0.027+0.63/0/0+0.003 ms cpu, 4-\u0026gt;5-\u0026gt;2 MB, 5 MB goal, 1 P 9# command-line-arguments 10gc 1 @0.004s 17%: 0.009+2.4+0.002 ms clock, 0.009+1.3/0/0+0.002 ms cpu, 4-\u0026gt;6-\u0026gt;5 MB, 5 MB goal, 1 P 11gc 2 @0.036s 16%: 0.014+8.7+0.004 ms clock, 0.014+4.0/2.2/0+0.004 ms cpu, 9-\u0026gt;9-\u0026gt;8 MB, 11 MB goal, 1 P 12mem.Alloc: 48128 13mem.TotalAlloc: 48128 14mem.HeapAlloc: 48128 15mem.NumGC: 0 16----- 17gc 1 @0.007s 1%: 0.011+0.11+0.002 ms clock, 0.011+0.10/0/0+0.002 ms cpu, 95-\u0026gt;95-\u0026gt;0 MB, 96 MB goal, 1 P 18gc 2 @0.054s 0%: 0.030+0.13+0.002 ms clock, 0.030+0.12/0/0+0.002 ms cpu, 95-\u0026gt;95-\u0026gt;0 MB, 96 MB goal, 1 P 19gc 3 @0.106s 0%: 0.023+0.12+0.002 ms clock, 0.023+0.12/0/0+0.002 ms cpu, 95-\u0026gt;95-\u0026gt;0 MB, 96 MB goal, 1 P 20gc 4 @0.141s 0%: 0.023+0.15+0.004 ms clock, 0.023+0.15/0/0+0.004 ms cpu, 95-\u0026gt;95-\u0026gt;0 MB, 96 MB goal, 1 P 21gc 5 @0.185s 0%: 0.021+0.12+0.001 ms clock, 0.021+0.11/0/0+0.001 ms cpu, 95-\u0026gt;95-\u0026gt;0 MB, 96 MB goal, 1 P 22gc 6 @0.221s 0%: 0.023+0.22+0.002 ms clock, 0.023+0.22/0/0+0.002 ms cpu, 95-\u0026gt;95-\u0026gt;0 MB, 96 MB goal, 1 P 23gc 7 @0.269s 0%: 0.025+0.12+0.001 ms clock, 0.025+0.12/0/0+0.001 ms cpu, 95-\u0026gt;95-\u0026gt;0 MB, 96 MB goal, 1 P 24gc 8 @0.311s 0%: 0.032+0.33+0.002 ms clock, 0.032+0.32/0/0+0.002 ms cpu, 95-\u0026gt;95-\u0026gt;0 MB, 96 MB goal, 1 P 25gc 9 @0.350s 0%: 0.022+0.10+0.006 ms clock, 0.022+0.097/0/0+0.006 ms cpu, 95-\u0026gt;95-\u0026gt;0 MB, 96 MB goal, 1 P 26gc 10 @0.390s 0%: 0.021+0.11+0.005 ms clock, 0.021+0.10/0/0+0.005 ms cpu, 95-\u0026gt;95-\u0026gt;0 MB, 96 MB goal, 1 P 27mem.Alloc: 100045256 28mem.TotalAlloc: 1000128368 29mem.HeapAlloc: 100045256 30mem.NumGC: 9 31----- در نگاه اول خروجی کد بالا کمی گند به نظر می رسد که سعی می کنیم در ذیل آنها را توضیح دهیم\nخروجی توضیح gc 1 شماره پاکسازی که در هربار اجرای عملیات پاکسازی بصورت خودکار به آن اضافه می شود @0.007s زمان اجرای پاکسازی بعد از شروع به کار برنامه 0% درصد منابع پردازشی استفاده شده بعد از اجرای برنامه 0.011+0.11+0.002 ms clock مقدار این متغیر متشکل از چند مقدار است که بصورت ذیل محاسبه می شود Tgc = Tseq + Tmark + Tsweep 95-\u0026gt;95-\u0026gt;0 MB این متغیر نیز چند مقداری است و مقادیر اول نشانگر عملکرد حافظه قبل از اجرای پاکسازی ، دوم بعد از اجرای پاکسازی و سوم مقدار پشته است 96 MB goal اندازه پشته برنامه مورد نظر 1 P تعداد پردازنده مورد استفاده شده Tseq: زمان توقف گوروتین های کاربر\nTmark: زمان مورد استفاده جهت فاز mark\nTsweep: زمان مورد استفاده جهت فاز sweep\n"},{"id":65,"href":"/chapter-4/go-plugin/","title":"4.22 کتابخانه Plugin","section":"فصل چهارم: مباحث پیشرفته","content":"در میان ویژگی‌های قابل توجه Go نسخه 1.8، سیستم جدید پلاگین‌های Go قرار دارد. این ویژگی به برنامه‌نویسان اجازه می‌دهد تا برنامه‌های ماژولار بدون ارتباط زنجیره‌ای با هم، با استفاده از بسته‌هایی که به صورت کتابخانه‌های اشیا شیء‌گرا کامپایل شده‌اند، ساخته شوند و به‌صورت پویا در زمان اجرا بارگذاری و به‌صورت پیوسته به آن‌ها پیوند داده شوند.\nاین تغییر بزرگی است! چرا که توسعه‌دهندگان نرم‌افزارهای سیستمی بزرگ در Go، بدون شک، نیاز به ماژولارسازی کد خود دارند. ما برای دستیابی به ماژولارسازی کد، از طراحی‌های متعدد out-of-process، مانند OS exec calls، سوکت و RPC/gRPC (و غیره) استفاده کرده‌ایم. این روش‌ها ممکن است به خوبی کار کنند، اما در بسیاری از زمینه‌ها به‌عنوان پایانه‌ای برای پردازش با قبل نبود یک سیستم پلاگین‌ای ناتیو در Go بکار رفته‌اند.\nدر این بخش از کتاب، من بررسی می‌کنم که ایجاد نرم‌افزار ماژولار با استفاده از سیستم پلاگین‌های Go (plugin) چه تبعاتی دارد.\nاز نسخه 1.8، plugin فقط در لینوکس کار می‌کند. با توجه به سطح علاقمندی به این ویژگی، این احتمالا در نسخه‌های آینده تغییر خواهد کرد. 4.22.1 طراحی ماژولار با Go # ایجاد برنامه‌های ماژولار با پلاگین﻿‌های Go، نیاز به همان شیوه کار قابل اعتماد نرم‌افزاری دارد که به بسته‌های Go رایج اعمال می‌شود. با این‌حال، پلاگین‌ها نگرانی‌های طراحی جدید را با توجه به اتصالشان به دیگر اجزای برنامه، بیشتر کرده‌اند.\nدر هنگام ساخت سیستم نرم‌افزاری قابل پلاگین‌گذاری، بسیار مهم است که قابلیت‌های واضحی برای اجزای سیستم تعریف شوند. سیستم باید رابط‌های ساده و شفافی برای یکپارچه‌سازی پلاگین فراهم کند. از سوی دیگر، توسعه‌دهندگان پلاگین باید به عنوان یک جعبه سیاه برای سیستم در نظر گرفته شوند و علاوه بر قراردادهای ارائه‌شده، هیچ فرضیاتی را انجام ندهند. پلاگین باید به عنوان یک اجزای مستقل در نظر گرفته شود که از دیگر اجزا جدا شده است. این باعث می‌شود که پلاگین‌ها بتوانند دوره‌ی life cycle توسعه و استقرار خود را بدون وابستگی به مصرف‌کنندگانشان دنبال کنند. کد پلاگین باید طراحی شود تا تمرکز خود را فقط بر روی یکی از مسائل عملکردی داشته باشد و نه بیشتر از آن. از آنجایی که پلاگین‌ها اجزای مستقل‌ای هستند که در زمان اجرا بارگیری می‌شوند، مهم این است که از مستندات خوبی برخوردار باشند. به عنوان مثال، نام توابع و متغیرهای پیاده سازی باید به طور واضح مشخص شوند تا خطاهای جستجوی symbol ها را جلوگیری کنند. پلاگین‌های Go می‌توانند تابع‌های بسته و متغیرهایی از هر نوع را به‌صورت خروجی دهند. می‌توانید پلاگین‌تان را طراحی کنید تا قابلیت‌های خود را به‌صورت یک مجموعه‌ی تابع‌های آزاد گروه‌بندی کند. سردرگمی، این است که شما باید به‌صورت جداگانه هر symbol تابع را جستجو و به آن متصل شوید. راهکار بهتر این است که از انواع interface استفاده کنید. ایجاد یک interface برای صادرکردن قابلیت‌ها، یک سطح تعاملی یکنواخت و مختصر با نشانگرهای عملیاتی واضح فراهم می‌کند. جستجو و متصل کردن به‌نمادی که به یک رابط حل می‌شود، دسترسی به کل مجموعه شیوه های تابعی برای قابلیت‌ها را فراهم می‌کند، نه فقط یکی از آن‌ها. 4.22.2 کتابخانه plugin # کتابخانه plugin، یک کتابخانه خیلی ساده و آسان است و فقط یک تابع Open و یک متد Lookup دارد که به شما برای بازکردن فایل so. و استفاده ازinterface های پیاده سازی شده کمک می کند.\n1type Plugin 2\tfunc Open(path string) (*Plugin, error) 3\tfunc (p *Plugin) Lookup(symName string) (Symbol, error) 4\t5type Symbol کتابخانه plugin، یک پکیج اصلی Go با توابع و متغیرهای صادرشده است که با استفاده از دستور زیر برای کامپایل ساخته شده است:\n1$ go build -buildmode=plugin وقتی که یک plugin برای اولین بار باز می‌شود، تابع init تمام بسته‌هایی که هنوز قسمت برنامه نیستند فراخوانی می‌شوند. تابع اصلی اجرا نمی‌شود. یک plugin تنها یکبار مقداردهی اولیه می‌شود و نمی‌تواند بسته شود.\n4.22.3 پیاده سازی قدم به قدم یک برنامه ماژولار با plugin # فرض کنید قصد یک پروژه بنویسیم که hello world را به زبان های مختلف در خروجی terminal چاپ کنیم.\n4.22.3.1 نمونه ساختار پروژه # در ابتدا نیاز داریم یک پروژه با ساختار زیر پیاده سازی کنیم:\n1├── [ 22] go.mod 2├── [ 779] main.go 3└── [ 224] plugin 4 ├── [ 240] en 5 │ └── [ 152] en.go 6 └── [ 240] fa 7 ├── [ 155] fa.go 4.22.3.2 نوشتن پلاگین # در ابتدا یک دایرکتوری plugin ایجاد کنید سپس براساس زبان مورد نظر خود یک یا چند sub directory ایجاد کنید.\nحال برای زبان فارسی و انگلیسی از کد زیر استفاده کنید:\nEnglish\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type hello string 6 7func (h hello) Hello() { 8fmt.Println(\u0026#34;Hello 🌎\u0026#34;) 9} 10 11// Hello exported as symbol named 12var Hello hello Persian\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type hello string 6 7func (h hello) Hello() { 8fmt.Println(\u0026#34;سلام 🌎\u0026#34;) 9} 10 11// Hello exported as symbol named 12var Hello hello در کد فوق ما به ازای هر زبان یک فایل go ایجاد کردیم که با پکیج main شروع می شود و داخلش یک type مشخص قرار دادیم و متد Hello را پیاده سازی کردیم. سپس یک متغییر با نام Hello تعریف کردیم تا به عنوان symbol برای پلاگین در دسترس باشد.\nاگر package شما نام دیگری غیر از main باشد با خطا مواجه خواهید شد به دلیل build شدن ماژول هستش.\n1-buildmode=plugin requires exactly one main package 4.22.3.3 بیلد پلاگین ها # برای بیلد گرفتن پلاگین ها باید از دستورات زیر استفاده کنید:\n1go build -buildmode=plugin -o plugin/en/en.so plugin/en/en.go 2 3 go build -buildmode=plugin -o plugin/fa/fa.so plugin/fa/fa.go زمانیکه بیلد میگیرید فایل پلاگین ها در محل plugin/en یا plugin/fa با پسوند so. قرار میگیرد.\nحال با استفاده از ابزار file در لینوکس می توانید اطلاعات ماژول بیلد شده را ببینید که به عنوان dynamic shared object شناخته می شود:\n1$ file plugin/en/en.so 2plugin/en/en.so: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, BuildID[sha1]=d23f35974563f658267b158466cbb551a97fb049, with debug_info, not stripped ساختار پروژه پس از بیلد پلاگین ها\n1├── [ 22] go.mod 2├── [ 779] main.go 3└── [ 224] plugin 4 ├── [ 240] en 5 │ ├── [ 152] en.go 6 │ └── [ 3.5M] en.so 7 └── [ 240] fa 8 ├── [ 155] fa.go 9 └── [ 3.5M] fa.so 4.22.3.4 استفاده از پلاگین ها # داخل روت پروژه یک فایل main.go ایجاد کنید و کد زیر را قرار دهید.\nتوجه کنید نیاز دارید فایل های پلاگین را در هر محلی هست load کنید.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;os\u0026#34; 6\t\u0026#34;plugin\u0026#34; 7) 8 9type Greeter interface { 10\tHello() 11} 12 13func main() { 14\t// determine plugin to load 15\tlang := \u0026#34;english\u0026#34; 16\tif len(os.Args) == 2 { 17\tlang = os.Args[1] 18\t} 19\tvar mod string 20\tswitch lang { 21\tcase \u0026#34;english\u0026#34;: 22\tmod = \u0026#34;./plugin/en/en.so\u0026#34; 23\tcase \u0026#34;persian\u0026#34;: 24\tmod = \u0026#34;./plugin/fa/fa.so\u0026#34; 25\tdefault: 26\tfmt.Println(\u0026#34;don\u0026#39;t support your language\u0026#34;) 27\tos.Exit(1) 28\t} 29 30\t// load module 31\tplug, err := plugin.Open(mod) 32\tif err != nil { 33\tfmt.Println(err) 34\tos.Exit(1) 35\t} 36 37\t// lookup for symbol 38\tsymbol, err := plug.Lookup(\u0026#34;Hello\u0026#34;) 39\tif err != nil { 40\tfmt.Println(err) 41\tos.Exit(1) 42\t} 43 44\t// assert symbol with interface 45\tp, ok := symbol.(Greeter) 46\tif !ok { 47\tfmt.Println(\u0026#34;unexpected type from module symbol\u0026#34;) 48\tos.Exit(1) 49\t} 50 51\t// call interface method 52\tp.Hello() 53 54} 1$ go run main.go english 2Hello 🌎 در ابتدا یک interface به همراه متد مشابه داخل پلاگین قرار دادیم. سپس داخل main یک زبان پیش فرض را داخل متغیر lang تعیین کردیم سپس از طریق os.Args زبان از طریق os.Stdin گرفتیم و داخل lang قرار دادیم پس از آن با استفاده از switch چک کردیم براساس زبان یک پلاگین یا ماژول مشخص را داخل متغیر mod مسیر دهی کنیم. سپس تابع Open کتابخانه plugin را فراخوانی کردیم و مسیر پلاگین را قرار دادیم. حال پس از باز شدن پلاگین متد Lookup را برای پیدا کردن symbol فراخوانی کردیم که ما نام symbol را Hello گذاشتیم. پس از اینکه symbol بدون خطا load شد ما symbol را با اینترفیس Greeter گرفتیم Assert کردیم تا بتوانیم از متدهای پیاده سازی شده استفاده کنیم. 4.22.4 پروژه هایی که از plugin استفاده کرده اند # در زیر ما لیستی از پروژه های فعالی که از پلاگین استفاده کرده اند را قرار دادیم تا بتوانید برای پیاده سازی پروژه های ماژولار ایده بگیرید:\nhttps://github.com/hashicorp/go-plugin https://github.com/luraproject/lura https://github.com/smartcontractkit/chainlink-starknet https://github.com/ava-labs/blobvm https://github.com/easysoft/zentaoatf 4.22.5 کلام آخر # ماژولارنویسی یکی از مهم ترین عناوین توسعه و طراحی نرم افزار بوده که شما با اینکار می توانید پلاگین های reusable بنویسید و در هر پروژه ای بسته به نیازتان استفاده کنید. شرکت های بزرگی نظیر hashicorp برای اکثر پروژهایش نظیر terraform یا consul از این قابلیت استفاده کرده است.\n"},{"id":66,"href":"/chapter-4/oop/","title":"4.23 شی گرایی در زبان گو","section":"فصل چهارم: مباحث پیشرفته","content":"گو یک زبان statically-typed است و بطور کلی امکانات شی گرایی را به شیوه قدیم و مرسوم پشتیبانی نمی کند. اما در عوض یک شیوه قرار دادی وجود دارد که به شما کمک می کند برخی از مفاهیم شی گرایی را با کمک اینترفیس, composition, متد و type embedding پیاده سازی کنید.\nاین مفاهیم شامل :\nکپسوله سازی ارث بری پلی مورفیسم overriding abstraction "},{"id":67,"href":"/chapter-4/oop/go-encapsulation/","title":"4.23.1 کپسوله سازی (Encapsulation)","section":"4.23 شی گرایی در زبان گو","content":"کپسوله سازی در زبان گو یا هر زبان دیگری یک مفهوم مشترک می باشد که شما یک داده یک تابع را پشت یک آبجکت یا یک واحد مستقل بپوشانید. با اینکار شما جلوی دسترسی مستقیم برروی داده را میگیرید. این کار در شی گرایی کمک می کند شما کدهای خود را بهتر سازماندهی کنید و جلوی دسترسی مستقیم ناخواسته را بگیرید.\nدر زبان گو برای Public/Private کردن یک آبجکت یا تابع کلمه کلیدی به نام public/private ندارد ولی در عوض شما می توانید داخل هر پکیج با بزرگ یا کوچک کردن حرف اول نام هر آبجکت یا تابع جلو دسترسی مستقیم را بگیرید.\n1var DatabaseName string // public 2var databaseName string // private 3 4func Greeting() {} // public 5func greeting() {} // private زمانی که شما یک آبجکت یا تابع را به شیوه فوق private می کنید در واقع آن آبجکت یا تابع فقط در همان package level خود در دسترس می باشد.\nبه عنوان مثال اگر تابع greeting داخل پکیج message باشد فقط در همان جا در دسترس می باشد.\n1└── message 2 ├── data.go 3 ├── message.go 4 └── resp.go در زیر یک مثال ساده زدیم توجه کنید :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type Person struct { 6\tname string 7\tage int 8} 9 10func (p *Person) GetAge() int { 11\treturn p.age 12} 13 14func (p *Person) getName() string { 15\treturn p.name 16} 17 18func (p *Person) SetAge(age int) { 19\tp.age = age 20} 21 22func main() { 23\tperson := Person{ 24\tname: \u0026#34;Javad\u0026#34;, 25\t} 26 27\tperson.SetAge(29) 28 29\tfmt.Printf(\u0026#34;%s with age %d\u0026#34;, person.getName(), person.GetAge()) 30} 1$ go run main.go 2Javad with age 29 کد فوق ما یک ساختار (آبجکت) Person ایجاد کردیم که داخلش ۲ فیلد name, age بصورت private وجود دارد که سایر پکیج ها نمی توانند دسترسی مستقیم به فیلد های Person دسترسی داشته باشند. حال ۳ متد تعریف کردیم GetAge برای گرفتن سن شخص , SetAge برای تعیین سن شخص , getName گرفتن نام شخص که فقط داخل همان پکیج در دسترس است این متد.\n"},{"id":68,"href":"/chapter-4/oop/go-inheritance/","title":"4.22.2 ارث بری","section":"4.23 شی گرایی در زبان گو","content":"در زبان گو ارث بری در واقع type embedding هست با استفاده type embedding می توانید یک type را داخل type دیگری جاسازی کنید و به واسطه type والد قابل دسترس است.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type Person struct { 6\tName string 7} 8 9func (p *Person) Introduce() { 10\tfmt.Printf(\u0026#34;Hi, my name is %s\\n\u0026#34;, p.Name) 11} 12 13type Student struct { 14\tPerson 15\tSchool string 16} 17 18func main() { 19\ts := \u0026amp;Student{Person{\u0026#34;John Doe\u0026#34;}, \u0026#34;Go University\u0026#34;} 20\ts.Introduce() 21} 1$ go run main.go 2Hi, my name is John Doe "},{"id":69,"href":"/chapter-4/oop/go-polymorphism/","title":"4.23.3 پلی مورفیسم (Polymorphism)","section":"4.23 شی گرایی در زبان گو","content":"پلی مورفیسم یکی از مفاهیم مهم در شی گرایی می باشد و هدف استفاده از پلی مورفیسم این است بین آبجکت ها رفتار مشترکی ایجاد کنیم. در زبان گو شما می توانید یک اینترفیس تعریف کنید و برای ساختارهای مختلف متدهای اینترفیس را پیاده سازی کنید.\nبه مثال زیر توجه کنید :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5// Shape is an interface that defines a method named `Area` 6type Shape interface { 7\tArea() float64 8} 9 10// Rectangle is a struct that represents a rectangle 11type Rectangle struct { 12\twidth float64 13\theight float64 14} 15 16// Area implements the Shape interface for Rectangle 17func (r Rectangle) Area() float64 { 18\treturn r.width * r.height 19} 20 21// Circle is a struct that represents a circle 22type Circle struct { 23\tradius float64 24} 25 26// Area implements the Shape interface for Circle 27func (c Circle) Area() float64 { 28\treturn 3.14 * c.radius * c.radius 29} 30 31func CalcArea(shapes ...Shape) { 32\tfor _, shape := range shapes { 33\tfmt.Println(shape.Area()) 34\t} 35} 36 37func main() { 38\tr := Rectangle{width: 10, height: 5} 39\tc := Circle{radius: 5} 40 41\tCalcArea(r, c) 42} 1$ go run main.go 250 378.5 در کد فوق ما یک اینترفیس Shape داریم که داخلش یک متد به نام Area هست حال این متد را برای ساختارهای Rectangle و Circle پیاده سازی کردیم که مساحت دایره و مستطیل را محاسبه کنیم. حال یک تابع CalcArea داریم به عنوان پارامتر slice از Shape ها میگیرد که ما داخل تابع main ساختار Rectangle و Circle که متد Area اینترفیس Shape را پیاده سازی کرده اند را پاس دادیم و در نهایت محاسبه مساحت را در خروجی چاپ می کند.\n"},{"id":70,"href":"/chapter-4/oop/go-overriding/","title":"4.23.4 overriding","section":"4.23 شی گرایی در زبان گو","content":"در زبان گو مثل سایر زبان های شی گرا امکان overriding مستقیم یک متد وجود ندارد اما در عوض شما می توانید با استفاده از type embedding و پیاده سازی متد یک اینترفیس این تکنیک را انجام دهید و به متدی که override انجام داده Shadow Method می گویند.\nبه مثال زیر توجه کنید :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type User interface { 6\tPrintName() 7} 8 9type Person struct { 10\tName string 11} 12 13func (p Person) PrintName() { 14\tfmt.Println(\u0026#34;My name is\u0026#34;, p.Name) 15} 16 17type Student struct { 18\tPerson 19} 20 21func (s Student) PrintName() { 22\tfmt.Println(\u0026#34;I am a student and my name is\u0026#34;, s.Name) 23} 24 25func main() { 26\tp := Person{Name: \u0026#34;John\u0026#34;} 27\ts := Student{Person{Name: \u0026#34;Jane\u0026#34;}} 28 29\tp.PrintName() 30\ts.PrintName() 31} 1$ go run main.go 2My name is John 3I am a student and my name is Jane در کد فوق ما یک اینترفیس User داریم که داخلش یک متد PrintName وجود دارد که این متد نام شخص یا دانش آموز را به همراه توضیحات چاپ می کند. حال ۲ تا ساختار داریم Person و Student که ساختار Setudent فقط Person را جاسازی کرده است. سپس برای این ۲ ساختار متد PrintName را پیاده سازی کردیم با این تفاوت که داخل متد PrintName ساختار Student متن دیگری قرار دادیم. در تابع main ما متغیر p, s را از نوع Person و Student ایجاد و مقدار دهی کردیم. سپس متد PrintName هر دو را فراخوانی کردیم.\n"},{"id":71,"href":"/chapter-4/oop/go-abstraction/","title":"4.23.5 abstraction","section":"4.23 شی گرایی در زبان گو","content":"Abstraction (به معنای انتزاع)، فرآیند حذف یا از بین بردن برخی ویژگی‌های غیرضروری یک چیز به‌منظور کاهش، خلاصه‌سازی و به کار بردن آن در مجموعه‌ای از ویژگی‌های ضروری است. در برنامه‌نویسی شیءگرا(OOP)، انتزاع یکی از سه مفهوم اصلی (به همراه مفاهیم Encapsulation و Inheritance) است.\nبه نقل از ویکی پدیا : انتزاع،[۱] (به انگلیسی: Abstraction) تجرید یا آهنجش فرایند اختصار، فشرده‌سازی، و تلخیص اطّلاعات از طریق شناسائی، استخراج و سپس، جداسازی و پنهان‌سازی جزئیّات[۲] از کلیّات[۳] است. انتزاع در لغت به معنای جدا کردن، گرفتن، درآوردن جزئی از یک کل[۴] و به معنای بازداشتن و امتناع کردن، برکندن و از جای کشیدن، گرفتن، و دور شدن می‌باشد.[۵]\nانتزاع فرایند یا نتیجهٔ تعمیم بخشیدن با کاهش محتوای اطلاعاتی یک مفهوم یا یک پدیدهٔ قابل مشاهده، جهت حفظ اطلاعات برای منظور خاص می‌باشد.\nدر زبان گو abstraction با استفاده از اینترفیس می توان انجام داد. یک اینترفیس یکسری متد دارد که ما این متدها را برای هریک از تایپ های مختلف پیاده سازی می کنیم.\nبه مثال زیر توجه کنید :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5// Shape is an interface that defines the basic methods for a shape. 6type Shape interface { 7\tArea() float64 8\tPerimeter() float64 9} 10 11// Rectangle is a struct that implements the Shape interface. 12type Rectangle struct { 13\twidth, height float64 14} 15 16// Area returns the area of the rectangle. 17func (r Rectangle) Area() float64 { 18\treturn r.width * r.height 19} 20 21// Perimeter returns the perimeter of the rectangle. 22func (r Rectangle) Perimeter() float64 { 23\treturn 2 * (r.width + r.height) 24} 25 26// Circle is a struct that implements the Shape interface. 27type Circle struct { 28\tradius float64 29} 30 31// Area returns the area of the circle. 32func (c Circle) Area() float64 { 33\treturn 3.14 * c.radius * c.radius 34} 35 36// Perimeter returns the perimeter of the circle. 37func (c Circle) Perimeter() float64 { 38\treturn 2 * 3.14 * c.radius 39} 40 41func main() { 42\t// Create a rectangle and a circle. 43\tr := Rectangle{width: 10, height: 20} 44\tc := Circle{radius: 5} 45 46\t// Declare a slice of Shape interfaces. 47\tshapes := []Shape{r, c} 48 49\t// Iterate over the shapes and print their area and perimeter. 50\tfor _, shape := range shapes { 51\tfmt.Println(\u0026#34;Area:\u0026#34;, shape.Area()) 52\tfmt.Println(\u0026#34;Perimeter:\u0026#34;, shape.Perimeter()) 53\tfmt.Println(\u0026#34;\u0026#34;) 54\t} 55} 1$ go run main.go 2Area: 200 3Perimeter: 60 4 5Area: 78.5 6Perimeter: 31.400000000000002 در کد فوق ما یک اینترفیس Shape داریم که ۲ تا متد Area و Perimeter داریم که مساحت و محیط را محاسبه می کند. در ادامه ۲ ساختار Rectangle و Circle داریم که برای این ساختارها متدهای اینترفیس Shape را پیاده سازی کردیم و در نهایت اندازه مساحت و محیط را محاسبه می کنیم.\n"},{"id":72,"href":"/chapter-5/","title":"فصل پنجم: برنامه نویسی شبکه با گو","section":"صفحه اصلی","content":"در این فصل به مباحث برنامه نویسی شبکه در زبان گو میپردازیم\u0026hellip;\n"},{"id":73,"href":"/chapter-5/network-basic/","title":"5.1 شبکه چیست","section":"فصل پنجم: برنامه نویسی شبکه با گو","content":"یک شبکه یک سیستم ارتباطی برای اتصال سیستم‌های پایانی به نام هاست‌ها است. مکانیزم‌های اتصال ممکن است از طریق سیم مسی، اترنت، فیبر نوری یا بی‌سیم باشد اما این موضوع به ما مربوط نمی‌شود. یک شبکه محلی (LAN) کامپیوترهایی را که در نزدیکی یکدیگر هستند، معمولاً تعلق به یک خانه، سازمان کوچک یا قسمتی از یک سازمان بزرگ دارند، به هم متصل می‌کند.\nیک شبکه گسترده (WAN) کامپیوترها را در یک منطقه فیزیکی بزرگتر، مانند بین شهرها متصل می‌کند. انواع دیگری هم وجود دارند، مانند MANs (شبکه‌های منطقه شهری)، PANs (شبکه‌های منطقه شخصی) و حتی BANs (شبکه‌های منطقه بدن).\nاینترنت اتصال دو یا بیشتر از شبکه‌های متمایز است، معمولاً LANs یا WANs. یک اینترانت، یک اینترنت با تمام شبکه‌ها که تعلق به یک سازمان واحد دارند، است.\nتفاوت‌های قابل توجهی بین یک اینترنت و یک اینترانت وجود دارد. معمولاً، یک اینترانت تحت کنترل مدیریت واحد قرار خواهد گرفت و یک مجموعه یکپارچه از سیاست‌ها را اعمال خواهد کرد. از طرفی، یک اینترنت تحت کنترل یک بدنه یکپارچه نخواهد بود و کنترل‌های انجام شده بر روی بخش‌های مختلف حتی سازگاری نخواهد داشت.\nیک مثال ساده از این تفاوت‌ها این است که یک اینترانت معمولاً به کامپیوترهایی محدود خواهد شد که توسط تعداد کمی از فروشندگان اجرایی یک نسخه استاندارد یک سیستم عامل خاص اجرا می‌شود. از طرفی، یک اینترنت معمولاً دارای مجموعه‌ای از کامپیوترها و سیستم‌های عامل مختلف خواهد بود.\nتکنیک‌های این کتاب برای اینترنت‌ها قابل اعمال هستند. آن‌ها همچنین برای اینترانت‌ها معتبر هستند، اما در آنجا شما نیز سیستم‌های تخصصی غیرقابل حمل وجود دارد.\nهمچنین، \u0026ldquo;مادر\u0026rdquo; تمام اینترنت‌ها وجود دارد: اینترنت. این فقط یک اینترنت بسیار بزرگ است که ما را با گوگل، کامپیوتر من با کامپیوتر شما و غیره متصل می‌کند.\n5.1.1 چند تعریف و مفهوم کلی در شبکه # 5.1.1.1 پروتکل # پروتکل های شبکه مجموعه قواعد و روش هایی از پیش تعریف شده برای ارتباط دو کامپیوتر در یک شبکه هستند\n5.1.1.2 هسته (node) # هر دستگاه متصل به شبکه که توانایی ارسال و دریافت داده را بستر شبکه داشته باشد یک هسته به حساب می آید\n5.1.1.3 پروتکل اینترنت IP # پروتکل اینترنت یا (internet protocol) یک ادرس منحصر بفرد برای هر دستگاه متصل به اینترنت است هر ایپی (v4) شامل چهار بخش یا octet است که هر بخش را عددی بین ۰ تا ۲۵۵ تشکیل می دهد\n5.1.1.3.1 ایپی ورژن ۶ # زمان شروع و توسعه پروتکل اینترنت هر دستگاه در شبکه نیاز به یک شناسه منحصر به فرد داشت. ایپی ورژن ۴ تنها قابلیت ایجاد 4 بیلیون شناسه یونیک را داشتند (که بنظر برای تمام دستگاه های موجود کافی و مناسب بود) بعد از رشد چشم گیر اینترنت و دستگاه های متصل به اینترنت تعداد IP موجود حدودا کافی نبود ایپی ورژن ۶ جدید ترین نسخه ایپی است که شمال 8 octet است و از hexadecimal استفاده میکند. در نتیجه حدود 340 undecillion ایپی ورژن ۶ منحصر به فرد میتوان تولید کرد که برای عدد قابل توجهی دستگاه متصل به شبکه کافی است. مثال ایپی ورژن ۶: ‍‍2001:0db8:85a3:0000:0000:8a2e:0370:7334\n5.1.1.3.2 تفاوت ها # تفاوت های IPv4 and IPv6\nحافظه:\nورژن ۴: ‍‍32bit ورژن ۶:‍‍ ‍‍128bit نوع ایپی:\nورژن ۴ : ‍‍numeric dot-decimal ورژن ۶ : alphanumeric hexadecimal در نهایت گفتنی است که ورژن ۶ ایپی با استفاده از موارد امنیتی از جمله رمزنگاری و احراز هویت امنیت این پروتوکول را گسترش داده است.\n5.1.2 لایه های پروتکل # سیستم‌های توزیع شده دشوار هستند. چندین کامپیوتر درگیر هستند که باید به یکدیگر متصل شوند. برنامه‌ها برای اجرا بر روی هر کامپیوتر در سیستم باید نوشته شوند و همه باید با همکاری یک وظیفه توزیع شده را انجام دهند. روش رایج برای مقابله با پیچیدگی، تجزیه آن به بخش‌های کوچکتر و ساده‌تر است. این بخش‌ها ساختار خود را دارند، اما همچنین وسایل مشخصی برای ارتباط با بخش‌های مرتبط دیگر دارند. در سیستم‌های توزیع شده، بخش‌ها لایه پروتکل نامیده می‌شوند و وظایف دقیقی دارند. آن‌ها یک پشته را تشکیل می‌دهند، هر لایه با لایه بالایی و پایینی خود ارتباط برقرار می‌کند. ارتباط بین لایه‌ها توسط پروتکل‌ها تعریف می‌شود. ارتباطات شبکه نیازمند پروتکل‌هایی برای پوشش ارتباطات بالارونده بین برنامه‌های کاربردی تا ارتباطات سیم و پیچیدگی‌های پروتکلی در لایه‌های پروتکلی است.\n5.1.2.1 پروتکل ISO OSI # اگرچه هرگز به درستی پیاده‌سازی نشده است، پروتکل‌های OSI (اتصالات باز سیستم‌ها) تأثیر بزرگی در روش‌های گفتگو و طراحی سیستم‌های توزیع شده داشته‌اند. معمولاً آن‌ها به شکلی نشان داده می‌شوند که در شکل زیر نشان داده شده است.\nوظیفه هر لایه از پایین به بالا به شرح زیر است:\nلایه فیزیکی با استفاده از فناوری‌های الکتریکی، نوری یا رادیویی جریان بیت را منتقل می‌کند. لایه اتصال داده‌ها، بسته‌های اطلاعاتی را به فریم‌های شبکه تبدیل کرده و آن‌ها را برای انتقال از طریق لایه فیزیکی و بازگشت به بسته‌های اطلاعاتی آماده می‌کند. لایه شبکه فناوری‌های سوئیچینگ و روتینگ را فراهم می‌کند. لایه حمل و نقل انتقال شفاف داده بین سیستم‌های پایانی را فراهم می‌کند و مسئول بازیابی خطا در سراسر انتها به انتها و کنترل پایین است. لایه جلسه، ارتباطات بین برنامه‌ها را برقرار، مدیریت و پایان می‌دهد. لایه ارائه، استقلال را از تفاوت‌های در نمایش داده‌ها (مانند رمزگذاری) فراهم می‌کند. لایه برنامه، پردازش‌های برنامه و کاربران پایانی را پشتیبانی می‌کند. یک لایه در مدل OSI معمولاً با یک پروتکل مدرن نقش مشابهی دارد؛ به عنوان مثال، پروتکل IP از TCP/IP با لایه شبکه، همچنین شناخته شده به عنوان لایه 3 (لایه فیزیکی لایه 1) مرتبط است. لایه برنامه، یعنی لایه 7، با HTTP مرتبط است. برخی از پروتکل‌ها مانند HTTPS به نظر می‌رسد لایه‌ها را با هم تلفیق می‌کنند، 5 (جلسه) و 6 (ارائه). هیچ مدلی کامل نیست؛ جایگزین‌هایی برای مدل OSI وجود دارد که به واقعیت مشخصی نزدیکتر هستند، مانند مدل پروتکل TCP/IP.\n5.1.2.2 پروتکل TCP/IP # در حالی که مدل OSI در حال بحث و جدل، پیاده‌سازی جزئی، و جنگیدن بود، پروژه تحقیقاتی DARPA در اینترنت مشغول ساخت پروتکل‌های TCP/IP بود. این پروتکل‌ها بسیار موفق بوده و منجر به ایجاد اینترنت (با حروف بزرگ) شده است. این پشته بسیار ساده‌تر است، همانطور که در شکل زیر نشان داده شده است.\n5.1.2.3 پروتکل http # پروتکل http یکی از پرکابردترین و در دسترس ترین پروتکل های دنیا است. تا حدی که شما با یک کلیک و باز کردن مروگر خود به آن درسترسی دارید.\nHttp مخفف عبارت Hyper Text Transfer Protocol است که به معنی پروتکلی برای انتقال ابرمتن‌ها می‌باشد\nاین پروتکل به منظور ایجاد صفحات وب انتقال ابر متن ها توسط تیم برنزلی طراحی و پیاده سازی شد.\nپروتکل Http از Handshaking به منظور ارسال و دریافت اطلاعات استفاده می‌کند. در این روش برای شروع و پایان عملیات تبادل اطلاعات بین سرور و کاربر چندین درخواست و پاسخ جابه جا میشود.\n5.1.3 دروازه (Gateways) # یک دروازه (Gateway) یک عبارت کلی برای یک جسم است که برای اتصال دو یا چند شبکه استفاده می‌شود. یک تکرار کننده (Repeater) در سطح فیزیکی عمل کرده و اطلاعات را از یک زیرشبکه به دیگری کپی می‌کند. یک پل (Bridge) در سطح لایه داده‌ای عمل می‌کند و فریم‌ها را بین شبکه‌ها کپی می‌کند. یک مسیریاب (Router) در سطح شبکه عمل می‌کند و نه تنها اطلاعات را بین شبکه‌ها منتقل می‌کند، بلکه بر روی مسیر تصمیم می‌گیرد.\nدروازه یک نقطه واسط برای ارتباط بین دو شبکه است و معمولاً دروازه‌ها برای ارتباط بین شبکه‌های مختلفی با ساختار‌های مختلف استفاده می‌شوند. تکرار کننده اطلاعات را در سطح فیزیکی از یک شبکه به شبکه دیگر منتقل می‌کند. پل از طریق بررسی آدرس MAC در هر فریم، فریم‌ها را بین شبکه‌های مختلف انتقال می‌دهد. مسیریاب به عنوان یک دروازه هوشمند عمل می‌کند و برای انتقال بسته‌های داده بین شبکه‌های مختلف از پروتکل‌های مسیریابی مانند RIP، OSPF و BGP استفاده می‌کند. همچنین، مسیریاب‌ها مسیر بهینه برای انتقال بسته‌های داده را انتخاب می‌کنند و مسیریابی برای کنترل ترافیک شبکه مورد استفاده قرار می‌گیرد.\n5.1.4 Host-Level Networking # در شبکه مبتنی بر یک میزبان، ما دارای نگرانی‌های اضافی هستیم که در طراحی، اشکال زدایی و پیاده‌سازی نرم‌افزار مبتنی بر شبکه مورد استفاده قرار می‌گیرند. برخی از این موارد عبارتند از:\nDNS (نظام نام دامنه، به عنوان نام‌گذاری سازگار با انسان) Firewalls (مانند مسدود کردن ترافیک ورودی یا خروجی) Routing (به عنوان مثال، فهمیدن کدام شبکه برای قرار دادن یک بسته مناسب است) مدیریت هویت میزبان (به عنوان مثال، آدرس IP) کنترل عملکرد (به عنوان مثال، شکل دهی و یا تلاش مجدد برای ترافیک) مسائل اتصال (به عنوان مثال، عدم وجود آداپتور شبکه، ارتباطات داخلی پردازش درون‌ساختمانی) در کل، طراحی، پیاده‌سازی و مدیریت شبکه در سطح میزبان به دلیل وجود این نگرانی‌های اضافی، بسیار پیچیده تر از طراحی، پیاده‌سازی و مدیریت شبکه در سطح شبکه به شمار می‌آید.\n5.1.5 کپسوله سازی Packet # در هرکدام از مدل OSI یا TCP/IP، ارتباط بین لایه‌ها با ارسال بسته‌های داده از یک لایه به لایه بعدی و در نهایت از طریق شبکه انجام می‌شود. هر لایه اطلاعات مدیریتی دارد که باید درباره لایه خود نگه داشته شود. برای این کار، هر لایه با اضافه کردن اطلاعات هدر به بسته‌ای که از لایه بالایی دریافت می‌کند، همانند یک لایه زیر، بسته را به لایه بعدی منتقل می‌کند. در سمت دریافت کننده، هدرهای این بسته‌ها با حرکت بسته به سمت لایه بالاتر حذف می‌شوند.\nبه عنوان مثال، پروتکل انتقال پرونده‌های ساده (TFTP) فایل‌ها را از یک کامپیوتر به کامپیوتر دیگری منتقل می‌کند. این پروتکل از پروتکل UDP روی پروتکل IP استفاده می‌کند که ممکن است از طریق اترنت ارسال شود. این به صورتی است که در شکل زیر نشان داده شده است.\n5.1.6 مدل های ارتباط # برای دو کامپیوتر برای ارتباط با یکدیگر، آن‌ها باید یک مسیر راه‌اندازی کنند که امکان ارسال حداقل یک پیام در یک جلسه را برای آن‌ها فراهم کند. دو مدل اصلی برای این کار وجود دارد:\n5.1.6.1 مدل مبتنی بر اتصال (Connection Oriented) # در این مدل، ابتدا یک اتصال بین دو کامپیوتر برقرار می‌شود و سپس داده‌ها در قالب یک جلسه انتقال می‌یابند. این مدل برای انتقال داده‌هایی که نیاز به اطمینان بالا و کیفیت خدمات دارند مفید است، به عنوان مثال، ارسال فایل‌های بزرگ، ارتباطات صوتی و تصویری، اتصال به اینترنت و غیره. پروتکل TCP مثالی از یک مدل مبتنی بر اتصال است.\n5.1.6.2 مدل بدون اتصال (Connectionless) # در این مدل، هیچ اتصالی بین دو کامپیوتر برقرار نمی‌شود و هر بسته به صورت مستقل از دیگر بسته‌ها ارسال می‌شود. این مدل برای انتقال داده‌هایی که نیاز به سرعت بالا و حجم کمتری از اطلاعات دارند مفید است، به عنوان مثال، ارسال پیام‌های کوتاه، سرور های بازی، درخواست اطلاعات از یک سرور و غیره. پروتکل UDP مثالی از یک مدل بدون اتصال است.\n5.1.7 مدل های ارتباطات # در یک سیستم توزیع‌شده، بسیاری از اجزا (یعنی فرآیندها) در حال اجرا هستند که باید با یکدیگر ارتباط برقرار کنند. دو مدل اصلی برای این کار وجود دارند: ارسال پیام و فراخوانی رویه‌های از راه دور (Remote Procedure Call).\nدر زمینه شبکه‌ها، این مدل‌ها اجازه ارتباط بین فرآیندها (و/یا رشته‌ها) با هدف فراخوانی رفتار روی فرآیند از راه دور را می‌دهند.\nدر مدل ارسال پیام، فرآیندها با یکدیگر به صورت غیرمستقیم و از طریق ارسال پیام‌هایی که شامل داده‌های خاصی هستند، ارتباط برقرار می‌کنند. این پیام‌ها ممکن است برای انتقال داده‌ها، درخواست خدمات، یا هر نوع ارتباطی بین فرآیندها استفاده شوند. این مدل برای سیستم‌هایی که ارتباطات غیرهمزمان، توزیع شده و یا برای ارتباطاتی که نیاز به پیچیدگی بیشتری دارند، مفید است.\nدر مدل فراخوانی رویه‌های از راه دور، فرآیند فراخواننده یک رویه محلی را فراخوانی می‌کند که در فرآیند دیگری اجرا می‌شود. در این مدل، فرآیند فراخواننده به عنوان مشتری عمل می‌کند و فرآیند دیگر به عنوان سرور. درخواست‌های مشتری به صورت پیام‌هایی به سرور فرستاده می‌شود و سرور درخواست‌ها را پردازش می‌کند و نتیجه را به مشتری می‌فرستد. این مدل برای سیستم‌هایی که نیاز به ارتباطات همزمان و یا درخواست‌هایی که نیاز به پردازش پیچیده دارند، مفید است.\n5.1.7.1 Message Passing # بعضی زبان‌ها بر اساس اصل ارسال پیام ساخته شده‌اند. زبان‌ها و ابزارهای همزمان از این مکانیزم استفاده می‌کنند و مثال شناخته شده‌ترین آن ممکن است خط لوله UNIX باشد. خط لوله UNIX یک خط لوله از بایت‌هاست، اما این یک محدودیت ذاتی نیست: PowerShell شرکت مایکروسافت می‌تواند اشیاء را از طریق خطوط لوله خود ارسال کند و زبان‌های همزمان مانند Parlog می‌توانند ساختارهای داده منطقی دلخواه را در پیام‌های بین فرآیندهای همزمان ارسال کنند. زبان‌های جدید مانند Go دارای مکانیزم‌هایی برای ارسال پیام (بین تردها) هستند.\nارسال پیام یک مکانیزم اولیه برای سیستم‌های توزیع‌شده است. یک اتصال راه‌اندازی کرده و برخی از داده‌ها را از آن پمپ کنید. در سمت دیگر، پیام را تشخیص دهید و به آن پاسخ دهید، با احتمال ارسال پیام‌های بازگشتی. این در شکل زیر نشان داده شده است.\nسیستم‌های مبتنی بر رویداد نیز به همین شکل عمل می‌کنند. در سطح پایین، زبان برنامه‌نویسی Node.js یک حلقه رویداد اجرا می‌کند که منتظر رویدادهای ورود/خروج است، برای این رویدادها شیء‌های اجرایی را فراخوانی کرده و به آن‌ها پاسخ می‌دهد. در سطح بالاتر، اکثر سیستم‌های رابط کاربری از یک حلقه رویداد برای انتظار ورودی کاربر استفاده می‌کنند، در حالی که در دنیای شبکه، Ajax از XMLHttpRequest برای ارسال و دریافت درخواست‌ها استفاده می‌کند.\n5.1.7.2 Remote Procedure Call # در هر سیستمی، انتقال اطلاعات و کنترل کم از یک بخش از سیستم به بخش دیگری اتفاق می‌افتد. در زبان‌های رویه‌ای، این ممکن است شامل فراخوانی رویه باشد، که در آن اطلاعات بر روی یک پشته فراخوانی قرار داده می‌شود و سپس کنترل به بخش دیگری از برنامه منتقل می‌شود. حتی با فراخوانی رویه، تفاوت‌هایی وجود دارد. کد ممکن است به طور استاتیک متصل شود تا کنترل از قسمتی از کد اجرایی برنامه به بخش دیگری از آن منتقل شود. به دلیل استفاده روزافزون از روتین‌های کتابخانه، معمول شده است کد را در شیء‌های به اشتراک گذاشته شده (.so) یا کتابخانه‌های پیوندی پویای (.dll) داشته باشیم، که کنترل به یک قطعه کد مستقل منتقل می‌شود.\nکتابخانه‌ها در همان ماشینی که کد فراخواننده در آن اجرا می‌شود، اجرا می‌شوند. این یک مرحله ساده (مفهومی) برای انتقال کنترل به یک رویه اجرا شده در ماشین دیگر (یعنی کتابخانه از راه دور) است. اما مکانیک این کار به این سادگی نیست! با این حال، این مدل کنترل باعث بروز فراخوانی رویه از راه دور (RPC) شده است که در یک فصل بعدی به طور جزئیات بیشتری بحث می‌شود. این در شکل زیر نشان داده شده است.\nهمانطور که گفته شد، بسیاری از مثال‌هایی که وجود دارد، بر اساس زبان‌های برنامه‌نویسی خاصی مانند بسته rpc Go یا سیستم‌های RPC پوشش دهی چندین زبان مانند SOAP و gRPC شرکت گوگل است.\nممکن است مبهم باشد که چگونه ارسال پیام و RPC از هم متفاوت هستند. در یک سطح، هردو با فراخوانی رفتار \u0026ldquo;جای دیگری\u0026rdquo; مرتبط هستند. به طور کلی، RPC در مقایسه با ارسال پیام کمتر انتزاعی است (یعنی به نظر می‌رسد و به احساس فراخوانی روتین‌های معمولی شبیه است)، در حالی که در ارسال پیام ممکن است به سیستم صف‌های از راه دور فراخوانی شده باشیم. با این حال، در پشت صحنه، RPC نیز پیام‌ها را ارسال می‌کند.\n5.1.7.3 مدل محاسبات توزیع شده (Distributed Computing) # در سطح بالاتر، می‌توانیم معادل بودن یا عدم معادل بودن اجزای یک سیستم توزیع شده را مورد بررسی قرار دهیم. شاید رایج‌ترین حالت یک حالت نامتقارن باشد: یک مشتری درخواست‌های خود را به یک سرور ارسال می‌کند و سرور پاسخ می‌دهد. این یک سیستم client-server است.\nاگر هر دو اجزای سیستم معادل باشند، قادر به شروع کردن و پاسخ دادن به پیام‌ها باشند، آنگاه یک سیستم همتا به همتا داریم. توجه کنید که این یک طبقه‌بندی منطقی است: یک همتا ممکن است یک ابرکامپیوتر با ۱۶۰۰۰ هسته باشد؛ دیگری ممکن است یک تلفن همراه باشد. اما اگر هر دو می‌توانند به طور مشابه عمل کنند، آنگاه آن‌ها همتای یکدیگر هستند.\nدر مثال سیستم client-server، مرورگری که با یک سرور وب صحبت می‌کند، یک مثال است. مثالی از یک سیستم همتا به همتا، سیستم پایگاه داده است که داده‌ها در آن تکثیر می‌شوند و در هر دو همتا در دسترس هستند.\nترکیب این سیستم‌ها باعث بوجود آمدن معماری‌های چند لایه می‌شود، که یکی از رایج‌ترین آن‌ها سه لایه است (یعنی ارائه -\u0026gt; برنامه -\u0026gt; داده یا مرورگر -\u0026gt; سرور وب -\u0026gt; پایگاه داده).\n5.1.7.3.1 سیستم client-server # به عکس زیر توجه کنید:\nدر سیستم فوق ممکن است توسط یک توسعه‌دهنده که نیاز به شناخت اجزای یک سیستم دارد، داشته باشد. همچنین، کاربری که از یک مرورگر استفاده می‌کند، می‌داند که مرورگر در سیستمش اجرا می‌شود، اما با سرورهای دیگری در جای دیگری ارتباط برقرار می‌کند.\nنمودار قبلی شبیه به مدل OSI است که در ابتدای کتاب بحث شد. لایه‌های موجود در شکل فوق نیز اختیاری هستند؛ به عنوان مثال، می‌توانیم هم مشتری و هم سرور را روی یک پاره‌ای از سخت افزار نصب کنیم. قرار گرفتن روی همان ماشین به این معنی است که ما می‌توانیم برخی از لایه‌های مدل OSI را از جمله لایه ۱ (فیزیکی)، لایه ۲ (پیوند داده) و لایه ۳ (شبکه) را حذف کنیم. ما می‌گوییم \u0026ldquo;احتمالا\u0026rdquo;، زیرا این لایه‌ها هنوز ممکن است برای دلایل مختلفی از جمله همگنی ابزارها یا امنیت، مورد نیاز باشند.\n5.1.7.3.2 اپلیکیشن Client-Server # برخی از برنامه‌ها ممکن است به طور شفاف توزیع شده باشند، به طوری که کاربر نمی‌داند که آن توزیع شده است. کاربران دید خود را از سیستم خود مشاهده می‌کنند، همانطور که در شکل زیر نشان داده شده است.\nبرای عملکرد، هر دو اجزا باید نصب شده باشند. چقدر پیچیدگی برنامه باید شفاف باشد، به برنامه و استفاده آن بستگی دارد.\n5.1.7.3.3 سرور توزیع شده # یک سیستم client-server نیازمند پیچیدگی نیست. مدل ابتدایی، یک سیستم مشتری-سرور تکی است که در شکل زیر نشان داده شده است.\nاما می‌توانید چندین مشتری و یک سرور داشته باشید، همانطور که در شکل زیر نشان داده شده است.\nدر این سیستم، مستر درخواست‌ها را دریافت کرده و به جای اینکه خودش آن‌ها را یکی یکی پردازش کند، آن‌ها را به سرورهای دیگر برای پردازش ارسال می‌کند. این یک مدل رایج است زمانی که مشتریان همزمان ممکن است وجود داشته باشند.\nهمچنین، می‌توانید یک مشتری و چندین سرور داشته باشید، همانطور که در شکل زیر نشان داده شده است.\nاین نوع سیستم بسیار رایج است زمانی که یک سرور باید به عنوان مشتری به سرورهای دیگر عمل کند، مانند یک سرور منطق تجاری که اطلاعات را از سرور پایگاه داده دریافت می‌کند. و البته، می‌تواند چندین مشتری با چندین سرور باشد.\nدوباره، این اجزا ممکن است روی یک سخت‌افزار فیزیکی قرار نگرفته باشند.\n"},{"id":74,"href":"/chapter-5/go-tcp-server-begginer/","title":"5.2 سرور tcp مقدماتی","section":"فصل پنجم: برنامه نویسی شبکه با گو","content":"ما میتوانیم در گو با استفاده از کتابخانه net یک سرور tcp ایجاد کنیم بعد از تکمیل شدن سرور با استفاده از دستور telnet به آن متصل میشویم\nدر قطعه کد زیر با تابع acceptLoop() درخواست های اتصال را مپذیریم و با تابع readLoop() پیام های اتصال را میخوانیم\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;log\u0026#34; 6\t\u0026#34;net\u0026#34; 7) 8 9// ساختار هر پیام در سرور 10type Message struct { 11\t// ادرس ip ارسال کننده پیام 12\tfrom string 13\t// متن و محتوای پیام 14\tpayload []byte 15} 16 17// ساختار سرور 18type Server struct { 19\t// ادرس و یا پورت سرور 20\tlistenAddr string 21\t// listener 22\tln net.Listener 23\t// چنل پیام برای انتقال پیام های دریافتی از اتصال ها بین گوروتین ها 24\tmsgch chan Message 25} 26 27// ایجاد یک سرور جدید 28func newServer(listenAddr string) *Server { 29\treturn \u0026amp;Server{ 30\tlistenAddr: listenAddr, 31\tmsgch: make(chan Message, 10), 32\t} 33} 34 35// شروع سرور و دریافت اتصال های جدید 36func (s *Server) start() error { 37\t// شروع سرور 38\tln, err := net.Listen(\u0026#34;tcp\u0026#34;, s.listenAddr) 39\tif err != nil { 40\treturn err 41\t} 42\tdefer ln.Close() 43\t// مقدار دهی listener 44\ts.ln = ln 45\t// با تابع acceptLoop اتصال های جدید به سرور را مدیریت میکنیم 46\t// با استفاده از go هر اتصال را روی یک گوروتین مجزا مدیریت میکنیم 47\tgo s.acceptLoop() 48 49\treturn nil 50} 51 52func (s *Server) acceptLoop() { 53\tfor { 54\t// اتصال های موجود را تایید میکنیم متغییر conn را با اتصال مورد نظر مقدار دهی میکنیم 55\tconn, err := s.ln.Accept() 56\tif err != nil { 57\tfmt.Println(\u0026#34;accept error:\u0026#34;, err) 58\tcontinue 59\t} 60\t// با استفاده از این تابع مقادیر ارسال شده توسط اتصال را به چنل message میدهیم 61\tgo s.readLoop(conn) 62\t} 63} 64 65func (s *Server) readLoop(conn net.Conn) { 66\tdefer conn.Close() 67\tbuf := make([]byte, 2048) 68 69\tfor { 70\t// پیام ارسال شده توسط هر اتصال را به متغییر buf میدهیم 71\tn, err := conn.Read(buf) 72\tif err != nil { 73\tfmt.Println(\u0026#34;read error:\u0026#34;, err) 74\tcontinue 75\t} 76 77\ts.msgch \u0026lt;- Message{ 78\t// ادرس ip ارسال کننده پیام از نوع net.IP 79\tfrom: conn.RemoteAddr().String(), 80\t// متن پیام 81\tpayload: buf[:n], 82\t} 83 84\t// بعد از دریافت هر پیام یک پیام به عنوان پاسخ ارسال میکنیم 85\tconn.Write([]byte(\u0026#34;your message recived!\\n\u0026#34;)) 86\t} 87} 88 89func main() { 90\t// ساخت سرور 91\tserver := newServer(\u0026#34;:3000\u0026#34;) 92 93\tgo func() { 94\t// در ازای هر پیام مقادیر آن را چاپ میکنیم 95\tfor msg := range server.msgch { 96\tfmt.Printf(\u0026#34;recived new from connection(%s): %s\\n\u0026#34;, msg.from, msg.payload) 97\t} 98\t}() 99\t100\t// شروع سرور 101\tlog.Fatal(server.start()) 102 103} بعد از پایان پیاده سازی سرور tcp با دستور زیر سرور خود را اجرا میکنیم: go run main.go\nو با دستور زیر در یک ترمینال مجزا به سرور متصل میشویم: telnet localhost 3000\nحال با نوشتن پیام و ارسال آن در ترمینال telnet متن پیام و ادرس اتصال در ترمینال سرور قابل مشاهده است.\nتوجه داشته باشید که دستور ‍telnet در ویندوز نیاز به فعال سازی دارد.\n"},{"id":75,"href":"/chapter-5/go-tcp-server-advanced/","title":"5.3 سرور tcp پیشرفته","section":"فصل پنجم: برنامه نویسی شبکه با گو","content":"در این قسمت به طراحی و ساخت یک سرور tcp بصورت پیشرفته میپردازیم. در قسمت قبل بعد از ایجاد سرور TCP ساده با استفاده از کلاینت telnet به آن متصل شدیم و دیتایی را انتقال دادیم.\nدر این قسمت یک سرور tcp را با هدف انتقال فایل های حجیم بصورت جریان ایجاد میکنم.\nقبل از شروع ایجاد سرور خود به دلیل اینکه چرا فایل های حجیم را استریم میکنیم و یا اصلا استریم چیست میپردازیم. زمانی که شما فایل های کم حجم را مستقیما انتقال میدهید با تاخیر کم و بصورت مطلوب انجام میشود. اما روایت برای فایل های سنگین تر متفاوت است، اگر این عمل بصورت مستقیم و یکجا انجام شود باعث ایجاد تاخیر و مصرف منابع بیش از حد روی سرور میشود. اما ما با استفاده از روش استریم، داده و فایل خود را بصورت قطعه های کم حجم و پشت سر هم ارسال میکنیم.\nدر ادامه به پیاده سازی سرور خود با استفاده از پروتکل tcp میپردازیم:\n1package main 2 3import ( 4\t\u0026#34;bytes\u0026#34; 5\t\u0026#34;crypto/rand\u0026#34; 6\t\u0026#34;encoding/binary\u0026#34; 7\t\u0026#34;fmt\u0026#34; 8\t\u0026#34;io\u0026#34; 9\t\u0026#34;log\u0026#34; 10\t\u0026#34;net\u0026#34; 11\t\u0026#34;time\u0026#34; 12) 13 14 15type FileServer struct { } 16 17 18func (fs *FileServer) start() { 19\tln, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;0.0.0.0:3000\u0026#34;) 20\tif err != nil { 21\tpanic(err) 22\t} 23 24\tfor { 25\tconn, err := ln.Accept() 26 27\tif err != nil { 28\tlog.Fatal(err) 29\tcontinue 30\t} 31 32\tfmt.Printf(\u0026#34;new connection: %s\\n\u0026#34;, conn.RemoteAddr().String()) 33 34\t// read data from accepted connections 35\tgo fs.readLoop(conn) 36\t} 37} 38 39func (fs *FileServer) readLoop(conn net.Conn) { 40 41\t// make a new buffer 42\tbuf := new(bytes.Buffer) 43 44\tfor { 45 46\tvar size int64 47 48\t// get the size from connection 49\tbinary.Read(conn, binary.LittleEndian, \u0026amp;size) 50 51\t// copy from connection until the end of file 52\tn, err := io.CopyN(buf, conn, size) 53\tif err != nil { 54\tlog.Fatal(err) 55\tcontinue 56\t} 57 58\tfmt.Println(buf.Bytes()) 59\tfmt.Printf(\u0026#34;received %d bytes over the network\\n\u0026#34;, n) 60\t} 61} 62 63func main() { 64 65\tgo func () { 66 67\ttime.Sleep(4 * time.Second) 68 69 // set your file szie 70\tsendFile(2000000) 71\t}() 72 73\ts := \u0026amp;FileServer{} 74\ts.start() 75} 76 77// client example that send a large file to server! 78func sendFile(size int) error { 79 80\tfile := make([]byte, size) 81 82\t// make a random file from the size provided 83\t_, err := io.ReadFull(rand.Reader, file) 84\tif err != nil { 85\treturn err 86\t} 87 88\t// dial with the tcp server (you can do this is an other file) 89\tconn, err := net.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;:3000\u0026#34;) 90\tif err != nil { 91\treturn err 92\t} 93 94\t// send the size of file 95\tbinary.Write(conn, binary.LittleEndian, int64(size)) 96 97\t// copy file over the network until the end of file 98\tn, err := io.CopyN(conn, bytes.NewReader(file), int64(size)) 99\tif err != nil { 100\treturn err 101\t} 102 103\tfmt.Printf(\u0026#34;written %d byte over the network\\n\u0026#34;, n) 104\treturn nil 105} بعد از پایان نوشتن کد شما میتوانید با اجرا کردن کد خود (ترجیحا انتخاب یک عدد بزرگ برای حجم فایل یا همان ورودی تابع sendFile) میتوانید استریم شدن بایت هارا بصورت چانک چانک در لاگ های سمت سرور ببینید.\n"},{"id":76,"href":"/chapter-5/go-udp-server-begginer/","title":"5.4 سرور udp مقدماتی","section":"فصل پنجم: برنامه نویسی شبکه با گو","content":"در این قسمت به طراحی و ساخت یک سرور UDP مقدماتی با گولنگ می پردازیم.\n5.4.1 معرفی UDP # پروتکل(User Datagram Protocol) یک پروتکل فاقد اتصال است. به این معنا که بسته های این پروتکل بدون اتصال قبلی و بررسی اینکه ایا همه بسته ها به درستی ارسال شده اند به دستگاه مورد نظر ارسال میشود. به همین دلیل سرعت در این پروتکل از پروتکل tcp پایین تر است اما تظمین ارسال کامل و سالم داده وجود ندارد. از موارد استفاده این پروتکل میتوان سرور بازی های انلاین را مثال زد.\n5.4.2 پیاده سازی # برای پیاده سازی یک سرور udp در گولنگ و اتصال به آن همچنان از کتابخانه net استفاده میکنیم.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;net\u0026#34; 6\t\u0026#34;strings\u0026#34; 7) 8 9 10func main() { 11 // ادرس IP و پورت مورد نظر را برای گوش سپردن به پکت های UDP مشخص میکنیم (مقدار بازگشتی این تابع اتصال ما است که قابلیت نوشتن و خواندن آن را داریم) 12\tconn, err := net.ListenUDP(\u0026#34;udp\u0026#34;, \u0026amp;net.UDPAddr{ 13\tPort: 3000, 14\tIP: net.ParseIP(\u0026#34;0.0.0.0\u0026#34;), 15\t}) 16\tif err != nil { 17\tpanic(err) 18\t} 19 20\tdefer conn.Close() 21\tfmt.Printf(\u0026#34;server listening %s\\n\u0026#34;, conn.LocalAddr().String()) 22 23\tfor { 24\tmessage := make([]byte, 20) 25 // تمام پیام های نوشته شده (ارسال شده) را میخوانیم 26 // متغییر message را با مقدار ارسال شده پر میکنیم (مقدار های بازگشتی این تابع طول پیام و آدرس ریموت ارسال کننده است) 27\treadLen, remote, err := conn.ReadFromUDP(message[:]) 28\tif err != nil { 29\tpanic(err) 30\t} 31 32 // متن پیام را تا قسمت خوانده شده به string تبدیل میکنیم 33\tdata := strings.TrimSpace(string(message[:readLen])) 34 // داده خروجی را چاپ میکنیم 35\tfmt.Printf(\u0026#34;received: %s from %s\\n\u0026#34;, data, remote) 36\t} 37} بعد از انجام مراحل بالا با دستور ‍go run main.go کد خود را اجرا میکنیم.\n5.4.3 کد کلاینت برای اتصال به سرور ساخته شده # اکنون با چند خط کد در زبان گولنگ به سرور خود متصل میشویم پیامی را به آن ارسال میکنیم\n1package main 2 3import \u0026#34;net\u0026#34; 4 5func main() { 6 // یک اتصال به سرور ایجاد میکنیم 7 Conn, _ := net.DialUDP(\u0026#34;udp\u0026#34;, nil, \u0026amp;net.UDPAddr{IP:[]byte{127,0,0,1},Port:3000,Zone:\u0026#34;\u0026#34;}) 8 9 defer Conn.Close() 10 // متن زیر را به سرور ارسال میکنیم 11 Conn.Write([]byte(\u0026#34;hello, gofarsi!\u0026#34;)) 12} اکنون همزمان با اجرا بودن کد سرور این قطعه کد را با دستور ‍‍go run client.go اجرا میکنیم (بسته به اسمی که برای فایل انتخاب کرده اید)\nخروجی در کنسول کد سرور به این صورت خواهد بود: received: hello, gofarsi! from 127.0.0.1:54960\n"},{"id":77,"href":"/chapter-5/go-udp-server-advanced/","title":"5.5 سرور udp پیشرفته","section":"فصل پنجم: برنامه نویسی شبکه با گو","content":"در قسمت قبل به ایجاد یک سرور udp ساده و ارسال پکت به آن پرداختیم. در این قسمت با استفاده از یک سرور و کلاینت udp یک پیام رسان بصورت feed میسازیم. عملکرد سرور و کلاینت: یک سرور udp ایجاد میکنیم که تمام کانکشن های موجود را ذخیره میکند و به محض دریافت پیام از هر یک از کانکشن ها پیام را برای تمام کانکشن های دیگر بجر کانکشن ارسال کننده پیام ارسال میکند.\nدر مرحله اول سروری که کانکشن ها و ارسال پیام را مدیریت میکنید مینویسیم:\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;net\u0026#34; 6) 7 8func main() { 9 // Set up the server 10 addr := net.UDPAddr{ 11 Port: 8000, 12 IP: net.ParseIP(\u0026#34;0.0.0.0\u0026#34;), 13 } 14 15 conn, err := net.ListenUDP(\u0026#34;udp\u0026#34;, \u0026amp;addr) 16 if err != nil { 17 fmt.Println(\u0026#34;Error listening:\u0026#34;, err) 18 return 19 } 20 21 defer conn.Close() 22 fmt.Println(\u0026#34;Server started on port\u0026#34;, addr.Port) 23 24 // Listen for incoming messages 25 buffer := make([]byte, 1024) 26 27 clients := make(map[string]*net.UDPAddr) 28\t29 for { 30 n, clientAddr, err := conn.ReadFromUDP(buffer) 31 if err != nil { 32 fmt.Println(\u0026#34;Error reading:\u0026#34;, err) 33 continue 34 } 35 36 // Add new client 37 if _, ok := clients[clientAddr.String()]; !ok { 38 clients[clientAddr.String()] = clientAddr 39 fmt.Println(\u0026#34;New client joined:\u0026#34;, clientAddr.String()) 40 } 41 42 // Broadcast message to all clients 43 message := buffer[:n] 44 for _, addr := range clients { 45 if addr.String() != clientAddr.String() { 46 _, err = conn.WriteToUDP(message, addr) 47 if err != nil { 48 fmt.Println(\u0026#34;Error broadcasting message:\u0026#34;, err) 49 } 50 } 51 } 52 } 53} در این قسمت یک سرور udp ایجاد کرده ایم و هر کانکشن جدید را به لیست کانکشن های خود اضافه میکنیم. همچنین در ازای هر پیام دریافتی از سمت کانکشن ها آن را برای کانکشن های دیگر ارسال میکنیم.\nدر ادامه یک کلاینت ساده برای سرور خود مینویسیم که پیام هارا نمایش دهد و متن ورودی در ترمینال را به سرور ارسال کند.\n1package main 2 3import ( 4 \u0026#34;bufio\u0026#34; 5 \u0026#34;fmt\u0026#34; 6 \u0026#34;net\u0026#34; 7 \u0026#34;os\u0026#34; 8) 9 10func main() { 11 // Set up connection to the server 12 conn, err := net.Dial(\u0026#34;udp\u0026#34;, \u0026#34;localhost:8000\u0026#34;) 13 if err != nil { 14 fmt.Println(\u0026#34;Error connecting:\u0026#34;, err) 15 return 16 } 17 defer conn.Close() 18 19 20 go func() { 21 for { 22 buf := make([]byte, 1024) // buffer for incoming message 23 n, err := conn.Read(buf) 24 if err != nil { 25 fmt.Println(\u0026#34;Error receiving message:\u0026#34;, err) 26 continue 27 } 28 fmt.Printf(\u0026#34;Received message: %s\\n\u0026#34;, string(buf[:n])) 29 } 30 }() 31 32 // Read input from terminal and send to server 33 scanner := bufio.NewScanner(os.Stdin) 34 for { 35\t// send messages to server 36 fmt.Print(\u0026#34;Enter message: \u0026#34;) 37 if !scanner.Scan() { 38 break 39 } 40 message := scanner.Text() 41 _, err = conn.Write([]byte(message)) 42 if err != nil { 43 fmt.Println(\u0026#34;Error sending message:\u0026#34;, err) 44 continue 45 } 46 } 47} در این کد ما تمام پیام های دریافتی از سرور را چاپ میکنیم و هر پیامی که کاربر در ترمینال وارد کند را به سرور ارسال میکنیم.\nبعد از اتمام کار برای تست کد خود سه ترمینال مجزا بار میکنیم. و در یکی از سرور ها فایل server.go و در دو ترمینال دیگر فایل client.go را اجرا میکنیم.\nهر پیامی که توسط هر کلاینتی ارسال شود برای دیگر کلاینت ها قابل مشاهده است.\nتوجه کنید اسم فایل ها بر اساس اسم انتخابی شما است. همچنین توجه داشته باشید که شما میتوانید هر تعداد دلخواهی کلاینت را اجرا کنید.\n"},{"id":78,"href":"/chapter-5/go-http-server-begginer/","title":"5.6 کتابخانه http سمت سرور مقدماتی","section":"فصل پنجم: برنامه نویسی شبکه با گو","content":"یکی از قابلیت های زبان گو این است که می توان با استفاده از کتابخانه http داخلی گو استفاده کرده و وب سرور پیاده سازی کرد.\nبرای پیاده سازی یک وب سرور حداقل به 3 چیز نیاز داریم: 1) مسیر 2) درگاه وب سرور 3) مقدار برگشتی\nمسیر: عبارت است از URL منحصر به فرد برای ارسال و دریافت اطلاعات ورودی\nدرگاه وب سرور: هر وب سرور نیاز دارد که درگاه (Port) خاصی را در اختیار داشته باشد و همواره به آن درگاه گوش بسپارد.\nمقدار برگشتی: هرگاه کاربر به مسیری وارد میشود یا اطلاعاتی را برای وب سرور ارسال میکند، مقداری از سمت سرور برای کاربر ارسال میشود.\nیک نمونه وب سرور در گو\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;net/http\u0026#34; 6) 7 8func main() { 9\t// مسیر / یا root را برای این تابع انتخاب میکنیم (کد این تابع با صدا شدن مسیر localhost:3000 اجرا می شود) 10\thttp.HandleFunc(\u0026#34;/\u0026#34;, func(writer http.ResponseWriter, request *http.Request) { 11\t// مقدار hello world را در مسیر مشخص شده برمیگردانیم 12\t_, err := fmt.Fprint(writer, \u0026#34;\u0026lt;h1\u0026gt;Hellow World!\u0026lt;/h1\u0026gt;\u0026#34;) 13\tif err != nil { 14\treturn 15\t} 16\t}) 17 18\tfmt.Println(\u0026#34;Starting The Server on :3000...\u0026#34;) 19\t// به درخواست های ارسال شده به پورت 3000 با پروتوکول http گوش میکنیم (سرور در انتظار درخواست از سمت کاربر یا client) می ماند 20\terr := http.ListenAndServe(\u0026#34;:3000\u0026#34;, nil) 21\tif err != nil { 22\treturn 23\t} 24 25} با وارد شدن به آدرس localhost:3000 مقدار برگشته شده در ‍handleFunc را مشاهده خواهید کرد.\n"},{"id":79,"href":"/chapter-5/go-http-server-advanced/","title":"5.7 کتابخانه http سمت سرور پیشرفته","section":"فصل پنجم: برنامه نویسی شبکه با گو","content":"در قسمت قبل با استفاده از کتابخانه net/http یک api ساده ایجاد کردیم.\nدر این قسمت به پیاده سازی یک سرور http برای مدیریت لیست TODO های خود میپردازیم و از چهار متد GET, POST, DELET and PATCH استفاده میکنیم.\nدر این پروژه از دیتابیس استفاده نمیشود. روش ذخیره سازی اطلاعات درون متغییر هاست دلیل استفاده نکردن از یک دیتابیس تمرکز این قسمت روی کتابخانه و پروتکل http است.\nدر ادامه به ایجاد سرور خود میپردازیم.\n1package main 2 3import ( 4\t\u0026#34;encoding/json\u0026#34; 5\t\u0026#34;fmt\u0026#34; 6 \u0026#34;log\u0026#34; 7\t\u0026#34;net/http\u0026#34; 8) 9 10// todo struct with json tags 11type Todo struct { 12\tID int `json:\u0026#34;id\u0026#34;` 13\tTitle string `json:\u0026#34;title\u0026#34;` 14\tStatus bool `json:\u0026#34;status\u0026#34;` 15} 16 17// just work as a DB for us! 18var todos []Todo 19 20// get all the items in the Todo list and write it. GET 21func getTodos(w http.ResponseWriter, r *http.Request) { 22\tw.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) 23\tjson.NewEncoder(w).Encode(todos) 24} 25 26// append a new data in array. POST 27func addTodo(w http.ResponseWriter, r *http.Request) { 28\tw.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) 29 30\tvar todo Todo 31\tjson.NewDecoder(r.Body).Decode(\u0026amp;todo) 32 33 // NOTE: this isn\u0026#39;t a good way to set ids in production! 34\ttodo.ID = len(todos) + 1 35\ttodos = append(todos, todo) 36 37\tjson.NewEncoder(w).Encode(todo) 38} 39 40// change the todo status. PATCH 41func updateTodo(w http.ResponseWriter, r *http.Request) { 42\tw.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) 43 44\tvar todo Todo 45\tjson.NewDecoder(r.Body).Decode(\u0026amp;todo) 46 47\tfor i, t := range todos { 48\tif t.ID == todo.ID { 49\ttodos[i].Status = todo.Status 50\tjson.NewEncoder(w).Encode(todos[i]) 51\treturn 52\t} 53\t} 54 55\tw.WriteHeader(http.StatusNotFound) 56\tjson.NewEncoder(w).Encode(map[string]string{\u0026#34;message\u0026#34;: \u0026#34;TODO not found\u0026#34;}) 57} 58 59// remove the TODO from array. DELETE 60func deleteTodo(w http.ResponseWriter, r *http.Request) { 61\tw.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) 62 63\tvar todo Todo 64\tjson.NewDecoder(r.Body).Decode(\u0026amp;todo) 65 66\tfor i, t := range todos { 67\tif t.ID == todo.ID { 68\ttodos = append(todos[:i], todos[i+1:]...) 69\tjson.NewEncoder(w).Encode(map[string]string{\u0026#34;message\u0026#34;: \u0026#34;TODO deleted\u0026#34;}) 70\treturn 71\t} 72\t} 73 74\tw.WriteHeader(http.StatusNotFound) 75\tjson.NewEncoder(w).Encode(map[string]string{\u0026#34;message\u0026#34;: \u0026#34;TODO not found\u0026#34;}) 76} 77 78 79func main() { 80 // set routes 81\thttp.HandleFunc(\u0026#34;/todos\u0026#34;, getTodos) 82\thttp.HandleFunc(\u0026#34;/todos/add\u0026#34;, addTodo) 83\thttp.HandleFunc(\u0026#34;/todos/update\u0026#34;, updateTodo) 84\thttp.HandleFunc(\u0026#34;/todos/delete\u0026#34;, deleteTodo) 85 86 // start server 87\tfmt.Println(\u0026#34;Server starting at port 8080\u0026#34;) 88\tlog.Fatal(http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil)) 89} بعد از اتمام نوشتن سرور با استفاده از یک کلاینت http مثل postman سرور خود را به روش زیر تست میکنیم:\nنکته: شما می توانید کلاینت خود را خودتان با استفاده از اموزش کلاینت http در قسمت های دیگر بنویسید!\nadd todo # endpoint: localhost:8080/todos/add\nmethod:POST\nrequest:\n1{ 2 \u0026#34;title\u0026#34;:\u0026#34;todo1 test\u0026#34; 3} response:\n1{ 2 \u0026#34;id\u0026#34;: 1, 3 \u0026#34;title\u0026#34;: \u0026#34;todo1 test\u0026#34;, 4 \u0026#34;status\u0026#34;: false 5} get todo\u0026rsquo;s # endpoint: localhost:8080/todos\nmethod:GET\nrequest:\nresponse:\n1[ 2 { 3 \u0026#34;id\u0026#34;: 1, 4 \u0026#34;title\u0026#34;: \u0026#34;todo1 test\u0026#34;, 5 \u0026#34;status\u0026#34;: false 6 }, 7 //... 8] update todo # endpoint: localhost:8080/todos/update\nmethod:PATCH\nrequest:\n1{ 2 \u0026#34;id\u0026#34;:1, 3 \u0026#34;status\u0026#34;:true 4} response:\n1{ 2 \u0026#34;id\u0026#34;: 1, 3 \u0026#34;title\u0026#34;: \u0026#34;todo1 test\u0026#34;, 4 \u0026#34;status\u0026#34;: true 5} delete todo # endpoint: localhost:8080/todos/delete\nmethod:DELETE\nrequest:\n1{ 2 \u0026#34;id\u0026#34;:1 3} response:\n1{ 2 \u0026#34;message\u0026#34;: \u0026#34;TODO deleted\u0026#34; 3} "},{"id":80,"href":"/chapter-5/go-http-client-begginer/","title":"5.8 کتابخانه http سمت کلاینت مقدماتی","section":"فصل پنجم: برنامه نویسی شبکه با گو","content":"برای ایجاد کلاینت http در گولنگ نیاز به کتابخانه net/http داریم. قبل از شروع به نوشتن کلاینت خود چند مفهوم کلی راه بررسی میکنیم.\n5.8.1 سرور # همانطور که میدانیم سرور های http برای تعریف مسیر ها منطق سرور و دریافت درخواست ها طراحی و ساخته میشوند. (در قسمت های قبل ایجاد سرور http بصورت کامل یادگرفتیم)\n5.8.2 کلاینت # کلاینت های در پروتوکول http برای صدا کردن (call) و ارسال درخواست به سرور ها طراحی و ساخته میشوند. در ادامه یک کلاینت مقدماتی و ساده را در زبان گولنگ ایجاد میکنیم.\n‍‍\n1 2package main 3 4import ( 5 \u0026#34;fmt\u0026#34; 6 \u0026#34;io/ioutil\u0026#34; 7 \u0026#34;net/http\u0026#34; 8 \u0026#34;time\u0026#34; 9) 10 11func main() { 12 // کلاینت خود را با استفاده از ماژول http ایجاد میکنیم 13 c := http.Client{Timeout: time.Duration(1) * time.Second} 14 // از طریق کلاینت ایجاد شده یک درخواست با متد GET به آدرس example.com ارسال میکنیم 15 // دقیقا سروری مشابه به سرور هایی که در قسمت های قبل ایجاد کردیم در آدرسی که الان به آن درخوایت ارسال میکنیم درحال گوش سپردن به درخواست ها میباشد. 16 resp, err := c.Get(\u0026#34;https://www.example.com\u0026#34;) 17 if err != nil { 18 fmt.Printf(\u0026#34;Error %s\u0026#34;, err) 19 return 20 } 21 defer resp.Body.Close() 22 // مقادیر دریافت شده از سرور را میخوانیم و چاپ میکنیم 23 body, err := ioutil.ReadAll(resp.Body) 24 fmt.Printf(\u0026#34;Body : %s\u0026#34;, body) 25} در نهایت با اجرای قطعه کد بالا خروجی ما پاسخی است که از سرور دریافت کرده ایم:\n1Body : \u0026lt;!doctype html\u0026gt; 2\u0026lt;html\u0026gt; 3\u0026lt;head\u0026gt; 4 \u0026lt;title\u0026gt;Example Domain\u0026lt;/title\u0026gt; 5 6 \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; 7 \u0026lt;meta http-equiv=\u0026#34;Content-type\u0026#34; content=\u0026#34;text/html; charset=utf-8\u0026#34; /\u0026gt; 8 \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1\u0026#34; /\u0026gt; 9 \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; 10 body { 11 background-color: #f0f0f2; 12 margin: 0; 13 padding: 0; 14 font-family: -apple-system, system-ui, BlinkMacSystemFont, \u0026#34;Segoe UI\u0026#34;, \u0026#34;Open Sans\u0026#34;, \u0026#34;Helvetica Neue\u0026#34;, Helvetica, Arial, sans-serif; 15 16 } 17 div { 18 width: 600px; 19 margin: 5em auto; 20 padding: 2em; 21 background-color: #fdfdff; 22 border-radius: 0.5em; 23 box-shadow: 2px 3px 7px 2px rgba(0,0,0,0.02); 24 } 25 a:link, a:visited { 26 color: #38488f; 27 text-decoration: none; 28 } 29 @media (max-width: 700px) { 30 div { 31 margin: 0 auto; 32 width: auto; 33 } 34 } 35 \u0026lt;/style\u0026gt; 36\u0026lt;/head\u0026gt; 37 38\u0026lt;body\u0026gt; 39\u0026lt;div\u0026gt; 40 \u0026lt;h1\u0026gt;Example Domain\u0026lt;/h1\u0026gt; 41 \u0026lt;p\u0026gt;This domain is for use in illustrative examples in documents. You may use this 42 domain in literature without prior coordination or asking for permission.\u0026lt;/p\u0026gt; 43 \u0026lt;p\u0026gt;\u0026lt;a href=\u0026#34;https://www.iana.org/domains/example\u0026#34;\u0026gt;More information...\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt; 44\u0026lt;/div\u0026gt; 45\u0026lt;/body\u0026gt; 46\u0026lt;/html\u0026gt; "},{"id":81,"href":"/chapter-5/go-http-client-advanced/","title":"5.9 کتابخانه http سمت کلاینت پیشرفته","section":"فصل پنجم: برنامه نویسی شبکه با گو","content":"در قسمت قبل به ایجاد یک کلاینت http ساده و ارسال یک درخواست با متد get پرداختیم.\nدر این قسمت به موارد کامل تر و جزیی تر کلاینت http میپردازیم.\nبرای انجام تمرین های این قسمت از یک api تستی که جهت یادگیری ساخته شده است استفاده میکنیم (شما میتوانید از هر api یا سروری استفاده کنید حتی سرور http که خودتان نوشته باشید.)\nدر این آموزش ما از api زیر استفاده میکنیم: api docs\n5.9.1 نوع درخواست های یک سرور http # یکی از مواردی که حین اتصال به یک سرور http باید مورد توجه قرار بگیرد متد یا نوع درخواست است.\nانواع متد ها: GET : پیام هایی که در این روش ارسال می‌شوند تنها برای دریافت اطلاعات از سرور میباشد.\nPOST : در این نوع پیام ها اطلاعاتی برای ثبت شدن در سرور به سمت سرور http ارسال میشود\nPUT : در این روش برای جایگزاری مقداری در سرور اطلاعاتی ارسال میشود.\nDELETE : از این روش برای حذف مقداری از روی سرور استفاده میشود\nPATCH : این روش برای ویرایش جزیی استفاده میشود.\nاین موارد ۵ تا از پرکابرد ترین نوع درخواست های http هستند.\n5.9.2 نوع پاسخ های یک سرور http # در پاسخ یک سرور http یکی از موارد پر اهمیت کد وضعیت یا status code است. این کد ها اعدادی بین ۱۰۰ تا ۵۹۹ هستند که نشان دهنده وضعیت درخوایت از سمت سرور میباشند.\nانواع کد وضعیت: 1XX: این دسته از کد های وضعیت نمایانگر اطلاعات درخواست هستند\n2XX: این دسته از کد های وضعیت نمایانگر موفقیت درخواست در ارسال ثبت یا ویرایش اطلاعات میباشد\n3xx: این دسته از کد های نشانگر ریدایرکت میباشد\n4xx: این دسته از کد ها نشانگر ارور از سمت کلاینت میباشند\n5xx: این دسته از کد های نشانگر ارور از سمت سرور میباشند\nدر قسمت های بعد به پیاده سازی کلاینت و سرور HTTP خواهیم پرداخت و شاهد این موارد در عمل خواهید بود.\nدر قسمت زیر فهرست تعدادی از کد های وضعیت پرکاربرد را میبینیم:\n200 ok : این کد وضعیت نشانگر موفقیت در پاسخ به متد GET است 404 NotFound : این کد وضعیت نشانگر پیدا نشدن مقدار درخواستی کاربر در سرور است که یکی از معروف ترین کد های وضعیت است 500 InternalServerError: این کد وضعیت نشانگر خطای فنی از سمت سرور است 401 Unauthorized : این کد وضعیت نشانگر این است که درخواست ارسال شده نیاز به احراز هویت دارد 403 Forbidden : این کد وضعیت نشانگر این است که دسترسی به URL مورد نظر نیازمند سطح دسترسی متفاوتی است(این مورد با ۴۰۱ متفاوت است) 5.9.3 GET request # در مرحله اول به ایجاد یک درخواست GET به سرور میپردازیم.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;io/ioutil\u0026#34; 6\t\u0026#34;net/http\u0026#34; 7) 8 9func main() { 10 // به url مورد نظر برای دریافت لیست محصولات موجود یک درخوایت با متد GET ایجاد میکنیم 11 resp, err := http.Get(\u0026#34;https://fakestoreapi.com/products\u0026#34;) 12 if err != nil { 13 fmt.Println(\u0026#34;Error:\u0026#34;, err) 14 return 15 } 16 defer resp.Body.Close() 17 18 // کد وضعیت پاسخ سرور را چاپ میکنیم 19 fmt.Println(resp.StatusCode) 20 21 // خروجی را در یک اسلایس ذخیره میکنیم 22 body, err := ioutil.ReadAll(resp.Body) 23 if err != nil { 24 fmt.Println(\u0026#34;Error:\u0026#34;, err) 25 return 26 } 27 28 // خروجی را چاپ میکنیم 29 fmt.Println(string(body)) 30} خروجی:\n1 2[ 3{ 4\u0026#34;id\u0026#34;:1, 5\u0026#34;title\u0026#34;:\u0026#34;Fjallraven - Foldsack No. 1 Backpack, Fits 15 Laptops\u0026#34;,\u0026#34;price\u0026#34;:109.95,\u0026#34;description\u0026#34;:\u0026#34;Your perfect pack for everyday use and walks in the forest. Stash your laptop (up to 15 inches) in the padded sleeve, your everyday\u0026#34;, 6\u0026#34;category\u0026#34;:\u0026#34;men\u0026#39;s clothing\u0026#34;, 7\u0026#34;image\u0026#34;:\u0026#34;https://fakestoreapi.com/img/81fPKd-2AYL._AC_SL1500_.jpg\u0026#34;, 8\u0026#34;rating\u0026#34;:{\u0026#34;rate\u0026#34;:3.9,\u0026#34;count\u0026#34;:120} 9}, 10// ..... 11] 5.9.4 POST request # در مرحله بعد با استفاده از متد POST یک محصول جدید به سرور اضافه میکنیم.\n1package main 2 3import ( 4 \u0026#34;bytes\u0026#34; 5 \u0026#34;fmt\u0026#34; 6 \u0026#34;net/http\u0026#34; 7) 8 9func main() { 10 url := \u0026#34;https://fakestoreapi.com/products\u0026#34; 11 // جیسان مورد نظر برای ارسال و ثبت در سرور را ایجاد میکنیم (مقادیر مورد نیاز در مستندات api ذکر میشود) 12 jsonStr := []byte(` 13\t{ 14\ttitle: \u0026#39;test product\u0026#39;, 15\tprice: 13.5, 16\tdescription: \u0026#39;lorem ipsum set\u0026#39;, 17\timage: \u0026#39;https://i.pravatar.cc\u0026#39;, 18\tcategory: \u0026#39;electronic\u0026#39; 19\t} 20\t`) 21 22 // یک درخواست یه ادرس سرور میسازیم 23 req, err := http.NewRequest(\u0026#34;POST\u0026#34;, url, bytes.NewBuffer(jsonStr)) 24 if err != nil { 25 fmt.Println(err) 26 } 27 28 29 client := \u0026amp;http.Client{} 30 // درخواست را انجام میدهیم 31 resp, err := client.Do(req) 32 if err != nil { 33 fmt.Println(err) 34 } 35 defer resp.Body.Close() 36 37 // کد وضعیت و پاسخ سرور را چاپ میکنیم 38 fmt.Println(\u0026#34;Status:\u0026#34;, resp.Status) 39 fmt.Println(\u0026#34;Response:\u0026#34;, resp) 40} در صورت برابر بودن کد وضعیت با ۲۰۰ محصول ایجاد شده توسط شما با موفقیت ثبت شده است.\n5.9.5 DELETE request # در مرحله بعد به ایجاد یک درخواست DELETE و پاک کردن یک محصول از سرور میپردازیم:\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;net/http\u0026#34; 6) 7 8func main() { 9 // شماره محصول مورد نظر را در انتهای url اضافه میکنیم (طبق مستندات) 10 url := \u0026#34;https://fakestoreapi.com/products/1\u0026#34; 11 // یک درخواست با متد DELETE ایجاد میکنیم 12 req, err := http.NewRequest(\u0026#34;DELETE\u0026#34;, url, nil) 13 if err != nil { 14 fmt.Println(err) 15 } 16 client := \u0026amp;http.Client{} 17 // درخواست را به سرور ارسال میکنیم 18 resp, err := client.Do(req) 19 if err != nil { 20 fmt.Println(err) 21 } 22 defer resp.Body.Close() 23 // درصورت موفقیت آمیز بودن درخواست خروجی عدد 200 است 24 fmt.Println(\u0026#34;Status:\u0026#34;, resp.Status) 25} 5.9.6 PUT request # در مرحله بعد به ایجاد یک درخواست PUT و اپدیت کردن اطلاعات یک محصول میپردازیم:\n1package main 2 3import ( 4\t\u0026#34;bytes\u0026#34; 5\t\u0026#34;fmt\u0026#34; 6\t\u0026#34;net/http\u0026#34; 7) 8 9func main() { 10 // ایدی محول مورد نظر را به انتهای url اضافه میکنیم 11 url := \u0026#34;https://fakestoreapi.com/products/7\u0026#34; 12 13 // مقدار های جدید را برای اپدیت شدن وارد میکنیم 14 requestBody := []byte(` 15\t{ 16\ttitle: \u0026#39;test product\u0026#39;, 17\tprice: 13.5, 18\tdescription: \u0026#39;lorem ipsum set\u0026#39;, 19\timage: \u0026#39;https://i.pravatar.cc\u0026#39;, 20\tcategory: \u0026#39;electronic\u0026#39; 21\t} 22\t`) 23 ‍‍ // درخواست را ایجاد میکنیم 24 req, err := http.NewRequest(\u0026#34;PUT\u0026#34;, url, bytes.NewBuffer(requestBody)) 25 if err != nil { 26 fmt.Println(err) 27 return 28 } 29 30 31 client := \u0026amp;http.Client{} 32 // درخواست را به سرور ارسال میکنیم 33 resp, err := client.Do(req) 34 if err != nil { 35 fmt.Println(err) 36 return 37 } 38 defer resp.Body.Close() 39 40 // درصورت 200 بودن کد وضعیت اپدیت با موفقیت انجام شده. 41 fmt.Println(resp.StatusCode) 42} "},{"id":82,"href":"/chapter-5/go-quic-prtoocol/","title":"5.10 پروتکل quic","section":"فصل پنجم: برنامه نویسی شبکه با گو","content":"پروتکل quic یک پروتکل توسعه یافته توسط google است. این پروتکل برای امنیت و سرعت بیشتر توسعه داده شده است.\nپروتکل quic از UDP استفاده میکند و در لایه transport قرار میگیرد.\nاین پروتکل اجازه ایجاد چند کانکشن بصورت همزمان را فراهم میکنید و همچنین http/3 بر اساس این پروتکل طراحی و ایجاد شده است.\nچند مورد از ویژگی های کلیدی quic : ۱. ایجاد کانکشن سریع تر به دلیل اسفاده از udp. ۲. نیازی به دست دادن سه مرحله مثل tcp ندارد. ۳. بصورت پیش فرص از رمزنگاری استفاده میکند.\nدر ادامه با استفاده از یک پکیج خارجی به نام quic-go یک سرور ساده با این پروتکل ایجاد میکنیم و یک پیام به آن ارسال میکنیم (عملکرد سرور ما تنها برگرداندن همان متن یا به اصطلاحی echo کردن آن است)\nبرای شروع کار ابتدا نیاز داریم پکیج مورد نظر خود را نصب کنیم\nبا استفاده از دستور زیر: go get github.com/quic-go/quic-go\nبعد از اتمام مرحله نصب شروع به نوشتن کد سرور و کلاینت خود میکنیم.\n1package main 2 3import ( 4\t\u0026#34;context\u0026#34; 5\t\u0026#34;crypto/rand\u0026#34; 6\t\u0026#34;crypto/rsa\u0026#34; 7\t\u0026#34;crypto/tls\u0026#34; 8\t\u0026#34;crypto/x509\u0026#34; 9\t\u0026#34;encoding/pem\u0026#34; 10\t\u0026#34;fmt\u0026#34; 11\t\u0026#34;io\u0026#34; 12\t\u0026#34;log\u0026#34; 13\t\u0026#34;math/big\u0026#34; 14 15\t\u0026#34;github.com/quic-go/quic-go\u0026#34; 16) 17 18const addr = \u0026#34;localhost:4242\u0026#34; 19 20// the message we sent to server you can also change it! 21const message = \u0026#34;hello gifarsi!\u0026#34; 22 23// starting the server and call the client function. 24func main() { 25\tgo func() { log.Fatal(echoServer()) }() 26 27\terr := clientMain() 28\tif err != nil { 29\tpanic(err) 30\t} 31} 32 33// this function start our echo server 34func echoServer() error { 35 // make a new listner with quic 36\tlistener, err := quic.ListenAddr(addr, generateTLSConfig(), nil) 37\tif err != nil { 38\treturn err 39\t} 40 41 // accept incoming connections 42\tconn, err := listener.Accept(context.Background()) 43\tif err != nil { 44\treturn err 45\t} 46 47 // accept incoming streams 48\tstream, err := conn.AcceptStream(context.Background()) 49\tif err != nil { 50\tpanic(err) 51\t} 52 53\t// Echo using the loggingWriter 54\t_, err = io.Copy(loggingWriter{stream}, stream) 55\treturn err 56} 57 58// client function thah send the message to our server 59func clientMain() error { 60 // set up a tls config 61\ttlsConf := \u0026amp;tls.Config{ 62\tInsecureSkipVerify: true, 63\tNextProtos: []string{\u0026#34;quic-echo-example\u0026#34;}, 64\t} 65 // dial with our udp server 66\tconn, err := quic.DialAddr(context.Background(), addr, tlsConf, nil) 67\tif err != nil { 68\treturn err 69\t} 70 71 // opening a new stream from our connection 72\tstream, err := conn.OpenStreamSync(context.Background()) 73\tif err != nil { 74\treturn err 75\t} 76 77 // write the message over the stream 78\tfmt.Printf(\u0026#34;Client: Sending \u0026#39;%s\u0026#39;\\n\u0026#34;, message) 79\t_, err = stream.Write([]byte(message)) 80\tif err != nil { 81\treturn err 82\t} 83 84 // read and print incoming answer from server 85\tbuf := make([]byte, len(message)) 86\t_, err = io.ReadFull(stream, buf) 87\tif err != nil { 88\treturn err 89\t} 90\tfmt.Printf(\u0026#34;Client: Got \u0026#39;%s\u0026#39;\\n\u0026#34;, buf) 91 92\treturn nil 93} 94 95// A wrapper for io.Writer that also logs the message. 96type loggingWriter struct{ io.Writer } 97 98func (w loggingWriter) Write(b []byte) (int, error) { 99\tfmt.Printf(\u0026#34;Server: Got \u0026#39;%s\u0026#39;\\n\u0026#34;, string(b)) 100\treturn w.Writer.Write(b) 101} 102 103// Setup a bare-bones TLS config for the server 104func generateTLSConfig() *tls.Config { 105\tkey, err := rsa.GenerateKey(rand.Reader, 1024) 106\tif err != nil { 107\tpanic(err) 108\t} 109\ttemplate := x509.Certificate{SerialNumber: big.NewInt(1)} 110\tcertDER, err := x509.CreateCertificate(rand.Reader, \u0026amp;template, \u0026amp;template, \u0026amp;key.PublicKey, key) 111\tif err != nil { 112\tpanic(err) 113\t} 114\tkeyPEM := pem.EncodeToMemory(\u0026amp;pem.Block{Type: \u0026#34;RSA PRIVATE KEY\u0026#34;, Bytes: x509.MarshalPKCS1PrivateKey(key)}) 115\tcertPEM := pem.EncodeToMemory(\u0026amp;pem.Block{Type: \u0026#34;CERTIFICATE\u0026#34;, Bytes: certDER}) 116 117\ttlsCert, err := tls.X509KeyPair(certPEM, keyPEM) 118\tif err != nil { 119\tpanic(err) 120\t} 121\treturn \u0026amp;tls.Config{ 122\tCertificates: []tls.Certificate{tlsCert}, 123\tNextProtos: []string{\u0026#34;quic-echo-example\u0026#34;}, 124\t} 125} بعد از اتمام نوشتن کد های سرور میتوانیم کد خود را اجرا و تست کنیم\ngo run main.go\nخروجی لاگ های ما به این صورت خواهد بود :\nClient: Sending \u0026#39;hello gifarsi!\u0026#39; Server: Got \u0026#39;hello gifarsi!\u0026#39; Client: Got \u0026#39;hello gifarsi!\u0026#39; در انتها توجه داشته باشید این یک مثال ساده از quic در گولنگ بود شما میتوانید با استفاده از همین پکیج سرور های کامل تر و پیچیده تر را توسعه دهید و همچنین با استفاده از quic-go/http3 یک سرور http3 توسعه دهید.\n"},{"id":83,"href":"/chapter-6/","title":"فصل ششم: ژنریک ها (Generics)","section":"صفحه اصلی","content":"در این بخش قصد داریم به بحث ژنریک ها بپردازیم که از نسخه go1.18 اضافه شد که تقریبا یکی از اساسی ترین تغییرات در سینتکس زبان گو بود و در قالب یک پروپوزال ارائه شد و سپس از نسخه ۱.۱۸ منتشر شد و تا الان تغییرات و بهبودهای زیادی داشته است.\nژنریک به زبان برنامه‌نویسی امکانات مهمی اضافه می‌کند:\nپارامترهای نوع برای توابع و انواع داده: با ژنریک، می‌توانید توابع و انواع داده‌ای را با پارامترهای نوع مخصوص بسازید. به این ترتیب می‌توانید یک تابع یا یک نوع داده را برای کار با انواع مختلف داده تعریف کنید.\nتعریف انواع رابط به عنوان مجموعه‌ای از انواع: با ژنریک، می‌توانید انواع اینترفیس را به عنوان مجموعه‌هایی از انواع تعریف کنید، حتی انواعی که متدهای خاصی ندارند. این به شما امکان می‌دهد تا انواع داده‌ای را به عنوان پارامترها در تعریف اینترفیس‌ها استفاده کنید.\nاستفاده از استنباط نوع (Type Inference): ژنریک اجازه می‌دهد که در بسیاری از موارد، پارامترهای نوع را در فراخوانی توابع حذف کنید. به این ترتیب کد شما ساده‌تر و خواناتر می‌شود و نیازی به تعیین دقیق نوع در همه جا ندارید.\nنکات کاربردی\nزمانی از ژنریک ها استفاده کنید که کدهای شما فقط با تغییر تایپ در حال تکرار است آنجا شما می توانید از ژنریک ها برای کاهش کد خود کمک بگیرید. از ژنریک ها می توانید برای کاهش Assertion اینترفیس ها استفاده کنید. با اینکه ژنریک یک ویژگی خوب است اما استفاده زیاد باعث پیچیدگی و سربار حافظه خواهد شد. ژنریک چیست؟ # ژنریک یک ویژگی مهم در Go است که به شما این امکان را می‌دهد تا کدهای کلی و قابل استفاده مجدد بنویسید بدون اینکه به تایپ‌های خاصی محدود شوید. به عبارت ساده‌تر، با ژنریک می‌توانید توابع و ساختارهای داده را بنویسید که با انواع مختلف داده‌ها کار کنند.\nبه عنوان مثال، فرض کنید یک تابع بخواهید بنویسید که دو عدد را با هم جمع کند. بدون استفاده از ژنریک، شما باید تابع‌های مجزایی برای جمع دو عدد از نوع مختلف (مثلاً عدد صحیح و عدد اعشاری) بنویسید. اما با ژنریک، می‌توانید یک تابع جمع کننده عمومی بنویسید که با هر نوع داده‌ای کار کند.\nدر اصطلاحات Go، از انواع نمادگذاری ژنریک می‌کنیم. این انواع می‌توانند به صورت متغیر باشند و از آن‌ها در تابع‌ها و ساختارهای داده استفاده کنید تا کدی ایجاد کنید که قابل استفاده با انواع مختلف داده‌ها باشد.\nاز مزیت‌های ژنریک در Go می‌توان به کاهش تکرار کد، افزایش قابلیت خوانایی کد و افزایش انعطاف‌پذیری برنامه اشاره کرد. با استفاده از این قابلیت، می‌توانید کدهای بهینه‌تری بنویسید و طراحی بهتری داشته باشید.\nبنابراین، ژنریک در Go به شما این امکان را می‌دهد که کدهای کلی‌تر و کاربردی‌تری بنویسید که با انواع مختلف داده‌ها سازگار باشند و به عنوان یک توسعه‌دهنده جوان، این ابزار قدرتمند را در توسعه نرم‌افزار‌های خود بهره‌بری کنید.\n"},{"id":84,"href":"/chapter-6/go-generic-simple/","title":"6.1 ژنریک مقدماتی","section":"فصل ششم: ژنریک ها (Generics)","content":" 6.1.1 مقدمه # این آموزش اصول اولیه generics در Go را معرفی می کند. با generics، می توانید functions یا types را که برای کار با هر یک از set of types ارائه شده با فراخوانی کد نوشته شده اند، اعلام و استفاده کنید. همینطور این قسمت فقط یک چشم انداز در استفاده از generic است و موارد بیشتر مثل Struct Types و Field Access به زودی به این کتاب اضافه خواهد شد. همینطور قسمت بیشتر این سند بر اساس مستندات go در این لینک نوشته شده است.\n6.1.2 تاریخچه و کاربرد # در Go 1.18، این زبان ویژگی جدیدی به نام انواع عمومی (که معمولاً با به صورت اختصار ، generic شناخته می‌شود) معرفی کرد که برای مدتی در لیست انتظارات توسعه‌دهندگان Go قرار داشت. در برنامه نویسی،generic type در واقع type ای است که می تواند همراه با چندین type دیگر استفاده شود. معمولاً در Go، اگر می‌خواهید بتوانید از دو مختلف برای یک متغیر استفاده کنید، باید از یک interface خاص مانند io.Reader یا interface{} استفاده کنید که امکان استفاده از هر value را فراهم می‌کند. استفاده از interface{} می‌تواند کار با آن typeها را جالب‌تر کند، زیرا برای تعامل با آن متغیرها باید بین چندین type دیگر translate کنید. استفاده از generic typeها به شما این امکان را می دهد که مستقیماً با typeها خود تعامل داشته باشید که منجر به کدهای تمیزتر و خواناتر می شود.\nدر این آموزش، شما دو تابع ساده non-generic را اعلام می‌کنید، سپس همان منطق را در یک تابع single generic ثبت می‌کنید. از طریق بخش های زیر ادامه می دهیم: 1- یک پوشه برای کد خود ایجاد کنید. 2- توابع non-generic را اضافه کنید. 3- یک تابع generic برای مدیریت چندین type اضافه کنید. 4- هنگام فراخوانی تابع generic، آرگومان های type را حذف کنید. 5- یک محدودیت type را اعلام کنید. نکته: برای سایر آموزش ها به این لینک مراجعه کنید. نکته: اگر ترجیح می دهید، می توانید از Go playground in “Go dev branch” mode برای ویرایش و اجرای برنامه خود استفاده کنید.\n6.1.3 پیش نیازها # نصب Go 1.18 یا بالاتر. برای دستورالعمل‌های نصب، به راهنمای نصب Go مراجعه کنید. ابزاری برای ویرایش کد: هر ویرایشگر متنی که داشته باشید به خوبی کار خواهد کرد. یک ترمینال فرمان Go: با استفاده از هر ترمینال در لینوکس و مک و در PowerShell یا cmd در ویندوز به خوبی کار می کند. 6.1.4 ساخت فولدر پروژه # برای شروع ، یک پوشه برای کدی که می نویسید ایجاد کنید.\n1- یک command prompt را باز کنید و به مسیر دلخواه خود تغییر دهید.\nدر لینوکس یا مک:On Linux or Mac:\n$ cd در ویندوز:\n1C:\\\u0026gt; cd %HOMEPATH% در ادامه آموزش علامت $ را به عنوان درخواست نشان می دهد. دستوراتی که استفاده می کنید در ویندوز نیز کار می کنند.\n2- از terminal یک دایرکتوری برای کد خود به نام generics ایجاد کنید.\n$ mkdir generics $ cd generics 3- یک ماژول برای نگهداری کد خود ایجاد کنید. دستور go mod init را اجرا کنید و مسیر ماژول کد جدید خود را به آن بدهید.\n1$ go mod init example/generics 2go: creating new go.mod: module example/generics نکته: برای کد production، یک مسیر ماژول را مشخص می‌کنید که بیشتر به نیازهای شما اختصاص دارد. برای اطلاعات بیشتر، حتما به مدیریت وابستگی ها مراجعه کنید.\nدر مرحله بعد، چند کد ساده برای کار با maps اضافه می کنید.\n6.1.5 اضافه کردن توابع non-generic # در این مرحله، دو تابع اضافه می‌کنید که هر کدام مقادیر یک map را با هم جمع کرده و مقدار کل را برمی‌گرداند. شما به جای یکی، دو تابع را declaration می کنید زیرا با دو نوع مختلف map کار می کنید: یکی که مقادیر int64 را ذخیره می کند و دیگری که مقادیر float64 را ذخیره می‌کند.\nنوشتن کد:\n1- با استفاده از ویرایشگر متن خود، فایلی به نام main.go در دایرکتوری generic ایجاد کنید. شما کد Go خود را در این فایل می نویسید.\n2- در main.go، در بالای فایل، package declaration زیر را قرار دهید.\npackage main\nیک برنامه مستقل (برخلاف یک library) همیشه در package main است.\n3- در زیر package declaration، دو اعلان تابع زیر را بچسبانید.\n1// SumInts adds together the values of m. 2func SumInts(m map[string]int64) int64 { 3 var s int64 4 for _, v := range m { 5 s += v 6 } 7 return s 8} 9 10// SumFloats adds together the values of m. 11func SumFloats(m map[string]float64) float64 { 12 var s float64 13 for _, v := range m { 14 s += v 15 } 16 return s 17} در این کد:\nدو تابع را برای جمع کردن مقادیر یک map و برگرداندن جمع اعلام کنید.\nتابع SumFloats یک map از نوع string را به مقادیر float64 می گیرد. تابع SumInts یک map از نوع string را به مقادیر int64 می گیرد. 4- در بالای main.go، در زیر اعلان package، تابع اصلی زیر را برای مقداردهی اولیه دو map قرار دهید و هنگام فراخوانی توابعی که در مرحله قبل اعلام کردید، از آنها به عنوان آرگومان استفاده کنید.\n1func main() { 2 // Initialize a map for the integer values 3 ints := map[string]int64{ 4 \u0026#34;first\u0026#34;: 34, 5 \u0026#34;second\u0026#34;: 12, 6 } 7 8 // Initialize a map for the float values 9 floats := map[string]float64{ 10 \u0026#34;first\u0026#34;: 35.98, 11 \u0026#34;second\u0026#34;: 26.99, 12 } 13 14 fmt.Printf(\u0026#34;Non-Generic Sums: %v and %v\\n\u0026#34;, 15 SumInts(ints), 16 SumFloats(floats)) 17} در این کد:\nیک map از مقادیر float64 و یک map از مقادیر int64 را راه اندازی کنید که هر کدام دارای دو ورودی است. برای یافتن مجموع مقادیر هر map، دو تابعی را که قبلاً اعلام کردید، فراخوانی کنید. نتیجه را چاپ کنید. 5- در نزدیکی و بالای main.go، درست در زیر package declaration، همیشه بسته‌ای را که برای پشتیبانی از کدی که نوشتید، وارد کنید.\nاولین خطوط کد باید به شکل زیر باشد:\npackage main import \u0026#34;fmt\u0026#34; 6- فایل main.go ذخیره کنید.\nاجرای کد\nاز خط فرمان در دایرکتوری حاوی main.go، کد را اجرا کنید.\n$ go run . Non-Generic Sums: 46 and 62.97 با ژنریک، می توانید به جای دو تابع، یک تابع را در اینجا بنویسید. در مرحله بعد، یک تابع کلی برای نقشه‌های حاوی مقادیر صحیح یا شناور اضافه می‌کنید.\n6.1.6 اضافه کردن تابع ژنریک برای استفاده از تایپ‌های مختلف # با generics، می توانید به جای دو تابع، یک تابع را در اینجا بنویسید. در مرحله بعد، یک تابع کلی برای mapهای حاوی مقادیر صحیح یا شناور اضافه می‌کنید.\nبرای پشتیبانی از مقادیر هر type، آن تابع منفرد به روشی نیاز دارد تا type هایی را که پشتیبانی می کند، اعلام یا declare کند. از سوی دیگر، کد فراخوانی به روشی نیاز دارد تا مشخص کند که آیا با یک map عدد صحیح یا شناور ارتباط می‌گیرد.\nبرای این منظور تابعی می نویسید که علاوه بر پارامترهای تابع معمولی، پارامترهای type را نیز اعلام می کند. این پارامترهای type، تابع را generic می‌کنند و آن را قادر می‌سازند با آرگومان‌هایی از typeهای مختلف کار کند درنهایت شما تابع را با آرگومان های type و آرگومان های تابع معمولی(ordinary) فراخوانی خواهید کرد.\nهر پارامتر type دارای یک type constraint (محدودیت نوع) است که به عنوان meta-type برای پارامتر type اثر می کند. هر type constraint، در واقع type arguments مجاز را مشخص می کند که کد فراخوانی می تواند برای type arguments مربوطه استفاده کند.\nدر حالی که محدودیت یک type parameter معمولاً مجموعه‌ای از types را نشان می‌دهد، در زمان کامپایل، پارامتر نهایی به صورت single type است - typeی که به عنوان type argument توسط کد فراخوان ارائه می‌شود. اگر type argument مورد استفاده type توسط محدودیت type parameter مجاز نباشد، کد کامپایل نخواهد شد.\nبه خاطر داشته باشید که یک type argument باید از تمام عملیاتی که کد generic روی آن انجام می‌دهد پشتیبانی کند. به عنوان مثال، اگر کد تابع شما سعی کند عملیات string ای (مانند indexing) را روی یک type parameter که محدودیت آن شامل انواع عددی است انجام دهد، کد کامپایل نمی شود.\nدر کدی که می خواهید بنویسید، از محدودیتی استفاده خواهید کرد که به type عدد صحیح یا شناور اجازه می دهد.\nنوشتن کد: 1- در زیر دو تابعی که قبلا اضافه کردید، generic function زیر را قرار دهید.\n1// SumIntsOrFloats sums the values of map m. It supports both int64 and float64 2// as types for map values. 3func SumIntsOrFloats[K comparable, V int64 | float64](m map[K]V) V { 4 var s V 5 for _, v := range m { 6 s += v 7 } 8 return s 9} در این کد:\nیک تابع SumIntsOrFloats با دو پارامتر نوع (داخل پرانتز)، K و V، و یک آرگومان که ازtype parameters است و m از نوع map[K]V استفاده می‌کند، تعریف شده. تابع مقداری از نوع V را برمی گرداند. برای پارامتر نوع K محدودیت type parameter را جهت مقایسه مشخص شده و به طور خاص برای مواردی مانند این در نظر گرفته شده است، محدودیت قابل مقایسه در Go از قبل اعلام شده است. این اجازه می دهد تا هر نوع که مقادیر آن ممکن است به عنوان عملوند از عملگرهای مقایسه == و != استفاده شود همینطور در زبان Go مستلزم این است که map keys قابل مقایسه باشند. بنابراین اعلام K به عنوان پارامتر قابل مقایسه ضروری است تا بتوانید از K به عنوان کلید در map variable استفاده کنید. همچنین تضمین می کند که کد فراخوانی از یک type مجاز برای map keys استفاده می کند. برای پارامتر نوع V محدودیتی را مشخص کنید که ترکیبی از دو type است: int64 و float64. با استفاده از علامت « | » اتحادی از این دو نوع type را مشخص می کند، به این معنی که این محدودیت اجازه می دهد تا هر type اجرا شود. کامپایلر به عنوان آرگومان در کد فراخوانی شده به هر کدام از typeها را اجازه فعالیت می‌دهد. مشخص کنید که آرگومان m از نوع map[K]V باشد، که در آن K و V تایپ‌هایی هستند که از قبل برای type parameters مشخص شده‌اند. توجه داشته باشید که می دانیم map[K]V یک نوع map معتبر است زیرا K یک نوع type مقایسه است. اگر K را قابل مقایسه اعلام نکرده بودیم، کامپایلر ارجاع به map[K]V را رد می کرد. 2- در main.go، در کنار کدی که از قبل نوشتید، کد زیر را اضافه کنید:\n1fmt.Printf(\u0026#34;Generic Sums: %v and %v\\n\u0026#34;, 2 SumIntsOrFloats[string, int64](ints), 3 SumIntsOrFloats[string, float64](floats)) در این کد موارد زیر رو داریم:\nبا فراخوانی کردن generic function که تعریف کردید تمام maps هایی که ایجاد کردید را pass کنید. همیشه type arguments را مشخص کنید - type names موجود درsquare brackets - در مورد types مختلفی که باید type parameters را در عملکردی که فراخوانی میشود جایگزین کنید. همانطور که در بخش بعدی مشاهده خواهید کرد، اغلب می توانید type arguments را در function call حذف کنید. Go اغلب می تواند آنها را از کد شما ویش بینی کند. مقدار sums returned رو پرینت کنید. اجرای کد:\n1$ go run . 2Non-Generic Sums: 46 and 62.97 3Generic Sums: 46 and 62.97 برای اجرای کد باید در هر فراخوانی، کامپایلر type parameters را با typeهای مشخص شده در آن فراخوانی جایگزین می‌کند.\nدر فراخوانی generic function که نوشته‌اید، type arguments را مشخص کرده‌اید که به کامپایلر می‌گویند از چه typeهایی به جای type parameterهای تابع استفاده کند. همانطور که در بخش بعدی خواهید دید، در بسیاری از موارد می توانید این نوع آرگومان ها را حذف کنید زیرا کامپایلر می تواند آنها را پیش‌بینی کند.\n6.1.7 حذف تایپ آرگومان تابع در زمان استفاده از تابع ژنریک # در این بخش، یک نسخه تغییر یافته از فراخوانی تابع generic را اضافه می‌کنید و یک تغییر کوچک برای ساده کردن کد فراخوانی ایجاد می‌کنید. شما type arguments را که در این مورد مورد نیاز نیستند، حذف خواهید کرد.\nوقتی کامپایلر Go می تواند typeهای را که می خواهید استفاده کنید پیش‌بینی کند، می توانید type argumentsها را در فراخوانی کد حذف کنید. کامپایلر type arguments را از typeهای function argument پیش بینی می کند.\nتوجه داشته باشید که این همیشه امکان پذیر نیست. به عنوان مثال، اگر شما نیاز به فراخوانی یک تابع generic دارید که هیچ آرگومان ندارد، باید type argumentها را در فراخوانی تابع قرار دهید.\nنوشتن کد:\nدر main.go، در کنار کدی که از قبل نوشتید، کد زیر را اضافه کنید:\n1fmt.Printf(\u0026#34;Generic Sums, type parameters inferred: %v and %v\\n\u0026#34;, 2 SumIntsOrFloats(ints), 3 SumIntsOrFloats(floats)) در مرحله بعد، تابع را با گرفتن اشتراک اعداد صحیح و شناور در یک محدودیت type که می توانید مجدداً استفاده کنید، مانند کدهای دیگر، ساده‌تر می کنید.\nDeclare a type constraint # در این بخش آخر ، محدودیتی را که قبلاً تعریف کرده اید به interface منتقل خواهید کرد تا بتوانید از آن در چندین جای مختلف از برنامه استفاده مجدد کنید. اعلام محدودیت ها از این طریق به ساده سازی کد کمک می کند ، مانند زمانی که یک constraint پیچیدگی بیشتری دارد.\nشما یک type constraint را به عنوان یک interface اعلام می کنید. این محدودیت اعمال شده به هر type اجرای interface منحصر به فردی را اجازه می دهد. به عنوان مثال ، اگر type constraint interface را با سه متد تعریف کنید، از آن با یک type arguments در یک generic function استفاده کنید ، type arguments استفاده شده برای call the function باید دارای تمام این متد ها باشند.\nهمینطور Constraint interfaces نیز می توانند به typeهای خاصی مراجعه کنند ، همانطور که در این بخش مشاهده خواهید کرد.\nنوشتن کد: 1- درست بالای main، بلافاصله بعد از دستورهای import، کد زیر را برای اعلام یک type constraint قرار دهید.\n1type Number interface { 2 int64 | float64 3} در این کد:\nباید شماره interface type را برای استفاده به عنوان یک type constraint اعلام کنید. اشتراک int64 و float64 را در داخل interface اعلام کنید. در اصل، شما اشتراک را از function declaration به یک type constraint جدید منتقل می‌کنید. به این ترتیب، هنگامی که می خواهید یک پارامتر نوع را به int64 یا float64 محدود کنید، می توانید از این Number به صورت type constraint به جای نوشتن int64 | float64 استفاده کنید.\n2 - در زیر توابعی که از قبل دارید، تابع SumNumbers که از نوع generic در زیر را جای‌گذاری کنید.\n1// SumNumbers sums the values of map m. It supports both integers 2// and floats as map values. 3func SumNumbers[K comparable, V Number](m map[K]V) V { 4 var s V 5 for _, v := range m { 6 s += v 7 } 8 return s 9} در این کد :\nیک تابع generic را با همان منطق تابع generic که قبلاً اعلام کرده بودید، اما با interface type جدید به جای union به عنوان type constraint، اعلام کنید. مانند قبل، از پارامترهای type برای انواع حالت های آرگومان و بازگشت استفاده می کنید.\n3 - در main.go زیر کدی که از قبل دارید، کد زیر را قرار دهید.\n1fmt.Printf(\u0026#34;Generic Sums with Constraint: %v and %v\\n\u0026#34;, 2 SumNumbers(ints), 3 SumNumbers(floats)) در این کد:\nهمیشه SumNumbers را با هر map فراخوانی کنید و sum را از مقادیر هر یک از اجزا چاپ کنید. مانند بخش قبل، در فراخوانی generic function، مقدار type آرگومان (type names in square brackets) را حذف می کنید. کامپایلر Go می تواند آرگومان نوع را از آرگومان های دیگر تشخیص دهد.\nاجرای کد: از خط فرمان در دایرکتوری حاوی main.go، کد را اجرا کنید.\n$ go run . Non-Generic Sums: 46 and 62.97 Generic Sums: 46 and 62.97 Generic Sums, type parameters inferred: 46 and 62.97 Generic Sums with Constraint: 46 and 62.97 در نتیجه:\nبه خوبی انجام شد! بلاخره شما کار با generic ها در Go یاد گرفتید.\nموضوعات پیشنهادی بعدی:\nاستفاده از Go Tour یک معرفی گام به گام عالی برای اصول Go است. بهترین شیوه های مفید Go را که در Effective Go و How to write Go code توضیح داده شده است، خواهید یافت. کد نهایی: می توانید این برنامه را درGo playground اجرا کنید. درGo playground به سادگی روی دکمه Run کلیک کنید.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type Number interface { 6 int64 | float64 7} 8 9func main() { 10 // Initialize a map for the integer values 11 ints := map[string]int64{ 12 \u0026#34;first\u0026#34;: 34, 13 \u0026#34;second\u0026#34;: 12, 14 } 15 16 // Initialize a map for the float values 17 floats := map[string]float64{ 18 \u0026#34;first\u0026#34;: 35.98, 19 \u0026#34;second\u0026#34;: 26.99, 20 } 21 22 fmt.Printf(\u0026#34;Non-Generic Sums: %v and %v\\n\u0026#34;, 23 SumInts(ints), 24 SumFloats(floats)) 25 26 fmt.Printf(\u0026#34;Generic Sums: %v and %v\\n\u0026#34;, 27 SumIntsOrFloats[string, int64](ints), 28 SumIntsOrFloats[string, float64](floats)) 29 30 fmt.Printf(\u0026#34;Generic Sums, type parameters inferred: %v and %v\\n\u0026#34;, 31 SumIntsOrFloats(ints), 32 SumIntsOrFloats(floats)) 33 34 fmt.Printf(\u0026#34;Generic Sums with Constraint: %v and %v\\n\u0026#34;, 35 SumNumbers(ints), 36 SumNumbers(floats)) 37} 38 39// SumInts adds together the values of m. 40func SumInts(m map[string]int64) int64 { 41 var s int64 42 for _, v := range m { 43 s += v 44 } 45 return s 46} 47 48// SumFloats adds together the values of m. 49func SumFloats(m map[string]float64) float64 { 50 var s float64 51 for _, v := range m { 52 s += v 53 } 54 return s 55} 56 57// SumIntsOrFloats sums the values of map m. It supports both floats and integers 58// as map values. 59func SumIntsOrFloats[K comparable, V int64 | float64](m map[K]V) V { 60 var s V 61 for _, v := range m { 62 s += v 63 } 64 return s 65} 66 67// SumNumbers sums the values of map m. Its supports both integers 68// and floats as map values. 69func SumNumbers[K comparable, V Number](m map[K]V) V { 70 var s V 71 for _, v := range m { 72 s += v 73 } 74 return s 75} "},{"id":85,"href":"/chapter-7/","title":"فصل هفتم: تست نویسی","section":"صفحه اصلی","content":"در این فصل به مباحث تست نویسی در زبان گو میپردازیم\u0026hellip;\n"},{"id":86,"href":"/chapter-7/go-test/","title":"7.1 پکیج testify","section":"فصل هفتم: تست نویسی","content":"یک کتابخانه مهم برای تست نویسی در زبان گو Testify هست که در زیر به توضیح اون می‌پردازیم. آدرس این کتابخانه در این لینک هست. به طور کلی زبان برنامه نویسی Go دارای یک framework تست سبک وزن است که از دستور go test و testing package تشکیل شده است.\nشما با ایجاد یک فایل با نامی که به test.goـ ختم می شود، یک test می نویسید که حاوی توابعی به نام TestXXX با signature func به صورت (t *testing.T) است. framework تست هر یک از این تابع ها را اجرا می کند. اگر تابع یک تابع شکست مانند t.Error یا t.Fail را فراخوانی کند، آزمایش ناموفق در نظر گرفته می شود. با ایجاد فایل HOME/hello/morestrings/reverse_test.go حاوی کد Go زیر، یک تست به پکیج morestrings اضافه کنید.\n1package morestrings 2 3import \u0026#34;testing\u0026#34; 4 5func TestReverseRunes(t *testing.T) { 6 cases := []struct { 7 in, want string 8 }{ 9 {\u0026#34;Hello, world\u0026#34;, \u0026#34;dlrow ,olleH\u0026#34;}, 10 {\u0026#34;Hello, 世界\u0026#34;, \u0026#34;界世 ,olleH\u0026#34;}, 11 {\u0026#34;\u0026#34;, \u0026#34;\u0026#34;}, 12 } 13 for _, c := range cases { 14 got := ReverseRunes(c.in) 15 if got != c.want { 16 t.Errorf(\u0026#34;ReverseRunes(%q) == %q, want %q\u0026#34;, c.in, got, c.want) 17 } 18 } 19} و تست را با کد زیر اجرا کنید.\n1$ cd $HOME/hello/morestrings 2 3$ go test 4 5PASS 6 7ok example/user/hello/morestrings 0.165s 8 9$ همینطور golang مجموعه‌ای از پکیج‌ها با ابزارهای زیادی برای اثبات کردن اینکه کد شما همانطور که می‌خواهید عمل خواهد کرد، فراهم می‌کند.\nاین ابزارها عبارتند از:\nEasy assertions Mocking Testing suite interfaces and functions Installation # به راحتی testity را با یک خط کد نصب کنید، یا آن را با خط دیگری به روز کنید.\n1go get github.com/stretchr/testify سپس بسته های زیر را در دسترس شما قرار می دهد:\n1github.com/stretchr/testify/assert 2 3github.com/stretchr/testify/require 4 5github.com/stretchr/testify/mock 6 7github.com/stretchr/testify/suite 8 9github.com/stretchr/testify/http (deprecated) همینطور package به عنوان testify/assert رو به کد اضافه کنید.\n1package yours 2 3import ( 4\u0026#34;testing\u0026#34; 5 6\u0026#34;github.com/stretchr/testify/assert\u0026#34; 7 8) 9 10func TestSomething(t *testing.T) { 11 12assert.True(t, true, \u0026#34;True is true!\u0026#34;) 13 14} 7.1.1 assert package # ابزار assert روش‌های مفیدی را ارائه می‌کند که به شما امکان می‌دهد کد تست بهتری را در Go بنویسید. به عنوان مثال:\nدلیل شکست برنامه را عالی و خوانا را پرینت کنید خوانا بودن و درک راحت کد را ساده کنید. به صورت اختیاری هر assertion را با یک پیام حاشیه نویسی کنید حالت زیر را در نظر بگیرید:\n1package yours 2 3 4 5import ( 6 7\u0026#34;testing\u0026#34; 8 9\u0026#34;github.com/stretchr/testify/assert\u0026#34; 10 11) 12 13func TestSomething(t *testing.T) { 14 15// assert equality 16 17assert.Equal(t, 123, 123, \u0026#34;they should be equal\u0026#34;) 18 19 20// assert inequality 21 22assert.NotEqual(t, 123, 456, \u0026#34;they should not be equal\u0026#34;) 23 24 25// assert for nil (good for errors) 26 27assert.Nil(t, object) 28 29 30// assert for not nil (good when you expect something) 31 32if assert.NotNil(t, object) { 33 34 35// now we know that object isn\u0026#39;t nil, we are safe to make 36 37// further assertions without causing any errors 38 39assert.Equal(t, \u0026#34;Something\u0026#34;, object.Value) 40 41 42\t} 43 44 45} هر تابع assert شی testing.T را به عنوان اولین آرگومان می گیرد، به این صورت است که خطاها را از طریق قابلیت های go test می نویسد.\nهر تابع assert یک bool برمی‌گرداند که نشان می‌دهد آیا assert موفقیت‌آمیز بوده است یا خیر، این برای شرایطی مفید است که می‌خواهید تحت شرایط خاصی به assertion بیشتر ادامه دهید.\nاگر بارها assert می کنید، از موارد زیر استفاده کنید:\n1package yours 2 3 4 5import ( 6 7\u0026#34;testing\u0026#34; 8 9\u0026#34;github.com/stretchr/testify/assert\u0026#34; 10 11) 12 13 14 15func TestSomething(t *testing.T) { 16 17assert := assert.New(t) 18 19 20 21// assert equality 22 23assert.Equal(123, 123, \u0026#34;they should be equal\u0026#34;) 24 25 26 27// assert inequality 28 29assert.NotEqual(123, 456, \u0026#34;they should not be equal\u0026#34;) 30 31 32 33// assert for nil (good for errors) 34 35assert.Nil(object) 36 37 38 39// assert for not nil (good when you expect something) 40 41if assert.NotNil(object) { 42 43 44 45// now we know that object isn\u0026#39;t nil, we are safe to make 46 47// further assertions without causing any errors 48 49assert.Equal(\u0026#34;Something\u0026#34;, object.Value) 50 51\t} 52 53} 7.1.2 require package # بسته require همان توابع سراسری را ارائه می‌کند که بسته assert داراست، اما به جای برگرداندن یک نتیجه boolean، تست فعلی را terminate می‌کند.\nبرای توضیح بیشتر در این مورد باید گزینه t.FailNow را برررسی کنی. FailNow عملکرد را به‌عنوان ناموفق علامت‌گذاری می‌کند و اجرای آن را با فراخوانی runtime.Goexit متوقف می‌کند (که سپس همه calls معوق را در گوروتین فعلی اجرا می‌کند). همینطور اجرای تست‌های بعد از این مورد ادامه خواهد داشت. FailNow باید از گوروتینی که تست یا تابع benchmark را اجرا می کند فراخوانی شود، نه از دیگر گوروتین های ایجاد شده در طول تست. فراخوانی FailNow دیگر برنامه‌ها را متوقف نمی‌کند.\n7.1.3 mock package # به طور کلی Mock یا Mocking یک تکنیک تست نویسی است که در آن قسمتی از کد را با یک پیاده سازی دلخواه جایگزین میشه و باعث شبیه سازی قسمت هایی از برنامه به جای اجرای حالت های واقعی بشه.\nهمیشه Mocking زمانی استفاده میشه که یک متد یا کلاس، وابستگی یا وابستگی هایی داره که توی تست‌ها ایجاد مشکل میکنه.\nمثلا یک سرویس رو باید تست کنیم که داخل اون از سرویس notification_sender استفاده شده یعنی به سرویس یا کلاس notification_sender وابستگی داره، درنتیجه هربار که اون تست رو انجام میدید یه notification هم ارسال میشه که این کار درست نیست\nدر این صورت میایم و سرویس یا کلاس notification_sender رو Mock میکنیم که دیگه notification ارسال نکنه ولی جواب رو true رو برگردونه گه این به معنی درست کار کردن بخش مورد نظر سیستم هست.\nاین باعث میشه گه بتونیم عملکر صحیح همون متد رو تست کنیم به جای اینکه تست مون را درگیر و وابسته به عوامل دیگه مثل ارسال notification کنیم.\nحالا بر میگردم به پیاده سازی این مکانیزم در زبان گو\nدر واقع Package mock سیستمی را ارائه می دهد که توسط آن می توان object ها را mock کرد و تأیید کرد که فراخوانی ها همانطور که انتظار می رود انجام می شوند.\nبسته mock مکانیزمی را برای نوشتن آسان اشیاء mock فراهم می کند که می تواند در هنگام نوشتن کد آزمایشی به جای اشیاء واقعی استفاده شود.\nهمیشه Package mock یک شی به نام Mock را ارائه می دهد که فعالیت را در یک شی دیگر دنبال می کند. معمولاً مطابق کد زیر در یک شیء آزمایشی تعبیه می شود:\n1type MyTestObject struct { 2// add a Mock object instance 3mock.Mock 4// other fields go here as normal 5} هنگام پیاده سازی متدهای یک interface، توابع خود را برای فراخوانی متد Mock.Called(args\u0026hellip;) مرتبط می کنید و مقادیر مناسب را برمی گردانید.\nبه عنوان مثال، برای mock کردن یک متد که نام و سن یک فرد را ذخیره می کند و سال تولد را به همراه یک خطا را برمی گرداند، می توانید این کد را بنویسید:\n1func (o *MyTestObject) SavePersonDetails(firstname, lastname string, age int) (int, error) { 2 3args := o.Called(firstname, lastname, age) 4 5return args.Int(0), args.Error(1) 6 7} متدهای Int، Error و Bool نمونه‌هایی از strongly typed getters هستند که موقعیت index آرگومان را می‌گیرند. با توجه به این لیست argument:\n1(12, true, \u0026#34;Something\u0026#34;) شما می توانید آنها را با strongly typed مانند این بخوانید:\n1args.Int(0) 2args.Bool(1) 3args.String(2) برای اشیاء از type مورد نظر، از روش generic مثل Arguments.Get(index) استفاده کنید و یک type assertion ایجاد کنید:\n1return args.Get(0).(*MyObject), args.Get(1).(*AnotherObjectOfMine) این ممکن است باعث panic شود اگر شیئی که دریافت می کنید nil باشد (تعریف type assertion ناموفق خواهد بود)، در این موارد ابتدا باید nil را بررسی کنید. یک تابع تست نمونه که قطعه کدی را که به یک شی خارجی testObj متکی است test می کند، می تواند موارد مورد نظر testify و assert را طوری تنظیم کند که به نظر واقعاً چنین رفتاری در برنامه رخ داده است. به عنوان مثال کد زیر:\n1package yours 2 3 4 5import ( 6 7\u0026#34;testing\u0026#34; 8 9\u0026#34;github.com/stretchr/testify/mock\u0026#34; 10 11) 12 13 14 15/* 16 17Test objects 18 19*/ 20 21 22 23// MyMockedObject is a mocked object that implements an interface 24 25// that describes an object that the code I am testing relies on. 26 27type MyMockedObject struct{ 28 29mock.Mock 30 31} 32 33 34 35// DoSomething is a method on MyMockedObject that implements some interface 36 37// and just records the activity, and returns what the Mock object tells it to. 38 39// 40 41// In the real object, this method would do something useful, but since this 42 43// is a mocked object - we\u0026#39;re just going to stub it out. 44 45// 46 47// NOTE: This method is not being tested here, code that uses this object is. 48 49func (m *MyMockedObject) DoSomething(number int) (bool, error) { 50 51 52 53args := m.Called(number) 54 55return args.Bool(0), args.Error(1) 56 57 58 59} 60 61 62 63/* 64 65Actual test functions 66 67*/ 68 69 70 71// TestSomething is an example of how to use our test object to 72 73// make assertions about some target code we are testing. 74 75func TestSomething(t *testing.T) { 76 77 78 79// create an instance of our test object 80 81testObj := new(MyMockedObject) 82 83 84 85// setup expectations 86 87testObj.On(\u0026#34;DoSomething\u0026#34;, 123).Return(true, nil) 88 89 90 91// call the code we are testing 92 93targetFuncThatDoesSomethingWithObj(testObj) 94 95 96 97// assert that the expectations were met 98 99testObj.AssertExpectations(t) 100 101 102 103 104} 105 106 107 108// TestSomethingWithPlaceholder is a second example of how to use our test object to 109 110// make assertions about some target code we are testing. 111 112// This time using a placeholder. Placeholders might be used when the 113 114// data being passed in is normally dynamically generated and cannot be 115 116// predicted beforehand (eg. containing hashes that are time sensitive) 117 118func TestSomethingWithPlaceholder(t *testing.T) { 119 120 121 122// create an instance of our test object 123 124testObj := new(MyMockedObject) 125 126 127 128// setup expectations with a placeholder in the argument list 129 130testObj.On(\u0026#34;DoSomething\u0026#34;, mock.Anything).Return(true, nil) 131 132 133 134// call the code we are testing 135 136targetFuncThatDoesSomethingWithObj(testObj) 137 138 139 140// assert that the expectations were met 141 142testObj.AssertExpectations(t) 143 144 145 146 147} 148 149 150 151// TestSomethingElse2 is a third example that shows how you can use 152 153// the Unset method to cleanup handlers and then add new ones. 154 155func TestSomethingElse2(t *testing.T) { 156 157 158 159// create an instance of our test object 160 161testObj := new(MyMockedObject) 162 163 164 165// setup expectations with a placeholder in the argument list 166 167mockCall := testObj.On(\u0026#34;DoSomething\u0026#34;, mock.Anything).Return(true, nil) 168 169 170 171// call the code we are testing 172 173targetFuncThatDoesSomethingWithObj(testObj) 174 175 176 177// assert that the expectations were met 178 179testObj.AssertExpectations(t) 180 181 182 183// remove the handler now so we can add another one that takes precedence 184 185mockCall.Unset() 186 187 188 189// return false now instead of true 190 191testObj.On(\u0026#34;DoSomething\u0026#34;, mock.Anything).Return(false, nil) 192 193 194 195testObj.AssertExpectations(t) 196 197} برای اطلاعات بیشتر در مورد نحوه نوشتن کد mock، اسناد API را برای mock package بررسی کنید.\nمی‌توانید از mockery tool برای تولید خودکار کد ساختگی در برابر یک interface نیز استفاده کنید و استفاده از mockها را بسیار سریع‌تر کنید.\n7.1.4 suite package # بسته‌ی suite قابلیت‌هایی را فراهم می‌کند که شما ممکن است از زبان‌های شی گرا متداول آنها را استفاده کنید. با استفاده از این بسته، شما می‌توانید یک مجموعه test را به عنوان یک ساختار بسازید، روش‌های setup/teardown را برای ساختار خود بسازید و روش‌های test را روی ساختار خود اجرا کنید و با استفاده از \u0026lsquo;go test\u0026rsquo; به طور معمول اجرا کنید.\nیک مثال از مجموعه آزمون به شرح زیر است:\n1// Basic imports 2 3import ( 4 5\u0026#34;testing\u0026#34; 6 7\u0026#34;github.com/stretchr/testify/assert\u0026#34; 8 9\u0026#34;github.com/stretchr/testify/suite\u0026#34; 10 11) 12 13 14 15// Define the suite, and absorb the built-in basic suite 16 17// functionality from testify - including a T() method which 18 19// returns the current testing context 20 21type ExampleTestSuite struct { 22 23suite.Suite 24 25VariableThatShouldStartAtFive int 26 27} 28 29 30 31// Make sure that VariableThatShouldStartAtFive is set to five 32 33// before each test 34 35func (suite *ExampleTestSuite) SetupTest() { 36 37suite.VariableThatShouldStartAtFive = 5 38 39} 40 41 42 43// All methods that begin with \u0026#34;Test\u0026#34; are run as tests within a 44 45// suite. 46 47func (suite *ExampleTestSuite) TestExample() { 48 49assert.Equal(suite.T(), 5, suite.VariableThatShouldStartAtFive) 50 51} 52 53 54 55// In order for \u0026#39;go test\u0026#39; to run this suite, we need to create 56 57// a normal test function and pass our suite to suite.Run 58 59func TestExampleTestSuite(t *testing.T) { 60 61suite.Run(t, new(ExampleTestSuite)) 62 63} رای یک مثال کامل‌تر و استفاده از تمامی قابلیت‌های فراهم شده توسط suite package، به مجموعه test مثال ما نگاه کنید.\nبرای کسب اطلاعات بیشتر در مورد نوشتن مجموعه‌های test، به مستندات API مربوط suite package مراجعه کنید.\nشیء Suite شامل متدهای assertion است:\n1// Basic imports 2 3import ( 4 5\u0026#34;testing\u0026#34; 6 7\u0026#34;github.com/stretchr/testify/suite\u0026#34; 8 9) 10 11 12 13// Define the suite, and absorb the built-in basic suite 14 15// functionality from testify - including assertion methods. 16 17type ExampleTestSuite struct { 18 19suite.Suite 20 21VariableThatShouldStartAtFive int 22 23} 24 25 26 27// Make sure that VariableThatShouldStartAtFive is set to five 28 29// before each test 30 31func (suite *ExampleTestSuite) SetupTest() { 32 33suite.VariableThatShouldStartAtFive = 5 34 35} 36 37 38 39// All methods that begin with \u0026#34;Test\u0026#34; are run as tests within a 40 41// suite. 42 43func (suite *ExampleTestSuite) TestExample() { 44 45suite.Equal(suite.VariableThatShouldStartAtFive, 5) 46 47} 48 49 50 51// In order for \u0026#39;go test\u0026#39; to run this suite, we need to create 52 53// a normal test function and pass our suite to suite.Run 54 55func TestExampleTestSuite(t *testing.T) { 56 57suite.Run(t, new(ExampleTestSuite)) 58 59} "},{"id":87,"href":"/chapter-8/","title":"فصل هشتم: پکیج های استاندارد","section":"صفحه اصلی","content":"در این فصل به مباحث پکیج های استاندارد در زبان گو میپردازیم\u0026hellip;\n"},{"id":88,"href":"/chapter-9/","title":"فصل نهم: الگوهای طراحی","section":"صفحه اصلی","content":"در این فصل، به مباحث الگوهای طراحی در زبان گو می‌پردازیم و سعی می‌کنیم به طور کلی و با مثال‌های مناسب، هر الگو را به شما آموزش دهیم و همچنین برخی از کاربردهای الگوها را نام ببریم.\nالگوی طراحی چیست؟ # الگوهای طراحی ، به عنوان راه‌حل‌های معمول برای مسائلی که در طراحی نرم‌افزار به طور متداول رخ می‌دهند، استفاده می‌شوند. آنها دستورالعمل‌هایی پیش‌فرض هستند که می‌توانید برای حل یک مسئله تکراری در کد خود استفاده کنید.\nچرا باید الگوهای طراحی را یاد بگیریم؟ # الگوهای طراحی، به شما کدهای برنامه برای حل یک مسئله ارائه نمی‌دهند. بلکه، آنها یک مفهوم کلی را برای حل یک مسئله در اختیار شما قرار می‌دهند و بر عهده شماست که این مفهوم را چگونه در برنامه خود پیاده‌سازی کنید.\nالگوهای طراحی، یک زبان مشترک را تعریف می‌کنند تا شما بتوانید با سایر توسعه‌دهندگان به طور موثرتری ارتباط برقرار کنید. به عنوان مثال، می‌توانید به هم‌تیمی خود بگویید: \u0026ldquo;می‌توانی این مسئله را با استفاده از الگوی سینگلتون حل کنی.\u0026rdquo; و او همه ایده‌های پشت این الگو را درک خواهد کرد، بدون اینکه نیاز به توضیح اضافی داشته باشید.\nبسیار مهم است، از الگوهای طراحی زمانی استفاده کنید که واقعاً نیاز دارید. این امر دقت و درک دقیق از مسئله و نیازهای طراحی شما را می‌طلبد. این موضوع کمک می‌کند تا شما کد قابل نگهداری ، قابل توسعه و خوانا توسعه دهید و همچنین از تجربه و دانش جمعی الگوها بهره‌برداری کنید. در نتیجه، درست استفاده کردن از الگوهای طراحی می‌تواند بهبود قابل توجهی در کیفیت و عملکرد برنامه شما ایجاد کند. طبقه‌بندی الگوهای طراحی # الگوهای طراحی با توجه به پیچیدگی، سطح جزئیات و مقیاس کاربرد در برنامه، متفاوت هستند.\nالگوهای طراحی سازنده مکانیزم‌های ایجاد شیء را ارائه می‌دهند که انعطاف‌پذیری و استفاده مجدد از کد موجود را افزایش می‌دهند. الگوهای طراحی ساختاری چگونگی ترکیب اشیاء و کلاس‌ها را به ساختارهای بزرگتر توضیح می‌دهد، در حالی که این ساختارها انعطاف‌پذیری و کارآمدی خود را حفظ می‌کنند. الگوهای طراحی رفتاری مراقبت از ارتباطات مؤثر و تخصیص مسئولیت‌ها بین اشیاء را بر عهده دارند. "},{"id":89,"href":"/chapter-9/creational-patterns/","title":"9.1 الگوهای طراحی سازنده","section":"فصل نهم: الگوهای طراحی","content":"الگوهای طراحی سازنده\u0026hellip;\n"},{"id":90,"href":"/chapter-9/structural-patterns/","title":"9.2 الگوهای طراحی ساختاری","section":"فصل نهم: الگوهای طراحی","content":"الگوهای طراحی ساختاری\u0026hellip;\n"},{"id":91,"href":"/chapter-9/behavioral-patterns/","title":"9.3 الگوهای طراحی رفتاری","section":"فصل نهم: الگوهای طراحی","content":"الگوهای طراحی رفتاری\u0026hellip;\n"},{"id":92,"href":"/chapter-9/concurrency-patterns/","title":"9.4 الگوهای همزمانی","section":"فصل نهم: الگوهای طراحی","content":" عنوان توضیحات وضعیت Wait For Result با استفاده از الگو Wait For Result می توانید یک عملیاتی را بصورت همزمانی انجام دهید و سپس منتظر نتیجه عملیات صورت گرفته بمانید. برای اینکار از کانال استفاده می شود. ✅ Fan Out/In الگو Fan Out/In یک تکنیک همزمانی در زبان گو می باشد که به شما اجازه می دهد چندین کار را با گوروتین همزمان انجام دهید و در نتیجه خروجی این کارها را با هم ترکیب کنید و به عنوان نتیجه نهایی دریافت کنید. ✅ Wait For Task الگو wait for task یکی از الگوهای رایج در زبان گو می باشد و انتظار برای تکمیل یک تسک یا فرآیند استفاده می شود. یک تسک با استفاده از گوروتین اجرا می شود و پس اتمامش کار تسک از طریق کانال سیگنال انجام می فرستد. ✅ Drop الگو Drop یک الگو مهم برای انجام خدمات سنگین می باشد. خدماتی که مواقعی باعث می شود حجم درخواست هایش بیش از ظرفیت موجود باشد و این درخواست ها بواسطه این الگو می تواند Drop شود. به عنوان مثال سرویس های DNS باید از این الگو استفاده کنند. ✅ Cancellation الگو cancellation که حرکت تکنیکی هست برای ارسال سینگال به گوروتین ها استفاده می شود که باید اجرای کاری را متوقف کند و ایده اصلی این کار با استفاده بستن کانال صورت میگیرد. ✅ Semaphore الگو Semaphore برای مدیریت کنترل دسترسی به منابع مشترک در همزمانی استفاده می شود. فرض کنید بصورت موازی ۱۰۰ درخواست HTTP سمت سرور میاد و I/O شبکه برای پردازش همزمان این ۱۰۰ درخواست درگیر میشود و به مرور عملکرد کاهش می یابد. حال اگر ما بیایم این ۱۰۰ درخواست موازی را تقسیم کنیم به ۵ دسته ۲۰ تایی که بصورت همزمانی انجام شود باعث می شود I/O شبکه کاهش یابد و عملکرد بهتری را خواهیم داشت. ✅ Bounded Work Pooling با استفاده از الگو Bounded Work Pooling امکان محدود سازی تعداد گوروتین ها را براساس کار مشخصی دارید و گوروتین ها را محدود به تعداد دفعات کار مشخص شده محدود می شود. این الگو برای وقت مفید است که شما می خواهید منابع را به یک کار خاص محدود کنید. ✅ Retry Timeout شما از الگو Retry Timeout برای تلاش مجدد یکسری عملیات استفاده کنید. برای اینکار شما می توانید از حلقه و تابع After در پکیج time کمک بگیرید و برای هرتلاش یک timeout مشخص کنید. ✅ Channel Cancellation از کانال ها برای ارتباط بین گوروتین ها و هماهنگ کردن اجرا استفاده می شود. حال گاهی اوقات نیاز است که ما یکسری فرآیند را داخل گوروتین لغو کنیم. در اینجا می توانیم با استفاده از کانال سیگنال لغو کردن بفرستید تا عملیات هایی که گوروتین مورد نظر انجام می داد لغو شود. ✅ Producer-Consumer الگو producer-consumer یکی از کاربردی ترین الگوها در زبان گو می باشد که با استفاده از الگو می توانید بطور همزمان یکسری اطلاعات تولید کنید و بفرستید داخل کانال و این اطلاعات توسط مصرف کننده بواسطه کانال دریافت شود. ✅ Monitor الگوی مانیتور به گروتین‌ ها اجازه می‌دهد هنگام ورود به حالت خواب بدون مسدود کردن اجرا یا مصرف منابع، منتظر شرایط خاصی باشند. ✅ Future در زبان گو الگو Future راهی برای نمایش نتیجه یک عملیات ناهمزمان (asynchronous) است که ممکن است آن عملیات هنوز تکمیل نشده باشد اما این الگو به شما این امکان را می دهد کدی بنویسید که طوری رفتار کند که گویی نتیجه یک عملیات فورا در دسترس است. حتی اگر عملیات در پس زمینه در حال اجرا باشد. ✅ Pipeline الگو خط لوله (Pipeline) یکی از پرکاربردی ترین الگوها در همزمانی می باشد شما با استفاده از این الگو می توانید تسک های بزرگ را به تسک های کوچکتر و مستقل تقسیم کنید که می توانند بطور همزمان کار کنند. هر stage داخل یک گوروتین انجام می شود و بواسطه کانال داده ها بین stage های مختلف منتقل می شود. ✅ Subscription الگو Subscription یکی از الگوهای کاربردی برای پیاده سازی consumer می باشد که به یک آدرسی مشترک شوید و در بازده زمانی مختلف درخواست دهید و یکسری اطلاعات دریافت کنید. ✅ Bridge Channel با استفاده از الگو Bridge Channel می توانید بین ۲ کانال داده ای را منتقل کنید فرض کنید یک داده را به کانال input میفرستید و از دریافت داده آن را می توانید به کانال دیگری منتقل کنید و عملا شما یک پل برای انتقال داده ایجاد کردید. ✅ Queuing الگوی \u0026ldquo;صف\u0026rdquo; در زبان گو الگویی است که در آن از یک گوروتین برای بافر کردن و مدیریت ترتیب مقادیر ارسال شده و دریافت شده از یک کانال استفاده می شود. ✅ "},{"id":93,"href":"/chapter-9/cloud-native-patterns/","title":"9.5 الگوهای Cloud Native","section":"فصل نهم: الگوهای طراحی","content":"الگوهای cloud native\u0026hellip;\n"},{"id":94,"href":"/chapter-9/anti-pattern/","title":"9.6 ضد الگوها (Anti-Patterns)","section":"فصل نهم: الگوهای طراحی","content":"ضد الگوها\n"},{"id":95,"href":"/chapter-10/","title":"فصل دهم: الگوریتم و ساختار داده","section":"صفحه اصلی","content":"در این فصل به مباحث الگوریتم و ساختار داده در زبان گو میپردازیم\u0026hellip;\n"},{"id":96,"href":"/chapter-11/","title":"فصل یازدهم: معماری های نرم افزار","section":"صفحه اصلی","content":"در این فصل به مباحث معماری های نرم افزار در زبان گو میپردازیم\u0026hellip;\n"},{"id":97,"href":"/chapter-9/creational-patterns/go-singleton-pattern/","title":"9.1.1 الگو Singleton","section":"9.1 الگوهای طراحی سازنده","content":"سینگلتون یک الگوی طراحی سازنده است که به شما این اجازه را می‌دهد، تنها یک شی از ساختار خود را با دسترسی سراسری ایجاد کنید.\nالگوی طراحی سینگلتون:\nاطمینان می‌دهد که تنها یک شی از یک ساختار ایجاد می‌شود. مشابه یک متغیر سراسری، به شما امکان می‌دهد از هر جای برنامه به آن شی دسترسی داشته باشید و از بازنویسی توسط نقاط دیگر برنامه نیز محافظت می‌کند. از الگوی سینگلتون زمانی استفاده کنید که بخواهید تنها یک شی از یک ساختار در دسترس کل برنامه باشد. به عنوان مثال، می‌توانید از الگوی سینگلتون برای ایجاد یک شی واحد از لاگر استفاده کنید که توسط بخش‌های مختلف برنامه به آن دسترسی دارند. مثال مفهومی از الگوی سینگلتون:\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;sync\u0026#34; 6 \u0026#34;time\u0026#34; 7) 8 9type MyLogger struct { 10} 11 12var ( 13 globalLogger *MyLogger 14 mu = \u0026amp;sync.Mutex{} 15) 16 17func GetMyLoggerInstance(i int) *MyLogger { 18 if globalLogger == nil { 19 mu.Lock() 20 defer mu.Unlock() 21 if globalLogger == nil { 22 fmt.Println(\u0026#34;creating myLogger instance by\u0026#34;, i) 23 globalLogger = \u0026amp;MyLogger{} 24 } 25 } else { 26 fmt.Println(\u0026#34;myLogger instance already created.\u0026#34;) 27 } 28 29 return globalLogger 30} 31 32func main() { 33 for i := 1; i \u0026lt;= 5; i++ { 34 go GetMyLoggerInstance(i) 35 } 36 time.Sleep(time.Second) 37} 1$ go run main.go 2creating myLogger instance by 2 3myLogger instance already created. 4myLogger instance already created. 5myLogger instance already created. 6myLogger instance already created. روش‌ دیگری نیز برای ایجاد یک شی توسط الگوی سینگلتون در زبان گو وجود دارد:\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;sync\u0026#34; 6 \u0026#34;time\u0026#34; 7) 8 9type MyLogger struct { 10} 11 12var ( 13 globalLogger *MyLogger 14 once sync.Once 15) 16 17func GetMyLoggerInstance(i int) *MyLogger { 18 if globalLogger == nil { 19 once.Do( 20 func() { 21 fmt.Println(\u0026#34;creating myLogger instance by\u0026#34;, i) 22 globalLogger = \u0026amp;MyLogger{} 23 }) 24 } else { 25 fmt.Println(\u0026#34;myLogger instance already created.\u0026#34;) 26 } 27 28 return globalLogger 29} 30 31func main() { 32 for i := 1; i \u0026lt;= 5; i++ { 33 go GetMyLoggerInstance(i) 34 } 35 time.Sleep(time.Second) 36} 1$ go run main.go 2creating myLogger instance by 4 مزایا:\n✅ اطمینان می‌دهد که تنها یک شی از ساختار وجود دارد. ✅ دسترسی سراسری به آن شی را فراهم می‌کند.\n✅ شی فقط در صورت نیاز به آن ایجاد و مقداردهی می‌شود.\nمعایب:\n❌ اصل مسئولیت واحد را نقض می‌کند و ممکن است باعث پیچیدگی در کد شود.\n❌ در برنامه‌های ماتی ترد ، پیاده‌سازی الگوی سینگلتون نیاز به رویکردهای خاص دارد و این ممکن است پیچیدگی را افزایش دهد.\n"},{"id":98,"href":"/chapter-9/creational-patterns/go-factory-method-pattern/","title":"9.1.2 الگو Factory Method","section":"9.1 الگوهای طراحی سازنده","content":"الگو Factory Method\u0026hellip;\n"},{"id":99,"href":"/chapter-9/creational-patterns/go-prototype-pattern/","title":"9.1.3 الگو Prototype","section":"9.1 الگوهای طراحی سازنده","content":"الگو Prototype\u0026hellip;\n"},{"id":100,"href":"/chapter-9/creational-patterns/go-abstract-factory-pattern/","title":"9.1.4 الگو Abstract Factory","section":"9.1 الگوهای طراحی سازنده","content":"الگو Abstract Factory\u0026hellip;\n"},{"id":101,"href":"/chapter-9/creational-patterns/go-builder-pattern/","title":"9.1.6 الگو Builder","section":"9.1 الگوهای طراحی سازنده","content":"الگو Builder\u0026hellip;\n"},{"id":102,"href":"/chapter-9/creational-patterns/go-object-pool-pattern/","title":"9.1.7 الگو Object Pool","section":"9.1 الگوهای طراحی سازنده","content":"الگو Object Pool\u0026hellip;\n"},{"id":103,"href":"/chapter-9/structural-patterns/go-adaptor-pattern/","title":"9.2.1 الگو Adaptor","section":"9.2 الگوهای طراحی ساختاری","content":"الگو Adaptor الگوی adapter یک الگوی ساختاری است که برای سازگار کردن موجودیت های مختلف با هم به کار می‌رود.\nداده ها در دنیای دیجیتال به فرمت‌های مختلف ذخیره و پردازش می‌شوند. این تفاوت در لایه‌ها و فرمت‌های مختلف نمایان و آشکار است. نمونه واضح و پرکاربرد آن فرمت‌های مختلفی مانند json و xml و باینری\u0026hellip; است که در پروتکل‌های ارتباطی متفاوت مورد استفاده قرار می‌گیرد و گاها برای ایجاد ارتباط و امکان خوانده شدن این داده‌ها نیازمند یک روش و الگوی قابل گسترش هستیم.\nالگوی adapter در اینجا مورد استفاده قرار می‌گیرد. نحوه پیاده سازی این الگو در زبان گو به اینصورت است که ابتدا یک struct مادر به همراه متد یا متدهای مورد نیاز ما که مابین موجودیت‌های متفاوت مشترک است تعریف می‌شود. همزمان برای هر فرمت داده یک struct جهت سازگار کردن داده‌ها ساخته می شود. متدهای این strcut توسط یک interface فراخوانی شده است. در اینجا کافی است که این interface را به عنوان ورودی متدهای struct مادر درنظر بگیریم. اینکار باعث ایجاد ارتباط میان struct ها و موجودیت های مختلف خواهد شد.\nدر زیر مثالی از پیاده سازی این الگو انجام گرفته است. در این مثال دو دستگاه پرینتر متفاوت وظیفه چاپ بر روی کاغذ با یک ابعاد خاص و مشخص (A4) را دارند در صورتی که هیچکدام بصورت اختصاصی این ابعاد را پشتیبانی نمیکنند بنابراین ما با پیاده سازی الگوی adapter این امکان را ایجاد میکنیم که این تفاوت ابعاد در داخل هر موجودیت مدیریت شود و فقط متد چاپ در ابعاد A4 فراخوانی شود.\n1package main 2 3 4type IPrint interface{ 5PrintA4() 6} 7 8type Printer struct {} 9 10func (p Printer) Print(printer IPrint) { 11printer.PrintA4() 12} 13 14// HP Printer 15type HpPrinter struct {} 16 17func (h HpPrinter) PrintWithHP() { 18println(\u0026#34;print with HP printer\u0026#34;) 19} 20 21type HpAdapter struct { 22printer *HpPrinter 23} 24 25func (ha HpAdapter) PrintA4() { 26println(\u0026#34;adapting to A4 size for HP printer\u0026#34;) 27//some adapting functions 28ha.printer.PrintWithHP() 29} 30 31 32// Canon Printer 33type CanonPrinter struct {} 34 35func (c CanonPrinter) PrintWithCanon() { 36println(\u0026#34;print with Canon printer\u0026#34;) 37} 38 39type CanonAdapter struct{ 40printer *CanonPrinter 41} 42 43func (ca CanonAdapter) PrintA4() { 44println(\u0026#34;adapting to A4 size for Canon printer\u0026#34;) 45//some adapting functions 46ca.printer.PrintWithCanon() 47} 48 49 50func main() { 51 52 53hpPrinter := \u0026amp;HpPrinter{} 54hpAdapter := HpAdapter{ 55printer: hpPrinter, 56} 57 58canonPrinter := \u0026amp;CanonPrinter{} 59canonAdapter := CanonAdapter{ 60printer: canonPrinter, 61} 62 63printer := Printer{} 64printer.Print(hpAdapter) 65printer.Print(canonAdapter) 66} 1 2adapting to A4 size for HP printer 3print with HP printer 4adapting to A4 size for Canon printer 5print with Canon printer ۱− در مثال بالا ما برای هر پرینتر یک struct به عنوان adapter ایجاد کرده ایم (خطوط 21 و 39) ۲− این struct ها متدی به نام PrintA4 را تعریف می‌کنند‌ که وظیفه تغییر داده ها به فرمت مشترک مورد نظر را دارند (خطوط 25 و 43) ۳− این متد در یک اینترفیس به نام IPrint نیز فراخوانی می‌شود (خط 5) ۴− در این مرحله یک struct به نام Printer ایجاد میکنیم (خط 8) ۵− در مرحله آخر متد اصلی که وظیفه Print کردن کاغذ برای هر پیرنتری را دارد تعریف میکنیم. نکته مهم ورودی این متد است که همان interface تعریف شده در مرحله 3 می باشد. ۶− مرحله آخر تغریف هر پرینتر و printerAdapter در خطوط 52 تا 61 است و درنهایت فراخوانی متد تعریف شده در مرحله 5 برای هر پرینتر در خطوط 64 و 65.\n"},{"id":104,"href":"/chapter-9/structural-patterns/go-bridge-pattern/","title":"9.2.2 الگو Bridge","section":"9.2 الگوهای طراحی ساختاری","content":"الگو Bridge\u0026hellip;\n"},{"id":105,"href":"/chapter-9/structural-patterns/go-composite-pattern/","title":"9.2.3 الگو Composite","section":"9.2 الگوهای طراحی ساختاری","content":"الگو Composite\u0026hellip;\n"},{"id":106,"href":"/chapter-9/structural-patterns/go-decorator-pattern/","title":"9.2.1 الگو Decorator","section":"9.2 الگوهای طراحی ساختاری","content":"الگو Decorator\u0026hellip;\n"},{"id":107,"href":"/chapter-9/structural-patterns/go-facade-pattern/","title":"9.2.5 الگو Facade","section":"9.2 الگوهای طراحی ساختاری","content":"الگو Facade\u0026hellip;\n"},{"id":108,"href":"/chapter-9/structural-patterns/go-flyweight-pattern/","title":"9.2.6 الگو Flyweight","section":"9.2 الگوهای طراحی ساختاری","content":"الگو Flyweight\u0026hellip;\n"},{"id":109,"href":"/chapter-9/structural-patterns/go-proxy-pattern/","title":"9.2.7 الگو Proxy","section":"9.2 الگوهای طراحی ساختاری","content":"الگو Proxy\u0026hellip;\n"},{"id":110,"href":"/chapter-9/behavioral-patterns/go-chain-of-responsibility-pattern/","title":"9.3.1 الگو Chain Of Responsibility","section":"9.3 الگوهای طراحی رفتاری","content":"الگو Chain Of Responsibility\u0026hellip;\n"},{"id":111,"href":"/chapter-9/behavioral-patterns/go-command-pattern/","title":"9.3.2 الگو Command","section":"9.3 الگوهای طراحی رفتاری","content":"الگو Command\u0026hellip;\n"},{"id":112,"href":"/chapter-9/behavioral-patterns/go-iterator-pattern/","title":"9.3.3 الگو Iterator","section":"9.3 الگوهای طراحی رفتاری","content":"الگو Iterator\u0026hellip;\n"},{"id":113,"href":"/chapter-9/behavioral-patterns/go-mediator-pattern/","title":"9.3.4 الگو Mediator","section":"9.3 الگوهای طراحی رفتاری","content":"الگو Mediator\u0026hellip;\n"},{"id":114,"href":"/chapter-9/behavioral-patterns/go-memento-pattern/","title":"9.3.5 الگو Memento","section":"9.3 الگوهای طراحی رفتاری","content":"الگو Memento\u0026hellip;\n"},{"id":115,"href":"/chapter-9/behavioral-patterns/go-observer-pattern/","title":"9.3.6 الگو Observer","section":"9.3 الگوهای طراحی رفتاری","content":"الگو Observer\u0026hellip;\n"},{"id":116,"href":"/chapter-9/behavioral-patterns/go-state-pattern/","title":"9.3.7 الگو State","section":"9.3 الگوهای طراحی رفتاری","content":"الگو State\u0026hellip;\n"},{"id":117,"href":"/chapter-9/behavioral-patterns/go-strategy-pattern/","title":"9.3.8 الگو Strategy","section":"9.3 الگوهای طراحی رفتاری","content":"الگو Strategy\u0026hellip;\n"},{"id":118,"href":"/chapter-9/behavioral-patterns/go-template-method-pattern/","title":"9.3.9 الگو Template Method","section":"9.3 الگوهای طراحی رفتاری","content":"الگو Template Method\u0026hellip;\n"},{"id":119,"href":"/chapter-9/behavioral-patterns/go-visitor-pattern/","title":"9.3.10 الگو Visitor","section":"9.3 الگوهای طراحی رفتاری","content":"الگو Visitor\u0026hellip;\n"},{"id":120,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-wait-for-result/","title":"9.4.1 الگو Wait For Result","section":"9.4 الگوهای همزمانی","content":" 9.4.1.1 توضیحات # با استفاده از الگو Wait For Result می توانید یک عملیاتی را بصورت همزمانی انجام دهید و سپس منتظر نتیجه عملیات صورت گرفته بمانید. برای اینکار از کانال استفاده می شود.\n9.4.1.2 دیاگرام # 9.4.1.3 نمونه کد # 1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;time\u0026#34; 6) 7 8func longRunningTask(c chan int) { 9\ttime.Sleep(3 * time.Second) 10\tc \u0026lt;- 42 11} 12 13func main() { 14\tc := make(chan int) 15\tgo longRunningTask(c) 16 17\tresult := \u0026lt;-c 18\tfmt.Println(\u0026#34;Result:\u0026#34;, result) 19} 1$ go run main.go 2Result: 42 در کد فوق ما یک تابع به نام longRunningTask داریم که قرار است بصورت همزمان اجرا شود در اینجا ما یک کانال را برای دریافت نتیجه از تابع ارسال می کنیم و منتظر پاسخ از طریق کانال می شویم.\n9.4.1.4 کاربردها # Web scraping : زمانی که شما عملیات web scraping انجام می دهید نیاز دارید بصورت همزمان از چندین آدرس داده جمع آوری کنید در اینجا شما می توانید بصورت همزمان به چندین آدرس درخواست دهید و سپس منتظر نتایج بمانید. API Calls : در معماری ماکروسرویس شما نیازی دارید چندین API را همزمان فراخوانی کنید و منتظر نتایج بمانید قبل از اینکه به کلاینت نتیجه نهایی را نمایش دهید. حال در اینجا می توانید از این الگو استفاده کنید و همزمان اینکار را انجام دهید و منتظر نتایج بمانید تا زمان کمتری صرف شود. Parallel Computation : برای محاسبات علمی شما احتیاج دارید بصورت همزمان محاسبات انجام دهید و قبل از اینکه بخواهید به مرحله بعدی فرآیند بروید می توانید برای نتایجی بصورت همزمان ایجاد کردید منتظر بمانید. "},{"id":121,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-fan-out-in/","title":"9.4.2 الگو Fan Out/In","section":"9.4 الگوهای همزمانی","content":" 9.4.2.1 توضیحات # الگو Fan Out/In یک تکنیک همزمانی در زبان گو می باشد که به شما اجازه می دهد چندین کار را با گوروتین همزمان انجام دهید و در نتیجه خروجی این کارها را با هم ترکیب کنید و به عنوان نتیجه نهایی دریافت کنید.\n9.4.2.2 دیاگرام # 9.4.2.3 نمونه کد # فرض کنید قصد دارید یک برنامه ای بنویسید که چندین فایل بصورت موازی دانلود کنید و در نهایت محتوای این فایل را میخواهید ترکیب کنید و یک خروجی داشته باشید.\nدر زیر یک مثال ساده زدیم :\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;sync\u0026#34; 6) 7 8func main() { 9\turls := []string{\u0026#34;url1\u0026#34;, \u0026#34;url2\u0026#34;, \u0026#34;url3\u0026#34;} 10\tvar wg sync.WaitGroup 11 12\t// Fan out: Launch goroutines to download files 13\tresults := make(chan string) 14\tfor _, url := range urls { 15\twg.Add(1) 16\tgo func(url string) { 17\tdefer wg.Done() 18\tresult := downloadFile(url) 19\tresults \u0026lt;- result 20\t}(url) 21\t} 22 23\t// Fan in: Combine results from goroutines 24\tgo func() { 25\twg.Wait() 26\tclose(results) 27\t}() 28 29\tvar output string 30\tfor result := range results { 31\toutput += result 32\t} 33\tfmt.Println(output) 34} 35 36func downloadFile(url string) string { 37\t// code to download file from url 38\treturn \u0026#34;file contents\u0026#34; 39} 1$ go run main.go 2file contentsfile contentsfile contents در بالا ما یکسری url داریم میخواهیم بصورت موازی فایل هایی را دانلود کنید. حال با توجه به تعداد url ها یک گوروتین ایجاد میکنیم که بصورت موازی شروع به دانلود فایل کنند و نتیجه را داخل کانال results بفرستند. در اینجا ما با کمک WaitGroup منتظر نتیجه کلی عملیات گوروتین ها می شویم و در نهایت پس از اینکه گوروتین ها کارشان اتمام شد. ما با کمک حلقه for-range داده ها را از کانال results دریافت می کنیم و این داده ها را باهم ترکیب میکنیم.\n9.4.2.4 کاربردها # پردازش داده (Data Processing) : شما با استفاده از الگو Fan Out/In بصورت موازی می توانید مقادیری زیاده از داده ها را پردازش کنید. به عنوان مثال شما یک داده بزرگی را دارید قصد دارید پردازشی برروی این داده انجام حال می توانید این داده را به بخش های کوچکتری بین گوروتین ها تقسیم کنید تا بصورت موازی پردازش شود در نهایت خروجی های پردازش شده را با هم ترکیب کنید. Web Scarping : شما با استفاده از الگو Fan Out/In می توانید چندین Scraping وب سایت را بطور همزمان ایجاد کنید و پس از آن نتایج را ترکیب کنید. به عنوان مثال شما بطور موازی چندین گوروتین را برای Web Scaring صفحات مختلف یک وب سایت ایجاد می کنید و با استفاده از کانال نتایج را جمع آوری میکند و در نهایت برروی این نتایج پردازش و در یک دیتابیس ذخیره می کنید. محاسبات توزیع شده (Distributed computing) : برای انجام محاسبات توزیع شما می توانید از الگو Fan Out/In استفاده کنید و چندین گوروتین را برای انجام یک در Machine های مختلف راه اندازی کنید و سپس از یک کانال برای جمع آوری داده استفاده کنید. سپس گوروتین اصلی می توانید نتایج حاصل از را از تمامی node ها جمع آوری کند و یک خروجی ترکیب شده ایجاد کند. شبکه : با استفاده از الگو Fan Out/In می توانید برای مدیریت همزمان چندین کانکشن ورودی و سپس ترکیب نتایج استفاده کنید. به عنوان مثال می توانید چندین گوروتین را برای مدیریت کانکشن های ورودی راه اندازی کنید و سپس از یک کانال برای جمع آودری نتایج استفاده کنید. پس از پردازش و ترکیب نتایج این نتایج را به عنوان خروجی به کلاینت نمایش دهد. "},{"id":122,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-wait-for-task/","title":"9.4.3 الگو Wait For Task","section":"9.4 الگوهای همزمانی","content":" 9.4.3.1 توضیحات # الگو wait for task یکی از الگوهای رایج در زبان گو می باشد و انتظار برای تکمیل یک تسک یا فرآیند استفاده می شود. یک تسک با استفاده از گوروتین اجرا می شود و پس اتمامش کار تسک از طریق کانال سیگنال انجام می فرستد.\nهمچنین می توانید شما یک کانال ایجاد کنید منتظر بمانید تسک انجام شود و دیتا مورد نظر را از طریق کانال بگیرید.\n9.4.3.2 دیاگرام # 9.4.3.3 نمونه کد # 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tdone := make(chan bool) 7\tgo task(done) 8 9\t\u0026lt;-done 10\tfmt.Println(\u0026#34;Task complete!\u0026#34;) 11} 12 13func task(done chan bool) { 14\t// Do some work here 15\tfmt.Println(\u0026#34;Working...\u0026#34;) 16\tdone \u0026lt;- true 17} 1$ go run main.go 2Working... 3Task complete! در مثال فوق ما یک کانال ایجاد کردیم که پس انجام شدن تسک وضعیت کار انجام شده را بگیریم. حال کانال done را به تابع task پاس دادیم پس از انجام شدن کارش مقدار true را به کانال فرستادیم و سپس ما وضعیت انجام شدن تسک را دریافت می کنیم.\n9.4.3.4 کاربردها # پرادزش حجم زیادی از داده ها بصورت موازی : می‌توانید از این الگو برای اجرای چندین گوروتین که تکه‌هایی از داده‌ها را به صورت موازی پردازش می‌کنند، استفاده کنید و سپس قبل از ادامه مرحله بعدی برنامه‌تان منتظر بمانید تا همه گوروتین‌ها تمام شوند. ایجاد ریکوئست API چندگانه : می‌توانید از این الگو برای برقراری همزمان چندین تماس API استفاده کنید و قبل از ادامه منتظر تمام پاسخ‌ها باشید. انتظار برای ورودی کاربر: می‌توانید از الگو برای اجرای یک گوروتین استفاده کنید که منتظر ورودی کاربر است و هنگام دریافت ورودی، پیامی را در کانال «انجام شد» ارسال می‌کند. این می تواند مفید باشد اگر بخواهید در پس زمینه منتظر ورودی بمانید در حالی که سایر بخش های برنامه شما همچنان به کار خود ادامه می دهند. انتظار برای آماده شدن منابع: می توانید از الگوی استفاده کنید تا قبل از ادامه مرحله بعدی برنامه، منتظر آماده شدن منابعی مانند اتصال پایگاه داده یا فایل باشید. انتظار برای تکمیل یک کار پس‌زمینه: می‌توانید از الگو برای اجرای یک کار در پس‌زمینه استفاده کنید و قبل از ادامه مرحله بعدی برنامه، منتظر تکمیل آن باشید. "},{"id":123,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-pooling/","title":"9.4.4 الگو Pooling","section":"9.4 الگوهای همزمانی","content":" 9.4.4.1 توضیحات # شما با استفاده از الگو pooling می توانید برای استفاده مجدد یا مدیریت تعداد ثابتی از منابع مانند : کانکشن های دیتابیس یا مجموعه ای از گوروتین های کارگر استفاده کنید. از کانال برای برقراری ارتباط بین مجموع منابع استفاده می شود.\n9.4.4.2 دیاگرام # 9.4.4.3 نمونه کد # 1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7func main() { 8\tjobs := make(chan int, 100) 9\tresults := make(chan int, 100) 10 11\t// Start 3 worker goroutines 12\tfor w := 1; w \u0026lt;= 3; w++ { 13\tgo worker(w, jobs, results) 14\t} 15 16\t// Send 5 jobs to the worker pool 17\tfor j := 1; j \u0026lt;= 5; j++ { 18\tjobs \u0026lt;- j 19\t} 20\tclose(jobs) 21 22\t// Collect the results 23\tfor a := 1; a \u0026lt;= 5; a++ { 24\tfmt.Println(\u0026lt;-results) 25\t} 26} 27 28func worker(id int, jobs \u0026lt;-chan int, results chan\u0026lt;- int) { 29\tfor j := range jobs { 30\tfmt.Println(\u0026#34;worker\u0026#34;, id, \u0026#34;processing job\u0026#34;, j) 31\tresults \u0026lt;- j * 2 32\t} 33} 1$ go run main.go 2worker 3 processing job 1 3worker 3 processing job 4 4worker 3 processing job 5 5worker 1 processing job 2 62 78 810 94 10worker 2 processing job 3 116 فرض کنید ما ۱۰۰ تسک داریم که قرار است این تسک ها را بین کارگرها تقسیم کنید و در نهایت نتیجه را از طریق کانال دریافت کنیم.\nحال ما ۲ تا کانال ایجاد می کنیم با بافر ۱۰۰ تایی به نام jobs و results که قرار است ۱۰۰ تسک بواسطه این کانال ها ارسال و دریافت شود.\nما یک تابع worker داریم که jobs را دریافت میکند از طریق کانال و پس از عملیات نتیجه را داخل کانال results میفرستد.\nکانال jobs از نوع فقط دریافتی است کانال results از نوع فقط ارسال است حال با فرض اینکه بطور موازی ۳ تا کارگر داریم که این تسک ها را دریافت می کنند و پس از انجام نتیجه را میفرستند. برای اینکه ۳ تا کارگر را ایجاد کنیم از حلقه استفاده میکنیم و تابع worker را داخل گوروتین قرا می دهیم و پس از آن jobs و results را به عنوان پارامتر ورودی به هر ورکر می دهیم.\nدر ادامه یک حلقه ایجاد می کنیم ۵ تا کار (job) داریم قرار است هرکدام از کارگرها توانست انجام دهد و ما کارها را از طریق کانال میفرستیم.\nدر نهایت یک حلقه دیگر داریم که این job ها را از طریق کانال results دریافت می کنیم و پس آن چاپ می کنیم.\n9.4.4.4 کاربردها # تقسیم کارهای پردازشی : شما با استفاده از این الگو می توانید پردازش یک داده سنگین را بین چند کارگر تقسیم کنید و بطور موازی این داده های سنگین در کمترین زمان پردازش می شود و جلو هزینه و سربار را میگیرد و باعث افزایش و بهبود عملکرد شود. "},{"id":124,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-drop/","title":"9.4.5 الگو Drop","section":"9.4 الگوهای همزمانی","content":" 9.4.5.1 توضیحات # الگو Drop یک الگو مهم برای انجام خدمات سنگین می باشد. خدماتی که مواقعی باعث می شود حجم درخواست هایش بیش از ظرفیت موجود باشد و این درخواست ها بواسطه این الگو می تواند Drop شود. به عنوان مثال سرویس های DNS باید از این الگو استفاده کنند.\n9.4.5.2 دیاگرام # 9.4.5.3 نمونه کد # 1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7func main() { 8\tin := make(chan int, 5) 9\tout := make(chan int, 5) 10 11\tgo func() { 12\tfor { 13\tselect { 14\tcase in \u0026lt;- 1: 15\tdefault: 16\tfmt.Println(\u0026#34;Dropping data\u0026#34;) 17\t} 18\t} 19\t}() 20 21\tgo func() { 22\tfor { 23\tselect { 24\tcase data := \u0026lt;-in: 25\tselect { 26\tcase out \u0026lt;- data: 27\tdefault: 28\tfmt.Println(\u0026#34;Dropping data\u0026#34;) 29\t} 30\t} 31\t} 32\t}() 33 34\tfor i := 0; i \u0026lt; 10; i++ { 35\tfmt.Println(\u0026lt;-out) 36\t} 37} 1$ go run main.go 2Dropping data 3Dropping data 4Dropping data 5Dropping data 61 7Dropping data 8 9Dropping data 10Dropping data 111 121 131 141 151 161 17Dropping data 18Dropping data 19Dropping data 20Dropping data 21Dropping data 22Dropping data 231 241 251 در کد فوق ما ۲ تا کانال داریم به نام in/out که بافر شده هستند حال کانال in داده را دریافت می کند و پس از آن داده را به کانال out میفرستد. در اینجا اگر حجم داده ای که دریافت شده بیشتر از اندازه کانال in باشد آن بخش زیاد Drop می شود و همچنین کانال out هم همان شرایط را دارد و سعی می کند داده را به اندازه ظرفیت معین شده مدیریت و پردازش کند.\n9.4.5.4 کاربردها # Rate limiting: هنگامی که با حجم بالای داده های ورودی سروکار دارید، ممکن است لازم باشد برخی از داده ها را حذف کنید تا حجم پردازش ثابتی حفظ شود. Logging: هنگام ثبت داده‌ها، ممکن است لازم باشد که ورودی‌های گزارش را حذف کنید اگر سیستم قادر به هماهنگی با سرعت تولید آنها نباشد. Queue: هنگام برخورد با صفی که توسط یک کانال پشتیبانی می شود، ممکن است به جای مسدود کردن فرستنده، لازم باشد داده های دریافتی را در صورت پر بودن صف حذف کنید. کنترل ترافیک: هنگام مواجهه با حجم بالای ترافیک ورودی، ممکن است لازم باشد مقداری از ترافیک ورودی را حذف کنید تا حجم پردازش ثابتی حفظ شود. سیستم های بلادرنگ (Real-time system): در سیستم‌های بلادرنگ که داده‌ها باید در یک بازه زمانی خاص پردازش شوند، ممکن است لازم باشد که برخی از داده‌های دریافتی حذف شوند، اگر سیستم قادر به هماهنگی با سرعت تولید داده‌ها نباشد. "},{"id":125,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-cancellation/","title":"9.4.6 الگو Cancellation","section":"9.4 الگوهای همزمانی","content":" 9.4.6.1 توضیحات # الگو cancellation که حرکت تکنیکی هست برای ارسال سینگال به گوروتین ها استفاده می شود که باید اجرای کاری را متوقف کند و ایده اصلی این کار با استفاده بستن کانال صورت میگیرد.\n9.4.6.2 دیاگرام # 9.4.6.3 نمونه کد # 1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;time\u0026#34; 6) 7 8func main() { 9\t// create cancel channel 10\tcancel := make(chan struct{}) 11 12\t// start goroutine 13\tgo func() { 14\tfor { 15\tselect { 16\tcase \u0026lt;-cancel: 17\tfmt.Println(\u0026#34;Cancelled\u0026#34;) 18\treturn 19\tdefault: 20\tfmt.Println(\u0026#34;Running\u0026#34;) 21\ttime.Sleep(time.Second) 22\t} 23\t} 24\t}() 25 26\t// run goroutine for 3 seconds 27\ttime.Sleep(3 * time.Second) 28 29\t// close cancel channel 30\tclose(cancel) 31 32\t// wait for goroutine to stop 33\ttime.Sleep(time.Second) 34} 1$ go run main.go 2Running 3Running 4Running 5Cancelled در کد فوق ما یک کانال از نوع ساختار ایجاد کردیم با عنوان cancel و این کانال را داخل یکی از case های select بصورت دریافت قرار دادیم که در ادامه ما یک Sleep ۳ گذاشتیم تا فرآیند انجام شود و Running چاپ شود. پس از آن کانال را close کردیم و سیگنال لغو فرآیند ارسال شد و گوروتین کاملا متوقف شد.\n9.4.6.4 کاربردها # لغو یک کار طولانی‌مدت: عملکردی که عملیات زمان‌بر مانند درخواست شبکه یا محاسبات را انجام می‌دهد، اگر دیگر به آن نیاز نباشد یا از مهلت زمانی فراتر رود، می‌توان آن را لغو کرد. پاکسازی منابع: تابعی که منابعی مانند فایل یا اتصال شبکه را تخصیص می دهد، می تواند لغو شود تا این منابع قبل از اینکه دیگر مورد نیاز نباشند آزاد شوند. خاتمه دادن به یک سرور: سروری که چندین درخواست را مدیریت می‌کند، می‌تواند با لغو تمام عملکردهای در حال اجرا که این درخواست‌ها را انجام می‌دهند، به‌خوبی خاموش شود. لغو یک کار پس زمینه: یک کار پس زمینه که همزمان با برنامه اصلی اجرا می شود را می توان لغو کرد تا از اجرای آن جلوگیری شود. "},{"id":126,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-semaphore/","title":"9.4.7 الگو Semaphore","section":"9.4 الگوهای همزمانی","content":" 9.4.7.1 توضیحات # الگو Semaphore برای مدیریت کنترل دسترسی به منابع مشترک در همزمانی استفاده می شود. فرض کنید بصورت موازی ۱۰۰ درخواست HTTP سمت سرور میاد و I/O شبکه برای پردازش همزمان این ۱۰۰ درخواست درگیر میشود و به مرور عملکرد کاهش می یابد. حال اگر ما بیایم این ۱۰۰ درخواست موازی را تقسیم کنیم به ۵ دسته ۲۰ تایی که بصورت همزمانی انجام شود باعث می شود I/O شبکه کاهش یابد و عملکرد بهتری را خواهیم داشت.\nحال برای اینکه بتوانیم این الگو را طراحی کنیم نیاز هست از کانال بافر شده استفاده کنیم.\nبه نقل از ویکی پدیا :\nدر علم رایانه نشانبر یا سمافور (به انگلیسی: Semaphore) به متغیری گفته می‌شود که در محیط‌های همروند برای کنترل دسترسی فرایندها به منابع مشترک به کار می‌رود. سمافور می‌تواند به دو صورت دودویی (که تنها دو مقدار صحیح و غلط را دارا است) یا شمارنده اعداد صحیح باشد. از سمافور برای جلوگیری از ایجاد وضعیت رقابتی میان فرایندها استفاده می‌گردد. به این ترتیب، اطمینان حاصل می‌شود که در هر لحظه تنها یک فرایند به منبع مشترک دسترسی دارد و می‌تواند از آن بخواند یا بنویسد (انحصار متقابل)\nسمافورها اولین بار به‌وسیلهٔ دانشمند علوم رایانه هلندی، ادسخر دیکسترا معرفی شدند.[۱] و امروزه به‌طور گسترده‌ای در سیستم عاملها مورد استفاده قرار می‌گیرند.\n9.4.7.2 دیاگرام # 9.4.7.3 نمونه کد # 1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;time\u0026#34; 6) 7 8type Semaphore interface { 9\tAcquire() 10\tRelease() 11} 12 13type semaphore struct { 14\tsemCh chan struct{} 15} 16 17func New(maxConcurrency int) Semaphore { 18\treturn \u0026amp;semaphore{ 19\tsemCh: make(chan struct{}, maxConcurrency), 20\t} 21} 22 23func (s *semaphore) Acquire() { 24\ts.semCh \u0026lt;- struct{}{} 25} 26 27func (s *semaphore) Release() { 28\t\u0026lt;-s.semCh 29} 30 31func main() { 32\tsem := New(3) 33\tdoneC := make(chan bool, 1) 34\ttotProcess := 10 35 36\tfor i := 1; i \u0026lt;= totProcess; i++ { 37\tsem.Acquire() 38\tgo func(v int) { 39\tdefer sem.Release() 40\tlongRunningProcess(v) 41 42\tif v == totProcess { 43\tdoneC \u0026lt;- true 44\t} 45\t}(i) 46\t} 47 48\t\u0026lt;-doneC 49} 50 51func longRunningProcess(taskID int) { 52\tfmt.Println(time.Now().Format(\u0026#34;15:04:05\u0026#34;), \u0026#34;Running task with ID\u0026#34;, taskID) 53\ttime.Sleep(2 * time.Second) 54} 1$ go run main.go 223:00:00 Running task with ID 3 323:00:00 Running task with ID 1 423:00:00 Running task with ID 2 523:00:02 Running task with ID 6 623:00:02 Running task with ID 4 723:00:02 Running task with ID 5 823:00:04 Running task with ID 7 923:00:04 Running task with ID 8 1023:00:04 Running task with ID 9 1123:00:06 Running task with ID 10 در کد فوق ما یک اینترفیس به نام Semaphore داریم که ۲ تا متد Acquire و Release دارد که با استفاده از Acquire منابع را قبل از اینکه تابع logRunningProcess را فراخوانی کنیم قفل می کنیم و پس از اینکه عملیات تابع logRunningProcess انجام شد با استفاده از Release منابع را آزاد می کنیم.\nیک تابع سازنده به نام New قرار دادیم که ظرفیت کانال Semaphore را مشخص می کند تا تعداد درخواستی که نیاز است همزمان انجام شود چندتا باشد.\nزمانیکه ما متد Acquire را فراخوانی می کنیم {}{}struct را به کانال می فرستیم تا زمانیکه ظرفیت پر نشده است. پس از اینکه ظرفیت کانال پر شود آن بخش از کد ما Acquire را فراخوانی کردیم قفل می شود و تا زمانی که از کانال بواسطه متد Release دریافت نکنیم منابع در دسترس نخواهد بود.\n9.4.7.4 کاربردها # مدیریت دسترسی به منابع مشترک همگام سازی دسترسی به ساختار داده مشترک مدیریت دسترسی به منابع محدود پیاده سازی یک Load Balancer پیاده سازی thread pool "},{"id":127,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-bounded-work-pooling/","title":"9.4.8 الگو Bounded Work Pooling","section":"9.4 الگوهای همزمانی","content":" 9.4.8.1 توضیحات # با استفاده از الگو Bounded Work Pooling امکان محدود سازی تعداد گوروتین ها را براساس کار مشخصی دارید و گوروتین ها را محدود به تعداد دفعات کار مشخص شده محدود می شود. این الگو برای وقت مفید است که شما می خواهید منابع را به یک کار خاص محدود کنید.\n9.4.8.2 دیاگرام # 9.4.8.3 نمونه کد # 1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;sync\u0026#34; 6) 7 8func main() { 9\t// Create a channel to hold the tasks 10\ttasks := make(chan int, 100) 11 12\t// Create a WaitGroup to track the goroutines 13\tvar wg sync.WaitGroup 14 15\t// Set the number of goroutines we want to use 16\tnumWorkers := 5 17 18\t// Launch the goroutines 19\tfor i := 0; i \u0026lt; numWorkers; i++ { 20\twg.Add(1) 21\tgo func() { 22\tfor task := range tasks { 23\tfmt.Println(\u0026#34;Processing task\u0026#34;, task) 24\t} 25\twg.Done() 26\t}() 27\t} 28 29\t// Add tasks to the channel 30\tfor i := 0; i \u0026lt; 20; i++ { 31\ttasks \u0026lt;- i 32\t} 33 34\t// Close the channel to signal to the goroutines that there are no more tasks 35\tclose(tasks) 36 37\t// Wait for all the goroutines to finish 38\twg.Wait() 39} 1$ go run main.go 2Processing task 2 3Processing task 4 4Processing task 5 5Processing task 6 6Processing task 7 7Processing task 8 8Processing task 10 9Processing task 11 10Processing task 12 11Processing task 13 12Processing task 14 13Processing task 15 14Processing task 16 15Processing task 17 16Processing task 18 17Processing task 19 18Processing task 3 19Processing task 9 20Processing task 0 21Processing task 1 در کد فوق ما یک کانال بافر شده با ظرفیت ۱۰۰ به نام tasks ایجاد کردیم سپس یک نمونه از WaitGroup درست کردیم. حال در متغیر numWorkers تعداد گوروتین قابل استفاده را مشخص کردیم و در ادامه داخل حلقه گوروتین برای انجام تسک ها ایجاد می کنیم که یک حلقه for-range برروی کانال tasks قرار دادیم و تسک ها را دریافت سپس پردازش می کنیم. در ادامه یک حلقه i تا ۲۰ قرار دادیم که که مقدار i را به کانال tasks میفرستد.\nدر نهایت پس از تکمیل شدن تسک ها کانال را میبندیم.\n9.4.8.4 کاربردها # یکی از کاربردهای این الگو برای هندل حجم زیادی از درخواست به سرور می باشد. سرور می‌تواند تعداد درخواست‌های همزمانی را که در هر زمان پردازش می‌کند محدود کند و خطر تمام شدن منابع را کاهش دهد. علاوه بر این، می تواند با اطمینان از اینکه درخواست ها به موقع پردازش می شوند، به بهبود پاسخگویی سرور کمک کند. "},{"id":128,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-retry-timeout/","title":"9.4.9 الگو Retry Timeout","section":"9.4 الگوهای همزمانی","content":" 9.4.9.1 توضیحات # شما از الگو Retry Timeout برای تلاش مجدد یکسری عملیات استفاده کنید. برای اینکار شما می توانید از حلقه و تابع After در پکیج time کمک بگیرید و برای هرتلاش یک timeout مشخص کنید.\n9.4.9.2 دیاگرام # 9.4.9.3 نمونه کد # 1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;net/http\u0026#34; 6\t\u0026#34;time\u0026#34; 7) 8 9func main() { 10\tvar resp *http.Response 11\tvar err error 12\ttimeout := time.Duration(3 * time.Second) 13\tfor i := 0; i \u0026lt; 3; i++ { 14\tresp, err = http.Get(\u0026#34;http://example.com\u0026#34;) 15\tif err == nil { 16\tbreak 17\t} 18\tfmt.Println(\u0026#34;Retrying...\u0026#34;) 19\t\u0026lt;-time.After(timeout) 20\t} 21\tif err != nil { 22\tfmt.Println(\u0026#34;Error:\u0026#34;, err) 23\t} else { 24\tfmt.Println(\u0026#34;Response:\u0026#34;, resp) 25\t} 26} 1$ go run main.go 2Retrying... 3Retrying... 4Retrying... 5Error: Get \u0026#34;http://example.com\u0026#34;: dial tcp: lookup example.com on 169.254.169.254:53: dial udp 169.254.169.254:53: connect: no route to host در کد فوق ما داخل حلقه عملیات گرفتن اطلاعات با استفاده از http.Get را قرار دادیم و اگر درخواست با خطا مواجه می شد مجدد تلاش می کردیم که در ادامه کد داخل حلقه از تابع After استفاده کردیم تا سیگنال timeout را بواسطه کانال دریافت کنیم و تلاش مجدد صورت گیرد.\n9.4.9.4 کاربردها # الگوی Retry Timeout معمولاً در شرایطی استفاده می‌شود که درخواست شبکه یا نوع دیگری از عملیات ممکن است به دلیل مشکلات موقتی مانند سرور مشغول یا نقص شبکه با شکست مواجه شود. با امتحان مجدد عملیات با فاصله زمانی بین تلاش ها، برنامه می تواند شانس نتیجه موفقیت آمیز را افزایش دهد. "},{"id":129,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-channel-cancellation/","title":"9.4.10 الگو Channel Cancellation","section":"9.4 الگوهای همزمانی","content":" 9.4.10.1 توضیحات # از کانال ها برای ارتباط بین گوروتین ها و هماهنگ کردن اجرا استفاده می شود. حال گاهی اوقات نیاز است که ما یکسری فرآیند را داخل گوروتین لغو کنیم. در اینجا می توانیم با استفاده از کانال سیگنال لغو کردن بفرستید تا عملیات هایی که گوروتین مورد نظر انجام می داد لغو شود.\n9.4.10.2 دیاگرام # 9.4.10.3 نمونه کد # 1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7func doWork(cancel chan bool) { 8\tfmt.Println(\u0026#34;Working...\u0026#34;) 9\tfor { 10\tselect { 11\tcase \u0026lt;-cancel: 12\tfmt.Println(\u0026#34;Canceled\u0026#34;) 13\treturn 14\tdefault: 15\t} 16\t} 17} 18 19func main() { 20\tcancel := make(chan bool) 21\tgo doWork(cancel) 22\t// do some other work 23\tfmt.Println(\u0026#34;Canceling...\u0026#34;) 24\tcancel \u0026lt;- true 25} 1$ go run main.go 2Canceling... 3Working... 4Canceled در مثال فوق ما یک کانال ایجاد کردیم برای لغو عملیات در حال اجرا در کانال. حال doWork را اجرا کردیم و سپس سیگنال لغو شدن ارسال کردیم داخل تابع doWork سیگنال را بواسطه select دریافت می کنیم و درخواست را لغو می کنیم.\n9.4.10.4 کاربردها # "},{"id":130,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-producer-consumer/","title":"9.4.11 الگو Producer-Consumer","section":"9.4 الگوهای همزمانی","content":" 9.4.11.1 توضیحات # الگو producer-consumer یکی از کاربردی ترین الگوها در زبان گو می باشد که با استفاده از الگو می توانید بطور همزمان یکسری اطلاعات تولید کنید و بفرستید داخل کانال و این اطلاعات توسط مصرف کننده بواسطه کانال دریافت شود.\nمعمولا برای این الگو از یک کانال دو طرفه استفاده می شود.\n9.4.11.2 دیاگرام # 9.4.11.3 نمونه کد # 1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;math/rand\u0026#34; 6\t\u0026#34;time\u0026#34; 7) 8 9func producer(ch chan\u0026lt;- int, d time.Duration) { 10\tfor { 11\tn := rand.Intn(100) 12\tch \u0026lt;- n 13\tfmt.Println(\u0026#34;Produced:\u0026#34;, n) 14\ttime.Sleep(d) 15\t} 16} 17 18func consumer1(ch \u0026lt;-chan int, d time.Duration) { 19\tfor n := range ch { 20\tfmt.Println(\u0026#34;Consumed 1:\u0026#34;, n) 21\ttime.Sleep(d) 22\t} 23} 24 25func consumer2(ch \u0026lt;-chan int, d time.Duration) { 26\tfor n := range ch { 27\tfmt.Println(\u0026#34;Consumed 2:\u0026#34;, n) 28\ttime.Sleep(d) 29\t} 30} 31 32func main() { 33\tch := make(chan int) 34\tgo producer(ch, 100*time.Millisecond) 35\tgo consumer1(ch, 200*time.Millisecond) 36\tgo consumer2(ch, 200*time.Millisecond) 37 38\ttime.Sleep(5 * time.Second) 39} 1$ go run main.go 2Consumed 1: 81 3Produced: 81 4Produced: 87 5Consumed 2: 87 6Consumed 1: 47 7Produced: 47 8Consumed 2: 59 9Produced: 59 10Consumed 1: 81 11Produced: 81 12Consumed 2: 18 13Produced: 18 14Consumed 1: 25 15Produced: 25 در مثال فوق ما یک کانال دو طرفه ایجاد کردیم سپس این کانال را تابع producer که بصورت فقط ارسال است پاس می دهیم. پس از آن کانال را به توابع consumer1 و consumer2 به عنوان کانال فقط دریافت پاس می دهیم.\nحال اطلاعات بواسطه تابع producer ایجاد می شود و به کانال ارسال می شود و هر کدام از consumer ها داده را دریافت میکنند و نمایش می دهند.\n9.4.11.4 کاربردها # خط لوله پردازش داده: شما با استفاده از الگو producer-consumer می توانید یک خط لوله (pipeline) ایجاد کنید و داده های مورد نظر ایجاد و بواسطه producer برای consumer ها ارسال کنید. Logging and Monitoring: تولید کننده ها می تواننده داده های لاگ را ایجاد کنند و بوسطه کانال ها بفرستند و مصرف کننده ها می توانند این داده ها را دریافت کنند و عملیات انجام دهند. استریم داده: شما با استفاده از این الگو می توانید بصورت Real-time داده را از تولید کننده به مصرف کننده بفرستید تا مصرف کننده گان عملیات لازمه را انجام دهند. "},{"id":131,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-monitor/","title":"9.4.12 الگو Monitor","section":"9.4 الگوهای همزمانی","content":" 9.4.12.1 توضیحات # الگوی مانیتور به گروتین‌ ها اجازه می‌دهد هنگام ورود به حالت خواب بدون مسدود کردن اجرا یا مصرف منابع، منتظر شرایط خاصی باشند.\nحال برای پیاده سازی این الگو ما از ساختاری به نام Cond در پکیج sync کمک میگیریم.\nبه نقل از ویکی پدیا :\nدر برنامه‌نویسی همروند (یا همان برنامه‌نویسی موازی)، مانیتور یک ساختار همگام سازی است که به ریسمان ها این امکان را می‌دهد که هم، انحصار متقابل داشته باشند و هم، بتوانند برای یک وضعیت خاص منتظر بمانند (مسدود شوند) تا وضعیت غلط شود. مانیتورها همچنین دارای یک مکانیسم هستند که به ریسمان‌های دیگر، از طریق سیگنال می‌فهمانند که شرایط آنها برآورده شده‌است. یک مانیتور، حاوی یک شئ میوتکس (قفل) و متغیرهای وضعیت است. یک متغیر وضعیت اساساً، ظرفی از ریسمان ها است که منتظر یک وضعیت خاص هستند. مانیتورها برای ریسمان‌ها مکانیسمی را فراهم می‌کنند، تا به‌طور موقت، و با هدف منتظر ماندن برای برآورده شدن شرایط خاص، دسترسی انحصاری را رها کنند، و سپس دسترسی انحصاری را مجدداً به دست آورند و کار خود را از سر گیرند.\n9.4.12.2 دیاگرام # 9.4.12.3 نمونه کد # 1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;sync\u0026#34; 6) 7 8type Item = int 9 10type Queue struct { 11\titems []Item 12\t*sync.Cond 13} 14 15func NewQueue() *Queue { 16\tq := new(Queue) 17\tq.Cond = sync.NewCond(\u0026amp;sync.Mutex{}) 18\treturn q 19} 20 21func (q *Queue) Put(item Item) { 22\tq.L.Lock() 23\tdefer q.L.Unlock() 24\tq.items = append(q.items, item) 25\tq.Signal() 26} 27 28func (q *Queue) GetMany(n int) []Item { 29\tq.L.Lock() 30\tdefer q.L.Unlock() 31\tfor len(q.items) \u0026lt; n { 32\tq.Wait() 33\t} 34\titems := q.items[:n:n] 35\tq.items = q.items[n:] 36\treturn items 37} 38 39func main() { 40\tq := NewQueue() 41 42\tvar wg sync.WaitGroup 43\tfor n := 10; n \u0026gt; 0; n-- { 44\twg.Add(1) 45\tgo func(n int) { 46\titems := q.GetMany(n) 47\tfmt.Printf(\u0026#34;%2d: %2d\\n\u0026#34;, n, items) 48\twg.Done() 49\t}(n) 50\t} 51 52\tfor i := 0; i \u0026lt; 100; i++ { 53\tq.Put(i) 54\t} 55 56\twg.Wait() 57} 1$ go run main.go 2 1: [ 0] 3 6: [ 1 2 3 4 5 6] 4 5: [ 7 8 9 10 11] 5 4: [12 13 14 15] 6 3: [16 17 18] 7 2: [19 20] 8 9: [21 22 23 24 25 26 27 28 29] 910: [30 31 32 33 34 35 36 37 38 39] 10 8: [40 41 42 43 44 45 46 47] 11 7: [48 49 50 51 52 53 54] در کد فوق ما یک صف ساده ایجاد کردیم و این صف را با استفاده از Cond مدیریت کردیم و ۲ چیز در اینجا انجام دادیم :\n۱۰ تا گوروتین ایجاد شد و تلاش کردند برای consume آیتم ها در یک ردیف و اگر همه آیتم ها یکبار در دسترس نباشد گوروتین ها منتظر می مانند تا زمانیکه آیتم ها افزایش یابند. گوروتین اصلی صفی که ایجاد کردیم با ۱۰۰ تا آیتم پر میکند و برای هر آیتمی که اضافه می شود یکی از گوروتین هایی که منتظر آیتم ها هستش را بیدار میکند تا فرآیند خود را تکمیل کند. 9.4.12.4 کاربردها # پردازش دسته‌ای: اگر مقدار زیادی داده دارید که باید به صورت دسته‌ای پردازش شوند، می‌توانید از Cond برای سیگنال دادن به زمان آماده شدن یک دسته برای پردازش و پایان پردازش استفاده کنید. انتظار برای رویدادهای خارجی: یک Cond را می توان برای انتظار یک رویداد خارجی، مانند سیگنال از یک سرور راه دور یا تکمیل یک کار پس زمینه استفاده کرد. کنترل جریان (Flow Control): اگر چندین گوروتین دارید که باید هماهنگ شوند تا اطمینان حاصل شود که فقط تعداد معینی از گوروتین ها در یک زمان معین اجرا می شوند، می توانید از Cond برای نشان دادن زمان شروع یا توقف یک گوروتین استفاده کنید. قفل کردن و باز کردن قفل منابع: می‌توانید از یک Cond برای همگام‌سازی دسترسی به منابع مشترک با انتظار برای سیگنال قبل از دریافت قفل و علامت‌گذاری زمانی که قفل آزاد می‌شود، استفاده کنید. همگام سازی چندین گوروتین: وقتی چندین گوروتین دارید که روی یک فرآیند کار می کنند و می خواهید مطمئن شوید که همه آنها قبل از رفتن به کار بعدی تمام می شوند، می توانید از یک Cond برای علامت دادن به پایان هر گوروتین استفاده کنید و منتظر بمانید تا همه قبل از انجام کامل شوند. "},{"id":132,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-future/","title":"9.4.13 الگو Future","section":"9.4 الگوهای همزمانی","content":" 9.4.13.1 توضیحات # در زبان گو الگو Future راهی برای نمایش نتیجه یک عملیات ناهمزمان (asynchronous) است که ممکن است آن عملیات هنوز تکمیل نشده باشد اما این الگو به شما این امکان را می دهد کدی بنویسید که طوری رفتار کند که گویی نتیجه یک عملیات فورا در دسترس است. حتی اگر عملیات در پس زمینه در حال اجرا باشد.\n9.4.13.2 دیاگرام # 9.4.13.3 نمونه کد # 1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;time\u0026#34; 6) 7 8type FutureInt struct { 9\tresult chan int 10} 11 12func (f *FutureInt) Get() int { 13\treturn \u0026lt;-f.result 14} 15 16func longRunningTask() *FutureInt { 17\tf := \u0026amp;FutureInt{result: make(chan int)} 18\tgo func() { 19\ttime.Sleep(time.Second) 20\tf.result \u0026lt;- 42 21\t}() 22\treturn f 23} 24 25func main() { 26\tf := longRunningTask() 27\t// Do other things 28\tfmt.Println(\u0026#34;The answer is:\u0026#34;, f.Get()) 29} 1$ go run main.go 2The answer is: 42 در کد فوق ما یک تابع به نام longRunningTask داریم که یک تسک زمانبر را انجام می دهد و در نهایت ساختار FutureInt را بازمیگرداند و نتیجه را داخل فیلد result بواسطه کانال میریزد. حال داخل تابع main یک متغیر f ایجاد کردیم و تابع longRunningTask را داخلش قرار دادیم و پس از آن متد Get را فراخوانی کردیم.\nحال اگر تسک داخل تابع longRunningTask تمام شود و مقدار را داخل کانال result بفرستد ما می توانید مقدار را از طریق متد Get دریافت کنیم و البته تا زمانیکه تسک داخل تابع longRunningTask تمام شود.\n9.4.13.4 کاربردها # درخواست های شبکه: هنگام ایجاد درخواست های شبکه، استفاده از الگوی Future برای نمایش نتیجه درخواست می تواند مفید باشد. کوئری های پایگاه داده: هنگام کوئری از پایگاه داده، می توانید از الگوی Future برای نمایش نتیجه کوئری استفاده کنید. این به شما امکان می دهد کدی بنویسید که به گونه ای رفتار کند که گویی نتیجه بلافاصله در دسترس است، حتی اگر تکمیل کوئری ممکن است کمی طول بکشد. "},{"id":133,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-pipeline/","title":"9.4.14 الگو Pipeline","section":"9.4 الگوهای همزمانی","content":" 9.4.14.1 توضیحات # الگو خط لوله (Pipeline) یکی از پرکاربردی ترین الگوها در همزمانی می باشد شما با استفاده از این الگو می توانید تسک های بزرگ را به تسک های کوچکتر و مستقل تقسیم کنید که می توانند بطور همزمان کار کنند. هر stage داخل یک گوروتین انجام می شود و بواسطه کانال داده ها بین stage های مختلف منتقل می شود.\n9.4.14.2 دیاگرام # 9.4.14.3 نمونه کد # 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func gen(nums ...int) \u0026lt;-chan int { 6\tout := make(chan int) 7\tgo func() { 8\tdefer close(out) 9\tfor _, n := range nums { 10\tout \u0026lt;- n 11\t} 12\t}() 13\treturn out 14} 15 16func sq(in \u0026lt;-chan int) \u0026lt;-chan int { 17\tout := make(chan int) 18\tgo func() { 19\tdefer close(out) 20\tfor n := range in { 21\tout \u0026lt;- n * n 22\t} 23\t}() 24\treturn out 25} 26 27func main() { 28\t// Set up the pipeline. 29\tc := gen(2, 3) 30\tout := sq(c) 31 32\t// Consume the output. 33\tfmt.Println(\u0026lt;-out) // 4 34\tfmt.Println(\u0026lt;-out) // 9 35} 1$ go run main.go 24 39 در مثال فوق ما یک قصد داریم اعدادی را مربع کنیم :\nدر stage اول تابع gen لیست اعدادی را به عنوان ورودی دریافت می کنند و سپس داخل کانال قرار می دهد و سپس کانال فقط دریافت را بازگشت می دهد. در stage دوم تابع sq کانال فقط دریافتی را به عنوان ورودی میگیرد سپس از طریق کانال اعداد را دریافت می کنیم و اعداد را مربع می کنیم و به کانال می فرستیم و در نهایت کانال را بازگشت می دهیم. تابع main شروع کننده Pipeline ما می باشد که در ابتدا اعداد را به تابع gen میفرست و یک کانال فقط دریافت می دهد و این کانال را به stage دوم تابع sq پاس می دهیم تا اعداد مربع شوند. و در آخر از طریق کانال مقادیر مربع شده را می توانیم دریافت کنیم و نمایش دهیم. نکات مهم :\nدر الگو Pipeline مرحله (stage) اول فقط داده هایی که قرار است عملیات را انجام دهیم پاس می دهیم. در سایر stage های به عنوان ورودی و خروجی کانال فقط دریافتی به عنوان پارامتر قرار می دهیم. گوروتین داخل هر stage اجرا می شود و از تابع inline استفاده می کنیم. کانال را داخل گوروتین داخل defer قرار دهید که پس از عملیات کانال بسته شود. از context می توانید برای کنترل عملیات داخل هر stage استفاده کنید, به عنوان مثال اگر قصد داشته باشید عملیاتی را که هر stage هست متوقف کنید کافیه از context استفاده کنید تا کنترل بیشتری داشته باشید. یک مثال کاربردی دیگر\n9.4.14.4 کاربردها # شبکه : یک Pipeline می تواند برای مدیریت چندین اتصال شبکه ورودی با عبور از چندین مرحله مانند تجزیه، فیلتر کردن و مسیریابی استفاده شود. محاسبات چند مرحله ای: یک Pipeline می تواند برای انجام یک سری محاسبات روی داده های ورودی استفاده شود که در آن خروجی یک مرحله به عنوان ورودی برای مرحله بعدی استفاده می شود. پردازش گزارش: یک Pipeline می تواند برای پردازش داده های گزارش با عبور دادن آنها از مراحل مختلف مانند فیلتر کردن، تجزیه، غنی سازی و نمایه سازی استفاده شود. تجزیه و تحلیل داده ها: یک Pipeline می تواند برای پردازش مجموعه داده های بزرگ با عبور از مراحل مختلف مانند فیلتر کردن، نقشه برداری و کاهش استفاده شود. "},{"id":134,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-subscription/","title":"9.4.15 الگو Subscription","section":"9.4 الگوهای همزمانی","content":" 9.4.15.1 توضیحات # الگو Subscription یکی از الگوهای کاربردی برای پیاده سازی consumer می باشد که به یک آدرسی مشترک شوید و در بازده زمانی مختلف درخواست دهید و یکسری اطلاعات دریافت کنید.\n9.4.15.2 دیاگرام # 9.4.15.3 نمونه کد # 1package main 2 3import ( 4\t\u0026#34;context\u0026#34; 5\t\u0026#34;encoding/json\u0026#34; 6\t\u0026#34;fmt\u0026#34; 7\t\u0026#34;io/ioutil\u0026#34; 8\t\u0026#34;log\u0026#34; 9\t\u0026#34;net/http\u0026#34; 10\t\u0026#34;os\u0026#34; 11\t\u0026#34;time\u0026#34; 12) 13 14const exampleAPIAddress = \u0026#34;https://random-data-api.com/api/stripe/random_stripe\u0026#34; 15 16type Card struct { 17\tId uint `json:\u0026#34;id\u0026#34;` 18\tUid string `json:\u0026#34;uid\u0026#34;` 19\tValidCard string `json:\u0026#34;valid_card\u0026#34;` 20\tToken string `json:\u0026#34;token\u0026#34;` 21\tInvalidCard string `json:\u0026#34;invalid_card\u0026#34;` 22\tMonth string `json:\u0026#34;month\u0026#34;` 23\tYear string `json:\u0026#34;year\u0026#34;` 24\tCCV string `json:\u0026#34;ccv\u0026#34;` 25\tCCVAmex string `json:\u0026#34;ccv_amex\u0026#34;` 26} 27 28type Subscription interface { 29\tUpdates() \u0026lt;-chan Card 30} 31 32type Fetcher interface { 33\tFetch() (Card, error) 34} 35 36type sub struct { 37\tfetcher Fetcher 38\tupdates chan Card 39} 40 41type fetcher struct { 42\turl string 43} 44 45type fetchResult struct { 46\tfetchedCard Card 47\terr error 48} 49 50// NewSubscription create subscription for fetch data per freq time in second 51func NewSubscription(ctx context.Context, fetcher Fetcher, freq uint) Subscription { 52\ts := \u0026amp;sub{ 53\tfetcher: fetcher, 54\tupdates: make(chan Card), 55\t} 56\tgo s.serve(ctx, freq) 57\treturn s 58} 59 60func NewFetcher(url string) Fetcher { 61\treturn \u0026amp;fetcher{ 62\turl: url, 63\t} 64} 65 66func (f *fetcher) Fetch() (Card, error) { 67\treturn requestAPI(f.url) 68} 69 70func (s *sub) serve(ctx context.Context, freq uint) { 71\tticker := time.NewTicker(time.Duration(freq) * time.Second) 72\tdone := make(chan fetchResult, 1) 73 74\tvar ( 75\tfetchedCard Card 76\tfetchResponseStream chan Card 77\tpending bool 78\t) 79 80\tfor { 81 82\tif pending { 83\tfetchResponseStream = s.updates 84\t} else { 85\tfetchResponseStream = nil 86\t} 87 88\tselect { 89\tcase \u0026lt;-ticker.C: 90\tif pending { 91\tbreak 92\t} 93\tgo func() { 94\tfetched, err := s.fetcher.Fetch() 95\tdone \u0026lt;- fetchResult{fetched, err} 96\t}() 97\tcase result := \u0026lt;-done: 98\tfetchedCard = result.fetchedCard 99\tif result.err != nil { 100\tlog.Printf(\u0026#34;fetch got error %v\u0026#34;, result.err) 101\tbreak 102\t} 103\tpending = true 104\tcase fetchResponseStream \u0026lt;- fetchedCard: 105\tpending = false 106\tcase \u0026lt;-ctx.Done(): 107\treturn 108\t} 109\t} 110} 111 112func (s *sub) Updates() \u0026lt;-chan Card { 113\treturn s.updates 114} 115 116func requestAPI(url string) (Card, error) { 117\tcard := Card{} 118\treq, err := http.NewRequest(http.MethodGet, url, nil) 119\tif err != nil { 120\treturn Card{}, err 121\t} 122\tres, err := http.DefaultClient.Do(req) 123\tif err != nil { 124\treturn Card{}, err 125\t} 126\tbody, err := ioutil.ReadAll(res.Body) 127\tif err != nil { 128\treturn Card{}, err 129\t} 130\tif err := json.Unmarshal(body, \u0026amp;card); err != nil { 131\treturn Card{}, err 132\t} 133\treturn card, nil 134} 135 136func main() { 137\tctx, cancel := context.WithCancel(context.Background()) 138\tsub := NewSubscription(ctx, NewFetcher(exampleAPIAddress), 3) 139 140\ttime.AfterFunc(1*time.Minute, func() { 141\tcancel() 142\tlog.Println(\u0026#34;canceled subscription task\u0026#34;) 143\tos.Exit(0) 144\t}) 145 146\tfor card := range sub.Updates() { 147\tfmt.Println(card) 148\t} 149} 1$ go run main.go 2{4643 add2475a-ed64-4039-831d-0e95469752d9 371449635398431 tok_mastercard_debit 4000000000000101 01 2024 920 7875} 3{6992 a89e3d71-785a-4d37-9639-be3ce7534257 2223003122003222 tok_discover 4000000000000069 11 2024 660 5241} 4{9287 f665526e-1b34-46f5-9d9d-50362631ed0f 5200828282828210 tok_mastercard_debit 4000000000000036 05 2026 993 6272} 5{4956 e8ae8e75-0ff2-42e8-921c-5cc438d64fac 3566002020360505 tok_amex 4000000000000044 10 2024 371 9989} 6{1193 954d1b36-829b-4726-bbb7-0f5f01b3dd40 6011000990139424 tok_mastercard_debit 4000000000000341 12 2026 331 5119} برای گرفتن دیتا ما یک اینترفیس به نام Subscription با متد Updates تعریف کردیم. 1type Subscription interface { 2\tUpdates() \u0026lt;-chan Card 3} سپس یک اینترفیس دیگر به نام Fetcher برای گرفتن داده از API با متد Fetch تعریف کردیم. 1type Fetcher interface { 2\tFetch() (Card, error) 3} اکنون یک تابع به نام NewSubscription ایجاد کردیم context, NetFetcher و مدت زمان فاصله بین هر درخواست را پاس دادیم. 1ctx, cancel := context.WithCancel(context.Background()) 2sub := NewSubscription(ctx, NewFetcher(exampleAPIAddress), 3) بعد از اینکه ساختار sub را راه اندازی کردیم متد serve را برای اجرا داخل گوروتین قرار دادیم. 1func NewSubscription(ctx context.Context, fetcher Fetcher, freq uint) Subscription { 2\ts := \u0026amp;sub{ 3\tfetcher: fetcher, 4\tupdates: make(chan Card), 5\t} 6\tgo s.serve(ctx, freq) 7\treturn s 8} حال پس از هر time.Ticker به آدرس API مورد نظر بواسطه متد Fetch درخواست ارسال می شود و اطلاعات دریافت می شود به داخل کانال می فرستیم. در نهایت از طریق متد Updates می توانیم اطلاعات را دریافت کنیم.\n9.4.15.4 کاربردها # دریافت اطلاعات از یک تولید کننده (Publisher) یا آدرسی (Pub/Sub) همگام سازی اطلاعات از یک API "},{"id":135,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-brdige-channel/","title":"9.4.16 الگو Bridge Channel","section":"9.4 الگوهای همزمانی","content":" 9.4.16.1 توضیحات # با استفاده از الگو Bridge Channel می توانید بین ۲ کانال داده ای را منتقل کنید فرض کنید یک داده را به کانال input میفرستید و از دریافت داده آن را می توانید به کانال دیگری منتقل کنید و عملا شما یک پل برای انتقال داده ایجاد کردید.\n9.4.16.2 دیاگرام # 9.4.17.3 نمونه کد # 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\t// Declare input and output channels 7\tinput := make(chan int) 8\toutput := make(chan int) 9 10\t// Launch goroutine to act as bridge between channels 11\tgo func() { 12\tfor { 13\t// Wait for value on input channel 14\tvalue := \u0026lt;-input 15 16\t// Forward value to output channel 17\toutput \u0026lt;- value 18\t} 19\t}() 20 21\t// Send a value to the input channel 22\tinput \u0026lt;- 1 23 24\t// Receive the value from the output channel 25\tfmt.Println(\u0026lt;-output) // prints \u0026#34;1\u0026#34; 26} 1$ go run main.go 21 در کد فوق ما ۲ کانال input و output ایجاد کردیم سپس داخل یک گوروتین داده را از کانال input دریافت کردیم و داخل متغیر value قرار دادیم سپس value را به کانال output فرستادیم و در نهایت داده دریافت شده از کانال output را چاپ کردیم.\n9.4.18.4 کاربردها # فیلتر داده ها: یک گوروتین می تواند به عنوان پلی بین یک کانال ورودی و یک کانال خروجی عمل کند، داده ناخواسته را فیلتر کرده و فقط آنهایی را که معیارهای خاصی را برآورده می کنند، ارسال می کند. تبدیل مقادیر: یک گوروتین می تواند به عنوان پلی بین یک کانال ورودی و یک کانال خروجی عمل کند و مقادیر دریافت شده در کانال ورودی را قبل از ارسال به کانال خروجی تبدیل کند. Fan-out: یک گوروتین می تواند به عنوان پلی بین یک کانال ورودی و چندین کانال خروجی عمل کند و مقدار یکسان را به طور همزمان به چندین کانال ارسال کند. Fan-in: یک گوروتین می تواند به عنوان پلی بین چندین کانال ورودی و یک کانال خروجی واحد عمل کند و مقادیر را از چندین کانال به یک کانال به روشی کنترل شده ارسال کند. ترکیب چند کانال: یک گوروتین می تواند به عنوان پلی بین چندین کانال ورودی و یک کانال خروجی واحد عمل کند و مقادیر از چندین کانال را در یک کانال واحد ترکیب کند تا توسط یک گوروتین consume شود. "},{"id":136,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-queuing/","title":"9.4.17 الگو Queuing","section":"9.4 الگوهای همزمانی","content":" 9.4.17.1 توضیحات # الگوی \u0026ldquo;صف\u0026rdquo; در زبان گو الگویی است که در آن از یک گوروتین برای بافر کردن و مدیریت ترتیب مقادیر ارسال شده و دریافت شده از یک کانال استفاده می شود.\n9.4.17.2 دیاگرام # 9.4.17.3 نمونه کد # 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\t// Declare the queue channel with a buffer size of 5 7\tqueue := make(chan int, 5) 8 9\t// Send values to the queue 10\tgo func() { 11\tfor i := 0; i \u0026lt; 10; i++ { 12\tqueue \u0026lt;- i 13\tfmt.Println(\u0026#34;Sent:\u0026#34;, i) 14\t} 15\tclose(queue) 16\t}() 17 18\t// Receive values from the queue 19\tfor value := range queue { 20\tfmt.Println(\u0026#34;Received:\u0026#34;, value) 21\t} 22} 1$ go run main.go 2Sent: 0 3Received: 0 4Received: 1 5Sent: 1 6Sent: 2 7Sent: 3 8Sent: 4 9Sent: 5 10Sent: 6 11Sent: 7 12Received: 2 13Received: 3 14Received: 4 15Received: 5 16Received: 6 17Received: 7 18Received: 8 19Sent: 8 20Sent: 9 21Received: 9 در کد فوق ما یک کانال بافر شده با ظرفیت ۵ ایجاد کردیم. سپس داخل یک گوروتین یک حلقه قرار داده از i تا ۱۰ و مقدار i را به کانال فرستادیم و در نهایت کانال را بستیم. سپس یکی حلقه for-range برروی کانال قرار دادیم و مقادیر را دریافت کردیم و سپس چاپ کردیم.\n9.4.17.4 کاربردها # زمان‌بندی کار (Task scheduling): یک کانال می‌تواند به عنوان صف برای نگه‌داشتن وظایفی که باید توسط یک گوروتین worker اجرا و استفاده شود. کارگر وظایف را به ترتیبی که اضافه شده اند از صف می گیرد و آنها را پردازش می کند. بافر کردن داده ها: یک کانال می تواند به عنوان یک بافر برای نگهداری داده های ورودی قبل از پردازش توسط گوروتین دیگر استفاده شود. این می تواند زمانی مفید باشد که سرعت پردازش داده ها کندتر از سرعت دریافت آن باشد. Throttling: یک کانال می تواند به عنوان یک صف برای محدود کردن سرعت پردازش داده ها توسط یک گوروتین استفاده شود. با افزودن یک بافر به کانال، زمانی که بافر پر شود، گوروتین ارسال کننده مسدود می شود و به طور موثر سرعت ارسال داده ها را کاهش می دهد. Logging: یک کانال می تواند به عنوان یک صف برای نگهداری پیام های گزارشی که باید در یک فایل نوشته شود یا از طریق شبکه ارسال شود استفاده شود. کارگر گوروتین پیام‌های گزارش را به ترتیبی که اضافه شده‌اند از صف می‌گیرد و در فایل گزارش می‌نویسد. Multi-threading: یک کانال می تواند به عنوان یک صف برای به اشتراک گذاری داده ها بین گوروتین های مختلف و مدیریت همزمانی برنامه استفاده شود. "},{"id":137,"href":"/chapter-9/cloud-native-patterns/go-cloud-native-circuit-breaker-pattern/","title":"9.5.1 الگو Circuit Breaker","section":"9.5 الگوهای Cloud Native","content":"الگو Circuit Breaker\u0026hellip;\n"},{"id":138,"href":"/chapter-9/cloud-native-patterns/go-cloud-native-debounce-pattern/","title":"9.5.2 الگو Debounce","section":"9.5 الگوهای Cloud Native","content":"الگو Debounce\u0026hellip;\n"},{"id":139,"href":"/chapter-9/cloud-native-patterns/go-cloud-native-retry-pattern/","title":"9.5.3 الگو Retry","section":"9.5 الگوهای Cloud Native","content":"الگو Retry\u0026hellip;\n"},{"id":140,"href":"/chapter-9/cloud-native-patterns/go-cloud-native-throttle-pattern/","title":"9.5.4 الگو Throttle","section":"9.5 الگوهای Cloud Native","content":"الگو Throttle\u0026hellip;\n"},{"id":141,"href":"/chapter-9/cloud-native-patterns/go-cloud-native-timeout-pattern/","title":"9.5.5 الگو Timeout","section":"9.5 الگوهای Cloud Native","content":"الگو Timeout\u0026hellip;\n"},{"id":142,"href":"/chapter-9/anti-pattern/go-anti-patterns-in-syntax/","title":"9.6.1 ضد الگو سینتکسی","section":"9.6 ضد الگوها (Anti-Patterns)","content":"ضد الگو سینتکسی\n"},{"id":143,"href":"/chapter-10/10.1-data-structures-queue-stack-lists/","title":"10.1 Data Structures (Queue Stack Lists)","section":"فصل دهم: الگوریتم و ساختار داده","content":"در این قسمت به بررسی مواردی مهم از ساختمان داده در زبان گو می‌پردازیم و این آموزش مناسب افرادی هست که با مباحث ساختمان داده آشنایی داشته باشند.\n10.1.1 Queue in Golang # یک صف (queue) ساده را می توان با استفاده از GO به کمک موارد زیر پیاده سازی کرد:\ncontainer/list package slice یک صف عملیات زیر را انجام می‌دهد:\nEnqueue Dequeue Front Size Empty 10.1.1.1 List Implementation # پیاده سازی صف به کمک لیست‌ها\n1package main 2 3import ( 4 \u0026#34;container/list\u0026#34; 5 \u0026#34;fmt\u0026#34; 6) 7 8type customQueue struct { 9 queue *list.List 10} 11 12func (c *customQueue) Enqueue(value string) { 13 c.queue.PushBack(value) 14} 15 16func (c *customQueue) Dequeue() error { 17 if c.queue.Len() \u0026gt; 0 { 18 ele := c.queue.Front() 19 c.queue.Remove(ele) 20 } 21 return fmt.Errorf(\u0026#34;Pop Error: Queue is empty\u0026#34;) 22} 23 24func (c *customQueue) Front() (string, error) { 25 if c.queue.Len() \u0026gt; 0 { 26 if val, ok := c.queue.Front().Value.(string); ok { 27 return val, nil 28 } 29 return \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;Peep Error: Queue Datatype is incorrect\u0026#34;) 30 } 31 return \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;Peep Error: Queue is empty\u0026#34;) 32} 33 34func (c *customQueue) Size() int { 35 return c.queue.Len() 36} 37 38func (c *customQueue) Empty() bool { 39 return c.queue.Len() == 0 40} 41 42func main() { 43 customQueue := \u0026amp;customQueue{ 44 queue: list.New(), 45 } 46 fmt.Printf(\u0026#34;Enqueue: A\\n\u0026#34;) 47 customQueue.Enqueue(\u0026#34;A\u0026#34;) 48 fmt.Printf(\u0026#34;Enqueue: B\\n\u0026#34;) 49 customQueue.Enqueue(\u0026#34;B\u0026#34;) 50 fmt.Printf(\u0026#34;Size: %d\\n\u0026#34;, customQueue.Size()) 51 for customQueue.Size() \u0026gt; 0 { 52 frontVal, _ := customQueue.Front() 53 fmt.Printf(\u0026#34;Front: %s\\n\u0026#34;, frontVal) 54 fmt.Printf(\u0026#34;Dequeue: %s\\n\u0026#34;, frontVal) 55 customQueue.Dequeue() 56 } 57 fmt.Printf(\u0026#34;Size: %d\\n\u0026#34;, customQueue.Size()) 58} خروجی برنامه بالا:\n1Enqueue: A 2Enqueue: B 3Size: 2 4Front: A 5Dequeue: A 6Front: B 7Dequeue: B 8Size: 0 10.1.1.2 Slice Implementation # پیاده سازی صف به کمک slice\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;sync\u0026#34; 6) 7 8type customQueue struct { 9\tqueue []string 10\tlock sync.RWMutex 11} 12 13func (c *customQueue) Enqueue(name string) { 14\tc.lock.Lock() 15\tdefer c.lock.Unlock() 16\tc.queue = append(c.queue, name) 17} 18 19func (c *customQueue) Dequeue() error { 20\tif len(c.queue) \u0026gt; 0 { 21\tc.lock.Lock() 22\tdefer c.lock.Unlock() 23\tc.queue = c.queue[1:] 24\treturn nil 25\t} 26\treturn fmt.Errorf(\u0026#34;Pop Error: Queue is empty\u0026#34;) 27} 28 29func (c *customQueue) Front() (string, error) { 30\tif len(c.queue) \u0026gt; 0 { 31\tc.lock.Lock() 32\tdefer c.lock.Unlock() 33\treturn c.queue[0], nil 34\t} 35\treturn \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;Peep Error: Queue is empty\u0026#34;) 36} 37 38func (c *customQueue) Size() int { 39\treturn len(c.queue) 40} 41 42func (c *customQueue) Empty() bool { 43\treturn len(c.queue) == 0 44} 45 46func main() { 47\tcustomQueue := \u0026amp;customQueue{ 48\tqueue: make([]string, 0), 49\t} 50 51\tfmt.Printf(\u0026#34;Enqueue: A\\n\u0026#34;) 52\tcustomQueue.Enqueue(\u0026#34;A\u0026#34;) 53\tfmt.Printf(\u0026#34;Enqueue: B\\n\u0026#34;) 54\tcustomQueue.Enqueue(\u0026#34;B\u0026#34;) 55\tfmt.Printf(\u0026#34;Len: %d\\n\u0026#34;, customQueue.Size()) 56 57\tfor customQueue.Size() \u0026gt; 0 { 58\tfrontVal, _ := customQueue.Front() 59\tfmt.Printf(\u0026#34;Front: %s\\n\u0026#34;, frontVal) 60\tfmt.Printf(\u0026#34;Dequeue: %s\\n\u0026#34;, frontVal) 61\tcustomQueue.Dequeue() 62\t} 63\tfmt.Printf(\u0026#34;Len: %d\\n\u0026#34;, customQueue.Size()) 64} خروجی برنامه بالا:\nEnqueue: A Enqueue: B Size: 2 Front: A Dequeue: A Front: B Dequeue: B Size: 0 10.1.2 Stack in Golang # یک پشته (Stack) ساده را می توان با استفاده از GO به کمک موارد زیر پیاده سازی کرد:\ncontainer/list package slice یک stack عملیات زیر را انجام می‌دهد:\nPush Pop Front Size Empty 10.1.2.1 List Implementation # پیاده سازی پشته به کمک لیست‌ها\n1package main 2 3import ( 4 \u0026#34;container/list\u0026#34; 5 \u0026#34;fmt\u0026#34; 6) 7 8type customStack struct { 9 stack *list.List 10} 11 12func (c *customStack) Push(value string) { 13 c.stack.PushFront(value) 14} 15 16func (c *customStack) Pop() error { 17 if c.stack.Len() \u0026gt; 0 { 18 ele := c.stack.Front() 19 c.stack.Remove(ele) 20 } 21 return fmt.Errorf(\u0026#34;Pop Error: Stack is empty\u0026#34;) 22} 23 24func (c *customStack) Front() (string, error) { 25 if c.stack.Len() \u0026gt; 0 { 26 if val, ok := c.stack.Front().Value.(string); ok { 27 return val, nil 28 } 29 return \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;Peep Error: Stack Datatype is incorrect\u0026#34;) 30 } 31 return \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;Peep Error: Stack is empty\u0026#34;) 32} 33 34func (c *customStack) Size() int { 35 return c.stack.Len() 36} 37 38func (c *customStack) Empty() bool { 39 return c.stack.Len() == 0 40} 41 42func main() { 43 customStack := \u0026amp;customStack{ 44 stack: list.New(), 45 } 46 fmt.Printf(\u0026#34;Push: A\\n\u0026#34;) 47 customStack.Push(\u0026#34;A\u0026#34;) 48 fmt.Printf(\u0026#34;Push: B\\n\u0026#34;) 49 customStack.Push(\u0026#34;B\u0026#34;) 50 fmt.Printf(\u0026#34;Size: %d\\n\u0026#34;, customStack.Size()) 51 for customStack.Size() \u0026gt; 0 { 52 frontVal, _ := customStack.Front() 53 fmt.Printf(\u0026#34;Front: %s\\n\u0026#34;, frontVal) 54 fmt.Printf(\u0026#34;Pop: %s\\n\u0026#34;, frontVal) 55 customStack.Pop() 56 } 57 fmt.Printf(\u0026#34;Size: %d\\n\u0026#34;, customStack.Size()) 58} خروجی برنامه بالا:\n1Push: A 2Push: B 3Size: 2 4Front: B 5Pop: B 6Front: A 7Pop: A 8Size: 0 10.1.2.2 Slice Implementation # پیاده سازی پشته به کمک slice\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;sync\u0026#34; 6) 7 8type customStack struct { 9 stack []string 10 lock sync.RWMutex 11} 12 13func (c *customStack) Push(name string) { 14 c.lock.Lock() 15 defer c.lock.Unlock() 16 c.stack = append(c.stack, name) 17} 18 19func (c *customStack) Pop() error { 20 len := len(c.stack) 21 if len \u0026gt; 0 { 22 c.lock.Lock() 23 defer c.lock.Unlock() 24 c.stack = c.stack[:len-1] 25 return nil 26 } 27 return fmt.Errorf(\u0026#34;Pop Error: Stack is empty\u0026#34;) 28} 29 30func (c *customStack) Front() (string, error) { 31 len := len(c.stack) 32 if len \u0026gt; 0 { 33 c.lock.Lock() 34 defer c.lock.Unlock() 35 return c.stack[len-1], nil 36 } 37 return \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;Peep Error: Stack is empty\u0026#34;) 38} 39 40func (c *customStack) Size() int { 41 return len(c.stack) 42} 43 44func (c *customStack) Empty() bool { 45 return len(c.stack) == 0 46} 47 48func main() { 49 customStack := \u0026amp;customStack{ 50 stack: make([]string, 0), 51 } 52 fmt.Printf(\u0026#34;Push: A\\n\u0026#34;) 53 customStack.Push(\u0026#34;A\u0026#34;) 54 fmt.Printf(\u0026#34;Push: B\\n\u0026#34;) 55 customStack.Push(\u0026#34;B\u0026#34;) 56 fmt.Printf(\u0026#34;Size: %d\\n\u0026#34;, customStack.Size()) 57 for customStack.Size() \u0026gt; 0 { 58 frontVal, _ := customStack.Front() 59 fmt.Printf(\u0026#34;Front: %s\\n\u0026#34;, frontVal) 60 fmt.Printf(\u0026#34;Pop: %s\\n\u0026#34;, frontVal) 61 customStack.Pop() 62 } 63 fmt.Printf(\u0026#34;Size: %d\\n\u0026#34;, customStack.Size()) 64} خروجی برنامه بالا:\n1Push: A 2Push: B 3Size: 2 4Front: B 5Pop: B 6Front: A 7Pop: A 8Size: 0 10.1.3 Set implementation in Golang # مجموعه (set) یک ساختار داده ای است که عناصر را بدون نظم خاصی در خود نگه می دارد. یک عنصر فقط یک بار در یک مجموعه ظاهر می شود.\nSet را می توان با استفاده از map در GO پیاده سازی کرد. ما از map[string]struct{} برای مجموعه استفاده خواهیم کرد زیرا struct{} هیچ حافظه ای اشغال نمی کند، بنابراین از نظر ذخیره سازی کارآمدتر است.\nدر زیر مثال ساده مجموعه (set) که دارای عملیات زیر است را داریم:\nAdd Remove Exists 1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5) 6 7//MakeSet initialize the set 8func makeSet() *customSet { 9 return \u0026amp;customSet{ 10 container: make(map[string]struct{}), 11 } 12} 13 14type customSet struct { 15 container map[string]struct{} 16} 17 18func (c *customSet) Exists(key string) bool { 19 _, exists := c.container[key] 20 return exists 21} 22 23func (c *customSet) Add(key string) { 24 c.container[key] = struct{}{} 25} 26 27func (c *customSet) Remove(key string) error { 28 _, exists := c.container[key] 29 if !exists { 30 return fmt.Errorf(\u0026#34;Remove Error: Item doesn\u0026#39;t exist in set\u0026#34;) 31 } 32 delete(c.container, key) 33 return nil 34} 35 36func (c *customSet) Size() int { 37 return len(c.container) 38} 39 40func main() { 41 customSet := makeSet() 42 fmt.Printf(\u0026#34;Add: B\\n\u0026#34;) 43 customSet.Add(\u0026#34;A\u0026#34;) 44 fmt.Printf(\u0026#34;Add: B\\n\u0026#34;) 45 customSet.Add(\u0026#34;B\u0026#34;) 46 fmt.Printf(\u0026#34;Size: %d\\n\u0026#34;, customSet.Size()) 47 fmt.Printf(\u0026#34;A Exists?: %t\\n\u0026#34;, customSet.Exists(\u0026#34;A\u0026#34;)) 48 fmt.Printf(\u0026#34;B Exists?: %t\\n\u0026#34;, customSet.Exists(\u0026#34;B\u0026#34;)) 49 fmt.Printf(\u0026#34;C Exists?: %t\\n\u0026#34;, customSet.Exists(\u0026#34;C\u0026#34;)) 50 fmt.Printf(\u0026#34;Remove: B\\n\u0026#34;) 51 customSet.Remove(\u0026#34;B\u0026#34;) 52 fmt.Printf(\u0026#34;B Exists?: %t\\n\u0026#34;, customSet.Exists(\u0026#34;B\u0026#34;)) 53} خروجی برنامه بالا:\n1Add: B 2Add: B 3Size: 2 4A Exists?: true 5B Exists?: true 6C Exists?: false 7Remove: B 8B Exists?: false 10.1.4 Linked List in Golang # لیست منفرد یک نوع ساده از لیست پیوندی است که امکان پیمایش در یک جهت یعنی جلو را فراهم می کند. هر گره در لیست پیوندی شامل بخش داده و اشاره گر به گره بعدی در لیست پیوند شده است.\nلیست پیوندی اجرا شده در مثال زیر از عملیات زیر پشتیبانی می کند.\nAddFront AddBack RemoveFront RemoveBack Traverse Front Size 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type ele struct { 6 name string 7 next *ele 8} 9 10type singleList struct { 11 len int 12 head *ele 13} 14 15func initList() *singleList { 16 return \u0026amp;singleList{} 17} 18 19func (s *singleList) AddFront(name string) { 20 ele := \u0026amp;ele{ 21 name: name, 22 } 23 if s.head == nil { 24 s.head = ele 25 } else { 26 ele.next = s.head 27 s.head = ele 28 } 29 s.len++ 30 return 31} 32 33func (s *singleList) AddBack(name string) { 34 ele := \u0026amp;ele{ 35 name: name, 36 } 37 if s.head == nil { 38 s.head = ele 39 } else { 40 current := s.head 41 for current.next != nil { 42 current = current.next 43 } 44 current.next = ele 45 } 46 s.len++ 47 return 48} 49 50func (s *singleList) RemoveFront() error { 51 if s.head == nil { 52 return fmt.Errorf(\u0026#34;List is empty\u0026#34;) 53 } 54 s.head = s.head.next 55 s.len-- 56 return nil 57} 58 59func (s *singleList) RemoveBack() error { 60 if s.head == nil { 61 return fmt.Errorf(\u0026#34;removeBack: List is empty\u0026#34;) 62 } 63 var prev *ele 64 current := s.head 65 for current.next != nil { 66 prev = current 67 current = current.next 68 } 69 if prev != nil { 70 prev.next = nil 71 } else { 72 s.head = nil 73 } 74 s.len-- 75 return nil 76} 77 78func (s *singleList) Front() (string, error) { 79 if s.head == nil { 80 return \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;Single List is empty\u0026#34;) 81 } 82 return s.head.name, nil 83} 84 85func (s *singleList) Size() int { 86 return s.len 87} 88 89func (s *singleList) Traverse() error { 90 if s.head == nil { 91 return fmt.Errorf(\u0026#34;TranverseError: List is empty\u0026#34;) 92 } 93 current := s.head 94 for current != nil { 95 fmt.Println(current.name) 96 current = current.next 97 } 98 return nil 99} 100 101func main() { 102 singleList := initList() 103 fmt.Printf(\u0026#34;AddFront: A\\n\u0026#34;) 104 singleList.AddFront(\u0026#34;A\u0026#34;) 105 fmt.Printf(\u0026#34;AddFront: B\\n\u0026#34;) 106 singleList.AddFront(\u0026#34;B\u0026#34;) 107 fmt.Printf(\u0026#34;AddBack: C\\n\u0026#34;) 108 singleList.AddBack(\u0026#34;C\u0026#34;) 109 110 fmt.Printf(\u0026#34;Size: %d\\n\u0026#34;, singleList.Size()) 111 112 err := singleList.Traverse() 113 if err != nil { 114 fmt.Println(err.Error()) 115 } 116 117 fmt.Printf(\u0026#34;RemoveFront\\n\u0026#34;) 118 err = singleList.RemoveFront() 119 if err != nil { 120 fmt.Printf(\u0026#34;RemoveFront Error: %s\\n\u0026#34;, err.Error()) 121 } 122 123 fmt.Printf(\u0026#34;RemoveBack\\n\u0026#34;) 124 err = singleList.RemoveBack() 125 if err != nil { 126 fmt.Printf(\u0026#34;RemoveBack Error: %s\\n\u0026#34;, err.Error()) 127 } 128 129 fmt.Printf(\u0026#34;RemoveBack\\n\u0026#34;) 130 err = singleList.RemoveBack() 131 if err != nil { 132 fmt.Printf(\u0026#34;RemoveBack Error: %s\\n\u0026#34;, err.Error()) 133 } 134 135 fmt.Printf(\u0026#34;RemoveBack\\n\u0026#34;) 136 err = singleList.RemoveBack() 137 if err != nil { 138 fmt.Printf(\u0026#34;RemoveBack Error: %s\\n\u0026#34;, err.Error()) 139 } 140 141 err = singleList.Traverse() 142 if err != nil { 143 fmt.Println(err.Error()) 144 } 145 146 fmt.Printf(\u0026#34;Size: %d\\n\u0026#34;, singleList.Size()) 147} خروجی برنامه بالا:\n1AddFront: A 2AddFront: B 3AddBack: C 4Size: 3 5B 6A 7C 8RemoveFront 9RemoveBack 10RemoveBack 11RemoveBack 12RemoveBack Error: removeBack: List is empty 13TranverseError: List is empty 14Size: 0 10.1.5 Doubly Linked List in Go # یک لیست مضاعف (Doubly Linked) شامل سه قسمت در گره خود است.\nفیلد داده. یک اشاره گر بعدی به گره بعدی در لیست اشاره می کند. یک اشاره گر قبلی که به گره قبلی در لیست اشاره می کند. در اینجا فیلدهای «داده‌ها» و «بعدی» مانند لیست‌های پیوندی منفرد هستند. فیلد اشاره گر «قبلی» ویژگی جدیدی است که لیست پیوندی را به لیست پیوندی دوگانه تبدیل می کند.\nدر زیر نمونه ای از یک لیست با پیوند دوگانه آورده شده است. اشاره گر قبلی گره head (start) به Null اشاره می کند. به طور مشابه، اشاره گر Next آخرین گره به Null اشاره می کند.\nبرای پیاده‌سازی یک doubly linked list در زبان Go، یک ساختار گره با داده‌ها، اشاره‌گر قبلی و اشاره‌گر بعدی، روش‌هایی برای افزودن گره‌ها در doubly linked list (از قسمت جلویی یا از انتهای هر دو) و روش‌هایی برای پیمایش به جلو/عقب ایجاد کنید.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type node struct { 6\tdata string 7\tprev *node 8\tnext *node 9} 10 11type doublyLinkedList struct { 12\tlen int 13\ttail *node 14\thead *node 15} 16 17func initDoublyList() *doublyLinkedList { 18\treturn \u0026amp;doublyLinkedList{} 19} 20 21func (d *doublyLinkedList) AddFrontNodeDLL(data string) { 22\tnewNode := \u0026amp;node{ 23\tdata: data, 24\t} 25\tif d.head == nil { 26\td.head = newNode 27\td.tail = newNode 28\t} else { 29\tnewNode.next = d.head 30\td.head.prev = newNode 31\td.head = newNode 32\t} 33\td.len++ 34\treturn 35} 36 37func (d *doublyLinkedList) AddEndNodeDLL(data string) { 38\tnewNode := \u0026amp;node{ 39\tdata: data, 40\t} 41\tif d.head == nil { 42\td.head = newNode 43\td.tail = newNode 44\t} else { 45\tcurrentNode := d.head 46\tfor currentNode.next != nil { 47\tcurrentNode = currentNode.next 48\t} 49\tnewNode.prev = currentNode 50\tcurrentNode.next = newNode 51\td.tail = newNode 52\t} 53\td.len++ 54\treturn 55} 56func (d *doublyLinkedList) TraverseForward() error { 57\tif d.head == nil { 58\treturn fmt.Errorf(\u0026#34;TraverseError: List is empty\u0026#34;) 59\t} 60\ttemp := d.head 61\tfor temp != nil { 62\tfmt.Printf(\u0026#34;value = %v, prev = %v, next = %v\\n\u0026#34;, temp.data, temp.prev, temp.next) 63\ttemp = temp.next 64\t} 65\tfmt.Println() 66\treturn nil 67} 68 69func (d *doublyLinkedList) TraverseReverse() error { 70\tif d.head == nil { 71\treturn fmt.Errorf(\u0026#34;TraverseError: List is empty\u0026#34;) 72\t} 73\ttemp := d.tail 74\tfor temp != nil { 75\tfmt.Printf(\u0026#34;value = %v, prev = %v, next = %v\\n\u0026#34;, temp.data, temp.prev, temp.next) 76\ttemp = temp.prev 77\t} 78\tfmt.Println() 79\treturn nil 80} 81 82func (d *doublyLinkedList) Size() int { 83\treturn d.len 84} 85func main() { 86\tdoublyList := initDoublyList() 87\tfmt.Printf(\u0026#34;Add Front Node: C\\n\u0026#34;) 88\tdoublyList.AddFrontNodeDLL(\u0026#34;C\u0026#34;) 89\tfmt.Printf(\u0026#34;Add Front Node: B\\n\u0026#34;) 90\tdoublyList.AddFrontNodeDLL(\u0026#34;B\u0026#34;) 91\tfmt.Printf(\u0026#34;Add Front Node: A\\n\u0026#34;) 92\tdoublyList.AddFrontNodeDLL(\u0026#34;A\u0026#34;) 93\tfmt.Printf(\u0026#34;Add End Node: D\\n\u0026#34;) 94\tdoublyList.AddEndNodeDLL(\u0026#34;D\u0026#34;) 95\tfmt.Printf(\u0026#34;Add End Node: E\\n\u0026#34;) 96\tdoublyList.AddEndNodeDLL(\u0026#34;E\u0026#34;) 97 98\tfmt.Printf(\u0026#34;Size of doubly linked ist: %d\\n\u0026#34;, doublyList.Size()) 99 100\terr := doublyList.TraverseForward() 101\tif err != nil { 102\tfmt.Println(err.Error()) 103\t} 104 105\terr = doublyList.TraverseReverse() 106\tif err != nil { 107\tfmt.Println(err.Error()) 108\t} 109} خروجی مورد انتظار برابر حالت زیر است:\n1Add Front Node: C 2Add Front Node: B 3Add Front Node: A 4Add End Node: D 5Add End Node: E 6Size of doubly linked ist: 5 7value = A, prev = , next = \u0026amp;{B 0xc000070060 0xc000070020} 8value = B, prev = \u0026amp;{A 0xc000070040}, next = \u0026amp;{C 0xc000070040 0xc000070080} 9value = C, prev = \u0026amp;{B 0xc000070060 0xc000070020}, next = \u0026amp;{D 0xc000070020 0xc0000700a0} 10value = D, prev = \u0026amp;{C 0xc000070040 0xc000070080}, next = \u0026amp;{E 0xc000070080 } 11value = E, prev = \u0026amp;{D 0xc000070020 0xc0000700a0}, next = 12 13value = E, prev = \u0026amp;{D 0xc000070020 0xc0000700a0}, next = 14value = D, prev = \u0026amp;{C 0xc000070040 0xc000070080}, next = \u0026amp;{E 0xc000070080 } 15value = C, prev = \u0026amp;{B 0xc000070060 0xc000070020}, next = \u0026amp;{D 0xc000070020 0xc0000700a0} 16value = B, prev = \u0026amp;{A 0xc000070040}, next = \u0026amp;{C 0xc000070040 0xc000070080} 17value = A, prev = , next = \u0026amp;{B 0xc000070060 0xc000070020} 10.1.6 Tree in Go # درخت به عنوان یک ساختمان داده غیرخطی تعریف می‌شود که از مجموعه‌ای از گره‌ها تشکیل شده است، و این گره‌ها توسط یال‌ها به یکدیگر متصل شده‌اند\nخواص یک درخت:\nدرخت از یک گره ریشه و صفر یا چند درخت فرعی متصل به آن تشکیل شده است گره ریشه بالاترین گره درخت است گره‌های برگ گره‌هایی هستند که هیچ فرزندی ندارند عمق یک گره تعداد یال‌ها بین ریشه و خودش است ارتفاع یک گره تعداد یال‌ها بین خودش و دورترین گره برگ در زیردرخت خود است ‍‍\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5// Tree represents a tree structure. 6type Tree struct { 7\troot *TreeNode 8} 9 10// TreeNode represents a node in the tree. 11type TreeNode struct { 12\tdata int 13\tchildren []*TreeNode 14} 15 16// insertTree adds a new node with the given data as the root node of the tree. 17func (tree *Tree) insertTree(data int) { 18\tif tree.root == nil { 19\ttree.root = \u0026amp;TreeNode{data: data} 20\t} 21} 22 23// InsertNode adds a new node with the given data as a child of the specified node. 24func (node *TreeNode) insertNode(data int) *TreeNode { 25\tnewNode := \u0026amp;TreeNode{data: data} 26\tnode.children = append(node.children, newNode) 27\treturn newNode 28} 29 30// deleteTree removes the specified node, starting from the root of the tree. 31func (tree *Tree) deleteFromRoot(nodeToDelete *TreeNode) { 32\tif tree.root != nil { 33\ttree.root = tree.root.deleteNode(nodeToDelete) 34\t} 35} 36 37// deleteNode recursively removes the specified node and its descendants from the current node\u0026#39;s children. 38func (node *TreeNode) deleteNode(nodeToDelete *TreeNode) *TreeNode { 39\tvar updatedChildren []*TreeNode 40\tfor _, child := range node.children { 41\tif child != nodeToDelete { 42\tupdatedChildren = append(updatedChildren, child.deleteNode(nodeToDelete)) 43\t} 44} 45 46\tnode.children = updatedChildren 47\treturn node 48} 49 50// searchFromRoot searches for a node with the specified data starting from the tree\u0026#39;s root. 51func (tree *Tree) searchFromRoot(data int) *TreeNode { 52\tif tree.root != nil { 53\tnode := tree.root.searchFromNode(data) 54\treturn node 55\t} 56\t57\treturn nil 58} 59 60// searchFromNode searches for a node with the specified data starting from the current node. 61func (node *TreeNode) searchFromNode(data int) *TreeNode { 62\tif node.data == data { 63\treturn node 64\t} 65\tfor _, child := range node.children { 66\tif foundNode := child.searchFromNode(data); foundNode != nil { 67\treturn foundNode 68\t} 69\t} 70 71\treturn nil 72} 73 74// traverseFromRoot initiates a traversal of the tree starting from the root node. 75func (tree *Tree) traverseFromRoot() { 76\tif tree.root != nil { 77\ttree.root.traverse() 78\t} 79} 80 81// traverse performs a recursive traversal starting from the current node. 82func (node *TreeNode) traverse() { 83\tif node == nil { 84\treturn 85\t} 86\t87\tfmt.Printf(\u0026#34;%d \u0026#34;, node.data) 88\tfor _, child := range node.children { 89\tchild.traverse() 90\t} 91} 92 93func main() { 94\t// Creating a Tree instance 95\ttree := Tree{} 96\t97\t// Inserting nodes 98\ttree.insertTree(1) 99\ttree.root.insertNode(2) 100\tnode3 := tree.root.insertNode(3) 101\tnode4 := tree.root.insertNode(4) 102\tnode3.insertNode(5) 103\tnode3.insertNode(6) 104\tnode4.insertNode(7) 105 106\t// Traversing and printing nodes 107\tfmt.Println(\u0026#34;Traverse from root:\u0026#34;) 108\ttree.root.traverse() 109\t110\t// Searching for node 111\tfmt.Println(\u0026#34;\\nSearch for node 3:\u0026#34;) 112\tnode := tree.searchFromRoot(3) 113\tif node != nil { 114\tfmt.Println(\u0026#34;node found\u0026#34;) 115\t} else { 116\tfmt.Println(\u0026#34;node not found\u0026#34;) 117\t} 118\t119\tfmt.Println(\u0026#34;Search for node 8:\u0026#34;) 120\tnode8 := tree.searchFromRoot(8) 121\tif node8 != nil { 122\tfmt.Println(\u0026#34;node found\u0026#34;) 123\t} else { 124\tfmt.Println(\u0026#34;node not found\u0026#34;) 125\t} 126\t127\t// Deleting a node 128\tfmt.Println(\u0026#34;After deleting node 3:\u0026#34;) 129\ttree.deleteFromRoot(node3) 130\ttree.root.traverse() 131} خروجی برنامه بالا:\n1Traverse from root: 21 2 3 5 6 4 7 3Search for node 3 4node found 5Search for node 8 6node not found 7After deleting node 3: 81 2 4 7 10.1.7 Binary Tree in Go # درخت دودویی، نوعی ساختار داده‌ای درخت است که هر گره آن می‌تواند حداکثر دو فرزند (یک فرزند چپ و یک فرزند راست) داشته باشد\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5// BinaryTree represents a binary tree. 6type BinaryTree struct { 7\troot *BinaryNode 8} 9 10// BinaryNode represents a node in the binary tree. 11type BinaryNode struct { 12\tdata int 13\tleft *BinaryNode 14\tright *BinaryNode 15} 16 17// insertFromRoot inserts a new node with the given data into the tree. 18func (tree *BinaryTree) insertFromRoot(data int) *BinaryTree { 19\tif tree.root != nil { 20\ttree.root.insertNode(data) 21\t} else { 22\ttree.root = \u0026amp;BinaryNode{data: data} 23\t} 24\t25\treturn tree 26} 27 28// insertNode inserts a new node with the given data into the subtree rooted at the current node using level-order traversal. 29func (node *BinaryNode) insertNode(data int) *BinaryNode { 30\tvar tempNode *BinaryNode 31\tqueue := []*BinaryNode{node} 32\t33\tfor len(queue) \u0026gt; 0 { 34\ttempNode, queue = queue[0], queue[1:] 35\t36\tif tempNode.left == nil { 37\ttempNode.left = \u0026amp;BinaryNode{data: data} 38\tbreak 39\t} 40\tqueue = append(queue, tempNode.left)\t41\t42\tif tempNode.right == nil { 43\ttempNode.right = \u0026amp;BinaryNode{data: data} 44\tbreak 45\t} 46\tqueue = append(queue, tempNode.right) 47\t} 48 49\treturn node 50} 51 52// deleteFromRoot deletes a specific node from the binary tree starting from the root. 53func (tree *BinaryTree) deleteFromRoot(nodeToDelete *BinaryNode) { 54\tif tree.root != nil { 55\ttree.root.deleteNode(nodeToDelete) 56\t} 57} 58 59// deletetNode attempts to delete a specific node from the subtree rooted at the current node. 60func (node *BinaryNode) deleteNode(nodeToDelete *BinaryNode) *BinaryNode { 61\tvar keyNode, lastNode, tempNode *BinaryNode 62\tqueue := []*BinaryNode{node}\t63\t64\tfor len(queue) \u0026gt; 0 { 65\ttempNode, queue = queue[0], queue[1:] 66\t67\tif tempNode == nodeToDelete {\t68\tkeyNode = tempNode 69\t} 70 71\tif tempNode.left != nil { 72\tlastNode, queue = tempNode, append(queue, tempNode.left) 73\t} 74 75\tif tempNode.right != nil { 76\tlastNode, queue = tempNode, append(queue, tempNode.right) 77\t} 78\t} 79 80 81 82\tif keyNode != nil { 83\tkeyNode.data = tempNode.data 84\t85\tif lastNode.right == tempNode { 86\tlastNode.right = nil 87\t} else { 88\tlastNode.left = nil 89\t} 90\t} 91 92\treturn node 93} 94 95// searchFromRoot searches for a node with the given data in the binary tree starting from the root. 96func (tree *BinaryTree) searchFromRoot(data int) *BinaryNode { 97\tif tree.root != nil { 98\treturn tree.root.searchFromNode(data) 99\t} 100\t101\treturn nil 102} 103 104// searchFromNode performs a level-order traversal to find a node with the given data 105func (node *BinaryNode) searchFromNode(data int) *BinaryNode { 106\tvar tempNode *BinaryNode 107\tqueue := []*BinaryNode{node} 108 109\tfor len(queue) \u0026gt; 0 { 110\ttempNode, queue = queue[0], queue[1:] 111\t112\tif tempNode.data == data { 113\treturn tempNode 114\t} 115 116\tif tempNode.left != nil { 117\tqueue = append(queue, tempNode.left) 118\t} 119 120\tif tempNode.right != nil { 121\tqueue = append(queue, tempNode.right) 122\t} 123\t} 124\t125\treturn nil 126} 127 128// printTreeInOrder prints the values of nodes in the binary tree starting from root using an in-order traversal. 129func (tree *BinaryTree) printTreeInOrder() { 130\tif tree.root != nil { 131\ttree.root.printSubTreeInOrder() 132\t} 133} 134 135// printTreePreOrder prints the values of nodes in the binary tree starting from root using a pre-order traversal. 136func (tree *BinaryTree) printTreePreOrder() { 137\tif tree.root != nil { 138\ttree.root.printSubTreePreOrder() 139\t} 140} 141 142// printTreePostOrder prints the values of nodes in the binary tree starting from root using a post-order traversal. 143func (tree *BinaryTree) printTreePostOrder() { 144\tif tree.root != nil { 145\ttree.root.printSubTreePostOrder() 146\t} 147} 148 149// printSubTreeInOrder prints the values of nodes in the subtree rooted at the given node using an in-order traversal. 150func (node *BinaryNode) printSubTreeInOrder() { 151\tif node != nil { 152\tnode.left.printSubTreeInOrder() 153\tfmt.Printf(\u0026#34;%d \u0026#34;, node.data) 154\tnode.right.printSubTreeInOrder() 155\t} 156} 157 158// printSubTreePreOrder prints the values of nodes in the subtree rooted at the given node using a pre-order traversal. 159func (node *BinaryNode) printSubTreePreOrder() { 160\tif node != nil { 161\tfmt.Printf(\u0026#34;%d \u0026#34;, node.data) 162\tnode.left.printSubTreePreOrder() 163\tnode.right.printSubTreePreOrder() 164\t} 165} 166 167// printSubTreePostOrder prints the values of nodes in the subtree rooted at the given node using a post-order traversal. 168func (node *BinaryNode) printSubTreePostOrder() { 169\tif node != nil { 170\tnode.left.printSubTreePostOrder() 171\tnode.right.printSubTreePostOrder() 172\tfmt.Printf(\u0026#34;%d \u0026#34;, node.data) 173\t} 174} 175 176func main() { 177\t// Create a new binary tree 178\ttree := BinaryTree{} 179\t180\t// Insert nodes 181\ttree.insertFromRoot(1) 182\ttree.insertFromRoot(2) 183\ttree.insertFromRoot(3) 184\ttree.insertFromRoot(4) 185\ttree.insertFromRoot(5) 186\ttree.insertFromRoot(6) 187\ttree.insertFromRoot(7)\t188\t189\tfmt.Println(\u0026#34;In-Order Traversal:\u0026#34;) 190\ttree.printTreeInOrder() 191\t192\tfmt.Println(\u0026#34;\\nPre-Order Traversal:\u0026#34;) 193\ttree.printTreePreOrder() 194\t195\tfmt.Println(\u0026#34;\\nPost-Order Traversal:\u0026#34;) 196\ttree.printTreePostOrder() 197\t198\t// Search for a node 199\tfmt.Println(\u0026#34;\\n\\nSearching for node with data 6:\u0026#34;) 200\tnodeToSearch := tree.searchFromRoot(6) 201\t202\tif nodeToSearch != nil { 203\tfmt.Println(\u0026#34;found node with data 6:\u0026#34;, nodeToSearch.data) 204\t} else { 205\tfmt.Println(\u0026#34;node with data 6 not found.\u0026#34;) 206\t} 207\t208\tfmt.Println(\u0026#34;\\nSearching for node with data 9:\u0026#34;) 209\tnodeToSearch = tree.searchFromRoot(9) 210\t211\tif nodeToSearch != nil { 212\tfmt.Println(\u0026#34;found node with data 9:\u0026#34;, nodeToSearch.data) 213\t} else { 214\tfmt.Println(\u0026#34;node with data 9 not found.\u0026#34;) 215\t} 216\t217\tfmt.Println(\u0026#34;\\nDeleting node with data 4:\u0026#34;) 218\tnodeToDelete := tree.searchFromRoot(4) 219\t220\tif nodeToDelete != nil { 221\tfmt.Println(\u0026#34;deleted node with data 4.\u0026#34;) 222\ttree.deleteFromRoot(nodeToDelete) 223\t} else { 224\tfmt.Println(\u0026#34;node with data 4 not found.\u0026#34;) 225\t} 226\t227\tfmt.Println(\u0026#34;\\nIn-Order Traversal after deletion:\u0026#34;) 228\ttree.printTreeInOrder() 229} خروجی کد بالا:\n1In-Order Traversal: 24 2 5 1 6 3 7 3Pre-Order Traversal: 41 2 4 5 3 6 7 5Post-Order Traversal: 64 5 2 6 7 3 1 7 8Searching for node with data 6: 9found node with data 6: 6 10 11Searching for node with data 9: 12node with data 9 not found. 13 14Deleting node with data 4: 15deleted node with data 4. 16 17In-Order Traversal after deletion: 187 2 5 1 6 3 10.1.8 Binary Search Tree in Go # درخت جستجو دودویی یک نوع از درخت دودویی است که ب هر گره دارای یک مقدار داده و دو زیردرخت (زیردرخت چپ و زیردرخت راست) می‌باشد. در این درخت، داده‌های کوچکتر از مقدار دادهٔ گره مورد نظر در زیردرخت چپ قرار می‌گیرند و داده‌های بزرگتر در زیردرخت راست قرار می‌گیرند . درخت جستجو دودویی به گونه ای طراحی شده است که عملیات جستجو، افزودن و حذف به طور موثر انجام شود\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5// BinarySearchTree represents a binary search tree. 6type BinarySearchTree struct { 7\troot *BinarySearchNode 8} 9 10// BinarySearchNode represents a node in the binary search tree. 11type BinarySearchNode struct { 12\tdata int 13\tleft *BinarySearchNode 14\tright *BinarySearchNode 15} 16 17// insertFromRoot inserts a new node with the given data into the binary search tree, starting from the root of the tree. 18func (tree *BinarySearchTree) insertFromRoot(data int) *BinarySearchTree { 19\tif tree.root != nil { 20\ttree.root.insertNode(data) 21\t} else { 22\ttree.root = \u0026amp;BinarySearchNode{data: data} 23\t} 24\t25\treturn tree 26} 27 28// insertNode inserts a new node with the given data into the binary search tree rooted at the current node. 29func (node *BinarySearchNode) insertNode(data int) *BinarySearchNode { 30\tif node == nil { 31\treturn \u0026amp;BinarySearchNode{data: data} 32\t} else if data == node.data { 33\treturn node 34\t} else if data \u0026gt; node.data { 35\tnode.right = node.right.insertNode(data) 36\t} else { 37\tnode.left = node.left.insertNode(data) 38\t} 39 40\treturn node 41} 42 43// deleteFromRoot deletes a specific node from the binary search tree starting from the root node. 44func (tree *BinarySearchTree) deleteFromRoot(nodeToDelete *BinarySearchNode) *BinarySearchNode { 45\tif tree.root != nil { 46\treturn tree.root.left.deleteNode(nodeToDelete) 47\t} 48\t49\treturn nil 50} 51 52// deleteNode recursively deletes a specific node from the subtree rooted at the current node. 53func (node *BinarySearchNode) deleteNode(nodeToDelete *BinarySearchNode) *BinarySearchNode { 54\tif node == nil { 55\treturn nil 56\t} 57\t58\tif nodeToDelete.data \u0026lt; node.data { 59\tnode.left = node.left.deleteNode(nodeToDelete) 60\t} else if nodeToDelete.data \u0026gt; node.data { 61\tnode.right = node.right.deleteNode(nodeToDelete) 62\t} else { 63\t64\tif node.left == nil { 65\treturn node.right 66\t} else if node.right == nil { 67\treturn node.left 68\t} 69 70\tminNode := node.right.findMin() 71\tnode.data = minNode.data 72\tnode.right = node.right.deleteNode(nodeToDelete) 73\t} 74\t75\treturn node 76 77} 78 79// findMin returns the minimum node value in the subtree rooted at the current node. 80func (node *BinarySearchNode) findMin() *BinarySearchNode { 81\tfor node.left != nil { 82\tnode = node.left 83\t} 84 85\treturn node 86} 87 88// searchFromRoot searches for a node with the specified data in the binary search tree starting from the root node. 89func (tree *BinarySearchTree) searchFromRoot(data int) *BinarySearchNode { 90\tif tree.root != nil { 91\treturn tree.root.searchNode(data) 92\t} 93\t94\treturn nil 95} 96 97 98 99// searchNode recursively searches for a node with the specified data in the subtree rooted at the current node. 100func (node *BinarySearchNode) searchNode(data int) *BinarySearchNode { 101\tif node == nil { 102\treturn nil 103\t} 104 105\tif node.data == data { 106\treturn node 107\t} else if data \u0026gt; node.data { 108\treturn node.right.searchNode(data) 109\t} else if data \u0026lt; node.data { 110\treturn node.left.searchNode(data) 111\t} 112 113\treturn nil 114} 115 116// printTreeInOrder prints the values of nodes in the binary search tree starting from root using an in-order traversal. 117func (tree *BinarySearchTree) printTreeInOrder() { 118\tif tree.root != nil { 119\ttree.root.printSubTreeInOrder() 120\t} 121} 122 123// printTreePreOrder prints the values of nodes in the binary search tree starting from root using a pre-order traversal. 124 125func (tree *BinarySearchTree) printTreePreOrder() { 126\tif tree.root != nil { 127\ttree.root.printSubTreePreOrder() 128\t} 129} 130 131// printTreePostOrder prints the values of nodes in the binary search tree starting from root using a post-order traversal. 132func (tree *BinarySearchTree) printTreePostOrder() { 133\tif tree.root != nil { 134\ttree.root.printSubTreePostOrder() 135\t} 136} 137 138// printSubTreeInOrder prints the values of nodes in the subtree rooted at the given node using an in-order traversal. 139func (node *BinarySearchNode) printSubTreeInOrder() { 140\tif node != nil { 141\tnode.left.printSubTreeInOrder() 142\tfmt.Printf(\u0026#34;%d \u0026#34;, node.data) 143\tnode.right.printSubTreeInOrder() 144\t} 145} 146 147// printSubTreePreOrder prints the values of nodes in the subtree rooted at the given node using a pre-order traversal. 148func (node *BinarySearchNode) printSubTreePreOrder() { 149\tif node != nil { 150\tfmt.Printf(\u0026#34;%d \u0026#34;, node.data) 151\tnode.left.printSubTreePreOrder() 152\tnode.right.printSubTreePreOrder() 153\t} 154} 155 156// printSubTreePostOrder prints the values of nodes in the subtree rooted at the given node using a post-order traversal. 157func (node *BinarySearchNode) printSubTreePostOrder() { 158\tif node != nil { 159\tnode.left.printSubTreePostOrder() 160\tnode.right.printSubTreePostOrder() 161\tfmt.Printf(\u0026#34;%d \u0026#34;, node.data) 162\t} 163} 164 165func main() { 166\t167\t// Create a BinarySearchTree 168\tbst := \u0026amp;BinarySearchTree{} 169\tbst.insertFromRoot(5).insertFromRoot(3).insertFromRoot(7).\t170\tinsertFromRoot(2).insertFromRoot(4) 171\t172\tfmt.Println(\u0026#34;In-order traversal:\u0026#34;) 173\tbst.printTreeInOrder() 174\t175\tfmt.Println(\u0026#34;\\nPre-order traversal:\u0026#34;) 176\tbst.printTreePreOrder() 177 178\tfmt.Println(\u0026#34;\\nPost-order traversal:\u0026#34;) 179\tbst.printTreePostOrder() 180 181\t// Search for a node 182\tfmt.Println(\u0026#34;\\n Searching for node with data 1\u0026#34;) 183\tsearchNode := bst.searchFromRoot(1) 184\tif searchNode != nil { 185\tfmt.Printf(\u0026#34;Node %d found.\\n\u0026#34;, searchNode.data) 186\t} else { 187\tfmt.Println(\u0026#34;Node not found.\u0026#34;) 188\t} 189 190\t// Search for a node 191\tfmt.Println(\u0026#34;Searching for node with data 3\u0026#34;) 192\tsearchNode = bst.searchFromRoot(3) 193\tif searchNode != nil {\t194\tfmt.Printf(\u0026#34;Node %d found.\\n\u0026#34;, searchNode.data) 195\t} else { 196\tfmt.Println(\u0026#34;Node not found.\u0026#34;) 197\t} 198\t199\t// Delete a node 200\tbst.deleteFromRoot(searchNode) 201\tfmt.Println(\u0026#34;In-order traversal after deleting 3:\u0026#34;) 202\tbst.printTreeInOrder() 203} خروجی کد بالا:\n1In-order traversal: 22 3 4 5 7 3Pre-order traversal: 45 3 2 4 7 5Post-order traversal: 62 4 3 7 5 7Searching for node with data 1 8Node not found. 9Searching for node with data 3 10Node 3 found. 11In-order traversal after deleting 3: 122 4 5 7 "},{"id":144,"href":"/chapter-4/tracing/","title":"4.24 Tracing","section":"فصل چهارم: مباحث پیشرفته","content":"در این فصل، این مورد را یاد خواهیم گرفت که چگونه یک برنامه در حال اجرا را ردیابی کنیم و آن را با ابزار ردیابی مشاهده کنیم. در این حالت با استفاده از کتابخانه استاندارد، یک ردیابی ایجاد خواهیم کرد.\n4.24.1 مثال از tracing # ما برنامه ای داریم که تعداد دفعات یافتن یک topic را در collection ای ازRSS news feed document را می شمارد. این برنامه از یک threaded algorithm به نام freq استفاده می کند که روی collection تکرار می شود و هر سند را یک به یک پردازش می کند و تعداد دفعاتی که topic پیدا شده است را برمی‌گرداند.\n1func freq(topic string, docs []string) int { 2\tvar found int 3\tfor _, doc := range docs { 4\tfile := fmt.Sprintf(\u0026#34;%s.xml\u0026#34;, doc[:8]) 5\tf, err := os.OpenFile(file, os.O_RDONLY, 0) 6\tif err != nil { 7\tlog.Printf(\u0026#34;Opening Document [%s] : ERROR : %v\u0026#34;, doc, err) 8\treturn 0 9\t} 10\tdata, err := io.ReadAll(f) 11\tf.Close() 12\tif err != nil { 13\tlog.Printf(\u0026#34;Reading Document [%s] : ERROR : %v\u0026#34;, doc, err) 14\treturn 0 15\t} 16\tvar d document 17\tif err := xml.Unmarshal(data, \u0026amp;d); err != nil { 18\tlog.Printf(\u0026#34;Decoding Document [%s] : ERROR : %v\u0026#34;, doc, err) 19\treturn 0 20\t} 21\tfor _, item := range d.Channel.Items { 22\tif strings.Contains(item.Title, topic) { 23\tfound++ 24\tcontinue 25\t} 26\tif strings.Contains(item.Description, topic) { 27\tfound++ 28\t} 29\t} 30\t} 31\treturn found 32} تابع Freq کار را به چهار مرحله تقسیم می کند: باز کردن، خواندن، باز کردن و جستجو. برای تست تابع freq، تابع main مجموعه ای از فایل های 4k را می سازد و freq را فراخوانی می کند.\n1type ( 2 3item struct { 4 5XMLName xml.Name `xml:\u0026#34;item\u0026#34;` 6 7Title string `xml:\u0026#34;title\u0026#34;` 8 9Description string `xml:\u0026#34;description\u0026#34;` 10 11} 12 13 14 15channel struct { 16 17XMLName xml.Name `xml:\u0026#34;channel\u0026#34;` 18 19Items []item `xml:\u0026#34;item\u0026#34;` 20 21} 22 23 24 25document struct { 26 27XMLName xml.Name `xml:\u0026#34;rss\u0026#34;` 28 29Channel channel `xml:\u0026#34;channel\u0026#34;` 30 31} 32 33) 34 35 36 37func main() { 38 39docs := make([]string, 4000) 40 41for i := range docs { 42 43docs[i] = fmt.Sprintf(\u0026#34;newsfeed-%.4d.xml\u0026#34;, i) 44 45} 46 47topic := \u0026#34;president\u0026#34; 48 49n := freq(topic, docs) 50 51log.Printf(\u0026#34;Searching %d files, found %s %d times.\u0026#34;, len(docs), topic, n) 52 53} کدی که تکه‌ای از اسناد 4k را می‌سازد، مجموعه‌ای از فایل‌های منحصربه‌فرد را براساس یک فایل واقعی که ما newfeed.xml نامیده‌ایم ایجاد می‌کند.\n1newsfeed.xml 2 3\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; 4 5\u0026lt;?xml-stylesheet title=\u0026#34;XSL_formatting\u0026#34; type=\u0026#34;text/xsl\u0026#34;?\u0026gt; 6 7\u0026lt;rss\u0026gt; 8 9\u0026lt;channel\u0026gt; 10 11\u0026lt;title\u0026gt;\u0026lt;![CDATA[BBC News - US \u0026amp; Canada]]\u0026gt;\u0026lt;/title\u0026gt; 12 13\u0026lt;description\u0026gt;\u0026lt;![CDATA[BBC News - US \u0026amp; Canada]]\u0026gt;\u0026lt;/description\u0026gt; 14 15\u0026lt;item\u0026gt; 16 17\u0026lt;title\u0026gt;\u0026lt;![CDATA[President China visit: US leader strik]]\u0026gt;\u0026lt;/title\u0026gt; 18 19\u0026lt;description\u0026gt;\u0026lt;![CDATA[The US president praises]]\u0026gt;\u0026lt;/description\u0026gt; 20 21\u0026lt;/item\u0026gt; 22 23\u0026lt;/channel\u0026gt; 24 25\u0026lt;/rss\u0026gt; این یک نمونه بسیار کوچک از فایل newsfeed.xml است. به جای اینکه فایل های واقعی 4k را نگه داریم، فقط یک فایل را نگه می داریم و تلاش می کنیم که 4k یکی از آنها را نشان دهد. الگوریتم freq کاراکترهای اضافی را از نام فایل، قبل از باز کردن فایل حذف می کند. خوب است که یک ایده اولیه از مدت زمان لازم برای پردازش این 4000 فایل با نسخه تک رشته ای Freq داشته باشید. پس می توانیم این کار را با استفاده از time command در ارتباط با اجرای برنامه انجام دهیم.\n1$ go build 2$ time ./trace 32021/05/12 09:30:52 Searching 4000 files, found president 28000 times. 4./trace 2.63s user 0.18s system 101% cpu 2.763 total می بینیم که زمان اجرای برنامه حدود 2.7 ثانیه طول کشید تا فایل های 4k را پردازش کند. اگر قرار بود فقط فایل‌های 4k یا شاید حتی چند هزار فایل دیگر را پردازش کنیم، این برنامه تکمیل شده و تمام بود. با این حال، در نظر داریم که توانایی پردازش یک میلیون فایل را داشته باشیم و تجزیه و تحلیل آن ساعت‌ها طول نکشد. پس باید راهی برای افزایش سرعت این برنامه پیدا کنیم. در واقع می‌توانیم از یک memory profile استفاده کنیم، هر چند که این برنامه از memory گذرا زیادی استفاده می‌کند و کار زیادی نمی‌توانیم در مورد آن انجام دهیم. پس می‌توانیم از یک cpu profile استفاده کنیم. این روش به در واقع بیان می‌کند که به لطف فراخوانی با os.OpenFile، بیشتر زمان را در فراخوانی و رخدادهای سیستمی مصرف می‌کنیم. مشکل استفاده از profiler در اینجا این است که یک profiler فقط می تواند بگوید که چه اتفاقی می افتد ولی باید بدانیم چه چیزی اتفاقی می افتد و چه چیزی اتفاق نمی افتد تا راهی برای سرعت بخشیدن به این برنامه پیدا کنیم. وقتی باید ببینیم چه اتفاقی نیافتاده، ابزار ردیابی گزینه خوبی است.\n4.24.2 Generating Traces # از آنجایی که این برنامه در عرض چند ثانیه شروع و متوقف می شود، می توانیم از کتابخانه استاندارد برای ایجاد ردی از این برنامه استفاده کنم. به طور کلی، ایجاد ردیابی برای بیش از چند ثانیه از زمان اجرا می‌تواند برای بررسی سخت باشد، زیرا یک ردیابی مقدار زیادی داده تولید می‌کند. ما می خواهیم بر روی ردپاهای کوچک و هدفمند تمرکز کنیم.\n1import ( 2 3\u0026#34;runtime/trace\u0026#34; //\u0026lt;-- ADDED 4 5) 6 7 8 9func main() { 10 11trace.Start(os.Stdout) // \u0026lt;-- ADDED 12 13defer trace.Stop() // \u0026lt;-- ADDED 14 15 16 17docs := make([]string, 4000) 18 19for i := range docs { 20 21docs[i] = fmt.Sprintf(\u0026#34;newsfeed-%.4d.xml\u0026#34;, i) 22 23} 24 25 26 27topic := \u0026#34;president\u0026#34; 28 29n := freq(topic, docs) 30 31log.Printf(\u0026#34;Search %d files, found %s %d times.\u0026#34;, len(docs), topic, n) 32 33} پس از افزودن بسته trace به importها، می توانیم از توابع trace.Start و Stop استفاده کنیم. نوشتن ردیابی در stdout گرفتن و تغییر مسیر داده های ردیابی به یک فایل را ساده می کند. حالا می توانم دوباره برنامه را اجرا کنیم.\n1$ go build 2 3 4 5$ time ./trace \u0026gt; t.out 6 72021/05/12 11:57:06 Search 4000 files, found president 28000 times. 8 9./trace \u0026gt; t.out 2.71s user 0.19s system 102% cpu 2.827 total 10 11 12 13$ time ./trace \u0026gt; t.out 14 152021/05/12 11:57:11 Search 4000 files, found president 28000 times. 16 17./trace \u0026gt; t.out 2.73s user 0.18s system 108% cpu 2.683 total 18 19 20 21$ ls -l 22 23total 9136 24 25-rw-r--r-- 1 bill staff 2108 Jan 4 08:16 README.md 26 27-rw-r--r-- 1 bill staff 25544 Jan 4 08:16 newsfeed.xml 28 29-rw-r--r-- 1 bill staff 1501618 May 12 11:57 t.out 30 31-rwxr-xr-x 1 bill staff 2470208 May 12 11:57 trace 32 33-rw-r--r-- 1 bill staff 8135 May 12 11:56 trace.go ما همیشه برنامه را دو بار اجرا می کنیم تا مطمئن شوم دستگاه گرم شده است. اجرای دوم معمولا بهتر از اولین اجرا می شود و من می توانم 144 میلی ثانیه تفاوت بین این دو اجرا ببینم. همچنین می‌توانم ببینم که فایل t.out در فهرست، 1.5 مگ داده در طول 2.6 ثانیه زمان اجرا گرفته است.\n4.24.3 Generating Traces # برای بررسی ردیابی، باید از ابزار ردیابی استفاده کنم.\n1$ go tool trace t.out 2 3 4 52021/05/12 12:00:19 Parsing trace... 6 72021/05/12 12:00:19 Splitting trace... 8 92021/05/12 12:00:19 Opening browser. Trace viewer is listening on 10 11http://127.0.0.1:64321 پس از تجزیه و تقسیم فایل، یک برگه مرورگر با مجموعه ای از linkها باز می شود.\nحالا می‌خواهیم اولین link را انتخاب کنیم که یک رابط کاربری مبتنی بر Chrome را باز می‌کند که می‌تواند داده‌های ردیابی را ارائه دهد. این ابزار فقط در کروم کار می کند.\nتمام اطلاعاتی که ارائه می شود تا میکروثانیه زمان وقوع آن ثبت می شود. در سمت چپ، می توانیم دسته های مختلف اطلاعات نموداری را ببینم.\nدر هر زمان معین در ردیابی موارد زیر را داریم:\n● Goroutines: The number of Goroutines.\n● Heap: The amount of memory in-use on the heap.\n● Threads: The number of operating system threads.\n● GC: The start/end of each GC with details.\n● Syscalls: The start/end of any system call with details.\n● Procs: The activity on each logical processor.\nاولین کاری که باید انجام دهیم اندازه گیری مدت زمان اجرای برنامه بر اساس داده های ردیابی است. می‌توانیم این کار را با ابزار زمان بندی، که آخرین ابزار در toolbar است، انجام دهیم.\nاگرtimeline کل ردیابی را انتخاب کنیم، برابر 2.67 ثانیه خواهد بود که تقریباً به آنچه time command ارائه شده است نزدیک است. نکته بعدی که می‌خواهم بدانم این است که اندازه heap چقدر ثابت مانده است یا چقدر بزرگ‌تر شده است. برای این کار باید نمای نمودار را گسترش می دهیم و سپس از ابزار انتخاب (اولین ابزار در نوار ابزار) برای انتخاب قسمت بالای نمودار heap استفاده می کنبم.\nدو رنگ (یا سایه) وجود دارد که در نمودار heap نشان داده شده است. نارنجی (سایه تیره تر) میزان حافظه در حال استفاده روی heap را در هر میکروثانیه نشان می دهد. سبز (سایه روشن‌تر) نشان‌دهنده زمانی است که GC بعدی بر اساس زمانی که آن مقدار حافظه دوباره در heap مورد استفاده قرار می‌گیرد، راه‌اندازی می‌شود.\nبه همین دلیل است که وقتی ناحیه نارنجی به بالای منطقه سبز می رسد، یک خط در قسمت GC وجود دارد. هر خط نشان دهنده یک GC است که اتفاق افتاده است.\nاز آنجایی که ناحیه سبز در یک خط مستقیم ثابت برای کل اجرای برنامه است، می توانم هر نقطه نارنجی را برای دیدن حداکثر اندازه heap انتخاب کنیم. در این صورت اگر بخواهم در مورد این عدد وضوح بیشتری داشته باشم، می توانیم از GODEBUG استفاده کنیم و دوباره برنامه را اجرا کنیم.\n1$ time GODEBUG=gctrace=1 ./trace \u0026gt; t.out 2 3gc 1 @0.016s 0%: 0.020+0.29+0.024 ms clock, 0.32+0.18/0.12/0.12+0.39 ms cpu, 4 54-\u0026gt;4-\u0026gt;0 MB, 5 MB goal, 16 P 6 7gc 2 @0.029s 0%: 0.030+0.23+0.002 ms clock, 0.49+0.15/0.17/0.001+0.037 ms 8 9cpu, 4-\u0026gt;4-\u0026gt;0 MB, 5 MB goal, 16 P 10 11gc 3 @0.040s 0%: 0.033+0.26+0.019 ms clock, 0.52+0.15/0.15/0.059+0.31 ms 12 13cpu, 4-\u0026gt;4-\u0026gt;0 MB, 5 MB goal, 16 P 14 15. . . 16 17gc 273 @2.793s 0%: 0.043+0.46+0.040 ms clock, 0.70+0.24/0.18/0.25+0.65 ms 18 19cpu, 4-\u0026gt;4-\u0026gt;0 MB, 5 MB goal, 16 P 20 21gc 274 @2.804s 0%: 0.043+0.35+0.002 ms clock, 0.69+0.28/0.37/0.16+0.042 ms 22 23cpu, 4-\u0026gt;4-\u0026gt;0 MB, 5 MB goal, 16 P 24 25gc 275 @2.814s 0%: 0.032+0.28+0.017 ms clock, 0.52+0.20/0.26/0.026+0.28 ms 26 27cpu, 4-\u0026gt;4-\u0026gt;0 MB, 5 MB goal, 16 P 28 292021/05/12 15:17:24 Searching 4000 files, found president 28000 times. اینطور به نظر می‌رسد که ، heap در meg 4 نگهداری می شد و تمام memory گذرا بوده است زیرا هر GC منجر به صفر بودن تعداد مقادیر زنده می شد. دقیقاً همان چیزی است که در ردیابی می بینیم. چیزی که واقعاً به آن نیاز داریم اطلاعات بیشتری در مورد GC است. این در مورد 1 GC نیست، بلکه در مورد همه GCهایی است که باید انجام شوند. پس می توانیم این اطلاعات را با استفاده از ابزار انتخاب و دوبار کلیک کردن روی هر خط آبی GC بدست بیاورم.\nاین اعداد در تعیین میزان کار GC در اجرای برنامه مفید هستند. با این اعداد ما یک پایه برای عملکرد برنامه داریم. با اعداد پایه، هنوز پاسخی در مورد اینکه چگونه می توانم برنامه را سرعت بخشم، نداریم. شاید نگاه کردن به بخش بزرگتری از نمودار کمک کند؟\n![[Pasted image 20230619032144.png]]\nاگر به این بخش از ردیابی دقیق تر نگاه کنیم، می توانیم مشکل را ببینیم. این برنامه فقط از یک پردازنده منطقی در هر زمان معین برای اجرای کار برنامه استفاده می کند. با این حال GC بیشتر منابع استفاده می کند. اگر الگوریتم را به صورت همزمان و friendly برای استفاده از تمام هسته‌های موجود در دستگاه خود تغییر دهیم، شاید این باید به بهبود performance کمک کند.\n4.24.4 الگوی Fan-Out # یکی از الگوهای concurrency که می‌توانم استفاده کنیم، الگوی fan-out است. این الگو به ما اجازه می دهد تا یک الگوریتم همزمان با کمترین مقدار تغییر کد داشته باشم. ایده این الگو این است که برای هر فایلی که نیاز به پردازش دارد، یک گوروتین ایجاد می‌کند و به scheduler اجازه می‌دهد تمام Goroutine را مدیریت کند و آنها را در تمام پردازنده‌های منطقی زمان‌بندی کند. ما می توانیم همه این گوروتین ها را fan-out کنیم زیرا ترتیب کار مهم نیست. مهم این است که همه چیز درست انجام شود.\n1func freqConcurrent(topic string, docs []string) int { 2 3 4 5var found int 6 7g := len(docs) // \u0026lt;-- ADDED 8 9var wg sync.WaitGroup // \u0026lt;-- ADDED 10 11wg.Add(g) // \u0026lt;-- ADDED 12 13 14 15for _, doc := range docs { 16 17. . . 18 19} 20 21 22 23wg.Wait() //\u0026lt;-- ADDED 24 25return int 26 27} برای شروع، باید کدی اضافه کنیم که مطمئن شویم تا زمانی که کار کامل نشده است، تابع freq برنگردد. این به بهترین وجه با استفاده از WaitGroup پیاده سازی می شود. ما با شناسایی تعداد گوروتین هایی که باید ایجاد شوند شروع می کنیم، که با طول docs collection نشان داده می شود. سپس آن عدد را به WaitGroup اضافه می کنم و در پایان تابع منتظر می مانم تا WaitGroup دوباره به صفر برسد.\n1func freqConcurrent(topic string, docs []string) int { 2 3 4 5var found int 6 7 8 9g := len(docs) 10 11var wg sync.WaitGroup 12 13wg.Add(g) 14 15for _, doc := range docs { 16 17go func(doc string) { // \u0026lt;-- ADDED 18 19defer wg.Done() // \u0026lt;-- ADDED 20 21. . . 22 23}(doc) // \u0026lt;-- ADDED 24 25} 26 27 28 29 30wg.Wait() 31 32return int 33 34} برای شروع، باید کدی اضافه کنیم که مطمئن شود تا زمانی که کار کامل نشده است، تابع freq برنگردد. این به بهترین وجه با استفاده از WaitGroup پیاده سازی می شود. من با شناسایی تعداد گوروتین هایی که باید ایجاد شوند شروع می کنیم، که با طول مجموعه اسناد نشان داده می شود. سپس آن عدد را به WaitGroup اضافه می کنیم و در پایان تابع منتظر می مانم تا WaitGroup دوباره به صفر برسد.\nدر مرحله بعد، کد موجود را در داخل حلقه for range حول یک Goroutine می پیچیم، جایی که هر document تکرار شده به Goroutine جدید منتقل می شود تا از هرگونه اشکال بسته شدن جلوگیری شود. با وجود Goroutine، می‌توانیم کد WaitGroup را با اطمینان از اینکه هر Goroutine ()wg.Done را قبل از پایان آن فراخوانی می‌کند، نهایی کنیم. آخرین کاری که باید انجام دهیم این است که هنگام پردازش یک فایل، مقدار بازگشتی 0 را از تمام شرایط خطای داخل حلقه حذف کنیم. ممکن است فکر کنیم این کد آماده است زیرا تمام هماهنگی ها با WaitGroup در جای خود است، اما اگر این کد را با race detector اجرا کنیم چه اتفاقی می افتد؟\n1 2$ go build -race 3 4$ ./trace \u0026gt; t.out 5 6================== 7 8WARNING: DATA RACE 9 10Read at 0x00c000157548 by goroutine 21: 11 12main.freq.func1() 13 14/Users/bill/code/go/src/github.com/ardanlabs/gotraining/topics/go/ 15 16profiling/trace/trace.go:103 +0x644 17 18Previous write at 0x00c000157548 by goroutine 66: 19 20main.freq.func1() 21 22/Users/bill/code/go/src/github.com/ardanlabs/gotraining/topics/go/ 23 24profiling/trace/trace.go:103 +0x65d 25 26. . . 27 28================== دو خط اول در خروجی می گوید که یک خواندن و یک نوشتن قبلی در همان محل حافظه در همان خط کد در داخل تابع تحت اللفظی وجود دارد. با این وجود در خط 103 چه کدی وجود دارد؟\n196 for _, item := range d.Channel.Items { 2 397 if strings.Contains(item.Title, topic) { 4 598 found++ 6 799 continue 8 9100 } 10 11101 12 13102 if strings.Contains(item.Description, topic) { 14 15103 found++ 16 17104 } 18 19105 } اگر شماره خطوط را به کد اضافه کنیم، می توانیم ببیینم که مورد مربوط به افزایش متغیر پیدا شده است. این کد در واقع دوباره در خط 98 استفاده می شود، بنابراین هر دو خط کد (98، 103) حاوی یک data race است. برای رفع این data race، باید افزایش متغیر پیدا شده را برای استفاده از یک atomic instruction. تغییر دهیم. برای این کار می توانم از atomic package استفاده کنم.\n196 for _, item := range d.Channel.Items { 2 397 if strings.Contains(item.Title, topic) { 4 598 atomic.AddInt32(\u0026amp;found, 1) // \u0026lt;-- CHANGED 6 799 continue 8 9100 } 10 11101 12 13102 if strings.Contains(item.Description, topic) { 14 15103 atomic.AddInt32(\u0026amp;found, 1) // \u0026lt;-- CHANGED 16 17104 } 18 19105 } ما خطوط 98 و 103 را برای استفاده از تابع atomic.AddInt32 جایگزین کردم. مشکل این است که این تابع به int32 نیاز دارد نه int، بنابراین باید دو تغییر دیگر انجام دهم.\n1func freq(topic string, docs []string) int { 2 3var found int32 // \u0026lt;-- CHANGED 4 5. . . 6 7wg.Wait() 8 9return int(found) // \u0026lt;-- CHANGED 10 11} این تغییرات برای استفاده از تابع atomic.AddInt32 و بازگرداندن یک عدد صحیح ضروری است. با این تغییرات، data race از بین خواهد رفت. با این حال، هنوز مشکل دیگری در مورد کد وجود دارد. اینکه آنقدرها هم که می‌توانست با حافظه پنهان سازگار نباشد.\n4.24.5 Cache Friendly # در حال تکمیل \u0026hellip;\n"}]