[{"id":0,"href":"/sponsors/","title":"اسپانسرهای کتاب","section":"صفحه اصلی","content":" سرویس ابری فینگ سکوی ابری\nبا سکوی ابری فینگ شما روی کد تمرکز کنید، فینگ آن را اجرا می‌کند.\nمشاهده سرویس\nسرویس ابری دارکوب سکوی ابری\nبا پلتفرم ابری دارکوب، سریع و آسان از مزایا و امکانات کوبرنتیز استفاده کنید.\nمشاهده سرویس\nاسپانسر کتاب شوید اسپانسر\nشما هم می توانید با ارایه خدمات خود اسپانسر کتاب شوید.\nدرخواست اسپانسر شدن\n"},{"id":1,"href":"/preface/","title":"پیشگفتار","section":"صفحه اصلی","content":" چرا از گو استفاده می‌کنیم؟\nوقتی در نوامبر سال ۲۰۰۹ رابرت گریسیمر، راب پایک و کن تامپسون برای اولین‌بار گو را بصورت عمومی انتشار دادند، خودشان مطمئن نبودند که به‌صورت گسترده مورد استفاده قرار می‌گیرد یا خیر. تا به تاریخ انتشار این مطلب، مشخص شده،‌گو بسیار فراگیرتر و رشد آن در صنعت وسیع‌تر از چیزی بوده‌است که ایجادکنندگان آن حدس می‌زدند. این‌ها نمونه‌هایی از کاربرد گو در دنیای امروز تکنولوژی هستند:\nGoogle’s Core Data Solutions Team Uses Go تیم راهکار هسته‌ی داده گوگل از گو استفاده می‌کند Chrome Content Optimization Service Runs on Go سرویس بهینه‌سازی محتوا در گوگل‌کروم توسط گو در حال اجراست Chrome’s user experience strategy, operating in the critical path for users is implemented in Go استراتژی حیاتی تجربه کاربری در کروم توسط گو پیاده‌سازی شده است Firebase Hosting Team Scaled With Go ابزار قدرتمند فایربیس توسط گو گسترش یافته است همچنین در صفحه رسمی گو می‌توانید لیستی از شرکت‌ها از Netflix و PayPal تا Uber و Microsoft رو به‌همراه خدماتی که از گو گرفته‌اند رو ملاحظه کنید. https://go.dev/solutions/#case-studies شناخت نیازمندی و ابزارهای پیاده‌سازی وابسته به آن.\nCloud \u0026amp; Network Services Command-line Interfaces Web Development DevOps \u0026amp; Site Reliability انواع منابع موجود جهت کسب اطلاعات و مقایسه‌ی آنها.\nمنابع مکتوب. سایت رسمی زبان گو. https://go.dev در نسخه حال‌حاضر وب‌سایت رسمی گو، مستندات لازم برای شناخت انواع جزئیات وجود دارد. ضمن‌اینکه یک خودآموز مختصر، جهت آشنایی ابتدایی مفاهیم را می‌توانید پیدا کنید. کتاب‌ها. اصولاً استفاده از کتاب‌ها بدلیل اینکه عمدتاً توسط اساتید، متخصصین شناخته‌شده نگارش می‌شود، توصیه می‌گردد. ضمن اینکه کتاب‌ها معمولاً امکان اصلاحات مستمر و انتشار نسخه‌های جدید و به‌روزتر رو دارا هستند و توسط ناشران معتبر منتشر می‌شوند. مقالات. بدلیل راحت‌تر بودن نشر مقالات، طبیعتاً امکان وجود هرنوع مطلبی با هر سطح و کیفیتی از محتوا وجود دارد. بنابراین، در استفاده از این نوع منابع، احتیاط و حساسیت بالاتری مورد نیاز است. منابع صوتی و تصویری. مزیت بزرگ این نوع از منابع، سرعت و امکانات کافی در انتقال مطلب است. اما اشکالی که وجود دارد عدم امکان ساده‌ی اصلاح محتوا و به‌روزرسانی آن است. ضمن‌اینکه این نوع از منابع، مانند مقالات توسط افراد مختلف و با طیفی از انواع کیفیت‌های متفاوت، وجود دارد. بررسی وضعیت منابع فارسی زبان گو در زمان تهیه این کتاب. درحال‌حاضر منابع نگارشی با کیفیت مناسب به‌زبان فارسی بسیار محدود است. این یکی از دلایل «چرایی» نگارش این کتاب به‌زبان فارسی است. ما امیدواریم با مشارکت همه اساتید و متخصصین این حوزه، این کتاب منبع آموزشی باکیفیت، دردسترس عموم متقاضیان، جهت توسعه ابزارهای حرفه‌ای با زبان گو باشد.\nچرا به زبان فارسی می‌نویسیم. دوستان و همکاران بسیاری هستند،‌که این سوال را مطرح می‌کنند که وقتی نیاز به دانش زبان انگلیسی، برای کسب مهارت در این تخصص، یک «باید» محسوب می‌شود، چرا مطلب فارسی؟ جواب این سوال ساده‌تر از پیجیدگی‌هایی هست که بنظر می‌رسد: − ایجاد و رونق جامعه تخصصی فارسی‌زبان توسط موضوع «کتاب» − ایجاد فضایی جهت ایحاد پرسش و پاسخ فارسی‌زبان‌ها − ارائه یک ترجمه فارسی، از منابع اصلی تخصصی، با امکان مقایسه برداشت افراد مختلف از زبان تخصصی − سرعت دادن به یادگیری، حداقل در مفاهیم ابتدایی − برای نوجوانان و افرادی که به‌هر دلیل، درحال‌حاضر تسلط کافی روی زبان انگلیسی ندارند و ارائه راهکار جهت تمرین و شروع یادگیری منابع روی زبان تخصصی\nبرای چگونگی نگارش کتاب می‌توان به موارد زیر اشاره کرد:\nچگونه از جامعه تخصصی، می‌توان در آموزش،بهینه‌سازی و رشد دانش متقاضیان این تخصص استفاده کرد. یکی از وظایف هر استاد، تربیت «شاگرد» و توسعه دانش است. افراد تازه‌کار با دانش و تجربه پیشکسوتان، با سرعت و کیفیت بالاتر، تبدیل به متخصصین جدید خواهند شد. کیفیت جامعه متخصصین، امکان کنترل مصرف منابع و تولید ابزارهای مفید را تعیین خواهد کرد. کار تیمی، به فرهنگ «با هم کار کردن» نیازمند هست.\nچرخ را از نو نسازیم، تجربه‌ها را از نو «تجربه» نکنیم، آموزش ببینیم و آموزش بدهیم. با کمی دقت و تجربه، کاملاً بدیهی‌ست در مقام قیاس بین چند جامعه تخصصی همسان، برتری از آن کسانی‌ست که در انتقال دانش-تجربه دست‌و‌دل‌بازتر هستند. جامعه تخصصی با دانش و تجربه عمیق، نیازمند وجود «مبتدیان» با پتانسیل حداکثری است و این میسر نیست مگر با جریان ساده و پایدار آموزش \u0026hellip; دانش امروز، در هر رشته و هر سطح برآیند «انتقال» پیشینیان ما هست. بجای غرور ناشی از آن می‌توان از انتقال با احترام آن به دیگران لذت برد.\n«کلمات» قدرت دارند. به درک و استفاده از کلمات احترام بگذاریم. در جامعه تخصصی حتی چند‌برابر !!! تا جای ممکن، در استفاده از کلمات تخصصی در محل درست خود دقت شده تا مفهوم نادرست منتقل نشود. از شما خواننده عزیز هم تقاضا داریم، هرکجا ایرادی هرچند کوچک ملاحظه فرمودید، به ما اطلاع دهید یا درخواست اصلاح آن را ارسال کنید.\n"},{"id":2,"href":"/history/","title":"تاریخچه","section":"صفحه اصلی","content":"زبان گو (Go) در سال ۲۰۰۷ (به شمسی: ۱۳۸۶) توسط «شرکت گوگل» با هدف افزایش بهره‌وری برنامه‌نویسی در محیط چندهسته‌ای، رایانه‌های شبکه‌ای و کدبیس‌های بزرگ طراحی شد [به نقل از ویکی پدیا] و سپس به عنوان یک زبان کامپایلری و تایپ استاتیک در نوامبر سال ۲۰۰۹ بصورت عمومی با هدف کامپایل کارآمد ، اجرای کارآمد وسهولت برنامه نویسی معرفی شد که توسط شرکت گوگل توسعه داده شده است و بسیاری از اعضای تیم طراحی و توسعه زبان گو [Ken Thompson, Rob Pike, Robert Griesemer] سال ها تجربه در زمینه تحقیق و توسعه زبان برنامه نویسی دارند.\nزبان گو دارای یک سری ویژگی های منحصر به فرد می باشد و برخی از ویژگی هایش از سایر زبان ها الهام گرفته شده است :\nپشتیبانی از برنامه نویسی همزمانی بصورت Built-in گوروتین ها امکان اجرای همزمانی توابع را فراهم می کند و همچنین گوروتین ها واقعا خیلی سبک هستند به طوری که شما می توانید هزاران گوروتین را همزمان در سخت افزارهای مدرن بدون هیچ مشکل عملکردی اجرا کنید. کانال ها برپایه مدل CSP می باشد که امکان همگام سازی داده ها بین گوروتین ها را فراهم می کند. پشتیبانی از تایپ های map و slice امکان پیاده سازی پلی مورفیسم با استفاده از اینترفیس ها پوینترها کلوژر توابع (یک تابع معمولی که داخل یک تابع دیگر به عنوان بازگشت تعریف می شود) متدها امکان defer برای تعویق فراخوانی یک تابع قابلیت جاسازی تایپ ها ایمنی حافظه در زبان گو قابلیت زباله جمع کن خودکار سازگاری کامل با انواع پلتفرم ها نظیر [linux, windows, mac, AIX, android, freeBSD] جهت توسعه و کامپایل امکان Cross-compile با این امکان می توانید در هر پلتفرمی برای سایر پلتفرم ها کامپایل کنید پشتیبانی از جنریک یا تایپ پارامتر (از نسخه ۱.۱۸) تست نویسی آسان اینترفیس و رفلکشن زبان گو مثل سایر زبان ها نظیر c, cpp یا java نیاز به نقطه ویرگول (Semicolons) ندارد و به نسبت زبان هایی که معرفی کردیم پرانتز کمتری استفاده می کند و همچنین ظاهر سینتکس گو خیلی خواناتر و راحتر می باشد. علاوه بر ویژگی های که در بالا معرفی کردیم یک سری نکات برجسته در خصوص زبان گو وجود دارد که به شرح زیر می باشند:\nسینتکس زبان گو به گونه ای طراحی شده که خیلی ساده و تمیز می باشد و این باعث می شود خیلی سریع زبان گو را یاد بگیرید و از همه مهم تر توسعه پروژه های مقیاس پذیر مقیاس پذیر با زبان گو به دلیل سادگی و آشکار بودن مفاهیم خیلی سریعتر صورت میگیرد.\nزبان گو دارای کلی پکیج های استاندارد و کاربردی جهت توسعه می باشد که همه این پکیج ها در انواع پلتفرم ها جهت توسعه قابل استفاده است.\nزبان گو دارای یک جامعه بزرگ از توسعه دهندگان و انجمن های فعال می باشد که خیلی سریع می توانید به پاسخ سوالات خود برسید.\nبرنامه نویس های زبان گو را گوفر صدا میزنند. "},{"id":3,"href":"/installation/","title":"آموزش نصب","section":"صفحه اصلی","content":"جهت نصب زبان گو برروی سیستم عامل مورد نظر خود در ابتدا باید نسخه مناسب با پلت فرم خود را دانلود کنید.\nلینوکس در اینجا نسخه مرتبط با لینوکس خود را دانلود کنید. 1$ wget -c https://go.dev/dl/go1.xx.x.linux-amd64.tar.gz سپس دستور زیر را بزنید تا اگر نسخه قبلی وجود دارد پاک شود و نسخه جدید در مسیر usr/local/go/ جایگزین شود. 1$ sudo rm -rf /usr/local/go \u0026amp;\u0026amp; sudo tar -C /usr/local -xzf go1.xx.x.linux-amd64.tar.gz افزودن مسیر usr/local/go/bin/ به متغیرهای محیطی 1export PATH=$PATH:/usr/local/go/bin بهتر است برای اینکه هر بار ترمینال را باز میکنید و فایل go توسط shell شناخته شود دستور فوق را به فایل home/{user}/.profile/ اضافه کنید. جهت اطمینان از اینکه زبان گو بدرستی برروی سیستم عامل شما نصب شده است دستور زیر را داخل ترمینال بزنید. 1$ go version ویندوز روش اول # در اینجا نسخه مرتبط با ویندوز خود را دانلود کنید. سپس فایل go1.xx.x.windows-{arch}.msi را اجرا کنید. مراحل نصب را بصورت پیش فرض طی کنید تا زبان گو برروی ویندوز نصب شود. پس از نصب جهت اطمینان از نصب بود زبان گو مراحل زیر را انجام دهید: وارد منو استارت شوید. در منو استارت کلمه cmd را جستجو کنید و سپس آن را اجرا کنید. داخل خط فرمان دستور زیر را بزنید تا از نصب بودن زبان گو اطمینان حاصل فرمایید. 1go version روش دوم # برای نصب گو می‌توانید از Chocolatey Package Manager استفاده کنید.\nخط فرمان PowerShell را به صورت Administrator باز کنید و دستور زیر را داخل PowerShell بزنید. 1Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString(\u0026#39;https://community.chocolatey.org/install.ps1\u0026#39;)) بعد از نصب می‌توانید از دستور choco برای نصب گو استفاده کنید. 1choco install golang جهت اطمینان از اینکه زبان گو بدرستی برروی سیستم عامل شما نصب شده است دستور زیر را داخل ترمینال بزنید. 1$ go version دقت داشته باشید برای نصب برنامه‌های مختلف مثل git و یا ابزارهای دیگر در محیط Administrator باید از دستور choco استفاده کنید. مکینتاش روش اول # در اینجا نسخه مرتبط با مکینتاش خود را دانلود کنید. سپس فایل go1.xx.x.darwin-{arch}.pkg را اجرا کنید. مراحل نصب را بصورت پیش فرض طی کنید تا زبان گو برروی مکینتاش نصب شود. پس از نصب اگر ترمینال باز بود آن را کامل ببنید تا تغییرات صورت گیرد. جهت اطمینان از اینکه زبان گو بدرستی برروی سیستم عامل شما نصب شده است دستور زیر را داخل ترمینال بزنید. 1$ go version روش دوم # برای نصب گو میتوانید از Homebrew Package Manager استفاده کنید.\nبرای نصب brew می‌توانید ترمینال خود را باز کنید و از دستور زیر استفاده کنید. 1$ /bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026#34; بعد از نصب brew از دستور زیر برای نصب گو داخل ترمینال استفاده کنید. 1$ brew update \u0026amp;\u0026amp; brew install golang جهت اطمینان از اینکه زبان گو بدرستی برروی سیستم عامل شما نصب شده است دستور زیر را داخل ترمینال بزنید. 1$ go version "},{"id":4,"href":"/toolchain/","title":"ابزارها, دستورات گو و معرفی IDE","section":"صفحه اصلی","content":"پس از اینکه زبان گو را برروی سیستم خود نصب کردید از طریق ترمینال و یا خط فرمان ویندوز قابل دسترس است که می‌توانید با زدن کلمه go یکسری عملیات انجام دهید:\n1$ go 2Go is a tool for managing Go source code. 3 4Usage: 5 6\tgo \u0026lt;command\u0026gt; [arguments] 7 8The commands are: 9 10\tbug start a bug report 11\tbuild compile packages and dependencies 12\tclean remove object files and cached files 13\tdoc show documentation for package or symbol 14\tenv print Go environment information 15\tfix update packages to use new APIs 16\tfmt gofmt (reformat) package sources 17\tgenerate generate Go files by processing source 18\tget add dependencies to current module and install them 19\tinstall compile and install packages and dependencies 20\tlist list packages or modules 21\tmod module maintenance 22\twork workspace maintenance 23\trun compile and run Go program 24\ttest test packages 25\ttool run specified go tool 26\tversion print Go version 27\tvet report likely mistakes in packages 28 29Use \u0026#34;go help \u0026lt;command\u0026gt;\u0026#34; for more information about a command. 30 31Additional help topics: 32 33\tbuildconstraint build constraints 34\tbuildmode build modes 35\tc calling between Go and C 36\tcache build and test caching 37\tenvironment environment variables 38\tfiletype file types 39\tgo.mod the go.mod file 40\tgopath GOPATH environment variable 41\tgopath-get legacy GOPATH go get 42\tgoproxy module proxy protocol 43\timportpath import path syntax 44\tmodules modules, module versions, and more 45\tmodule-get module-aware go get 46\tmodule-auth module authentication using go.sum 47\tpackages package lists and patterns 48\tprivate configuration for downloading non-public code 49\ttestflag testing flags 50\ttestfunc testing functions 51\tvcs controlling version control with GOVCS 52 53Use \u0026#34;go help \u0026lt;topic\u0026gt;\u0026#34; for more information about that topic. جدول دستورات (Commands) # دستور توضیحات build با این دستور (go build main.go) می‌توانید فایل go را کامپایل کنید. clean با این دستور می‌توانید فایل‌های کش‌شده را پاکسازی کنید. doc با این دستور (go doc fmt.Println) می‌توانید داکیومنت هر یک از توابع عمومی را ببینید. env با این دستور می‌توانید متغیرهای محیطی تنظیم شده زبان گو را ببینید و آنها را با دستور go env -w key=value مقدار دهی کنید. fmt با این دستور می‌توانید کدهای خود را مرتب go fmt ./... کنید. install با استفاده از این دستور می‌توانید یکسری پکیج‌های را گرفته و کامپایل کنید. list لیست پکیج‌ها و ماژول‌های دانلود شده. generate با این دستور می‌توانید از قابلیتGenerator زبان گو استفاده کنید و فایل generate کنید. mod برای مدیریت و ایجاد فایل mod به ازای هر پروژه. get با این دستور می‌توانید پکیجی را دانلود یا بروز رسانی کنید و همچنین برای استفاده از این دستور نیاز به git دارید که نصب باشد. work با این دستور می‌توانید یک workspace ایجاد کنید و آن را مدیریت کنید. run با این دستور (go run main.go) می‌توانید فایل‌های گو یا پروژه را اجرا کنید. test با این دستور (go test example_test.go) می‌توانید فایل‌های تست را اجرا کنید. version با این دستور می‌توانید نسخه نصب شده زبان گو را ببینید. vet با این دستور می‌توانید اشتباهات کدهای خود را ببینید. اجرای کد ساده در زبان گو # در زیر یک نمونه کد ساده قرار دادیم که به سادگی می‌توانید با دستور go run main.go اجرا کنید و خروجی را ببینید.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 fmt.Println(\u0026#34;Hello world!!!\u0026#34;) 7} 1$ go run main.go 2Hello world!!! در کد فوق ما یکسری کلید واژه نظیر package , import , func استفاده کردیم که در بخش 1.2 کلید واژه و شناسه‌ها با آنها آشنا می‌شوید.\nانواع نرم‌افزارهای محیط توسعه (IDE) و ویرایش‌گر کد (Code Editor) # در زبان برنامه‌نویسی گو نیز مثل سایر زبان‌ها، می‌توان از ابزارهای کدنویسی مانند نرم‌افزارهای محیط توسعه و همچنین از ویرایش‌گرهای کد استفاده کرد که محبوب‌ترین‌ها معرفی می‌شوند:\nنرم‌افزار Jetbrains Goland اگر با سایر محصولات جت‌برینز آشنا باشید به‌راحتی می‌توانید از این نرم‌افزار محیط توسعه استفاده کنید. نرم‌افزار VsCode تقریباً همه برنامه‌نویس‌ها با آن آشنا هستند. یک ویرایش‌گر کد متن باز می‌باشد که بین برنامه‌نویس‌ها خیلی محبوب است و برای استفاده زبان گو در این نرم‌افزار می‌توان افزونه vscode-go را نصب کنید. نرم‌افزار Vim یک نرم‌افزار متن باز و معروف می‌باشد که داخل ترمینال قابل استفاده است و از آن می‌توانید جهت توسعه با زبان گو استفاده کنید و البته نیازمند نصب پلاگین می‌باشد. "},{"id":5,"href":"/roadmap/","title":"نقشه یادگیری زبان گو","section":"صفحه اصلی","content":"در زیر ما نقشه یادگیری زبان گو را براساس داده های سایت roadmap.sh قرار دادیم که در ابتدا باید طبق نقشه یادگیری زبان گو شروع کنید و سپس برای افزایش دانش خود به نقشه یادگیری بک اند نگاهی بندازید.\n"},{"id":6,"href":"/changes-log/","title":"تغییرات نسخه های زبان گو","section":"صفحه اصلی","content":"\n2022-08-02 نسخه 1.19 بزودی تکمیل می شود\n2022-03-15 نسخه 1.18 بزودی تکمیل می شود\n2021-08-16 نسخه 1.17 بزودی تکمیل می شود\n2021-02-16 نسخه 1.16 بزودی تکمیل می شود\n2020-08-11 نسخه 1.15 بزودی تکمیل می شود\n2020-02-25 نسخه 1.14 بزودی تکمیل می شود\n2019-09-03 نسخه 1.13 بزودی تکمیل می شود\n2019-02-25 نسخه 1.12 بزودی تکمیل می شود\n2018-08-24 نسخه 1.11 بزودی تکمیل می شود\n2018-02-16 نسخه 1.10 بزودی تکمیل می شود\n2017-08-24 نسخه 1.9 بزودی تکمیل می شود\n2017-02-16 نسخه 1.8 بزودی تکمیل می شود\n2016-08-15 نسخه 1.7 بزودی تکمیل می شود\n2016-02-17 نسخه 1.6 بزودی تکمیل می شود\n2015-08-19 نسخه 1.5 بزودی تکمیل می شود\n2014-12-10 نسخه 1.4 بزودی تکمیل می شود\n2014-06-18 نسخه 1.3 بزودی تکمیل می شود\n2013-12-01 نسخه 1.2 بزودی تکمیل می شود\n2013-05-13 نسخه 1.1 بزودی تکمیل می شود\n2012-03-28 نسخه 1 بزودی تکمیل می شود\n"},{"id":7,"href":"/chapter-1/","title":"فصل اول: آشنایی با مفاهیم گو","section":"صفحه اصلی","content":"در فصل اول به مفاهیم پایه زبان برنامه‌نویسی گو بطور عمیق می‌پردازیم. این فصل شامل چندین بخش هست :\n1.1 ساختار کد گو 1.2 کلید واژه و شناسه‌ها 1.3 تایپ های پایه 1.4 عملگرها 1.5 متغیرها و constant 1.6 مقادیر صفر تایپ ها (zero values) 1.7 تابع (function) 1.8 آرایه و slice 1.9 حلقه ها (for) 1.10 نقشه map 1.11 شرط (if, switch) 1.12 اضافه کردن پکیج در کد (package) 1.13 defer, panic, recovery 1.14 لیست تایپ ها و توابع Builtin 1.15 قالب بندی رشته ها "},{"id":8,"href":"/chapter-1/structure-of-go-code/","title":"1.1 ساختار کد گو","section":"فصل اول: آشنایی با مفاهیم گو","content":"همانطور که در تاریخچه زبان گو گفتیم, زبان گو سینتکس خیلی تمیز و ساده ای دارد که به راحتی می توانید کدهای زبان گو را بخوانید. در ادامه ما سعی می کنیم با مثال های ساده شما را با ساختار کد زبان گو آشنا کنیم.\nبه نقل از تاریخچه سینتکس زبان گو به گونه ای طراحی شده که خیلی ساده و تمیز می باشد و این باعث می شود خیلی سریع زبان گو را یاد بگیرید و از همه مهم تر توسعه پروژه های مقیاس پذیر با زبان گو به دلیل سادگی و آشکار بودن مفاهیم خیلی سریعتر صورت میگیرد. 1.1.0 زبان برنامه نویسی # یک زبان برنامه‌نویسی یک زبان مصنوعی انگلیسی است که برای بیان محاسباتی که توسط یک ماشین (مخصوصاً رایانه) قابل انجام است، طراحی شده‌است. زبان‌های برنامه‌نویسی برای ایجاد برنامه‌هایی به کار می‌روند که رفتار یک ماشین را مشخص می‌کنند، الگوریتم دقیق را بیان می‌کنند، یا روشی برای تعامل انسان و رایانه هستند. بسیاری از زبان‌های برنامه‌نویسی تعدادی قالب از ویژگی‌های نوشته شده دستوری یا نحو (syntax) و معناشناسی (semantics) دارند، چرا که رایانه‌ها دستورهای دقیقاً مشخص نیاز دارند. برخی توسط سند خصوصیات (specification document) تعیین شده‌اند (برای مثال یک استاندارد ISO)، در حالی که برخی دیگر دارای پیاده‌سازی غالبی می‌باشند[به نقل از ویکی پدیا].\n1.1.1 پکیج # هر برنامه‌ای که با ساختار گو ایجاد شده باشد، از پکیج(ها) ساخته شده است. درواقع زبان گو یک زبان بر پایه پکیج است. برخلاف برخی دیگر که بر پایه فایل هستند. این به‌این‌معنی است که به «مجموعه»ای از ابزارها اعم از ثابت‌ها، متغیرها و عملیات مختلف که زیرمجموعه یک نام تعریف می‌شوند، پکیج می‌گوئیم. تفاوتی ندارد در یک «فایل» یا «چند» فایل، بشرطی که ابتدای همگی package name باشد.\n1.1.2 یک نمونه کد ساده زبان گو # قبل از اینکه محتوای بدنه کد زیر را بررسی کنید بهتره نحوه کامنت گذاری کد در زبان گو آشنا شوید.\n1.1.2.1 کامنت گذاری # کامنت ها در زبان گو همانند زبان سی می باشد که با قرار دادن ۲ اسلش در ابتدای خط یا قرار دادن یک یا چند خط ما بین /* و */ ایجاد میشود.\n1// کامنت عادی یک خطی 2 3/* 4بلاک کامنت برای نوشتن کامنت چند خطی 5*/ 1.1.2.2 نمونه کد # در پایین یک نمونه کد قرار دادیم که با کامنت هر کدام از بخش های بدنه کد گو را توضیح دادیم\n1package main // نام پکیج فایل سورس را مشخص می کند 2 3import \u0026#34;math/rand\u0026#34; // یک پکیج استاندارد ایمپورت شده 4 5const MaxRnd = 16 // یک ثابت تعریف شده است 6 7// تابع 8func StatRandomNumbers(n int) (int, int) { 9\tvar a, b int 10\tfor i := 0; i \u0026lt; n; i++ { 11\tif rand.Intn(MaxRnd) \u0026lt; MaxRnd/2 { 12\ta = a + 1 13\t} else { 14\tb++ 15\t} 16\t} 17\treturn a, b 18} 19 20// تابع main اولین نقطه شروع اجرای کد شما می باشد که در این تابع سایر موارد تعریف می شود. 21func main() { 22\tvar num = 100 23\tx, y := StatRandomNumbers(num) 24\tprint(\u0026#34;Result: \u0026#34;, x, \u0026#34; + \u0026#34;, y, \u0026#34; = \u0026#34;, num, \u0026#34;? \u0026#34;) 25\tprintln(x+y == num) 26} سورس کد بالا را در فایلی با نام basic-code-element-demo.go ذخیره می کنیم و سپس با دستور زیر اجرا می کنیم تا خروجی کد فوق را ببینیم :\n1$ go run basic-code-element-demo.go 2Result: 46 + 54 = 100? true 1.1.3 تابع main # در زبان گو پکیج main به عنوان یک پکیج منحصربه فرد در نظر گرفته می‌شود، به شکلی که در هنگام اجرای برنامه مشخص میکند شروع کار و خواندن برنامه از کجا باید باشد. در نهایت داخل این پکیج ما تابع ()main را داریم که این تابع نقطه شروع اجرای برنامه ما خواهد بود. این تابع هیچ ارگومانی نمیگیرد و هیچ چیزی رو هم بازگشت نخواهد داد. زبان گو به صورت خودکار تابع ()main را فراخوانی می‌کند. برای همین نیازی به فراخوانی این تابع توسط شما وجود ندارد. برای همین باید دقت داشته باشید در هر برنامه ای که می‌نویسید حتما از پکیج و تابع main باید استفاده کنید.\n1// تعریف پکیج main 2package main 3 4// تعریف تابع main 5func main() { 6\tprintln(\u0026#34;Hello GoFarsi!\u0026#34;) 7} 1.1.4 اجرای کد # برای اجرای کدهای گو می‌توان از پارامتر run استفاده کرد.\n1$ go run main.go 2Result: Hello GoFarsi! دستور بالا ابتدا داخل پوشه temp سیستم شما یک فایل اجرایی را درست میکند و سپس آن فایل را اجرا میکند و در نهایت خروجی را به ما نشان میدهد. اگر شما بخواهید خروجی فایل اجرایی (executable) داشته باشید و سپس آن را اجرا کنید می‌توانید از دستور زیر استفاده کنید:\n1$ go build main.go 2$ ./main 3Result: Hello GoFarsi! اگر بخواهید برای خروجی فایل اجرایی اسمی در نظر بگیرید میتوانید از دستور زیر با پارامتر o- استفاده کنید.\n1$ go build -o goFarsi main.go 2$ ./goFarsi 3Result: Hello GoFarsi! دقت کنید اگر از سیستم عامل ویندوز استفاده میکنید بعد از وارد کردن اسم پسوند exe را نیز اضافه کنید. برای راحتی و سرعت بخشیدن هنگام توسعه ما از دستور go run استفاده می‌کنیم. 1.1.5 بررسی syntax # برخلاف بیشتر زبان‌های برنامه نویسی در زبان گو شما نمی‌توانید از حالت های مختلف برای نوشتن کد خود استفاده کنید. مثلا کد زیر هنگام کامپایل کردن خطا میدهد.\n1package main 2 3func main() 4{ 5\tprintln(\u0026#34;not compiled\u0026#34;) 6} خروجی کد بالا :\n1$ go run main.go 2Result: 3# command-line-arguments 4.\\main.go:4:1: syntax error: unexpected semicolon or newline before { صرفا با تغییر براکت ما با خطا مواجه شدیم. شاید از دید شما این نوع نوشتن کد نباید خطا ایجاد کند. ولی وقتی شما داخل یک تیم هستید و مجبور هستید کدها را بازخوانی کنید تا بفهمید چه اتفاقی افتاده است، با حالتهای مختلف سینتکس مواجه نخواهید شد، و همه کدها یک دست و از یک ساختار پیروی می‌کند. که باعث خواندن سریع تر، درک بهتر و امکان توسعه سریعتر را برای ما و هم تیمی های ما ایجاد خواهد کرد.\n1.1.5.1 استفاده از go fmt # برای آنکه از این نوع خطاها جلوگیری شود و فرمت مناسب و یک نواختی داخل کدهای ما وجود داشته باشد، خود IDEها این خطاها را بهمون نشون میدن. خود توسعه دهندگان زبان گو پارامتر fmt یا به عبارتی فرمت را در اختیار ما قرار داده اند تا هر زمان که کدی مینویسم و ذخیره میکنیم بتوانیم با استفاده از این دستور ساختار کد خود را مرتب کنید و اگر خطایی وجود داشته باشد قبل از کامپایل کردن برنامه آن را پیدا و رفع کنیم. مثلا خروجی استفاده از پارامتر fmt\n1$ go fmt main.go 2Result: 3.\\main.go:4:1: unexpected semicolon or newline before { حالا فرض کنید کدی را نوشته اید و داخل کد شما فضای زیادی وجود دارد و اندازه tab ها و space ها مشخص نیست. به مثال زیر توجه کنید:\n1package main 2 3func main(){ 4 5 6 7\tprintln(\u0026#34;print line 1\u0026#34;) 8\t9\t10\t11\t12println(\u0026#34;print line 2\u0026#34;) 13\t14\t15} وقتی کدی شبیه کد بالا را دارید و از دستور go fmt استفاده میکنیم خروجی کد بالا به شکل زیر تغییر پیدا می‌کند:\n1package main 2 3func main() { 4 5\tprintln(\u0026#34;print line 1\u0026#34;) 6\t7\tprintln(\u0026#34;print line 2\u0026#34;) 8} در برنامه فوق ما یکسری کلمات کلیدی نظیر package, import, const, func, var , for, if, else, return استفاده کردیم و سایر کلماتی که داخل کد فوق دیدید به عنوان شناسه می باشد. برای اطلاعات بیشتر در خصوص کلید واژه و شناسه لطفا بخش کلید واژه و شناسه ها را مطالعه فرمایید. "},{"id":9,"href":"/chapter-1/go-built-in-keywords-identifiers/","title":"1.2 کلید واژه و شناسه‌ها","section":"فصل اول: آشنایی با مفاهیم گو","content":"در این بخش قصد داریم به کلید واژه و شناسه های زبان گو بپردازیم.\n1.2.1 کلید واژه # زبان گو تا نسخه فعلی فقط ۲۵ تا کلید واژه دارد که به شرح زیر است:\n1 2 3 4 5 1 break default func interface select 2 case defer go map struct 3 chan else goto package switch 4 const fallthrough if range type 5 continue for import return var کلمات کلیدی فوق به ۴ دسته تقسیم می‌شوند که به شرح زیر می‌باشد:\nکلمات کلیدی که بصورت گلوبال در بدنه قرار می‌گیرند «package, import, type, var, const, func» کلمات کلیدی کامپوزیت «struct, inteface, map, chan» کلمات کلیدی که در جریان کنترل کد استفاده می‌شوند «break, case, continue, default, if, else, for, fallthrough, goto, range, return, switch, select» در بخش های دیگر کتاب ما بطور مفصل به مفاهیم کلمات کلیدی فوق می‌پردازیم. 1.2.2 شناسه‌ها # شناسه توکنی است که باید از حروف یونیکد, ارقام یونیکد (اعداد دسته بندی شده در استاندارد ۸.۰ یونیکد) و خط زیرین ـ تشکیل شده باشد.\nعلامت کاربرد ـ نادیده گرفتن \u0026amp; دسترسی به آدرس حافظه * دسترسی مقدار داخل یک خانه حافظه 1.2.2.1 قوانین شناسه‌ها # نامگذاری باید از حروف a-z یا A-Z و یا 0-9 باشد. نام شناسه‌ها نباید با اعداد شروع شود. نام شناسه‌ها به حروف بزرگ و کوچک حساس می‌باشد. استفاده از کلید واژه ممنوع می‌باشد. هیچ محدودیتی در تعداد حروف نام شناسه وجود ندارد و مطلوب ترین حالت ۴ الی ۱۵ حرف می‌باشد. 1// شناسه‌های معتبر 2 3_geeks23 4geeks 5gek23sd 6Geeks 7geeKs 8geeks_geeks 9 10// شناسه‌های نامعتبر 11 12212geeks 13if 14default در زبان گو یکسری شناسه‌ها از قبل برای برخی از بخش های کد تعیین شده است که در زیر می‌توانید ببینید :\n1// Constant (ثابت ها) 2 3true, false, iota, nil 4 5// Types (تایپ ها) 6 7int, int8, int16, int32, int64, uint, 8uint8, uint16, uint32, uint64, uintptr, 9float32, float64, complex128, complex64, 10bool, byte, rune, string, error 11 12// Functions (توابع) 13 14make, len, cap, new, append, copy, close, 15delete, complex, real, imag, panic, recover "},{"id":10,"href":"/chapter-1/go-basic-types/","title":"1.3 تایپ های پایه","section":"فصل اول: آشنایی با مفاهیم گو","content":" 1.3.1 تایپ چیست؟ # یک تایپ مشخص کننده نوع داده است، که به کامپایلر می‌گوید قرار است چه نوع داده ای داخل یک متغییر ذخیره گردد. زبان ها انواع تایپ های مختلفی به صورت پیشفرض دارند که می‌توان از آن‌ها داخل برنامه خود استفاده کرد. ما می‌توانیم تایپ ها را به دو دسته کلی تعریف کنیم.\n1.3.1.1 تایپ ایستا (Static Type) # زبانی مثل زبان گو یک زبان تایپ ایستا است، یعنی وقتی ما یک داده ای از نوع عددی داخل یک متغیر تعریف می‌کنیم داخل همان متغیر امکان اضافه کردن داده ای غیر داده عددی وجود ندارد.\n1.3.1.2 تایپ پویا (Dynamic Type) # زبان‌هایی مثل PHP، JavaScript و \u0026hellip; جزو زبان‌های تایپ پویا هستند. یعنی وقتی یک متغیری از نوع عددی تعریف می‌کنیم می‌توانیم به همان متغیر مقادیر دیگه‌ای مثل مقادیر رشته‌ای اضافه کنیم.\nبرای اطلاعات بیشتر می‌توان تایپ سیستم را داخل ویکی‌پدیا مطالعه کنید.\n1.3.2 تایپ‌ها در زبان گو # زبان گو مثل سایر زبان‌ها یکسری تایپ‌های پایه دارد که در هر بخش از کد گو می‌توانید استفاده کنید. در ادامه ما این تایپ ها را با مقادیر پیش فرض‌شان معرفی می کنیم.\nتایپ محدوده مقدار پیش فرض یا مقدار صفر حجم استفاده از حافظه int بستگی به معماری سیستم عامل که ۳۲ بیت یا ۶۴ بیت باشد 0 ۴ یا 8 بایت int8 128- تا 127 0 ۱ بایت int16 32768- تا 32767 0 ۲ بایت int32 2147483648- تا 2147483647 0 ۴ بایت int64 9223372036854775808- تا 9223372036854775807 0 8 بایت uint بستگی به معماری سیستم عامل که ۳۲ بیت یا ۶۴ بیت باشد 0 ۴ یا 8 بایت uint8 0 تا 255 0 ۱ بایت uint16 0 تا 65535 0 ۲ بایت uint32 0 تا 6294967295 0 ۴ بایت uint64 0 تا 18446744073709551615 0 8 بایت uintptr عدد خیلی بزرگ 0 ۸ بایت float32 IEEE-754 0 ۴ بایت float64 IEEE-754 0 ۸ بایت complex64 - 0+0i ۸ بایت complex128 - 0+0i ۱۶ بایت bool - false ۱ بایت string - \u0026quot; \u0026quot; ۸ بایت زبان گو بطور پیش فرض از دو نوع تایپ با نام مستعار پشتیبانی می کند :\nتایپ byte این تایپ نام مستعار برای تایپ uint8 می باشد. تایپ rune این تایپ نام مستعار برای تایپ int32 می باشد. 1.3.3 سفارشی‌سازی تایپ‌(ها) # نام‌گذاری جدید : برای تایپ‌های رشته‌ای، عددی و بول، می‌توان نام سفارشی جدید انتخاب و در پروژه استفاده کرد: 1 2/* type alias */ 3 4// bul and bool define the same type. 5type bul = bool 6// content and string define the same type. 7type content = string 8// UI8, uint8 and byte define the same type. 9type UI8 = uint8 10// Word, rune and int32 define the same type. 11type Word = rune ایجاد تایپ جدید معادل یک تایپ موجود : همچنین می‌توان از تایپ‌های موجود، یک نمونه جدید ایجاد کرد: 1/* type definition */ 2 3// state and bool are two different types. 4type state bool 5// str and string are two different types. 6type str string 7// ID and uint64 are two different types. 8type ID uint64 9// decimal and float32 are two different types. 10type decimal float32 1.3.4 مقدار پیش فرض تایپ ها # هر یک از تایپ ها در زبان گو دارای مقدار پیش فرضی می باشد که به شرح زیر است :\nتایپ بولین مقدار پیش فرضش false می باشد. تمامی تایپ اعداد (int, uint, float) مقدار پیش فرضش صفر می باشد. تایپ استرینگ مقدار پیش فرضش \u0026quot; \u0026quot; می باشد. 1.3.5 انواع مقادیر تایپ ها # در زبان گو تایپ ها یکسری مقادیر مختلفی را دریافت می کنند که در زیر به این مقادیر می پردازیم.\n1.3.5.1 تایپ بولین # تایپ بولین فقط true و false را به عنوان مقدار دریافت می کند.\n1.3.5.2 تایپ Integer # تایپ اعداد ۴ نوع مقدار مختلف دریافت می کند که به ترتیب Decimal (پایه ۱۰), Octal (پایه ۸), Hex (پایه ۱۶) و Binrary (پایه ۲ یا دودویی) می باشد.\n10xF // the hex form (starts with a \u0026#34;0x\u0026#34; or \u0026#34;0X\u0026#34;) 20XF 3 4017 // the octal form (starts with a \u0026#34;0\u0026#34;, \u0026#34;0o\u0026#34; or \u0026#34;0O\u0026#34;) 50o17 60O17 7 80b1111 // the binary form (starts with a \u0026#34;0b\u0026#34; or \u0026#34;0B\u0026#34;) 90B1111 10 1115 // the decimal form (starts without a \u0026#34;0\u0026#34;) 1package main 2 3func main() { 4\tprintln(15 == 017) // true 5\tprintln(15 == 0xF) // true 6} 1.3.5.3 تایپ Float # تایپ Float چند نوع مقدار را دریافت می کند که به ترتیب مقدار ممیز شناور اعشاری ممکن است شامل یک قسمت صحیح اعشاری، یک نقطه اعشاری، یک قسمت کسری اعشاری، و یک قسمت توانی عدد صحیح (مبتنی بر 10) باشد.\n11.23 201.23 // == 1.23 3.23 41. 5// An \u0026#34;e\u0026#34; or \u0026#34;E\u0026#34; starts the exponent part (10-based). 61.23e2 // == 123.0 7123E2 // == 12300.0 8123.E+2 // == 12300.0 91e-1 // == 0.1 10.1e0 // == 0.1 110010e-2 // == 0.1 120e+5 // == 0.0 1.3.5.4 تایپ rune # تایپ rune یک تایپ با نام مستعار int32 می باشد که از تایپ های اعداد صحیح خاصی هستند. در rune برای ذخیره نقطه یونیکد یا حروف خاص استفاده می شود که زیر به عنوان نمونه قرار دادیم.\n1\u0026#39;a\u0026#39; // an English character 2\u0026#39;π\u0026#39; 3\u0026#39;众\u0026#39; // a Chinese character 1// 141 is the octal representation of decimal number 97. 2\u0026#39;\\141\u0026#39; 3// 61 is the hex representation of decimal number 97. 4\u0026#39;\\x61\u0026#39; 5\u0026#39;\\u0061\u0026#39; 6\u0026#39;\\U00000061\u0026#39; 1package main 2 3func main() { 4\tprintln(\u0026#39;a\u0026#39; == 97) 5\tprintln(\u0026#39;a\u0026#39; == \u0026#39;\\141\u0026#39;) 6\tprintln(\u0026#39;a\u0026#39; == \u0026#39;\\x61\u0026#39;) 7\tprintln(\u0026#39;a\u0026#39; == \u0026#39;\\u0061\u0026#39;) 8\tprintln(\u0026#39;a\u0026#39; == \u0026#39;\\U00000061\u0026#39;) 9\tprintln(0x61 == \u0026#39;\\x61\u0026#39;) 10\tprintln(\u0026#39;\\u4f17\u0026#39; == \u0026#39;众\u0026#39;) 11} 1.3.5.4 تایپ رشته (string) # در زبان گو مقدار تایپ رشته بطور پیش فرض از نوع یونیکد UTF-8 می باشد.\n1// The interpreted form. 2\u0026#34;Hello\\nworld!\\n\\\u0026#34;你好世界\\\u0026#34;\u0026#34; 3 4// The raw form. 5`Hello 6world! 7\u0026#34;你好世界\u0026#34;` همچنین رشته از کارکترهای خاص یونیکد مانند 0x0D پشتیبانی می کند.\n1.3.6 خوانایی بهتر اعداد با _ # در زبان گو شما می توانید برای خوانایی بهتر اعداد چند رقمی از _ برای جداسازی استفاده کنید.\n1// Legal ones: 26_9 // == 69 30_33_77_22 // == 0337722 40x_Bad_Face // == 0xBadFace 50X_1F_FFP-16 // == 0X1FFFP-16 60b1011_0111 + 0xA_B.Fp2i 7 8// Illegal ones: 9_69 // _ can\u0026#39;t appear as the first character 1069_ // _ can\u0026#39;t appear as the last character 116__9 // one side of _ is a illegal character 120_xBadFace // \u0026#34;x\u0026#34; is not a legal octal digit 131_.5 // \u0026#34;.\u0026#34; is not a legal octal digit 141._5 // \u0026#34;.\u0026#34; is not a legal octal digit "},{"id":11,"href":"/chapter-1/go-operators/","title":"1.4 عملگرها","section":"فصل اول: آشنایی با مفاهیم گو","content":"زبان گو هم مثل سایر زبان ها دارای یکسری عملگرها مانند: عملگرهای حسابی, عملگرهای مقایسه ای, عملگرهای منطقی و عملگرهای بیتی می باشد.\n1.4.1 عملگرهای حسابی # زبان گو دارای ۵ تا عملگر حسابی می باشد که به ترتیب :\nعملگر نام + جمع - تفریق * ضرب / تقسیم % باقی مانده این ۵ تا عملگر اغلب به ترتیب مجموع, تفاوت, حاصلضرب و ضریب نیز نامیده می شوند.\n1 a := 1 2 b := 2 3 4 c := a + b // 3 5 d := a - b // -1 6 e := a * b // 2 7 f := a / b // 0 8 g := a % b // 1 در کد نمونه بالا ما := که متغیر کوتاه است استفاده کردیم که در بhttps://book.gofarsi.ir/chapter-1/go-variables-and-consts/خش 1.5 متغیرها و ثابت ها معرفی خواهیم کرد. 1.4.2 عملگرهای مقایسه ای # زبان گو دارای ۶ عملگر مقایسه ای می باشد که به ترتیب :\nعملگر نام == مساوی بودن =! مساوی نبودن با \u0026gt; کمتر از =\u0026gt; کمتر یا مساوی \u0026lt; بزرگتر =\u0026lt; بزرگتر یا مساوی نتیجه این استفاده از این عملگرهای مقایسه فوق یک نوع untyped بولین است یعنی حاصل این مقایسه ها در واقع true یا false است.\n1 a := 1 2 b := 2 3 c := 1 4 5 println(a == b) // false 6 println(a == c) // true 7 println(a \u0026lt; b) // true 8 println(b \u0026gt; c) // true 9 println(c \u0026lt;= a) // true 10 println(c \u0026gt;= b) // false 11 println(b != a) // true 12 println(c != a) // false 1.4.3 عملگرهای منطقی # زبان گو دارای ۳ نوع عملگر منطقی می باشد که به ترتیب :\nعملگر نام \u0026amp;\u0026amp; AND || OR ! NOT عملگر \u0026amp;\u0026amp; به انگلیسی AND به فارسی و , اگر هردو عملگر true باشد مقدار بازگشتی true و در غیر اینصورت false خواهد بود. عملگر || به انگلیسی OR به فارسی یا , اگر یکی از عملگرها true باشد مقدار بازگشتی true در غیر این صورت false خواهد بود. عملگر ! به انگلیسی NOT به فارسی ‍‍منفی یا نفی , زمانیکه شما از عملگر ! استفاده می کنید معکوس نتیجه عملوند را نیاز دارید. 1a := true 2b := true 3c := false 4 5fmt.Println(a \u0026amp;\u0026amp; b) //true 6fmt.Println(a || b) //true 7fmt.Println(!a) //false 8fmt.Println(!c) //true مثال زیر نتیجه مقادیر متفاوت و عملگر های منطقی را نشان میدهد.\n1 // x y x \u0026amp;\u0026amp; y x || y !x !y 2 true true true true false false 3 true false false true false true 4 false true false true true false 5 false false false false true true 1.4.4 عملگرهای بیتی # زبان گو داری 5عملگر بیتی می باشد که به ترتیب :\nعملگر نام \u0026gt;\u0026gt; شیفت بیتی به چپ \u0026lt;\u0026lt; شیفت بیتی به راست \u0026amp; AND | OR ^ XOR ‍‍\nعملگر \u0026gt;\u0026gt; به انگلیسی Zero fill left shift یا به اختصار left shift به فارسی که اسم مناسبی براش نیافتیم به نقل از ویکی پدیا شیفت بیتی به چپ , مقدار باینری ما را با استفاده از انتقال یا اضافه کردن صفر ها به سمت چپ انتقال میدهد. عملگر \u0026lt;\u0026lt; به انگلیسی Zero fill right shift یا به اختصار right shift به فارسی که اسم مناسبی براش نیافتیم به نقل از ویکی پدیا شیفت بیتی به راست , مقدار باینری ما را با به سمت راست انتقال میدهد. در زیر دو مثال رو مشاهده میکنید که از این دو عملگر استفاده شده:\n1//example 1 2a := 0b01000101 3b := a \u0026lt;\u0026lt; 1 4c := a \u0026gt;\u0026gt; 1 5fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, a, a) //binary:01000101,value:69 6fmt.Println(\u0026#34;\u0026#34;) 7fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, b, b) //binary:10001010,value:138 8fmt.Println(\u0026#34;\u0026#34;) 9fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, c, c) //binary:00100010,value:34 10 11fmt.Println(\u0026#34;\\n\\n---------------\\n\u0026#34;) 12//example 2 13d := 0b01010101 14e := d \u0026lt;\u0026lt; 3 15f := d \u0026gt;\u0026gt; 3 16fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, d, d) //binary:01010101,value:85 17fmt.Println(\u0026#34;\u0026#34;) 18fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, e, e) //binary:1010101000,value:680 19fmt.Println(\u0026#34;\u0026#34;) 20fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, f, f) //binary:00001010,value:10 21fmt.Println(\u0026#34;\u0026#34;) 22 */ در مثال دو همانطور که مشاهده کردید زمانی که از عملگر \u0026gt;\u0026gt; استفاده کردید در صورتی که اولین خانه ی باینری از سمت چپ مقدار 1 داشته باشه مابقی مقدار به صورتی 0 به باینری مون اضافه میشه و در غیر این صورت 1 هامون به همون مقدار به سمت چپ خواهد رفت.\nدر واقع 08b% یک شناساگر قالب (format specifier) برای نمایش باینری در هشت خانه است در اینجا میتوانید بیشتر راجب شناساگر های قالب بخوانید. عملگر \u0026amp; به انگلیسی AND به فارسی و دو مقدار باینری رو با یک دیگر مقایسه و اگر هر بیت مقدار 1 در هر دو طرف داشته باشد آن را 1 نگه میدارد و در غیر اینصورت آن بیت را 0 میکند. عملگر | به انگلیسی OR به فارسی یا دو مقدار باینری رو با یک دیگر مقایسه و اگر هر بیت مقدار 1 در یک طرف یا هر دوطرف داشته باشد آن را 1 نگه میدارد و در غیر اینصورت آن بیت را 0 میکند. عملگر ^ به انگلیسی XOR به فارسی نامی ندارد دو مقدار باینری رو با یک دیگر مقایسه و اگر هر بیت مقدار 1 در هر دوطرف داشته باشد آن را 0 میکند.\n1//\u0026amp; operator example 2a := 0b01000101 3b := 0b01010100 4c := a \u0026amp; b 5fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, a, a) //binary:01000101,value:69 6fmt.Println(\u0026#34;\u0026#34;) 7fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, b, b) //binary:01010100,value:84 8fmt.Println(\u0026#34;\u0026#34;) 9fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, c, c) //binary:01000100,value:68 10 11fmt.Println(\u0026#34;\\n\\n---------------\\n\u0026#34;) 12 13//| operator example 14d := 0b01000101 15e := 0b01010100 16f := d | e 17fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, d, d) //binary:01000101,value:69 18fmt.Println(\u0026#34;\u0026#34;) 19fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, e, e) //binary:01010100,value:84 20fmt.Println(\u0026#34;\u0026#34;) 21fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, f, f) //binary:01010101,value:85 22 23fmt.Println(\u0026#34;\\n\\n---------------\\n\u0026#34;) 24 25//^ operator example 26g := 0b01000101 27h := 0b01010100 28i := a ^ b 29fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, g, g) //binary:01000101,value:69 30fmt.Println(\u0026#34;\u0026#34;) 31fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, h, h) //binary:01010100,value:84 32fmt.Println(\u0026#34;\u0026#34;) 33fmt.Printf(\u0026#34;binary:%08b,value:%v\u0026#34;, i, i) //binary:00010001,value:17 1.4.5 اولویت عملگرها # در زبان گو ما یکسری اولویت ها برای عملگرها داریم و همچنین در زبان گو مثل سایر زبان ها پرانتز () ترویج دهنده اولویت ها می باشد.\n1 * / % \u0026lt;\u0026lt; \u0026gt;\u0026gt; \u0026amp; \u0026amp;^ 2 + - | ^ 3 == != \u0026lt; \u0026lt;= \u0026gt; \u0026gt;= 4 \u0026amp;\u0026amp; 5 || توجه در زبان گو اولویت \u0026lt;\u0026lt; و \u0026gt;\u0026gt; بیشتر از + و - می باشد. "},{"id":12,"href":"/chapter-1/go-variables-and-consts/","title":"1.5 متغیرها و constant","section":"فصل اول: آشنایی با مفاهیم گو","content":" 1.5.1 متغیر (Variable) # در برنامه‌نویسی رایانه، یک متغیر یک مکان در حافظه (آدرس حافظه) است که دارای یک نام نمادین با عنوان می‌باشد و می‌تواند حاوی اطلاعات یا یک مقدار معلوم یا مجهول که به آن ارزش یا مقدار گفته می‌شود باشد. به زبان دیگر، متغیر در برنامه‌نویسی به فضایی که برای ذخیره داده‌ها کنار گذاشته شده‌است می‌گویند (به نقل از سایت ویکی پدیا)\nتعریف یک متغیر رشته # 1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7func main() { 8\tvar s string = \u0026#34;Hello World\u0026#34; 9\tfmt.Println(s) 10} 1$ go run main.go 2Hello World یک متغیر با استفاده از کلید واژه var ایجاد کردیم. نام متغیر را s گذاشتیم تایپ متغیر را از نوع string تعیین کردیم سپس با عملگر = مقدار متغیر را مشخص از نوع رشته تعیین کردیم. رشته \u0026quot;Hello World\u0026quot; به عنوان مقدار متغیر s می باشد و این مقدار در خانه مشخصی از حافظه قرار گرفته از پکیج استاندارد fmt برای چاپ مقدار متغیر s استفاده کردیم که این پکیج یکسری توابع جهت انجام عملیات های مختلفی نظیر چاپ مقادیر را دارند که در کد بالا ما از تابع Println استفاده کردیم. 1.5.1.1 اختصاص مقدار جدید به متغیر از قبل ایجاد شده # در کد زیر ما یک متغیر از قبل تعریف کردیم و مقدار جدید را در خط ۹ به متغیر اختصاص دادیم.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7func main() { 8\tvar s string 9\ts = \u0026#34;Hello World\u0026#34; 10\tfmt.Println(s) 11} زمانیکه شما یک متغیر بصورت var s string تعریف می کنید مقدار پیش فرض \u0026quot;\u0026quot; برای متغیر تعیین می شود. 1.5.1.2 اختصاص مقدار رشته به تایپ اشتباه # 1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7func main() { 8\tvar i int 9\ti = \u0026#34;One\u0026#34; 10\tfmt.Println(i) 11} 1$ go run main.go 2./main.go:cannot use \u0026#34;One\u0026#34; (type string) as type int in assignment در کد بالا ما یک متغیر از نوع int تعریف کردیم و در خط ۹ مقدار \u0026quot;One\u0026quot; را به آن تخصیص دادیم و پس از اجرا با خطای cannot use \u0026quot;One\u0026quot; (type string) as type int in assignment اینکه شما یک مقدار رشته را به تایپ اشتباه اختصاص دادید مواجه خواهید شد.\n1.5.1.3 تعریف متغیر به صورت خلاصه # زبان گو علاوه بر اینکه از کلید واژه var برای تعریف متغیر پشتیبانی می کند, از =: می توانید یک متغیر تعریف کنید و نیازی به مشخص کردن تایپ متغیر نمی باشد چون زبان گو بر اساس مقدار تعیین شده تایپ متغیر را تشخیص می دهد.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\ts := \u0026#34;Hello World\u0026#34; 7\tfmt.Println(s) 8} توجه کنید شما فقط داخل تابع می توانید به صورت مختصر متغیر تعریف کنید و جهت تعریف متغیر بصورت عمومی باید از var استفاده کنید.\nبهتر است برای تعریف متغیر داخل تابع از از روش مختصر استفاده کنید و متغیر با var بصورت عمومی در بدنه کد باشد.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7var s string = \u0026#34;Hello World\u0026#34; 8 9func main() { 10\tfmt.Println(s) 11} 1.5.1.4 تعریف چند متغیر در یک خط # در زبان گو شما می توانید همزمان چند متغیر را در یک خط تعریف کنید که در زیر یک نمونه کد مثال زدیم :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\ta, b, c := \u0026#34;hello\u0026#34;, 1, 1.5 7\tvar d, e, f = \u0026#34;world\u0026#34;, 13, 24 8\tfmt.Println(a, b, c, d, e, f) 9} 1$ go run main.go 2hello 1 1.5 world 13 24 1.5.1.5 تعریف متغیر با مقدار پیش فرض # در کد زیر ما یکسری متغیر با تایپ های مختلف تعریف کردیم که با مقدار پیش فرض ایجاد شده اند.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 var i int 7 var f float32 8 var b bool 9 var s string 10 fmt.Printf(\u0026#34;%v %v %v %q\\n\u0026#34;, i, f, b, s) //0 0 false \u0026#34;\u0026#34; 11} 1.5.2 مقدار ثابت (Constant) # constant همانند متغیر ها با کلید واژه const تعریف می شوند و مقدار بصورت const a string = \u0026quot;hello world\u0026quot; می گیرند و با این تفاوت که constant در طول اجرای کد مقدارشان غیرقابل تغییر هست و این تضمین را به شما می کنند هیچ چیزی در طول اجرا باعث تاثیر در تغییر مقدار constant نشود.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7const s string = \u0026#34;Hello World\u0026#34; 8 9func main() { 10\tfmt.Println(s) 11} 1$ go run main.go 2Hello World همانطور که در فوق گفتیم شما نمی توانید Constant را مجدد مقدار دهی کنید و در زیر خطایی که رخ می دهد در زمان اجرا را قرار دادیم :\n1package main 2 3func main() { 4 const a int = 8 5 a = 9 6} 1$ go run main.go 2main.go:5:cannot assign to a 1.5.2.1 تعریف Constant بدون نیاز به تعیین تایپ # در constant شما همانند متغییر می توانید یک const به تعیین تایپ تعریف کنید و زبان گو در زمان اجرا با توجه به مقدارتان تایپ را تشخیص می دهد.\n1const a = 1 //Default hidden type is int 2const b = \u0026#34;circle\u0026#34; //Default hidden type is string 3const c = 5.4 //Default hidden type is float64 4const d = true //Default hidden type is bool 5const e = \u0026#39;a\u0026#39; //Default hidden type is rune 6const f = 3+5i //Default hidden type is complex128 1.5.3 نحوه مشاهده تایپ متغیر یا Constant # در زیر ما با استفاده یکی از توابع پکیج fmt نوع و مقدار متغیر یا constant ها را چاپ کردیم.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5// Named untyped constant 6const a = 123 //Default hidden type is int 7const b = \u0026#34;circle\u0026#34; //Default hidden type is string 8const c = 5.6 //Default hidden type is float64 9const d = true //Default hidden type is bool 10const e = \u0026#39;a\u0026#39; //Default hidden type is rune 11const f = 3 + 5i //Default hidden type is complex8 12 13var u = 123 //Default hidden type is int 14var v = \u0026#34;circle\u0026#34; //Default hidden type is string 15var w = 5.6 //Default hidden type is float64 16var x = true //Default hidden type is bool 17var y = \u0026#39;a\u0026#39; //Default hidden type is rune 18var z = 3 + 5i //Default hidden type is complex128 19 20func main() { 21\tfmt.Println(\u0026#34;\u0026#34;) 22\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, a, a) 23\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, b, b) 24\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, c, c) 25\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, d, d) 26\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, e, e) 27\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, f, f) 28 29\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, u, u) 30\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, v, v) 31\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, w, w) 32\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, x, x) 33\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, y, y) 34\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, z, z) 35} 1.5.3.1 استفاده از iota در constant # شناسه iota فقط با constant قابل استفاده اس که با آن می توانید برای ایجاد اعداد auto increment استفاده کنید.\nایجاد auto increment بدون iota :\n1const ( 2 a = 0 3 b = 1 4 c = 2 5) ایجاد auto increment با iota :\n1const ( 2 a = iota // 0 3 b // 1 4 c // 2 5) توجه کنید مقدار پیش فرض با iota صفر می باشد و constant از نوع int می باشد. 1.5.3.2 نحوه ایجاد enum # از iota و constant برای ایجاد enum استفاده می شود که در زیر یک نمونه کد برای ایجاد enum قرار دادیم.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type Size uint8 6 7const ( 8\tsmall Size = iota 9\tmedium 10\tlarge 11\textraLarge 12) 13 14func main() { 15\tfmt.Println(small) 16\tfmt.Println(medium) 17\tfmt.Println(large) 18\tfmt.Println(extraLarge) 19} 1$ go run main.go 20 31 42 53 1.5.3.3 نادیده گرفتن مقدار اول iota # وقتی که داریم از iota استفاده می‌کنیم شاید هنگام استفاده از auto increament نیاز باشد مقدار اول را نادیده بگیریم. برای اینکار می‌توان از _ استفاده کرد به شکل زیر :\n1const ( 2 _ = iota // ignore 3 a // 1 4 b // 2 5 c // 3 6) 1.5.3.4 خودآزمون iota # خروجی کد زیر را در ذهن پیدا کنید و با اجرای کد صحت آن را بررسی کنید.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tconst ( 7\tA = iota 8\tB 9\tC 10\tD = B + C 11\tE 12\tF 13\tG = iota 14\tH 15\tI = H 16\tJ 17\tK 18\t) 19\tfmt.Println(A, B, C, D, E, F, G, H, I, J, K) 20} 1.5.4 قوانین نام گذاری متغیر و constant # در زیر ما یکسری قوانین جهت نام گذاری متغیر و constant تعریف کردیم :\nنام متغیر یا constant فقط با یک حرف انگلیسی یا _ شروع می شود. نام ها می تواند ترکیبی از اعداد و حروف انگلیسی یا _ باشد. زبان گو به حروف بزرگ و کوچک در نام ها حساس است و اگر شما hello یا Hello تعریف کنید ۲ تا متغیر یا constant متفاوت محسوب می شوند. محدودیتی در تعداد حروف نام ها وجود ندارد ولی بهتر است از یک تعداد مطلوب و مشخصی برای نام ها استفاده کنید. توجه داشته باشید اصولا اسم constant ها را با حروف بزرگ و خارج از function تعریف می‌کنند.\nبا مشخص کردن اسم با حروف بزرگ هنگام استفاده از constant ها مشخص تر خواهد بود. از آنجایی که constant ها فقط امکان read یا همان خواندن را می‌دهند ممکن است در قسمت های مختلف به آن مقادیر نیاز داشته باشیم. به دلیل اینکه با هر بار فراخوانی function مانع از این شویم کامپایلر عملیات مقدار دهی const را دوباره انجام ندهد بهتر است آن را خارج از تابع تعریف کنیم. "},{"id":13,"href":"/chapter-1/go-zero-values/","title":"1.6 مقادیر صفر تایپ ها (zero values)","section":"فصل اول: آشنایی با مفاهیم گو","content":"در زیر لیست تمامی تایپ ها با مقادیر صفرشان قرار دادیم :\nتایپ مقدار پیش فرض یا مقدار صفر int 0 int8 0 int16 0 int32 0 int64 0 uint 0 uint8 0 uint16 0 uint32 0 uint64 0 uintptr 0 float32 0 float64 0 complex64 0+0i complex128 0+0i bool false string \u0026quot;\u0026quot; interface nil slice nil channel nil map nil pointer nil function nil struct براساس مقدار پیش فرض فیلدها "},{"id":14,"href":"/chapter-1/go-function/","title":"1.7 تابع (function)","section":"فصل اول: آشنایی با مفاهیم گو","content":" 1.7.1 تابع چیست؟ # در برنامه‌نویسی، تابع به تکه کدهایی سازمان یافته گفته می شود که برای انجام عملی خاص استفاده می شوند. به کمک توابع می توانیم تکه کدهارو از یکدیگر جدا کنیم و از تکرار کدهای تکراری جلوگیری کنیم و به برنامه مون نظم بیشتری بدیم.\nهمانند شکل زیر تابع مانند یک جعبه (یا قطعه کد) می باشد. که یک مقدار ورودی گرفته و روی آن پردازش هایی انجام می دهد و یک خروجی تولید می کند. در برنامه نویسی تابع می تواند یک یا چند ورودی و خروجی داشته باشد. و ممکن است یک تابع هیچ ورودی نداشته باشد و خروجی داشته باشد یا بلعکس.\n1.7.1.1 چرا از توابع در برنامه نویسی استفاده می کنیم؟ # با استفاده از توابع، می توانیم یک قطعه کد را یک بار بنویسیم و چندین بار از آن در برنامه استفاده کنیم. با استفاده از توابع، حجم کدنویسی ما کم تر میشه و سرعت توسعه نرم افزار بیشتر می شود. توابع به ما کمک می کنند تا کد خود را به تکه هایی تقسیم کنیم تا برنامه ما خوانا و قابل درک باشد. همچنین نگهداری و اشکال زدایی کد را آسان تر می کند. 1.7.2 توابع در زبان گولنگ # توابع یکی از قابلیت های مهم هر زبانی محسوب می شود. توابع در زبان برنامه نویسی گولنگ داری سینتکس ساده ای هستند.\n1.7.2.1 تعریف یک تابع # 1func function_name( [parameter list] ) [return_types] { 2 3 // body of the function 4 5} func - با این کلید واژه یک تابع تعریف می کنیم Function Name - نام تابع باید یکتا و در طول برنامه منحصر به فرد باشد. همچنین معمولاً نمی‌توان تابعی با نام توابع از پیش تعریف شده داشت. Parameters - پارامترهای ورودی در این قسمت تعریف می‌شوند. پارامترها اختیاری هستند یعنی ممکن است یک تابع هیچ پارامتری نداشته باشد. Return Type - نوع داده های بازگشتی را در این قسمت مشخص می کنیم و در برخی توابع عملیات موردنظر را بدون بازگرداندن مقداری انجام می دهند در این توابع نیازی به تعیین return_type نمی باشد. Function Body - این قسمت شامل کدهایی است که نشان می دهد تابع چه کارهایی انجام می دهد 1.7.2.1.1 مثال # 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func plus(a int, b int) int { 6\treturn a + b 7} 8 9func main() { 10\tfmt.Println(plus(4, 13)) 11} 1$ go run func.go 217 در اینجا یک تابع یا نام plus تعریف کردیم که دو پارامتر a, b را با نوع داده int را دریافت می کند و جمع دو عدد را حساب می کند. توجه کنید که همیشه باید نوع داده را مشخص کنیم. بعد از تعریف پارامترهای ورودی و قبل از قرار دادن کد داخل براکت int را می بینید که نوع خروجی داده را مشخص می کند و باید از نوع int باشد. برای صدا زدن توابع از کلیدواژه name(args) استفاده می کنیم. در صورتی که نوع پارامترهای ورودی از یک نوع باشند بجای تعریف تک تک نوع داده ها می توانیم نوع داده را در آخر همه پارامترهای هم نوع مشخص کنیم.\n1func plus(a, b int) 2// or 3func name(a string, b,c int) 1.7.2.1.2 الگو دیگر تعریف تابع: # 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tplus := func (a int, b int) int { 7\treturn a + b 8\t} 9\tfmt.Println(plus(3, 4)) 10} 1$ go run main.go 27 1.7.3 قوانین نام گذاری تابع در گولنگ # نام تابع باید با یک حرف شروع شود. نام تابع فقط می تواند شامل حروف-عدد و underscores باشد. (A-z, 0-9, _ ) نام توابع به حروف کوچک و بزرگ حساس می باشد. در نام گذاری توابع از فاصله نمی توانیم استفاده کنیم. ‬1.7.4 چند بازگشتی مقادیر در گولنگ (Multiple results) # همچنین در گولنگ توابع می توانند چندین مقادیر را برگردانند.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func vals() (int, int) { 6 return 3, 7 7} 8 9func main() { 10 11 a, b := vals() 12 fmt.Println(a) 13 fmt.Println(b) 14 15 _, c := vals() 16 fmt.Println(c) 17} 1$ go run main.go 23 37 47 در کد بالا تابعی ساختیم با اسم vals که دو خروجی از نوع int دارد بنابراین نوع تعریف توابع چندبازگشتی متفاوت است و بصورت (data-type, data-type, \u0026hellip; ) می باشد. در مثال اول ما با کمک دو متغیر a,b دو خروجی تابع vals را دریافت کردیم. در مثال دوم ما با استفاده از _ blank identifier از دریافت یا استخراج خروجی اول صرف نظر کردیم و فقط خروجی دوم با متغیر c را دریافت کردیم. در توابع چند بازگشتی خروجی آنها را باید با , از هم جدا کرد 1.7.4.1 مقادیر بازگشتی نام گذاری شده (Named Return Values) # در گولنگ می توانیم مقدار بازگشتی یک تابع را نامگذاری کنیم. به مثال زیر توجه کنید.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func split(sum int) (x, y int) { 6\tx = sum * 4 / 9 7\ty = sum - x 8\treturn 9} 10 11func main() { 12\tfmt.Println(split(17)) 13} 1$ go run main.go 27 10 ما در این تابع مقدار بازگشتی را x, y از نوع int نام گذاری می کنیم. در اینجا یک دستور return بدون تعیین آرگومان بازگشتی، مقادیر نام گذاری شده را باز می گرداند. که به عنوان Naked return شناخته می شود. از naked return باید در توابع کوتاه مانند مثال بالا استفاده شود. استفاده آن در تابع طولانی منجر به کاهش خوانایی کد می شود. 1.7.5 توابع متنوع در گولنگ (Variadic Functions) # یکی از قابلیت های گو وجود توابع متنوع هاست که به شما اجازه می دهد هر چقدر پارامتر نیاز دارید بدون تعریف وارد تابع کنید. ‍‍\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func sum(nums ...int) { 6 fmt.Print(nums, \u0026#34; \u0026#34;) 7 total := 0 8 9 for _, num := range nums { 10 total += num 11 } 12 fmt.Println(total) 13} 14 15func main() { 16 17 sum(1, 2) 18 sum(1, 2, 3) 19 20 nums := []int{1, 2, 3, 4} 21 sum(nums...) 22} 1$ go run variadic-functions.go 2[1 2] 3 3[1 2 3] 6 4[1 2 3 4] 10 در اینجا تابعی تعریف کردیم که تعداد دلخواهی از آرگومان ها از نوع int را به کمک \u0026hellip; که قبل از نوع داده قرار گرفته به داخل تابع منتقل می کند. برای صدا زدن این توابع میتوان به روش sum(num1, num2, \u0026hellip;) عمل کرد. اگر شما داده ای با نوع slice دارید می توانید آن را به کمک اپراتور \u0026hellip; به صورت sum(nums\u0026hellip;) به داخل تابع انتقال بدید. 1.7.6 توابع نانشناس در گولنگ (Anonymous Functions) # در زبان گولنگ می توانیم تابع بدون نام تعریف کنیم. که به عنوان توابع ناشناس شناخته می شوند.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 7 // anonymous function 8 var sum = func(n1, n2 int) int { 9 sum := n1 + n2 10 11 return sum 12 } 13 14 // function call 15 result := sum(5, 3) 16 17 fmt.Println(\u0026#34;Sum is:\u0026#34;, result) 18 19} 1$ go run main.go 2Sum is: 8 از آنجایی که توابع ناشناس نامی ندارد ما در بعضی اوقات آن ها را به یک متغیر اختصاص می دهیم سپس از نام متغیر برای فراخوانی تابع استفاده می کنیم. در این مثال می بینید که ما از sum برای فراخوانی تابع استفاده می کنیم. مانند توابع معمولی ما میتونیم برای تابع ناشناس پارامتر تعریف کنیم و همچنین مقداری را از تابع برگردانیم در این مثال تابع دو مقدار با نوع داده int دریافت میکنید و یک خروجی با نوع int دارد. تابع ناشناس را می توان برای عملکردهایی که نیازی به نامگذاری ندارند و معمولا برای استفاده کوتاه مدت هست، استفاده کرد. اما یکی از موارد کاربردی توابع ناشناس در گولنگ پاس دادن آن ها به توابعی هستند که تابعی را تحت عنوان پارامتر ورودی دریافت میکنند. در مثال زیر ما یک تابع تعریف کردیم که در پارامتر سوم یک تابع دریافت میکند که باید دو ورودی int و یک خروجی int داشته باشد.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func add10AndSum(num1 int, num2 int, sum func(n1, n2 int) int) { 6 result := sum(num1+10, num2+10) 7 fmt.Println(\u0026#34;Sum by adding 10 is:\u0026#34;, result) 8} 9 10func main() { 11 add10AndSum(5, 3, func(n1, n2 int) int { 12 sum := n1 + n2 13 14 return sum 15 }) 16} 1$ go run main.go 2Sum by adding 10 is: 28 1.7.7 توابع از پیش تعریف شده (Built-in Function) # در گولنگ علاوه بر تابع هایی که توسط کابر تعریف میشه. یکسری توابع وجود دارد که از قبل تعریف شده اند که طراحان این زبان برای سهولت کار برنامه نویسان این توابع را نوشته اند و آن را همراه زبان گولنگ ارائه می دهند.\nhttps://book.gofarsi.ir/chapter-1/go-builtins/\n"},{"id":15,"href":"/chapter-1/go-array/","title":"1.8 آرایه و slice","section":"فصل اول: آشنایی با مفاهیم گو","content":"آرایه و slice دو نوع تایپ با یک وجه اشتراک در زبان گو می باشند ولی این دو نوع تایپ یکسری تفاوت هایی با هم دارند که در ادامه به این دو تایپ می پردازیم.\n1.8.1 تعریف آرایه # آرایه یکی از عمومی ترین تایپ ها در زبان های برنامه نویسی می باشد که برای نگه داری گروهی مقادیر از یک نوع تایپ استفاده می شود. برای دسترسی به هرکدام از مقادیر درون آرایه باید از اندیس استفاده کرد. معمولا برای آرایه شما تعداد مشخص و ثابتی را برای تعداد خانه های آرایه مشخص کنید که این آرایه قرار است چندتا مقدار نگه داری کند.\nدر زیر یک نمونه کد در خصوص آرایه قرار دادیم :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tarrayInts := [5]int{1, 25, 12354, 654, 32} 7\tfmt.Println(arrayInts) 8} 1$ go run array.go 2[1 25 12354 654 32] یک متغیر کوتاه از نوع آرایه با نام arrayInts تعریف کردیم. ظرفیت آرایه را با عدد ۵ تعیین کردیم (یعنی این آرایه فقط ۵ تا مقدار بیشتر نگه داری نمی کند) سپس تایپ آرایه را از نوع int مشخص کردیم. در نهایت در همانجا آرایه را مقدار دهی کردیم. 1.8.2 مفهوم اندازه و ظرفیت (size, capacity) # در آرایه ما ۲ تا مفهوم داریم اندازه و ظرفیت که از عنوان این مفهوم مشخص است آرایه دارای یک اندازه و ظرفیت مشخصی می باشد و اگر شما بیشتر از ظرفیت و اندازه تعیین شده مقدار دهی کنید با خطا مواجه خواهید شد.\nدر آرایه ظرفیت به نسبت اندازه تعیین می شود. 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tarrayString := [3]string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;} 7\tfmt.Println(arrayString) 8} 1$ go run array.go 2./prog.go:6:42: index 3 is out of bounds (\u0026gt;= 3) در کد فوق ما یک آرایه با اندازه ۳ تعریف کردیم و ۴ تا مقدار قرار دادیم و پس اجرا با خطای تعداد مقادیر بیشتر از اندازه و ظرفیت می باشد مواجه شدیم.\n1.8.2.1 تابع len و cap # برای آرایه و slice ما ۲ تا تابع داریم که می توانیم اندازه و ظرفیت یک آرایه یا slice را بگیریم.\nتابع len یکی از توابعی می باشد خیلی کاربردی و پراستفاده هنگام کار با آرایه یا slice می باشد که می توانید اندازه آرایه یا slice را بگیرید. تابع cap ظرفیت آرایه و slice را نمایش می دهد. 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tarrayString := [3]string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;} 7\tfmt.Printf(\u0026#34;array %v, len %d, cap %d\u0026#34;, arrayString, len(arrayString), cap(arrayString)) 8} 1$ go run main.go 2array [a b c], len 3, cap 3 1.8.3 تعریف آرایه و مقدارهی # در زیر ما یک آرایه با مقدار پیش فرض و اندازه مشخص تعریف کردیم و قصد داریم در ادامه کد مقداردهی کنیم.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tnums := [5]int{} 7\tfmt.Printf(\u0026#34;array nums values %v, len %d, cap %d\u0026#34;, nums, len(nums), cap(nums)) 8 9\tnums[0] = 1 10\tnums[1] = 2 11\tnums[2] = 10 12\tnums[4] = 999 13\t14\tfmt.Println(\u0026#34;\u0026#34;) 15\tfmt.Printf(\u0026#34;array nums values %v, len %d, cap %d\u0026#34;, nums, len(nums), cap(nums)) 16} 1$ go run main.go 2array nums values [0 0 0 0 0], len 5, cap 5 3array nums values [1 2 10 0 999], len 5, cap 5 در کد فوق در ابتدا ما یک آرایه بدون مقدار تعریف کردیم. سپس با استفاده از اندیس مقدار را خانه مشخص قرار دادیم. 1.8.3.1 تعریف آرایه با اندازه تعیین شده توسط کامپایلر # شما در زبان گو می توانید با استفاده از ... یک آرایه با اندازه مشخص شده توسط کامپایلر تعریف کنید.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tnums := [...]int{1, 25, 45, 8797, 78, 879, 541, 11} 7\tfmt.Printf(\u0026#34;array nums values %v, len %d, cap %d\u0026#34;, nums, len(nums), cap(nums)) 8} 1$ go run main.go 2array nums values [1 25 45 8797 78 879 541 11], len 8, cap 8 توجه کنید زمانیکه ... برای تعریف آرایه استفاده می کنید فقط در همان لحظه تعریف می توانید مقدار دهی کنید. 1.8.3.2 تعریف آرایه دوبعدی یا چندبعدی # در زبان گو همانند سایر زبان ها می توانید آرایه دوبعدی یا چند بعدی تعریف کنید که این برای پیاده سازی ماتریس یا یکسری سناریوهای توسعه کاربردی می باشد.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tnums := [2][2][2]int{{{1, 2}, {2, 3}}, {{4, 5}, {6, 7}}} 7\tfmt.Printf(\u0026#34;array nums values %v, len %d, cap %d\u0026#34;, nums, len(nums), cap(nums)) 8} 1$ go run main.go 2array nums values [[[1 2] [2 3]] [[4 5] [6 7]]], len 2, cap 2 1.8.3.3 مقایسه آرایه ها # در کد زیر ما یک نمونه مقایسه آرایه ها قرار دادیم که این مقایسه براساس تایپ, اندازه و مقادیر در نظر گرفته می شود.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tnums := [2]int{1, 2} 7\tnums2 := [2]int{1, 3} 8\tnums3 := [2]int{1, 2} 9\tnums4 := [3]int{1, 2, 3} 10\tchars := [2]string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;} 11 12\tfmt.Println(nums == nums2) // false 13\tfmt.Println(nums == nums3) // true 14\tfmt.Println(nums == nums4) // error: invalid operation: nums == nums4 (mismatched types [2]int and [3]int) 15\tfmt.Println(nums == chars) // error: invalid operation: nums == chars (mismatched types [2]int and [2]string) 16} 1.8.4 برش (slice) # همانطور که می دانید آرایه یک از مهم ترین عناوین در زبان های برنامه نویسی می باشد. اما در زبان گو slice به نسبت آرایه خیلی پراستفاده کاربردی است. اگر بخواهیم خیلی ساده slice را توصیف کنیم در واقع \u0026ldquo;یک slice به عنوان یک بخش بهم پیوسته از یک آرایه تعریف می شود که شما می توانید المنت هایش را در حال اجرا افزایش یا کاهش دهید بدون آنکه ظرفیت و اندازه آن را مشخص کنید.\u0026rdquo;\nاما این سوال پیش می آید علت اینکه slice به نسبت آرایه کاربردی هست چیست؟ آرایه دارای برخی از محدودیت ها علی الخصوص اندازه ثابت می باشد اما در slice شما این محدودیت ها را نخواهید داشت و خیلی ساده می توانید المنت ها را افزایش, حذف و حتی کپی کنید.\nدر زبان گو slice ها یک پارچگی آرایه را حفظ می کند و کار با آرایه خیلی ساده و آسان تر خواهد شد. 1.8.4.1 تعریف یک slice با اندازه مشخص # شما می توانید با استفاده از تابع make یک slice با اندازه مشخص تعریف کنید.\n1slice := make([]int, 5) 2 3fmt.Println(len(slice)) // Print 5 4 5fmt.Println(cap(slice)) // Print 5 1.8.4.2 تعریف یک slice با اندازه و ظرفیت مشخص # شما می توانید با استفاده از تابع make یک slice با ظرفیت و اندازه مشخصی تعریف کنید.\n1slice := make([]int, 3, 5) 2 3fmt.Println(len(slice)) // Print 3 4 5fmt.Println(cap(slice)) // Print 5 توجه کنید مقدار ظرفیت نباید کمتر از مقدار اندازه باشد.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\ttest := make([]int, 5, 4) 7\tfmt.Println(test) 8} 1$ go run main.go 2./main.go:6:22: invalid argument: length and capacity swapped 1.8.4.3 تعریف یک slice با متغیر کوتاه # شما خیلی ساده می توانید یک slice را توسط متغیر کوتاه ایجاد کنید.\n1slice := []string{\u0026#34;Red\u0026#34;, \u0026#34;Blue\u0026#34;, \u0026#34;Green\u0026#34;, \u0026#34;Yellow\u0026#34;, \u0026#34;Pink\u0026#34;} 2 3fmt.Println(len(slice)) //Print 5 4 5fmt.Println(cap(slice)) //Print 5 6 7intSlice:= []int{10, 20, 30} 8 9fmt.Println(len(intSlice)) //Print 3 10 11fmt.Println(cap(intSlice)) //Print 3 1.8.4.4 تعریف یک slice با موقعیت های شاخص # شما می توانید یک slice را با موقعیت های شاخص ایجاد کنید که n تا المنت با مقدار پیش فرض ایجاد می کند و در آخر x را به آخر slice اضافه می کند.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\ttest := []int{99: 88} 7\tfmt.Println(len(test), cap(test)) 8} 1.8.4.5 تعریف یک slice خالی # شما می توانید خیلی ساده یک slice خالی ایجاد کنید.\n1sliceOne := make([]int, 0) 2 3sliceTwo := []int{} 4 5fmt.Println(sliceOne == nil) // print false 6 7fmt.Println(len(sliceOne)) // print 0 8 9fmt.Println(cap(sliceOne)) // print 0 10 11fmt.Println(sliceTwo == nil) // print false 12 13fmt.Println(len(sliceTwo)) // print 0 14 15fmt.Println(cap(sliceTwo)) // print 0 1.8.5 مقدار دهی مجدد یکی از المنت های slice یا آرایه # شما خیلی راحت می توانید مقدار یکی از المنت های slice یا آرایه را مقدار دهی کنید.\n1slice := []int{10, 20, 30, 40} 2 3fmt.Println(slice) //print [10 20 30 40] 4 5slice[1] = 25 6 7fmt.Println(slice) // print [10 25 30 40] 1.8.6 ایجاد یک slice جدید براساس یک slice از پیش تعریف شده # شما می توانید یک slice جدید را براساس یک slice از پیش تعریف شده تعریف کنید.\n1x := []int{10, 20, 30, 40, 50} 2 3fmt.Println(x) // Print [10 20 30 40 50] 4 5fmt.Println(len(x)) // Print 5 6 7fmt.Println(cap(x)) // Print 5 8 9y := x[1:3] 10 11fmt.Println(y) //Print [20 30] 12 13fmt.Println(len(y)) //Print 2 14 15fmt.Println(cap(y)) //Print 4 ما یک x با ۵ تا المنت مقدار دهی شده تعریف کردیم. سپس یک متغیر کوتاه با نام y تعریف کردیم که متغیر x را با داخلش قرار دادیم. سپس برای x گفتم المنت های از اندیس ۱ تا ۳ را به y دسترسی دهد. توجه کنید اتفاقی در بالا رخ داد ما تعیین اندیس اندازه و ظرفیت جدید برای y تعیین کردیم.\nLen: 3 - 1 = 2 Cap: 5 - 1 = 4\n1.8.7 خطای index out of range در slice # یک slice فقط با توجه به اندازه و اندیس هاش امکان دسترسی و مقدار دهی مجدد المنت هایش می باشد اما اگر شما خارج از اندازه تعیین شده تلاش کنید جهت مقدار دهی با خطای index out of range مواجه خواهید شد.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tslice := []int{10, 20, 30, 40, 50} 7\tnewSlice := slice[1:3] 8\tnewSlice[3] = 45 9\tfmt.Println(newSlice) 10} 1$ go run main.go 2panic: runtime error: index out of range [3] with length 2 3 4goroutine 1 [running]: 5main.main() 6\t/tmp/sandbox548843089/prog.go:8 +0x5b 1.8.8 گسترش (append) المنت های یک slice # شما خیلی ساده می توانید با استفاده از append المنت های یک slice را گسترش دهید.\n1slice := []int{10, 20, 30, 40, 50} 2 3newSlice := slice[1:3] 4 5fmt.Println(len(newSlice)) // Print 2 6 7fmt.Println(cap(newSlice)) // Print 4 8 9newSlice = append(newSlice, 60) 10 11fmt.Println(len(newSlice)) // Print 3 12 13fmt.Println(cap(newSlice)) // Print 4 در کد زیر اتفاقی که صورت گرفته شما اگر ... را بعد از کلمه slice بزارید یعنی دارید میگید تمامی المنت های داخل slice به newSlice اضافه شود.\n1slice := []int{10, 20, 30, 40, 50} 2 3newSlice := append(newSlice, slice...) 1.8.9 نحوه حذف یک المنت در slice # برای حذف یک المنت در slice باید بصورت تکنیکی اینکار را انجام دهید چون زبان گو یک روش built-in برای اینکار ندارد.\nدر این روش شما باید در ابتدا آخرین المنت را به المنت مورد نظر با استفاده از اندیس کپی کنید. سپس آخرین المنت را از slice حذف کنید. 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tslice := []int{10, 20, 30, 40, 50} 7\tslice[1] = slice[len(slice)-1] 8\tslice = slice[:len(slice)-1] 9\tfmt.Println(slice) 10} 1.8.10 تابع copy در slice # شما با استفاده از تابع copy می توانید یک slice را به slice دیگری کپی کنید.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tsrc := []int{1, 2, 3, 4, 5} 7\tdst := make([]int, 5) 8\tnumberOfElementsCopied := copy(dst, src) 9\tfmt.Println(numberOfElementsCopied, dst) 10} 1$ go run main.go 25 [1 2 3 4 5] 1.8.11 نحوه مرتب کردن (sort) یک slice # برای مرتب کردن یک slice می توانید از توابع کتابخانه sort در زبان گو استفاده کنید.\nsort.Ints sort.Float64s sort.Strings 1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;sort\u0026#34; 6) 7 8func main() { 9\ts := []int{4, 2, 3, 1} 10\tsort.Ints(s) 11\tfmt.Println(s) 12} 1$ go run main.go 2[1 2 3 4] 1.8.12 فرق بین آرایه و slice # فرق نوع تعریف آرایه و slice برای تعریف آرایه شما باید داخل براکت [] یک مقداری را قرار دهید. برای تعریف slice هیچ مقداری داخل براکت [] هیچ مقداری نباید قرار دهید. 1array := [3]int{10, 20, 30} 2 3slice := []int{10, 20, 30} فرق بین خالی بودن آرایه و slice مقدار خالی بودن یک slice هست nil مقدار خالی یک آرایه, همان آرایه با المنت های مقدار پیش فرض می باشد. 1var slice []int32 2var array [2]int32 3 4fmt.Println(slice == nil) // print true 5fmt.Println(len(slice)) // print 0 6fmt.Println(cap(slice)) // print 0 7 8fmt.Println(array) // print [0 0] "},{"id":16,"href":"/chapter-1/go-for/","title":"1.9 حلقه ها (for)","section":"فصل اول: آشنایی با مفاهیم گو","content":" 1.9.1 حلقه # حلقه‌ها را در زبان گو به ساده‌ترین شکل ممکن و فقط با استفاده از کلید واژه for و در مدل‌های مختلف (سه‌بخشی, بی نهایت, foreach و \u0026hellip;) می‌توان پیاده‌سازی کرد.\n1.9.2 حلقه سه بخشی # این نمونه از حلقه‌ها که متداول‌ترین نوع حلقه است با استفاده از سه‌بخش:\nمقداردهی شرط شمارنده ایجاد می‌شوند.\n1for initialization ; condition ; counter { 2\t//loop codes 3} در کد زیر نمونه‌ای از این حلقه‌ها قابل مشاهده و اجرا است.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tsum := 0 7\tfor i := 1; i \u0026lt; 10; i++ { 8\tsum += i 9\t} 10 11\tfmt.Println(sum) 12} 1$ go run main.go 245 1.9.3 حلقه while # این مدل حلقه تماماً شبیه به رفتار while در زبان C را دارد با این تفاوت که پیاده‌سازی آن، تنها با کلیدواژه‌ی for و با حذف بخش مقداردهی و شمارنده حلقه سه‌بخشی انجام می‌گیرد. در واقع در این حلقه تنها با تعریف یک شرط کدهای داخل حلقه تا زمان برقراری آن شرط اجرا می‌شوند.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\ti := 0 7\tfor i \u0026lt; 10 { 8\tfmt.Println(i) 9\ti++ 10\t} 11} 1$ go run main.go 20 31 42 53 64 75 86 97 108 119 1.9.4 حلقه بی‌نهایت # اگر از حلقه‌ی while بخش شرط را حذف کنیم چه اتفاقی می‌افتد؟ در این حالت ما یک شرط بی نهایت ساخته‌ایم (شبیه به while(1)) که تا زمانی‌ که برنامه متوقف نشود و یا کدهای داخل حلقه، فرمان خروج از حلقه را ندهند، چرخه زندگی حلقه ادامه خواهد داشت.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tsum := 0 7\tfor { 8\tsum++ 9\t} 10 11\tfmt.Println(\u0026#34;this line will never execute\u0026#34;) 12} با اجرای کد بالا خطای تایم‌اوت دریافت خواهید کرد، به‌دلیل اینکه حلقه هیچگاه پایان نمی‌پذیرد.\n1.9.5 حلقه for-range # حلقه for-range یکی از پرکاربردترین حلقه ها در زبان گو می باشد که شما می توانید برای slice, آرایه و map یا رشته از این حلقه استفاده کنید.\n1for index, value := range slice/array {} 1for key, value := range map {} 1.9.5.1 حلقه for-range برای slice و آرایه # شما با استفاده از حلقه for-range می توانید به المنت های آرایه و slice و همچنین اندیس شان دسترسی پیدا کنید. و دقت کنید ۲ حالت وجود دارد :\n1.9.5.1.1 دسترسی با استفاده از یک کپی از المنت # در کد زیر ما با استفاده از for-range به یک کپی از المنت های slice letter دسترسی پیدا کردیم.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 letters := []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;} 7 8 //With index and value 9 fmt.Println(\u0026#34;Both Index and Value\u0026#34;) 10 for i, letter := range letters { 11 fmt.Printf(\u0026#34;Index: %d Value:%s\\n\u0026#34;, i, letter) 12 } 13 14\t//Only value 15 fmt.Println(\u0026#34;\\nOnly value\u0026#34;) 16 for _, letter := range letters { 17 fmt.Printf(\u0026#34;Value: %s\\n\u0026#34;, letter) 18 } 19} 1$ go run main.go 2Both Index and Value 3Index: 0 Value:a 4Index: 1 Value:b 5Index: 2 Value:c 6 7Only value 8Value: a 9Value: b 10Value: c 1.9.5.1.2 دسترسی مستقیم به خانه حافظه المنت # شما با استفاده از اندیس (index) می توانید مستقیما به خانه حافظه المنت دسترسی پیدا کنید و برروی آن المنت در همان خانه حافظه تغییرات ایجاد کنید.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 letters := []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;} 7 8 fmt.Println(\u0026#34;\\nOnly letter\u0026#34;) 9 for i := range letters { 10 fmt.Printf(\u0026#34;letter: %s\\n\u0026#34;, letters[i]) 11 } 12} 1$go run main.go 2Only letter 3letter: a 4letter: b 5letter: c 1.9.1.2 حلقه for-range برای map # شما با استفاده از حلقه for-range می توانید برروی map به کلید و مقدار هر یک از مقادیر map دسترسی پیدا کنید.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 sample := map[string]string{ 7 \u0026#34;a\u0026#34;: \u0026#34;x\u0026#34;, 8 \u0026#34;b\u0026#34;: \u0026#34;y\u0026#34;, 9 } 10 11 //Iterating over all keys and values 12 fmt.Println(\u0026#34;Both Key and Value\u0026#34;) 13 for k, v := range sample { 14 fmt.Printf(\u0026#34;key :%s value: %s\\n\u0026#34;, k, v) 15 } 16 17 //Iterating over only keys 18 fmt.Println(\u0026#34;\\nOnly keys\u0026#34;) 19 for k := range sample { 20 fmt.Printf(\u0026#34;key :%s\\n\u0026#34;, k) 21 } 22 23 //Iterating over only values 24 fmt.Println(\u0026#34;\\nOnly values\u0026#34;) 25 for _, v := range sample { 26 fmt.Printf(\u0026#34;value :%s\\n\u0026#34;, v) 27 } 28} 1$go run main.go 2Both Key and Value 3key :a value: x 4key :b value: y 5 6Only keys 7key :a 8key :b 9 10Only values 11value :x 12value :y 1.9.1.3 حلقه for-range برای رشته (string) # شما با استفاده از حلقه for-range می توانید به هرکدام از کارکترهای رشته دسترسی پیدا کنید.\n1for index, character := range string { 2 //Do something with index and character 3} به کد نمونه زیر توجه کنید :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 sample := \u0026#34;a£b\u0026#34; 7 8 //With index and value 9 fmt.Println(\u0026#34;Both Index and Value\u0026#34;) 10 for i, letter := range sample { 11 fmt.Printf(\u0026#34;Start Index: %d Value:%s\\n\u0026#34;, i, string(letter)) 12 } 13 14 //Only value 15 fmt.Println(\u0026#34;\\nOnly value\u0026#34;) 16 for _, letter := range sample { 17 fmt.Printf(\u0026#34;Value:%s\\n\u0026#34;, string(letter)) 18 } 19 20 //Only index 21 fmt.Println(\u0026#34;\\nOnly Index\u0026#34;) 22 for i := range sample { 23 fmt.Printf(\u0026#34;Start Index: %d\\n\u0026#34;, i) 24 } 25} 1$ go run main.go 2Both Index and Value 3Start Index: 0 Value:a 4Start Index: 1 Value:£ 5Start Index: 3 Value:b 6 7Only value 8Value:a 9Value:£ 10Value:b 11 12Only Index 13Start Index: 0 14Start Index: 1 15Start Index: 3 1.9.6 کلید واژه break # با استفاده از break می‌توان چرخه‌ی اجرای یک حلقه را پایان داد. به عنوان مثال در حلقه بی‌نهایت بالا می‌توان با تعریف یک شرط خاص از حلقه خارج شد. کد زیر نمونه استفاده از break را نمایش می‌دهد.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tsum := 0 7\tfor { 8\tsum++ 9\tif sum == 10 { 10\tbreak 11\t} 12\t} 13 14\tfmt.Println(sum) 15\tfmt.Println(\u0026#34;now this line will execute\u0026#34;) 16} 1$ go run main.go 210 3now this line will execute 1.9.7 کلیدواژه continue # این کلیدواژه چرخه‌ی اجرای حلقه را یک مرحله جلو می‌برد. به این‌معنی که اگر در حلقه از این کلیدواژه استفاده شود، کدهای بعد از continue اجرا نشده و چرخه بعدی (گام بعدی) اجرا خواهد شد.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 7\tfor i := 1; i \u0026lt; 10; i++ { 8\tif i%2 == 0 { 9\tcontinue 10\t} 11\tfmt.Println(i) 12\t} 13} 1$ go run main.go 21 33 45 57 69 قابل ذکر است که continue و break در حلقه‌های تودرتو، فقط روی اولین حلقه درونی تاثیر خواهند گذاشت. 1.9.8 خودآزمون حلقه # سوال با استفاده از زبان Go برنامه‌ای بنویسید که سری‌ زیر را ایجاد کند:\n11 222 3333 455555 588888888 613131313131313131313131313 7212121212121212121212121212121212121212121 الگوریتم پاسخ ‍1 + 0 = 1 1 + 1 = 2 2 + 1 = 3 3 + 2 = 5 5 + 3 = 8 8 + 5 = 13 13 + 8 = 21 a + b = c b = a a = c کد پاسخ 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 var ( 7 n = 6 // can define any result count ... 8 a, b, c = 1, 0, 0 9 ) 10 for i := 0; i \u0026lt;= n; i++ { 11 c = a + b 12 for j := 1; j \u0026lt;= c; j++ { 13 fmt.Print(c) 14 } 15 fmt.Println() 16 b, a = a, c 17 } 18} "},{"id":17,"href":"/chapter-1/go-map/","title":"1.10 نقشه map","section":"فصل اول: آشنایی با مفاهیم گو","content":" 1.10.1 مقدمه # نقشه ، یک نوع ساختار داده است. نقشه (ها) جهت جمع‌آوری و نگهداری مجموعه‌ای از داده‌ها استفاده می‌گردند. نقشه ، از نوع داده‌های انجمنی (هش) بصورت «کلید-مقدار» است. نقشه ، مجموعه‌ای از داده‌ها بصورت جفت‌‌های مرتب‌نشده است. 1.10.2 تعریف # یک مپ شبیه به فرمت زیر است:\nmap[KeyType]ValueType کلمه کلیدی map و بعد نوع کلید و در آخر هم نوع مقدار تعریف می‌شود.\nکلید: برای اشاره به یک مقدار ذخیره شده، به یک نام‌گذاری برای آن مقدار نیاز داریم و این یعنی «کلید» آن مقدار.\nمقدار کلید در یک مپ، باید یکتا باشد. محدودیت: برای تعریف کلید، از انواع تایپ‌هایی که قابل مقایسه هستند، می‌توان استفاده کرد: Boolean(s) Number(s) String(s) Array(s) Pointer(s) Struct(s) Interface(s) (تا زمانی که از مقادیر مقایسه‌پذیر استفاده می‌کند) از Slice(s) Map(s) Function(s) نمی‌توان برای تعریف «کلید» مپ استفاده کرد. در مپ می‌توان برای کلید از مقدار داخل یک متغیر بهره برد. 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tmyMap := make(map[int]string) 7\tmyKey := 13 8\tmyMap[myKey] = \u0026#34;thirteen\u0026#34; 9\tfmt.Println(myMap) //map[13:thirteen] 10\tfmt.Println(myMap[myKey]) //thirteen 11} مقدار: محتوی داده‌ای است که کلید به آن اشاره می‌کند و برخلاف کلید، هیچ محدودیت برای انتخاب «نوع» آن وجود ندارد، به‌عنوان نمونه می‌توان از یک مپ دیگر برای مقدار استفاده کرد. (مپ‌های تودرتو )\nmap[string]map[int]string 1.10.3 ایجاد و مقداردهی اولیه # مقدار پیش‌فرض برای یک مپ nil می‌باشد. برای مقداردهی مپ‌(ها) از روش‌های زیر استفاده می‌شود:\nاستفاده از کلمه کلیدی var 1var sampleMap = map[keyType]valueType{keyName1:value1, keyName2:value2, ...} 2var sampleMap map[keyType]valueType = map[keyType]valueType{} استفاده از علامت =: 1sampleMap := map[keyType]valueType{keyName1:value1, keyName2:value2, ...} استفاده از تابع make 1var sampleMap = make(map[keyType]valueType) 2sampleMap := make(map[keyType]valueType) 1.10.4 مپ با مقدار nil # درصورت تعریف اولیه مپ توسط دستور var sampleMap map[keyType]valueType یک ماهیت مپ با مقدار nil تولید می‌شود که نمی‌توان بدون مقداردهی اولیه، روی آن عملیات ارسال و دریافت داده‌ انجام داد:\n1 var sampleMap map[uint8]int 2 sampleMap[13] = 9999999 3 //panic: assignment to entry in nil map برای مقداردهی یک مپ nil:\n1var m map[string]string از روش‌های زیر می‌توان بهره گرفت:\n1var m map[string]string = map[string]string{} 2m := make(map[string]string) 3m := map[string]string{} 1.10.5 توابع مربوط به مپ # تابع (len): برای برگشت تعداد عناصر داخل مپ از len استفاده می‌شود: 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tvar sampleMap = map[string]bool{} 7\tvar otherMap = make(map[string]uint) 8\tvar nilMap map[bool]bool 9 10\tsampleMap[\u0026#34;condition#1\u0026#34;] = true 11\tsampleMap[\u0026#34;condition#2\u0026#34;] = false 12 13\totherMap[\u0026#34;foo\u0026#34;] = 1 14 15\tfmt.Println(len(sampleMap))\t//2 16\tfmt.Println(len(otherMap))\t//1 17\tfmt.Println(len(nilMap))\t//0 (len nil is zero) 18} مقدار برگشتی برای تابع len روی مپ‌ nil برابر صفر (۰) است.\n1.10.6 عملیات CRUD روی مپ # C : Create برای ایجاد مپ، در قسمت [[#ایجاد و مقداردهی اولیه:]] توضیح داده شده است.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 animals := make(map[int]string) // nil map of string-int pairs 7 animals[1] = \u0026#34;Gopher\u0026#34; 8 animals[2] = \u0026#34;owl\u0026#34; 9 animals[3] = \u0026#34;cheetah\u0026#34; 10 animals[4] = \u0026#34;eagle\u0026#34; 11 animals[5] = \u0026#34;lion\u0026#34; 12 13 fmt.Println(animals) //map[1:Gopher 2:owl 3:cheetah 4:eagle 5:lion] 14 15} R : Read جهت خواندن مقادیر مپ می‌توان از الگوی زیر استفاده کرد: mapName[\u0026quot;keyName\u0026quot;] مثال:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 animals := make(map[int]string) // nil map of string-int pairs 7 animals[1] = \u0026#34;Gopher\u0026#34; 8 animals[2] = \u0026#34;owl\u0026#34; 9 animals[3] = \u0026#34;cheetah\u0026#34; 10 animals[4] = \u0026#34;eagle\u0026#34; 11 animals[5] = \u0026#34;lion\u0026#34; 12 13 fmt.Println(animals[2]) //owl 14} U : Update برای بروزرسانی مقادیر مپ، از الگوی mapName[keyName] = newValue استفاده می‌شود. مثال:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 animals := make(map[int]string) // nil map of string-int pairs 7 animals[1] = \u0026#34;Gopher\u0026#34; 8 animals[2] = \u0026#34;owl\u0026#34; 9 animals[3] = \u0026#34;cheetah\u0026#34; 10 animals[4] = \u0026#34;eagle\u0026#34; 11 animals[5] = \u0026#34;lion\u0026#34; 12 13 fmt.Println(animals[2]) //owl 14 15 animals[2] = \u0026#34;wolf\u0026#34; 16 17 fmt.Println(animals[2]) //wolf 18} D : Delete جهت حذف مقادیر در مپ، از فانکشن delete متعلق به پکیج builtin استفاده می‌شود.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 animals := make(map[int]string) // nil map of string-int pairs 7 animals[1] = \u0026#34;Gopher\u0026#34; 8 animals[2] = \u0026#34;owl\u0026#34; 9 animals[3] = \u0026#34;cheetah\u0026#34; 10 animals[4] = \u0026#34;eagle\u0026#34; 11 animals[5] = \u0026#34;lion\u0026#34; 12 13 fmt.Println(animals) //map[1:Gopher 2:owl 3:cheetah 4:eagle 5:lion] 14 fmt.Println(len(animals)) //5 15 delete(animals, 4) 16 17 fmt.Println(animals) //map[1:Gopher 2:owl 3:cheetah 5:lion] 18 fmt.Println(len(animals)) //4 19} نکته: اگر کلید مورد استفاده در فانکشن delete() پیدا نشود، هیچ اتفاقی نخواهد افتاد. علت عدم بازگشت ارور در فانکشن delete() است\n1// The delete built-in function deletes the element with the specified key 2// (m[key]) from the map. If m is nil or there is no such element, delete 3// is a no-op. 4func delete(m map[Type]Type1, key Type) 1.10.7 بررسی وجود کلید # یکی از خدماتی که مپ ارائه می‌دهد،‌ پاسخ به سوال وجود یک کلید خاص در مپ می‌باشد که به‌عنوان راهکاری برای حل مسائل از آن استفاده می‌شود. مثال زیر را ببینید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 7\tvar personData = map[string]string{\u0026#34;name\u0026#34;: \u0026#34;frank\u0026#34;, \u0026#34;family\u0026#34;: \u0026#34;colleti\u0026#34;, \u0026#34;dob\u0026#34;: \u0026#34;1970-05-12\u0026#34;} 8 9\tname, nameExist := personData[\u0026#34;name\u0026#34;] 10\tfamily, familyExist := personData[\u0026#34;family\u0026#34;] 11\tdob, dobExist := personData[\u0026#34;dob\u0026#34;] 12\torganization, organizationExist := personData[\u0026#34;organization\u0026#34;] 13 14\tfmt.Println(name, nameExist)\t15\t//frank true 16\tfmt.Println(family, familyExist) 17\t//colleti true 18\tfmt.Println(dob, dobExist) 19\t//1970-05-12 true 20\tfmt.Println(organization, organizationExist) 21\t// false 22} 1.10.8 مپ، یک جدول، یک منبع # وقتی یک مپ تعریف می‌شود، اگر مپ(های) دیگری از روی آن ساخته شو(نـ)د، دارای یک منبع برای ذخیره و دریافت اطلاعات خواهند بود. در مثال زیر، مپ editorMap از مپ companyProfile ایجاد و وقتی ویرایش می‌شود، مپ اصلی نیز،‌ ویرایش شده است.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 7\tvar companyProfile = map[string]string{ 8\t\u0026#34;name\u0026#34;: \u0026#34;companyName\u0026#34;, 9\t\u0026#34;address\u0026#34;: \u0026#34;sampleAddress\u0026#34;, 10\t} 11\tvar editorMap = companyProfile // == editorMap := companyProfile 12 13\tfmt.Println(companyProfile[\u0026#34;name\u0026#34;], \u0026#34;\\t\u0026#34;, companyProfile[\u0026#34;address\u0026#34;]) 14\t//companyName sampleAddress 15\tfmt.Println(editorMap[\u0026#34;name\u0026#34;], \u0026#34;\\t\u0026#34;, editorMap[\u0026#34;address\u0026#34;]) 16\t//companyName sampleAddress 17 18\teditorMap[\u0026#34;name\u0026#34;] = \u0026#34;new name\u0026#34; 19\teditorMap[\u0026#34;address\u0026#34;] = \u0026#34;new address\u0026#34; 20 21\t//reference map also edited when editor map edit 22\tfmt.Println(companyProfile[\u0026#34;name\u0026#34;], \u0026#34;\\t\u0026#34;, companyProfile[\u0026#34;address\u0026#34;]) 23\t//new name new address 24\tfmt.Println(editorMap[\u0026#34;name\u0026#34;], \u0026#34;\\t\u0026#34;, editorMap[\u0026#34;address\u0026#34;]) 25\t//new name new address 26} 1.10.9 پیمایش روی مپ # یکی از اصلی‌ترین اهداف ایجاد و نگهداری انواع تایپ‌های مربوط به مجموعه داده‌ها، امکان دسترسی به اجزای داده و انواع لوپ از ابزارهای آن است. با استفاده از for-range می‌توان به اجزای یک داده‌ از نوع کلید-مقدار دسترسی داشت\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7func main() { 8\tanimals := make(map[int][]string) // nil map of string-int pairs 9\tanimals[0] = []string{\u0026#34;Gopher\u0026#34;, \u0026#34;running\u0026#34;, \u0026#34;rodent\u0026#34;} 10\tanimals[1] = []string{\u0026#34;owl\u0026#34;, \u0026#34;flying\u0026#34;, \u0026#34;carnivorous\u0026#34;} 11\tanimals[2] = []string{\u0026#34;cheetah\u0026#34;, \u0026#34;running\u0026#34;, \u0026#34;carnivorous\u0026#34;} 12\tanimals[3] = []string{\u0026#34;eagle\u0026#34;, \u0026#34;flying\u0026#34;, \u0026#34;carnivorous\u0026#34;} 13\tanimals[4] = []string{\u0026#34;lion\u0026#34;, \u0026#34;running\u0026#34;, \u0026#34;carnivorous\u0026#34;} 14 15\tfor index, animal := range animals { 16\tfmt.Printf(\u0026#34;%v- %s is %s animal and can %s \\n\u0026#34;, index, animal[0], animal[2], animal[1]) 17\t} 18} خروجی\n1user@system:~/go/src/temp❇ GO[1.19.3] 22:29:00 2→ go run main.go 30- Gopher is rodent animal and can running 41- owl is carnivorous animal and can flying 52- cheetah is carnivorous animal and can running 63- eagle is carnivorous animal and can flying 74- lion is carnivorous animal and can running 8user@system:~/go/src/temp❇ GO[1.19.3] 22:29:00 9→ go run main.go 104- lion is carnivorous animal and can running 110- Gopher is rodent animal and can running 121- owl is carnivorous animal and can flying 132- cheetah is carnivorous animal and can running 143- eagle is carnivorous animal and can flying 15user@system:~/go/src/temp❇ GO[1.19.3] 22:29:02 16→ go run main.go 172- cheetah is carnivorous animal and can running 183- eagle is carnivorous animal and can flying 194- lion is carnivorous animal and can running 200- Gopher is rodent animal and can running 211- owl is carnivorous animal and can flying به نحوه چیدمان خروجی‌ها دقت کنید، درباره علت یکسان نبودن خروجی‌ها در اجراهای متعدد تحقیق کنید.\n1.10.10 تبدیل اطلاعات رشته − مپ − اسلایس # نمونه کد زیر یک رشته را به مپ و یک مپ را به اسلایس تبدیل می‌کند.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7func seriesStringToMap(inputs ...string) map[int]string { 8\tresult := make(map[int]string) 9\tfor index, input := range inputs { 10\tresult[index] = input 11\t} 12\treturn result 13} 14 15func mapToSlice(inputs map[int]string) []string { 16\tresult := make([]string, len(inputs)) 17\tfor index, input := range inputs { 18\tresult[index] = input 19\t} 20\treturn result 21} 22 23func main() { 24\tmyAnimal := \u0026#34;Eagle Cheetah Owl Lion Gopher\u0026#34; 25 26\tmyMappedAnimal := seriesStringToMap(myAnimal) 27\tfmt.Println(myMappedAnimal) 28\t//map[0:Eagle Cheetah Owl Lion Gopher] 29 30\tmySlicedAnimal := mapToSlice(myMappedAnimal) 31\tfmt.Println(mySlicedAnimal) 32\t//[Eagle Cheetah Owl Lion Gopher] 33} 1.10.11 خودآزمون # کد زیر را بررسی کنید و خروجی(های) آن را با ذهن خود پردازش کنید. سپس صحت آن(ها) را بررسی و درباره آن تحقیق کنید:\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 var myMap map[string]int 7 fmt.Println(myMap) 8 9 var otherMap = map[string]int{} 10 fmt.Println(otherMap) 11 12 myMap[\u0026#34;foo\u0026#34;] = 13 13 fmt.Println(myMap) 14 15 otherMap[\u0026#34;bar\u0026#34;] = 99 16 fmt.Println(otherMap) 17} "},{"id":18,"href":"/chapter-1/go-if-switch/","title":"1.11 شرط (if, switch)","section":"فصل اول: آشنایی با مفاهیم گو","content":" 1.11.1 شرط (if-else) # زبان گو همانند ساز سایر زبان ها دارای شرط می باشد که خیلی ساده می توانید از آن استفاده کنید و در زیر ما فرمت استاندارد شرط در زبان گو را قرار دادیم :\n1if condition { 2 //Do something 3} else if condition { 4 //Do something 5} else { 6 //Do something 7} در بالا condition عبارتی است که قرار است وضعیت شرط را مشخص کند و در صورت true شدن شرط بر قرار می شود و در صورت برقرار نشدن شرط اول وارد else if می شود و مجدد یک condition دیگری را چک می کنیم که وضعیتش true می شود یا خیر و در نهایت منتهی می شود به else.\nدر شرط ما یک یا چندتا condition می توانیم داشته باشیم که این condition ها برای تعیین وضعیت از یکسری عملگرها نظیر \u0026amp;\u0026amp; , || , \u0026gt; , \u0026lt; , \u0026lt;= , =\u0026gt; , ! و \u0026hellip; استفاده می کند.\nزبان گو از فرمت های زیر برای ایجاد شرط استفاده می کند :\nفقط if if-else تو در تو (nested) شرط کوتاه با if 1.11.2 کلمه if به تنهایی # شما می توانید به تنهایی از if استفاده و یک condition را بررسی کنید :\n1if condition { 2 //Do something 3} برای نمونه کد زیر را ببینید :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 a := 6 7 if a \u0026gt; 5 { 8 fmt.Println(\u0026#34;a is greater than 5\u0026#34;) 9 } 10} 1$ go run main.go 2a is greater than 5 در بالا ما مقدار a را با عدد ۵ بررسی کردیم که آیا a از ۵ بزرگتر است یا خیر؟ و جواب بله a بزرگتر است و شرط برقرار شد.\nدر زیر مثال دیگر زدیم که چندتا condition را داخل یک شرط بررسی می کنیم برقرار می شود یا خیر :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 a := 4 7 if a \u0026gt; 3 \u0026amp;\u0026amp; a \u0026lt; 6 { 8 fmt.Println(\u0026#34;a is within range\u0026#34;) 9 } 10} 1$ go run main.go 2a is within range 1.11.3 کلمه else # شرط با else فرمتش مانند زیر است :\n1if condition { 2 //Do something 3} else { 4 //Do something 5} در بالا اگر condition برقرار نشود عملیات داخل else صورت میگیرد. که در ادامه یک مثال ساده زدیم :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 a := 1 7 b := 2 8 9 if a \u0026gt; b { 10 fmt.Println(\u0026#34;a is greater than b\u0026#34;) 11 } else { 12 fmt.Println(\u0026#34;b is greater than a\u0026#34;) 13 } 14} 1$ go run main.go 2b is greater than a 1.11.4 ادامه شرط با else if # شما با استفاده کلمه else if می توانید condition دیگر را بررسی کرده و در صورت برقرار شدن شرط عملیات را انجام دهید.\n1if condition1 { 2 //Do something 3} else if condition2 { 4 //Do something 5} else { 6 //Do something 7} در زیر ما یک نمونه مثال برای else if زدیم :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 age := 29 7 if age \u0026lt; 18 { 8 fmt.Println(\u0026#34;Kid\u0026#34;) 9 } else if age \u0026gt;= 18 \u0026amp;\u0026amp; age \u0026lt; 40 { 10 fmt.Println(\u0026#34;Young\u0026#34;) 11 } else { 12 fmt.Println(\u0026#34;Old\u0026#34;) 13 } 14} 1$ go run main.go 2Young 1.11.5 شرط تو در تو (nested) # شما می توانید شرط تو در تو (nested) داشته باشید (برای توسعه پروژه بهتره است کمتر استفاده از کنید از شرط تو در تو)\n1if condition { 2 //Do something 3 if condition2 { 4 //Do something 5 } 6 //Do something 7} در زیر یک نمونه شرط تو در تو به همراه else قرار دادیم :\n1if condition1 { 2 //... 3} else { 4 //... 5 if condition2 { 6 //... 7 } else { 8 //.... 9 } 10 //.... 11} در زیر مثال برای شرط تو در تو زدیم :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 a := 1 7 b := 2 8 c := 3 9 if a \u0026gt; b { 10 if a \u0026gt; c { 11 fmt.Println(\u0026#34;Biggest is a\u0026#34;) 12 } else if b \u0026gt; c { 13 fmt.Println(\u0026#34;Biggest is b\u0026#34;) 14 } 15 } else if b \u0026gt; c { 16 fmt.Println(\u0026#34;Biggest is b\u0026#34;) 17 } else { 18 fmt.Println(\u0026#34;Biggest is c\u0026#34;) 19 } 20} 1$ go run main.go 2Biggest is c 1.11.6 تعریف شرط و قرار دادن condition در متغیر کوتاه # در زبان گو شرط ها امکان تعریف متغیر کوتاه برای condition را دارد که می توانید در همان خط شرط برقراری شرط را بررسی کنید.\n1if statement; condition { 2 //Do something 3} در زیر یک مثال ساده زدیم که توضیح می دهیم :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 if a := 6; a \u0026gt; 5 { 7 fmt.Println(\u0026#34;a is greater than 5\u0026#34;) 8 } 9} 1$ go run main.go 2a is greater than 5 در بالا ما یک متغیر کوتاه با نام a داخل شرط تعریف کردیم و مقدار 6 را بهش دادیم و سپس با قرار دادن ; برقراری وضعیت شرط را بررسی کردیم.\n1.11.7 Switch # زبان گو ‌مانند برخی از زبان ها از switch پشتیبانی می کند و switch یک روش خیلی خوب برای جلوگیری از else if های بیشتر در شرط می باشد.\n1switch statement; expression { 2case expression1: 3 //Dosomething 4case expression2: 5 //Dosomething 6default: 7 //Dosomething 8} زمانیکه switch را تعریف می کنید شما باید statement و expression را برای بررسی قرار دهید و سپس داخل هر یک از case ها وضعیت برقرار بررسی می کنید و در نهایت اگر هیچکدام از case ها برابر با expresstion نباشد از default استفاده میکنیم تا مقدار پیش فرض را برگردانیم.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 switch ch := \u0026#34;b\u0026#34;; ch { 7 case \u0026#34;a\u0026#34;: 8 fmt.Println(\u0026#34;a\u0026#34;) 9 case \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;: 10 fmt.Println(\u0026#34;b or c\u0026#34;) 11 default: 12 fmt.Println(\u0026#34;No matching character\u0026#34;) 13 } 14} 1$ go run main.go 2b or c در مثال فوق ما حرف b انگلیسی را به متغیر کوتاه ch دادیم و سپس ch جهت بررسی هریک case ها پس ; نقطه ویرگول قرار دادیم. و در نهایت در هر یک از case بررسی کردیم کدام مقدار برابر ch است.\n1.11.8 Switch خودآزمون # تفاوت ساختار و خروجی چهار فرمت مشابه زیر را بررسی کنید:\nحالت اول 1switch f(); { 2case true: 3 println(1) 4case false: 5 println(0) 6} حالت دوم 1switch f() 2{ 3case true: 4 println(1) 5case false: 6 println(0) 7} حالت سوم 1switch f() { 2case true: 3 println(1) 4case false: 5 println(0) 6} حالت چهارم 1switch f(); true { 2case true: 3 println(1) 4case false: 5 println(0) 6} کدها در زمان اجرا یا پیش از آن، در برخی IDE یا Code Editor(ها) فرمت می‌شوند. هدف این خودآزمون دقت به ساختار ابزار switch است. "},{"id":19,"href":"/chapter-1/go-package/","title":"1.12 اضافه کردن پکیج در کد (package)","section":"فصل اول: آشنایی با مفاهیم گو","content":"زبان برنامه نویسی گو به شکلی طراحی شده است تا بتوانیم شیو‌ه های خوب مهندسی نرم افزار را به خوبی و ساده پیاده سازی کنیم. یکی از الگوهای مهم برای ارتقای کیفیت یک نرم افزار استفاده از DRY principle است. کلمه DRY مخفف Don’t Repeat Yourself است. که به صورت خیلی ساده یعنی کدی که خواهید نوشت را دوبار تکرار نکنید. تا جایی که امکان دارد باید از کدهای قبلی که نوشته اید بتوانید استفاده کنید. پکیج‌ها امکاناتی از جمله:\nقابلیت استفاده مجدد از کد را به ما میدهند. امکان ماژولار، و قابل نگهداری را فراهم می‌کنند. امکان مدیریت بهتر فایل‌ها را در یک واحد ایجاد می‌کنند. 1.12.1 پکیج‌ها در زبان گو # پکیج در اصل یک یا مجموعه از سورس فایل های شما است که داخل یک فولدر قرار ممکن است قرار بگیرد. هر سورس فایلی که دارید در زبان گو متعلق به یک پکیج است. برای تعریف یک پکیج از دستور زیر استفاده میکنیم:\n1package \u0026lt;packagename\u0026gt; برای تعریف پکیج باید در اولین خط فایل آن را با کلید واژه package تعریف کنید. داخل این پکیج شما می‌توانید کد‌هایی که لازم دارید را بنویسید و تصمیم بگیرید کدام متغییر، فانکشن یا تایپ باید به صورت عمومی باشد یا باید به صورت خصوصی فقط داخل پکیج مورد استفاده قرار بگیرد.\nقطعا میدانیم بعد از نوشتن پکیج اگر بخواهیم از آن پکیج داخل پکیج‌های دیگر استفاده کنیم باید از کلید واژه import استفاده کنیم.\n1.12.2 اضافه کردن پکیج # برای اضافه کردن پکیج‌های مختلف ما از کلید واژه import استفاده می‌کنیم.\n1import \u0026#34;fmt\u0026#34; برای مثال در کد بالا ما از پکیج استاندارد هسته گو استفاده کریدم. این به این معنی است همراه با تعریف کلمه fmt میتوانیم از توابعی که داخل این پکیج استفاده شده است استفاده کنیم. در مثال زیر ما از تابع Println برای چاپ مقدارHello GoFarsi!‍ استفاده کردیم.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tfmt.Println(\u0026#34;Hello GoFarsi!\u0026#34;) 7} تعریف کردن توابع به این شکل مزایای زیادی دارد از جمله:\nاگر اسم های مشابهی داشته باشید، داخل پکیج‌های مختلف می‌توانید از آن‌ها استفاده کنید و خوانایی برنامه افزایش پیدا میکند و باعث می‌شود از نام‌های طولانی استفاده نکنیم. مجموعه کدی که مربوط به هم هستن را در یک پکیج می‌توانیم قرار دهیم. و پیدا کردن و استفاده مجدد را برای ما راحتر می‌کند. فرایند تغییر و کامپایل را می‌تواند به حداقل برساند. 1.12.2.1 اضافه کردن چندین پکیج # ما می‌توانیم برای اضافه کردن هر پکیج از کلید واژه import به شکل زیر استفاده کنیم :\n1import \u0026#34;fmt\u0026#34; 2import \u0026#34;time\u0026#34; 3import \u0026#34;math\u0026#34; 4import \u0026#34;math/rand\u0026#34; اما با تشکر از گو ما میتوانیم کلیدواژهایی که قرار است بیشتر از یک بار اجرا شوند را به شکل زیر نیز تعریف کنید:\n1import ( 2\t\u0026#34;fmt\u0026#34; 3\t\u0026#34;time\u0026#34; 4\t\u0026#34;math\u0026#34; 5 \u0026#34;math/rand\u0026#34; 6) یعنی یک بار از کلیدواژ import استفاده کنیم و بعد اسم پکیج ها را به ترتیب داخل آن بنویسیم.\n1.12.3 اسم های عمومی و خصوصی (Export و Unexport) # همه توابع، متغیر‌ها و تایپ ‌هایی که تعریف میکنید اگر اول حرف اسم‌ها را بزرگ بزارید به این منظور است که آن را به صورت عمومی تعریف کرده اید و خارج از پکیج آن تابع، متغیر یا تایپ قابل دسترسی است. و اگر شما حرف اول اسم توابع، متغیرها و تایپ‌هایی که تعریف کردید را کوچک بگذارید به این معنی است که فقط داخل این پکیج آن تابع، متغیر یا تایپ قابل تعریف و استفاده است و خارج از پکیج قابل استفاده نیست.\nبرای مثال کد زیر را مشاهده کنید:\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;math\u0026#34; 6) 7 8func main() { 9\tfmt.Println(math.MaxInt64) // result: 9223372036854775807 10} در کد بالا ما از دو پکیج fmt و math استفاده کردیم. تابع Println از پکیج fmt به دلیل اینکه اولین حرف آن بزرگ است ما می‌توانیم داخل پکیج main خود از آن تابع استفاده کنیم. و برای پکیج math دقیقا بخاطر آنکه اول حرف MaxInt64 بزرگ است می‌توانیم از آن استفاده کنیم.\nحالا فرض کنیم که داخل پکیج math ما می‌خواهیم عدد pi را برگردانیم و ممکن است این متغییر فقط داخل این پکیج تعریف شده باشد پس اگر کاراکتر اول را به صورت کوچک بذاریم با خطا مواجه خواهیم شد:\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;math\u0026#34; 6) 7 8func main() { 9\tfmt.Println(math.MaxInt64) 10\tfmt.Println(math.pi) 11} 12 13// result: 14./prog.go:10:19: undefined: math.pi 15Go build failed. برای حل خطای بالا کافی است pi را به Pi تغییر دهید.\n1.12.4 اضافه کردن پکیج‌های 3rd party # فرض کنید می‌خواهیم از پکیج Gin (github.com) می‌خواهیم استفاده کنیم برای اضافه کردن این پکیج ما ‌می‌توانیم به دو شکل زیر آن را اضافه کنیم.\nداخل پروژه خود از دستور زیر استفاده کنید:\n1$ go get -u github.com/gin-gonic/gin بعدا می‌توانید وارد پروژه خود شوید و با کلید واژه import از آن استفاده کنید به شکل زیر :\n1package main 2 3import ( 4 \u0026#34;net/http\u0026#34; 5 6 \u0026#34;github.com/gin-gonic/gin\u0026#34; 7) 8 9func main() { 10 r := gin.Default() 11 r.GET(\u0026#34;/ping\u0026#34;, func(c *gin.Context) { 12 c.JSON(http.StatusOK, gin.H{ 13 \u0026#34;message\u0026#34;: \u0026#34;pong\u0026#34;, 14 }) 15 }) 16 r.Run() // listen and serve on 0.0.0.0:8080 (for windows \u0026#34;localhost:8080\u0026#34;) 17} حالت دیگر استفاده از go mod tidy است به این شکل که ما از دستور go get استفاده نمیکنیم. و همان مستقیم داخل پروژه آدرس gin را داخل import وارد میکنیم.\nو همان ابتدا داخل کد یک فانکشن را با همان پکیج فراخوانی میکنیم (اینکار لازم است چون همانطور که می دانید خود go tool وقتی بداند شما پکجی را تعریف کردید و استفاده نکردید آن را اتوماتیک پاک میکند.)\nسپس از دستور زیر استفاده میکنیم:\n1$ go mod tidy این دستور کل کدهای شما را بررسی می‌کند و اگر ببینید پکیجی تعریف شده است و شما آن را ندارید سعی میکند آن پکیج را برای شما دانلود و به پروژه شما اضافه کند.\n"},{"id":20,"href":"/chapter-1/go-defer-panic-recovery/","title":"1.13 defer, panic, recovery","section":"فصل اول: آشنایی با مفاهیم گو","content":" 1.13.1 تعویق (defer) # کلمه کلیدی defer یکی از کاربردی ترین امکانات زبان گو می باشد که شما می توانید اجرای یک تابع را به تعویق بندازید و در آخر تابع فعلی اجرا کنید. عموما defer برای توابعی کاربرد دارد که قصد دارد پاکسازی یا بستن عملیات های صورت گرفته را انجام دهد نظیر توابع Close در برخی از جاها.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7func main() { 8\tdefer fmt.Println(\u0026#34;world\u0026#34;) 9\tfmt.Println(\u0026#34;hello\u0026#34;) 10} 1$ go run main.go 2hello 3world 1.13.1.1 تعویق (defer) تابع درون خطی (inline) # شما خیلی ساده می توانید توابع درون خطی را تعویق بندازید.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 defer func() { fmt.Println(\u0026#34;In inline defer\u0026#34;) }() 7 fmt.Println(\u0026#34;Executed\u0026#34;) 8} 1$ go run main.go 2Executed 3In inline defer 1.13.1.2 تعویق (defer) چند تابع در یک تابع # در کد زیر ما داخل یک تابع چند تابع را تعویق (defer) کردیم.\n1package main 2import \u0026#34;fmt\u0026#34; 3func main() { 4 i := 0 5 i = 1 6 defer fmt.Println(i) 7 i = 2 8 defer fmt.Println(i) 9 i = 3 10 defer fmt.Println(i) 11} 1$ go run main.go 23 32 41 1.13.2 پانیک (panic) # در زبان گو panic همانند exception به معنای خروج از برنامه در شرایط غیر عادی می باشد. panic در ۲ حالت زیر پیش می آید:\nخطاهای در زمان اجرا برنامه فراخوانی تابع panic توسط برنامه نویس در بخش های مختلف برنامه 1func panic(v interface{}) از تابع فوق شما می توانید برای ایجاد panic استفاده کنید و به عنوان ورودی دلیل panic را می توانید در قالب خطا یه یک متن مشخص کنید.\nتایپ {}interface یک تایپ خیلی کاربردی می باشد برای مواقعی نمی دانیم ورودی یا خروجی تابع یا تایپ متغیر چی میخواهد باشد از اینترفیس استفاده می کنیم.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5var ( 6\ta interface{} = 123 7\tb interface{} = \u0026#34;abcd\u0026#34; 8\tc interface{} = 2.5 9) 10 11func main() { 12\tfmt.Printf(\u0026#34;%v, %T\\n\u0026#34;, a, a) 13\tfmt.Printf(\u0026#34;%v, %T\\n\u0026#34;, b, b) 14\tfmt.Printf(\u0026#34;%v, %T\\n\u0026#34;, c, c) 15} 1$ go run main.go 2123, int 3abcd, string 42.5, float64 و به عنوان یک تایپ ضمنی می باشد که در ادامه فصل بعدی بیشتر آشنا خواهیم شد.\n1.13.2.1 خطای panic در زمان اجرا (runtime) # خطاهای panic در زمان اجرا به دلایل زیر می تواند رخ دهد :\nخطای Out of bounds/range array/slice فراخوانی تابع که nil pointer باشد ارسال داده برروی کانال های بسته شده type assertion نادرست 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 7\ta := []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;} 8\tprint(a, 2) 9} 10 11func print(a []string, index int) { 12\tfmt.Println(a[index]) 13} 1$ go run main.go 2panic: runtime error: index out of range [2] with length 2 3 4goroutine 1 [running]: 5main.checkAndPrint(...) 6 main.go:12 7main.main() 8 /main.go:8 +0x1b 9exit status 2 در تابع فوق ما یک تابع جهت چاپ یک المنت در داخل slice نوشتیم و به عنوان ورودی a و اندیس ۲ را می دهیم در صورتیکه slice ما فقط ۲ تا المنت بیشتر ندارد 0 و 1 ما به اندیس ۲ اشاره کردیم که باعث بروز panic شده است.\nپانیک رخ داده شامل متن خطا محل رخ دادن panic در قالب stacktrace می باشد 1.13.2.2 خطای panic از قبل تعیین شده توسط برنامه نویس # همانطور که گفتیم شما می توانید هرجایی از بدنه توابع خود تابع panic را فراخوانی که تا برنامه در آن محل خطایی را نمایش و متوقف شود.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 7\ta := []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;} 8\tcheckAndPrint(a, 2) 9} 10 11func checkAndPrint(a []string, index int) { 12\tif index \u0026gt; (len(a) - 1) { 13\tpanic(\u0026#34;Out of bound access for slice\u0026#34;) 14\t} 15\tfmt.Println(a[index]) 16} 1$ go run main.go 2panic: Out of bound access for slice 3 4goroutine 1 [running]: 5main.checkAndPrint(0xc000104f58, 0x2, 0x2, 0x2) 6 main.go:13 +0xe2 7main.main() 8 main.go:8 +0x7d 9exit status 2 توجه کنید استفاده از تابع panic در برخی مواقع مفید می باشد به عنوان مثال قصد دارید هنگام اجرا یکسری تنظیمات از سمت کاربر دریافت کنید و در صورتیکه تنظیمات دارای مشکل باشد می توانید با استفاده panic جلو ادامه روند برنامه را بگیرید تا کاربر خطا را رفع کند. 1.13.3 بازیابی (recovery) # برخی اوقات panic ها غیرقابل پیش بینی می باشند و ممکن است در حال حاضر برنامه شما بدون هیچ خطایی اجرا شوند و به روند خود ادامه دهد اما ممکن است به دلیل اشتباه panic رخ دهد و برنامه شما کاملا متوقف و باعث از دست دادن وضعیت استیبل برنامه شود.\nبه همین منظور یک تابع به نام recover وجود دارد که پس از رخ دادن panic برنامه مجدد بتواند به وضعیت قبلی خود بازگردد تا بعدا خطای panic رخ داده را بررسی و رفع کنیم.\n1func recover() interface{} یک نمونه کد استفاده از recover :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 7\ta := []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;} 8\tcheckAndPrint(a, 2) 9\tfmt.Println(\u0026#34;Exiting normally\u0026#34;) 10} 11 12func checkAndPrint(a []string, index int) { 13\tdefer handleOutOfBounds() 14\tif index \u0026gt; (len(a) - 1) { 15\tpanic(\u0026#34;Out of bound access for slice\u0026#34;) 16\t} 17\tfmt.Println(a[index]) 18} 19 20func handleOutOfBounds() { 21\tif r := recover(); r != nil { 22\tfmt.Println(\u0026#34;Recovering from panic:\u0026#34;, r) 23\t} 24} 1$ go run main.go 2Recovering from panic: Out of bound access for slice 3Exiting normally در کد فوق ما یک تابع داریم که این تابع یک اندیسی از یک slice را چاپ می کند اما اگر این اندیس خارج از تعداد المنت های slice باشد یک خطای panic رخ می دهد. ما برای جلوگیری از خطای panic تابع handleOutOfBounds با استفاده defer درون تابع checkAndPrint قرار دادیم که پس از رخ دادن panic بصورت خودکار بازیابی صورت بگیرد تا برنامه ما متوقف نشود.\n1.13.4 چاپ اطلاعات stacktrace پس از بازیابی # شما می توانید پس از اینکه بازیابی کردید جزئیات بیشتر در خصوص خطای panic رخ داده بدست آوردید.\n1package main 2import ( 3 \u0026#34;fmt\u0026#34; 4 \u0026#34;runtime/debug\u0026#34; 5) 6func main() { 7 a := []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;} 8 checkAndPrint(a, 2) 9 fmt.Println(\u0026#34;Exiting normally\u0026#34;) 10} 11func checkAndPrint(a []string, index int) { 12 defer handleOutOfBounds() 13 if index \u0026gt; (len(a) - 1) { 14 panic(\u0026#34;Out of bound access for slice\u0026#34;) 15 } 16 fmt.Println(a[index]) 17} 18func handleOutOfBounds() { 19 if r := recover(); r != nil { 20 fmt.Println(\u0026#34;Recovering from panic:\u0026#34;, r) 21 fmt.Println(\u0026#34;Stack Trace:\u0026#34;) 22 debug.PrintStack() 23 } 24} 1$ go run main.go 2Recovering from panic: Out of bound access for slice 3Stack Trace: 4goroutine 1 [running]: 5runtime/debug.Stack(0xd, 0x0, 0x0) 6 stack.go:24 +0x9d 7runtime/debug.PrintStack() 8 stack.go:16 +0x22 9main.handleOutOfBounds() 10 main.go:27 +0x10f 11panic(0x10ab8c0, 0x10e8f60) 12 /Users/slohia/Documents/goversion/go1.14.1/src/runtime/panic.go:967 +0x166 13main.checkAndPrint(0xc000104f58, 0x2, 0x2, 0x2) 14 main.go:18 +0x111 15main.main() 16 main.go:11 +0x81 17Exiting normally "},{"id":21,"href":"/chapter-1/go-builtins/","title":"1.14 لیست تایپ ها و توابع Builtin","section":"فصل اول: آشنایی با مفاهیم گو","content":"در زیر لیست تایپ ها و توابع Builtin تا نسخه ۱.۱۹ را با توضیحات قرار دادیم.\n1// bool is the set of boolean values, true and false. 2type bool bool 3 4// true and false are the two untyped boolean values. 5const ( 6 true = 0 == 0 // Untyped bool. 7 false = 0 != 0 // Untyped bool. 8) 9 10// uint8 is the set of all unsigned 8-bit integers. 11// Range: 0 through 255. 12type uint8 uint8 13 14// uint16 is the set of all unsigned 16-bit integers. 15// Range: 0 through 65535. 16type uint16 uint16 17 18// uint32 is the set of all unsigned 32-bit integers. 19// Range: 0 through 4294967295. 20type uint32 uint32 21 22// uint64 is the set of all unsigned 64-bit integers. 23// Range: 0 through 18446744073709551615. 24type uint64 uint64 25 26// int8 is the set of all signed 8-bit integers. 27// Range: -128 through 127. 28type int8 int8 29 30// int16 is the set of all signed 16-bit integers. 31// Range: -32768 through 32767. 32type int16 int16 33 34// int32 is the set of all signed 32-bit integers. 35// Range: -2147483648 through 2147483647. 36type int32 int32 37 38// int64 is the set of all signed 64-bit integers. 39// Range: -9223372036854775808 through 9223372036854775807. 40type int64 int64 41 42// float32 is the set of all IEEE-754 32-bit floating-point numbers. 43type float32 float32 44 45// float64 is the set of all IEEE-754 64-bit floating-point numbers. 46type float64 float64 47 48// complex64 is the set of all complex numbers with float32 real and 49// imaginary parts. 50type complex64 complex64 51 52// complex128 is the set of all complex numbers with float64 real and 53// imaginary parts. 54type complex128 complex128 55 56// string is the set of all strings of 8-bit bytes, conventionally but not 57// necessarily representing UTF-8-encoded text. A string may be empty, but 58// not nil. Values of string type are immutable. 59type string string 60 61// int is a signed integer type that is at least 32 bits in size. It is a 62// distinct type, however, and not an alias for, say, int32. 63type int int 64 65// uint is an unsigned integer type that is at least 32 bits in size. It is a 66// distinct type, however, and not an alias for, say, uint32. 67type uint uint 68 69// uintptr is an integer type that is large enough to hold the bit pattern of 70// any pointer. 71type uintptr uintptr 72 73// byte is an alias for uint8 and is equivalent to uint8 in all ways. It is 74// used, by convention, to distinguish byte values from 8-bit unsigned 75// integer values. 76type byte = uint8 77 78// rune is an alias for int32 and is equivalent to int32 in all ways. It is 79// used, by convention, to distinguish character values from integer values. 80type rune = int32 81 82// any is an alias for interface{} and is equivalent to interface{} in all ways. 83type any = interface{} 84 85// comparable is an interface that is implemented by all comparable types 86// (booleans, numbers, strings, pointers, channels, arrays of comparable types, 87// structs whose fields are all comparable types). 88// The comparable interface may only be used as a type parameter constraint, 89// not as the type of a variable. 90type comparable interface{ comparable } 91 92// iota is a predeclared identifier representing the untyped integer ordinal 93// number of the current const specification in a (usually parenthesized) 94// const declaration. It is zero-indexed. 95const iota = 0 // Untyped int. 96 97// nil is a predeclared identifier representing the zero value for a 98// pointer, channel, func, interface, map, or slice type. 99var nil Type // Type must be a pointer, channel, func, interface, map, or slice type 100// Type is here for the purposes of documentation only. It is a stand-in// for any Go type, but represents the same type for any given function 101// invocation. 102type Type int 103 104// Type1 is here for the purposes of documentation only. It is a stand-in// for any Go type, but represents the same type for any given function 105// invocation. 106type Type1 int 107 108// IntegerType is here for the purposes of documentation only. It is a stand-in// for any integer type: int, uint, int8 etc. 109type IntegerType int 110 111// FloatType is here for the purposes of documentation only. It is a stand-in// for either float type: float32 or float64. 112type FloatType float32 113 114// ComplexType is here for the purposes of documentation only. It is a// stand-in for either complex type: complex64 or complex128. 115type ComplexType complex64 116 117// The append built-in function appends elements to the end of a slice. If 118// it has sufficient capacity, the destination is resliced to accommodate the 119// new elements. If it does not, a new underlying array will be allocated. 120// Append returns the updated slice. It is therefore necessary to store the 121// result of append, often in the variable holding the slice itself: 122// 123// slice = append(slice, elem1, elem2) 124// slice = append(slice, anotherSlice...) 125// 126// As a special case, it is legal to append a string to a byte slice, like this: 127// 128// slice = append([]byte(\u0026#34;hello \u0026#34;), \u0026#34;world\u0026#34;...) 129func append(slice []Type, elems ...Type) []Type 130 131// The copy built-in function copies elements from a source slice into a 132// destination slice. (As a special case, it also will copy bytes from a 133// string to a slice of bytes.) The source and destination may overlap. Copy 134// returns the number of elements copied, which will be the minimum of 135// len(src) and len(dst). 136func copy(dst, src []Type) int 137 138// The delete built-in function deletes the element with the specified key 139// (m[key]) from the map. If m is nil or there is no such element, delete 140// is a no-op. 141func delete(m map[Type]Type1, key Type) 142 143// The len built-in function returns the length of v, according to its type: 144// 145// Array: the number of elements in v. 146// Pointer to array: the number of elements in *v (even if v is nil). 147// Slice, or map: the number of elements in v; if v is nil, len(v) is zero. 148// String: the number of bytes in v. 149// Channel: the number of elements queued (unread) in the channel buffer; 150// if v is nil, len(v) is zero. 151// 152// For some arguments, such as a string literal or a simple array expression, the 153// result can be a constant. See the Go language specification\u0026#39;s \u0026#34;Length and 154// capacity\u0026#34; section for details. 155func len(v Type) int 156 157// The cap built-in function returns the capacity of v, according to its type: 158// 159// Array: the number of elements in v (same as len(v)). 160// Pointer to array: the number of elements in *v (same as len(v)). 161// Slice: the maximum length the slice can reach when resliced; 162// if v is nil, cap(v) is zero. 163// Channel: the channel buffer capacity, in units of elements; 164// if v is nil, cap(v) is zero. 165// 166// For some arguments, such as a simple array expression, the result can be a 167// constant. See the Go language specification\u0026#39;s \u0026#34;Length and capacity\u0026#34; section for 168// details. 169func cap(v Type) int 170 171// The make built-in function allocates and initializes an object of type 172// slice, map, or chan (only). Like new, the first argument is a type, not a 173// value. Unlike new, make\u0026#39;s return type is the same as the type of its 174// argument, not a pointer to it. The specification of the result depends on 175// the type: 176// 177// Slice: The size specifies the length. The capacity of the slice is 178// equal to its length. A second integer argument may be provided to 179// specify a different capacity; it must be no smaller than the 180// length. For example, make([]int, 0, 10) allocates an underlying array 181// of size 10 and returns a slice of length 0 and capacity 10 that is 182// backed by this underlying array. 183// Map: An empty map is allocated with enough space to hold the 184// specified number of elements. The size may be omitted, in which case 185// a small starting size is allocated. 186// Channel: The channel\u0026#39;s buffer is initialized with the specified 187// buffer capacity. If zero, or the size is omitted, the channel is 188// unbuffered. 189func make(t Type, size ...IntegerType) Type 190 191// The new built-in function allocates memory. The first argument is a type, 192// not a value, and the value returned is a pointer to a newly 193// allocated zero value of that type. 194func new(Type) *Type 195 196// The complex built-in function constructs a complex value from two 197// floating-point values. The real and imaginary parts must be of the same 198// size, either float32 or float64 (or assignable to them), and the return 199// value will be the corresponding complex type (complex64 for float32, 200// complex128 for float64). 201func complex(r, i FloatType) ComplexType 202 203// The real built-in function returns the real part of the complex number c. 204// The return value will be floating point type corresponding to the type of c. 205func real(c ComplexType) FloatType 206 207// The imag built-in function returns the imaginary part of the complex 208// number c. The return value will be floating point type corresponding to 209// the type of c. 210func imag(c ComplexType) FloatType 211 212// The close built-in function closes a channel, which must be either 213// bidirectional or send-only. It should be executed only by the sender, 214// never the receiver, and has the effect of shutting down the channel after 215// the last sent value is received. After the last value has been received 216// from a closed channel c, any receive from c will succeed without 217// blocking, returning the zero value for the channel element. The form 218// 219// x, ok := \u0026lt;-c 220// 221// will also set ok to false for a closed and empty channel. 222func close(c chan\u0026lt;- Type) 223 224// The panic built-in function stops normal execution of the current 225// goroutine. When a function F calls panic, normal execution of F stops 226// immediately. Any functions whose execution was deferred by F are run in 227// the usual way, and then F returns to its caller. To the caller G, the 228// invocation of F then behaves like a call to panic, terminating G\u0026#39;s 229// execution and running any deferred functions. This continues until all 230// functions in the executing goroutine have stopped, in reverse order. At 231// that point, the program is terminated with a non-zero exit code. This 232// termination sequence is called panicking and can be controlled by the 233// built-in function recover. 234func panic(v any) 235 236// The recover built-in function allows a program to manage behavior of a 237// panicking goroutine. Executing a call to recover inside a deferred 238// function (but not any function called by it) stops the panicking sequence 239// by restoring normal execution and retrieves the error value passed to the 240// call of panic. If recover is called outside the deferred function it will 241// not stop a panicking sequence. In this case, or when the goroutine is not 242// panicking, or if the argument supplied to panic was nil, recover returns 243// nil. Thus the return value from recover reports whether the goroutine is 244// panicking. 245func recover() any 246 247// The print built-in function formats its arguments in an 248// implementation-specific way and writes the result to standard error. 249// Print is useful for bootstrapping and debugging; it is not guaranteed 250// to stay in the language. 251func print(args ...Type) 252 253// The println built-in function formats its arguments in an 254// implementation-specific way and writes the result to standard error. 255// Spaces are always added between arguments and a newline is appended. 256// Println is useful for bootstrapping and debugging; it is not guaranteed 257// to stay in the language. 258func println(args ...Type) 259 260// The error built-in interface type is the conventional interface for 261// representing an error condition, with the nil value representing no error. 262type error interface { 263 Error() string 264} "},{"id":22,"href":"/chapter-1/go-string-formatting/","title":"1.15 قالب بندی رشته ها","section":"فصل اول: آشنایی با مفاهیم گو","content":"در زبان گو مانند سایر زبان ها یکسری عناوین برای قالب بندی رشته وجود دارد که برخی از این عناوین مشترک بین همه زبان ها می باشد و برخی مختص زبان گو است.\n1.15.1 قالب بندی با تابع Printf و Sprintf # زمانیکه شما از تابع Printf یا Sprintf استفاده می کنید می توانید رشته خروجی را با استفاده از پارامترهای بعد از رشته قالب بندی کنید و در نهایت بصورت یک رشته نمایش دهید.\n1fmt.Printf(\u0026#34;{{Verb}}\u0026#34;, value1, value2, value3, ..., valueN) 1fmt.Sprintf(\u0026#34;{{Verb}}\u0026#34;, value1, value2, value3, ..., valueN) توجه کنید هر دو تابع فوق خیلی کاربردی و پر استفاده هستند ولی این ۲ تابع کارکردشان مشترک ولی خروجی متفاوت می باشد.\nبه عنوان مثال :\nشما با استفاده از Printf می توانید یک رشته را قالب بندی کنید و در نهایت به عنوان خروجی چاپ کنید. ولی با استفاده از Sprintf می توانید یک رشته را قالب بندی کنید و در نهایت می توانید مقدار خروجی را داخل یک متغیر قرار دهید. 1x := fmt.Sprintf(\u0026#34;age %s is %d years\u0026#34;, \u0026#34;Javad\u0026#34;, 30) 1.15.1.1 قالب بندی یک slice # Verb fmt.Printf(\u0026quot;{{Verb}}\u0026quot;, []int64{0, 1}) خروجی توضیحات %v [0 1] فرمت پیش فرض %#v []int64{0, 1} قالب بندی کد گو %T []int64 تایپ مقدار توجه کنید v% یکی از پرکاربرد ترین Verb ها می باشد که برای مواقعی که قصد دارید یک مقدار را داخل رشته بزارید ولی از تایپ اون مقدار خبر ندارید می توانید v% کنید که هر نوع داده ای را قرار می دهد. 1.15.1.2 قالب بندی اعداد صحیح # Verb fmt.Printf(\u0026quot;{{Verb}}\u0026quot;, 15) خروجی توضیحات %d 15 عدد پایه ۱۰ %+d +15 نمایش + در کنار عدد %4d ␣␣15 ۴ کارکتر با فاصله از راست %-4d 15␣␣ ۴ کارکتر با فاصله از چپ %04d 0015 نمایش عدد با پیشوند صفر %b 1111 عدد با پایه باینری %o 17 عدد با پایه ۸ اکتال %x f عدد با پایه ۱۶ هگز حروف کوچک %X F عدد با پایه ۱۶ هگز حروف بزرگ %#x 0xf عدد با پایه ۱۶ هگز به همراه 0x 1.15.1.3 قالب بندی اعداد اعشاری # Verb fmt.Printf(\u0026quot;{{Verb}}\u0026quot;, 123.456) خروجی توضیحات %e 1.234560e+02 نمایش بصورت نماد عملی %f 123.456000 نقطه اعشاری، بدون نما. دقت پیش فرض 6 است %.2f 123.46 عرض پیش فرض، دقت 2 رقم بعد از نقطه اعشار %8.2f ␣␣123.46 عرض 8 کاراکتر، دقت 2 رقم بعد از نقطه اعشار. کاراکتر پیش‌فرض padding space است %08.2f 00123.46 عرض 8 کاراکتر، دقت 2 رقم بعد از نقطه اعشار. لایه سمت چپ با نویسه مشخص شده (اینجا، 0) %g 123.456 نما در صورت نیاز، فقط ارقام ضروری 1.15.1.4 قالب بندی کارکترها # Verb fmt.Printf(\u0026quot;{{Verb}}\u0026quot;, 'A') خروجی توضیحات %c A کارکتر %q 'A' کارکتر به همراه تک کوتیشن %U U+0041 یونیکد %#U U+0041 'A' یونیکد به همراه کارکتر 1.15.1.5 قالب بندی رشته (string) و slice بایت # Verb fmt.Printf(\u0026quot;{{Verb}}\u0026quot;, \u0026quot;gophers\u0026quot;) خروجی توضیحات %s gophers رشته ساده %8s ␣␣gophers با ۸ پدینگ راست چین شده %-8s gophers␣␣ با ۸ پدینگ چپ چین شده %q \u0026quot;gophers\u0026quot; رشته به همراه دابل کوتیشن %x 676f7068657273 خروجی هگز مقدار % x 67 6f 70 68 65 72 73 خروجی هگز مقدار با فاصله 1.15.1.6 قالب بندی بولین # Verb fmt.Printf(\u0026quot;{{Verb}}\u0026quot;, true) خروجی توضیحات %t true نمایش مقدار بولین در رشته 1.15.1.6 قالب بندی اشاره گر (pointer) # Verb fmt.Printf(\u0026quot;{{Verb}}\u0026quot;, new(int)) خروجی توضیحات %p 0xc0000b2000 نمایش آدرس حافظه با پایه ۱۶ به همراه 0x 1.15.2 مقادیر خاص در رشته # همانطور که گفتیم زبان گو یکسری کارکترهای خاص دارد که باعث تغییراتی در خروجی رشته خواهد شد و این کارکترهای خاص بین همه زبان ها مشترک است.\nVerb توضیحات \\a U+0007 هشدار یا زنگ \\b U+0008 بک اسپیس backspace \\\\ U+005c بک اسلش backslash \\t U+0009 تب بصورت افقی \\n U+000A خط جدید \\f U+000C حالت فرم \\r U+000D حالت برگشت \\v U+000b تب بصورت عمودی %% نمایش درصد برای حالت های خاص نظیر fmt.Printf(\u0026quot;%05.2f%%\u0026quot;, math.Pi) "},{"id":23,"href":"/chapter-2/","title":"فصل دوم: مکانیزم های زبان","section":"صفحه اصلی","content":"در این فصل به مکانزیم های زبان گو میپردازیم و برخی از اصطلاحات زبان گو را آموزش می دهیم.\n2.1 در خصوص اشاره گر آموزش خواهیم داد. 2.2 به مهم ترین تایپ در زبان گو ساختار می پردازیم و آموزش می دهیم چطور با استفاده از ساختار دیتامدل های پروژه های خود را پیاده سازی کنید. 2.3 به بحث متدهای می پردازیم که چطور این نوع توابع را پیاده سازی کنید. 2.4 در خصوص اینترفیس در زبان گو توضیح می دهیم دقیقا چی هستند و چطور میشه ازش استفاده کرد. 2.5 به جاسازی ساختار و اینترفیس می پردازیم. 2.6 در خصوص مدیریت خطاها در زبان گو می پردازیم که چه ویژگی هایی دارد. 2.7 تفاوت castin با conversion را آموزش می دهیم. "},{"id":24,"href":"/chapter-2/pointer/","title":"2.1 اشاره گر (Pointer)","section":"فصل دوم: مکانیزم های زبان","content":"اشاره گر در واقع متغیری است که آدرس حافظه متغیر دیگری را نگه می دارد.\n1var ex *T در بالا ما یک متغیری تعریف کردیم که مقدار داخل آدرس حافظه متغیری T را با استفاده از * را نگه می دارد.\nدر اشاره گر ۲ تا اپراتور داریم که هر کدام از این ها را در کنار یک متغیر بزاریم به آدرس حافظه یا مقدار داخل خانه حافظه متغیر قبلی دسترسی پیدا می کنیم :\n\u0026amp; با استفاده از این می توانیم آدرس حافظه متغیر فرضا x را به متغیر دیگری بدهیم (y := \u0026amp;x) * با استفاده از این می توانیم به مقدار داخل خانه حافظه متغیر فرضا x دسترسی پیدا کنیم (x*) برای اینکه یک اشاره گر تعریف کنیم ۲ روش وجود دارد :\nاستفاده از تابع new استفاده از اپراتور \u0026amp; (آمپرسند) 2.1.1 استفاده از تابع new # یک اشاره گر با استفاده از تابع new بصورت زیر راه اندازی می شود :\n1a := new(int) 2*a = 10 3fmt.Println(*a) //Output will be 10 در بالا ما متغیر a را از نوع int اشاره گر تعریف کردیم و سپس داخل آدرس حافظه a مقدار ۱۰ را قرار دادیم.\nتوجه کنید مقدار پیش فرض یک متغیر از نوع اشاره گر nil می باشد. و اگر جایی شما متغیر از نوع اشاره گر بصورت nil بفرستید ممکن است panic از نوع nil pointer بر بخورید و پروژه کاملا متوقف شود. 2.1.2 استفاده از اپراتور \u0026lsquo;\u0026amp;\u0026rsquo; # برای دریافت آدرس حافظه یک متغیر از \u0026amp; استفاده می شود :\n1a := 2 2b := \u0026amp;a 3fmt.Println(*b) //Output will be 2 در زیر یک نمونه کد مثال زدیم توجه کنید :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 var b *int 7 a := 2 8 b = \u0026amp;a 9 10 fmt.Println(b) 11 fmt.Println(*b) 12 b = new(int) 13 *b = 10 14 fmt.Println(*b) 15} 1$ go run main.go 22 310 40xc0000b0018 در خروجی بالا 0xc0000b0018 آدرس حافظه متغیر a می باشد.\n2.1.3 اپراتور * اشاره گر # اپراتور * برای می توانیم برای عملیات زیر استفاده کنیم :\nگرفتن مقدار یک آدرس حافظه که با استفاده از اشاره گر ذخیره شده است. تغییر مقدار یک آدرس حافظه 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\ta := 2 7\tb := \u0026amp;a 8\tfmt.Println(a) 9\tfmt.Println(*b) 10 11\t*b = 3 12\tfmt.Println(a) 13\tfmt.Println(*b) 14 15\ta = 4 16\tfmt.Println(a) 17\tfmt.Println(*b) 18} 1$ go run main.go 22 32 43 53 64 74 در بالا a و b* هر دور به یک متغیر دارند اشاره می کنند. بنابرین تغییر مقدار داخل خانه حافظه روی هر دو متغیر تاثیر میگذارد.\n2.1.4 اشاره گر به یک اشاره گر # شما می توانید یک متغیر اشاره گر تعریف کنید و متغیر اشاره گر دیگری را بهش اختصاص دهید.\n1a := 2 2b := \u0026amp;a 3c := \u0026amp;b در بالا متغیر a مقدارش ۲ می باشد و آدرسش در حافظه 0xXXXXXX است و در مقدار متغیر b ما اشاره کردیم به آدرس حافظه متغیر a و در ادامه در متغیر c به آدرس حافظه متغیر b اشاره کردیم که آدرسش در حافظه 0xYYYYYY است.\nزمانیکه شما بخواهید مقدار c را چاپ کنید کافیه c** را استفاده کنید تا مقدار را ۲ را که داخل خانه حافظه متغیر a قرار دارد را چاپ کند.\nبه مثال زیر توجه کنید :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\ta := 2 7\tb := \u0026amp;a 8\tc := \u0026amp;b 9 10\tfmt.Printf(\u0026#34;a: %d\\n\u0026#34;, a) 11\tfmt.Printf(\u0026#34;b: %x\\n\u0026#34;, b) 12\tfmt.Printf(\u0026#34;c: %x\\n\u0026#34;, c) 13 14\tfmt.Println() 15\tfmt.Printf(\u0026#34;a: %d\\n\u0026#34;, a) 16\tfmt.Printf(\u0026#34;*\u0026amp;a: %d\\n\u0026#34;, *\u0026amp;a) 17\tfmt.Printf(\u0026#34;*b: %d\\n\u0026#34;, *b) 18\tfmt.Printf(\u0026#34;**c: %d\\n\u0026#34;, **c) 19 20\tfmt.Println() 21\tfmt.Printf(\u0026#34;\u0026amp;a: %d\\n\u0026#34;, \u0026amp;a) 22\tfmt.Printf(\u0026#34;b: %d\\n\u0026#34;, b) 23\tfmt.Printf(\u0026#34;\u0026amp;*b: %d\\n\u0026#34;, \u0026amp;*b) 24\tfmt.Printf(\u0026#34;*\u0026amp;b: %d\\n\u0026#34;, *\u0026amp;b) 25\tfmt.Printf(\u0026#34;*c: %d\\n\u0026#34;, *c) 26 27\tfmt.Println() 28\tfmt.Printf(\u0026#34;b: %d\\n\u0026#34;, \u0026amp;b) 29\tfmt.Printf(\u0026#34;*c: %d\\n\u0026#34;, c) 30} 1$ go run main.go 2a: 2 3b: c000018078 4c: c00000e028 5 6a: 2 7*\u0026amp;a: 2 8*b: 2 9**c: 2 10 11\u0026amp;a: 824633819256 12b: 824633819256 13\u0026amp;*b: 824633819256 14*\u0026amp;b: 824633819256 15*c: 824633819256 16 17b: 824633778216 18*c: 824633778216 توجه کنید زبان گو همانند زبان c استفاده از اشاره گر حسابی (Pointer Arithmetic) امکان پذیر نمی باشد و با خطای زیر مواجه خواهید شد :\n1package main 2func main() { 3 a := 1 4 b := \u0026amp;a 5 b = b + 1 6} 1$ go run main.go 2invalid operation: b + 1 (mismatched types *int and int) "},{"id":25,"href":"/chapter-2/struct/","title":"2.2 ساختار (struct)","section":"فصل دوم: مکانیزم های زبان","content":"در زبان گو ساختار به کالکشنی از فیلدها با تایپ های مختلف می گویند. شما با استفاده ساختار می توانید ساختار یا مدل کلی از بدنه پروژه خود را بنویسید. برای نمونه ما یک ساختار employee مثال زدیم تا با ساختار آشنا شوید.\n1type employee struct { 2 name string 3 age int 4 salary int 5} نکته: ساختار می‌تواند بصورت خالی نیز جهت برخی اهداف ایجاد گردد.\n1type sample struct {} متدها روی ساختار\nبرای ایجاد ساختار باید از کلمه کلیدی type استفاده کنید.\nداخل بدنه ساختار فیلدها را تعریف کنید.\nفیلد name از نوع string فیلد age از نوع int فیلد salary از نوع int ساختار زبان گو را با class در سایر زبان ها مقایسه می کنند. 2.2.1 تعریف تایپ struct # در زیر یک مثال ساده برای اینکه بتوانید در هر جای بدنه فایل go ساختار تعریف کنید زدیم :\n1type point struct { 2 x float64 3 y float64 4} در بالا ما ۲ تا فیلد برای ساختار تعریف کردیم که هر دو فیلد از نوع float64 می باشند.\n2.2.2 ایجاد یک متغیر ساختار (struct) # برای ایجاد یک متغیر ساختار می توانید خیلی ساده تعریف کنید و خانه ای از حافظه را برای متغیر در نظر گرفته شود.\n1emp := employee{} در بالا یک متغیر با مقدار پیش فرض صفر ساختار employee تعریف کردیم.\nزمانیکه یک متغیر ساختار تعریف می کنید مقدار استفاده از حافظه 0 بایت می باشد. ایجاد متغیر ساختار و مقدار دهی فیلدها در یک خط : 1emp := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} ایجاد متغیر ساختار و مقدار دهی فیلد در خط های مختلف (توصیه می شود) : 1emp := employee{ 2 name: \u0026#34;Sam\u0026#34;, 3 age: 31, 4 salary: 2000, 5} توجه کنید هیچ اجباری نیست حتما فیلدی را مقدار دهی کنید چون می توانید در جاهای دیگر یا هر زمانیکه نیاز داشتید مقدار دهی کنید.\n1emp := employee{ 2 name: \u0026#34;Sam\u0026#34;, 3 age: 31, 4} در بالا ما فیلد salary را مقدار دهی نکردیم و بطور پیش فرض کامپایلر با توجه به تایپ فیلد مقدار پیش فرض صفر اون تایپ را در نظر میگیرد.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type employee struct { 6 name string 7 age int 8 salary int 9} 10 11func main() { 12 emp1 := employee{} 13 fmt.Printf(\u0026#34;Emp1: %+v\\n\u0026#34;, emp1) 14 15 emp2 := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} 16 fmt.Printf(\u0026#34;Emp2: %+v\\n\u0026#34;, emp2) 17 18 emp3 := employee{ 19 name: \u0026#34;Sam\u0026#34;, 20 age: 31, 21 salary: 2000, 22 } 23 fmt.Printf(\u0026#34;Emp3: %+v\\n\u0026#34;, emp3) 24 25 emp4 := employee{ 26 name: \u0026#34;Sam\u0026#34;, 27 age: 31, 28 } 29 fmt.Printf(\u0026#34;Emp4: %+v\\n\u0026#34;, emp4) 30} 1$ go run main.go 2Emp1: {name: age:0 salary:0} 3Emp2: {name:Sam age:31 salary:2000} 4Emp3: {name:Sam age:31 salary:2000} 5Emp4: {name:Sam age:31 salary:0} ایجاد متغیر ساختار و مقدار دهی فیلدها بدون نام فیلد : شما می توانید فیلدها را بدون اینکه نام فیلد را قرار دهید مقدار دهی کنید اما از نظر تکنیکی اینکار توصیه نمی شود.\n1emp := employee{\u0026#34;Sam\u0026#34;, 31, 2000} 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type employee struct { 6 name string 7 age int 8 salary int 9} 10 11func main() { 12 emp := employee{\u0026#34;Sam\u0026#34;, 31, 2000} 13 fmt.Printf(\u0026#34;Emp: %+v\\n\u0026#34;, emp) 14} 1$ go run main.go 2Emp2: {name:Sam age:31 salary:2000} 2.2.3 دسترسی و تنظیم فیلدهای ساختار (struct) # زمانیکه شما یک متغیر ساختار تعریف می کنید می توانید خیلی آسان با استفاده از همان متغیر به فیلدهای ساختار دسترسی پیدا کنید و مقدار هر کدام از فیلدها را تغییر دهید.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type employee struct { 6 name string 7 age int 8 salary int 9} 10 11func main() { 12 emp := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} 13 14 //Accessing a struct field 15 n := emp.name 16 fmt.Printf(\u0026#34;Current name is: %s\\n\u0026#34;, n) 17 18 //Assigning a new value 19 emp.name = \u0026#34;John\u0026#34; 20 fmt.Printf(\u0026#34;New name is: %s\\n\u0026#34;, emp.name) 21} 1$ go run main.go 2Current name is: Sam 3New name is: John 2.2.4 کار با اشاره گر (Pointer) در ساختار (struct) # شما برای ایجاد یک struct از نوع اشاره گر از دو حالت زیر می توانید استفاده کنید :\nبا استفاده از عملگر \u0026amp; که اشاره به خانه حافظه دارد با استفاده از تابع new 2.2.4.1 ایجاد ساختار با استفاده عملگر \u0026amp; # برای اینکه بتوانید یک ساختار از نوع اشاره گر ایجاد کنید می توانید از عملگر \u0026amp; استفاده کنید.\n1emp := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} 2empP := \u0026amp;emp حتی یک ساختار اشاره گر می تواند مستقیما ایجاد شود :\n1empP := \u0026amp;employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} به کد زیر توجه کنید :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type employee struct { 6 name string 7 age int 8 salary int 9} 10 11func main() { 12 emp := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} 13 empP := \u0026amp;emp 14 fmt.Printf(\u0026#34;Emp: %+v\\n\u0026#34;, empP) 15 empP = \u0026amp;employee{name: \u0026#34;John\u0026#34;, age: 30, salary: 3000} 16 fmt.Printf(\u0026#34;Emp: %+v\\n\u0026#34;, empP) 17} 1$ go run main.go 2Emp: \u0026amp;{name:Sam age:31 salary:2000} 3Emp: \u0026amp;{name:John age:30 salary:3000} 2.2.4.2 ایجاد ساختار با استفاده تابع new # 1func new(Type) *Type با استفاده از تابع new :\nشما یک ساختار ایجاد می کنید. سپس فیلدها با مقدار پیش فرض صفر مقدار دهی اولیه می شوند. در نهایت ساختار شما از نوع اشاره گر بازگشت داده می شود. 1empP := new(employee) برای اینکه آدرس خانه حافظه ساختار از نوع اشاره گر را ببینید کافیه :\n1fmt.Printf(\u0026#34;Emp Pointer: %p\\n\u0026#34;, empP) برای اینکه مقدار هر یک از فیلدها را ببینید کافیه :\n1fmt.Printf(\u0026#34;Emp Value: %+v\\n\u0026#34;, *empP) 1$ go run main.go 2Emp Value: {name: age:0 salary:0} در زیر یک کد نمونه قرار دادیم به عنوان مثال :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type employee struct { 6 name string 7 age int 8 salary int 9} 10 11func main() { 12 empP := new(employee) 13 fmt.Printf(\u0026#34;Emp Pointer Address: %p\\n\u0026#34;, empP) 14 fmt.Printf(\u0026#34;Emp Pointer: %+v\\n\u0026#34;, empP) 15 fmt.Printf(\u0026#34;Emp Value: %+v\\n\u0026#34;, *empP) 16} 1$ go run main.go 2Emp Pointer Address: 0xc000130000 3Emp Pointer: \u0026amp;{name: age:0 salary:0} 4Emp Value: {name: age:0 salary:0} 2.2.5 چاپ یک متغیر ساختار (struct) # برای اینکه بتوانید یک متغیر را چاپ کنید از دو روش زیر می توانید استفاده کنید و توجه کنید متغیر ساختار بصورت key/value هستش.\nبا استفاده از پکیج fmt چاپ متغیر ساختار با استفاده از پکیج json/encoding 2.2.5.1 چاپ با استفاده از fmt # در پکیج fmt ۲ تا تابع کاربردی جهت چاپ وجود دارد که اکثر اوقات استفاده می کنیم :\nتابع Println ورودی را با فرمت پیش فرض چاپ و در نهایت خط جدید در نظر میگیرد. تابع Printf ورودی را با فرمت مشخص شده چاپ می کند و دست شما برای تعیین فرمت باز می باشد. در زیر ما یک نمونه از employee ایجاد کردیم :\n1emp := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} حال به شیوه های زیر با استفاده از تابع Printf ساختار را چاپ کردیم :\n1fmt.Printf(\u0026#34;%v\u0026#34;, emp) - {Sam 31 2000} 1fmt.Printf(\u0026#34;%+v\u0026#34;, emp) - {name:Sam age:31 salary:2000} %v - مقدار هر کدام از فیلدهای ساختار چاپ می کند. %+v - مقدار هرکدام از فیلدها به همراه اسم فیلد چاپ می کند. در زیر با استفاده از از تابع Println ساختار را چاپ کردیم :\n1fmt.Println(emp) - {Sam 31 2000} در نهایت کد زیر یک مثال کلی از چاپ با استفاده از پکیج fmt می باشد :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type employee struct { 6 name string 7 age int 8 salary int 9} 10 11func main() { 12 emp := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} 13 fmt.Printf(\u0026#34;Emp: %v\\n\u0026#34;, emp) 14 fmt.Printf(\u0026#34;Emp: %+v\\n\u0026#34;, emp) 15 fmt.Printf(\u0026#34;Emp: %#v\\n\u0026#34;, emp) 16 fmt.Println(emp) 17} 1$ go run main.go 2Emp: {Sam 31 2000} 3Emp: {name:Sam age:31 salary:2000} 4Emp: main.employee{name:\u0026#34;Sam\u0026#34;, age:31, salary:2000} 5{Sam 31 2000} 2.2.5.2 چاپ ساختار با استفاده از پکیج JSON # در این روش ما با استفاده از ۲ تابع Marshal و MarshalIndent پکیج json ساختار را encode می کنیم. و در نهایت خروجی encode شده را چاپ می کنیم.\nMarshal - در این تابع به عنوان ورودی ساختار را پاس می دهیم و در نهایت ۲ خروجی از نوع بایت و خطا دریافت می کنیم. 1Marshal(v interface{}) ([]byte, error) MarhsalIndent - با استفاده از این تابع ۳ تا ورودی پاس می دهیم به ترتیب ساختار, پیشوند و indent و در نهایت ۲ خروجی از نوع بایت و خطا دریافت می کنیم. 1MarshalIndent(v interface{}, prefix, indent string) ([]byte, error) حالا با استفاده از توابع فوق یک کد نمونه مثال می زنیم چطور از این توابع استفاده کنید :\n1package main 2 3import ( 4 \u0026#34;encoding/json\u0026#34; 5 \u0026#34;fmt\u0026#34; 6 \u0026#34;log\u0026#34; 7) 8 9type employee struct { 10 Name string 11 Age int 12 salary int 13} 14 15func main() { 16 emp := employee{Name: \u0026#34;Sam\u0026#34;, Age: 31, salary: 2000} 17 //Marshal 18 empJSON, err := json.Marshal(emp) 19 if err != nil { 20 log.Fatalf(err.Error()) 21 } 22 fmt.Printf(\u0026#34;Marshal funnction output %s\\n\u0026#34;, string(empJSON)) 23 24 //MarshalIndent 25 empJSON, err = json.MarshalIndent(emp, \u0026#34;\u0026#34;, \u0026#34; \u0026#34;) 26 if err != nil { 27 log.Fatalf(err.Error()) 28 } 29 fmt.Printf(\u0026#34;MarshalIndent funnction output %s\\n\u0026#34;, string(empJSON)) 30} 1$ go run main.go 2Marshal funnction output {\u0026#34;Name\u0026#34;:\u0026#34;Sam\u0026#34;,\u0026#34;Age\u0026#34;:31} 3 4MarshalIndent funnction output { 5 \u0026#34;Name\u0026#34;: \u0026#34;Sam\u0026#34;, 6 \u0026#34;Age\u0026#34;: 31 7} برای اطلاعات بیشتر در خصوص پکیج json می توانید به بخش آموزش کار با jsonمراجعه کنید. 2.2.6 کار با تگ ها در ساختار (struct) # در ساختار زبان گو شما امکان اضافه کردن metadata به هر یک از فیلدها را دارید که ما به عنوان تگ می شناسیم که تگ ها برای انجام یکسری عملیات خاص نظیر encode/decode, اعتبارسنجی مقادیر فیلدها و \u0026hellip; کمک می کند و یکی از کاربردی ترین عناوین در ساختار می باشد.\nدر زیر ما یک نمونه ساختار به همراه تگ تعریف کردیم :\n1type strutName struct{ 2 fieldName type `key:\u0026#34;value\u0026#34; key2:\u0026#34;value2\u0026#34;` 3} 1type employee struct { 2 Name string `json:\u0026#34;n\u0026#34;` 3 Age int `json:\u0026#34;a\u0026#34;` 4 Salary int `json:\u0026#34;s\u0026#34;` 5} تگ json به شما برای تعیین نام key داخل json کمک می کند و شما می توانید عنوان هر یک از فیلدهای بدنه json را یک نام اختصاصی قرار دهید و با استفاده از اون نام اختصاصی عملیات encode/decode در json انجام دهید.\n1package main 2 3import ( 4 \u0026#34;encoding/json\u0026#34; 5 \u0026#34;fmt\u0026#34; 6 \u0026#34;log\u0026#34; 7) 8 9type employee struct { 10 Name string `json:\u0026#34;n\u0026#34;` 11 Age int `json:\u0026#34;a\u0026#34;` 12 Salary int `json:\u0026#34;s\u0026#34;` 13} 14 15func main() { 16 emp := employee{Name: \u0026#34;Sam\u0026#34;, Age: 31, Salary: 2000} 17 //Converting to jsonn 18 empJSON, err := json.MarshalIndent(emp, \u0026#39;\u0026#39;, \u0026#39; \u0026#39;) 19 if err != nil { 20 log.Fatalf(err.Error()) 21 } 22 fmt.Println(string(empJSON)) 23} 1$ go run main.go 2{ 3 \u0026#34;n\u0026#34;: \u0026#34;Sam\u0026#34;, 4 \u0026#34;a\u0026#34;: 31, 5 \u0026#34;s\u0026#34;: 2000 6} در خروجی بالا نام key هر کدام از فیلدها تغییر کرده و دقت کنید ارتباط فیلدهای ساختار شما با فیلدهای json به واسطه تگی که تعیین کردید می باشد.\n2.2.7 تعریف فیلد ناشناس در ساختار (struct) # در ساختار امکان تعریف فیلدهای ناشناس را دارید و می توانید فیلد ناشناس را مقدار دهی کنید.\n1type employee struct { 2 string 3 age int 4 salary int 5} در زیر یک مثال ساده در خصوص فیلد ناشناس زدیم :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type employee struct { 6 string 7 age int 8 salary int 9} 10 11func main() { 12 emp := employee{string: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} 13 //Accessing a struct field 14 n := emp.string 15 fmt.Printf(\u0026#34;Current name is: %s\\n\u0026#34;, n) 16 //Assigning a new value 17 emp.string = \u0026#34;John\u0026#34; 18 fmt.Printf(\u0026#34;New name is: %s\\n\u0026#34;, emp.string) 19} 1$ go run main.go 2Current name is: Sam 3New name is: John 2.2.8 تعریف ساختار تو در تو (nested) # یکی دیگر از امکانات ساختار در زبان گو بحث ساختار تو در تو می باشد. که در زیر مثالی که زدیم ساختار address را داخل employee قرار دادیم :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type employee struct { 6 name string 7 age int 8 salary int 9 address address 10} 11 12type address struct { 13 city string 14 country string 15} 16 17func main() { 18 address := address{city: \u0026#34;London\u0026#34;, country: \u0026#34;UK\u0026#34;} 19 emp := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000, address: address} 20 fmt.Printf(\u0026#34;City: %s\\n\u0026#34;, emp.address.city) 21 fmt.Printf(\u0026#34;Country: %s\\n\u0026#34;, emp.address.country) 22} 1$ go run main.go 2City: London 3Country: UK توجه کنید شما طبق روش زیر می توانید به فیلدهای تو در تو دسترسی داشته باشید :\n1emp.address.city 2emp.address.country 2.2.9 تعریف یک ساختار عمومی یا خصوصی (Public/Private) # در زبان گو چیزی به عنوان کلمه کلیدی public یا private جهت تعیین وضعیت دسترسی به بیرون ندارد ولی در عوض کامپایلر گو براساس حرف بزرگ یا کوچک عنوان ساختار یا سایر تایپ ها تشخیص می دهد تایپ شما عمومی است یا خصوصی و در صورتیکه شما حرف اول را کوچک قرار دهید به کامپایلر دارید میگید این تایپ از بیرون این پکیج دسترسی ندارد.\n1type Person struct { 2 Name string 3 age int 4} 5 6type company struct { 7 Name string 8} برای اطلاعات بیشتر بهتره به بخش کپسوله سازی مراجعه کنید. 2.2.10 مقایسه ساختارها # در زبان گو خیلی ساده می توانید ساختارها را بر اساس عنوان فیلد و تایپ و مقدارشان مقایسه کنید. اما باید توجه کنید ساختارها فقط براساس تایپ هایی که در زیر معرفی کردیم امکان مقایسه را خواهند داشت :\nboolean numeric string pointer channel interface types structs array اما ۳ تایپ زیر امکان مقایسه را از بین می برد :\nSlice Map Function 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type employee struct { 6 name string 7 age int 8 salary int 9} 10 11func main() { 12 emp1 := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} 13 emp2 := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} 14 if emp1 == emp2 { 15 fmt.Println(\u0026#34;emp1 annd emp2 are equal\u0026#34;) 16 } else { 17 fmt.Println(\u0026#34;emp1 annd emp2 are not equal\u0026#34;) 18 } 19} 1$ go run main.go 2emp1 annd emp2 are equal "},{"id":26,"href":"/chapter-2/method/","title":"2.3 متد (Method)","section":"فصل دوم: مکانیزم های زبان","content":"متد در واقع یک تابع گیرنده (reciver) است که به واسطه یک تایپ در دسترس خواهد, تا زمانیکه شما یک متغیر از نوع تایپی که دارای متد می باشد را راه اندازی نکنید به متدهایش دسترسی نخواهید داشت.\nاکثرا متد را یکی از عناوین شی گرایی در زبان گو میشناسند که مزایای خوبی دارد بخصوص اگر متدها برای تایپ struct تعریف شوند شما می توانید برای هریک از فیلدهای ساختارتان توابع بخصوصی در قالب متد بنویسید .\nدر زیر یک نمونه از متد را قرار دادیم :\n1func (receiver receiver_type) some_func_name(arguments) return_values توجه کنید برای تعریف تابع متد باید قبل از اسم تابع پرانتز قرار دهید و داخلش یک نام و تایپ مورد (reciver type) نظر را قرار دهید.\n2.3.1 متدها برای ساختار (struct) # زبان گو یک زبان شی گرا نیست ولی برخی از مفاهیم شی گرایی را بصورت قرار دادی دارد که شما می توانید در کدهای خود استفاده کنید. ساختار در زبان گو یک تایپ می باشد که این تایپ کالکشنی از تایپ های مختلف می باشد که بخش قبلی ما بهش پرداختیم.\nدر زیر یک مثال در خصوص استفاده از متدها برای ساختار زدیم :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type employee struct { 6 name string 7 age int 8 salary int 9} 10 11func (e employee) details() { 12 fmt.Printf(\u0026#34;Name: %s\\n\u0026#34;, e.name) 13 fmt.Printf(\u0026#34;Age: %d\\n\u0026#34;, e.age) 14} 15 16func (e employee) getSalary() int { 17 return e.salary 18} 19 20func main() { 21 emp := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} 22 emp.details() 23 fmt.Printf(\u0026#34;Salary %d\\n\u0026#34;, emp.getSalary()) 24} 1$ go run main.go 2Name: Sam 3Age: 31 4Salary 2000 در کد بالا ما یک ساختار با نام employee ایجاد کردیم و سپس برایش ۲ تا متد با نام های details و getSalary تعریف کردیم. حال برای اینکه بتوانیم از این متدها استفاده کنیم داخل تابع main ما یک متغیر از نوع employee تعریف کردیم و سپس با استفاده از نقطه . پس از نام متغیر به متدها دسترسی پیدا کردیم همانند دسترسی به فیلدهای ساختار.\nآیا با استفاده از متد می توانیم مقدار یکی از فیلدهای داخل ساختار را تغییر دهیم ؟ این سوال ۲ جواب دارد هم آره و هم خیر\nحال به مثال زیر توجه کنید تا توضیح دهیم :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type employee struct { 6 name string 7 age int 8 salary int 9} 10 11func (e employee) setNewName(newName string) { 12 e.name = newName 13} 14 15func main() { 16 emp := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} 17 emp.setNewName(\u0026#34;John\u0026#34;) 18 fmt.Printf(\u0026#34;Name: %s\\n\u0026#34;, emp.name) 19} 1$ go run main.go 2Name: Sam علت اینکه می گوییم خیر : به خاطر اینکه ما داریم با یک کپی از فیلدهای ساختار کار می کنیم و با تغییر مقدار هر یک از فیلدها تغییر صورت نمی پذیرد. اما علت اینکه می گوییم آره : اگر ما با استفاده از اشاره گر به فیلدهای داخل ساختار دسترسی پیدا کنیم می توانید مستقیما داخل خانه حافظه مشخص شده مقدار فیلد مورد نظر ساختار را در هرجایی از پروژه تغییر دهیم. 2.3.2 استفاده از اشاره گر (pointer) در متدها # در بالا ما مثالی زدیم و اشاره کردیم به اینکه آیا می توانید مقدار هر یک از فیلدهای ساختار را با استفاده از متد تغییر دهیم یا خیر و در پاسخ گفتیم آره و خیر و علت آره را توضیح دادیم. حال می خواهیم با یک مثال این مورد را توضیح دهیم.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type employee struct { 6 name string 7 age int 8 salary int 9} 10 11func (e *employee) setNewName(newName string) { 12 e.name = newName 13} 14 15func main() { 16 emp := \u0026amp;employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} 17 emp.setNewName(\u0026#34;John\u0026#34;) 18 fmt.Printf(\u0026#34;Name: %s\\n\u0026#34;, emp.name) 19} 1$ go run main.go 2Name: John در بالا متد setNewName یک نوع متد گیرنده از نوع اشاره گر است که ما داخل این تابع متد به مقدار فیلدهای داخل خانه حافظه ساختار employee دسترسی داریم و می توانیم مقدار دهی کنیم.\nآیا استفاده از گیرنده اشاره گر واقعا ضروری است؟ خیر, ضروری نیست زیرا ما وقتی به متدها دسترسی داریم که یک نمونه (instance) از تایپ مورد نظر ایجاد کنیم تا به متدهایش دسترسی داشته باشیم و همچنین اگر فرضا نیاز داشته باشیم که یکی از فیلد های ساختار را مقدار دهی کنیم بازم می توانیم به آدرس خانه متغیری که ساختار راه نگه داری می کند اشاره کنیم و مقدارش را تغییر دهیم.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type employee struct { 6 name string 7 age int 8 salary int 9} 10 11func (e *employee) setNewName(newName string) { 12 e.name = newName 13} 14 15func main() { 16 emp := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000} 17 emp.setNewName(\u0026#34;John\u0026#34;) 18 19 fmt.Printf(\u0026#34;Name: %s\\n\u0026#34;, emp.name) 20 21 (\u0026amp;emp).setNewName(\u0026#34;Mike\u0026#34;) 22 fmt.Printf(\u0026#34;Name: %s\\n\u0026#34;, emp.name) 23} 1$ go run main.go 2Name: John 3Name: Mike 2.3.2.1 چه موقع باید از گیرنده اشاره گر برای متد استفاده کنیم # زمانیکه قصد داریم متدهایی بنویسیم که برروی مقدار فیلدهای ساختار در زمان اجرا تغییراتی انجام دهد. زمانیکه ساختار خیلی بزرگ است و کلی فیلد دارد در اینجا بهتر از گیرنده اشاره گر استفاده کنیم تا هر بار با یکی کپی از ساختار مواجه نشویم و اینکار سربار را کم می کند. 2.3.4 تعریف متد برای فیلدهای ساختار تو در تو (nested) # شما می توانید برای فیلدهایی که ساختار تو در تو دارد متد بنویسید :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type employee struct { 6\tname string 7\tage int 8\tsalary int 9\taddress address 10} 11 12type address struct { 13\tcity string 14\tcountry string 15} 16 17func (a address) details() { 18\tfmt.Printf(\u0026#34;City: %s\\n\u0026#34;, a.city) 19\tfmt.Printf(\u0026#34;Country: %s\\n\u0026#34;, a.country) 20} 21 22func main() { 23\taddress := address{city: \u0026#34;London\u0026#34;, country: \u0026#34;UK\u0026#34;} 24 25\temp := employee{name: \u0026#34;Sam\u0026#34;, age: 31, salary: 2000, address: address} 26 27\temp.address.details() 28} 1$ go run main.go 2City: London 3Country: UK در بالا ما یک متد برای ساختار address تعریف کردیم و سپس ساختار address را داخل ساختار employee گذاشتیم. در نهایت شما با استفاده از employee می توانید به متدهای address هم دسترسی داشته باشید و استفاده کنید.\n"},{"id":27,"href":"/chapter-2/interface/","title":"2.4 اینترفیس (Interface)","section":"فصل دوم: مکانیزم های زبان","content":"اینترفیس در زبان گو مجموعه ای از متدها می باشد. این مجموعه متدها با توجه به ورودی و خروجی که دارند دارای رفتارهای خاصی هستند. زمانیکه شما یک اینترفیس به همراه یکسری از متدها تعریف می کنید باید در جایی این متدها را پیاده سازی کنید.\nاینترفیس ها به شما اجازه می دهد تا از Duck typing استفاده کنید. حالا این duck typing چیست؟\nduck typing روشی در برنامه نویسی کامپیوتری است که به شما امکان می دهد تست اردک را انجام دهید، جایی که ما نوع را بررسی نمی کنیم، بلکه تنها وجود برخی ویژگی ها یا روش ها را بررسی می کنیم. بنابراین آنچه واقعاً اهمیت دارد این است که آیا یک شی دارای ویژگی ها و روش های خاصی است و نه نوع آن.\nبرگردیم به بحث اینترفیس, در زیر ما یک نمونه اینترفیس را قرار دادیم :\n1type name_of_interface interface{ 2//Method signature 1 3//Method signature 2 4} برای اینکه مفهوم بالا را بهتر بفهمیم بزارید یک مثال بزنیم ساده بزنیم فرض کنید ما یک شی به نام animal که دارای یکسری رفتارها مانند: نفش کشید, راه رفتن را دارد که این رفتارهای باید به یک حیوان اختصاص دهیم تا بتوانیم رفتارهای آن حیوان را مشخص کنیم.\n1type animal interface { 2 breathe() 3 walk() 4} در بالا ما یک اینترفیس تعریف کردیم ۲ تا متد دارد حالا بیاید یک متغیر از نوع اینترفیس animal درست کنیم و چاپ کنیم.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type animal interface { 6 breathe() 7 walk() 8} 9 10func main() { 11 var a animal 12 fmt.Println(a) 13} 1$ go run main.go 2nil در بالا وقتی اینترفیس را چاپ کردیم و خروجی nil بود و توجه کنید اینترفیس مقدار پیش فرض یا خالی بودنش nil هست.\n2.4.1 پیاده سازی اینترفیس # در بالا ما یک اینترفیس animal تعریف کردیم که ۲ متد داشت حالا قصد داریم یک شی (منظور ساختار در گو) به نام lion تعریف کنیم و متدهای اینترفیس animal را پیاده سازی کنیم.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type animal interface { 6 breathe() 7 walk() 8} 9 10type lion struct { 11 age int 12} 13 14func (l lion) breathe() { 15 fmt.Println(\u0026#34;Lion breathes\u0026#34;) 16} 17 18func (l lion) walk() { 19 fmt.Println(\u0026#34;Lion walk\u0026#34;) 20} 21 22func main() { 23 var a animal 24 a = lion{age: 10} 25 a.breathe() 26 a.walk() 27} 1$ go run main.go 2Lion breathes 3Lion walk در بالا ما یک متغیر با تایپ animal تعریف کردیم :\n1var a animal سپس ما یک نمونه از ساختار lion را بهش اختصاص دادیم :\n1a = lion{} اختصاص یک نمونه از ساختار lion به متغیر a که با تایپ lion بود موفقیت آمیز بود زیرا ما برای lion متدهای مورد مربوط animal را که breathe و walk بود پیاده سازی کردیم. این مفهوم کاملا شبیه به ducking typing هستش که در بالا گفتیم. یک شیر می تواند نفش بکشد و راه برود از این رو او یک حیوان است.\nتوجه کنید اگر شما متد جدیدی را اضافه یا کم کنید و همچنین اگر تغییر ایجاد کنید باید این تغییرات برروی اشیایی که با اینترفیس شما در ارتباط هست صورت بگیرید.\nبه عنوان مثال شما اگر به اینترفیس animal یک متد جدیدی اضافه کنید حتما باید برای ساختار lion باید پیاده سازی کنید.\n2.4.2 اینترفیس ها بطور ضمنی (implicitly) پیاده سازی می شود # برای اینترفیس هیچ حالت صریح (explicit) هنگام تعریف وجود ندارد و همه چی بصورت ضمنی است و تا زمانیکه یک اینترفیس برای یک شی (ساختار) متدهایش پیاده سازی نشود هیچ کاربردی نخواهد داشت.\nتوجه کنید هیچ حالت صریحی وجود ندارد که بگوید شما تمامی متدهای اینترفیس animal را برای ساختار lion پیاده سازی کردید یا خیر و فقط در زمان کامپایل اگر ایرادی وجود داشته باشد کامپایلر به شما خطا می دهد. و البته IDE هایی مانند: Goland , Vscode به شما هنگام نوشتن کد در خصوص این مورد کمک میکنند قبل از کامپایل متوجه خطاهای مرتبط با پیاده سازی اینترفیس شوید.\nخب بزارید یک مثال پیچیده برای اینترفیس animal بزنیم و یک شی (ساختار) دیگر به نام dog اضافه کنیم و متدهای اینترفیس animal را برای این شی پیاده سازی کنیم.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type animal interface { 6 breathe() 7 walk() 8} 9 10type lion struct { 11 age int 12} 13 14func (l lion) breathe() { 15 fmt.Println(\u0026#34;Lion breathes\u0026#34;) 16} 17 18func (l lion) walk() { 19 fmt.Println(\u0026#34;Lion walk\u0026#34;) 20} 21 22type dog struct { 23 age int 24} 25 26func (l dog) breathe() { 27 fmt.Println(\u0026#34;Dog breathes\u0026#34;) 28} 29 30func (l dog) walk() { 31 fmt.Println(\u0026#34;Dog walk\u0026#34;) 32} 33 34func main() { 35 var a animal 36 37 a = lion{age: 10} 38 a.breathe() 39 a.walk() 40 41 a = dog{age: 5} 42 a.breathe() 43 a.walk() 44} 1$ go run main.go 2Lion breathes 3Lion walk 4Dog breathes 5Dog walk در مثال بالا ما یک ساختار با نام dog تعریف کردیم و سپس متدهای animal را برای ساختار dog پیاده سازی کردیم و در نهایت ساختار dog را به متغیر اینترفیس a اختصاص دادیم. همانطور که میبینیم dog هم همانند lion نفس میکشد و راه می رود.\nتوجه کنید در بالا ما برای ۲ تا شی lion و dog یک وجه مشترک به نام animal به همراه رفتار مشترک تعریف کردیم که به اینکار پلی مورفیسم می گویند و یکی از عناوین پرکاربرد در شی گرایی می باشد که در بخش شی گرایی زبان گو بیشتر می پردازیم. دو نکته مهم در خصوص اینترفیس :\nاینترفیس ها فقط زمان کامپایل مشخص می شود که برای اشیا به درستی پیاده سازی شده اند یا خیر و اگر فرضا ما برای ساختار lion در کد بالا متد walk را حذف کنیم با خطای زیر رو به رو خواهیم شد : 1cannot use lion literal (type lion) as type animal in assignment: ورود و خروجی های هر متدی که پیاده سازی می کنید برای اشیا (ساختارها) بستگی به تعریف ضمنی متد داخل اینترفیس دارد و اگر شما متدی را داخل اینترفیس تغییر دهید حتما باید آن متد در اشیایی که قبلا پیاده سازی شده تغییر یابد. حالا فرض کنید ما برای اینترفیس animal یک متد جدیدی به نام speed تعریف کردیم که این متد به عنوان خروجی مقداری با تایپ int بر میگرداند:\n1type animal interface { 2 breathe() 3 walk() 4 speed() int 5} حالا ساختار lion باید متد speed را مانند کد زیر پیاده سازی کرده است :\n1func (l lion) speed() اگر دقت کنید ما داخل اینترفیس animal گفتیم متد speed یک مقدار خروجی از نوع int دارد ولی ما برای ساختار lion متد speed را بدون خروجی نوشتیم. اتفاقی که می افتد هنگام کامپایل با خطای زیر مواجه خواهیم شد :\n1cannot use lion literal (type lion) as type animal in assignment: 2 lion does not implement animal (wrong type for speed method) 3 have speed() 4 want speed() int با توجه به اتفاقی که افتاد ما نتیجه میگریم متدی که داخل اینترفیس به همراه ورودی و خروجی اضافه می شود باید به همان شکل برای ساختارهامون پیاده سازی کنیم.\n2.4.3 استفاده از اینترفیس به عنوان پارامتر ورودی تابع # توابع تایپ های اینترفیس را به عنوان ورودی قبول می کنند و هر ساختار یا تایپی متدهای اینترفیس را پیاده سازی کرده باشد می تواند به عنوان پارامتر ورودی به تابع ارسال شود.\nبه عنوان مثال ما در کد زیر ۲ تا تابع داریم به نام های callBreathe و callWalk که به عنوان ورودی اینترفیس animal را قبول می کند و ما یک ۲ نمونه از ساختارهای lion و dog را که متدهای اینترفیس animal را پیاده سازی کرده اند را به این ۲ تابع پاس دادیم.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type animal interface { 6\tbreathe() 7\twalk() 8} 9 10type lion struct { 11 age int 12} 13 14func (l lion) breathe() { 15\tfmt.Println(\u0026#34;Lion breathes\u0026#34;) 16} 17 18func (l lion) walk() { 19\tfmt.Println(\u0026#34;Lion walk\u0026#34;) 20} 21 22type dog struct { 23 age int 24} 25 26func (l dog) breathe() { 27\tfmt.Println(\u0026#34;Dog breathes\u0026#34;) 28} 29 30func (l dog) walk() { 31\tfmt.Println(\u0026#34;Dog walk\u0026#34;) 32} 33 34func main() { 35\tl := lion{age: 10} 36\tcallBreathe(l) 37\tcallWalk(l) 38 39\td := dog{age: 5} 40\tcallBreathe(d) 41\tcallWalk(d) 42} 43 44func callBreathe(a animal) { 45\ta.breathe() 46} 47 48func callWalk(a animal) { 49\ta.breathe() 50} 1$ go run main.go 2Lion breathes 3Lion walk 4Dog breathes 5Dog walk 2.4.4 چرا اینترفیس؟ # شاید برای شما این سوال پیش بیاد چرا باید از اینترفیس استفاده کنیم و مزایای آن چیست؟ ما در زیر مزایای استفاده از اینترفیس و علت اینکه چرا باید از اینترفیس باید استفاده کنیم را توضیح خواهیم داد.\nاینترفیس به ما در نوشتن کدهای ماژولارتر و جداشده تر بین بخش های مختلف کد کمک می کند و همچنین می تواند باعث کاهش وابستگی بین بخش های مختلف کد شود. بزارید یک مثال کاربردی بزنیم :\nفرض کنید شما یک برنامه نوشتید که یک لایه دیتابیس دارد که دیتاها با توجه به کانفیگ دیتابیس های mongodb یا arangodb در یکی از این دو دیتابیس ذخیره شود. حالا اگر ما بیایم در لایه دیتابیس یک اینترفیس قرار دهیم و متدهایش برروی دیتابیس ها که عملیاتی انجام دهد را برای هر دو دیتابیس پیاده سازی کنیم. حالا اگر برنامه ای که نوشتیم با استفاده از اینترفیس با دیتابیس تعامل داشته باشد هرگز متوجه نمی شود که چه نوع دیتابیس در برنامه استفاده شده است. مثلا اگر ما بیایم داخل کانفیگ پروژه تنظیمات arangodb را به mongodb تغییر دهیم بدون هیچ تغییری در لایه برنامه می توانیم به واسطه اینترفیسی که قرار دادیم با دیتابیس mongodb تعامل داشته باشیم.\nاز اینترفیس ها می توان برای پیاده سازی مفهوم پلی مورفیسم در زمان اجرا استفاده کرد. که به این مفهوم RunTime Polymorphism می گویند. بزارید یک مثال برای توضیح فوق بزنیم :\nفرض کنید کشورهای مختلف روش های مختلفی برای محاسبه مالیات دارند که شما می توانید با استفاده از یک اینترفیس این عملیات محاسبه را انجام دهید.\n1type taxCalculator interface{ 2 calculateTax() 3} در بالا ما یک اینترفیس با نام taxCalculator داریم که یک متد به نام calculateTax جهت محاسبه مالیات دارد. حالا ما باید به ازای هر کشور یک ساختار داشته باشیم که این ساختارها باید متد calculateTax را با توجه شیوه محاسباتی خود پیاده سازی کرده باشند.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type taxSystem interface { 6 calculateTax() int 7} 8type indianTax struct { 9 taxPercentage int 10 income int 11} 12func (i *indianTax) calculateTax() int { 13 tax := i.income * i.taxPercentage / 100 14 return tax 15} 16type singaporeTax struct { 17 taxPercentage int 18 income int 19} 20func (i *singaporeTax) calculateTax() int { 21 tax := i.income * i.taxPercentage / 100 22 return tax 23} 24type usaTax struct { 25 taxPercentage int 26 income int 27} 28func (i *usaTax) calculateTax() int { 29 tax := i.income * i.taxPercentage / 100 30 return tax 31} 32func main() { 33 indianTax := \u0026amp;indianTax{ 34 taxPercentage: 30, 35 income: 1000, 36 } 37 singaporeTax := \u0026amp;singaporeTax{ 38 taxPercentage: 10, 39 income: 2000, 40 } 41 42 43 taxSystems := []taxSystem{indianTax, singaporeTax} 44 totalTax := calculateTotalTax(taxSystems) 45 46 47 fmt.Printf(\u0026#34;Total Tax is %d\\n\u0026#34;, totalTax) 48} 49 50func calculateTotalTax(taxSystems []taxSystem) int { 51 totalTax := 0 52 for _, t := range taxSystems { 53 totalTax += t.calculateTax() // در اینجا runtime polymorphism رخ می دهد 54 } 55 return totalTax 56} 1$ go run main.go 2Total Tax is 300 در خط زیر RunTime Polymorphism رخ داده است.\n1 totalTax += t.calculateTax() //This is where runtime polymorphism happens 2.4.5 استفاده از اشاره گر هنگام پیاده سازی اینترفیس # متدها تایپ های گیرنده خود را به دو صورت اشاره گر یا مقدار می تواند دریافت کند. در بالا مثال animal ما داشتیم با حالت گیرنده مقدار بود. حالا می خواهیم بصورت گیرنده اشاره گر تعریف کنیم.\n2 نکته با توجه مثالی که خواهیم زد وجود دارد :\nاگر شما برای یک تایپی تمامی متدهای اینترفیس را بصورت گیرنده مقدار تعریف کرده باشید هر دو متغیری که یک نمونه از تایپ را بصورت اشاره گر و بدون اشاره گرده تعریف کرده باشد می تواند به اینترفیس animal انتصاب شود و بدون هیچ مشکلی کار کند.\nاگر شما برای یک تایپی تمامی متدهای اینترفیس را بصورت گیرنده اشاره گر تعریف کرده باشید فقط متغیری که یک نمونه از تایپ که با اشاره گر تعریف کرده باشد می تواند به اینترفیس انتصاب یابد.\nمثال با حالت اولی که توضیح دادیم :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type animal interface { 6\tbreathe() 7\twalk() 8} 9 10type lion struct { 11\tage int 12} 13 14func (l lion) breathe() { 15\tfmt.Println(\u0026#34;Lion breathes\u0026#34;, l) 16} 17 18func (l lion) walk() { 19\tfmt.Println(\u0026#34;Lion walk\u0026#34;, l) 20} 21 22func main() { 23\tvar a animal 24 25\ta = lion{age: 10} 26\ta.breathe() 27\ta.walk() 28 29\ta = \u0026amp;lion{age: 5} 30\ta.breathe() 31\ta.walk() 32} 1$ go run main.go 2Lion breathes {10} 3Lion walk {10} 4Lion breathes {5} 5Lion walk {5} در بالا ما یک نمونه از ساختار lion با اشاره گر ایجاد کردیم و مقدار age را ۵ قرار دادیم و به اینترفیس animal انتصابش کردیم و بدون هیچ مشکلی کار کرد.\nحالا برای حالت دوم به مثال زیر توجه کنید :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type animal interface { 6\tbreathe() 7\twalk() 8} 9 10type lion struct { 11\tage int 12} 13 14func (l *lion) breathe() { 15\tfmt.Println(\u0026#34;Lion breathes\u0026#34;) 16} 17 18func (l *lion) walk() { 19\tfmt.Println(\u0026#34;Lion walk\u0026#34;) 20} 21 22func main() { 23\tvar a animal 24 25\ta = lion{age: 10} 26\ta.breathe() 27\ta.walk() 28 29\ta = \u0026amp;lion{age: 5} 30\ta.breathe() 31\ta.walk() 32} 1$ go run main.go 2cannot use lion literal (type lion) as type animal in assignment: 3 lion does not implement animal (breathe method has pointer receiver) در بالا خطایی که رخ داده گفته شده شما فقط می توانید یک نمونه از ساختار lion را فقط با اشاره گر استفاده کنید.\n2.4.6 پیاده سازی اینترفیس برای تایپ های غیر ساختار # همانطور که قبلا گفتیم شما می توانید برای هر تایپی متد تعریف کنید و در اینجا هم می توانید متدهای یک اینترفیس را برای هر تایپی پیاده سازی کنید.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type animal interface { 6\tbreathe() 7\twalk() 8} 9 10type cat string 11 12func (c cat) breathe() { 13\tfmt.Println(\u0026#34;Cat breathes\u0026#34;) 14} 15 16func (c cat) walk() { 17\tfmt.Println(\u0026#34;Cat walk\u0026#34;) 18} 19 20func main() { 21\tvar a animal 22 23\ta = cat(\u0026#34;smokey\u0026#34;) 24\ta.breathe() 25\ta.walk() 26} 1$ go run main.go 2Cat breathes 3Cat walk در بالا ما یک تایپ با نام cat از نوع رشته تعریف کردیم و سپس متدهای اینترفیس animal را برای این تایپ پیاده سازی کردیم.\n2.4.7 پیاده سازی چندتایی اینترفیس برای تایپ # شما می توانید برای تایپ های خود چندین اینترفیس مختلف استفاده کنید و متدهای این اینترفیس ها را پیاده سازی کنید.\nدر کد زیر ما ۲ تا اینترفیس animal و mammal داریم که داخل اینترفیس mammal یک متد با نام feed وجود دارد حالا می خواهیم برای ساختار lion از این اینترفیس استفاده کنیم.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type animal interface { 6 breathe() 7 walk() 8} 9 10type mammal interface { 11 feed() 12} 13 14type lion struct { 15 age int 16} 17func (l lion) breathe() { 18 fmt.Println(\u0026#34;Lion breathes\u0026#34;) 19} 20func (l lion) walk() { 21 fmt.Println(\u0026#34;Lion walk\u0026#34;) 22} 23func (l lion) feed() { 24 fmt.Println(\u0026#34;Lion feeds young\u0026#34;) 25} 26func main() { 27 var a animal 28 l := lion{} 29 a = l 30 a.breathe() 31 a.walk() 32 var m mammal 33 m = l 34 m.feed() 35} 1$ go run main.go 2Lion breathes 3Lion walk 4Lion feeds young 2.4.8 مقدار صفر یا پیش فرض اینترفیس # اینترفیس هم همانند سایر تایپ ها یک مقدار پیش فرض دارد که این مقدار پیش فرض nil هستش.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4type animal interface { 5 breathe() 6 walk() 7} 8 9func main() { 10 var a animal 11 fmt.Println(a) 12} 1$ go run main.go 2nil 2.4.9 بدنه اینترفیس # اینترفیس دارای یک بدنه اس که از دو بخش تشکیل شده تایپ و مقدار وقتی شما یک تایپی را به اینترفیس منتصب می کنید در بخش مقدار نوع و مقدار تایپی که منتصب کردید به اینترفیس در دسترس است.\ngraph TD A[Interface Variable] --\u003e B(Interface Type) \u0026 C(Interface Value) C --\u003e D(تایپ داخلی) \u0026 E(مقدار داخلی) اگر بخواهیم با توجه به مثال ساختار lion توجه کنیم به شکل زیر می شود :\ngraph TD A[Interface Variable] --\u003e B(Interface Type) \u0026 C(Interface Value) C --\u003e D(lion) \u0026 E(\"{age: 10}\") حالا در زیر مثالی زدیم با استفاده از T% و v% نوع و مقدار را می توانید چاپ کنیم.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type animal interface { 6 breathe() 7 walk() 8} 9 10type lion struct { 11 age int 12} 13 14func (l lion) breathe() { 15 fmt.Println(\u0026#34;Lion breathes\u0026#34;) 16} 17 18func (l lion) walk() { 19 fmt.Println(\u0026#34;Lion walk\u0026#34;) 20} 21 22func main() { 23 var a animal 24 a = lion{age: 10} 25 fmt.Printf(\u0026#34;Underlying Type: %T\\n\u0026#34;, a) 26 fmt.Printf(\u0026#34;Underlying Value: %v\\n\u0026#34;, a) 27} 1$ go run main.go 2Concrete Type: main.lion 3Concrete Value: {10} 2.4.10 دسترسی به مقادیر داخلی اینترفیس # برای اینکه بتوانید به مقادیر داخلی اینترفیس دسترسی پیدا کنید ۲ تا روش وجود دارد :\nبا استفاده از Type Assertion با استفاده از Switch 2.4.10.1 با استفاده از Type Assertion # برای اینکه بتوانید به مقدار داخلی یک اینترفیس دسترسی پیدا کنید باید جلوی متغیر از نوع اینترفیس یک نقطه . و در ادامه داخل پرانتز تایپ مورد نظری که قصد داری تشخیص دهید را باید قرار دهید.\n1val, ok := i.({type}) در بالا زمانیکه Type Assertion انجام می دهید ۲ تا متغیر دارید که اولیش مقداره و دومیش تایید می کند تایپی که به اینترفیس دادید همان است (منظور متغیر ok هستش که مقدارش از نوع bool هستش)\nاگر هنگام Type Assertion شما وضعیت متغیر ok را بررسی نکنید با خطای panic مواجه خواهید شد. 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type animal interface { 6\tbreathe() 7\twalk() 8} 9 10type lion struct { 11\tage int 12} 13 14func (l lion) breathe() { 15\tfmt.Println(\u0026#34;Lion breathes\u0026#34;) 16} 17 18func (l lion) walk() { 19\tfmt.Println(\u0026#34;Lion walk\u0026#34;) 20} 21 22type dog struct { 23\tage int 24} 25 26func (d dog) breathe() { 27\tfmt.Println(\u0026#34;Dog breathes\u0026#34;) 28} 29 30func (d dog) walk() { 31\tfmt.Println(\u0026#34;Dog walk\u0026#34;) 32} 33 34func main() { 35\tvar a animal 36 37\ta = lion{age: 10} 38\tprint(a) 39 40} 41 42func print(a animal) { 43\tl, ok := a.(lion) 44\tif ok { 45\tfmt.Printf(\u0026#34;Age: %d\\n\u0026#34;, l.age) 46\t} 47} 1$ go run main.go 2Age: 10 در بالا ما تایپ lion را به اینترفیس animal پاس دادیم و بررسی کردیم آیا تایپ lion از نوع تایپ داخلی اینترفیس animal هست یا خیر.\n1l := a.(lion) 2.4.10.2 با استفاده از Switch # شما با استفاده از switch می توانید تایپ اینترفیس را تشخیص دهید.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type animal interface { 6\tbreathe() 7\twalk() 8} 9 10type lion struct { 11\tage int 12} 13 14func (l lion) breathe() { 15\tfmt.Println(\u0026#34;Lion breathes\u0026#34;) 16} 17 18func (l lion) walk() { 19\tfmt.Println(\u0026#34;Lion walk\u0026#34;) 20} 21 22type dog struct { 23\tage int 24} 25 26func (d dog) breathe() { 27\tfmt.Println(\u0026#34;Dog breathes\u0026#34;) 28} 29 30func (d dog) walk() { 31\tfmt.Println(\u0026#34;Dog walk\u0026#34;) 32} 33 34func main() { 35\tvar a animal 36 37\tx = lion{age: 10} 38\tprint(x) 39 40} 41 42func print(a animal) { 43\tswitch v := a.(type) { 44\tcase lion: 45\tfmt.Println(\u0026#34;Type: lion\u0026#34;) 46\tcase dog: 47\tfmt.Println(\u0026#34;Type: dog\u0026#34;) 48\tdefault: 49\tfmt.Printf(\u0026#34;Unknown Type %T\u0026#34;, v) 50\t} 51} 1$ go run main.go 2Type: lion 2.4.11 اینترفیس خالی # شما می توانید اینترفیس بصورت خالی و بدون متد در هرجایی از کد خود استفاده کنید و هر تایپی را می توانید به این اینترفیس انتصاب دهید. به عنوان مثال در زیر یک تابع نوشتیم که به عنوان پارامتر ورودی یک اینترفیس خالی می گیرد و مقدار این پارامتر را چاپ می کند.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 test(\u0026#34;thisisstring\u0026#34;) 7 test(\u0026#34;10\u0026#34;) 8 test(true) 9} 10 11func test(a interface{}) { 12 fmt.Printf(\u0026#34;(%v, %T)\\n\u0026#34;, a, a) 13} 1$ go run main.go 2(thisisstring, string) 3(10, string) 4(true, bool) توجه کنید اینترفیس خالی خیلی کاربردی هستش و usecase های مختلفی دارد.\n"},{"id":28,"href":"/chapter-2/type-embedding/","title":"2.5 جاسازی تایپ (type embedding)","section":"فصل دوم: مکانیزم های زبان","content":"در زبان گو برای ساختار و اینترفیس امکان جاسازی تایپ وجود دارد. یعنی شما می توانید یک ساختار یا یک اینترفیس را داخل ساختار دیگر جاسازی کنید و یا داخل اینترفیس یک اینترفیس دیگر را جاسازی کنید.\n1 2type animal interface { 3 breathe() 4 walk() 5} 6 7type human interface { 8 animal 9 speak() 10} 11 12type base struct { 13 num int 14} 15 16type container struct { 17\thuman 18 base 19 str string 20} در بالا ما اینترفیس animal را در اینترفیس human جاسازی کردیم و در ادامه داخل ساختار container اینترفیس human و ساختار base را جاسازی کردیم.\nبا اینکار ما به متدهای اینترفیس human و animal و همچنین به فیلدهای ساختار base دسترسی داریم و می توانیم از متدها و فیلدهای جاسازی با استفاده از ساختار container استفاده کنیم.\nتوجه کنید شما نمی توانید یک ساختار را داخل اینترفیس جاسازی کنید. 2.5.1 جاسازی ساختار # شما می توانید هر چندتا ساختاری که دارید داخل یک ساختاری جاسازی و به هرکدام از فیلدهای ساختارهای جاسازی شده دسترسی دارید.\nبه مثال زیر توجه کنید :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type base struct { 6 num int 7} 8 9func (b base) describe() string { 10 return fmt.Sprintf(\u0026#34;base with num=%v\u0026#34;, b.num) 11} 12 13type container struct { 14 base 15 str string 16} 17 18func main() { 19 20 co := container{ 21 base: base{ 22 num: 1, 23 }, 24 str: \u0026#34;some name\u0026#34;, 25 } 26 27 fmt.Printf(\u0026#34;co={num: %v, str: %v}\\n\u0026#34;, co.num, co.str) 28 29 fmt.Println(\u0026#34;also num:\u0026#34;, co.base.num) 30 31 fmt.Println(\u0026#34;describe:\u0026#34;, co.describe()) 32 33 type describer interface { 34 describe() string 35 } 36 37 var d describer = co 38 fmt.Println(\u0026#34;describer:\u0026#34;, d.describe()) 39} 1$ go run main.go 2co={num: 1, str: some name} 3also num: 1 4describe: base with num=1 5describer: base with num=1 2.5.1.1 جاسازی اینترفیس در ساختار # همانطور که گفتیم یک اینترفیس می تواند داخل یک ساختار جاسازی شود و همه متدهای اینترفیس به واسطه ساختار مورد قابل دسترس است و می توانید هر یک از متدها را استفاده کنید.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type animal interface { 6 breathe() 7 walk() 8} 9 10type dog struct { 11 age int 12} 13 14func (d dog) breathe() { 15 fmt.Println(\u0026#34;Dog breathes\u0026#34;) 16} 17 18func (d dog) walk() { 19 fmt.Println(\u0026#34;Dog walk\u0026#34;) 20} 21 22type pet1 struct { 23 a animal 24 name string 25} 26 27type pet2 struct { 28 animal 29 name string 30} 31 32func main() { 33 d := dog{age: 5} 34 p1 := pet1{name: \u0026#34;Milo\u0026#34;, a: d} 35 36 fmt.Println(p1.name) 37 // p1.breathe() 38 // p1.walk() 39 p1.a.breathe() 40 p1.a.walk() 41 42 p2 := pet2{name: \u0026#34;Oscar\u0026#34;, animal: d} 43 fmt.Println(p1.name) 44 p2.breathe() 45 p2.walk() 46 p1.a.breathe() 47 p1.a.walk() 48} 1$ go run main.go 2Milo 3Dog breathes 4Dod walk 5 6Oscar 7Dog breathes 8Dog walk 9Dog breathes 10Dog walk 2.5.2 جاسازی اینترفیس # شما همانند ساختارها می توانید اینترفیس ها را جاسازی کنید و فقط کافیه اینترفیس ها را داخل دیگر اینترفیس ها جاسازی کنید تا متدهای اینترفیس های جاسازی شده دسترسی داشته باشید.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type animal interface { 6\tbreathe() 7\twalk() 8} 9 10type human interface { 11\tanimal 12\tspeak() 13} 14 15type employee struct { 16\tname string 17} 18 19func (e employee) breathe() { 20\tfmt.Println(\u0026#34;Employee breathes\u0026#34;) 21} 22 23func (e employee) walk() { 24\tfmt.Println(\u0026#34;Employee walk\u0026#34;) 25} 26 27func (e employee) speak() { 28\tfmt.Println(\u0026#34;Employee speaks\u0026#34;) 29} 30 31func main() { 32\tvar h human 33 34\th = employee{name: \u0026#34;John\u0026#34;} 35\th.breathe() 36\th.walk() 37\th.speak() 38} 1$ go run main.go 2Employee breathes 3Employee walk 4Employee speaks یکی دیگه از مثال هایی که می توانیم بزنیم پکیج io اینترفیس ReadWriter هستش که ۲ تا اینترفیس Reader و Writer داخل این اینترفیس جاسازی شده است.\n"},{"id":29,"href":"/chapter-2/error-handling/","title":"2.6 مدیریت خطاها","section":"فصل دوم: مکانیزم های زبان","content":"در این بخش قصد به مقوله مدیریت خطاها در زبان گو بپردازیم و اینکه چطور می توانید خیلی ساده خطاها را مدیریت کنید. مدیریت خطا در زبان گو با سایر زبان ها متفاوت هست و شما با چیزی به نام try-catch یا try-except سروکار ندارید.\nمدیریت خطاها در زبان گو به دو روش صورت می گیرد :\nبا استفاده از پیاده سازی اینترفیس error که یک روش مرسوم جهت مدیریت و نمایش خطا می باشد. با استفاده از panic/recover که در فصل اول توضیح دادیم 2.6.1 مدیریت خطا با اینترفیس error # روش زبان گو برای مقابله با خطا این است که به صراحت شما خطا را به عنوان خروجی تابع برگردانید. برای اینکه ساده بفهمید منظورم را بهتره بگم شما اگر میخواهید خطای هر تابع را مدیریت کنید کافیه اینترفیس error به خروجی تابع بزارید.\nhttps://pkg.go.dev/builtin#error\n1type error interface { 2 Error() string 3} به مثال زیر توجه کنید :\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;os\u0026#34; 6) 7 8func main() { 9\tfile, err := os.Open(\u0026#34;non-existing.txt\u0026#34;) 10\tif err != nil { 11\tfmt.Println(err) 12\t} else { 13\tfmt.Println(file.Name() + \u0026#34;opened succesfully\u0026#34;) 14\t} 15} 1$ go run main.go 2open non-existing.txt: no such file or directory در بالا ما از تابع Open در پکیج برای بازکردن فایل استفاده کردیم. اگر دقت کنید این تابع ۲ تا خروجی دارد یکی ساختار File هست و دیگری خطا هست. در ادامه ما با استفاده شرط آمدیم چک کردیم اینترفیس err آیا خالی است یا خیر؟ در بالا این اینترفیس خالی nil نیست و ما خطا را چاپ کردیم.\nاین یک روش مرسوم هست شما خطای هر تابعی را به این صورت بررسی کنید آیا خالی است یا خیر و در صورت وجود خطا بتوانید یک سناریو دسترسی را داشته باشید و آن را بهتر مدیریت کنید.\nدقت کنید اینترفیس error یک متد دارد به نام ()Error که این متد متن خطا را بصورت رشته بر میگرداند.\nآیا همیشه نیاز است خطاها را مدیریت کنیم؟\nشاید بپرسید آیا واقعا نیاز هست ما همیشه خطاها را مدیریت کنیم؟ در جواب این سوال می توانیم بگیم هم آره و هم خیر\nعلت اینکه میگیم آره از این بابت هست اگر خطاها را بدرستی مدیریت نکنیم احتمال اینکه با panic در هرجا مواجه شویم خیلی زیاد می شود. بخصوص خطای nil pointer . پس بهتر است تا جایی که می توانید خطاها را بدرستی مدیریت کنید و همچنین اگر جایی احتمال می دهید panic پیش میاد بهتر است از recover استفاده کنید تا پایداری برنامه را بالا ببرید. علت اینکه میگیم خیر از این بابت هست در زبان گو هیچ اجباری برای مدیریت خطاها وجود ندارد و گاهی اوقات می توانید خطاها را نادیده بگیرید یا اینکه با استفاده از ـ نادیده بگیریدش. 2.6.2 مزایای استفاده از error به عنوان یک تایپ در زبان گو # به شما این امکان را می دهد کنترل بیشتری رو خطاها داشته باشید و تو هر قدم می توانید خطاها را بررسی کنید. جلوگیری از try-catch جهت مدیریت خطا (دقت کنید در سایر زبان ها باید تا جایی که ممکن است از try-catch کمتر استفاده کنید) 2.6.3 روش های مختلف برای ایجاد یک خطا # در زبان گو شما می توانید در هرجای کد خود یک خطا با محتوای مناسب ایجاد کنید و یا اینکه برخی از خطاهای برخی از کتابخانه ها را هم پوشانی کنید.\n1. با استفاده (\u0026ldquo;متن خطا\u0026rdquo;)errors.New\n1package main 2 3import ( 4 \u0026#34;errors\u0026#34; 5 \u0026#34;fmt\u0026#34; 6) 7 8func main() { 9 sampleErr := errors.New(\u0026#34;error occured\u0026#34;) 10 fmt.Println(sampleErr) 11 } 1$ go run main.go 2error occured در بالا ما با استفاده از تابع New پکیج errors یک خطا با متن مشخص ایجاد کردیم و متغیر sampleErr از نوع اینترفیس error می باشد که می توانید در هرجای کد خود مدیریتش کنید.\n2. با استفاده از (\u0026ldquo;error is %s\u0026rdquo;, \u0026ldquo;some error message\u0026rdquo;)fmt.Errorf\nشما با استفاده از تابع Errorf در پکیج fmt می توانید یک خطا ایجاد کنید و توجه کنید این متن خطا قابل فرمت هستش و حتی شما می توانید متن خطا را داینامیک کنید.\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5) 6 7func main() { 8\tmsg := \u0026#34;database connection issue\u0026#34; 9 sampleErr := fmt.Errorf(\u0026#34;Err is: %s\u0026#34;, msg) 10 fmt.Println(sampleErr) 11} 1$ go run main.go 2Err is: database connection issue 2.6.4 ایجاد خطا پیشرفته # در مثال زیر ما قصد داریم یک خطای پیشرفته ایجاد کنیم و آن را به آسانی مدیریت کنیم.\nویژگی های خطای پیشرفته :\nدر زیر inputError یک نوع ساختار است که داخلش ۲ تا فیلد message و missingField دارد و همچنین دارای یک متد ()Error می باشد. شما می توانید به این ساختار خطای پیشرفته متدهای بیشتری اضافه کنید و همچنین گسترش دهید که به عنوان مثال ما متد getMissingFields را برای گرفتن محتوای missingField اضافه کردیم. ما با استفاده از type assertion می توانیم اینترفیس error را به inputError تبدیل کنیم. 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type inputError struct { 6 message string 7 missingField string 8} 9 10func (i *inputError) Error() string { 11 return i.message 12} 13 14func (i *inputError) getMissingField() string { 15 return i.missingField 16} 17 18func main() { 19 err := validate(\u0026#34;\u0026#34;, \u0026#34;\u0026#34;) 20 if err != nil { 21 if err, ok := err.(*inputError); ok { 22 fmt.Println(err) 23 fmt.Printf(\u0026#34;Missing Field is %s\\n\u0026#34;, err.getMissingField()) 24 } 25 } 26} 27 28func validate(name, gender string) error { 29 if name == \u0026#34;\u0026#34; { 30 return \u0026amp;inputError{message: \u0026#34;Name is mandatory\u0026#34;, missingField: \u0026#34;name\u0026#34;} 31 } 32 if gender == \u0026#34;\u0026#34; { 33 return \u0026amp;inputError{message: \u0026#34;Gender is mandatory\u0026#34;, missingField: \u0026#34;gender\u0026#34;} 34 } 35 return nil 36} 1$ go run main.go 2Name is mandatory 3Missing Field is name 2.6.5 نادیده گرفتن خطاها # شما در هرجای کد خود با استفاده از _ می توانید متغیر خطا را نادیده بگیرید و آن را مدیریت نکنید. هر چند در بالا گفتیم نادیده گرفتن خطاها عوارضی در بر دارد و ما همیشه تاکید میکنیم تا جایی که ممکن است خطاها را مدیریت کنید.\n1package main 2import ( 3 \u0026#34;fmt\u0026#34; 4 \u0026#34;os\u0026#34; 5) 6func main() { 7 file, _ := os.Open(\u0026#34;non-existing.txt\u0026#34;) 8 fmt.Println(file) 9} 1$ go run main.go 2{nil} در بالا ما خطای تابع Open را نادیده گرفتیم و مقدار file را چاپ کردیم و مقدار چاپ شده nil است چون تایپ خروجی با اشاره گر است و قطعا مقدار خالی بودش nil است و دقت کنید اگر این متغیر را به تابع دیگری پاس دهید قطعا با panic مواجه خواهید شد.\n2.6.6 هم پوشانی (Wrapping) خطا # در زبان گو شما می توانید خطا را با خطا و پیغام مشخصی هم پوشانی کنید. حالا هم پوشانی خطا چیست؟\nبزارید با یک مثال ساده توضیح دهیم فرض کنید شما تو لایه دیتابیس خود یکسری خطاها از سمت دیتابیس دریافت می کنید به عنوان مثال اگر شما سندی را در دیتابیس monogdb پیدا نکنید با خطای no documents found مواجه خواهید شد. شما در اینجا نمی توانید همان متن خطا را به کاربر نمایش دهید بلکه باید آن خطا را با یک متن خطای مناسب هم پوشانی کنید.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7type notPositive struct { 8\tnum int 9} 10 11func (e notPositive) Error() string { 12\treturn fmt.Sprintf(\u0026#34;checkPositive: Given number %d is not a positive number\u0026#34;, e.num) 13} 14 15type notEven struct { 16\tnum int 17} 18 19func (e notEven) Error() string { 20\treturn fmt.Sprintf(\u0026#34;checkEven: Given number %d is not an even number\u0026#34;, e.num) 21} 22 23func checkPositive(num int) error { 24\tif num \u0026lt; 0 { 25\treturn notPositive{num: num} 26\t} 27\treturn nil 28} 29 30func checkEven(num int) error { 31\tif num%2 == 1 { 32\treturn notEven{num: num} 33\t} 34\treturn nil 35} 36 37func checkPostiveAndEven(num int) error { 38\tif num \u0026gt; 100 { 39\treturn fmt.Errorf(\u0026#34;checkPostiveAndEven: Number %d is greater than 100\u0026#34;, num) 40\t} 41 42\terr := checkPositive(num) 43\tif err != nil { 44\treturn err 45\t} 46 47\terr = checkEven(num) 48\tif err != nil { 49\treturn err 50\t} 51 52\treturn nil 53} 54 55func main() { 56\tnum := 3 57\terr := checkPostiveAndEven(num) 58\tif err != nil { 59\tfmt.Println(err) 60\t} else { 61\tfmt.Println(\u0026#34;Givennnumber is positive and even\u0026#34;) 62\t} 63 64} 1$ go run main.go 2checkEven: Given number 3 is not an even number 2.6.7 Unwrap خطاها # در بخش بالا شما با نحوه هم پوشانی کردن آشنا شدید. اما این امکان را داریم خطاها را unwrap کنیم با استفاده از یک تابع در پکیج errors به نام Unwrap.\n1func Unwrap(err error) error منظورمان از unwrap کردن این است اگر ما یک خطایی را آمده باشیم هم پوشانی کرده باشیم با استفاده unwrap می توانیم آن خطا را ببینیم.\n1import ( 2 \u0026#34;errors\u0026#34; 3 \u0026#34;fmt\u0026#34; 4) 5type errorOne struct{} 6func (e errorOne) Error() string { 7 return \u0026#34;Error One happened\u0026#34; 8} 9func main() { 10 e1 := errorOne{} 11 e2 := fmt.Errorf(\u0026#34;E2: %w\u0026#34;, e1) 12 e3 := fmt.Errorf(\u0026#34;E3: %w\u0026#34;, e2) 13 fmt.Println(errors.Unwrap(e3)) 14 fmt.Println(errors.Unwrap(e2)) 15 fmt.Println(errors.Unwrap(e1)) 16} 1$ go run main.go 2E2: Error One happended 3Error One happended در کد بالا متغیر e2 خطای داخل ساختار e1 را هم پوشانی کرده و سپس متغیر e3 خطای متغیر e2 را هم پوشانی می کند. در نهایت با تابع Unwrap متن خطای اصلی را چاپ کردیم.\n2.6.8 بررسی دو خطا اگر برابر هستند # در زبان گو شما می توانید ۲ اینترفیس را با هم مقایسه کنید و این مقایسه به وسیله اپراتور == یا با استفاده از تابع Is در پکیج errors صورت می گیرد. اساسا ۲ تا مقوله برای این مقایسه در نظر گرفته خواهد شد :\n1func Is(err, target error) bool هر دو این اینترفیس به یک نوع تایپ منصوب شده باشند. مقدار داخلی اینترفیس باید باید برابر باشند یا اینکه هر دو (nil) باشند. 1package main 2import ( 3 \u0026#34;errors\u0026#34; 4 \u0026#34;fmt\u0026#34; 5) 6type errorOne struct{} 7func (e errorOne) Error() string { 8 return \u0026#34;Error One happended\u0026#34; 9} 10func main() { 11 var err1 errorOne 12 err2 := do() 13 if err1 == err2 { 14 fmt.Println(\u0026#34;Equality Operator: Both errors are equal\u0026#34;) 15 } 16 if errors.Is(err1, err2) { 17 fmt.Println(\u0026#34;Is function: Both errors are equal\u0026#34;) 18 } 19} 20func do() error { 21 return errorOne{} 22} 1$ go run main.go 2Equality Operator: Both errors are equal 3Is function: Both errors are equal "},{"id":30,"href":"/chapter-2/casting-vs-conversion/","title":"2.7 فرق casting با conversion","section":"فصل دوم: مکانیزم های زبان","content":" 2.7.1 conversion # conversion زمانی اتفاق می افتد که ما مقدار یک داده را به تایپ دیگری اختصاص دهیم.\nو اگر زبان هایی که Static Type هستند از این مقوله بطور ضمنی پشتیبانی می کنند ولی در زبان گو کمی متفاوت است. اگر شما بخواهید conversion انجام دهید باید بصورت دستی اینکار را انجام دهید. چون کامپایلر گو روی برخی از عناوین بطور صریح در نظر میگیرد.\n2.7.2 type casting # در زبان گو چیزی به نام type casting بطور کلی وجود ندارد. پس بهتره در خصوص این مورد داخل داکیومنت ها یا سایت های مختلف نگردید. برای درک بهتر این موضوع بهتره https://go.dev/ref/spec#Conversions را مطالعه کنید.\n2.7.3 مثال conversion # در زیر یک مثال در خصوص conversion زدیم تا با این مقوله آشنا شوید :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 7\tvar totalsum int = 846 8\tvar number int = 19 9\tvar avg float32 10 11\tavg = float32(totalsum) / float32(number) 12 13\tfmt.Printf(\u0026#34;Average = %f\\n\u0026#34;, avg) 14} 1$ go run main.go 2Average = 44.526318 "},{"id":31,"href":"/chapter-3/","title":"فصل سوم: همزمانی (concurrency)","section":"صفحه اصلی","content":"در این فصل به صورت عمیق به مباحث همزمانی در زبان گو پرداخته شده است که شامل عناوین زیر می‌باشد.\n۳.۱ آشنایی با مبحث همزمانی. ۳.۲ گوروتین چیست. ۳.۳ کالبدشکافی پکیج sync و تشریح انواع و توابع کاربردی آن برای مباحث همگام‌سازی همزمانی. ۳.۴ آشنایی با پکیج atomic و کاربردهای آن. ۳.۵ آشنایی با Data Race و روش‌های پیشگیری از آن. ۳.۶ کانال‌ها و روش‌ اشتراک‌گذاری داده از طریق آن. ۳.۷ آشنایی با کلید‌واژه select و بررسی کاربردهای متنوع آن. ۳.۸ پکیج context و اهمیت آن. ۳.۹ تکنیک‌های مورد استفاده در همزمانی. ۳.۱۰ الگوهای متداول همزمانی و کاربردهای آن. "},{"id":32,"href":"/chapter-3/go-concurrency/","title":"3.1 آشنایی با همزمانی","section":"فصل سوم: همزمانی (concurrency)","content":"\nنرم‌افزارهای بزرگ به منظور توسعه راحت‌تر و قابلیت نگهداری بیشتر و همچنین پرهیز از تکرار از ده‌ها زیر برنامه کوچک‌تر تشکیل می‌شوند که به آنها توابع می‌گوییم و تمامی این زیربرنامه‌های کوچک در کنار هم اما به صورت مستقل عملکرد کلی برنامه بزرگتر را شکل می‌دهند. به عنوان مثال یک وب سرور درخواست‌های ارسال شده از سمت مرورگرها را مدیریت می کند و در پاسخ صفحات وب HTML را آماده کرده و ارائه می‌دهد و هر در خواست از طریق فراخوانی چندین برنامه کوچک رسیدگی می شود تا نتیجه را به مرورگر برگردانده شود.\nدر طول آماده‌سازی نتیجه‌‌ی هر یک از این زیربرنامه‌ها، به دلایل گوناگون از جمله تاخیر(های) شبکه، IO و \u0026hellip; اجرای زیربرنامه‌ها برای مدتی هرچند کوتاه متوقف می‌شود و این وقفه‌ها، زمان پاسخگویی نرم‌افزارها را طولانی‌تر می‌کنند؛ گاهی‌اوقات اولویت ترتیب اجرا و وابستگی/استقلال زیربرنامه‌ها، به توسعه‌دهنده این اجازه را می‌دهد که اجرای بعضی از زیربرنامه‌ها را از حالت «صف/ترتیبی» به حالت «موازی» تغییر دهد، لذا به منظور استفاده بهینه‌ از منابع و افزایش عملکرد کلی نرم‌افزار از مقوله‌ای به نام همزمانی استفاده می کنند.\nیکی از نقاط قوت در زبان Go سهولت و امنیت استفاده از همزمانی با کمک گوروتین و کانال‌هاست که در ادامه‌ی این فصل به‌طور جامع، مباحث مربوط به آن را بررسی کرده و روش پیاده‌سازی همزمانی در برنامه‌های زبان Go را آموزش خواهیم داد.\n۳.۱.۱ فرق بین همزمانی (concurrency) و موازی (parallelism) # موازی‌سازی (parallelism) یعنی چندین فرآیند به‌طور همزمان توسط چند threads یا به طور دقیق‌تر هسته پردازشی انجام شود و این هسته‌ها می‌توانند از طریق حافظه اشتراکی با هم ارتباط برقرار کنند و در نهایت نتایج فرآیندها پس از پایان با هم ترکیب می‌شوند. لذا داشتن حداقل دو یا چند هسته پردازش فیزیکی از الزامات پیاده‌سازی موازی است.\nدر مقابل برنامه‌های همزمان الزاماً به‌صورت موازی اجرا نمی‌شوند و بیشتر در مورد ساختار یک برنامه است تا شیوه دقیق اجرای آن برنامه یا زیربرنامه. همزمانی به گونه‌ای است که دو یا چند کار مختلف ممکن است به طور همزمان در حال پیشرفت و انجام باشند. و در نهایت این فرآیندهای همزمان به نتایج مختلفی ختم می شوند.\nحال می‌خواهیم با یک مثال ملموس این دو مبحث را باز کنیم تا به درکی دقیق‌تر از تفاوت این‌دو نایل آییم.\nتصور کنید که برنامه بزرگ ما یک کافی‌شاپ است که صفی از مشتریان سفارش خود را داده و منتظر دریافت آن می‌شوند.\nهمانطور که از تصویر بالا متوجه می‌شوید مشتری دوم تا پایان آماده‌سازی سفارش مشتری اول باید منتظر بماند لذا به منظور بالا بردن کارایی کلی سیستم می‌توان از پردازش موازی بهره برد به این منظور با استخدام یک فرد دیگر و یک دستگاه قهوه سازی دیگر پردازش مشتریان را به صورت موازی انجام خواهیم داد.\nچنانچه پیشتر هم گفته شد ما با محدودیت منابع روبرو هستیم و برای بالا بردن تعداد پردازش‌های موازی نیازمند خرید دستگاه قهوه ساز جدید و استخدام نیروی جدید هستیم. تا به اینجا هدف این بود که مشکل انتظار طولانی مدت مشتریان در صف را از طریق پردازش موازی حل کنیم اما این کار بسیار پرهزینه است راه حل دیگری هم وجود دارد که همان همزمانی است. بدیهی است وقفه ایجاد شده برای آماده‌سازی سفارش تنها محدود به دستگاه قهوه‌ساز نیست و بخشی از آن مربوط به زمان سپری شده برای دریافت سفارش از مشتریان توسط باریستا و مراجعه به دستگاه برای آماده‌سازی آن می‌شود لذا می‌توان با استخدام یک نیروی جدید بدون خرید دستگاه قهوه‌ساز جدید سفارش مشتریان را به صورت جداگانه پردازش کرده و به‌جای صف سفارش یک صف انتظار آماده‌سازی تشکیل داد به این ترتیب مدت زمان انتظار افراد برای دریافت سفارش کوتاه تر شده و عملکر کلی سیستم افزایش می‌یابد.\nالبته هیچ چیز ما را محدود به پردازش سریال در حالت همزمانی نمی‌کند یعنی در صورت تشکیل صف طولانی می توانیم عملکرد موازی را اینجا هم اعمال کنیم به تصویر پایین دقت کنید.\nهمانطور که مشاهده می‌شود در پردازش همزمان ما با تغییر ساختار به صورت موازی یا غیرموازی عملکر کلی سیستم را افزایش داده‌ایم.\nنکته: تا به اینجا بارها برروی عملکر کلی سیستم تأکید نموده‌ایم. این مسئله از آنجا حائز اهمیت است که خواننده باید به درکی درست از مقوله همزمانی برسد. ما در همزمانی سرعت پردازش یک درخواست را افزایش نمی‌دهیم در حقیقت به دلیل پیچیده‌تر شدن پیاده‌سازی و روند اجرا زمان پردازش یک درخواست منحصر به فرد طولانی‌تر هم می‌شود اما آنچه در مبحث همزمانی بهبود می‌یابد عملکر کلی سیستم است. لذا استفاده از همزمانی تنها در صورتی می‌تواند به بهبود کارایی یک سیستم نرم‌افزای منجر شود که صفی از درخواست‌ها تشکیل شده باشد و تأخیرات مختلف مانع از پردازش بی‌درنگ درخواست‌ها در اکثر مواقع شود لذا با استفاده از پیاده‌سازی همزمانی از منابع سیستم در زمان انتظار درخواست‌ها به صورت بهینه استفاده خواهد شد.\nزبان Go با استفاده از متغیرهای محیطی GOMAXPROCS در کنار همزمانی از موازی‌سازی (parallelism) هم استفاده می‌شود. هرچند بطور پیش فرض برنامه‌ای که با زبان گو نوشته می‌شود از تمامی هسته‌های CPU استفاده می‌کند ولی شما می‌توانید با GOMAXPROCS تعداد هسته‌ها را محدود کنید. لازم به ذکر است که در زبان Go شما به طور مستقیم نمی‌توانید اجرای موازی زیربرنامه‌ای را به کامپایلر دیکته کنید و تصمیم‌گیری در این مورد به عهده Go Runtime Scheduler است.\n"},{"id":33,"href":"/chapter-3/goroutine/","title":"3.2 گوروتین (goroutine)","section":"فصل سوم: همزمانی (concurrency)","content":"گوروتین ها را می توان به عنوان یک thread سبک در نظر گرفت که بصورت مستقلانه می تواند همزمان با سایر گوروتین های دیگر کارها را انجام دهد. و همچنین گوروتین ها می توانند به واسطه کانال داده ها را بین هم اشتراک گذاری و منتقل کنند.\nحداکثر اندازه stack یک گوروتین در زبان گو ۱ گیگابایت می باشد.\n1var maxstacksize uintptr = 1 \u0026lt;\u0026lt; 20 // enough until runtime.main sets it for real 2 3\tif newsize \u0026gt; maxstacksize || newsize \u0026gt; maxstackceiling { 4\tif maxstacksize \u0026lt; maxstackceiling { 5\tprint(\u0026#34;runtime: goroutine stack exceeds \u0026#34;, maxstacksize, \u0026#34;-byte limit\\n\u0026#34;) 6\t} else { 7\tprint(\u0026#34;runtime: goroutine stack exceeds \u0026#34;, maxstackceiling, \u0026#34;-byte limit\\n\u0026#34;) 8\t} 9\tprint(\u0026#34;runtime: sp=\u0026#34;, hex(sp), \u0026#34; stack=[\u0026#34;, hex(gp.stack.lo), \u0026#34;, \u0026#34;, hex(gp.stack.hi), \u0026#34;]\\n\u0026#34;) 10\tthrow(\u0026#34;stack overflow\u0026#34;) 11\t} در زیر با استفاده از کلمه کلیدی go یک نمونه گوروتین ایجاد کردیم و توجه کنید شما فقط توابع را می توانید همزمانی کنید.\n1go functionName(parameters) به عنوان مثال :\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;time\u0026#34; 6) 7 8func main() { 9 go start() 10 fmt.Println(\u0026#34;Started\u0026#34;) 11 time.Sleep(1 * time.Second) 12 fmt.Println(\u0026#34;Finished\u0026#34;) 13} 14 15func start() { 16 fmt.Println(\u0026#34;In Goroutine\u0026#34;) 17} 1$ go run main.go 2Started 3In Goroutine 4Finished در کد فوق ما تابع ()start را بواسطه کلمه کلیدی go داخل گوروتین قرار دادیم و این تابع بصورت مستقلانه از تابع main اجرا شد. اما این وسط یک نکته ای وجود دارد. همانطور که گفتیم تابع اصلی جهت اجرا برنامه های زبان گو تابع main می باشد و اگر شما تابعی را بواسطه گوروتین از main جدا کنید ممکن است فرآیندهای داخل تابع main زود اتمام شود و شما خروجی تابعی که داخل گوروتین گذاشتید را نبینید.\nما در کد بالا با استفاده از تابع Sleep پکیج time یک وقفه ۱ ثانیه گذاشتیم و این وقفه باعث شد تا عملیات داخل تابع ()start تمام شود و خروجی نمایش داده شود.\nخب حالا بزارید مثال فوق را بدون وقفه تست کنیم :\n1package main 2import ( 3 \u0026#34;fmt\u0026#34; 4) 5func main() { 6 go start() 7 fmt.Println(\u0026#34;Started\u0026#34;) 8 fmt.Println(\u0026#34;Finished\u0026#34;) 9} 10func start() { 11 fmt.Println(\u0026#34;In Goroutine\u0026#34;) 12} 1$ go run main.go 2Started 3Finished در خروجی بالا هرگز پیغام داخل تابع ()start چاپ نمی شود.\n1In Goroutine علت اصلی این اتفاق این است که تابع main خودش داخل یک گوروتین اجرا می شود و زمانیکه شما یک تابع دیگری را داخل گوروتین قرار می دهید تا لحظه ای که تابع برای اجرا برنامه ریزی شود برنامه اتمام می شود.\n3.2.1 گوروتین تابع main # تابع main را وقتی می توانید ایجاد کنید که نام پکیج شما main و گوروتین اصلی شما main است. همه گوروتین ها از تابع main شروع می شوند و گوروتین ها بطور همزمان باز می توانند سایر گوروتین ها را اجرا کنند.\nزمانیکه شما تابع main را فراخوانی می کنید بخش اصلی و شروع برنامه شما است. و اگر تابع main شما به هر دلیلی متوقف شود یا اتمام شود سایر گوروتین ها از بین می روند.\nگوروتین ها چیزی به نام parent یا child ندارند. زمانیکه شما یک گوروتین را اجرا می کنید این گوروتین در کنار سایر گوروتین ها اجرا می شود و کارش را انجام می دهد. زمانی کار یک گوروتین تمام می شود که تابع بازگشت (return) داشته باشد.\nبزارید یک مثال بزنیم تا ببینید چیزی به نام parent یا child برای گوروتین نداریم :\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;time\u0026#34; 6) 7 8func main() { 9 go start() 10 fmt.Println(\u0026#34;Started\u0026#34;) 11 time.Sleep(1 * time.Second) 12 fmt.Println(\u0026#34;Finished\u0026#34;) 13} 14 15func start() { 16 go start2() 17 fmt.Println(\u0026#34;In Goroutine\u0026#34;) 18} 19func start2() { 20 fmt.Println(\u0026#34;In Goroutine2\u0026#34;) 21} 1$ go run main.go 2Started 3In Goroutine 4In Goroutine2 5Finished در کد بالا داخل تابع main ما تابع start را با گوروتین اجرا کردیم و داخل تابع start تابع start2 را با گوروتین اجرا کردیم. این ۲ تابع start و start2 در کنار هم اجرا می شود و در نهایت کارشان اتمام می شود و هیچ کدام منتظر دیگری نخواهد بود.\n3.2.2 ایجاد گوروتین چندتایی # شما می توانید n تا گوروتین بطور همزمان در کنار هم اجرا کنید, در زیر یک مثال زدیم ببینید :\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;time\u0026#34; 6) 7 8func execute(id int) { 9 fmt.Printf(\u0026#34;id: %d\\n\u0026#34;, id) 10} 11 12func main() { 13 fmt.Println(\u0026#34;Started\u0026#34;) 14 for i := 0; i \u0026lt; 10; i++ { 15 go execute(i) 16 } 17 time.Sleep(time.Second * 2) 18 fmt.Println(\u0026#34;Finished\u0026#34;) 19} 1$ go run main.go 2Started 3id: 4 4id: 9 5id: 1 6id: 0 7id: 8 8id: 2 9id: 6 10id: 3 11id: 7 12id: 5 13Finished در کد فوق ما یک حلقه قرار دادیم از i صفر تا ۱۰ که داخلش تابع execute را ۱۰ بار اجرا می کند. و هربار اجرا می شود خروجی های مختلفی دارد و ترتیبی درست نخواهید علت این اتفاق این است بطور همزمان اجرا می شوند در کنار هم و هرکدام از گوروتین ها زودتر کارش تمام شود خروجی را نمایش می دهد. به همین دلیل ترتیب درستی نخواهد داشت.\n3.2.3 زمانبندی گوروتین ها # زمانیکه یک برنامه گو اجرا می شود. go runtime رشته های (threads) سیستم عامل را راه اندازی می کند که معادل تعداد CPU های logical قابل استفاده برای فرآیند فعلی است. هر یک از logical CPU ها یک هسته مجازی دارد.\n1virtual_cores = x*number_of_physical_cores در بالا x هست تعداد threads به ازای هر هسته CPU\nدر گو ما یک تابع به نام NumCPU داخل پکیج runtime داریم که می توانید تعداد logical Proccessors موجود برای برنامه گو را ببینید.\n1package main 2import ( 3 \u0026#34;fmt\u0026#34; 4 \u0026#34;runtime\u0026#34; 5) 6func main() { 7 fmt.Println(runtime.NumCPU()) 8} روی سیستم من عدد 8 را چاپ کرد یعنی سیستم من ۴ هسته که هر هسته دارای ۲ threads است. که قابل استفاده برای برنامه گو روی سیستم من می باشد.\n"},{"id":34,"href":"/chapter-3/go-sync-package/","title":"3.3 پکیج sync","section":"فصل سوم: همزمانی (concurrency)","content":"پکیج sync یکی از کاربردی ترین پکیج ها در زمینه همزمانی می باشد و یکسری تایپ و توابع برایهمگام سازی و کنترل دسترسی همزمان به داده مشترک ارائه می دهد. که پرکاربردترین آن ها :\nMutex : با استفاده از این می توانید آن بخش از داده ای که گوروتین ها بطور همزمان قصد دارند دسترسی داشته باشند را می توانید قفل کنید. RWMutex : با استفاده از این می توانید به چندین گوروتین اجازه خواندن دهید ولی فقط یک گوروتین می تواند بنویسد در یک زمان. WaitGroup: یک هماهنگ کننده گوروتین می باشد برای اینکه ترتیب عملیات ها در هنگام همزمانی رعایت شود. Once: این اجازه می دهد یک تابع حداکثر یک بار اجرا شود. Pool: مجموعه از آبجکت های موقت که امکان ذخیره و دریافت دارند بدون اینکه بخشی از حافظه را اشتغال کنند. Cond:با استفاده از Cond می توانید چندین گوروتین ایجاد کنید و اجرای فرآیند آن ها را منتظر وقوع یک رویداد بزارید. توجه کنید که پکیج sync فقط و فقط برای مدیریت و همگام سازی دسترسی های گوروتین ها به یک داده مشترک استفاده می شود. 3.3.1 Mutex # در پکیج sync یک تایپ به نام Mutex وجود دارد که به شما این امکان را می دهد دسترسی به داده مشترک را همگام سازی کنید. زمانیکه از تایپ Mutex استفاده می کند ۲ حالت دارد Lock یا Unlock. وقتی شما Lock می کند فقط و فقط یک گوروتین می تواند برروی آن بخش از داده کار کند و تا زمانیکه شما Unlock نکنید سایر گوروتین ها نمی توانند دسترسی داشته باشند و تا زمانیکه Unlock صورت گیرد سایر گوروتین ها تلاش می کنند تا بتوانند دسترسی پیدا کنند.\nبه مثال زیر توجه کنید :\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;sync\u0026#34; 6\t\u0026#34;time\u0026#34; 7) 8 9var count int 10 11func main() { 12\tmu := new(sync.Mutex) 13\t14\tgo increment(mu) 15\tgo increment(mu) 16\tgo increment(mu) 17\tgo increment(mu) 18 19\ttime.Sleep(time.Second) 20} 21 22func increment(mu *sync.Mutex) { 23\tmu.Lock() 24\tdefer mu.Unlock() 25\tcount++ 26\tfmt.Printf(\u0026#34;Incrementing: %d\\n\u0026#34;, count) 27} 1$ go run main.go 2 3Incrementing: 1 4Incrementing: 2 5Incrementing: 3 6Incrementing: 4 در بالا ما یک تابع به نام increment ایجاد کردیم و به عنوان ورودی تایپ Mutex را بصورت پوینتر پاس دادیم. سپس با استفاده از توابع Lock و Unlock برای افزایش مقدار count یک قفل گذاشتیم.\nحال ۴ تا گوروتین داریم که قصد دارند همزمان روی بخش مشترک از حافظه عملیاتی را انجام دهند در اینجا ما با استفاده Mutex جلوی اینکه همزمان دسترسی داشته باشند به اون داده از حافظه را گرفتیم و فقط یک گوروتین می تواند عملیات انجام دهد و تا زمانیکه شما Unlock نکنید سایر گوروتین ها منتظر می مانند.\n3.3.1.1 سناریوهای استفاده # همگام سازی دسترسی به متغیرهای مشترک: یک mutex می تواند برای همگام سازی دسترسی به متغیرهای مشترک بین چندین گوروتین استفاده شود. این می تواند در مواردی مفید باشد که چندین گوروتین نیاز به خواندن یا به روز رسانی یک متغیر به طور همزمان دارند.\nهماهنگی دسترسی به حالت مشترک: یک mutex می تواند برای هماهنگ کردن دسترسی به حالت مشترک بین چندین گوروتین استفاده شود. به عنوان مثال، ممکن است از یک mutex استفاده کنید تا اطمینان حاصل کنید که فقط یک گوروتین می تواند یک ساختار داده مشترک را در یک زمان تغییر دهد.\nپیاده سازی الگوهای تولیدکننده-مصرف کننده (producer-consumer): یک mutex می تواند برای پیاده سازی الگوهای تولیدکننده-مصرف کننده استفاده شود، که در آن یک یا چند گوروتین داده تولید می کنند و یک یا چند گوروتین آن را مصرف می کنند. mutex می تواند برای همگام سازی دسترسی به ساختار داده مشترک که داده ها را نگه می دارد استفاده شود.\n۲ نکته خیلی مهم\nسعی کنید پس از اینکه تابع Lock را فراخوانی میکنید تابع Unlock را داخل defer قرار دهید. زمانیکه قصد دارید Mutex را به عنوان پارامتر ورودی برای توابع تعریف کنید بهتر است از نوع اشاره گر باشد. 3.3.2 RWMutex # در پکیج sync یک تایپ به نام RWMutex وجود دارد که عملیات خواندن و نوشتن برروی یک داده مشترک را همگام سازی می کند. شما می توانید به چندین گوروتین اجازه خواندن یک داده مشترک را بدهید ولی فقط یک گوروتین می تواند عملیات نوشتن را برروی آن داده مشترک را انجام دهد.\nدر زیر یک مثال قرار دادیم توجه کنید :\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;math/rand\u0026#34; 6\t\u0026#34;strings\u0026#34; 7\t\u0026#34;sync\u0026#34; 8\t\u0026#34;time\u0026#34; 9) 10 11func init() { 12\trand.Seed(time.Now().Unix()) 13} 14func sleep() { 15\ttime.Sleep(time.Duration(rand.Intn(1000)) * time.Millisecond) 16} 17func reader(c chan int, m *sync.RWMutex, wg *sync.WaitGroup) { 18\tsleep() 19\tm.RLock() 20\tc \u0026lt;- 1 21\tsleep() 22\tc \u0026lt;- -1 23\tm.RUnlock() 24\twg.Done() 25} 26func writer(c chan int, m *sync.RWMutex, wg *sync.WaitGroup) { 27\tsleep() 28\tm.Lock() 29\tc \u0026lt;- 1 30\tsleep() 31\tc \u0026lt;- -1 32\tm.Unlock() 33\twg.Done() 34} 35func main() { 36\tvar m sync.RWMutex 37\tvar rs, ws int 38\trsCh := make(chan int) 39\twsCh := make(chan int) 40\tgo func() { 41\tfor { 42\tselect { 43\tcase n := \u0026lt;-rsCh: 44\trs += n 45\tcase n := \u0026lt;-wsCh: 46\tws += n 47\t} 48\tfmt.Printf(\u0026#34;%s%s\\n\u0026#34;, strings.Repeat(\u0026#34;R\u0026#34;, rs), 49\tstrings.Repeat(\u0026#34;W\u0026#34;, ws)) 50\t} 51\t}() 52\twg := sync.WaitGroup{} 53\tfor i := 0; i \u0026lt; 10; i++ { 54\twg.Add(1) 55\tgo reader(rsCh, \u0026amp;m, \u0026amp;wg) 56\t} 57\tfor i := 0; i \u0026lt; 3; i++ { 58\twg.Add(1) 59\tgo writer(wsCh, \u0026amp;m, \u0026amp;wg) 60\t} 61\twg.Wait() 62} 1$ go run main.go 2R 3RR 4R 5RR 6R 7W 8R 9RR 10RRR 11RRRR 12RRRRR 13RRRRRR 14RRRRRRR 15RRRRRR 16RRRRR 17RRRR 18RRR 19RR 20R 21W 22W 3.3.3 WaitGroup # یک ساختاری داخل پکیج sync داریم به نام WaitGroup است. معمولا برای منتظر ماندن برای پایان اجرای گروهی از گوروتین ها استفاده می شود. این ساختار ۳ متد دارد که به شرح زیر می باشد :\nAdd این متد که به عنوان ورودی عدد می گیرد تعداد گوروتین هایی که قرار است منتظر بمانند را تعیین میکند. Done این تابع زمانی استفاده می شود فرآیند داخل هریک از گوروتین ها اتمام شود. Wait این متد گوروتین ها را بلاک می کند تا زمانیکه سیگنال Done از تمامی گوروتین ها دریافت کند. بذارید به مثال توضیح دهیم :\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;sync\u0026#34; 6 \u0026#34;time\u0026#34; 7) 8 9func main() { 10 var wg sync.WaitGroup 11 wg.Add(2) 12 go sleep(\u0026amp;wg, time.Second*1) 13 go sleep(\u0026amp;wg, time.Second*2) 14 wg.Wait() 15 fmt.Println(\u0026#34;All goroutines finished\u0026#34;) 16} 17 18func sleep(wg *sync.WaitGroup, t time.Duration) { 19 defer wg.Done() 20 time.Sleep(t) 21 fmt.Println(\u0026#34;Finished Execution\u0026#34;) 22} 1$ go run main.go 2Finished Execution 3Finished Execution 4All goroutines finished در بالا ما یک متغیر از ساختار WaitGroup ایجاد کردیم و پس از ایجاد متد Add را فراخوانی کردیم و تعداد گوروتین هایی که قرار است منتظر بماند را مشخص کردیم. سپس آدرس حافظه متغیر wg را به تابع sleep به عنوان ورودی پاس دادیم و در نهایت داخل تابع sleep با استفاده از defer متد Done را فراخوانی کردیم.\nزمانیکه عملیات تابع sleep اتمام می شود متد Done فراخوانی می شود و یک گوروتین از لیست گوروتین های آبجکت WaitGroup کم می شود.\n1// Done decrements the WaitGroup counter by one. 2func (wg *WaitGroup) Done() { 3 wg.Add(-1) 4} حال وقتی فرآیند ۲ تا گوروتین اتمام شود اون بخش از کد از حالت بلاک بودن خارج می شود.\n۳ نکته خیلی مهم\nساختار WaitGroup یکی از پرکاربرد ترین قابلیت ها برای بحث همزمانی می باشد و برخی اوقات برای جلوگیری از Data race و همچنین برای ترتیب دهی عملیات همزمانی هم می توان از این استفاده کرد. سعی کنید WaitGroup را بصورت اشاره گر به توابعی که داخل گوروتین قرار دارند پاس دهید. هیچوقت تعداد گوروتین را بیشتر یا کمتر از اون تعدادی که دارید به متد Add ‌ندهید چون با خطای Panic مواجه خواهید شد. 3.3.4 Once # در پکیج sync ما یک تایپ داریم به نام Once که برای اطمینان از اینکه یک تابع فقط یکبار فراخوانی می شود استفاده می شود. شما فرض کنید قصد دارید در طول برنامه از یک آبجکت فقط یک instance داشته باشید می توانید با استفاده از Once این کار را انجام دهید (شما با استفاده از Once می توانید الگو طراحی Singleton را پیاده سازی کنید.)\nبه مثال زیر توجه کنید :\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;sync\u0026#34; 6) 7 8type singleton struct { 9\tdata string 10} 11 12var instance *singleton 13var once sync.Once 14 15func GetInstance() *singleton { 16\tonce.Do(func() { 17\tinstance = \u0026amp;singleton{data: \u0026#34;some data\u0026#34;} 18\t}) 19\treturn instance 20} 21 22func main() { 23\ts1 := GetInstance() 24\ts2 := GetInstance() 25\tif s1 == s2 { 26\tfmt.Println(\u0026#34;Same instance\u0026#34;) 27\t} else { 28\tfmt.Println(\u0026#34;Different instances\u0026#34;) 29\t} 30} 1$ go run main.go 2Same instance در مثال فوق ما یک تابع داریم به نام GetInstance که به عنوان خروجی ساختار singleton را بصورت اشاره گر ارائه می دهد. قبل از تابع ۲ تا متغیر تعریف کردیم به نام once و instance که داخل تابع GetInstance از متد Do متغیر once یک تابع inline را قرار دادیم که فقط یک آبجکت از ساختار singleton می سازد و داخل متغیر instance قرار می دهد. در نهایت instance بازگشت داده می شود.\n3.3.5 Pool # در نسخه ۱.۳ زبان گو امکانی تایپی به نام Pool در پکیج sync که امکان ایجاد استخر آبجکت ها بطور موقت بدون اینکه بخواهد بخشی از حافظه را اشتغال کند اضافه شد. هر آبجکتی که در Pool ذخیره شود بطور خودکار در هرزمانی بدون اینکه اطلاع رسانی کند حذف می شود. امکان استفاده مجدد از آبجکت هایی که داخل استخر می گیرند وجود دارد و این باعث می شود سربار استفاده حافظه کاهش یابد.\n1package main 2 3import ( 4\t\u0026#34;bytes\u0026#34; 5\t\u0026#34;io\u0026#34; 6\t\u0026#34;os\u0026#34; 7\t\u0026#34;sync\u0026#34; 8\t\u0026#34;time\u0026#34; 9) 10 11var bufPool = sync.Pool{ 12\tNew: func() any { 13\t// The Pool\u0026#39;s New function should generally only return pointer 14\t// types, since a pointer can be put into the return interface 15\t// value without an allocation: 16\treturn new(bytes.Buffer) 17\t}, 18} 19 20// timeNow is a fake version of time.Now for tests. 21func timeNow() time.Time { 22\treturn time.Unix(1136214245, 0) 23} 24 25func Log(w io.Writer, key, val string) { 26\tb := bufPool.Get().(*bytes.Buffer) 27\tb.Reset() 28\t// Replace this with time.Now() in a real logger. 29\tb.WriteString(timeNow().UTC().Format(time.RFC3339)) 30\tb.WriteByte(\u0026#39; \u0026#39;) 31\tb.WriteString(key) 32\tb.WriteByte(\u0026#39;=\u0026#39;) 33\tb.WriteString(val) 34\tw.Write(b.Bytes()) 35\tbufPool.Put(b) 36} 37 38func main() { 39\tLog(os.Stdout, \u0026#34;path\u0026#34;, \u0026#34;/search?q=flowers\u0026#34;) 40} 1$ go run main.go 22006-01-02T15:04:05Z path=/search?q=flowers در بالا ما یک متغیر به نام bufPool ایجاد کردیم که یک آبجکت از نوع bytes.Buffer ایجاد می کند. سپس داخل تابع Log ما با استفاده از متد Get آبجکت مورد نظر را از Pool خارج و داخل متغیر b قرار دادیم و پس از آن عملیات لازم را برروی Buffer انجام و در نهایت با استفاده از متد Put آبجکت را به Pool اضافه کردیم. حالا اتفاقی که صورت گرفته ما عملیاتی که نیاز داشتیم را برروی آبجکت انجام دادیم بدون اینکه بخوایم بخشی از حافظه را درگیر کنیم.\n3.3.5.1 بنچمارک در خصوص Pool # 1package main 2 3import ( 4 \u0026#34;sync\u0026#34; 5 \u0026#34;testing\u0026#34;) 6 7type Person struct { 8 Age int 9} 10 11var personPool = sync.Pool{ 12 New: func() interface{} { return new(Person) }, 13} 14 15func BenchmarkWithoutPool(b *testing.B) { 16 var p *Person 17 b.ReportAllocs() 18 b.ResetTimer() 19 for i := 0; i \u0026lt; b.N; i++ { 20 for j := 0; j \u0026lt; 10000; j++ { 21 p = new(Person) 22 p.Age = 23 23 } 24 } 25} 26 27func BenchmarkWithPool(b *testing.B) { 28 var p *Person 29 b.ReportAllocs() 30 b.ResetTimer() 31 for i := 0; i \u0026lt; b.N; i++ { 32 for j := 0; j \u0026lt; 10000; j++ { 33 p = personPool.Get().(*Person) 34 p.Age = 23 35 personPool.Put(p) 36 } 37 } 38} 1$ go test -bench=. -benchmem 2 3goos: linux 4goarch: amd64 5pkg: pool 6cpu: Intel(R) Core(TM) i5-3570 CPU @ 3.40GHz 7BenchmarkWithoutPool-4 5262 213177 ns/op 80000 B/op 10000 allocs/op 8BenchmarkWithPool-4 7699 152788 ns/op 0 B/op 0 allocs/op 9PASS 10ok pool 2.343s 3.3.5.2 مثال های کاربردی # مثال اول :\nفرض کنید شما می خواهید یک فایل csv را با کلی رکورد parse کنید. هر رکورد نیازمند این است که داخل یک ساختاری قرار بگیرد و ایجاد یک ساختار باعث می شود بخشی از حافظه اختصاص یابد به آن ساختار. حالا فکر کنید میلیون ها رکورد داشته باشید و این تخصیص حافظه می تواند باعث توقف برنامه شود.\nحالا برای اینکه بخواهیم جلوی این اتفاق را بگیریم و سربار را کاهش دهیم بهتر است ما از sync.Pool استفاده کنیم و ساختارها را داخل استخر قرار دهیم. و زمانیکه هرکدام از ساختارها مورد نیاز نباشد می توانند داخل استخر قرار گیرند و مجدد استفاده شود. اینکار باعث می شود بطور خیلی قابل توجهی تعداد تخصیص حافظه کاهش یابد و عملکرد برنامه چند برابر شود.\nمثال دوم :\nموارد استفاده دیگر از sync.Pool برای ذخیره کردن آبجکت های پرکاربرد نظیر کانکشن دیتابیس یا شبکه و همچنین آبجکت هایی که قصد داریم برروی آن عملیات serialize و deserialize انجام دهیم.\n3.3.6 Cond # با استفاده از Cond می توانید چندین گوروتین ایجاد کنید و گوروتین ها تا زمان وقوع یک رویداد منتظر می مانند و هیچ فرآیندی را اجرا نمیکنند. هر Cond که ایجاد میکنید داخلش یک قفل از نوع (Mutex یا RWMutex) وجود دارد که می توانید گوروتین ها را منتظر نگه دارید.\nزمانیکه شما یک Cond میسازید به عنوان ورودی یک قفل از نوع (Mutex یا RWMutex) یه عنوان ورودی می دهید. حال شما ۳ تا متد درخصوص Cond خواهید داشت که به شرح زیر است :\nBroadcast: با استفاده از این متد می توانید تمامی گوروتین هایی که در حالت منتظر هستند را آزاد کنید تا به فرآیند خود ادامه دهند. Signal: با استفاده از این متد می توانید به گوروتین سیگنال بفرستید تا از حالت منتظر خارج شود و به فرآیند خود ادامه دهد. Wait: این متد بصورت atomic منتظر می ماند تا زمانیکه unlocks صورت گیرد و تا اون موقع گوروتین ها را در حالت تعلیق نگه می دارد. به مثال زیر توجه کنید :\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;sync\u0026#34; 6) 7 8var sharedRsc = make(map[string]interface{}) 9 10func main() { 11\tvar wg sync.WaitGroup 12\twg.Add(2) 13\tm := sync.Mutex{} 14\tc := sync.NewCond(\u0026amp;m) 15\tgo func() { 16\t// this go routine wait for changes to the sharedRsc 17\tc.L.Lock() 18\tfor len(sharedRsc) == 0 { 19\tc.Wait() 20\t} 21\tfmt.Println(\u0026#34;goroutine1\u0026#34;, sharedRsc[\u0026#34;rsc1\u0026#34;]) 22\tc.L.Unlock() 23\twg.Done() 24\t}() 25 26\tgo func() { 27\t// this go routine wait for changes to the sharedRsc 28\tc.L.Lock() 29\tfor len(sharedRsc) == 0 { 30\tc.Wait() 31\t} 32\tfmt.Println(\u0026#34;goroutine2\u0026#34;, sharedRsc[\u0026#34;rsc2\u0026#34;]) 33\tc.L.Unlock() 34\twg.Done() 35\t}() 36 37\t// this one writes changes to sharedRsc 38\tc.L.Lock() 39\tsharedRsc[\u0026#34;rsc1\u0026#34;] = \u0026#34;foo\u0026#34; 40\tsharedRsc[\u0026#34;rsc2\u0026#34;] = \u0026#34;bar\u0026#34; 41\tc.Broadcast() 42\tc.L.Unlock() 43\twg.Wait() 44} 1$ go run main.go 2goroutine2 bar 3goroutine1 foo "},{"id":35,"href":"/chapter-3/go-atomic/","title":"3.4 پکیج atomic","section":"فصل سوم: همزمانی (concurrency)","content":"پکیج atomic یک حافظه atomic سطح پایین برای پیاده سازی الگوریتم های همگام سازی شده است. از مواردی که خیلی قابل اهمیت است با این پکیج شما می توانید یکسری الگوهای همگام سازی را پیاده سازی کنید. سعی کنید با دقت بیشتری از این پکیج استفاده کنید چون کارکردش خارج از safe memory هست.\nبه مثال زیر توجه کنید :\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;sync\u0026#34; 6\t\u0026#34;sync/atomic\u0026#34; 7) 8 9type Cache struct { 10\tmu sync.Mutex 11\tdata map[string]string 12} 13 14func (c *Cache) Set(key, value string) { 15\tc.mu.Lock() 16\tdefer c.mu.Unlock() 17\tc.data[key] = value 18} 19 20func (c *Cache) Get(key string) (value string, ok bool) { 21\tc.mu.Lock() 22\tdefer c.mu.Unlock() 23\tvalue, ok = c.data[key] 24\treturn 25} 26 27type AtomicCache struct { 28\tmu sync.Mutex 29\tdata atomic.Value 30} 31 32func (c *AtomicCache) Set(key, value string) { 33\tc.mu.Lock() 34\tdefer c.mu.Unlock() 35\tc.data.Store(map[string]string{key: value}) 36} 37 38func (c *AtomicCache) Get(key string) (value string, ok bool) { 39\tdata := c.data.Load().(map[string]string) 40\tvalue, ok = data[key] 41\treturn 42} 43 44func main() { 45\tcache := Cache{data: map[string]string{}} 46\tcache.Set(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;) 47\tfmt.Println(cache.Get(\u0026#34;key\u0026#34;)) // Output: value, true 48 49\tatomicCache := AtomicCache{data: atomic.Value{}} 50\tatomicCache.Set(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;) 51\tfmt.Println(atomicCache.Get(\u0026#34;key\u0026#34;)) // Output: value, true 52} 1$ go run main.go 2value true 3value true در مثال فوق ما یک ساختار به نام Cache داریم که داخلش یک فیلد از نوع map داریم و قصد داریم یکسری اطلاعات را داخل کش بریزیم حال زمانیکه Set/Get می کنیم با استفاده از Mutex اون بخش از عملیات را لاک میکنیم تا جلوی عملیات نوشتن چندین گوروتین برروی یک آدرس حافظه را بگیریم. حال این عملیات رو ما با استفاده از atomic انجام دادیم و همگام سازی داده را بردیم تو سطح خیلی پایین تر در حافظه و با استفاده از atomic.Value که یک اینترفیس است این عملیات را انجام دادیم و این عملیات Set/Get حالت atomic پیدا کرده است.\n3.4.1 برخی از کاربردهای atomic # در زیر چندتا use case برای استفاده از پکیج atomic معرفی کردیم :\nپیاده سازی همگام سازی بدون مسدودیت : پکیج atomic توابع سطح پایینی را برای انجام عملیات حافظه اتمی فراهم می کند که می تواند برای پیاده سازی الگوریتم های همگام سازی غیرمسدود مانند مقایسه و تعویض (CAS) یا بارگذاری لینک/ذخیره شرطی استفاده شود. LL/SC).\nپیاده سازی ساختارهای داده با همزمانی سطح (high-concurrency) بالا : با پکیج atomic می توان برای پیاده سازی ساختارهای داده ای استفاده کرد که برای دسترسی همزمان و اصلاح توسط چندین گوروتین ایمن هستند. به عنوان مثال، می توانید از بسته اتمی برای پیاده سازی نقشه یا صف همزمان استفاده کنید.\nپیاده سازی شمارنده (counter) از نوع atomic : شما با استفاده از پکیج atomic می توانید برای افزایش و کاهش شمارنده ها به صورت اتمی که می تواند برای اجرای مواردی مانند شمارش مرجع یا محدود کردن ratelimit استفاده شود.\n"},{"id":36,"href":"/chapter-3/goroutine-data-race/","title":"3.5 آموزش مقابله با data race","section":"فصل سوم: همزمانی (concurrency)","content":"معمولا تو بحث همزمانی یکی از اتفاقاتی که خیلی ممکن است رخ دهد بحث data race است و data race زمانی رخ می دهد که ۲ یا چند گوروتین قصد دارند به یک آدرس حافظه در یک زمان دسترسی داشته باشند. حال اگر ما جلوی data race را نگیریم ممکن است تغییرات نادرست برروی مقادیر داخل خانه حافظه صورت گیرد.\nراه هایی برای مقابله با data race وجود دارد که به شرح زیر است :\nاستفاده از Mutex داخل پکیج sync برای قفل گذاشتن/برداشتن یک بخش دیتا. استفاده RWMutex داخل پکیج sync می توانید داده اشتراک گذاری شده را قفل کنید فقط یک گوروتین عملیات نوشتن داشته باشد. استفاده از پکیج atomic برای عملیات بصورت atomic برروی مقادیر. 3.5.1 تشخیص Data Race # به لطف امکان جانبی زبان گو شما می توانید خیلی راحت بخش هایی که data race رخ داده را تشخیص دهید. کافیه سوییچ race- را هنگام build اضافه کنید تا در زمان data race ها را تشخیص دهید.\n1$ go run -race main.go 2 3================== 4WARNING: DATA RACE 5Write at 0x00c000522c20 by goroutine 29: 6 git.ramooz.org/ramooz/golang-components/event-driven/rabbitmq.(*Connection).handleReconnect() 7 /home/user/Project/go/ramooz.org/medx/software-builder/vendor/git.ramooz.org/ramooz/golang-components/event-driven/rabbitmq/rabbit.go:86 +0x89 8 git.ramooz.org/ramooz/golang-components/event-driven/rabbitmq.NewConnection.func1() 9 /home/user/Project/go/ramooz.org/medx/software-builder/vendor/git.ramooz.org/ramooz/golang-components/event-driven/rabbitmq/rabbit.go:35 +0x58 10 11Previous read at 0x00c000522c20 by main goroutine: 12 git.ramooz.org/ramooz/golang-components/event-driven/rabbitmq.NewConnection() 13 /home/user/Project/go/ramooz.org/medx/software-builder/vendor/git.ramooz.org/ramooz/golang-components/event-driven/rabbitmq/rabbit.go:37 +0x324 14 git.ramooz.org/ramooz/golang-components/logger.initializeRabbitMQ() 15 /home/user/Project/go/ramooz.org/medx/software-builder/vendor/git.ramooz.org/ramooz/golang-components/logger/rabbit.conn.go:11 +0x226 16 git.ramooz.org/ramooz/golang-components/logger.NewLogger() 17 /home/user/Project/go/ramooz.org/medx/software-builder/vendor/git.ramooz.org/ramooz/golang-components/logger/logger.go:37 +0x456 18 ramooz.org/ramooz/user-service/configs.initNewLogger() 19 /home/user/Project/go/ramooz.org/medx/software-builder/configs/configs.go:158 +0x938 20 ramooz.org/ramooz/user-service/configs.ConfigServer() 21 /home/user/Project/go/ramooz.org/medx/software-builder/configs/configs.go:54 +0x15a 22 main.main() 23 /home/user/Project/go/ramooz.org/medx/software-builder/main.go:17 +0x29 24 25Goroutine 29 (running) created at: 26 git.ramooz.org/ramooz/golang-components/event-driven/rabbitmq.NewConnection() 27 /home/user/Project/go/ramooz.org/medx/software-builder/vendor/git.ramooz.org/ramooz/golang-components/event-driven/rabbitmq/rabbit.go:35 +0x2da 28 git.ramooz.org/ramooz/golang-components/logger.initializeRabbitMQ() 29 /home/user/Project/go/ramooz.org/medx/software-builder/vendor/git.ramooz.org/ramooz/golang-components/logger/rabbit.conn.go:11 +0x226 30 git.ramooz.org/ramooz/golang-components/logger.NewLogger() 31 /home/user/Project/go/ramooz.org/medx/software-builder/vendor/git.ramooz.org/ramooz/golang-components/logger/logger.go:37 +0x456 32 ramooz.org/ramooz/user-service/configs.initNewLogger() 33 /home/user/Project/go/ramooz.org/medx/software-builder/configs/configs.go:158 +0x938 34 ramooz.org/ramooz/user-service/configs.ConfigServer() 35 /home/user/Project/go/ramooz.org/medx/software-builder/configs/configs.go:54 +0x15a 36 main.main() 37 /home/user/Project/go/ramooz.org/medx/software-builder/main.go:17 +0x29 38================== در خروجی بالا یک هشدار data race داده است که در فلان خط کد شما فلان گوروتین ها در یک زمان دسترسی برروی یک داده را دارند. و شما با توجه به خروجی می توانید سناریو های جلوگیری را انجام دهید.\n"},{"id":37,"href":"/chapter-3/go-channel/","title":"3.6 کانال (channel)","section":"فصل سوم: همزمانی (concurrency)","content":" کانال یک نوع تایپ است که داده از نوع خاصی را نگه داری میکند و امکان برقراری ارتباط و همگام سازی داده بین گوروتین ها را فراهم می کند. شما می توانید کانال ها را به عنوان خط لوله های در نظر بگیرید که این خط لوله ها به گوروتین ها متصل می شود و باعث برقراری ارتباط بین گوروتین ها می شود. این ارتباط بین گوروتین ها به هیچ قفل صریحی نیاز ندارد (منظورم mutex و \u0026hellip;) چون کانال ها بصورت داخلی قفل ها را مدیریت میکند و در زمان های مناسب و مشخص Lock و UnLock می کند.\nبه نقل از رابرت گریزمر که یکی از توسعه دهنده های اصلی زبان برنامه نویسی گو می باشد در خصوص کانال ها می گوید : با برقراری ارتباط حافظه را به اشتراک بزارید ولی با اشتراک گذاری حافظه ارتباط برقرار نکنید.\nمنظور از نقل فوق این است شما برای اینکه بخوای بین گوروتین ها ارتباط برقرار کنی این کار را با اشتراک گذاری حافظه نکنید. بلکه باید بواسطه کانال ها حافظه را بین گوروتین ها به اشتراک بزارید.\nزبان گو برای بحث همزمانی ۲ تا مقوله خیلی مهم دارد که این دو با هم در ارتباط هستند :\nگوروتین ها : اجزای مستقل و سبک وزن برای دستیابی به همزمان و حالت موازی. کانال ها : فراهم کننده ارتباط و همگام سازی داده بین گوروتین ها 3.6.1 تعریف کانال ها # همانطور که گفتیم کانال یک نوع تایپ است که داده از نوع خاصی را نگه داری میکند و شما باید این تایپ را برای متغیری تعریف کنید تا بتوانید بواسطه آن متغیر می توانیم بین گوروتین ها ارتباط برقرار کنیم.\n1var \u0026lt;variable_name\u0026gt; chan \u0026lt;type\u0026gt; به مثال زیر توجه کنید :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 var a chan int 7 fmt.Println(a) 8} 1$ go run main.go 2{nil} در بالا ما یک متغیر با نام a تعریف کردیم که از نوع کانال با تایپ int می باشد و این کانال فقط انتقال داده از نوع int را انجام می دهد. و مقدار پیش فرض کانال nil می باشد که در خروجی می توانید ببینید.\nتوجه کنید همیشه سعی کنید کانال را با استفاده از تابع make ایجاد کنید. 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 a := make(chan int) 7 fmt.Println(a) 8} 1$ go run main.go 20xc0000240c0 در خروجی کد بالا همانطور که مشاهده می کنید به جای nil آدرس حافظه داده را نمایش می دهد.\nزمانیکه شما یک کانال را به واسطه make ایجاد می کنید در واقع دارید یک instance از ساختار hchan ایجاد می کنید و تمامی فیلدهای این ساختار مقدار پیش فرض میگیرند.\n1type hchan struct { 2 qcount uint // total data in the queue 3 dataqsiz uint // size of the circular queue 4 buf unsafe.Pointer // points to an array of dataqsiz elements 5 elemsize uint16 6 closed uint32 // denotes weather channel is closed or not 7 elemtype *_type // element type 8 sendx uint // send index 9 recvx uint // receive index 10 recvq waitq // list of recv waiters 11 sendq waitq // list of send waiters 12 lock mutex 13} 3.6.2 عملیات ها برروی کانال # وقتی شما یک کانال ایجاد می کنید ۲ تا عملیات اصلی برروی کانال می توانید انجام دهید :\nارسال : ارسال داده به داخل کانال دریافت : دریافت داده از کانال 3.6.2.1 عملیات ارسال # برای ارسال داده به داخل کانال یک قالب استاندارد وجود دارد که بهتر است همیشه به خاطر بسپارید :\n1ch \u0026lt;- val متغیر ch همان کانالی است که با تایپ مشخصی ازش ایجاد کردیم. متغیر val هم مقداری است که به واسطه \u0026gt;- داریم به کانال ارسال می کنیم. توجه کنید تایپ val باید با تایپی که برای کانال مشخص کردید حتما یکی باشد. 3.6.2.2 عملیات دریافت # عملیات دریافت در کانال صرفا جهت خواندن داده از طریق کانال می باشد که یک قالب استاندارد همانند عملیات ارسال دارد :\n1val := \u0026lt;- ch در اینجاهم ch همان متغیر کانال می باشد. متغیر val هم منتظر دریافت داده به واسطه \u0026gt;- از طریق کانال ch می باشد. 3.6.2.3 مثال عملیات ارسال و دریافت # در زیر یک مثال میزنیم که داده ای را بواسطه کانال ارسال/دریافت می کنیم بین گوروتین ها.\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;time\u0026#34; 6) 7 8func main() { 9 ch := make(chan int) 10 11 fmt.Println(\u0026#34;Sending value to channel\u0026#34;) 12 go send(ch) 13 14 fmt.Println(\u0026#34;Receiving from channel\u0026#34;) 15 go receive(ch) 16 17 time.Sleep(time.Second * 1) 18} 19 20func send(ch chan int) { 21 ch \u0026lt;- 1 22} 23 24func receive(ch chan int) { 25 val := \u0026lt;-ch 26 fmt.Printf(\u0026#34;Value Received=%d in receive function\\n\u0026#34;, val) 27} 1$ go run main.go 2Sending value to channel 3Receiving from channel 4Value Received=1 in receive function در کد فوق ما یک کانال با نام ch از نوع int ایجاد کردیم. سپس ۲ تابع send و received را داخل گوروتین قرار دادیم که هر دو تابع به عنوان پارامتر ورودی تایپ int را بصورت کانال میگیرد. حال متغیر کانال ch را به هر دو تابع پاس دادیم. و در هر دو تابع ۲ تا عملیات صورت گرفته :\nتابع send مقدار عدد ۱ را به داخل کانال ارسال کرده تابع recived مقدار را از کانال ch دریافت کرده و داخل متغیر val قرار داده است و در نهایت متغیر val را چاپ کرده است. در انتهای تابع main ما یک sleep به مدت ۱ ثانیه قرار دادیم که بتوانید خروجی برنامه را ببینیم و اگر اینکار را نکنیم برنامه متوقف می شود و ممکن دو گوروتین برای اجرا برنامه ریزی نشوند.\nیک نکته بسیار مهمی که وجود دارد در مورد عملیات دریافت باید توجه کنید که یک مقدار خاص از نوع int به داخل کانال فقط یک بار ارسال شده است و فقط یکبار مقدار قابل دریافت از کانال. همانطور که می بینید هیچ قفلی در گوروتین ها موقع ارسال و دریافت استفاده نشده است و قفل ها توسط خود کانال مدیریت می شود و نیازی به استفاده از قفل ها در کد نیست.\nبزارید یک مثال ساده برای اینکه ببینید چطور کانال ها Lock و UnLock می شود بزنیم :\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;time\u0026#34; 6) 7 8func main() { 9 ch := make(chan int) 10 go send(ch) 11 12 go receive(ch) 13 time.Sleep(time.Second * 2) 14} 15 16func send(ch chan int) { 17 time.Sleep(time.Second * 1) 18 fmt.Println(\u0026#34;Timeout finished\u0026#34;) 19 ch \u0026lt;- 1 20} 21 22func receive(ch chan int) { 23 val := \u0026lt;-ch 24 fmt.Printf(\u0026#34;Receiving Value from channel finished. Value received: %d\\n\u0026#34;, val) 25} 1$ go run main.go 2Timeout finished 3Receiving Value from channel finished. Value received: 1 در کد فوق ما داخل تابع send یک sleep به مدت ۱ ثانیه قرار دادیم. و پس از اینکه ۱ ثانیه تمام شد مقدار را داخل کانال ch ارسال کردیم و سپس مقدار داخل تابع recived دریافت شد.\nاتفاقی که در کد فوق رخداد زمانیکه شما عملیات دریافت را انجام می دهید تا زمانیکه مقداری از کانال دریافت نشود اون بخش از کد شما Lock می شود و پس از اینکه دریافت شد مقدار از کانال آن بخش Unlock خواهد شد.\n3.6.3 ایجاد کانال بافر شده # در زبان گو شما می توانید کانال های بافر شده ایجاد کنید. یک کانال بافر دارای مقداری ظرفیت برای نگه داری داده برای کانال بافر است.\nبزارید کمی ساده تر توضیح دهیم شما برای کانال همانند آرایه و slice می توانید یک ظرفیت مشخصی تعیین کنید که این کانال فقط می تواند این مقدار از داده را نگه داری کند و تا زمانیکه مقادیر از کانال خارج نشود ظرفیت کانال پرخواهد بود و مقدار جدیدی را نمی توانید به کانال ارسال کنید.\nبرای ایجاد یک کانال بافر شده با از قالب زیر استفاده کنید :\n1a := make(chan , capacity) مقدار capacity که بصورت عدد هست تعداد بافر کانال را مشخص می کند که این کانال فقط می تواند این حجم از داده را داخل کانال نگه داری کند.\nبه مثال زیر توجه کنید :\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5) 6 7func main() { 8 ch := make(chan int, 1) 9 ch \u0026lt;- 1 10 fmt.Println(\u0026#34;Sending value to channnel complete\u0026#34;) 11 val := \u0026lt;-ch 12 fmt.Printf(\u0026#34;Receiving Value from channel finished. Value received: %d\\n\u0026#34;, val) 13} 1$ go run main.go 2Sending value to channnel complete 3Receiving Value from channel finished. Value received: 1 در کد فوق ما یک کانال بافر شده با ظرفیت ۱ ایجاد کردیم و مقدار ۱ را به کانال ارسال کردیم و در ادامه از این مقدار را از کانال دریافت کردیم.\n1ch := make(chan int, 1) 3.6.3.1 ارسال داده برروی کانال با ظرفیت پر # حالا فرض کنید می خواهیم به کانال بافر شده کد فوق یک مقدار دیگری را ارسال کنیم :\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7func main() { 8\tch := make(chan int, 1) 9\tch \u0026lt;- 1 10\tch \u0026lt;- 2 11\tfmt.Println(\u0026#34;Sending value to channnel complete\u0026#34;) 12\tval := \u0026lt;-ch 13\tfmt.Printf(\u0026#34;Receiving Value from channel finished. Value received: %d\\n\u0026#34;, val) 14} 1$ go run main.go 2fatal error: all goroutines are asleep - deadlock! 3 4goroutine 1 [chan send]: 5main.main() 6\t/tmp/sandbox2390960160/prog.go:10 +0x4b در کد فوق اتفاقی که افتاد ما یک کانال بافر شده با ظرفیت ۱ ایجاد کردیم ولی به این کانال ۲ تا مقدار ارسال کردیم:\n1ch \u0026lt;- 1 2ch \u0026lt;- 2 در ادامه اتفاقی که صورت گرفت کانال ما به خاطر پر شدن ظرفیتش بلاک شده بود و داده دیگه ای را نمی توانست نگه داری کند. در نتیجه با خطای deadlock مواجه شد و برنامه کاملا متوقف شد :\n1fatal error: all goroutines are asleep - deadlock! دریافت مجدد داده از کانال خالی شده # به مثال زیر توجه کنید :\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5) 6 7func main() { 8 ch := make(chan int, 1) 9 ch \u0026lt;- 1 10 fmt.Println(\u0026#34;Sending value to channnel complete\u0026#34;) 11 val := \u0026lt;-ch 12 val = \u0026lt;-ch 13 fmt.Printf(\u0026#34;Receiving Value from channel finished. Value received: %d\\n\u0026#34;, val) 14} 1$ go run main.go 2Sending value to channnel complete 3fatal error: all goroutines are asleep - deadlock! 4 5goroutine 1 [chan receive]: 6main.main() 7\t/tmp/sandbox3239418330/prog.go:12 +0xad در کد فوق ما یک کانال بافر شده با ظرفیت ۱ ایجاد کردیم و یک مقدار را به کانال ارسال کردیم و در نهایت ۲ بار دریافت از کانال را فرخوانی کردیم. اما اتفاقی که افتاده بازم با خطای deadlock مواجه شدیم چون کانال خالی شده است و هیچ داده ای بیشتر از بافر اش ندارد.\n3.6.4 جهت های کانال # شما می توانید کانال را جهت های مختلفی تعریف کنید که به شرح زیر است :\nدو طرفه : کانال با جهت دوطرفه مانند مثال های قبلی می باشد که شما chan int به این شکل تعریف می کنید. یک طرفه فقط ارسال : شما می توانید یک کانال ایجاد کنید که فقط عملیات ارسال chan\u0026lt;- int را انجام می دهد. یک طرفه فقط دریافت : شما می توانید یک کانال ایجاد کنید که فقط عملیات دریافت \u0026lt;-chan int را انجام می دهد. حالا این سوال پیش می آید چرا باید ما یک کانال ایجاد کنیم که عملیات فقط ارسال یا عملیات فقط دریافت را انجام می دهد. این کار وقتی مفید است که شما بخواهید برای پارامترهای ورودی یا خروجی توابع خود را محدود به یک عملیات در کانال کنید.\nکانال حالت های مختلفی دارد که شما پارامترهای ورودی و خروجی تابع استفاده کنید :\nchan کانال دوطرفه chan \u0026lt;- کانال فقط ارسال \u0026lt;-chan کانال فقط دریافت 3.6.4.1 کانال فقط ارسال # برای ایجاد کانال فقط ارسال شما می توانید به شکل زیر برای ورودی یا خروجی تابع تعریف کنید :\n1func process(ch chan\u0026lt;- int){ doSomething } زمانیکه شما تلاش کنید کانال با جهت های مختلف به پارامتر ورودی تابع فقط ارسال کانالی را پاس دهید با خطای زیر مواجه خواهید شد :\n1invalid operation: \u0026lt;-ch (receive from send-only type chan\u0026lt;- int) به مثال ساده زیر توجه کنید :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tch := make(chan int, 3) 7\tgo process(ch) 8\tfmt.Println(\u0026lt;-ch) 9} 10func process(ch chan\u0026lt;- int) { 11\tch \u0026lt;- 2 12} 1$ go run main.go 22 در کد فوق ما یک تابع به نام process ایجاد کردیم که کانال فقط ارسال به عنوان پارامتر ورودی دارد و در ادامه ما کانال ch را که دو طرفه است به این تابع پاس دادیم و مقدار دریافتی را چاپ کردیم.\n3.6.4.2 کانال فقط دریافت # برای ایجاد کانال فقط دریافت شما می توانید به شکل زیر برای ورودی یا خروجی تابع تعریف کنید :\n1func process(ch \u0026lt;-chan int){ doSomething } زمانیکه شما تلاش کنید کانال با جهت های مختلف به پارامتر ورودی تابع فقط دریافت پاس دهید با خطای زیر مواجه خواهید شد :\n1invalid operation: ch \u0026lt;- 2 (send to receive-only type \u0026lt;-chan int) به مثال ساده زیر توجه کنید :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tch := make(chan int, 3) 7\tch \u0026lt;- 2 8\tprocess(ch) 9} 10func process(ch \u0026lt;-chan int) { 11\ts := \u0026lt;-ch 12\tfmt.Println(s) 13} 1$ go run main.go 22 3.6.5 گرفتن ظرفیت یک کانال # شما می توانید همانند slice یا آرایه ظرفیت یک کانال را با استفاده از تابع ()cap ببینید.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 ch := make(chan int, 3) 7 fmt.Printf(\u0026#34;Capacity: %d\\n\u0026#34;, cap(ch)) 8} 1$ go run main.go 2Capacity: 3 توجه کنید ظرفیت کانال بافر نشده همیشه صفر است. 3.6.6 گرفتن طول یک کانال # شما با استفاده از تابع ()len می توانید طول و اندازه یک کانال را بگیرید و ببینید چه مقدار داده داخل کانال قرار دارد.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tch := make(chan int, 3) 7\tch \u0026lt;- 5 8\tfmt.Printf(\u0026#34;Len: %d\\n\u0026#34;, len(ch)) 9 10\tch \u0026lt;- 6 11\tfmt.Printf(\u0026#34;Len: %d\\n\u0026#34;, len(ch)) 12\tch \u0026lt;- 7 13\tfmt.Printf(\u0026#34;Len: %d\\n\u0026#34;, len(ch)) 14} 1$ go run main.go 2Len: 1 3Len: 2 4Len: 3 3.6.7 عملیات بستن (close) یک کانال # در زبان گو ما یک تابع Built-in به نام close داریم که می توانیم برای بستن یک کانال استفاده کنیم و زمانیکه که یک کانال بسته شود دیگر نمی توانیم داده ای را به آن کانال ارسال کنیم. کانال معمولا زمانی بسته می شود که همه داده ها ارسال شده است و داده دیگری برای ارسال نداریم و باید کانال را ببندیم.\nبه مثال زیر توجه کنید :\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;time\u0026#34; 6) 7 8func main() { 9 ch := make(chan int) 10 go sum(ch, 3) 11 ch \u0026lt;- 2 12 ch \u0026lt;- 2 13 ch \u0026lt;- 2 14 close(ch) 15 time.Sleep(time.Second * 1) 16} 17 18func sum(ch chan int, len int) { 19 sum := 0 20 for i := 0; i \u0026lt; len; i++ { 21 sum += \u0026lt;-ch 22 } 23 fmt.Printf(\u0026#34;Sum: %d\\n\u0026#34;, sum) 24} 1$ go run main.go 2Sum: 6 در کد فوق ما یک کانال بافر شده با ظرفیت ۳ ایجاد کردیم و سپس ۳ تا مقدار را به کانال ارسال کردیم و پس از آن کانال را با تابع close بستیم چون دیگر نمیخواهیم داده دیگری را ارسال کنیم.\nتوجه کنید ارسال داده برروی کانال بسته شده ممکن است برنامه شما با خطای panic مواجه و کاملا متوقف شود.\n1package main 2func main() { 3 ch := make(chan int) 4 close(ch) 5 ch \u0026lt;- 2 6} 1$ go run main.go 2panic: send on closed channel اما برای اینکه بتوانیم جلوی این panic رخ داده را بگیریم می توانیم زمانیکه داریم از کانال مقدار دریافت می کنیم می توانیم assertion انجام دهیم تا متوجه بسته بودن کانال شویم :\n1package main 2import ( 3 \u0026#34;fmt\u0026#34; 4) 5func main() { 6 ch := make(chan int, 1) 7 ch \u0026lt;- 2 8 val, ok := \u0026lt;-ch 9 fmt.Printf(\u0026#34;Val: %d OK: %t\\n\u0026#34;, val, ok) 10 11 close(ch) 12 val, ok = \u0026lt;-ch 13 fmt.Printf(\u0026#34;Val: %d OK: %t\\n\u0026#34;, val, ok) 14} 1$ go run main.go 2Val: 2 OK: true 3Val: 0 OK: false اگر مقدار ok از کانال دریافتی true باشد یعنی کانال بسته نشده است و اگر مقدار false دریافت کنیم یعنی کانال بسته شده است.\n3.6.8 استفاده از حلقه for-range برروی کانال # یکی از کاربردی ترین حالت های دریافت داده از کانال استفاده از حلقه for-range است که می توانید تا زمان بسته شدن کانال مقدار دریافت کنید.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;time\u0026#34; 6) 7 8func main() { 9\tch := make(chan int, 3) 10\tch \u0026lt;- 2 11\tch \u0026lt;- 2 12\tch \u0026lt;- 2 13\tclose(ch) 14\tgo sum(ch) 15\ttime.Sleep(time.Second * 1) 16} 17 18func sum(ch chan int) { 19\tsum := 0 20\tfor val := range ch { 21\tsum += val 22\t} 23\tfmt.Printf(\u0026#34;Sum: %d\\n\u0026#34;, sum) 24} 1$ go run main.go 2Sum: 6 در کد فوق ما یک کانال بافر شده با ظرفیت ۳ ایجاد کردیم سپس ۳ تا مقدار به کانال ارسال کردیم و داخل تابع sum مقادیر را با استفاده از حلقه for-range دریافت و پس از آن چاپ کردیم.\nحالا یک سوال پیش می آید آیا ما اگر کانال را در تابع main نبندیم چه اتفاقی می افتد؟ اگر شما کانال را نبندید بطور حتمی با خطا deadlock مواجه خواهید شد. حلقه ای که داخل تابع sum قرار دادید برای دریافت داده هیچوقت متوقف نخواهد شد.\nپس سعی کنید همیشه و همه جا در جای درست بستن کانال را انجام دهید تا دچار مشکلات مختلف نشوید.\n3.6.9 کانال nil # همانطور که در اوایل این بخش گفتیم مقدار پیش فرض یک کانال nil است و زمانیکه ما یک کانال بدون تابع make تعریف می کنیم مقدار پیش فرضش nil خوهد بود.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 var a chan int 7 fmt.Print(\u0026#34;Default zero value of channel: \u0026#34;) 8 fmt.Println(a) 9} 1$ go run main.go 2nil یکسری نکات در خصوص کانال nil وجود دارد :\nارسال داده به یک کانالی که nil است باعث بلاک شدن همیشگی کد شما در آن خط خواهد شد. دریافت داده به یک کانالی که nil است باعث بلاک شدن همیشگی کد شما در آن خط خواهد شد. بستن یک کانالی که nil باشد باعث panic برنامه شما خواهد شد. "},{"id":38,"href":"/chapter-3/go-select/","title":"3.7 آموزش استفاده از select","section":"فصل سوم: همزمانی (concurrency)","content":"در زبان گو select همانند switch می باشد که دارای case و default هستش اما یک فرق کلی دارد که به عملکردش برمیگردد. case های select برای عملیات ارسال و دریافت از کانال منتظر می ماند. در کل شما با استفاده از select می توانید از کانال های مختلف اطلاعات ارسال و دریافت کنید و پس از آن برروی آن اطلاعات عملیات انجام دهید.\nselect تا زمانی که یکی از case ها آماده شود بلاک می شود. اگر همزمان چندتا case برای انجام عملیات آماده شود select بصورت تصادفی یکی را انتخاب میکند تا عملیات تکمیل شود. 1select { 2case channel_send_or_receive: 3 //Dosomething 4case channel_send_or_receive: 5 //Dosomething 6default: 7 //Dosomething 8} select از بین case ها موردی را انتخاب می کند که در آن عملیات ارسال یا دریافت کانال بلاک نشده باشد و آماده اجرا باشد. اگر چند مورد از case ها آماده باشد یکی از آنها بصورت تصادفی انتخاب می شود تا فرآیند را تکمیل کند.\nبزارید یک مثال ساده بزنیم :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 ch1 := make(chan string) 7 ch2 := make(chan string) 8 9 go goOne(ch1) 10 go goTwo(ch2) 11 12 select { 13 case msg1 := \u0026lt;-ch1: 14 fmt.Println(msg1) 15 case msg2 := \u0026lt;-ch2: 16 fmt.Println(msg2) 17 } 18} 19 20func goOne(ch chan string) { 21 ch \u0026lt;- \u0026#34;From goOne goroutine\u0026#34; 22} 23 24func goTwo(ch chan string) { 25 ch \u0026lt;- \u0026#34;From goTwo goroutine\u0026#34; 26} 1$ go run main.go 2From goOne goroutine در کد فوق ما ۲ تا کانال تعریف کردیم و کانال ها را به توابع goOne و goTwo پاس دادیم سپس داخل تابع به هرکدام از کانال مقداری ارسال شد. حالا در ادامه بدنه main یک select قرار دادیم که هر یک از case ها منتظر دریافت اطلاعات از کانال مشخص شده براش است.\nپس از اینکه یکی یا هر دو از کانال داده را آماده کردند بصورت تصادفی یکی از case ها انتخاب می شود تا عملیات را تکمیل کند.\nکه در خروجی مقداری که از ch1 آماده را نمایش می دهد. اما اگر بخواهیم خروجی هر دو کانال را ببینیم می توانیم از حلقه استفاده کنیم. به مثال زیر توجه کنید :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 ch1 := make(chan string) 7 ch2 := make(chan string) 8 go goOne(ch1) 9 go goTwo(ch2) 10 for i := 0; i \u0026lt; 2; i++ { 11 select { 12 case msg1 := \u0026lt;-ch1: 13 fmt.Println(msg1) 14 case msg2 := \u0026lt;-ch2: 15 fmt.Println(msg2) 16 } 17 } 18} 19 20func goOne(ch chan string) { 21 ch \u0026lt;- \u0026#34;From goOne goroutine\u0026#34; 22} 23 24func goTwo(ch chan string) { 25 ch \u0026lt;- \u0026#34;From goTwo goroutine\u0026#34; 26} 1$ go run main.go 2From goOne goroutine 3From goTwo goroutine در کد فوق ما select را داخل یک حلقه fori قرار دادیم و گفتیم مقدار i کوچکتر از ۲ بود ++i شود. که در هر دو تایم مقدار دریافتی از کانال ها را توانستیم به عنوان خروجی چاپ کنیم.\nهمانطور که قبلا گفتیم اگر شما داخل select یک case ی را بزارید که هیچ اطلاعات از کانال دریافت نکند ممکن است برنامه شما کاملا بلاک شود و با خطای deadlock مواجه شوید.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 ch1 := make(chan string) 7 select { 8 case msg := \u0026lt;-ch1: 9 fmt.Println(msg) 10 } 11} 1$ go run main.go 2fatal error: all goroutines are asleep - deadlock! اتفاقی که در کد فوق رخ داد ما یک کانال ایجاد کردیم و سپس داخل select یک case قرار دادیم که منتظر دریافت داده از کانال می باشد. اما چون هیچ داده به کانال ارسال نمی شود برنامه بطور کلی در همان تیکه از کد بلاک می شود و در نهایت شما با خطای داخل خروجی مواجه خواهید شد.\n3.7.1 نحوه کنترل عملیات های کانال با select # در بالا در خصوص select توضیح دادیم که چه کاربردی هایی دارد اما بزارید توضیحات را تکمیل کنیم. وقتی شما قصد دارید از گوروتین و کانال استفاده کنید در اینجا select نقش خیلی پررنگی در کنترل عملیات کانال ها دارد. اینجاست که بحث همزمانی در زبان گو خیلی زیبا می شود. select می تواند بطور همزمان داده را از کانال دریافت کند و برای اجرا سایر عملیات آماده کند. بنابراین select همراه با کانال و گوروتین خیلی ابزار قدرتمندی می شود برای کنترل و مدیریت همگام سازی و همزمانی.\n3.7.1.1 عملیات ارسال با select # در زیر یک مثالی زدیم که با استفاده از select داده ای را به کانال میریزیم و سپس آن داده را از کانال دیگر دریافت می کنیم :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 ch1 := make(chan string) 7 ch2 := make(chan string) 8 go goOne(ch1) 9 go goTwo(ch2) 10 select { 11 12 case msg1 := \u0026lt;-ch1: 13 fmt.Println(msg1) 14 case ch2 \u0026lt;- \u0026#34;To goTwo goroutine\u0026#34;: 15 } 16} 17 18func goOne(ch chan string) { 19 ch \u0026lt;- \u0026#34;From goOne goroutine\u0026#34; 20} 21 22func goTwo(ch chan string) { 23 msg := \u0026lt;-ch 24 fmt.Println(msg) 25} 1$ go run main.go 2To goTwo goroutine در کد فوق ما با استفاده از یکی از case های select داده ای را داخل کانال ریختیم و آن داده را داخل گوروتین تابع goTwo دریافت کردیم و پس آن چاپ کردیم مقدار دریافتی را.\n3.7.2 استفاده از default در select # در زبان گو switch و select می توانند یک default داشته باشند. در اینجا default مربوط select رفتارش همانند default داخل switch می باشد. حالا اگر هر یک از case ها عملیات دریافت یا ارسالی برای اجرا نداشته باشند می توانید با استفاده از default از بلاک شدن برای همیشه جلوگیری کنید. و خیلی مهمه که بدانید وقتی دارید داخل select از default استفاده می کنید select از نوع non-blocking می شود. اگر شما داخل select از default استفاده نکنید ممکن است آن بخش کد شما مسدود شود تا زمانیکه یکی از case ها از کانال داده ای را دریافت کند تا ادامه عملیات صورت گیرد.\nبه مثال زیر توجه کنید :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 ch1 := make(chan string) 7 select { 8 case msg := \u0026lt;-ch1: 9 fmt.Println(msg) 10 default: 11 fmt.Println(\u0026#34;Default statement executed\u0026#34;) 12 } 13} 1$ go run main.go 2Default statement executed در کد فوق ما یک کانال ایجاد کردیم و دریافت داده از کانال را داخل یکی از case های select قرار دادیم و پس از آن default را قرار دادیم که از مسدود شدن برنامه جلوگیری کند.\n3.7.3 مسدود سازی select با استفاده از timeout # شما می توانید یک select را با استفاده از timeout بطور موقت تا یک بازده زمانی مسدود کنید. که اینکار توسط تابع After داخل پکیج time صورت میگیرد.\n1func After(d Duration) \u0026lt;-chan Time تابع After یک مدت زمان میگیرد و سپس به عنوان خروجی یک کانال فقط دریافت از نوع Time برمیگرداند.\nبه مثال زیر توجه کنید :\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;time\u0026#34; 6) 7 8func main() { 9\tch1 := make(chan string) 10\tgo goOne(ch1) 11 12\tselect { 13\tcase msg := \u0026lt;-ch1: 14\tfmt.Println(msg) 15\tcase \u0026lt;-time.After(time.Second * 1): 16\tfmt.Println(\u0026#34;Timeout\u0026#34;) 17\t} 18} 19 20func goOne(ch chan string) { 21\ttime.Sleep(time.Second * 2) 22\tch \u0026lt;- \u0026#34;From goOne goroutine\u0026#34; 23} 1$ go run main.go 2Timeout کد کد فوق ما در یکی از case های select تابع After را به عنوان کانال دریافت کننده قرار دادیم و سپس مقدار ۱ ثانیه به تابع After پاس دادیم و پس از ۱ ثانیه select از مسدودی خارج شد.\n3.7.4 select خالی # یک select خالی و بدون case می تواند برنامه شما بطور کلی بلاک کند و باعث بروز خطای deadlock شود. اگر select خالی داخل یک گوروتین دیگری قرار گیرد آن گوروتین بطور کلی برای همیشه بلاک خواهد شد اما اگر داخل تابع main قرار دهید باعث بروز deadlock خواهد شد.\n1package main 2 3func main() { 4 select {} 5} 1$ go run main.go 2fatal error: all goroutines are asleep - deadlock! 3.7.5 استفاده از select در حلقه بینهایت # ما می توانیم select را داخل یک حلقه بینهایت قرار دهیم تا برای همیشه از case ها چندتا داده بواسطه کانال دریافت کنیم و عملیاتی را انجام دهیم یا اینکه اگر قصد داریم که از هر یک از case ها داده ای را دریافت کردیم حلقه را متوقف کنیم اینکار را هم بواسطه return می توانیم انجام دهیم.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;time\u0026#34; 6) 7 8func main() { 9\tnews := make(chan string) 10\tgo newsFeed(news) 11 12\tprintAllNews(news) 13} 14 15func printAllNews(news chan string) { 16\tfor { 17\tselect { 18\tcase n := \u0026lt;-news: 19\tfmt.Println(n) 20\tcase \u0026lt;-time.After(time.Second * 1): 21\tfmt.Println(\u0026#34;Timeout: News feed finished\u0026#34;) 22\treturn 23\t} 24\t} 25} 26 27func newsFeed(ch chan string) { 28\tfor i := 0; i \u0026lt; 2; i++ { 29\ttime.Sleep(time.Millisecond * 400) 30\tch \u0026lt;- fmt.Sprintf(\u0026#34;News: %d\u0026#34;, i+1) 31\t} 32} 1$ go run main.go 2News: 1 3News: 2 4Timeout: News feed finished در کد فوق ما یک کانال بافر نشده با نام news ایجاد کردیم و این کانال را داخل گوروتین newsFeed و تابع printAllNews قرار دادیم. تابع newsFeed یک مقداری را به کانال ارسال می کند. و ما داخل تابع printAllNews بواسطه حلقه بینهایت و select دریافت می کنیم و یکی از case های select عملیات timeout را دارد که بعد ۱ ثانیه حلقه را کاملا متوقف کند.\n3.7.6 select با یک کانال nil # معمولا اگر یک کانال nil را برای ارسال یا دریافت داخل case قرار دهید برنامه شما همیشه بلاک می شود. اگر شما داخل یکی از case ها بیاید پس از انجام عملیات مقدار یک کانال را nil بزارید case ای که مقدار داخل کانال را دریافت می کند غیرفعال می شود و به هیچ عنوان دیگر قابل استفاده نخواهد بود. و توسط select آن case کاملا نادیده گرفته خواهد شد و select منتظر دریافت و ارسال داده از سایر case ها خواهد بود.\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;time\u0026#34; 6) 7 8func main() { 9 news := make(chan string) 10 go newsFeed(news) 11 printAllNews(news) 12} 13 14func printAllNews(news chan string) { 15 for { 16 select { 17 case n := \u0026lt;-news: 18 fmt.Println(n) 19 news = nil 20 case \u0026lt;-time.After(time.Second * 1): 21 fmt.Println(\u0026#34;Timeout: News feed finished\u0026#34;) 22 return 23 } 24 } 25} 26 27func newsFeed(ch chan string) { 28 for i := 0; i \u0026lt; 2; i++ { 29 time.Sleep(time.Millisecond * 400) 30 ch \u0026lt;- fmt.Sprintf(\u0026#34;News: %d\u0026#34;, i+1) 31 } 32} 1$ go run main.go 2News: 1 3Timeout: News feed finished در کد فوق ما داخل case n := \u0026lt;-news پس از اینکه مقدار دریافتی را چاپ کردیم اومدی مقدار کانال news را برابر nil قرار دادیم. حال داده ای به اون کانال ارسال شود دیگر نمی توانیم دریافت کنیم و select آن case را بطور کلی نادیده میگیرد.\n1case n := \u0026lt;-news: 2 fmt.Println(n) 3 news = nil 3.7.7 استفاده از break در select # شما می توانید break داخل هر یک از case های select استفاده کنید.\n1import \u0026#34;fmt\u0026#34; 2 3func main() { 4\tch := make(chan string, 1) 5\tch \u0026lt;- \u0026#34;Before break\u0026#34; 6 7\tselect { 8\tcase msg := \u0026lt;-ch: 9\tfmt.Println(msg) 10\tbreak 11\tfmt.Println(\u0026#34;After break\u0026#34;) 12\tdefault: 13\tfmt.Println(\u0026#34;Default case\u0026#34;) 14\t} 15} 1$ go run main.go 2Before break در کد فوق ما با استفاده از break توانستیم select را کاملا متوقف کنیم و برنامه اتمام شود و اگر دقت کرده باشید بعد از break کلمات After break چاپ نشده.\n1fmt.Println(\u0026#34;After break\u0026#34;) "},{"id":39,"href":"/chapter-3/go-context/","title":"3.8 پکیج context","section":"فصل سوم: همزمانی (concurrency)","content":" پکیج context که یک پکیج built-in هست یکی از پرکاربرد ترین پکیج ها می باشد. که اگر شما حتی نخواسته باشید سمت این پکیج بروید به مرور زمان وقتی که جلوتر بروید با این پکیج رو به رو خواهید شد و مجبور خواهید بود این پکیج را یاد بگیرید.\nاین پکیج چندان بزرگ نیست شاید بتوانید توابع و چیزهایی که داخلش هست را زود یادبگیرید اما دقت کنید یک روزی این پکیج میشه بنیادی ترین قسمت از کدهایتان که باهاش کار میکنید.\nنگران نباشید در این بخش از کتاب شما با سادگی با این پکیج رو به رو خواهید شد و خیلی راحت می توانید درک کنید که باید با این پکیج چکار کنید.\n3.8.1 context چیست؟ # در واقع context مانند یک درخت می باشد که کلی شاخه دارد و هر شاخه به شاخه های ریزتری تقسیم شده و در نهایت به برگ ها و میوه های درخت منتهی می شوند. حال شما می توانید در هر ناحیه شاخه والد را قطع کنید تا شاخه های فرزند از بین برود. در زبان گو context یک اینترفیس است که یکسری متد دارد که هریک از متدها می تواند عملیاتی را انجام دهد و این امکان را فراهم می کند هر وقت یک درخواست از سمت کلاینت به سرور می آید این درخواست می تواند در لایه های مختلف منتهی شود و داخل context می تواند یکسری key/value های مهم باشد که شما می توانید در هر لایه دسترسی داشته باشید و هچنین می توانید سیگنال cancel بفرستید که درخواستی که تا هرجا رفته اس کنسل شود.\nحال بزارید یک مثال ساده به زبان گو بزنیم و تا کمی راحتر در کنید.\nشما فرض کنید یک کلاینت به سرور http راه اندازی کردید (در فصل ۵ آشنا خواهید شد) که یکسری آدرس API دارد که کلاینت می تواند با استفاده از این آدرس ها با سرور شما ارتباط برقرار کند و یک عملیاتی را انجام دهد. حال وقتی کلاینت درخواست می دهد. درخواست تا زمانیکه کامل شود و خروجی به کاربر نمایش داده شود می توانید این درخواست را بواسطه context در لایه های مختلف پروژه خود منتهی کنی و یکسری عملیات یا اطلاعات را در هر لایه از context بگیرید. اگر به دیاگرام فوق نگاه کنید اگر کلاینت درخواستش را لغو کند و درخواست کاربر به واسط context تا لایه Manager رفته باشد می تواند این درخواست در همان لایه متوقف شود و عملیات تکمیل نشود.\nبرای درک بهتر مثال فوق بهتره فایل صوتی زیر را گوش دهید تا بهتر بتوانید درک کنید :\n3.8.1.1 کاربردهای context # لغو یک درخواستی که منتهی شده به لایه های مختلف پروژه بواسطه تابع cancel در پکیج context انتقال داده های حساس به لایه های مختلف بواسطه تابع WithValue در پکیج context گذاشتن timeout برروی context جهت لغو درخواستی که خیلی باعث منتظر ماندن می شود بواسطه تابع WithTimeout در پکیج context 3.8.1.2 معرفی اینترفیس context # بدنه اصلی یک context از اینترفیس تشکیل شده که یکسری متدها برای مدیریت یک درخواست برروی لایه های مختلف را دارد.\n1type Context interface { 2 //It retures a channel when a context is cancelled, timesout (either when deadline is reached or timeout time has finished) 3 Done() \u0026lt;-chan struct{} 4 5 //Err will tell why this context was cancelled. A context is cancelled in three scenarios. 6 // 1. With explicit cancellation signal 7 // 2. Timeout is reached 8 // 3. Deadline is reached 9 Err() error 10 11 //Used for handling deallines and timeouts 12 Deadline() (deadline time.Time, ok bool) 13 14 //Used for passing request scope values 15 Value(key interface{}) interface{} 16} متد Done : بواسطه این متد که یک کانال فقط دریافت است شما می توانید سیگنال توقف درخواست را دریافت کنید و خطا برگردانید. متد Err : داخل این متد اینترفیس خطا وجود دارد که خطاهای مربوط به context را می توانید دریافت و مدیریت کنید. متد Deadline : با استفاده از این متد می توانید context هایی که از نوع Deadline هستند را مدیریت کنید. متد Value : با استفاده از این می توانید مقادیری که بصورت key/value داخل context ذخیره شده را دریافت کنید که بصورت اینترفیس یک key میگیرد و به صورت اینترفیس مقدار داخل key را برمیگرداند. 3.8.2 ایجاد یک context # شما با استفاده از ۲ تابع داخل پکیج context می توانید اولین context خام را ایجاد کنید و در واقع این context ایجاد شده می تواند والد تمامی context هایی که در لایه مختلف ایجاد کردید باشد.\nبرای ایجاد context گفتیم ۲ تابع وجود دارد که به شرح زیر می باشد :\ncontext.Background() : # داخل پکیج context ما یک تابع داریم به نام Background یک اولین context خام و والد را میسازد و به شما یک اینترفیس از نوع Context می دهد.\nاین context ایجاد شده هیچ مقداری داخلش ندارد. هیچ وقت نمی تواند کنسل شود. و هیچ deadline ندارد. در هر صورت بدانید ریشه اصلی context شما با این تابع ایجاد می شود و نقطه شروع انتقال یک درخواست بین لایه هایتان با این context والد خواهد بود.\n1func Background() Context context.ToDo() : # داخل پکیج context ما یک تابع داریم به نام ToDo که یک context خالی ایجاد می کند و هدف از این context ایجاد شده با ToDo این است هنوز برایمان مشخص نیست چکار میخوایم انجام بدیم با context می توانیم از این تابع استفاده کنیم. و معمولا برای تست ها و اعتبارسنجی و آنالیز کد خیلی کاربردی هست.\nو دقت کنید در پایه اصلی پروژه اتون بهتره از Background همیشه استفاده کنید.\n1func TODO() Context 3.8.3 درخت Context # در واقع context خام یا ریشه که بواسطه تابع Background یا ToDo ایجاد می شود همانند یک درخت است که قرار است این درخت به شاخه های ریزتری تقسیم شود و هر یک از شاخه ها عملیات مختلفی کنترل شود و به شاخه های دیگر منتقل شود.\n3.8.3.1 ایجاد یک فرزند برای context # شما خیلی ساده مانند کد زیر می توانید یک فرزند برای درخت خود ایجاد کنید :\n1rootCtx := context.Background() 2childCtx := context.WithValue(rootCtx, \u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;) در کد فوق ما یک rootCtx ایجاد کردیم که همان درخت است و سپس اومدیم با استفاده از تابع WithValue یک شاخه ایجاد کردیم که داخل این شاخه یک key/value قرار دارد. که این key/value در لایه های دیگر که منتقل می شود قرار دارد.\n3.8.3.2 ایجاد دو فرزند برای context # 1rootCtx := context.Background() 2childCtx := context.WithValue(rootCtx, \u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;) 3childOfChildCtx, cancelFunc := context.WithCancel(childCtx) در کد فوق :\nrootCtx درخت است childCtx فرزند اول است که با استفاده از WithValue ایجاد شده و یک مقدار key/value را نگه داری می کند. childOfChildCtx برای فرزند اول context ما یک فرزند دیگری ایجاد کردیم با استفاده از تابع WithCancel که این تابع به شما یک context و یک تابع از نوع cancelFunc برمیگرداند. 3.8.3.3 درخت چند سطحی # 1rootCtx := context.Background() 2childCtx1 := context.WithValue(rootCtx, \u0026#34;key1\u0026#34;, \u0026#34;value1\u0026#34;) 3childCtx2, cancelFunc := context.WithCancel(childCtx1) 4childCtx3 := context.WithValue(rootCtx, \u0026#34;user_id\u0026#34;, \u0026#34;some_user_id\u0026#34;) در کد فوق :\nrootCtx درخت است childCtx1 فرزند اول است که با استفاده از WithValue ایجاد شده و یک مقدار key/value را نگه داری می کند. childCtx2 برای فرزند اول context ما یک فرزند دیگری ایجاد کردیم با استفاده از تابع WithCancel که این تابع به شما یک context و یک تابع از نوع cancelFunc برمیگرداند. childCtx3 با استفاده از WithValue از rootCtx که درخت است تشکیل شده حالا اگر ما برای childCtx1 بیایم یک فرزند دیگر با نام childCtx4 اضافه کنیم بصورت زیر خواهد شد :\n1childCtx4 := context.WithValue(childCtx1, \u0026#34;current_time\u0026#34;, \u0026#34;some_time) 3.8.4 تابع context.WithValue # همانطور که گفتیم شما با استفاده از تابع WithValue می توانید مقادیری را بصورت key/value به context اضافه کنید و سپس این مقادیر را با استفاده از context به لایه های مختلف منتقل کنید.\n1withValue(parent Context, key, val interface{}) (ctx Context) دقت کنید شما می توانید بواسطه context.WithValue مقادیر خیلی مهم و حساس نظیر توکن ها و \u0026hellip; را به لایه های مختلف خود منتقل کنید و این مورد خیلی قابل اهمیت است با استفاده از context انجام دهید. 1// Root Context 2ctxRoot := context.Background() 3 4// Below ctxChild has acess to only one pair {\u0026#34;a\u0026#34;:\u0026#34;x\u0026#34;} 5ctxChild := context.WithValue(ctxRoot, \u0026#34;a\u0026#34;, \u0026#34;x\u0026#34;) 6 7// Below ctxChildofChild has access to both pairs {\u0026#34;a\u0026#34;:\u0026#34;x\u0026#34;, \u0026#34;b\u0026#34;:\u0026#34;y\u0026#34;} as it is derived from ctxChild 8ctxChildofChild := context.WithValue(ctxChild, \u0026#34;b\u0026#34;, \u0026#34;y\u0026#34;) در بالا ما یک ctxRoot ایجاد کردیم و سپس یک فرزند با استفاده از تابع WithValue ایجاد کردیم که یک مقدار از نوع key/value با نام a را داخل context فرزند قرار دادیم. حالا برای context فرزند مجدد با استفاده از WithValue یک فرزند دیگری ایجاد کردیم که یک مقدار دیگر از نوع key/value با نام b قرار دادیم حالا اگر دقت کنید ctxChildofChild دارای ۲ مقدار a و b هستش.\nبزارید یک مثال ساده بزنیم :\n1package main 2 3import ( 4\t\u0026#34;context\u0026#34; 5\t\u0026#34;fmt\u0026#34; 6) 7 8func main() { 9\tctx := context.WithValue(context.Background(), \u0026#34;language\u0026#34;, \u0026#34;Go\u0026#34;) 10 11\tfmt.Println(manager(ctx, \u0026#34;language\u0026#34;)) 12} 13 14func manager(ctx context.Context, key string) string { 15\tif v := ctx.Value(key); v != nil { 16\treturn v.(string) 17\t} 18\treturn \u0026#34;not found value\u0026#34; 19} 1$ go run main.go 2Go در کد فوق ما یک context ایجاد کردیم و داخلش با استفاده از WithValue مقدار key/value قرار دادیم و سپس این context را تابع manager پاس دادیم و داخل تابع manager ما با استفاده از متد Value که داخل اینترفیس ctx هست مقدار کلید language را گرفتیم.\nنکته کاربردی و مهم همیشه سعی کنید context را به عنوان اولین پارامتر برای توابع تعریف کنید. و بهتر است برای نام پارامتر ctx یا c بزارید. 3.8.5 تابع context.WithCancel # زمانیکه شما با استفاده از تابع WithCancel یک context فرزند ایجاد می کنید ۲ تا خروجی به شما می دهد اولی context و دومی تابع cancel می باشد. که شما می توانید تابع cancel را برای لغو درخواستی که از سمت کلاینت یا لایه های بالاتر اومده را انجام دهید.\n1type CancelFunc func() 2 3func WithCancel(parent Context) (ctx Context, cancel CancelFunc) حالا سعی با استفاده از مثال زیر بحث لغو کردن را درک کنید :\n1package main 2 3import ( 4 \u0026#34;context\u0026#34; 5 \u0026#34;fmt\u0026#34; 6 \u0026#34;time\u0026#34; 7) 8 9func main() { 10 ctx := context.Background() 11 cancelCtx, cancelFunc := context.WithCancel(ctx) 12 go task(cancelCtx) 13 time.Sleep(time.Second * 3) 14 cancelFunc() 15 time.Sleep(time.Second * 1) 16} 17 18func task(ctx context.Context) { 19 i := 1 20 for { 21 select { 22 case \u0026lt;-ctx.Done(): 23 fmt.Println(\u0026#34;Gracefully exit\u0026#34;) 24 fmt.Println(ctx.Err()) 25 return 26 default: 27 fmt.Println(i) 28 time.Sleep(time.Second * 1) 29 i++ 30 } 31 } 32} 1$ go run main.go 21 32 43 5Gracefully exit 6context canceled در کد فوق ما یک context فرزند با استفاده از WithCancel ایجاد کردیم که به عنوان خروجی cancelCtx و cancelFunc را داد. سپس cancelCtx را به تابع task منتقل کردیم تا عملیاتی را انجام دهد. حال در ادامه کد تابع main ما یک Sleep در حد ۳ ثانیه گذاشتیم و گفتیم تابع cancelFunc اجرا شود. اگر دقت کنید پس ۳ ثانیه سیگنال لغو به تابع task ارسال شده و خطای Gracefully exit را چاپ کردیم و پس از آن خطای context چاپ کردیم.\nنکته کاربردی و مهم همیشه سعی کنید تابع cancelFunc را پس از اینکه context فرزند را با WithCancel ایجاد کردید داخل defer قرار دهید.\n1ctx := context.Background() 2cancelCtx, cancelFunc := context.WithCancel(ctx) 3defer cancelFunc() 3.8.6 تابع context.WithTimeout # تابع WithTimeout یکی از کاربردی ترین context ها را برای ما ایجاد میکند و باعث می شود جلوی طول کشید یک درخواست خارجی یا عملیاتی را بگیرد و درخواست را لغو کند. این تابع همانند تابع WithCancel به شما تابع cancelFunc را می دهد و در عوض از شما یک مدت زمان را میگیرد.\n1func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) بزارید یک مثال ساده بزنیم :\n1package main 2 3import ( 4 \u0026#34;context\u0026#34; 5 \u0026#34;fmt\u0026#34; 6 \u0026#34;time\u0026#34; 7) 8 9func main() { 10 ctx := context.Background() 11 cancelCtx, cancel := context.WithTimeout(ctx, time.Second*3) 12 defer cancel() 13 go task1(cancelCtx) 14 time.Sleep(time.Second * 4) 15} 16 17func task1(ctx context.Context) { 18 i := 1 19 for { 20 select { 21 case \u0026lt;-ctx.Done(): 22 fmt.Println(\u0026#34;Gracefully exit\u0026#34;) 23 fmt.Println(ctx.Err()) 24 return 25 default: 26 fmt.Println(i) 27 time.Sleep(time.Second * 1) 28 i++ 29 } 30 } 31} 1$ go run main.go 21 32 43 5Gracefully exit 6context deadline exceeded در کد فوق ما یک context فرزند با استفاده از تابع WithTimeout ایجاد کردیم و مدت زمان ۳ ثانیه به این تابع پاس دادیم و پس از آن context فرزند به همراه تابع cancelFunc دریافت کردیم. حالا تابع cancel را داخل defer قرار دادیم و cancelCtx را به تابع task1 که داخل گوروتین است پاس دادیم. و یک Sleep به مدت ۴ ثانیه گذاشتیم تابع main کارش اتمام نشود. حال پس از اینکه ۳ ثانیه گذشت داخل select سیگنال cancel را دریافت کردیم و خطای context deadline exceeded که نشان دهنده اتمام شدن مدت زمان هست را چاپ کردیم. و همانطور که متوجه شدید درخواست کلی ما لغو شدش.\n3.8.7 تابع context.WithDeadline # تابع WithDeadline تا حدی شبیه به WithTimeout است اما با این تفاوت که پارامتر زمانی که میگیرد از نوع time.Time است و مدت زمانی که میگیرد براساس تایم هست مثلا شما میگید ۵ ثانیه بعد از زمان الان درخواست را لغو کند در صورتیکه withTimeout مدت زمان میگیرد که درخواست ۵ ثانیه مهلت دارد کارش را اتمام کند.\n1func WithDeadline(parent Context, d time.Time) (Context, CancelFunc) به مثال زیر توجه کنید :\n1package main 2 3import ( 4 \u0026#34;context\u0026#34; 5 \u0026#34;fmt\u0026#34; 6 \u0026#34;time\u0026#34; 7) 8 9func main() { 10 ctx := context.Background() 11 cancelCtx, cancel := context.WithDeadline(ctx, time.Now().Add(time.Second*5)) 12 defer cancel() 13 go task(cancelCtx) 14 time.Sleep(time.Second * 6) 15} 16 17func task(ctx context.Context) { 18 i := 1 19 for { 20 select { 21 case \u0026lt;-ctx.Done(): 22 fmt.Println(\u0026#34;Gracefully exit\u0026#34;) 23 fmt.Println(ctx.Err()) 24 return 25 default: 26 fmt.Println(i) 27 time.Sleep(time.Second * 1) 28 i++ 29 } 30 } 31} 1$ go run main.go 21 32 43 54 65 7Gracefully exit 8context deadline exceeded در کد فوق یک context فرزند با استفاده از تابع WithDeadline ایجاد کردیم و سپس با توجه به زمان فعلی مدت زمان ۵ ثانیه بعد را درنظر گرفتیم که مثلا اگر الان ساعت است 10:45:30 درخواست را در 10:45:35 لغو کند.\n3.8.8 نکات کاربردی # هیچوقت سعی نکنید اینترفیس context را داخل یک ساختار ذخیره کنید اما می توانید embed کنید. همیشه context باید بین لایه های خود منتقل کنید تا بتوانید کنترل بهتری برروی درخواست ها داشته باشید. همیشه سعی کنید context را به عنوان اولین پارامتر توابع قرار دهید. نام context به عنوان پارامتر توابع بهتر است ctx یا c باشد. اگر هنوز مطمئن نیستید که با context چکاری میخواهید انجام دهید بهتر است context را با context.ToDo ایجاد کنید. توجه کنید فقط تابعی که context والد را ایجاد کرده می تواند درخواست را لغو کند پس سعی نکنید تابع cancelFunc را به توابع زیرین پاس دهید. "},{"id":40,"href":"/chapter-3/go-concurrency-teqniques/","title":"3.9 تکنیک های همزمانی","section":"فصل سوم: همزمانی (concurrency)","content":" 3.9.1 ارسال سیگنال انجام شدن با کانال ساختار # شما می توانید با استفاده از کانال struct یک سیگنال تکمیل شدن انجام یک کار را بفرستید.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;time\u0026#34; 6) 7 8func task1(done chan struct{}) { 9\t// Do some work here 10\tfmt.Println(\u0026#34;doing task 1\u0026#34;) 11 12\ttime.Sleep(2 * time.Second) 13 14\tfmt.Println(\u0026#34;task 1 has been completed\u0026#34;) 15\tdone \u0026lt;- struct{}{} 16} 17 18func task2(done \u0026lt;-chan struct{}) { 19\tselect { 20\tcase \u0026lt;-done: 21\t// Do some work here 22\tfmt.Println(\u0026#34;doing task 2\u0026#34;) 23\ttime.Sleep(2 * time.Second) 24\tfmt.Println(\u0026#34;task 2 has been completed\u0026#34;) 25\t} 26} 27 28func main() { 29\tdone := make(chan struct{}) 30 31\tgo task1(done) 32\tgo task2(done) 33 34\ttime.Sleep(5 * time.Second) 35\tfmt.Println(\u0026#34;all tasks has been completed\u0026#34;) 36} 1$ go run main.go 2doing task 1 3task 1 has been completed 4doing task 2 5task 2 has been completed 6all tasks has been completed در کد فوق ما دو تابع به نام task1 و task2 داریم که داخل گوروتین هستند و به عنوان پارامتر ورودی یک کانال ساختار خالی میگیرد حال کانال ساختار را به هر دو تابع پاس دادیم در ابتدا task1 فرآیند خود را انجام می دهد و سپس سیگنال انجام شدن را می فرستد و در ادامه تابع task2 سیگنال را دریافت می کند و فرآیندهای خود را انجام می دهد.\nدر زبان گو شما وقتی یک struct کاملا خالی و بدون فیلد میسازید هیچ تخصیص حافظه برایش صورت نمیگیرد. 3.9.2 بررسی یک سرویس یا فرآیند با heartbeat # شما با استفاده از همزمانی می توانید یک heartbeat پیاده سازی کنید تا یک سرویس یا فرآیند را بطور مداوم طی بازده زمانی مشخصی زیر نظر داشته باشد و از وضعیت آن سرویس یا فرآیند به شما اطلاع دهد.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;time\u0026#34; 6) 7 8func heartbeat(interval time.Duration, c chan\u0026lt;- struct{}) { 9 ticker := time.NewTicker(interval) 10\tfor { 11\tselect { 12\tcase \u0026lt;-ticker.C: 13\tc \u0026lt;- struct{}{} 14\t} 15\t} 16} 17 18func task() { 19\t// Do some work here 20\tfmt.Println(\u0026#34;Task running...\u0026#34;) 21} 22 23func main() { 24\tc := make(chan struct{}) 25\tgo heartbeat(1*time.Second, c) 26 27\tfor { 28\tselect { 29\tcase \u0026lt;-c: 30\ttask() 31\t} 32\t} 33} 1$ go run main.go 2Task running... 3Task running... 4Task running... 5Task running... در کد فوق ما یک تابع به نام heartbeat ایجاد کردیم که طی مدت زمانی یک سیگنال می فرستد تا تابع task اجرا شود که وضعیت فرآیند یا سرویس را گزارش دهد. ما مدت زمان را ۱ ثانیه گذاشتیم و یک کانال ساختار ایجاد کردیم و به تابع heartbeat که داخل یک گوروتین هست پاس دادیم سپس هر ۱ ثانیه از طریق کانال c ما سیگنال اجرای task برای بررسی وضعیت سرویس یا فرآیند را دریافت میکنیم.\n3.9.3 ارسال درخواست های تکراری به سرور یا سرویسی # فرض کنید شما نیاز دارید به یک سرور یا سرویسی چندین درخواست تکراری را بصورت موازی بفرستید حال اینجا شما می توانید که به اینکار replicated requests می گویند.\nبه مثال زیر توجه کنید :\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;net/http\u0026#34; 6) 7 8func makeRequest(url string, c chan\u0026lt;- *http.Response) { 9 resp, err := http.Get(url) 10 if err != nil { 11 c \u0026lt;- nil 12 } else { 13 c \u0026lt;- resp 14 } 15} 16 17func main() { 18 urls := []string{\u0026#34;http://example.com\u0026#34;, \u0026#34;http://example.org\u0026#34;, \u0026#34;http://example.net\u0026#34;} 19 20 c := make(chan *http.Response) 21 defer close(c) 22 for _, url := range urls { 23 go makeRequest(url, c) 24 } 25 26 for i := 0; i \u0026lt; len(urls); i++ { 27 resp := \u0026lt;-c 28 if resp == nil { 29 fmt.Println(\u0026#34;Error making request\u0026#34;) 30 } else { 31 fmt.Println(resp.Status) 32 } 33 } 34} 1$ go run main.go 2200 OK 3200 OK 4200 OK در کد فوق ما یک تابع makeRequest داریم که ۲ تا پارامتر ورودی دارد اولین پارامتر url میگیرد و دومین پارامتر یک کانال فقط ارسال از نوع http.Response* میگیرد. سپس یک ریکوئست با متد GET ایجاد میکند و خروجی را داخل کانال میفرستد. در تابع main ما یک لیست url داریم که قرار است بصورت موازی به این آدرس ها درخواست بفرستیم و خروجی را دریافت کنیم در اینجا یک کانال از نوع http.Response* ایجاد کردیم و سپس یک حلقه for-range قرار دادیم به ازای هر یک از url ها تابع makeRequest را فراخوانی کردیم و داخل گوروتین قرار دادیم. در نهایت یک حلقه for-i داریم که به تعداد url ها شمارش میکند و از طریق کانال رسپانس را دریافت می کند.\n3.9.4 بازیابی سلامتی یک گوروتین # در برنامه نویسی همزمانی خیلی مهم است شما به سلامتی یک گوروتین رسیدگی کنید که اگر گوروتین قادر به انجام کاری نیست مجدد بتوانید سلامتی گوروتین را بازیابی کنید. در زبان گو شما می توانید با استفاده از پکیج context گوروتین هایی که وضعیت سالمی ندارد را با راه اندازی مجدد سلامتی آنها را بازیابی کنید.\n1package main 2 3import ( 4\t\u0026#34;context\u0026#34; 5\t\u0026#34;fmt\u0026#34; 6\t\u0026#34;time\u0026#34; 7) 8 9func unhealthyGoroutine(ctx context.Context) { 10\tfor { 11\tselect { 12\tcase \u0026lt;-ctx.Done(): 13\tfmt.Println(\u0026#34;Goroutine is unhealthy, exiting\u0026#34;) 14\treturn 15\tdefault: 16\t// Do some work here 17\tfmt.Println(\u0026#34;Goroutine running...\u0026#34;) 18\ttime.Sleep(500 * time.Millisecond) 19\t} 20\t} 21} 22 23func main() { 24\tctx, cancel := context.WithTimeout(context.Background(), 3*time.Second) 25\tdefer cancel() 26 27\tfor { 28\tgo unhealthyGoroutine(ctx) 29\t\u0026lt;-time.After(4 * time.Second) 30\t} 31} 1$ go run main.go 2Goroutine running... 3Goroutine running... 4Goroutine running... 5Goroutine running... 6Goroutine running... 7Goroutine running... 8Goroutine is unhealthy, exiting 9Goroutine is unhealthy, exiting 10Goroutine is unhealthy, exiting 11Goroutine is unhealthy, exiting 12Goroutine is unhealthy, exiting 13Goroutine is unhealthy, exiting در کد فوق ما یک تابع به نام unhealthyGoroutine داریم که بصورت جداگانه در گوروتین های مختلف اجرا می شود و کاری را انجام می دهد. داخل تابع ما یک select داریم که در یکی از case هایش context.Done را بررسی میکنیم آیا فرآیند لغو شده است یا خیر. داخل تابع main ما یک context از نوع Timeout با مدت زمان ۳ ثانیه ای ایجاد کردیم و در ادامه داخل یک حلقه بینهایت تابع unhealthyGoroutine داخل گوروتین قرار دادیم و هر ۴ ثانیه یک نمونه از این تابع داخل گوروتین های مختلف اجرا می شود.\nدر اینجا کارهای داخل تابع unhealthyGoroutine انجام شود پس از ۳ ثانیه بواسطه context فرآیندها لغو می شود و از گوروتین خارج می شود. حال ما داخل تابع main اجازه دادیم یک گوروتین جدید و سالم را اجرا کند و جایگزین گوروتین ناسالم شود.\n3.9.5 پیاده سازی الگوریتم فیبوناچی با همزمانی # دنباله فیبوناچی مجموعه ای از اعداد است که در آن هر عدد حاصل جمع دو عدد قبلی است که معمولا با 0 و 1 شروع می شود. ، 55، 89، 144 و غیره. دنباله فیبوناچی به نام ریاضیدان ایتالیایی، لئوناردو پیزا، که به فیبوناچی نیز معروف بود، نامگذاری شده است. الگوریتم فیبوناچی روشی برای محاسبه عدد n در دنباله فیبوناچی است. روش‌های مختلفی برای پیاده‌سازی الگوریتم فیبوناچی وجود دارد، اما رایج‌ترین روش استفاده از بازگشت است.\nدر علوم و مهندسی کامپیوتر، از دنباله فیبوناچی برای تحلیل عملکرد الگوریتم هایی مانند برج هانوی و تکنیک جستجوی فیبوناچی استفاده می شود.\nدر زیر ما برای اینکه بتوانید در سریعترین حالت ممکن محاسبات را انجام دهیم خیلی ساده می توانیم از همزمانی و کانال استفاده کنیم و در کسری از ثانیه محاسبه کنیم.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7func fibo(n int) \u0026lt;-chan int { 8\tresult := make(chan int) 9\tgo func() { 10\tdefer close(result) 11 12\tif n \u0026lt;= 2 { 13\tresult \u0026lt;- 1 14\treturn 15\t} 16 17\tresult \u0026lt;- \u0026lt;-fibo(n-1) + \u0026lt;-fibo(n-2) 18 19\t}() 20 21\treturn result 22} 23 24func main() { 25\tfmt.Println(\u0026lt;-fibo(25)) 26} 1$ go run main.go 275025 "},{"id":41,"href":"/chapter-3/go-concurrency-patterns/","title":"3.10 الگو های همزمانی","section":"فصل سوم: همزمانی (concurrency)","content":"الگو های همزمانی را در فصل ۹ در کنار سایر الگوهای طراحی قرار دادیم یک مرجع کامل از الگوهای طراحی برای زبان گو داشته باشیم. در این بخش فقط ما خلاصه توضیحی در خصوص الگوها قرار دادیم و شما را ارجاع می دهیم به صفحه الگو :\nعنوان توضیحات وضعیت Wait For Result با استفاده از الگو Wait For Result می توانید یک عملیاتی را بصورت همزمانی انجام دهید و سپس منتظر نتیجه عملیات صورت گرفته بمانید. برای اینکار از کانال استفاده می شود. ✅ Fan Out/In الگو Fan Out/In یک تکنیک همزمانی در زبان گو می باشد که به شما اجازه می دهد چندین کار را با گوروتین همزمان انجام دهید و در نتیجه خروجی این کارها را با هم ترکیب کنید و به عنوان نتیجه نهایی دریافت کنید. ✅ Wait For Task الگو wait for task یکی از الگوهای رایج در زبان گو می باشد و انتظار برای تکمیل یک تسک یا فرآیند استفاده می شود. یک تسک با استفاده از گوروتین اجرا می شود و پس اتمامش کار تسک از طریق کانال سیگنال انجام می فرستد. ✅ Drop الگو Drop یک الگو مهم برای انجام خدمات سنگین می باشد. خدماتی که مواقعی باعث می شود حجم درخواست هایش بیش از ظرفیت موجود باشد و این درخواست ها بواسطه این الگو می تواند Drop شود. به عنوان مثال سرویس های DNS باید از این الگو استفاده کنند. ✅ Cancellation الگو cancellation که حرکت تکنیکی هست برای ارسال سینگال به گوروتین ها استفاده می شود که باید اجرای کاری را متوقف کند و ایده اصلی این کار با استفاده بستن کانال صورت میگیرد. ✅ Semaphore الگو Semaphore برای مدیریت کنترل دسترسی به منابع مشترک در همزمانی استفاده می شود. فرض کنید بصورت موازی ۱۰۰ درخواست HTTP سمت سرور میاد و I/O شبکه برای پردازش همزمان این ۱۰۰ درخواست درگیر میشود و به مرور عملکرد کاهش می یابد. حال اگر ما بیایم این ۱۰۰ درخواست موازی را تقسیم کنیم به ۵ دسته ۲۰ تایی که بصورت همزمانی انجام شود باعث می شود I/O شبکه کاهش یابد و عملکرد بهتری را خواهیم داشت. ✅ Bounded Work Pooling با استفاده از الگو Bounded Work Pooling امکان محدود سازی تعداد گوروتین ها را براساس کار مشخصی دارید و گوروتین ها را محدود به تعداد دفعات کار مشخص شده محدود می شود. این الگو برای وقت مفید است که شما می خواهید منابع را به یک کار خاص محدود کنید. ✅ Retry Timeout شما از الگو Retry Timeout برای تلاش مجدد یکسری عملیات استفاده کنید. برای اینکار شما می توانید از حلقه و تابع After در پکیج time کمک بگیرید و برای هرتلاش یک timeout مشخص کنید. ✅ Channel Cancellation از کانال ها برای ارتباط بین گوروتین ها و هماهنگ کردن اجرا استفاده می شود. حال گاهی اوقات نیاز است که ما یکسری فرآیند را داخل گوروتین لغو کنیم. در اینجا می توانیم با استفاده از کانال سیگنال لغو کردن بفرستید تا عملیات هایی که گوروتین مورد نظر انجام می داد لغو شود. ✅ Producer-Consumer الگو producer-consumer یکی از کاربردی ترین الگوها در زبان گو می باشد که با استفاده از الگو می توانید بطور همزمان یکسری اطلاعات تولید کنید و بفرستید داخل کانال و این اطلاعات توسط مصرف کننده بواسطه کانال دریافت شود. ✅ Monitor الگوی مانیتور به گروتین‌ ها اجازه می‌دهد هنگام ورود به حالت خواب بدون مسدود کردن اجرا یا مصرف منابع، منتظر شرایط خاصی باشند. ✅ Future در زبان گو الگو Future راهی برای نمایش نتیجه یک عملیات ناهمزمان (asynchronous) است که ممکن است آن عملیات هنوز تکمیل نشده باشد اما این الگو به شما این امکان را می دهد کدی بنویسید که طوری رفتار کند که گویی نتیجه یک عملیات فورا در دسترس است. حتی اگر عملیات در پس زمینه در حال اجرا باشد. ✅ Pipeline الگو خط لوله (Pipeline) یکی از پرکاربردی ترین الگوها در همزمانی می باشد شما با استفاده از این الگو می توانید تسک های بزرگ را به تسک های کوچکتر و مستقل تقسیم کنید که می توانند بطور همزمان کار کنند. هر stage داخل یک گوروتین انجام می شود و بواسطه کانال داده ها بین stage های مختلف منتقل می شود. ✅ Subscription الگو Subscription یکی از الگوهای کاربردی برای پیاده سازی consumer می باشد که به یک آدرسی مشترک شوید و در بازده زمانی مختلف درخواست دهید و یکسری اطلاعات دریافت کنید. ✅ Bridge Channel با استفاده از الگو Bridge Channel می توانید بین ۲ کانال داده ای را منتقل کنید فرض کنید یک داده را به کانال input میفرستید و از دریافت داده آن را می توانید به کانال دیگری منتقل کنید و عملا شما یک پل برای انتقال داده ایجاد کردید. ✅ Queuing الگوی \u0026ldquo;صف\u0026rdquo; در زبان گو الگویی است که در آن از یک گوروتین برای بافر کردن و مدیریت ترتیب مقادیر ارسال شده و دریافت شده از یک کانال استفاده می شود. ✅ "},{"id":42,"href":"/chapter-4/","title":"فصل چهارم: مباحث پیشرفته","section":"صفحه اصلی","content":"در این فصل به مباحث پیشرفته زبان گو میپردازیم\u0026hellip;\n"},{"id":43,"href":"/chapter-4/build-go-file/","title":"4.1 آموزش Build پروژه","section":"فصل چهارم: مباحث پیشرفته","content":"برای build یک پروژه شما باید از کامند go build استفاده کنید که این کامند دارای یکسری سوییچ می باشد که در زیر ما معرفی خواهیم کرد.\n4.1.1 نحوه build یک فایل گو # معمولا شما باید برای build فایلی که دارای package main هست را برای build استفاده کنید مانند مثال زیر :\n1$ go build main,go پس از build در محل همان فایل یک فایل با نام main ایجاد می شود.\nاگر فایل main شما در روت پروژه باشد نیازی نیست به دستور go build نام فایل را بدهید کافیه مانند دستور زیر پروژه را build کنید.\n1$ go build . خروجی یک فایل با نام پروژه ایجاد می شود.\n4.1.2 استفاده از gcflags برای build # همانطور که گفتیم کامند build دارای یکسری سوییچ می باشد که یکی از سوییچ هایش gcflags می باشد که می توانید هنگام build یکسری اطلاعات مربوط به دیباگ به فایل خروجی اضافه می شود.\n1$ go build -gcflags \u0026#34;-N -l\u0026#34; main.go توجه کنید این نوع build گرفتن برای انجام Remote Debugging که در بخش بعدی آموزش می دهیم خیلی کاربردی می باشد.\n4.1.3 تعیین نام خروجی فایل, معماری و سیستم عامل # اگر یادتان باشد در بخش تاریخچه زبان گو یکی از ویژگی های بارزی که در خصوص زبان گو گفتیم بحث Cross-Platform Build بود که شما می توانید در همان سیستم عاملی که هستید برای سایر پلت فرم ها و سیستم عامل ها خروجی بگیرید.\n1$ GOOS=linux GOARCH=amd64 go build -o myproject main.go کامند فوق در لینوکس و سیستم عامل های یونیکسی کاربردی است که شما می توانید قبل از فرمان اصلی یکسری environment variables تعیین کنید. که در کامند فوق ما ۲ تا environment قرار دادیم اولی برای تعیین سیستم عامل هست و دومی معماری هست که ۳۲ بیت یا ۶۴ بیت و همچنین از نوع arm باشد. سپس فرمان go build را قرار دادیم حال خروجی فایل مناسب برای هر سیستم عامل لینوکس با معماری amd64 (۶۴ بیت) می باشد. و در انتهای کامند یک سوییچ o- قرار دادیم که نام خروجی فایل build شده چی باشد.\n4.1.4 گرفتن build به همراه race detector # در فصل سوم یک بخشی داشتیم به نام data race که در خصوصش توضیح دادیم چطور جلوی این اتفاق را در همزمانی بگیریم. حال یک سوییچ در کامند build داریم به نام race- برای تشخیص data race کمک می کند.\n1$ go build -race 4.1.5 مقدار دهی متغیر هنگام build # اما یکی از سوییچ های خیلی جالب در زبان گو هست که هنگام build پروژه می تواند متغیری را در هرجای پروژه مقدار دهی کند و از کاربردهای آن می توان برای تعیین ورژن پروژه و\u0026hellip; می باشد.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5var ( 6\tVersion string 7\tBuildTime string 8) 9 10func main() { 11\tfmt.Printf(\u0026#34;version %s, build time %s\u0026#34;, Version, BuildTime) 12} 1$ go build -ldflags \u0026#34;-X main.Version=1.0.0 -X main.BuildTime=`date -u +%Y-%m-%dT%H:%M:%SZ`\u0026#34; main.go 1$ ./main 2version 1.0.0, build time 2023-01-27T14:19:23Z در کد فوق ما ۲ متغیر ایجاد کردیم که هنگام build مقدار دهی کنیم و به کامند build ما یک سوییچ ldflags- اضافه کردیم و آدرس متغیرها را دادیم جهت مقدار دهی.\nتوجه کنید اگر متغیرهایتان داخل پکیج (پوشه ای) مانند configs بود آدرس متغییر بصورت زیر می شود :\n1$ go build -ldflags \u0026#34;-X configs.Version=1.0.0 -X configs.BuildTime=`date -u +%Y-%m-%dT%H:%M:%SZ`\u0026#34; main.go "},{"id":44,"href":"/chapter-4/debugging-go-code/","title":"4.2 آموزش کار با Debugging","section":"فصل چهارم: مباحث پیشرفته","content":"برای بحث debugging در زبان گو روش های مختلفی وجود دارد که محبوبترین روش ها به شرح زیر می باشد :\nبا استفاده پکیج fmt : شما با استفاده از تابع fmt.Println می توانید مقادیر برخی از متغیرها را چاپ کنید و یکی از روش های ساده برای بحث دیباگ هستش. با استفاده از پکیج log : یکی از کاربردی ترین روش ها بحث لاگ کردن هستش که شما می توانید هر بخش از کدهای خود را لاگ کنید و بصورت زنده در console یا داخل فایل ببینید و از همه مهمتر شما می توانید لاگ های خود را سطح بندی کنید تا بهتر بتوانید دیباگ کنید. استفاده از پکیج pprof : پکیج pprof به شما کمک می کند تا راحتر مشکلات عملکردی برنامه خود را بیابید و همچنین خروجی profile از عملکرد برنامه با CPU و Memory را آنالیز کنید. با استفاده از IDE ها: اکثر IDE هایی (Goland, Vscode) که قبلا معرفی کردیم دارای دیباگر داخلی می باشند که شما می توانید در هر بخش از کد خود breakpoint بزارید و خط به خط کد را دیباگ کنید و مشکلات را برطرف کنید. با استفاده از دیباگر dlv : یکی از محبوبترین دیباگرهایی بصورت متن باز در حال توسعه است delve می باشد که به شما برای دیباگ کردن بصورت تعاملی هنگام اجرا کمک می کند. حال در ادامه ما با مثال هایی نحوه کار با این شیوه هایی که معرفی کردیم آموزش می دهیم.\n4.2.1 نحوه دیباگ با fmt # شما با استفاده از تابع fmt.Println می توانید مقادیر برخی از متغیرها را چاپ کنید و برای اینکار به مثال ساده زیر توجه کنید :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func fibonacci(n uint) uint { 6\tif n \u0026lt; 2 { 7\treturn n 8\t} 9 10\tvar a, b uint 11 12\tb = 1 13 14\tfor n--; n \u0026gt; 0; n-- { 15\ta += b 16\ta, b = b, a 17\tfmt.Println(\u0026#34;this is example debugging value a is \u0026#34;, a, \u0026#34; value b is \u0026#34;, b) 18\t} 19 20\treturn b 21} 22 23func main() { 24\tfmt.Println(fibonacci(100)) 25} 1$ go run main.go 2this is example debugging value a is 1 value b is 1 3this is example debugging value a is 1 value b is 2 4this is example debugging value a is 2 value b is 3 5this is example debugging value a is 3 value b is 5 6this is example debugging value a is 5 value b is 8 7... 8this is example debugging value a is 6174643828739884737 value b is 16008811023750101250 9this is example debugging value a is 16008811023750101250 value b is 3736710778780434371 103736710778780434371 در کد فوق برای اینکه مقدار a, b را ببینیم از تابع Println استفاده کردیم تا مقدار داخل این دو متغیر را ببینیم.\n4.2.2 نحوه دیباگ با استفاده log # یکی از کاربردی ترین روش ها بحث لاگ کردن هستش که شما می توانید هر بخش از کدهای خود را لاگ کنید و بصورت زنده در console یا داخل فایل ببینید و از همه مهمتر شما می توانید لاگ های خود را سطح بندی کنید تا بهتر بتوانید دیباگ کنید. حال برای اینکه با log دیباگ کنید یک پکیج استاندارد به نام log داریم که می توانید بسته به نیازتان تغییرات دهید و هچنین پکیج هایی نظیر zap, logrus و \u0026hellip; هست برای بحث لاگ به شما خیلی کمک می کنند.\n1package main 2 3import ( 4\t\u0026#34;log\u0026#34; 5\t\u0026#34;os\u0026#34; 6) 7 8func main() { 9\t// Set the log level to Info 10\tlog.SetFlags(0) 11\tlog.SetPrefix(\u0026#34;[Info] \u0026#34;) 12\tlog.SetOutput(os.Stdout) 13\tlog.Println(\u0026#34;This is an informational message\u0026#34;) 14 15\t// Set the log level to Warning 16\tlog.SetPrefix(\u0026#34;[Warn] \u0026#34;) 17\tlog.SetOutput(os.Stdout) 18\tlog.Println(\u0026#34;This is a warning message\u0026#34;) 19 20\t// Set the log level to Error 21\tlog.SetPrefix(\u0026#34;[Error] \u0026#34;) 22\tlog.SetOutput(os.Stderr) 23\tlog.Println(\u0026#34;This is an error message\u0026#34;) 24} 1$ go run main.go 2[Info] This is an informational message 3[Warn] This is a warning message 4[Error] This is an error message در کد فوق ما با استفاده از تابع SetPrefix یک پیشوند برای لاگ ها اضافه کردیم تا بتوانیم لاگ با سطح های مختلف ایجاد کنیم. و با استفاده از log.Println لاگ را چاپ کردیم. در ادامه این فصل به بحث آموزش کار به log میپردازیم.\n4.2.3 دیباگ عملکرد با استفاده از pprof # زبان گو یک ابزار داخلی دارد جهت آنالیز و دیباگ عملکرد به نام pprof که با استفاده از آن می توانید یکسری اطلاعات در خصوص عملکرد برنامه تهیه کنید و براساس آنالیز اطلاعات مشکلات عملکردی را می توانید برطرف کنید.\n1package main 2 3import ( 4\t\u0026#34;log\u0026#34; 5\t\u0026#34;net/http\u0026#34; 6\t_ \u0026#34;net/http/pprof\u0026#34; 7) 8 9func main() { 10\tlog.Println(http.ListenAndServe(\u0026#34;localhost:6060\u0026#34;, nil)) 11} 1$ go run main.go در کد فوق ما از پکیج مسیر net/http/pprof استفاده کردیم تا عملکرد برنامه را در وب سرور زبان گو را آنالیز و دیباگ کنیم. حال اگر به آدرس http://localhost:6060/debug/pprof/ بروید می توانید وضعیت عملکرد وب سرور را در لحظه ببینید و آنالیز کنید.\n4.2.3.1 آنالیز وضعیت CPU # برای آنالیز وضعیت CPU کافیه کامند زیر را بزنید :\n1go tool pprof http://localhost:6060/debug/pprof/profile 4.2.3.2 آنالیز وضعیت heap memory # برای آنالیز حافظه heap کافیه کامند زیر را بزنید :\n1go tool pprof http://localhost:6060/debug/pprof/heap 2 3Fetching profile over HTTP from http://localhost:6060/debug/pprof/heap 4Saved profile in /home/javad/pprof/pprof.main.alloc_objects.alloc_space.inuse_objects.inuse_space.001.pb.gz 5File: main 6Type: inuse_space 7Time: Jan 27, 2023 at 6:46pm (+0330) 8Entering interactive mode (type \u0026#34;help\u0026#34; for commands, \u0026#34;o\u0026#34; for options) 9(pprof) pdf زمانیکه کامند فوق را بزنید وارد شل pprof خواهید شد که می توانید با زدن help کامندهای کاربردی را جهت آنالیز ببینید. به عنوان مثال pdf را بزنید یک خروجی pdf بصورت گراف از وضعیت حافظه heap ارائه می دهد که می توانید وضعیت را آنالیز کنید (جهت خواندن گراف این آموزش را مطالعه کنید).\n"},{"id":45,"href":"/chapter-4/go-mod/","title":"4.3 آموزش کار با go mod","section":"فصل چهارم: مباحث پیشرفته","content":"آموزش کار با go mod\u0026hellip;\n"},{"id":46,"href":"/chapter-4/workspace/","title":"4.4 آموزش کار با workspace","section":"فصل چهارم: مباحث پیشرفته","content":"آموزش کار با workspace\u0026hellip;\n"},{"id":47,"href":"/chapter-4/vendor/","title":"4.5 آموزش کار با Vendor","section":"فصل چهارم: مباحث پیشرفته","content":"آموزش کار با workspace\u0026hellip;\n"},{"id":48,"href":"/chapter-4/command-line-go/","title":"4.6 آموزش نوشتن برنامه command line","section":"فصل چهارم: مباحث پیشرفته","content":"آموزش نوشتن برنامه command line\u0026hellip;\n"},{"id":49,"href":"/chapter-4/work-with-file-in-go/","title":"4.7 آموزش کار با فایل","section":"فصل چهارم: مباحث پیشرفته","content":"آموزش کار با فایل\u0026hellip;\n"},{"id":50,"href":"/chapter-4/work-with-json-file-in-go/","title":"4.8 آموزش کار با json","section":"فصل چهارم: مباحث پیشرفته","content":"آموزش کار با json\u0026hellip;\n"},{"id":51,"href":"/chapter-4/work-with-toml-file-in-go/","title":"4.9 آموزش کار با toml","section":"فصل چهارم: مباحث پیشرفته","content":"آموزش کار با toml\u0026hellip;\n"},{"id":52,"href":"/chapter-4/work-with-yaml-file-in-go/","title":"4.10 آموزش کار با yaml","section":"فصل چهارم: مباحث پیشرفته","content":"آموزش کار با yaml\u0026hellip;\n"},{"id":53,"href":"/chapter-4/work-with-csv-file-in-go/","title":"4.11 آموزش کار با csv","section":"فصل چهارم: مباحث پیشرفته","content":"آموزش کار با csv\u0026hellip;\n"},{"id":54,"href":"/chapter-4/work-with-ini-file-in-go/","title":"4.12 آموزش کار با ini","section":"فصل چهارم: مباحث پیشرفته","content":"بطور خلاصه فایل های ini.* جهت ذخیره تنظیمات مختلف استفاده می شود تنظیماتی مثل: آدرس خاص در شبکه، اطلاعات ورود به سیستم های مختلف و موارد از این قبیل.\nبرای شروع ساختار پروژه ما به این شکل است\n1$ mkdir -p /tmp/ini 2$ cd /tmp/ini 3$ touch my.ini main.go 4$ tree . . 5├── main.go 6└── my.ini در پروژه دو فایل ایجاد کردیم یکی فایل اصلی برنامه main.go و دیگری my.ini که می خواهیم تنظیمات برنامه را در آن نگهداری کنیم. محتوای داخل فایل ini را بصورت ذیل تعریف کرده ایم\n1# possible values : production, development 2app_mode = development 3 4[paths] 5# Path to where grafana can store temp files, sessions, and the sqlite3 db (if that is used) 6data = /home/git/grafana 7 8[server] 9# Protocol (http or https) 10protocol = http 11 12# The http port to use 13http_port = 9999 14# Redirect to correct domain if host header does not match domain # Prevents DNS rebinding attacks 15enforce_domain = true همانطور که در توصیف کد آمده است 5 مقدار مختلف داخل فایل آمده است برخی را توضیح می دهیم\nمقدار app_mode که در واقع میخواهیم جهت تشخیص مود توسعه استفاده کنیم برای مثال به کمک این مقدار میخواهیم لاگ های برنامه در پروداکشن نمایش داده نشود ولی در زمان توسعه دهنده بتوانیم لاگ هایم مختلف را مشاهده کنیم. قسمت بعد protocol است که کاملا مشخص می باشد و در واقع میخواهیم پروتکل استفاده شده را مشخص کنیم حط بعد شماره پورت مورد استفاده برنامه است که مقدار 9999 می باشد مقادیر وارد شده صرفا برای مثال می باشد و می توان هر مقداری را که در برنامه نیاز دارید ایجاد کنید.\n1package main 2import ( 3\u0026#34;fmt\u0026#34; 4\u0026#34;os\u0026#34; 5\u0026#34;gopkg.in/ini.v1\u0026#34; 6) 7 8func main() { 9cfg, err := ini.Load(\u0026#34;my.ini\u0026#34;) 10 11if err != nil { 12fmt.Printf(\u0026#34;Fail to read file: %v\u0026#34;, err) 13os.Exit(1) 14} 15 16// Classic read of values, default section can be represented as empty string 17fmt.Println(\u0026#34;App Mode:\u0026#34;, cfg.Section(\u0026#34;\u0026#34;).Key(\u0026#34;app_mode\u0026#34;).String()) 18fmt.Println(\u0026#34;Data Path:\u0026#34;, cfg.Section(\u0026#34;paths\u0026#34;).Key(\u0026#34;data\u0026#34;).String()) 19 20// Let\u0026#39;s do some candidate value limitation 21fmt.Println(\u0026#34;Server Protocol:\u0026#34;, 22cfg.Section(\u0026#34;server\u0026#34;).Key(\u0026#34;protocol\u0026#34;).In(\u0026#34;http\u0026#34;, []string{\u0026#34;http\u0026#34;, \u0026#34;https\u0026#34;})) 23 24// Value read that is not in candidates will be discarded and fall back to given default value 25fmt.Println(\u0026#34;Email Protocol:\u0026#34;, cfg.Section(\u0026#34;server\u0026#34;).Key(\u0026#34;protocol\u0026#34;).In(\u0026#34;smtp\u0026#34;, []string{\u0026#34;imap\u0026#34;, \u0026#34;smtp\u0026#34;})) 26 27// Try out auto-type conversion 28fmt.Printf(\u0026#34;Port Number: (%[1]T) %[1]d\\n\u0026#34;, cfg.Section(\u0026#34;server\u0026#34;).Key(\u0026#34;http_port\u0026#34;).MustInt(9999)) 29 30fmt.Printf(\u0026#34;Enforce Domain: (%[1]T) %[1]v\\n\u0026#34;, cfg.Section(\u0026#34;server\u0026#34;).Key(\u0026#34;enforce_domain\u0026#34;).MustBool(false)) 31 32// Now, make some changes and save it 33cfg.Section(\u0026#34;\u0026#34;).Key(\u0026#34;app_mode\u0026#34;).SetValue(\u0026#34;production\u0026#34;) cfg.SaveTo(\u0026#34;my.ini.local\u0026#34;) 34 35} خروجی اجرای کد بالا به این شکل است\n1$ go run main.go 2App Mode: development 3Data Path: /home/git/grafana 4Server Protocol: http 5Email Protocol: smtp Port Number: (int) 9999 6Enforce Domain: (bool) true 7 8$ cat my.ini.local 9# possible values : production, development 10app_mode = production [paths] 11# Path to where grafana can store temp files, sessions, and the sqlite3 db (if that is used) data = /home/git/grafana 12... کد بالا به اندازه کافی شفاف و ساده است که نیازی به توضیح بیشتر ندارد در ابتدا نیاز است تا بسته \u0026ldquo;gopkg.in/ini.v1\u0026rdquo; را به برنامه اضافه کنیم سپس با متد load فایل کانفیگ موجود را به حافظه بارگذاری می کنیم تا محتوای آن را بخوانیم و خط های بعد مقادیر آن را میخوانیم در خط پایانی نیز مقدار app_mode را به production تغییر دادیم و در فایل جدیدی به نام my.ini.local ذخیره کردیم .\nمی توانیم به شکل های مختلف یک فایل را بارگذاری یا ایجاد کنیم به مثال ذیل توجه کنید:\n1cfg, err := ini.Load( []byte(\u0026#34;raw data\u0026#34;), // Raw data 2\t\u0026#34;filename\u0026#34;, // File 3\tioutil.NopCloser(bytes.NewReader([]byte(\u0026#34;some other data\u0026#34;))), 4) در این قطعه کد ما تنظیمات خود را به 3 شکل می توانیم فراخوانی کنیم رشته، فایل و io.ReadCloser البته در صورت نیاز می توانیم یک فایل خالی در فضای حافظه بشکل ذیل نیز ایجاد کنیم.\n1cfg := ini.Empty() در ابتدا می توانید هر تعداد فایل ini را بارگذاری و یا فرخوانی کنید ولیکن مواقعی نیاز دارید که یک منبع دیگر به آنها اضافه کنید که برای این منظور می توانید از دستور Append استفاده نمائید\n1err := cfg.Append(\u0026#34;other file\u0026#34;, []byte(\u0026#34;other raw data\u0026#34;)) و یا مواقعی از چند منبع اقدام به بارگذاری می نمائید که احتمال دارد برخی از آن منابع خطا در بارگذاری دهد در این شرایط بهتر از تابع ()LooseLoadd استفاده کنید\n1cfg, err := ini.LooseLoad(\u0026#34;filename\u0026#34;, \u0026#34;filename_404\u0026#34;) و در نهایت می توانید پس از تغییرات دلخواه فایل را بصورت ذیل ذخیره نمائید\n1// ... 2err = cfg.SaveTo(\u0026#34;my.ini\u0026#34;) 3err = cfg.SaveToIndent(\u0026#34;my.ini\u0026#34;, \u0026#34;\\t\u0026#34;) همانطور که در بالا دید برای دسترسی به یک قسمت از فایل ما از تابع Section بصورت ذیل استفاده می کنیم\n1sec, err := cfg.GetSection(\u0026#34;section name\u0026#34;) که در اینجا \u0026ldquo;section name\u0026rdquo; نام قطعه کد ما در فایل تنظیمات است. برخی از توابع مهم این بسته عبارت اند از : 1.\n1err := cfg.NewSection(\u0026#34;new section\u0026#34;) جهت ایجاد قطعه جدید 2.\n1secs := cfg.Sections() 2names := cfg.SectionStrings() برای بدست آوردن تمامی قطعات داخل فایل 3.\n1key, err := cfg.Section(\u0026#34;\u0026#34;).GetKey(\u0026#34;app_mode\u0026#34;) برای بدست آوردن key یک section بطور مثال \u0026ldquo;app_mode\u0026rdquo; 4. ```go key, err := cfg.Section(\u0026quot;\u0026quot;).HasKey(\u0026ldquo;app_mode\u0026rdquo;)\nبرای بررسی وجود یک key 5. ```go key, err := cfg.Section(\u0026#34;\u0026#34;).NewKey(\u0026#34;name\u0026#34;, \u0026#34;value\u0026#34;) برای ایجاد یک key جدید\n"},{"id":55,"href":"/chapter-4/work-with-environment-variable/","title":"4.13 آموزش کار با environment variable","section":"فصل چهارم: مباحث پیشرفته","content":"آموزش کار با environment variable\u0026hellip;\n"},{"id":56,"href":"/chapter-4/go-regular-expressions/","title":"4.14 آموزش کار با regexp","section":"فصل چهارم: مباحث پیشرفته","content":"مواقعی در کد نویسی دارید که نیاز هست تا یک عبارتی مثل شماره تلفن،کد پستی و یا شماره پاسپورت وارد شده را بصورت قاعده مند بررسی کنید به عبارتی کاربر نتواند برای فیلد شماره تلفن، کاراکتر غیر عددی وارد کند. در این مواقع بهتر است داده وارد شده بصورت قاعده مند بررسی شود. برای درک بهتر موضوع به رشته وارد شده توسط کاربر که می تواند سهوا باشد دقت کنید\n+989121234#566 در این رشته کاربر مرتکب دو اشتباه شده است.\nشماره موبایل یک رقم بیشتر وارد شده است کاربر بجای رقم از علامت # استفاده کرده است در چنین شرایطی روش های بررسی مرسوم داده پاسخگو نیست و بهتر است از عبارات با قاعده استفاده کنیم.\nدر زبان برنامه نویسی Go بسته از پیش تعریف شده regexp برای اینکار وجود دارد.\n1import ( 2 \u0026#34;regexp\u0026#34; 3) برای شروع و درک بهتر مطلب اجازه دهید از یک مثال ساده شروع کنیم. میخواهیم بررسی کنیم آیا کاربر کارکتر نقطه [.] را وارد کرده است یا خیر .\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;regexp\u0026#34; 6) 7 8func main() { 9 sampleRegex := regexp.MustCompile(\u0026#34;[.]\u0026#34;) 10 match := sampleRegex.Match([]byte(\u0026#34;.\u0026#34;)) 11 fmt.Println(match) 12} در کد فوق به کمک تابع MustCompile عبارت قاعده مند را دریافت می کنیم در صورتیکه عبارت وارد شده قابل قبول یا معتبر نباشد panic اتفاق خواهد افتاد . دقت داشته باشید که خود عبارت قاعده مند دارای استاندارد و چارچوب های مشخص است که بهتر است درصورت عدم اطلاع از ابتدا آن را بیاموزید.\nدقت کنید که در کد فوق عبارت مد نظر خود را داخل [] قرار داده ایم و در خط بعد با تابع Match که مقدار مورد نظر را بصورت رشته ای از بایت ها به آن معرفی کرده ایم بررسی می کنیم که \u0026ldquo;.\u0026rdquo; در رشته وجود دارد یا خیر که خروجی این بررسی یک مقدار بولین بصورت ذیل است.\ntrue در واقع می توانید رشته های ساده را نیز با این روش مقایسه کنید بطور مثال :\n1package main 2 3import ( 4 \u0026#34;fmt\u0026#34; 5 \u0026#34;regexp\u0026#34; 6) 7func main() { 8 first := \u0026#34;abc\u0026#34; 9 second := \u0026#34;xyz\u0026#34; 10 third := \u0026#34;123\u0026#34; 11 sampleRegex := regexp.MustCompile(first + second + third) 12 13 match := sampleRegex.Match([]byte(\u0026#34;abcxyz123\u0026#34;)) 14 fmt.Println(match) 15} خروجی بررسی بالا\n1$go run main.go 2true اگر به کد فوق دقت کنید متوجه خواهید شد که مقادیر بررسی شده بصورت کامل بوده و چنانچه بررسی شما شامل بخشی از عبارت وارد شده باشد باز نتیجه بررسی اشتباه خواهد بود برای مثال ما قسمتی از کد را تغییر می دهیم\n1package main 2... 3func main() { 4 5\t... 6 match := sampleRegex.Match([]byte(\u0026#34;abcxyz\u0026#34;)) 7 8 fmt.Println(match) 9 10} در اینجا نتیجه بررسی برای عبارت \u0026ldquo;abcxyz\u0026rdquo; که در عبارت اصلی یعنی \u0026ldquo;abcxyz123\u0026rdquo; قرار دارد مقدار false نمایش داده خواهد شد که این به معنای بررسی کل عبارت است. برای رفع این اشتباه می بایست از ساختار عبارات قاعده مند بهر بگیریم و به این شکل به برنامه اطلاع دهیم که عبارت مد نظر ما می تواند بخشی از عبارت وارد شده باشد.\n1package main 2import ( 3 \u0026#34;fmt\u0026#34; 4 \u0026#34;regexp\u0026#34; 5) 6func main() { 7 sampleRegex := regexp.MustCompile(\u0026#34;[abc]\u0026#34;) 8 match := sampleRegex.Match([]byte(\u0026#34;abcd\u0026#34;)) 9 10 fmt.Printf(\u0026#34;For abcd: %t\\n\u0026#34;, match) 11 match = sampleRegex.Match([]byte(\u0026#34;1abc23\u0026#34;)) 12 fmt.Printf(\u0026#34;For 1abc23: %t\\n\u0026#34;, match) 13 14 match = sampleRegex.Match([]byte(\u0026#34;abc\u0026#34;)) 15 fmt.Printf(\u0026#34;For abc: %t\\n\u0026#34;, match) 16} خروجی کد\n1$go run main.go 2For abcd: true 3For 1abc23: true 4For abc: true در کد فوق کارکترهای [] به این معنا است که عبارت مورد نظر می تواند شامل عبارت مورد مقایسه نیز باشد. به چند تا از علائم و معانی پرکاربرد در عبارات قاعده مند توجه کنید.\n\\w فقط شامل حروف باشد \\W شامل حروف نباشد \\d شامل اعداد باشد \\Dشامل اعداد نباشد \\s شامل فضای خالی باشد \\S شامل فضای خالی نباشد \\+ شامل حداقل یک یا بیشتر باشد \\* شامل صفر یا بیشتر باشد \\| شامل عبارت مورد نظر و یا مورد دیگر باشد لیست کامل این عبارات را می توانید در اینجا مشاهده کنید.\nدر مواقعی مایل هستیم که عبارت مورد نظر در رشته را جستجو و نمایش دهیم بطور مثال:\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;regexp\u0026#34; 6) 7 8func main() { 9\tsampleRegexp := regexp.MustCompile(`(ab){2}`) 10 11\tmatches := sampleRegexp.FindString(\u0026#34;abab\u0026#34;) 12\tfmt.Println(matches) 13 14\tmatches = sampleRegexp.FindString(\u0026#34;ababbc\u0026#34;) 15\tfmt.Println(matches) 16} در اینجا از برنامه خواسته ایم که به دنبال ترکیبی از ab با تکرار دوبار متوالی باشد و در انتها عبارت پیدا شده توسط تابع FindString را نمایش دهد که علامت () تاکید روی عبارت مورد نظر است و {2} به معنی تکرار حداقل دوبار متوالی است.\nخروجی کد بالا\n1$go run main.go 2abab 3abab در پایان می خواهیم یک مثال سختر را که در ابتدا به آن اشاره کردیم بنویسیم و آن بررسی شماره تلفن است.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;regexp\u0026#34; 6) 7 8func main() { 9\tsampleRegexp := regexp.MustCompile(`^\\+989(1[0-9]|3[1-9]|2[1-9])?[0-9]{7}$`) 10 11\tmatches := sampleRegexp.Match([]byte(\u0026#34;+989121234#566\u0026#34;)) 12\tfmt.Println(matches) 13 14\tmatches = sampleRegexp.Match([]byte(\u0026#34;+989121234567\u0026#34;)) 15\tfmt.Println(matches) 16} خروجی کد بالا\n1$ go run main.go 2false 3true در کد فوق علامت ^ در عبارات با قاعده به معنی شروع ساختار عبارت است و علامت $ به معنای پایان عبارت. درواقع تمامی رشته های که قرار است عتبار سنجی شوند باید در ساختار بین این تو کاراکتر تطبیق شوند. در ادامه نیاز است تا با کمک کاراکتر \\ اثر کارکتر + را خنثی کنیم به این معنی که تمامی شماره های وارد شده باید علامت + در ابتدا داشته باشند سپس قید شده است که 989 که پیش شمار ایران و موبایل است را قید کرده ایم . از آنجا که شماره موبایلهای ایران 911|912|913 شروع می شود با این عبارت \u0026ldquo;(1[0-9]|3[1-9]|2[1-9])\u0026rdquo; مشخص کرده ایم. علامت ؟ به معنی حداقل یکبار تکرار شده عبارت قبل خودش است و در انتها کاربر می بایست هفت رقم وارد که به این صورت مشخص شده است \u0026ldquo;[0-9]{7}\u0026rdquo;. همانطور مشاهده می کنید رشته اول معتبر نبوده ولی رشته دوم صحیح است.\n"},{"id":57,"href":"/chapter-4/go-reflection/","title":"4.15 آموزش reflection","section":"فصل چهارم: مباحث پیشرفته","content":"آموزش reflection\u0026hellip;\n"},{"id":58,"href":"/chapter-4/go-generator/","title":"4.16 آموزش generator","section":"فصل چهارم: مباحث پیشرفته","content":"آموزش generator\u0026hellip;\n"},{"id":59,"href":"/chapter-4/go-stringer/","title":"4.17 آموزش stringer","section":"فصل چهارم: مباحث پیشرفته","content":"آموزش stringer\u0026hellip;\n"},{"id":60,"href":"/chapter-4/effective-go/","title":"4.18 تکنیک های کدنویسی زبان گو","section":"فصل چهارم: مباحث پیشرفته","content":"آموزش تکنیک های کدنویسی\u0026hellip;\n"},{"id":61,"href":"/chapter-4/go-commentry/","title":"4.19 اصول کامنت نویسی","section":"فصل چهارم: مباحث پیشرفته","content":"اصول کامنت نویسی در زبان گو\n"},{"id":62,"href":"/chapter-4/go-code-rules/","title":"4.20 قوانین کدنویسی در گو","section":"فصل چهارم: مباحث پیشرفته","content":"قوانین کدنویسی در گو\u0026hellip;\n"},{"id":63,"href":"/chapter-4/go-garbage-collector/","title":"4.21 زباله جمع کن (garbage collector)","section":"فصل چهارم: مباحث پیشرفته","content":"زباله جمع کن (garbage collector)\u0026hellip;\n"},{"id":64,"href":"/chapter-4/oop/","title":"4.22 شی گرایی در زبان گو","section":"فصل چهارم: مباحث پیشرفته","content":"گو یک زبان statically-typed است و بطور کلی امکانات شی گرایی را به شیوه قدیم و مرسوم پشتیبانی نمی کند. اما در عوض یک شیوه قرار دادی وجود دارد که به شما کمک می کند برخی از مفاهیم شی گرایی را با کمک اینترفیس, composition, متد و type embedding پیاده سازی کنید.\nاین مفاهیم شامل :\nکپسوله سازی ارث بری پلی مورفیسم overriding abstraction "},{"id":65,"href":"/chapter-4/oop/go-encapsulation/","title":"4.22.1 کپسوله سازی (Encapsulation)","section":"4.22 شی گرایی در زبان گو","content":"کپسوله سازی در زبان گو یا هر زبان دیگیری یک مفهوم مشترک می باشد که شما یک داده یک تابع را پشت یک آبجکت یا یک واحد مستقل بپوشانید. با اینکار شما جلوی دسترسی مستقیم برروی داده را میگیرید. این کار در شی گرایی کمک می کند شما کدهای خود را بهتر سازماندهی کندی و جلوی دسترسی مستقیم ناخواسته را میگیرید.\nدر زبان گو برای Public/Private کردن یک آبجکت یا تابع کلمه کلیدی به نام public/private ندارد ولی در عوض شما می توانید داخل هر پکیج با بزرگ یا کوچک کردن حرف اول نام هر آبجکت یا تابع جلو دسترسی مستقیم را بگیرید.\n1var DatabaseName string // public 2var databaseName string // private 3 4func Greeting() {} // public 5func greeting() {} // private زمانی که شما یک آبجکت یا تابع را به شیوه فوق private می کنید در واقع آن آبجکت یا تابع فقط در همان package level خود در دسترس می باشد.\nبه عنوان مثال اگر تابع greeting داخل پکیج message باشد فقط در همان جا در دسترس می باشد.\n1└── message 2 ├── data.go 3 ├── message.go 4 └── resp.go در زیر یک مثال ساده زدیم توجه کنید :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type Person struct { 6\tname string 7\tage int 8} 9 10func (p *Person) GetAge() int { 11\treturn p.age 12} 13 14func (p *Person) getName() string { 15\treturn p.name 16} 17 18func (p *Person) SetAge(age int) { 19\tp.age = age 20} 21 22func main() { 23\tperson := Person{ 24\tname: \u0026#34;Javad\u0026#34;, 25\t} 26 27\tperson.SetAge(29) 28 29\tfmt.Printf(\u0026#34;%s with age %d\u0026#34;, person.getName(), person.GetAge()) 30} 1$ go run main.go 2Javad with age 29 کد فوق ما یک ساختار (آبجکت) Person ایجاد کردیم که داخلش ۲ فیلد name, age بصورت private وجود دارد که سایر پکیج ها نمی توانند دسترسی مستقیم به فیلد های Person دسترسی داشته باشند. حال ۳ متد تعریف کردیم GetAge برای گرفتن سن شخص , SetAge برای تعیین سن شخص , getName گرفتن نام شخص که فقط داخل همان پکیج در دسترس است این متد.\n"},{"id":66,"href":"/chapter-4/oop/go-inheritance/","title":"4.22.2 ارث بری","section":"4.22 شی گرایی در زبان گو","content":"در زبان گو ارث بری در واقع type embedding هست با استفاده type embedding می توانید یک type را داخل type دیگری جاسازی کنید و به واسطه type والد قابل دسترس است.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type Person struct { 6\tName string 7} 8 9func (p *Person) Introduce() { 10\tfmt.Printf(\u0026#34;Hi, my name is %s\\n\u0026#34;, p.Name) 11} 12 13type Student struct { 14\tPerson 15\tSchool string 16} 17 18func main() { 19\ts := \u0026amp;Student{Person{\u0026#34;John Doe\u0026#34;}, \u0026#34;Go University\u0026#34;} 20\ts.Introduce() 21} 1$ go run main.go 2Hi, my name is John Doe "},{"id":67,"href":"/chapter-4/oop/go-polymorphism/","title":"4.22.3 پلی مورفیسم (Polymorphism)","section":"4.22 شی گرایی در زبان گو","content":"پلی مورفیسم یکی از مفاهیم مهم در شی گرایی می باشد و هدف استفاده از پلی مورفیسم این است بین آبجکت ها رفتار مشترکی ایجاد کنیم. در زبان گو شما می توانید یک اینترفیس تعریف کنید و برای ساختارهای مختلف متدهای اینترفیس را پیاده سازی کنید.\nبه مثال زیر توجه کنید :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5// Shape is an interface that defines a method named `Area` 6type Shape interface { 7\tArea() float64 8} 9 10// Rectangle is a struct that represents a rectangle 11type Rectangle struct { 12\twidth float64 13\theight float64 14} 15 16// Area implements the Shape interface for Rectangle 17func (r Rectangle) Area() float64 { 18\treturn r.width * r.height 19} 20 21// Circle is a struct that represents a circle 22type Circle struct { 23\tradius float64 24} 25 26// Area implements the Shape interface for Circle 27func (c Circle) Area() float64 { 28\treturn 3.14 * c.radius * c.radius 29} 30 31func CalcArea(shapes ...Shape) { 32\tfor _, shape := range shapes { 33\tfmt.Println(shape.Area()) 34\t} 35} 36 37func main() { 38\tr := Rectangle{width: 10, height: 5} 39\tc := Circle{radius: 5} 40 41\tCalcArea(r, c) 42} 1$ go run main.go 250 378.5 در کد فوق ما یک اینترفیس Shape داریم که داخلش یک متد به نام Area هست حال این متد را برای ساختارهای Rectangle و Circle پیاده سازی کردیم که مساحت دایره و مستطیل را محاسبه کنیم. حال یک تابع CalcArea داریم به عنوان پارامتر slice از Shape ها میگیرد که ما داخل تابع main ساختار Rectangle و Circle که متد Area اینترفیس Shape را پیاده سازی کرده اند را پاس دادیم و در نهایت محاسبه مساحت را در خروجی چاپ می کند.\n"},{"id":68,"href":"/chapter-4/oop/go-overriding/","title":"4.22.4 overriding","section":"4.22 شی گرایی در زبان گو","content":"در زبان گو مثل سایر زبان های شی گرا امکان overriding مستقیم یک متد وجود ندارد اما در عوض شما می توانید با استفاده از type embedding و پیاده سازی متد یک اینترفیس این تکنیک را انجام دهید و به متدی که override انجام داده Shadow Method می گویند.\nبه مثال زیر توجه کنید :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type User interface { 6\tPrintName() 7} 8 9type Person struct { 10\tName string 11} 12 13func (p Person) PrintName() { 14\tfmt.Println(\u0026#34;My name is\u0026#34;, p.Name) 15} 16 17type Student struct { 18\tPerson 19} 20 21func (s Student) PrintName() { 22\tfmt.Println(\u0026#34;I am a student and my name is\u0026#34;, s.Name) 23} 24 25func main() { 26\tp := Person{Name: \u0026#34;John\u0026#34;} 27\ts := Student{Person{Name: \u0026#34;Jane\u0026#34;}} 28 29\tp.PrintName() 30\ts.PrintName() 31} 1$ go run main.go 2My name is John 3I am a student and my name is Jane در کد فوق ما یک اینترفیس User داریم که داخلش یک متد PrintName وجود دارد که این متد نام شخص یا دانش آموز را به همراه توضیحات چاپ می کند. حال ۲ تا ساختار داریم Person و Student که ساختار Setudent فقط Person را جاسازی کرده است. سپس برای این ۲ ساختار متد PrintName را پیاده سازی کردیم با این تفاوت که داخل متد PrintName ساختار Student متن دیگری قرار دادیم. در تابع main ما متغیر p, s را از نوع Person و Student ایجاد و مقدار دهی کردیم. سپس متد PrintName هر دو را فراخوانی کردیم.\n"},{"id":69,"href":"/chapter-4/oop/go-abstraction/","title":"4.22.5 abstraction","section":"4.22 شی گرایی در زبان گو","content":"Abstraction (به معنای انتزاع)، فرآیند حذف یا از بین بردن برخی ویژگی‌های غیرضروری یک چیز به‌منظور کاهش، خلاصه‌سازی و به کار بردن آن در مجموعه‌ای از ویژگی‌های ضروری است. در برنامه‌نویسی شیءگرا(OOP)، انتزاع یکی از سه مفهوم اصلی (به همراه مفاهیم Encapsulation و Inheritance) است.\nبه نقل از ویکی پدیا : انتزاع،[۱] (به انگلیسی: Abstraction) تجرید یا آهنجش فرایند اختصار، فشرده‌سازی، و تلخیص اطّلاعات از طریق شناسائی، استخراج و سپس، جداسازی و پنهان‌سازی جزئیّات[۲] از کلیّات[۳] است. انتزاع در لغت به معنای جدا کردن، گرفتن، درآوردن جزئی از یک کل[۴] و به معنای بازداشتن و امتناع کردن، برکندن و از جای کشیدن، گرفتن، و دور شدن می‌باشد.[۵]\nانتزاع فرایند یا نتیجهٔ تعمیم بخشیدن با کاهش محتوای اطلاعاتی یک مفهوم یا یک پدیدهٔ قابل مشاهده، جهت حفظ اطلاعات برای منظور خاص می‌باشد.\nدر زبان گو abstraction با استفاده از اینترفیس می توان انجام داد. یک اینترفیس یکسری متد دارد که ما این متدها را برای هریک از تایپ های مختلف پیاده سازی می کنیم.\nبه مثال زیر توجه کنید :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5// Shape is an interface that defines the basic methods for a shape. 6type Shape interface { 7\tArea() float64 8\tPerimeter() float64 9} 10 11// Rectangle is a struct that implements the Shape interface. 12type Rectangle struct { 13\twidth, height float64 14} 15 16// Area returns the area of the rectangle. 17func (r Rectangle) Area() float64 { 18\treturn r.width * r.height 19} 20 21// Perimeter returns the perimeter of the rectangle. 22func (r Rectangle) Perimeter() float64 { 23\treturn 2 * (r.width + r.height) 24} 25 26// Circle is a struct that implements the Shape interface. 27type Circle struct { 28\tradius float64 29} 30 31// Area returns the area of the circle. 32func (c Circle) Area() float64 { 33\treturn 3.14 * c.radius * c.radius 34} 35 36// Perimeter returns the perimeter of the circle. 37func (c Circle) Perimeter() float64 { 38\treturn 2 * 3.14 * c.radius 39} 40 41func main() { 42\t// Create a rectangle and a circle. 43\tr := Rectangle{width: 10, height: 20} 44\tc := Circle{radius: 5} 45 46\t// Declare a slice of Shape interfaces. 47\tshapes := []Shape{r, c} 48 49\t// Iterate over the shapes and print their area and perimeter. 50\tfor _, shape := range shapes { 51\tfmt.Println(\u0026#34;Area:\u0026#34;, shape.Area()) 52\tfmt.Println(\u0026#34;Perimeter:\u0026#34;, shape.Perimeter()) 53\tfmt.Println(\u0026#34;\u0026#34;) 54\t} 55} 1$ go run main.go 2Area: 200 3Perimeter: 60 4 5Area: 78.5 6Perimeter: 31.400000000000002 در کد فوق ما یک اینترفیس Shape داریم که ۲ تا متد Area و Perimeter داریم که مساحت و محیط را محاسبه می کند. در ادامه ۲ ساختار Rectangle و Circle داریم که برای این ساختارها متدهای اینترفیس Shape را پیاده سازی کردیم و در نهایت اندازه مساحت و محیط را محاسبه می کنیم.\n"},{"id":70,"href":"/chapter-5/","title":"فصل پنجم: برنامه نویسی شبکه با گو","section":"صفحه اصلی","content":"در این فصل به مباحث برنامه نویسی شبکه در زبان گو میپردازیم\u0026hellip;\n"},{"id":71,"href":"/chapter-5/go-http-server-begginer/","title":"5.1 کتابخانه http سمت سرور مقدماتی","section":"فصل پنجم: برنامه نویسی شبکه با گو","content":"آموزش کتابخانه http سمت سرور مقدماتی\u0026hellip;\n"},{"id":72,"href":"/chapter-5/go-http-server-advanced/","title":"5.2 کتابخانه http سمت سرور پیشرفته","section":"فصل پنجم: برنامه نویسی شبکه با گو","content":"آموزش کتابخانه http سمت سرور پیشرفته\u0026hellip;\n"},{"id":73,"href":"/chapter-5/go-http-client-begginer/","title":"5.3 کتابخانه http سمت کلاینت مقدماتی","section":"فصل پنجم: برنامه نویسی شبکه با گو","content":"آموزش کتابخانه http سمت کلاینت مقدماتی\u0026hellip;\n"},{"id":74,"href":"/chapter-5/go-http-client-advanced/","title":"5.4 کتابخانه http سمت کلاینت پیشرفته","section":"فصل پنجم: برنامه نویسی شبکه با گو","content":"آموزش کتابخانه http سمت کلاینت پیشرفته\u0026hellip;\n"},{"id":75,"href":"/chapter-6/","title":"فصل ششم: جنریک (Generics)","section":"صفحه اصلی","content":"در این فصل به مباحث جنریک در زبان گو میپردازیم\u0026hellip;\n"},{"id":76,"href":"/chapter-7/","title":"فصل هفتم: تست نویسی","section":"صفحه اصلی","content":"در این فصل به مباحث تست نویسی در زبان گو میپردازیم\u0026hellip;\n"},{"id":77,"href":"/chapter-8/","title":"فصل هشتم: پکیج های استاندارد","section":"صفحه اصلی","content":"در این فصل به مباحث پکیج های استاندارد در زبان گو میپردازیم\u0026hellip;\n"},{"id":78,"href":"/chapter-9/","title":"فصل نهم: الگوهای طراحی","section":"صفحه اصلی","content":"در این فصل به مباحث الگوهای طراحی در زبان گو میپردازیم و سعی می کنیم بطور کلی و با مثال های مناسب به شما هر الگو را آموزش دهیم و همچنین برخی از کاربردهای الگوها را نام ببریم.\nسعی کنید وقتی از الگوهای طراحی استفاده کنید که واقعا احساس نیاز کنید, خیلی قابل اهمیته که در جای درست از الگوها استفاده کنید. "},{"id":79,"href":"/chapter-9/creational-patterns/","title":"9.1 الگوهای طراحی سازنده","section":"فصل نهم: الگوهای طراحی","content":"الگوهای طراحی سازنده\u0026hellip;\n"},{"id":80,"href":"/chapter-9/structural-patterns/","title":"9.2 الگوهای طراحی ساختاری","section":"فصل نهم: الگوهای طراحی","content":"الگوهای طراحی ساختاری\u0026hellip;\n"},{"id":81,"href":"/chapter-9/behavioral-patterns/","title":"9.3 الگوهای طراحی رفتاری","section":"فصل نهم: الگوهای طراحی","content":"الگوهای طراحی رفتاری\u0026hellip;\n"},{"id":82,"href":"/chapter-9/concurrency-patterns/","title":"9.4 الگوهای همزمانی","section":"فصل نهم: الگوهای طراحی","content":" عنوان توضیحات وضعیت Wait For Result با استفاده از الگو Wait For Result می توانید یک عملیاتی را بصورت همزمانی انجام دهید و سپس منتظر نتیجه عملیات صورت گرفته بمانید. برای اینکار از کانال استفاده می شود. ✅ Fan Out/In الگو Fan Out/In یک تکنیک همزمانی در زبان گو می باشد که به شما اجازه می دهد چندین کار را با گوروتین همزمان انجام دهید و در نتیجه خروجی این کارها را با هم ترکیب کنید و به عنوان نتیجه نهایی دریافت کنید. ✅ Wait For Task الگو wait for task یکی از الگوهای رایج در زبان گو می باشد و انتظار برای تکمیل یک تسک یا فرآیند استفاده می شود. یک تسک با استفاده از گوروتین اجرا می شود و پس اتمامش کار تسک از طریق کانال سیگنال انجام می فرستد. ✅ Drop الگو Drop یک الگو مهم برای انجام خدمات سنگین می باشد. خدماتی که مواقعی باعث می شود حجم درخواست هایش بیش از ظرفیت موجود باشد و این درخواست ها بواسطه این الگو می تواند Drop شود. به عنوان مثال سرویس های DNS باید از این الگو استفاده کنند. ✅ Cancellation الگو cancellation که حرکت تکنیکی هست برای ارسال سینگال به گوروتین ها استفاده می شود که باید اجرای کاری را متوقف کند و ایده اصلی این کار با استفاده بستن کانال صورت میگیرد. ✅ Semaphore الگو Semaphore برای مدیریت کنترل دسترسی به منابع مشترک در همزمانی استفاده می شود. فرض کنید بصورت موازی ۱۰۰ درخواست HTTP سمت سرور میاد و I/O شبکه برای پردازش همزمان این ۱۰۰ درخواست درگیر میشود و به مرور عملکرد کاهش می یابد. حال اگر ما بیایم این ۱۰۰ درخواست موازی را تقسیم کنیم به ۵ دسته ۲۰ تایی که بصورت همزمانی انجام شود باعث می شود I/O شبکه کاهش یابد و عملکرد بهتری را خواهیم داشت. ✅ Bounded Work Pooling با استفاده از الگو Bounded Work Pooling امکان محدود سازی تعداد گوروتین ها را براساس کار مشخصی دارید و گوروتین ها را محدود به تعداد دفعات کار مشخص شده محدود می شود. این الگو برای وقت مفید است که شما می خواهید منابع را به یک کار خاص محدود کنید. ✅ Retry Timeout شما از الگو Retry Timeout برای تلاش مجدد یکسری عملیات استفاده کنید. برای اینکار شما می توانید از حلقه و تابع After در پکیج time کمک بگیرید و برای هرتلاش یک timeout مشخص کنید. ✅ Channel Cancellation از کانال ها برای ارتباط بین گوروتین ها و هماهنگ کردن اجرا استفاده می شود. حال گاهی اوقات نیاز است که ما یکسری فرآیند را داخل گوروتین لغو کنیم. در اینجا می توانیم با استفاده از کانال سیگنال لغو کردن بفرستید تا عملیات هایی که گوروتین مورد نظر انجام می داد لغو شود. ✅ Producer-Consumer الگو producer-consumer یکی از کاربردی ترین الگوها در زبان گو می باشد که با استفاده از الگو می توانید بطور همزمان یکسری اطلاعات تولید کنید و بفرستید داخل کانال و این اطلاعات توسط مصرف کننده بواسطه کانال دریافت شود. ✅ Monitor الگوی مانیتور به گروتین‌ ها اجازه می‌دهد هنگام ورود به حالت خواب بدون مسدود کردن اجرا یا مصرف منابع، منتظر شرایط خاصی باشند. ✅ Future در زبان گو الگو Future راهی برای نمایش نتیجه یک عملیات ناهمزمان (asynchronous) است که ممکن است آن عملیات هنوز تکمیل نشده باشد اما این الگو به شما این امکان را می دهد کدی بنویسید که طوری رفتار کند که گویی نتیجه یک عملیات فورا در دسترس است. حتی اگر عملیات در پس زمینه در حال اجرا باشد. ✅ Pipeline الگو خط لوله (Pipeline) یکی از پرکاربردی ترین الگوها در همزمانی می باشد شما با استفاده از این الگو می توانید تسک های بزرگ را به تسک های کوچکتر و مستقل تقسیم کنید که می توانند بطور همزمان کار کنند. هر stage داخل یک گوروتین انجام می شود و بواسطه کانال داده ها بین stage های مختلف منتقل می شود. ✅ Subscription الگو Subscription یکی از الگوهای کاربردی برای پیاده سازی consumer می باشد که به یک آدرسی مشترک شوید و در بازده زمانی مختلف درخواست دهید و یکسری اطلاعات دریافت کنید. ✅ Bridge Channel با استفاده از الگو Bridge Channel می توانید بین ۲ کانال داده ای را منتقل کنید فرض کنید یک داده را به کانال input میفرستید و از دریافت داده آن را می توانید به کانال دیگری منتقل کنید و عملا شما یک پل برای انتقال داده ایجاد کردید. ✅ Queuing الگوی \u0026ldquo;صف\u0026rdquo; در زبان گو الگویی است که در آن از یک گوروتین برای بافر کردن و مدیریت ترتیب مقادیر ارسال شده و دریافت شده از یک کانال استفاده می شود. ✅ "},{"id":83,"href":"/chapter-9/cloud-native-patterns/","title":"9.5 الگوهای Cloud Native","section":"فصل نهم: الگوهای طراحی","content":"الگوهای cloud native\u0026hellip;\n"},{"id":84,"href":"/chapter-9/anti-pattern/","title":"9.6 ضد الگوها (Anti-Patterns)","section":"فصل نهم: الگوهای طراحی","content":"ضد الگوها\n"},{"id":85,"href":"/chapter-10/","title":"فصل دهم: الگوریتم و ساختار داده","section":"صفحه اصلی","content":"در این فصل به مباحث الگوریتم و ساختار داده در زبان گو میپردازیم\u0026hellip;\n"},{"id":86,"href":"/chapter-11/","title":"فصل یازدهم: معماری های نرم افزار","section":"صفحه اصلی","content":"در این فصل به مباحث معماری های نرم افزار در زبان گو میپردازیم\u0026hellip;\n"},{"id":87,"href":"/chapter-9/creational-patterns/go-singleton-pattern/","title":"9.1.1 الگو Singleton","section":"9.1 الگوهای طراحی سازنده","content":"الگو Singleton\u0026hellip;\n"},{"id":88,"href":"/chapter-9/creational-patterns/go-factory-method-pattern/","title":"9.1.2 الگو Factory Method","section":"9.1 الگوهای طراحی سازنده","content":"الگو Factory Method\u0026hellip;\n"},{"id":89,"href":"/chapter-9/creational-patterns/go-prototype-pattern/","title":"9.1.3 الگو Prototype","section":"9.1 الگوهای طراحی سازنده","content":"الگو Prototype\u0026hellip;\n"},{"id":90,"href":"/chapter-9/creational-patterns/go-abstract-factory-pattern/","title":"9.1.4 الگو Abstract Factory","section":"9.1 الگوهای طراحی سازنده","content":"الگو Abstract Factory\u0026hellip;\n"},{"id":91,"href":"/chapter-9/creational-patterns/go-builder-pattern/","title":"9.1.6 الگو Builder","section":"9.1 الگوهای طراحی سازنده","content":"الگو Builder\u0026hellip;\n"},{"id":92,"href":"/chapter-9/creational-patterns/go-object-pool-pattern/","title":"9.1.7 الگو Object Pool","section":"9.1 الگوهای طراحی سازنده","content":"الگو Object Pool\u0026hellip;\n"},{"id":93,"href":"/chapter-9/structural-patterns/go-adaptor-pattern/","title":"9.2.1 الگو Adaptor","section":"9.2 الگوهای طراحی ساختاری","content":"الگو Adaptor\u0026hellip;\n"},{"id":94,"href":"/chapter-9/structural-patterns/go-bridge-pattern/","title":"9.2.2 الگو Bridge","section":"9.2 الگوهای طراحی ساختاری","content":"الگو Bridge\u0026hellip;\n"},{"id":95,"href":"/chapter-9/structural-patterns/go-composite-pattern/","title":"9.2.3 الگو Composite","section":"9.2 الگوهای طراحی ساختاری","content":"الگو Composite\u0026hellip;\n"},{"id":96,"href":"/chapter-9/structural-patterns/go-decorator-pattern/","title":"9.2.1 الگو Decorator","section":"9.2 الگوهای طراحی ساختاری","content":"الگو Decorator\u0026hellip;\n"},{"id":97,"href":"/chapter-9/structural-patterns/go-facade-pattern/","title":"9.2.5 الگو Facade","section":"9.2 الگوهای طراحی ساختاری","content":"الگو Facade\u0026hellip;\n"},{"id":98,"href":"/chapter-9/structural-patterns/go-flyweight-pattern/","title":"9.2.6 الگو Flyweight","section":"9.2 الگوهای طراحی ساختاری","content":"الگو Flyweight\u0026hellip;\n"},{"id":99,"href":"/chapter-9/structural-patterns/go-proxy-pattern/","title":"9.2.7 الگو Proxy","section":"9.2 الگوهای طراحی ساختاری","content":"الگو Proxy\u0026hellip;\n"},{"id":100,"href":"/chapter-9/behavioral-patterns/go-chain-of-responsibility-pattern/","title":"9.3.1 الگو Chain Of Responsibility","section":"9.3 الگوهای طراحی رفتاری","content":"الگو Chain Of Responsibility\u0026hellip;\n"},{"id":101,"href":"/chapter-9/behavioral-patterns/go-command-pattern/","title":"9.3.2 الگو Command","section":"9.3 الگوهای طراحی رفتاری","content":"الگو Command\u0026hellip;\n"},{"id":102,"href":"/chapter-9/behavioral-patterns/go-iterator-pattern/","title":"9.3.3 الگو Iterator","section":"9.3 الگوهای طراحی رفتاری","content":"الگو Iterator\u0026hellip;\n"},{"id":103,"href":"/chapter-9/behavioral-patterns/go-mediator-pattern/","title":"9.3.4 الگو Mediator","section":"9.3 الگوهای طراحی رفتاری","content":"الگو Mediator\u0026hellip;\n"},{"id":104,"href":"/chapter-9/behavioral-patterns/go-memento-pattern/","title":"9.3.5 الگو Memento","section":"9.3 الگوهای طراحی رفتاری","content":"الگو Memento\u0026hellip;\n"},{"id":105,"href":"/chapter-9/behavioral-patterns/go-observer-pattern/","title":"9.3.6 الگو Observer","section":"9.3 الگوهای طراحی رفتاری","content":"الگو Observer\u0026hellip;\n"},{"id":106,"href":"/chapter-9/behavioral-patterns/go-state-pattern/","title":"9.3.7 الگو State","section":"9.3 الگوهای طراحی رفتاری","content":"الگو State\u0026hellip;\n"},{"id":107,"href":"/chapter-9/behavioral-patterns/go-strategy-pattern/","title":"9.3.8 الگو Strategy","section":"9.3 الگوهای طراحی رفتاری","content":"الگو Strategy\u0026hellip;\n"},{"id":108,"href":"/chapter-9/behavioral-patterns/go-template-method-pattern/","title":"9.3.9 الگو Template Method","section":"9.3 الگوهای طراحی رفتاری","content":"الگو Template Method\u0026hellip;\n"},{"id":109,"href":"/chapter-9/behavioral-patterns/go-visitor-pattern/","title":"9.3.10 الگو Visitor","section":"9.3 الگوهای طراحی رفتاری","content":"الگو Visitor\u0026hellip;\n"},{"id":110,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-wait-for-result/","title":"9.4.1 الگو Wait For Result","section":"9.4 الگوهای همزمانی","content":" 9.4.1.1 توضیحات # با استفاده از الگو Wait For Result می توانید یک عملیاتی را بصورت همزمانی انجام دهید و سپس منتظر نتیجه عملیات صورت گرفته بمانید. برای اینکار از کانال استفاده می شود.\n9.4.1.2 دیاگرام # 9.4.1.3 نمونه کد # 1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;time\u0026#34; 6) 7 8func longRunningTask(c chan int) { 9\ttime.Sleep(3 * time.Second) 10\tc \u0026lt;- 42 11} 12 13func main() { 14\tc := make(chan int) 15\tgo longRunningTask(c) 16 17\tresult := \u0026lt;-c 18\tfmt.Println(\u0026#34;Result:\u0026#34;, result) 19} 1$ go run main.go 2Result: 42 در کد فوق ما یک تابع به نام longRunningTask داریم که قرار است بصورت همزمان اجرا شود در اینجا ما یک کانال را برای دریافت نتیجه از تابع ارسال می کنیم و منتظر پاسخ از طریق کانال می شویم.\n9.4.1.4 کاربردها # Web scraping : زمانی که شما عملیات web scraping انجام می دهید نیاز دارید بصورت همزمان از چندین آدرس داده جمع آوری کنید در اینجا شما می توانید بصورت همزمان به چندین آدرس درخواست دهید و سپس منتظر نتایج بمانید. API Calls : در معماری ماکروسرویس شما نیازی دارید چندین API را همزمان فراخوانی کنید و منتظر نتایج بمانید قبل از اینکه به کلاینت نتیجه نهایی را نمایش دهید. حال در اینجا می توانید از این الگو استفاده کنید و همزمان اینکار را انجام دهید و منتظر نتایج بمانید تا زمان کمتری صرف شود. Parallel Computation : برای محاسبات علمی شما احتیاج دارید بصورت همزمان محاسبات انجام دهید و قبل از اینکه بخواهید به مرحله بعدی فرآیند بروید می توانید برای نتایجی بصورت همزمان ایجاد کردید منتظر بمانید. "},{"id":111,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-fan-out-in/","title":"9.4.2 الگو Fan Out/In","section":"9.4 الگوهای همزمانی","content":" 9.4.2.1 توضیحات # الگو Fan Out/In یک تکنیک همزمانی در زبان گو می باشد که به شما اجازه می دهد چندین کار را با گوروتین همزمان انجام دهید و در نتیجه خروجی این کارها را با هم ترکیب کنید و به عنوان نتیجه نهایی دریافت کنید.\n9.4.2.2 دیاگرام # 9.4.2.3 نمونه کد # فرض کنید قصد دارید یک برنامه ای بنویسید که چندین فایل بصورت موازی دانلود کنید و در نهایت محتوای این فایل را میخواهید ترکیب کنید و یک خروجی داشته باشید.\nدر زیر یک مثال ساده زدیم :\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;sync\u0026#34; 6) 7 8func main() { 9\turls := []string{\u0026#34;url1\u0026#34;, \u0026#34;url2\u0026#34;, \u0026#34;url3\u0026#34;} 10\tvar wg sync.WaitGroup 11 12\t// Fan out: Launch goroutines to download files 13\tresults := make(chan string) 14\tfor _, url := range urls { 15\twg.Add(1) 16\tgo func(url string) { 17\tdefer wg.Done() 18\tresult := downloadFile(url) 19\tresults \u0026lt;- result 20\t}(url) 21\t} 22 23\t// Fan in: Combine results from goroutines 24\tgo func() { 25\twg.Wait() 26\tclose(results) 27\t}() 28 29\tvar output string 30\tfor result := range results { 31\toutput += result 32\t} 33\tfmt.Println(output) 34} 35 36func downloadFile(url string) string { 37\t// code to download file from url 38\treturn \u0026#34;file contents\u0026#34; 39} 1$ go run main.go 2file contentsfile contentsfile contents در بالا ما یکسری url داریم میخواهیم بصورت موازی فایل هایی را دانلود کنید. حال با توجه به تعداد url ها یک گوروتین ایجاد میکنیم که بصورت موازی شروع به دانلود فایل کنند و نتیجه را داخل کانال results بفرستند. در اینجا ما با کمک WaitGroup منتظر نتیجه کلی عملیات گوروتین ها می شویم و در نهایت پس از اینکه گوروتین ها کارشان اتمام شد. ما با کمک حلقه for-range داده ها را از کانال results دریافت می کنیم و این داده ها را باهم ترکیب میکنیم.\n9.4.2.4 کاربردها # پردازش داده (Data Processing) : شما با استفاده از الگو Fan Out/In بصورت موازی می توانید مقادیری زیاده از داده ها را پردازش کنید. به عنوان مثال شما یک داده بزرگی را دارید قصد دارید پردازشی برروی این داده انجام حال می توانید این داده را به بخش های کوچکتری بین گوروتین ها تقسیم کنید تا بصورت موازی پردازش شود در نهایت خروجی های پردازش شده را با هم ترکیب کنید. Web Scarping : شما با استفاده از الگو Fan Out/In می توانید چندین Scraping وب سایت را بطور همزمان ایجاد کنید و پس از آن نتایج را ترکیب کنید. به عنوان مثال شما بطور موازی چندین گوروتین را برای Web Scaring صفحات مختلف یک وب سایت ایجاد می کنید و با استفاده از کانال نتایج را جمع آوری میکند و در نهایت برروی این نتایج پردازش و در یک دیتابیس ذخیره می کنید. محاسبات توزیع شده (Distributed computing) : برای انجام محاسبات توزیع شما می توانید از الگو Fan Out/In استفاده کنید و چندین گوروتین را برای انجام یک در Machine های مختلف راه اندازی کنید و سپس از یک کانال برای جمع آوری داده استفاده کنید. سپس گوروتین اصلی می توانید نتایج حاصل از را از تمامی node ها جمع آوری کند و یک خروجی ترکیب شده ایجاد کند. شبکه : با استفاده از الگو Fan Out/In می توانید برای مدیریت همزمان چندین کانکشن ورودی و سپس ترکیب نتایج استفاده کنید. به عنوان مثال می توانید چندین گوروتین را برای مدیریت کانکشن های ورودی راه اندازی کنید و سپس از یک کانال برای جمع آودری نتایج استفاده کنید. پس از پردازش و ترکیب نتایج این نتایج را به عنوان خروجی به کلاینت نمایش دهد. "},{"id":112,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-wait-for-task/","title":"9.4.3 الگو Wait For Task","section":"9.4 الگوهای همزمانی","content":" 9.4.3.1 توضیحات # الگو wait for task یکی از الگوهای رایج در زبان گو می باشد و انتظار برای تکمیل یک تسک یا فرآیند استفاده می شود. یک تسک با استفاده از گوروتین اجرا می شود و پس اتمامش کار تسک از طریق کانال سیگنال انجام می فرستد.\nهمچنین می توانید شما یک کانال ایجاد کنید منتظر بمانید تسک انجام شود و دیتا مورد نظر را از طریق کانال بگیرید.\n9.4.3.2 دیاگرام # 9.4.3.3 نمونه کد # 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tdone := make(chan bool) 7\tgo task(done) 8 9\t\u0026lt;-done 10\tfmt.Println(\u0026#34;Task complete!\u0026#34;) 11} 12 13func task(done chan bool) { 14\t// Do some work here 15\tfmt.Println(\u0026#34;Working...\u0026#34;) 16\tdone \u0026lt;- true 17} 1$ go run main.go 2Working... 3Task complete! در مثال فوق ما یک کانال ایجاد کردیم که پس انجام شدن تسک وضعیت کار انجام شده را بگیریم. حال کانال done را به تابع task پاس دادیم پس از انجام شدن کارش مقدار true را به کانال فرستادیم و سپس ما وضعیت انجام شدن تسک را دریافت می کنیم.\n9.4.3.4 کاربردها # پرادزش حجم زیادی از داده ها بصورت موازی : می‌توانید از این الگو برای اجرای چندین گوروتین که تکه‌هایی از داده‌ها را به صورت موازی پردازش می‌کنند، استفاده کنید و سپس قبل از ادامه مرحله بعدی برنامه‌تان منتظر بمانید تا همه گوروتین‌ها تمام شوند. ایجاد ریکوئست API چندگانه : می‌توانید از این الگو برای برقراری همزمان چندین تماس API استفاده کنید و قبل از ادامه منتظر تمام پاسخ‌ها باشید. انتظار برای ورودی کاربر: می‌توانید از الگو برای اجرای یک گوروتین استفاده کنید که منتظر ورودی کاربر است و هنگام دریافت ورودی، پیامی را در کانال «انجام شد» ارسال می‌کند. این می تواند مفید باشد اگر بخواهید در پس زمینه منتظر ورودی بمانید در حالی که سایر بخش های برنامه شما همچنان به کار خود ادامه می دهند. انتظار برای آماده شدن منابع: می توانید از الگوی استفاده کنید تا قبل از ادامه مرحله بعدی برنامه، منتظر آماده شدن منابعی مانند اتصال پایگاه داده یا فایل باشید. انتظار برای تکمیل یک کار پس‌زمینه: می‌توانید از الگو برای اجرای یک کار در پس‌زمینه استفاده کنید و قبل از ادامه مرحله بعدی برنامه، منتظر تکمیل آن باشید. "},{"id":113,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-pooling/","title":"9.4.4 الگو Pooling","section":"9.4 الگوهای همزمانی","content":" 9.4.4.1 توضیحات # شما با استفاده از الگو pooling می توانید برای استفاده مجدد یا مدیریت تعداد ثابتی از منابع مانند : کانکشن های دیتابیس یا مجموعه ای از گوروتین های کارگر استفاده کنید. از کانال برای برقراری ارتباط بین مجموع منابع استفاده می شود.\n9.4.4.2 دیاگرام # 9.4.4.3 نمونه کد # 1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7func main() { 8\tjobs := make(chan int, 100) 9\tresults := make(chan int, 100) 10 11\t// Start 3 worker goroutines 12\tfor w := 1; w \u0026lt;= 3; w++ { 13\tgo worker(w, jobs, results) 14\t} 15 16\t// Send 5 jobs to the worker pool 17\tfor j := 1; j \u0026lt;= 5; j++ { 18\tjobs \u0026lt;- j 19\t} 20\tclose(jobs) 21 22\t// Collect the results 23\tfor a := 1; a \u0026lt;= 5; a++ { 24\tfmt.Println(\u0026lt;-results) 25\t} 26} 27 28func worker(id int, jobs \u0026lt;-chan int, results chan\u0026lt;- int) { 29\tfor j := range jobs { 30\tfmt.Println(\u0026#34;worker\u0026#34;, id, \u0026#34;processing job\u0026#34;, j) 31\tresults \u0026lt;- j * 2 32\t} 33} 1$ go run main.go 2worker 3 processing job 1 3worker 3 processing job 4 4worker 3 processing job 5 5worker 1 processing job 2 62 78 810 94 10worker 2 processing job 3 116 فرض کنید ما ۱۰۰ تسک داریم که قرار است این تسک ها را بین کارگرها تقسیم کنید و در نهایت نتیجه را از طریق کانال دریافت کنیم.\nحال ما ۲ تا کانال ایجاد می کنیم با بافر ۱۰۰ تایی به نام jobs و results که قرار است ۱۰۰ تسک بواسطه این کانال ها ارسال و دریافت شود.\nما یک تابع worker داریم که jobs را دریافت میکند از طریق کانال و پس از عملیات نتیجه را داخل کانال results میفرستد.\nکانال jobs از نوع فقط دریافتی است کانال results از نوع فقط ارسال است حال با فرض اینکه بطور موازی ۳ تا کارگر داریم که این تسک ها را دریافت می کنند و پس از انجام نتیجه را میفرستند. برای اینکه ۳ تا کارگر را ایجاد کنیم از حلقه استفاده میکنیم و تابع worker را داخل گوروتین قرا می دهیم و پس از آن jobs و results را به عنوان پارامتر ورودی به هر ورکر می دهیم.\nدر ادامه یک حلقه ایجاد می کنیم ۵ تا کار (job) داریم قرار است هرکدام از کارگرها توانست انجام دهد و ما کارها را از طریق کانال میفرستیم.\nدر نهایت یک حلقه دیگر داریم که این job ها را از طریق کانال results دریافت می کنیم و پس آن چاپ می کنیم.\n9.4.4.4 کاربردها # تقسیم کارهای پردازشی : شما با استفاده از این الگو می توانید پردازش یک داده سنگین را بین چند کارگر تقسیم کنید و بطور موازی این داده های سنگین در کمترین زمان پردازش می شود و جلو هزینه و سربار را میگیرد و باعث افزایش و بهبود عملکرد شود. "},{"id":114,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-drop/","title":"9.4.5 الگو Drop","section":"9.4 الگوهای همزمانی","content":" 9.4.5.1 توضیحات # الگو Drop یک الگو مهم برای انجام خدمات سنگین می باشد. خدماتی که مواقعی باعث می شود حجم درخواست هایش بیش از ظرفیت موجود باشد و این درخواست ها بواسطه این الگو می تواند Drop شود. به عنوان مثال سرویس های DNS باید از این الگو استفاده کنند.\n9.4.5.2 دیاگرام # 9.4.5.3 نمونه کد # 1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7func main() { 8\tin := make(chan int, 5) 9\tout := make(chan int, 5) 10 11\tgo func() { 12\tfor { 13\tselect { 14\tcase in \u0026lt;- 1: 15\tdefault: 16\tfmt.Println(\u0026#34;Dropping data\u0026#34;) 17\t} 18\t} 19\t}() 20 21\tgo func() { 22\tfor { 23\tselect { 24\tcase data := \u0026lt;-in: 25\tselect { 26\tcase out \u0026lt;- data: 27\tdefault: 28\tfmt.Println(\u0026#34;Dropping data\u0026#34;) 29\t} 30\t} 31\t} 32\t}() 33 34\tfor i := 0; i \u0026lt; 10; i++ { 35\tfmt.Println(\u0026lt;-out) 36\t} 37} 1$ go run main.go 2Dropping data 3Dropping data 4Dropping data 5Dropping data 61 7Dropping data 8 9Dropping data 10Dropping data 111 121 131 141 151 161 17Dropping data 18Dropping data 19Dropping data 20Dropping data 21Dropping data 22Dropping data 231 241 251 در کد فوق ما ۲ تا کانال داریم به نام in/out که بافر شده هستند حال کانال in داده را دریافت می کند و پس از آن داده را به کانال out میفرستد. در اینجا اگر حجم داده ای که دریافت شده بیشتر از اندازه کانال in باشد آن بخش زیاد Drop می شود و همچنین کانال out هم همان شرایط را دارد و سعی می کند داده را به اندازه ظرفیت معین شده مدیریت و پردازش کند.\n9.4.5.4 کاربردها # Rate limiting: هنگامی که با حجم بالای داده های ورودی سروکار دارید، ممکن است لازم باشد برخی از داده ها را حذف کنید تا حجم پردازش ثابتی حفظ شود. Logging: هنگام ثبت داده‌ها، ممکن است لازم باشد که ورودی‌های گزارش را حذف کنید اگر سیستم قادر به هماهنگی با سرعت تولید آنها نباشد. Queue: هنگام برخورد با صفی که توسط یک کانال پشتیبانی می شود، ممکن است به جای مسدود کردن فرستنده، لازم باشد داده های دریافتی را در صورت پر بودن صف حذف کنید. کنترل ترافیک: هنگام مواجهه با حجم بالای ترافیک ورودی، ممکن است لازم باشد مقداری از ترافیک ورودی را حذف کنید تا حجم پردازش ثابتی حفظ شود. سیستم های بلادرنگ (Real-time system): در سیستم‌های بلادرنگ که داده‌ها باید در یک بازه زمانی خاص پردازش شوند، ممکن است لازم باشد که برخی از داده‌های دریافتی حذف شوند، اگر سیستم قادر به هماهنگی با سرعت تولید داده‌ها نباشد. "},{"id":115,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-cancellation/","title":"9.4.6 الگو Cancellation","section":"9.4 الگوهای همزمانی","content":" 9.4.6.1 توضیحات # الگو cancellation که حرکت تکنیکی هست برای ارسال سینگال به گوروتین ها استفاده می شود که باید اجرای کاری را متوقف کند و ایده اصلی این کار با استفاده بستن کانال صورت میگیرد.\n9.4.6.2 دیاگرام # 9.4.6.3 نمونه کد # 1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;time\u0026#34; 6) 7 8func main() { 9\t// create cancel channel 10\tcancel := make(chan struct{}) 11 12\t// start goroutine 13\tgo func() { 14\tfor { 15\tselect { 16\tcase \u0026lt;-cancel: 17\tfmt.Println(\u0026#34;Cancelled\u0026#34;) 18\treturn 19\tdefault: 20\tfmt.Println(\u0026#34;Running\u0026#34;) 21\ttime.Sleep(time.Second) 22\t} 23\t} 24\t}() 25 26\t// run goroutine for 3 seconds 27\ttime.Sleep(3 * time.Second) 28 29\t// close cancel channel 30\tclose(cancel) 31 32\t// wait for goroutine to stop 33\ttime.Sleep(time.Second) 34} 1$ go run main.go 2Running 3Running 4Running 5Cancelled در کد فوق ما یک کانال از نوع ساختار ایجاد کردیم با عنوان cancel و این کانال را داخل یکی از case های select بصورت دریافت قرار دادیم که در ادامه ما یک Sleep ۳ گذاشتیم تا فرآیند انجام شود و Running چاپ شود. پس از آن کانال را close کردیم و سیگنال لغو فرآیند ارسال شد و گوروتین کاملا متوقف شد.\n9.4.6.4 کاربردها # لغو یک کار طولانی‌مدت: عملکردی که عملیات زمان‌بر مانند درخواست شبکه یا محاسبات را انجام می‌دهد، اگر دیگر به آن نیاز نباشد یا از مهلت زمانی فراتر رود، می‌توان آن را لغو کرد. پاکسازی منابع: تابعی که منابعی مانند فایل یا اتصال شبکه را تخصیص می دهد، می تواند لغو شود تا این منابع قبل از اینکه دیگر مورد نیاز نباشند آزاد شوند. خاتمه دادن به یک سرور: سروری که چندین درخواست را مدیریت می‌کند، می‌تواند با لغو تمام عملکردهای در حال اجرا که این درخواست‌ها را انجام می‌دهند، به‌خوبی خاموش شود. لغو یک کار پس زمینه: یک کار پس زمینه که همزمان با برنامه اصلی اجرا می شود را می توان لغو کرد تا از اجرای آن جلوگیری شود. "},{"id":116,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-semaphore/","title":"9.4.7 الگو Semaphore","section":"9.4 الگوهای همزمانی","content":" 9.4.7.1 توضیحات # الگو Semaphore برای مدیریت کنترل دسترسی به منابع مشترک در همزمانی استفاده می شود. فرض کنید بصورت موازی ۱۰۰ درخواست HTTP سمت سرور میاد و I/O شبکه برای پردازش همزمان این ۱۰۰ درخواست درگیر میشود و به مرور عملکرد کاهش می یابد. حال اگر ما بیایم این ۱۰۰ درخواست موازی را تقسیم کنیم به ۵ دسته ۲۰ تایی که بصورت همزمانی انجام شود باعث می شود I/O شبکه کاهش یابد و عملکرد بهتری را خواهیم داشت.\nحال برای اینکه بتوانیم این الگو را طراحی کنیم نیاز هست از کانال بافر شده استفاده کنیم.\nبه نقل از ویکی پدیا :\nدر علم رایانه نشانبر یا سمافور (به انگلیسی: Semaphore) به متغیری گفته می‌شود که در محیط‌های همروند برای کنترل دسترسی فرایندها به منابع مشترک به کار می‌رود. سمافور می‌تواند به دو صورت دودویی (که تنها دو مقدار صحیح و غلط را دارا است) یا شمارنده اعداد صحیح باشد. از سمافور برای جلوگیری از ایجاد وضعیت رقابتی میان فرایندها استفاده می‌گردد. به این ترتیب، اطمینان حاصل می‌شود که در هر لحظه تنها یک فرایند به منبع مشترک دسترسی دارد و می‌تواند از آن بخواند یا بنویسد (انحصار متقابل)\nسمافورها اولین بار به‌وسیلهٔ دانشمند علوم رایانه هلندی، ادسخر دیکسترا معرفی شدند.[۱] و امروزه به‌طور گسترده‌ای در سیستم عاملها مورد استفاده قرار می‌گیرند.\n9.4.7.2 دیاگرام # 9.4.7.3 نمونه کد # 1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;time\u0026#34; 6) 7 8type Semaphore interface { 9\tAcquire() 10\tRelease() 11} 12 13type semaphore struct { 14\tsemCh chan struct{} 15} 16 17func New(maxConcurrency int) Semaphore { 18\treturn \u0026amp;semaphore{ 19\tsemCh: make(chan struct{}, maxConcurrency), 20\t} 21} 22 23func (s *semaphore) Acquire() { 24\ts.semCh \u0026lt;- struct{}{} 25} 26 27func (s *semaphore) Release() { 28\t\u0026lt;-s.semCh 29} 30 31func main() { 32\tsem := New(3) 33\tdoneC := make(chan bool, 1) 34\ttotProcess := 10 35 36\tfor i := 1; i \u0026lt;= totProcess; i++ { 37\tsem.Acquire() 38\tgo func(v int) { 39\tdefer sem.Release() 40\tlongRunningProcess(v) 41 42\tif v == totProcess { 43\tdoneC \u0026lt;- true 44\t} 45\t}(i) 46\t} 47 48\t\u0026lt;-doneC 49} 50 51func longRunningProcess(taskID int) { 52\tfmt.Println(time.Now().Format(\u0026#34;15:04:05\u0026#34;), \u0026#34;Running task with ID\u0026#34;, taskID) 53\ttime.Sleep(2 * time.Second) 54} 1$ go run main.go 223:00:00 Running task with ID 3 323:00:00 Running task with ID 1 423:00:00 Running task with ID 2 523:00:02 Running task with ID 6 623:00:02 Running task with ID 4 723:00:02 Running task with ID 5 823:00:04 Running task with ID 7 923:00:04 Running task with ID 8 1023:00:04 Running task with ID 9 1123:00:06 Running task with ID 10 در کد فوق ما یک اینترفیس به نام Semaphore داریم که ۲ تا متد Acquire و Release دارد که با استفاده از Acquire منابع را قبل از اینکه تابع logRunningProcess را فراخوانی کنیم قفل می کنیم و پس از اینکه عملیات تابع logRunningProcess انجام شد با استفاده از Release منابع را آزاد می کنیم.\nیک تابع سازنده به نام New قرار دادیم که ظرفیت کانال Semaphore را مشخص می کند تا تعداد درخواستی که نیاز است همزمان انجام شود چندتا باشد.\nزمانیکه ما متد Acquire را فراخوانی می کنیم {}{}struct را به کانال می فرستیم تا زمانیکه ظرفیت پر نشده است. پس از اینکه ظرفیت کانال پر شود آن بخش از کد ما Acquire را فراخوانی کردیم قفل می شود و تا زمانی که از کانال بواسطه متد Release دریافت نکنیم منابع در دسترس نخواهد بود.\n9.4.7.4 کاربردها # مدیریت دسترسی به منابع مشترک همگام سازی دسترسی به ساختار داده مشترک مدیریت دسترسی به منابع محدود پیاده سازی یک Load Balancer پیاده سازی thread pool "},{"id":117,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-bounded-work-pooling/","title":"9.4.8 الگو Bounded Work Pooling","section":"9.4 الگوهای همزمانی","content":" 9.4.8.1 توضیحات # با استفاده از الگو Bounded Work Pooling امکان محدود سازی تعداد گوروتین ها را براساس کار مشخصی دارید و گوروتین ها را محدود به تعداد دفعات کار مشخص شده محدود می شود. این الگو برای وقت مفید است که شما می خواهید منابع را به یک کار خاص محدود کنید.\n9.4.8.2 دیاگرام # 9.4.8.3 نمونه کد # 1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;sync\u0026#34; 6) 7 8func main() { 9\t// Create a channel to hold the tasks 10\ttasks := make(chan int, 100) 11 12\t// Create a WaitGroup to track the goroutines 13\tvar wg sync.WaitGroup 14 15\t// Set the number of goroutines we want to use 16\tnumWorkers := 5 17 18\t// Launch the goroutines 19\tfor i := 0; i \u0026lt; numWorkers; i++ { 20\twg.Add(1) 21\tgo func() { 22\tfor task := range tasks { 23\tfmt.Println(\u0026#34;Processing task\u0026#34;, task) 24\t} 25\twg.Done() 26\t}() 27\t} 28 29\t// Add tasks to the channel 30\tfor i := 0; i \u0026lt; 20; i++ { 31\ttasks \u0026lt;- i 32\t} 33 34\t// Close the channel to signal to the goroutines that there are no more tasks 35\tclose(tasks) 36 37\t// Wait for all the goroutines to finish 38\twg.Wait() 39} 1$ go run main.go 2Processing task 2 3Processing task 4 4Processing task 5 5Processing task 6 6Processing task 7 7Processing task 8 8Processing task 10 9Processing task 11 10Processing task 12 11Processing task 13 12Processing task 14 13Processing task 15 14Processing task 16 15Processing task 17 16Processing task 18 17Processing task 19 18Processing task 3 19Processing task 9 20Processing task 0 21Processing task 1 در کد فوق ما یک کانال بافر شده با ظرفیت ۱۰۰ به نام tasks ایجاد کردیم سپس یک نمونه از WaitGroup درست کردیم. حال در متغیر numWorkers تعداد گوروتین قابل استفاده را مشخص کردیم و در ادامه داخل حلقه گوروتین برای انجام تسک ها ایجاد می کنیم که یک حلقه for-range برروی کانال tasks قرار دادیم و تسک ها را دریافت سپس پردازش می کنیم. در ادامه یک حلقه i تا ۲۰ قرار دادیم که که مقدار i را به کانال tasks میفرستد.\nدر نهایت پس از تکمیل شدن تسک ها کانال را میبندیم.\n9.4.8.4 کاربردها # یکی از کاربردهای این الگو برای هندل حجم زیادی از درخواست به سرور می باشد. سرور می‌تواند تعداد درخواست‌های همزمانی را که در هر زمان پردازش می‌کند محدود کند و خطر تمام شدن منابع را کاهش دهد. علاوه بر این، می تواند با اطمینان از اینکه درخواست ها به موقع پردازش می شوند، به بهبود پاسخگویی سرور کمک کند. "},{"id":118,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-retry-timeout/","title":"9.4.9 الگو Retry Timeout","section":"9.4 الگوهای همزمانی","content":" 9.4.9.1 توضیحات # شما از الگو Retry Timeout برای تلاش مجدد یکسری عملیات استفاده کنید. برای اینکار شما می توانید از حلقه و تابع After در پکیج time کمک بگیرید و برای هرتلاش یک timeout مشخص کنید.\n9.4.9.2 دیاگرام # 9.4.9.3 نمونه کد # 1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;net/http\u0026#34; 6\t\u0026#34;time\u0026#34; 7) 8 9func main() { 10\tvar resp *http.Response 11\tvar err error 12\ttimeout := time.Duration(3 * time.Second) 13\tfor i := 0; i \u0026lt; 3; i++ { 14\tresp, err = http.Get(\u0026#34;http://example.com\u0026#34;) 15\tif err == nil { 16\tbreak 17\t} 18\tfmt.Println(\u0026#34;Retrying...\u0026#34;) 19\t\u0026lt;-time.After(timeout) 20\t} 21\tif err != nil { 22\tfmt.Println(\u0026#34;Error:\u0026#34;, err) 23\t} else { 24\tfmt.Println(\u0026#34;Response:\u0026#34;, resp) 25\t} 26} 1$ go run main.go 2Retrying... 3Retrying... 4Retrying... 5Error: Get \u0026#34;http://example.com\u0026#34;: dial tcp: lookup example.com on 169.254.169.254:53: dial udp 169.254.169.254:53: connect: no route to host در کد فوق ما داخل حلقه عملیات گرفتن اطلاعات با استفاده از http.Get را قرار دادیم و اگر درخواست با خطا مواجه می شد مجدد تلاش می کردیم که در ادامه کد داخل حلقه از تابع After استفاده کردیم تا سیگنال timeout را بواسطه کانال دریافت کنیم و تلاش مجدد صورت گیرد.\n9.4.9.4 کاربردها # الگوی Retry Timeout معمولاً در شرایطی استفاده می‌شود که درخواست شبکه یا نوع دیگری از عملیات ممکن است به دلیل مشکلات موقتی مانند سرور مشغول یا نقص شبکه با شکست مواجه شود. با امتحان مجدد عملیات با فاصله زمانی بین تلاش ها، برنامه می تواند شانس نتیجه موفقیت آمیز را افزایش دهد. "},{"id":119,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-channel-cancellation/","title":"9.4.10 الگو Channel Cancellation","section":"9.4 الگوهای همزمانی","content":" 9.4.10.1 توضیحات # از کانال ها برای ارتباط بین گوروتین ها و هماهنگ کردن اجرا استفاده می شود. حال گاهی اوقات نیاز است که ما یکسری فرآیند را داخل گوروتین لغو کنیم. در اینجا می توانیم با استفاده از کانال سیگنال لغو کردن بفرستید تا عملیات هایی که گوروتین مورد نظر انجام می داد لغو شود.\n9.4.10.2 دیاگرام # 9.4.10.3 نمونه کد # 1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7func doWork(cancel chan bool) { 8\tfmt.Println(\u0026#34;Working...\u0026#34;) 9\tfor { 10\tselect { 11\tcase \u0026lt;-cancel: 12\tfmt.Println(\u0026#34;Canceled\u0026#34;) 13\treturn 14\tdefault: 15\t} 16\t} 17} 18 19func main() { 20\tcancel := make(chan bool) 21\tgo doWork(cancel) 22\t// do some other work 23\tfmt.Println(\u0026#34;Canceling...\u0026#34;) 24\tcancel \u0026lt;- true 25} 1$ go run main.go 2Canceling... 3Working... 4Canceled در مثال فوق ما یک کانال ایجاد کردیم برای لغو عملیات در حال اجرا در کانال. حال doWork را اجرا کردیم و سپس سیگنال لغو شدن ارسال کردیم داخل تابع doWork سیگنال را بواسطه select دریافت می کنیم و درخواست را لغو می کنیم.\n9.4.10.4 کاربردها # "},{"id":120,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-producer-consumer/","title":"9.4.11 الگو Producer-Consumer","section":"9.4 الگوهای همزمانی","content":" 9.4.11.1 توضیحات # الگو producer-consumer یکی از کاربردی ترین الگوها در زبان گو می باشد که با استفاده از الگو می توانید بطور همزمان یکسری اطلاعات تولید کنید و بفرستید داخل کانال و این اطلاعات توسط مصرف کننده بواسطه کانال دریافت شود.\nمعمولا برای این الگو از یک کانال دو طرفه استفاده می شود.\n9.4.11.2 دیاگرام # 9.4.11.3 نمونه کد # 1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;math/rand\u0026#34; 6\t\u0026#34;time\u0026#34; 7) 8 9func producer(ch chan\u0026lt;- int, d time.Duration) { 10\tfor { 11\tn := rand.Intn(100) 12\tch \u0026lt;- n 13\tfmt.Println(\u0026#34;Produced:\u0026#34;, n) 14\ttime.Sleep(d) 15\t} 16} 17 18func consumer1(ch \u0026lt;-chan int, d time.Duration) { 19\tfor n := range ch { 20\tfmt.Println(\u0026#34;Consumed 1:\u0026#34;, n) 21\ttime.Sleep(d) 22\t} 23} 24 25func consumer2(ch \u0026lt;-chan int, d time.Duration) { 26\tfor n := range ch { 27\tfmt.Println(\u0026#34;Consumed 2:\u0026#34;, n) 28\ttime.Sleep(d) 29\t} 30} 31 32func main() { 33\tch := make(chan int) 34\tgo producer(ch, 100*time.Millisecond) 35\tgo consumer1(ch, 200*time.Millisecond) 36\tgo consumer2(ch, 200*time.Millisecond) 37 38\ttime.Sleep(5 * time.Second) 39} 1$ go run main.go 2Consumed 1: 81 3Produced: 81 4Produced: 87 5Consumed 2: 87 6Consumed 1: 47 7Produced: 47 8Consumed 2: 59 9Produced: 59 10Consumed 1: 81 11Produced: 81 12Consumed 2: 18 13Produced: 18 14Consumed 1: 25 15Produced: 25 در مثال فوق ما یک کانال دو طرفه ایجاد کردیم سپس این کانال را تابع producer که بصورت فقط ارسال است پاس می دهیم. پس از آن کانال را به توابع consumer1 و consumer2 به عنوان کانال فقط دریافت پاس می دهیم.\nحال اطلاعات بواسطه تابع producer ایجاد می شود و به کانال ارسال می شود و هر کدام از consumer ها داده را دریافت میکنند و نمایش می دهند.\n9.4.11.4 کاربردها # خط لوله پردازش داده: شما با استفاده از الگو producer-consumer می توانید یک خط لوله (pipeline) ایجاد کنید و داده های مورد نظر ایجاد و بواسطه producer برای consumer ها ارسال کنید. Logging and Monitoring: تولید کننده ها می تواننده داده های لاگ را ایجاد کنند و بوسطه کانال ها بفرستند و مصرف کننده ها می توانند این داده ها را دریافت کنند و عملیات انجام دهند. استریم داده: شما با استفاده از این الگو می توانید بصورت Real-time داده را از تولید کننده به مصرف کننده بفرستید تا مصرف کننده گان عملیات لازمه را انجام دهند. "},{"id":121,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-monitor/","title":"9.4.12 الگو Monitor","section":"9.4 الگوهای همزمانی","content":" 9.4.12.1 توضیحات # الگوی مانیتور به گروتین‌ ها اجازه می‌دهد هنگام ورود به حالت خواب بدون مسدود کردن اجرا یا مصرف منابع، منتظر شرایط خاصی باشند.\nحال برای پیاده سازی این الگو ما از ساختاری به نام Cond در پکیج sync کمک میگیریم.\nبه نقل از ویکی پدیا :\nدر برنامه‌نویسی همروند (یا همان برنامه‌نویسی موازی)، مانیتور یک ساختار همگام سازی است که به ریسمان ها این امکان را می‌دهد که هم، انحصار متقابل داشته باشند و هم، بتوانند برای یک وضعیت خاص منتظر بمانند (مسدود شوند) تا وضعیت غلط شود. مانیتورها همچنین دارای یک مکانیسم هستند که به ریسمان‌های دیگر، از طریق سیگنال می‌فهمانند که شرایط آنها برآورده شده‌است. یک مانیتور، حاوی یک شئ میوتکس (قفل) و متغیرهای وضعیت است. یک متغیر وضعیت اساساً، ظرفی از ریسمان ها است که منتظر یک وضعیت خاص هستند. مانیتورها برای ریسمان‌ها مکانیسمی را فراهم می‌کنند، تا به‌طور موقت، و با هدف منتظر ماندن برای برآورده شدن شرایط خاص، دسترسی انحصاری را رها کنند، و سپس دسترسی انحصاری را مجدداً به دست آورند و کار خود را از سر گیرند.\n9.4.12.2 دیاگرام # 9.4.12.3 نمونه کد # 1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;sync\u0026#34; 6) 7 8type Item = int 9 10type Queue struct { 11\titems []Item 12\t*sync.Cond 13} 14 15func NewQueue() *Queue { 16\tq := new(Queue) 17\tq.Cond = sync.NewCond(\u0026amp;sync.Mutex{}) 18\treturn q 19} 20 21func (q *Queue) Put(item Item) { 22\tq.L.Lock() 23\tdefer q.L.Unlock() 24\tq.items = append(q.items, item) 25\tq.Signal() 26} 27 28func (q *Queue) GetMany(n int) []Item { 29\tq.L.Lock() 30\tdefer q.L.Unlock() 31\tfor len(q.items) \u0026lt; n { 32\tq.Wait() 33\t} 34\titems := q.items[:n:n] 35\tq.items = q.items[n:] 36\treturn items 37} 38 39func main() { 40\tq := NewQueue() 41 42\tvar wg sync.WaitGroup 43\tfor n := 10; n \u0026gt; 0; n-- { 44\twg.Add(1) 45\tgo func(n int) { 46\titems := q.GetMany(n) 47\tfmt.Printf(\u0026#34;%2d: %2d\\n\u0026#34;, n, items) 48\twg.Done() 49\t}(n) 50\t} 51 52\tfor i := 0; i \u0026lt; 100; i++ { 53\tq.Put(i) 54\t} 55 56\twg.Wait() 57} 1$ go run main.go 2 1: [ 0] 3 6: [ 1 2 3 4 5 6] 4 5: [ 7 8 9 10 11] 5 4: [12 13 14 15] 6 3: [16 17 18] 7 2: [19 20] 8 9: [21 22 23 24 25 26 27 28 29] 910: [30 31 32 33 34 35 36 37 38 39] 10 8: [40 41 42 43 44 45 46 47] 11 7: [48 49 50 51 52 53 54] در کد فوق ما یک صف ساده ایجاد کردیم و این صف را با استفاده از Cond مدیریت کردیم و ۲ چیز در اینجا انجام دادیم :\n۱۰ تا گوروتین ایجاد شد و تلاش کردند برای consume آیتم ها در یک ردیف و اگر همه آیتم ها یکبار در دسترس نباشد گوروتین ها منتظر می مانند تا زمانیکه آیتم ها افزایش یابند. گوروتین اصلی صفی که ایجاد کردیم با ۱۰۰ تا آیتم پر میکند و برای هر آیتمی که اضافه می شود یکی از گوروتین هایی که منتظر آیتم ها هستش را بیدار میکند تا فرآیند خود را تکمیل کند. 9.4.12.4 کاربردها # پردازش دسته‌ای: اگر مقدار زیادی داده دارید که باید به صورت دسته‌ای پردازش شوند، می‌توانید از Cond برای سیگنال دادن به زمان آماده شدن یک دسته برای پردازش و پایان پردازش استفاده کنید. انتظار برای رویدادهای خارجی: یک Cond را می توان برای انتظار یک رویداد خارجی، مانند سیگنال از یک سرور راه دور یا تکمیل یک کار پس زمینه استفاده کرد. کنترل جریان (Flow Control): اگر چندین گوروتین دارید که باید هماهنگ شوند تا اطمینان حاصل شود که فقط تعداد معینی از گوروتین ها در یک زمان معین اجرا می شوند، می توانید از Cond برای نشان دادن زمان شروع یا توقف یک گوروتین استفاده کنید. قفل کردن و باز کردن قفل منابع: می‌توانید از یک Cond برای همگام‌سازی دسترسی به منابع مشترک با انتظار برای سیگنال قبل از دریافت قفل و علامت‌گذاری زمانی که قفل آزاد می‌شود، استفاده کنید. همگام سازی چندین گوروتین: وقتی چندین گوروتین دارید که روی یک فرآیند کار می کنند و می خواهید مطمئن شوید که همه آنها قبل از رفتن به کار بعدی تمام می شوند، می توانید از یک Cond برای علامت دادن به پایان هر گوروتین استفاده کنید و منتظر بمانید تا همه قبل از انجام کامل شوند. "},{"id":122,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-future/","title":"9.4.13 الگو Future","section":"9.4 الگوهای همزمانی","content":" 9.4.13.1 توضیحات # در زبان گو الگو Future راهی برای نمایش نتیجه یک عملیات ناهمزمان (asynchronous) است که ممکن است آن عملیات هنوز تکمیل نشده باشد اما این الگو به شما این امکان را می دهد کدی بنویسید که طوری رفتار کند که گویی نتیجه یک عملیات فورا در دسترس است. حتی اگر عملیات در پس زمینه در حال اجرا باشد.\n9.4.13.2 دیاگرام # 9.4.13.3 نمونه کد # 1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;time\u0026#34; 6) 7 8type FutureInt struct { 9\tresult chan int 10} 11 12func (f *FutureInt) Get() int { 13\treturn \u0026lt;-f.result 14} 15 16func longRunningTask() *FutureInt { 17\tf := \u0026amp;FutureInt{result: make(chan int)} 18\tgo func() { 19\ttime.Sleep(time.Second) 20\tf.result \u0026lt;- 42 21\t}() 22\treturn f 23} 24 25func main() { 26\tf := longRunningTask() 27\t// Do other things 28\tfmt.Println(\u0026#34;The answer is:\u0026#34;, f.Get()) 29} 1$ go run main.go 2The answer is: 42 در کد فوق ما یک تابع به نام longRunningTask داریم که یک تسک زمانبر را انجام می دهد و در نهایت ساختار FutureInt را بازمیگرداند و نتیجه را داخل فیلد result بواسطه کانال میریزد. حال داخل تابع main یک متغیر f ایجاد کردیم و تابع longRunningTask را داخلش قرار دادیم و پس از آن متد Get را فراخوانی کردیم.\nحال اگر تسک داخل تابع longRunningTask تمام شود و مقدار را داخل کانال result بفرستد ما می توانید مقدار را از طریق متد Get دریافت کنیم و البته تا زمانیکه تسک داخل تابع longRunningTask تمام شود.\n9.4.13.4 کاربردها # درخواست های شبکه: هنگام ایجاد درخواست های شبکه، استفاده از الگوی Future برای نمایش نتیجه درخواست می تواند مفید باشد. کوئری های پایگاه داده: هنگام کوئری از پایگاه داده، می توانید از الگوی Future برای نمایش نتیجه کوئری استفاده کنید. این به شما امکان می دهد کدی بنویسید که به گونه ای رفتار کند که گویی نتیجه بلافاصله در دسترس است، حتی اگر تکمیل کوئری ممکن است کمی طول بکشد. "},{"id":123,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-pipeline/","title":"9.4.14 الگو Pipeline","section":"9.4 الگوهای همزمانی","content":" 9.4.14.1 توضیحات # الگو خط لوله (Pipeline) یکی از پرکاربردی ترین الگوها در همزمانی می باشد شما با استفاده از این الگو می توانید تسک های بزرگ را به تسک های کوچکتر و مستقل تقسیم کنید که می توانند بطور همزمان کار کنند. هر stage داخل یک گوروتین انجام می شود و بواسطه کانال داده ها بین stage های مختلف منتقل می شود.\n9.4.14.2 دیاگرام # 9.4.14.3 نمونه کد # 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func gen(nums ...int) \u0026lt;-chan int { 6\tout := make(chan int) 7\tgo func() { 8\tdefer close(out) 9\tfor _, n := range nums { 10\tout \u0026lt;- n 11\t} 12\t}() 13\treturn out 14} 15 16func sq(in \u0026lt;-chan int) \u0026lt;-chan int { 17\tout := make(chan int) 18\tgo func() { 19\tdefer close(out) 20\tfor n := range in { 21\tout \u0026lt;- n * n 22\t} 23\t}() 24\treturn out 25} 26 27func main() { 28\t// Set up the pipeline. 29\tc := gen(2, 3) 30\tout := sq(c) 31 32\t// Consume the output. 33\tfmt.Println(\u0026lt;-out) // 4 34\tfmt.Println(\u0026lt;-out) // 9 35} 1$ go run main.go 24 39 در مثال فوق ما یک قصد داریم اعدادی را مربع کنیم :\nدر stage اول تابع gen لیست اعدادی را به عنوان ورودی دریافت می کنند و سپس داخل کانال قرار می دهد و سپس کانال فقط دریافت را بازگشت می دهد. در stage دوم تابع sq کانال فقط دریافتی را به عنوان ورودی میگیرد سپس از طریق کانال اعداد را دریافت می کنیم و اعداد را مربع می کنیم و به کانال می فرستیم و در نهایت کانال را بازگشت می دهیم. تابع main شروع کننده Pipeline ما می باشد که در ابتدا اعداد را به تابع gen میفرست و یک کانال فقط دریافت می دهد و این کانال را به stage دوم تابع sq پاس می دهیم تا اعداد مربع شوند. و در آخر از طریق کانال مقادیر مربع شده را می توانیم دریافت کنیم و نمایش دهیم. نکات مهم :\nدر الگو Pipeline مرحله (stage) اول فقط داده هایی که قرار است عملیات را انجام دهیم پاس می دهیم. در سایر stage های به عنوان ورودی و خروجی کانال فقط دریافتی به عنوان پارامتر قرار می دهیم. گوروتین داخل هر stage اجرا می شود و از تابع inline استفاده می کنیم. کانال را داخل گوروتین داخل defer قرار دهید که پس از عملیات کانال بسته شود. از context می توانید برای کنترل عملیات داخل هر stage استفاده کنید, به عنوان مثال اگر قصد داشته باشید عملیاتی را که هر stage هست متوقف کنید کافیه از context استفاده کنید تا کنترل بیشتری داشته باشید. یک مثال کاربردی دیگر\n9.4.14.4 کاربردها # شبکه : یک Pipeline می تواند برای مدیریت چندین اتصال شبکه ورودی با عبور از چندین مرحله مانند تجزیه، فیلتر کردن و مسیریابی استفاده شود. محاسبات چند مرحله ای: یک Pipeline می تواند برای انجام یک سری محاسبات روی داده های ورودی استفاده شود که در آن خروجی یک مرحله به عنوان ورودی برای مرحله بعدی استفاده می شود. پردازش گزارش: یک Pipeline می تواند برای پردازش داده های گزارش با عبور دادن آنها از مراحل مختلف مانند فیلتر کردن، تجزیه، غنی سازی و نمایه سازی استفاده شود. تجزیه و تحلیل داده ها: یک Pipeline می تواند برای پردازش مجموعه داده های بزرگ با عبور از مراحل مختلف مانند فیلتر کردن، نقشه برداری و کاهش استفاده شود. "},{"id":124,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-subscription/","title":"9.4.15 الگو Subscription","section":"9.4 الگوهای همزمانی","content":" 9.4.15.1 توضیحات # الگو Subscription یکی از الگوهای کاربردی برای پیاده سازی consumer می باشد که به یک آدرسی مشترک شوید و در بازده زمانی مختلف درخواست دهید و یکسری اطلاعات دریافت کنید.\n9.4.15.2 دیاگرام # 9.4.15.3 نمونه کد # 1package main 2 3import ( 4\t\u0026#34;context\u0026#34; 5\t\u0026#34;encoding/json\u0026#34; 6\t\u0026#34;fmt\u0026#34; 7\t\u0026#34;io/ioutil\u0026#34; 8\t\u0026#34;log\u0026#34; 9\t\u0026#34;net/http\u0026#34; 10\t\u0026#34;os\u0026#34; 11\t\u0026#34;time\u0026#34; 12) 13 14const exampleAPIAddress = \u0026#34;https://random-data-api.com/api/stripe/random_stripe\u0026#34; 15 16type Card struct { 17\tId uint `json:\u0026#34;id\u0026#34;` 18\tUid string `json:\u0026#34;uid\u0026#34;` 19\tValidCard string `json:\u0026#34;valid_card\u0026#34;` 20\tToken string `json:\u0026#34;token\u0026#34;` 21\tInvalidCard string `json:\u0026#34;invalid_card\u0026#34;` 22\tMonth string `json:\u0026#34;month\u0026#34;` 23\tYear string `json:\u0026#34;year\u0026#34;` 24\tCCV string `json:\u0026#34;ccv\u0026#34;` 25\tCCVAmex string `json:\u0026#34;ccv_amex\u0026#34;` 26} 27 28type Subscription interface { 29\tUpdates() \u0026lt;-chan Card 30} 31 32type Fetcher interface { 33\tFetch() (Card, error) 34} 35 36type sub struct { 37\tfetcher Fetcher 38\tupdates chan Card 39} 40 41type fetcher struct { 42\turl string 43} 44 45type fetchResult struct { 46\tfetchedCard Card 47\terr error 48} 49 50// NewSubscription create subscription for fetch data per freq time in second 51func NewSubscription(ctx context.Context, fetcher Fetcher, freq uint) Subscription { 52\ts := \u0026amp;sub{ 53\tfetcher: fetcher, 54\tupdates: make(chan Card), 55\t} 56\tgo s.serve(ctx, freq) 57\treturn s 58} 59 60func NewFetcher(url string) Fetcher { 61\treturn \u0026amp;fetcher{ 62\turl: url, 63\t} 64} 65 66func (f *fetcher) Fetch() (Card, error) { 67\treturn requestAPI(f.url) 68} 69 70func (s *sub) serve(ctx context.Context, freq uint) { 71\tticker := time.NewTicker(time.Duration(freq) * time.Second) 72\tdone := make(chan fetchResult, 1) 73 74\tvar ( 75\tfetchedCard Card 76\tfetchResponseStream chan Card 77\tpending bool 78\t) 79 80\tfor { 81 82\tif pending { 83\tfetchResponseStream = s.updates 84\t} else { 85\tfetchResponseStream = nil 86\t} 87 88\tselect { 89\tcase \u0026lt;-ticker.C: 90\tif pending { 91\tbreak 92\t} 93\tgo func() { 94\tfetched, err := s.fetcher.Fetch() 95\tdone \u0026lt;- fetchResult{fetched, err} 96\t}() 97\tcase result := \u0026lt;-done: 98\tfetchedCard = result.fetchedCard 99\tif result.err != nil { 100\tlog.Printf(\u0026#34;fetch got error %v\u0026#34;, result.err) 101\tbreak 102\t} 103\tpending = true 104\tcase fetchResponseStream \u0026lt;- fetchedCard: 105\tpending = false 106\tcase \u0026lt;-ctx.Done(): 107\treturn 108\t} 109\t} 110} 111 112func (s *sub) Updates() \u0026lt;-chan Card { 113\treturn s.updates 114} 115 116func requestAPI(url string) (Card, error) { 117\tcard := Card{} 118\treq, err := http.NewRequest(http.MethodGet, url, nil) 119\tif err != nil { 120\treturn Card{}, err 121\t} 122\tres, err := http.DefaultClient.Do(req) 123\tif err != nil { 124\treturn Card{}, err 125\t} 126\tbody, err := ioutil.ReadAll(res.Body) 127\tif err != nil { 128\treturn Card{}, err 129\t} 130\tif err := json.Unmarshal(body, \u0026amp;card); err != nil { 131\treturn Card{}, err 132\t} 133\treturn card, nil 134} 135 136func main() { 137\tctx, cancel := context.WithCancel(context.Background()) 138\tsub := NewSubscription(ctx, NewFetcher(exampleAPIAddress), 3) 139 140\ttime.AfterFunc(1*time.Minute, func() { 141\tcancel() 142\tlog.Println(\u0026#34;canceled subscription task\u0026#34;) 143\tos.Exit(0) 144\t}) 145 146\tfor card := range sub.Updates() { 147\tfmt.Println(card) 148\t} 149} 1$ go run main.go 2{4643 add2475a-ed64-4039-831d-0e95469752d9 371449635398431 tok_mastercard_debit 4000000000000101 01 2024 920 7875} 3{6992 a89e3d71-785a-4d37-9639-be3ce7534257 2223003122003222 tok_discover 4000000000000069 11 2024 660 5241} 4{9287 f665526e-1b34-46f5-9d9d-50362631ed0f 5200828282828210 tok_mastercard_debit 4000000000000036 05 2026 993 6272} 5{4956 e8ae8e75-0ff2-42e8-921c-5cc438d64fac 3566002020360505 tok_amex 4000000000000044 10 2024 371 9989} 6{1193 954d1b36-829b-4726-bbb7-0f5f01b3dd40 6011000990139424 tok_mastercard_debit 4000000000000341 12 2026 331 5119} برای گرفتن دیتا ما یک اینترفیس به نام Subscription با متد Updates تعریف کردیم. 1type Subscription interface { 2\tUpdates() \u0026lt;-chan Card 3} سپس یک اینترفیس دیگر به نام Fetcher برای گرفتن داده از API با متد Fetch تعریف کردیم. 1type Fetcher interface { 2\tFetch() (Card, error) 3} اکنون یک تابع به نام NewSubscription ایجاد کردیم context, NetFetcher و مدت زمان فاصله بین هر درخواست را پاس دادیم. 1ctx, cancel := context.WithCancel(context.Background()) 2sub := NewSubscription(ctx, NewFetcher(exampleAPIAddress), 3) بعد از اینکه ساختار sub را راه اندازی کردیم متد serve را برای اجرا داخل گوروتین قرار دادیم. 1func NewSubscription(ctx context.Context, fetcher Fetcher, freq uint) Subscription { 2\ts := \u0026amp;sub{ 3\tfetcher: fetcher, 4\tupdates: make(chan Card), 5\t} 6\tgo s.serve(ctx, freq) 7\treturn s 8} حال پس از هر time.Ticker به آدرس API مورد نظر بواسطه متد Fetch درخواست ارسال می شود و اطلاعات دریافت می شود به داخل کانال می فرستیم. در نهایت از طریق متد Updates می توانیم اطلاعات را دریافت کنیم.\n9.4.15.4 کاربردها # دریافت اطلاعات از یک تولید کننده (Publisher) یا آدرسی (Pub/Sub) همگام سازی اطلاعات از یک API "},{"id":125,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-brdige-channel/","title":"9.4.16 الگو Bridge Channel","section":"9.4 الگوهای همزمانی","content":" 9.4.16.1 توضیحات # با استفاده از الگو Bridge Channel می توانید بین ۲ کانال داده ای را منتقل کنید فرض کنید یک داده را به کانال input میفرستید و از دریافت داده آن را می توانید به کانال دیگری منتقل کنید و عملا شما یک پل برای انتقال داده ایجاد کردید.\n9.4.16.2 دیاگرام # 9.4.17.3 نمونه کد # 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\t// Declare input and output channels 7\tinput := make(chan int) 8\toutput := make(chan int) 9 10\t// Launch goroutine to act as bridge between channels 11\tgo func() { 12\tfor { 13\t// Wait for value on input channel 14\tvalue := \u0026lt;-input 15 16\t// Forward value to output channel 17\toutput \u0026lt;- value 18\t} 19\t}() 20 21\t// Send a value to the input channel 22\tinput \u0026lt;- 1 23 24\t// Receive the value from the output channel 25\tfmt.Println(\u0026lt;-output) // prints \u0026#34;1\u0026#34; 26} 1$ go run main.go 21 در کد فوق ما ۲ کانال input و output ایجاد کردیم سپس داخل یک گوروتین داده را از کانال input دریافت کردیم و داخل متغیر value قرار دادیم سپس value را به کانال output فرستادیم و در نهایت داده دریافت شده از کانال output را چاپ کردیم.\n9.4.18.4 کاربردها # فیلتر داده ها: یک گوروتین می تواند به عنوان پلی بین یک کانال ورودی و یک کانال خروجی عمل کند، داده ناخواسته را فیلتر کرده و فقط آنهایی را که معیارهای خاصی را برآورده می کنند، ارسال می کند. تبدیل مقادیر: یک گوروتین می تواند به عنوان پلی بین یک کانال ورودی و یک کانال خروجی عمل کند و مقادیر دریافت شده در کانال ورودی را قبل از ارسال به کانال خروجی تبدیل کند. Fan-out: یک گوروتین می تواند به عنوان پلی بین یک کانال ورودی و چندین کانال خروجی عمل کند و مقدار یکسان را به طور همزمان به چندین کانال ارسال کند. Fan-in: یک گوروتین می تواند به عنوان پلی بین چندین کانال ورودی و یک کانال خروجی واحد عمل کند و مقادیر را از چندین کانال به یک کانال به روشی کنترل شده ارسال کند. ترکیب چند کانال: یک گوروتین می تواند به عنوان پلی بین چندین کانال ورودی و یک کانال خروجی واحد عمل کند و مقادیر از چندین کانال را در یک کانال واحد ترکیب کند تا توسط یک گوروتین consume شود. "},{"id":126,"href":"/chapter-9/concurrency-patterns/go-concurrency-pattern-queuing/","title":"9.4.17 الگو Queuing","section":"9.4 الگوهای همزمانی","content":" 9.4.17.1 توضیحات # الگوی \u0026ldquo;صف\u0026rdquo; در زبان گو الگویی است که در آن از یک گوروتین برای بافر کردن و مدیریت ترتیب مقادیر ارسال شده و دریافت شده از یک کانال استفاده می شود.\n9.4.17.2 دیاگرام # 9.4.17.3 نمونه کد # 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\t// Declare the queue channel with a buffer size of 5 7\tqueue := make(chan int, 5) 8 9\t// Send values to the queue 10\tgo func() { 11\tfor i := 0; i \u0026lt; 10; i++ { 12\tqueue \u0026lt;- i 13\tfmt.Println(\u0026#34;Sent:\u0026#34;, i) 14\t} 15\tclose(queue) 16\t}() 17 18\t// Receive values from the queue 19\tfor value := range queue { 20\tfmt.Println(\u0026#34;Received:\u0026#34;, value) 21\t} 22} 1$ go run main.go 2Sent: 0 3Received: 0 4Received: 1 5Sent: 1 6Sent: 2 7Sent: 3 8Sent: 4 9Sent: 5 10Sent: 6 11Sent: 7 12Received: 2 13Received: 3 14Received: 4 15Received: 5 16Received: 6 17Received: 7 18Received: 8 19Sent: 8 20Sent: 9 21Received: 9 در کد فوق ما یک کانال بافر شده با ظرفیت ۵ ایجاد کردیم. سپس داخل یک گوروتین یک حلقه قرار داده از i تا ۱۰ و مقدار i را به کانال فرستادیم و در نهایت کانال را بستیم. سپس یکی حلقه for-range برروی کانال قرار دادیم و مقادیر را دریافت کردیم و سپس چاپ کردیم.\n9.4.17.4 کاربردها # زمان‌بندی کار (Task scheduling): یک کانال می‌تواند به عنوان صف برای نگه‌داشتن وظایفی که باید توسط یک گوروتین worker اجرا و استفاده شود. کارگر وظایف را به ترتیبی که اضافه شده اند از صف می گیرد و آنها را پردازش می کند. بافر کردن داده ها: یک کانال می تواند به عنوان یک بافر برای نگهداری داده های ورودی قبل از پردازش توسط گوروتین دیگر استفاده شود. این می تواند زمانی مفید باشد که سرعت پردازش داده ها کندتر از سرعت دریافت آن باشد. Throttling: یک کانال می تواند به عنوان یک صف برای محدود کردن سرعت پردازش داده ها توسط یک گوروتین استفاده شود. با افزودن یک بافر به کانال، زمانی که بافر پر شود، گوروتین ارسال کننده مسدود می شود و به طور موثر سرعت ارسال داده ها را کاهش می دهد. Logging: یک کانال می تواند به عنوان یک صف برای نگهداری پیام های گزارشی که باید در یک فایل نوشته شود یا از طریق شبکه ارسال شود استفاده شود. کارگر گوروتین پیام‌های گزارش را به ترتیبی که اضافه شده‌اند از صف می‌گیرد و در فایل گزارش می‌نویسد. Multi-threading: یک کانال می تواند به عنوان یک صف برای به اشتراک گذاری داده ها بین گوروتین های مختلف و مدیریت همزمانی برنامه استفاده شود. "},{"id":127,"href":"/chapter-9/cloud-native-patterns/go-cloud-native-circuit-breaker-pattern/","title":"9.5.1 الگو Circuit Breaker","section":"9.5 الگوهای Cloud Native","content":"الگو Circuit Breaker\u0026hellip;\n"},{"id":128,"href":"/chapter-9/cloud-native-patterns/go-cloud-native-debounce-pattern/","title":"9.5.2 الگو Debounce","section":"9.5 الگوهای Cloud Native","content":"الگو Debounce\u0026hellip;\n"},{"id":129,"href":"/chapter-9/cloud-native-patterns/go-cloud-native-retry-pattern/","title":"9.5.3 الگو Retry","section":"9.5 الگوهای Cloud Native","content":"الگو Retry\u0026hellip;\n"},{"id":130,"href":"/chapter-9/cloud-native-patterns/go-cloud-native-throttle-pattern/","title":"9.5.4 الگو Throttle","section":"9.5 الگوهای Cloud Native","content":"الگو Throttle\u0026hellip;\n"},{"id":131,"href":"/chapter-9/cloud-native-patterns/go-cloud-native-timeout-pattern/","title":"9.5.5 الگو Timeout","section":"9.5 الگوهای Cloud Native","content":"الگو Timeout\u0026hellip;\n"},{"id":132,"href":"/chapter-9/anti-pattern/go-anti-patterns-in-syntax/","title":"9.6.1 ضد الگو سینتکسی","section":"9.6 ضد الگوها (Anti-Patterns)","content":"ضد الگو سینتکسی\n"}]