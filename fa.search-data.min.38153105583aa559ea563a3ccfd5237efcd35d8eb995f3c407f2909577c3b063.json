[{"id":0,"href":"/preface/","title":"پیشگفتار","section":"صفحه اصلی","content":" چرا از گو استفاده می‌کنیم؟\nشناخت نیازمندی و ابزارهای پیاده‌سازی وابسته به آن.\nانواع منابع موجود جهت کسب اطلاعات و مقایسه‌ی آنها.\nمنابع مکتوب. سایت رسمی زبان گو. https://go.dev در نسخه حال‌حاضر وب‌سایت رسمی گو، مستندات لازم برای شناخت انواع جزئیات وجود دارد. ضمن‌اینکه یک خودآموز مختصر، جهت آشنایی ابتدایی مفاهیم را می‌توانید پیدا کنید. کتاب‌ها. اصولاً استفاده از کتاب‌ها بدلیل اینکه عمدتاً توسط اساتید، متخصصین شناخته‌شده نگارش می‌شود، توصیه می‌گردد. ضمن اینکه کتاب‌ها معمولاً امکان اصلاحات مستمر و انتشار نسخه‌های جدید و به‌روزتر رو دارا هستند و توسط ناشران معتبر منتشر می‌شوند. مقالات. بدلیل راحت‌تر بودن نشر مقالات، طبیعتاً امکان وجود هرنوع مطلبی با هر سطح و کیفیتی از محتوا وجود دارد. بنابراین، در استفاده از این نوع منابع، احتیاط و حساسیت بالاتری مورد نیاز است. منابع صوتی و تصویری. مزیت بزرگ این نوع از منابع، سرعت و امکانات کافی در انتقال مطلب است. اما اشکالی که وجود دارد عدم امکان ساده‌ی اصلاح محتوا و به‌روزرسانی آن است. ضمن‌اینکه این نوع از منابع، مانند مقالات توسط افراد مختلف و با طیفی از انواع کیفیت‌های متفاوت، وجود دارد. بررسی وضعیت منابع فارسی زبان گو در زمان تهیه این کتاب. درحال‌حاضر منابع نگارشی با کیفیت مناسب به‌زبان فارسی بسیار محدود است. این یکی از دلایل «چرایی» نگارش این کتاب به‌زبان فارسی است. ما امیدواریم با مشارکت همه اساتید و متخصصین این حوزه، این کتاب منبع آموزشی باکیفیت، دردسترس عموم متقاضیان، جهت توسعه ابزارهای حرفه‌ای با زبان گو باشد.\nچرا به زبان فارسی می‌نویسیم. دوستان و همکاران بسیاری هستند،‌که این سوال را مطرح می‌کنند که وقتی نیاز به دانش زبان انگلیسی، برای کسب مهارت در این تخصص، یک «باید» محسوب می‌شود، چرا مطلب فارسی؟ جواب این سوال ساده‌تر از پیجیدگی‌هایی هست که بنظر می‌رسد: − ایجاد و رونق جامعه تخصصی فارسی‌زبان توسط موضوع «کتاب» − ایجاد فضایی جهت ایحاد پرسش و پاسخ فارسی‌زبان‌ها − ارائه یک ترجمه فارسی، از منابع اصلی تخصصی، با امکان مقایسه برداشت افراد مختلف از زبان تخصصی − سرعت دادن به یادگیری، حداقل در مفاهیم ابتدایی − برای نوجوانان و افرادی که به‌هر دلیل، درحال‌حاضر تسلط کافی روی زبان انگلیسی ندارند و ارائه راهکار جهت تمرین و شروع یادگیری منابع روی زبان تخصصی\nبرای چگونگی نگارش کتاب می‌توان به موارد زیر اشاره کرد:\nچگونه از جامعه تخصصی، می‌توان در آموزش،بهینه‌سازی و رشد دانش متقاضیان این تخصص استفاده کرد. یکی از وظایف هر استاد، تربیت «شاگرد» و توسعه دانش است. افراد تازه‌کار با دانش و تجربه پیشکسوتان، با سرعت و کیفیت بالاتر، تبدیل به متخصصین جدید خواهند شد. کیفیت جامعه متخصصین، امکان کنترل مصرف منابع و تولید ابزارهای مفید را تعیین خواهد کرد.\nچرخ را از نو نسازیم، تجربه‌ها را از نو «تجربه» نکنیم، آموزش ببینیم و آموزش بدهیم.\n«کلمات» قدرت دارند. به درک و استفاده از کلمات احترام بگذاریم. در جامعه تخصصی حتی چند‌برابر !!!\nدانش امروز، در هر رشته و هر سطح برآیند «انتقال» پیشینیان ما هست. بجای غرور ناشی از آن می‌توان از انتقال با احترام آن به دیگران لذت برد.\nکار تیمی، به فرهنگ «با هم کار کردن» نیازمند هست.\n... اصلاح و تکمیل می‌شود ...\n"},{"id":1,"href":"/history/","title":"تاریخچه","section":"صفحه اصلی","content":"زبان گو (Go) در سال ۲۰۰۷ (به شمسی: ۱۳۸۶) توسط «شرکت گوگل» با هدف افزایش بهره‌وری برنامه‌نویسی در محیط چندهسته‌ای، رایانه‌های شبکه‌ای و کدبیس‌های بزرگ طراحی شد [به نقل از ویکی پدیا] و سپس به عنوان یک زبان کامپایلری و تایپ استاتیک در نوامبر سال ۲۰۰۹ بصورت عمومی با هدف کامپایل کارآمد ، اجرای کارآمد وسهولت برنامه نویسی معرفی شد که توسط شرکت گوگل توسعه داده شده است و بسیاری از اعضای تیم طراحی و توسعه زبان گو [Ken Thompson, Rob Pike, Robert Griesemer] سال ها تجربه در زمینه تحقیق و توسعه زبان برنامه نویسی دارند.\nزبان گو دارای یک سری ویژگی های منحصر به فرد می باشد و برخی از ویژگی هایش از سایر زبان ها الهام گرفته شده است :\nپشتیبانی از برنامه نویسی همزمانی بصورت Built-in گوروتین ها امکان اجرای همزمانی توابع را فراهم می کند و همچنین گوروتین ها واقعا خیلی سبک هستند به طوری که شما می توانید هزاران گوروتین را همزمان در سخت افزارهای مدرن بدون هیچ مشکل عملکردی اجرا کنید. کانال ها برپایه مدل CSP می باشد که امکان همگام سازی داده ها بین گوروتین ها را فراهم می کند. پشتیبانی از تایپ های map و slice امکان پیاده سازی پلی مورفیسم با استفاده از اینترفیس ها پوینترها کلوژر توابع (یک تابع معمولی که داخل یک تابع دیگر به عنوان بازگشت تعریف می شود) متدها امکان defer برای تعویق فراخوانی یک تابع قابلیت جاسازی تایپ ها ایمنی حافظه در زبان گو قابلیت زباله جمع کن خودکار سازگاری کامل با انواع پلتفرم ها نظیر [linux, windows, mac, AIX, android, freeBSD] جهت توسعه و کامپایل امکان Cross-compile با این امکان می توانید در هر پلتفرمی برای سایر پلتفرم ها کامپایل کنید پشتیبانی از جنریک یا تایپ پارامتر (از نسخه ۱.۱۸) تست نویسی آسان اینترفیس و رفلکشن زبان گو مثل سایر زبان ها نظیر c, cpp یا java نیاز به نقطه ویرگول (Semicolons) ندارد و به نسبت زبان هایی که معرفی کردیم پرانتز کمتری استفاده می کند و همچنین ظاهر سینتکس گو خیلی خواناتر و راحتر می باشد. علاوه بر ویژگی های که در بالا معرفی کردیم یک سری نکات برجسته در خصوص زبان گو وجود دارد که به شرح زیر می باشند:\nسینتکس زبان گو به گونه ای طراحی شده که خیلی ساده و تمیز می باشد و این باعث می شود خیلی سریع زبان گو را یاد بگیرید و از همه مهم تر توسعه پروژه های مقیاس پذیر مقیاس پذیر با زبان گو به دلیل سادگی و آشکار بودن مفاهیم خیلی سریعتر صورت میگیرد.\nزبان گو دارای کلی پکیج های استاندارد و کاربردی جهت توسعه می باشد که همه این پکیج ها در انواع پلتفرم ها جهت توسعه قابل استفاده است.\nزبان گو دارای یک جامعه بزرگ از توسعه دهندگان و انجمن های فعال می باشد که خیلی سریع می توانید به پاسخ سوالات خود برسید.\nبرنامه نویس های زبان گو را گوفر صدا میزنند. "},{"id":2,"href":"/installation/","title":"آموزش نصب","section":"صفحه اصلی","content":"جهت نصب زبان گو برروی سیستم عامل مورد نظر خود در ابتدا باید نسخه مناسب با پلت فرم خود را دانلود کنید.\nلینوکس در اینجا نسخه مرتبط با لینوکس خود را دانلود کنید. 1$ wget -c https://go.dev/dl/go1.xx.x.linux-amd64.tar.gz سپس دستور زیر را بزنید تا اگر نسخه قبلی وجود دارد پاک شود و نسخه جدید در مسیر usr/local/go/ جایگزین شود. 1$ sudo rm -rf /usr/local/go \u0026amp;\u0026amp; sudo tar -C /usr/local -xzf go1.xx.x.linux-amd64.tar.gz افزودن مسیر usr/local/go/bin/ به متغیرهای محیطی 1export PATH=$PATH:/usr/local/go/bin بهتر است برای اینکه هر بار ترمینال را باز میکنید و فایل go توسط shell شناخته شود دستور فوق را به فایل home/{user}/.profile/ اضافه کنید. جهت اطمینان از اینکه زبان گو بدرستی برروی سیستم عامل شما نصب شده است دستور زیر را داخل ترمینال بزنید. 1$ go version ویندوز روش اول # در اینجا نسخه مرتبط با ویندوز خود را دانلود کنید. سپس فایل go1.xx.x.windows-{arch}.msi را اجرا کنید. مراحل نصب را بصورت پیش فرض طی کنید تا زبان گو برروی ویندوز نصب شود. پس از نصب جهت اطمینان از نصب بود زبان گو مراحل زیر را انجام دهید: وارد منو استارت شوید. در منو استارت کلمه cmd را جستجو کنید و سپس آن را اجرا کنید. داخل خط فرمان دستور زیر را بزنید تا از نصب بودن زبان گو اطمینان حاصل فرمایید. 1go version روش دوم # برای نصب گو می‌توانید از Chocolatey Package Manager استفاده کنید.\nخط فرمان PowerShell را به صورت Administrator باز کنید و دستور زیر را داخل PowerShell بزنید. 1Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString(\u0026#39;https://community.chocolatey.org/install.ps1\u0026#39;)) بعد از نصب می‌توانید از دستور choco برای نصب گو استفاده کنید. 1choco install golang جهت اطمینان از اینکه زبان گو بدرستی برروی سیستم عامل شما نصب شده است دستور زیر را داخل ترمینال بزنید. 1$ go version دقت داشته باشید برای نصب برنامه‌های مختلف مثل git و یا ابزارهای دیگر در محیط Administrator باید از دستور choco استفاده کنید. مکینتاش روش اول # در اینجا نسخه مرتبط با مکینتاش خود را دانلود کنید. سپس فایل go1.xx.x.darwin-{arch}.pkg را اجرا کنید. مراحل نصب را بصورت پیش فرض طی کنید تا زبان گو برروی مکینتاش نصب شود. پس از نصب اگر ترمینال باز بود آن را کامل ببنید تا تغییرات صورت گیرد. جهت اطمینان از اینکه زبان گو بدرستی برروی سیستم عامل شما نصب شده است دستور زیر را داخل ترمینال بزنید. 1$ go version روش دوم # برای نصب گو میتوانید از Homebrew Package Manager استفاده کنید.\nبرای نصب brew می‌توانید ترمینال خود را باز کنید و از دستور زیر استفاده کنید. 1$ /bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026#34; بعد از نصب brew از دستور زیر برای نصب گو داخل ترمینال استفاده کنید. 1$ brew update \u0026amp;\u0026amp; brew install golang جهت اطمینان از اینکه زبان گو بدرستی برروی سیستم عامل شما نصب شده است دستور زیر را داخل ترمینال بزنید. 1$ go version "},{"id":3,"href":"/toolchain/","title":"ابزارها, دستورات گو و معرفی IDE","section":"صفحه اصلی","content":"پس از اینکه زبان گو را برروی سیستم خود نصب کردید از طریق ترمینال و یا خط فرمان ویندوز قابل دسترس است که می توانید با زدن کلمه go یکسری عملیات انجام دهید:\n1$ go 2Go is a tool for managing Go source code. 3 4Usage: 5 6\tgo \u0026lt;command\u0026gt; [arguments] 7 8The commands are: 9 10\tbug start a bug report 11\tbuild compile packages and dependencies 12\tclean remove object files and cached files 13\tdoc show documentation for package or symbol 14\tenv print Go environment information 15\tfix update packages to use new APIs 16\tfmt gofmt (reformat) package sources 17\tgenerate generate Go files by processing source 18\tget add dependencies to current module and install them 19\tinstall compile and install packages and dependencies 20\tlist list packages or modules 21\tmod module maintenance 22\twork workspace maintenance 23\trun compile and run Go program 24\ttest test packages 25\ttool run specified go tool 26\tversion print Go version 27\tvet report likely mistakes in packages 28 29Use \u0026#34;go help \u0026lt;command\u0026gt;\u0026#34; for more information about a command. 30 31Additional help topics: 32 33\tbuildconstraint build constraints 34\tbuildmode build modes 35\tc calling between Go and C 36\tcache build and test caching 37\tenvironment environment variables 38\tfiletype file types 39\tgo.mod the go.mod file 40\tgopath GOPATH environment variable 41\tgopath-get legacy GOPATH go get 42\tgoproxy module proxy protocol 43\timportpath import path syntax 44\tmodules modules, module versions, and more 45\tmodule-get module-aware go get 46\tmodule-auth module authentication using go.sum 47\tpackages package lists and patterns 48\tprivate configuration for downloading non-public code 49\ttestflag testing flags 50\ttestfunc testing functions 51\tvcs controlling version control with GOVCS 52 53Use \u0026#34;go help \u0026lt;topic\u0026gt;\u0026#34; for more information about that topic. جدول دستورات (Commands) # دستور توضیحات build با این دستور می توانید فایل go را کامپایل go build main.go کنید. clean با این دستور می توانید فایل های کش شده را پاکسازی کنید doc با این دستور می توانید به داکیومنت هر یک از توابع عمومی go doc fmt.Println را ببینید env با این دستور می توانید متغیرهای محیطی تنظیم شده زبان گو را ببینید و آنها را با دستور go env -w key=value مقدار دهی کنید. fmt با این دستور می توانید کدهای خود را مرتب go fmt ./... کنید. install با استفاده از این دستور می توانید یکسری پکیج های را گرفته و کامپایل کنید جهت استفاده list لیست پکیج ها و ماژول های دانلود شده generate با این دستور می توانید از قابلیتGenerator زبان گو استفاده کنید و فایل generate کنید. mod برای مدیریت و ایجاد فایل mod به ازای هر پروژه get با این دستور می توانید پکیجی را دانلود یا بروز رسانی کنید و همچنین برای استفاده از این دستور نیاز به git دارید که نصب باشد work با این دستور می توانید یک workspace ایجاد کنید و آن را مدیریت کنید. run با این دستور می توانید فایل های گو یا پروژه را go run main.go اجرا کنید test با این دستور می توانید فایل های تست را go test example_test.go اجرا کنید version با این دستور می توانید نسخه نصب شده زبان گو را ببینید vet با این دستور می توانید اشتباهات کدهای خود را ببینید اجرای کد ساده در زبان گو # در زیر یک نمونه کد ساده قرار دادیم که به سادگی می توانید با دستور go run main.go اجرا کنید و خروجی را ببینید.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 fmt.Println(\u0026#34;Hello world!!!\u0026#34;) 7} 1$ go run main.go 2Hello world!!! در کد فوق ما یکسری کلید واژه نظیر package , import , func استفاده کردیم که در بخش 1.2 کلید واژه و شناسه‌ها آشنا می شوید.\nانواع نرم افزارهای محیط توسعه (IDE) # زبان گو هم مثل سایر زبان ها دارای یکسری نرم افزار محیط توسعه می باشد. که در زیر محبوبترین ها را معرفی می کنیم.\nنرم افزار Jetbrains Goland اگر با سایر محصولات جت برینز آشنا باشید به راحتی از این نرم افزار محیط توسعه استفاده کنید. نرم افزار VsCode تقریبا همه برنامه نویس ها باهاش آشنا هستند یک نرم افزار محیط توسعه متن باز می باشد که خیلی محبوب است بین برنامه نویس ها است و برای استفاده زبان گو در این نرم افزار باید افزونه vscode-go را نصب کنید. نرم افزار Vim یک نرم افزار متن باز و معروف می باشد که داخل ترمینال قابل استفاده است و ازش می توانید جهت توسعه با زبان گو استفاده کنید و البته نیازمند نصب پلاگین می باشد. "},{"id":4,"href":"/roadmap/","title":"نقشه یادگیری زبان گو","section":"صفحه اصلی","content":"در زیر ما نقشه یادگیری زبان گو را براساس داده های سایت roadmap.sh قرار دادیم که در ابتدا باید طبق نقشه یادگیری زبان گو شروع کنید و سپس برای افزایش دانش خود به نقشه یادگیری بک اند نگاهی بندازید.\nنقشه یادگیری زبان گو نقشه یادگیری بک اند "},{"id":5,"href":"/chapter-1/","title":"فصل اول: آشنایی با مفاهیم گو","section":"صفحه اصلی","content":"در فصل اول به مفاهیم پایه زبان برنامه نویسی گو بطور عمیق می بپردازیم. این فصل شامل چندین بخش هستش که در زیر بطور مختصر توضیح دادیم :\nبخش اول : ساختار کد گو بخش دوم : کلید واژه ها و شناسه ها بخش سوم : تایپ های پایه نظیر اعداد صحیح, float, رشته و boolean بخش چهارم : عملگرها نظیر = - / * + \u0026gt; \u0026lt; بخش پنجم : متغیرها و ثابت ها بخش ششم : تابع بخش هفتم : آرایه و slice بخش هشتم : نقشه بخش نهم : عبارات شرطی و switch بخش دهم : انواع حلقه ها بخش یازدهم : کار با پکیج ها و نحوه استفاده از پکیج بخش دوازدهم : به defer , panic, recovery می پردازیم "},{"id":6,"href":"/chapter-1/structure-of-go-code/","title":"1.1 ساختار کد گو","section":"فصل اول: آشنایی با مفاهیم گو","content":"همانطور که در تاریخچه زبان گو گفتیم, زبان گو سینتکس خیلی تمیز و ساده ای دارد که به راحتی می توانید کدهای زبان گو را بخوانید. در ادامه ما سعی می کنیم با مثال های ساده شما را با ساختار کد زبان گو آشنا کنیم.\nبه نقل از تاریخچه سینتکس زبان گو به گونه ای طراحی شده که خیلی ساده و تمیز می باشد و این باعث می شود خیلی سریع زبان گو را یاد بگیرید و از همه مهم تر توسعه پروژه های مقیاس پذیر با زبان گو به دلیل سادگی و آشکار بودن مفاهیم خیلی سریعتر صورت میگیرد. زبان برنامه نویسی # یک زبان برنامه‌نویسی یک زبان مصنوعی انگلیسی است که برای بیان محاسباتی که توسط یک ماشین (مخصوصاً رایانه) قابل انجام است، طراحی شده‌است. زبان‌های برنامه‌نویسی برای ایجاد برنامه‌هایی به کار می‌روند که رفتار یک ماشین را مشخص می‌کنند، الگوریتم دقیق را بیان می‌کنند، یا روشی برای تعامل انسان و رایانه هستند. بسیاری از زبان‌های برنامه‌نویسی تعدادی قالب از ویژگی‌های نوشته شده دستوری یا نحو (syntax) و معناشناسی (semantics) دارند، چرا که رایانه‌ها دستورهای دقیقاً مشخص نیاز دارند. برخی توسط سند خصوصیات (specification document) تعیین شده‌اند (برای مثال یک استاندارد ISO)، در حالی که برخی دیگر دارای پیاده‌سازی غالبی می‌باشند[به نقل از ویکی پدیا].\nیک نمونه کد ساده زبان گو # قبل از اینکه محتوای بدنه کد زیر را بررسی کنید بهتره نحوه کامنت گذاری کد در زبان گو آشنا شوید.\nکامنت گذاری # کامنت ها در زبان گو همانند زبان سی می باشد که با استفاده از ۲ اسلش ایجاد میشود.\n1// کامنت عادی یک خطی 2 3/* 4بلاک کامنت برای نوشتن کامنت چند خطی 5*/ نمونه کد # در پایین یک نمونه کد قرار دادیم که با کامنت هر کدام از بخش های بدنه کد گو را توضیح دادیم\n1package main // نام پکیج فایل سورس را مشخص می کند 2 3import \u0026#34;math/rand\u0026#34; // یک پکیج استاندارد ایمپورت شده 4 5const MaxRnd = 16 // یک ثابت تعریف شده است 6 7// تابع 8func StatRandomNumbers(n int) (int, int) { 9\tvar a, b int 10\tfor i := 0; i \u0026lt; n; i++ { 11\tif rand.Intn(MaxRnd) \u0026lt; MaxRnd/2 { 12\ta = a + 1 13\t} else { 14\tb++ 15\t} 16\t} 17\treturn a, b 18} 19 20// تابع main اولین نقطه شروع اجرای کد شما می باشد که در این تابع سایر موارد تعریف می شود. 21func main() { 22\tvar num = 100 23\tx, y := StatRandomNumbers(num) 24\tprint(\u0026#34;Result: \u0026#34;, x, \u0026#34; + \u0026#34;, y, \u0026#34; = \u0026#34;, num, \u0026#34;? \u0026#34;) 25\tprintln(x+y == num) 26} سورس کد بالا را در فایلی با نام main.go ذخیره می کنیم و سپس با دستور زیر اجرا می کنیم تا خروجی کد فوق را ببینیم :\n1$ go run basic-code-element-demo.go 2Result: 46 + 54 = 100? true تابع main # در زبان گو پکیج main به عنوان یک پکیج منحصربه فرد در نظر گرفته می‌شود، به شکلی که در هنگام اجرای برنامه مشخص میکند شروع کار و خواندن برنامه از کجا باید باشد. در نهایت داخل این پکیج ما تابع ()main را داریم که این تابع نقطه شروع اجرای برنامه ما خواهد بود. این تابع هیچ ارگومانی نمیگیرد و هیچ چیزی رو هم بازگشت نخواهد داد. زبان گو به صورت خودکار تابع ()main را فراخوانی می‌کند. برای همین نیازی به فراخوانی این تابع توسط شما وجود ندارد. برای همین باید دقت داشته باشید در هر برنامه ای که می‌نویسید حتما از پکیج و تابع main باید استفاده کنید.\n1// تعریف پکیج main 2package main 3 4// تعریف تابع main 5func main() { 6\tprintln(\u0026#34;Hello GoFarsi!\u0026#34;) 7} اجرای کد # برای اجرای کدهای گو می‌توان از پارامتر run استفاده کرد.\n1$ go run main.go 2Result: Hello GoFarsi! دستور بالا ابتدا داخل پوشه temp سیستم شما یک فایل اجرایی را درست میکند و سپس آن فایل را اجرا میکند و در نهایت خروجی را به ما نشان میدهد. اگر شما بخواهید خروجی فایل اجرایی (executable) داشته باشید و سپس آن را اجرا کنید می‌توانید از دستور زیر استفاده کنید:\n1$ go build main.go 2$ ./main 3Result: Hello GoFarsi! اگر بخواهید برای خروجی فایل اجرایی اسمی در نظر بگیرید میتوانید از دستور زیر با پارامتر o- استفاده کنید.\n1$ go build -o goFarsi main.go 2$ ./goFarsi 3Result: Hello GoFarsi! دقت کنید اگر از سیستم عامل ویندوز استفاده میکنید بعد از وارد کردن اسم پسوند exe را نیز اضافه کنید. برای راحتی و سرعت بخشیدن هنگام توسعه ما از دستور go run استفاده می‌کنیم. بررسی syntax # برخلاف بیشتر زبان‌های برنامه نویسی در زبان گو شما نمی‌توانید از حالت های مختلف برای نوشتن کد خود استفاده کنید. مثلا کد زیر هنگام کامپایل کردن خطا میدهد.\n1package main 2 3func main() 4{ 5\tprintln(\u0026#34;not compiled\u0026#34;) 6} خروجی کد بالا :\n1$ go run main.go 2Result: 3# command-line-arguments 4.\\main.go:4:1: syntax error: unexpected semicolon or newline before { صرفا با تغییر براکت ما با خطا مواجه شدیم. شاید از دید شما این نوع نوشتن کد نباید خطا ایجاد کند. ولی وقتی شما داخل یک تیم هستید و مجبور هستید کدها را بازخوانی کنید تا بفهمید چه اتفاقی افتاده است، با حالتهای مختلف سینتکس مواجه نخواهید شد، و همه کدها یک دست و از یک ساختار پیروی می‌کند. که باعث خواندن سریع تر، درک بهتر و امکان توسعه سریعتر را برای ما و هم تیمی های ما ایجاد خواهد کرد.\nاستفاده از go fmt # برای آنکه از این نوع خطاها جلوگیری شود و فرمت مناسب و یک نواختی داخل کدهای ما وجود داشته باشد، خود IDEها این خطاها را بهمون نشون میدن. خود توسعه دهندگان زبان گو پارامتر fmt یا به عبارتی فرمت را در اختیار ما قرار داده اند تا هر زمان که کدی مینویسم و ذخیره میکنیم بتوانیم با استفاده از این دستور ساختار کد خود را مرتب کنید و اگر خطایی وجود داشته باشد قبل از کامپایل کردن برنامه آن را پیدا و رفع کنیم. مثلا خروجی استفاده از پارامتر fmt\n1$ go fmt main.go 2Result: 3.\\main.go:4:1: unexpected semicolon or newline before { حالا فرض کنید کدی را نوشته اید و داخل کد شما فضای زیادی وجود دارد و اندازه tab ها و space ها مشخص نیست. به مثال زیر توجه کنید:\n1package main 2 3func main(){ 4 5 6 7\tprintln(\u0026#34;print line 1\u0026#34;) 8\t9\t10\t11\t12println(\u0026#34;print line 2\u0026#34;) 13\t14\t15} وقتی کدی شبیه کد بالا را دارید و از دستور go fmt استفاده میکنیم خروجی کد بالا به شکل زیر تغییر پیدا می‌کند:\n1package main 2 3func main() { 4 5\tprintln(\u0026#34;print line 1\u0026#34;) 6\t7\tprintln(\u0026#34;print line 2\u0026#34;) 8} در برنامه فوق ما یکسری کلمات کلیدی نظیر package, import, const, func, var , for, if, else, return استفاده کردیم و سایر کلماتی که داخل کد فوق دیدید به عنوان شناسه می باشد. برای اطلاعات بیشتر در خصوص کلید واژه و شناسه لطفا بخش کلید واژه و شناسه ها را مطالعه فرمایید. "},{"id":7,"href":"/chapter-1/go-built-in-keywords-identifiers/","title":"1.2 کلید واژه و شناسه‌ها","section":"فصل اول: آشنایی با مفاهیم گو","content":"در این بخش قصد داریم به کلید واژه و شناسه های زبان گو بپردازیم.\nکلید واژه # زبان گو تا نسخه فعلی فقط ۲۵ تا کلید واژه دارد که به شرح زیر است:\n1 2 3 4 5 1 break default func interface select 2 case defer go map struct 3 chan else goto package switch 4 const fallthrough if range type 5 continue for import return var کلمات کلیدی فوق به ۴ دسته تقسیم می‌شوند که به شرح زیر می‌باشد:\nکلمات کلیدی که بصورت گلوبال در بدنه قرار می‌گیرند «package, import, type, var, const, func» کلمات کلیدی کامپوزیت «struct, inteface, map, chan» کلمات کلیدی که در جریان کنترل کد استفاده می‌شوند «break, case, continue, default, if, else, for, fallthrough, goto, range, return, switch, select» در بخش های دیگر کتاب ما بطور مفصل به مفاهیم کلمات کلیدی فوق می‌پردازیم. شناسه‌ها # شناسه توکنی است که باید از حروف یونیکد, ارقام یونیکد (اعداد دسته بندی شده در استاندارد ۸.۰ یونیکد) و خط زیرین ـ تشکیل شده باشد.\nعلامت کاربرد ـ نادیده گرفتن \u0026amp; دسترسی به آدرس حافظه * دسترسی مقدار داخل یک خانه حافظه قوانین شناسه‌ها # نامگذاری باید از حروف a-z یا A-Z و یا 0-9 باشد. نام شناسه‌ها نباید با اعداد شروع شود. نام شناسه‌ها به حروف بزرگ و کوچک حساس می‌باشد. استفاده از کلید واژه ممنوع می‌باشد. هیچ محدودیتی در تعداد حروف نام شناسه وجود ندارد و مطلوب ترین حالت ۴ الی ۱۵ حرف می‌باشد. 1// شناسه‌های معتبر 2 3_geeks23 4geeks 5gek23sd 6Geeks 7geeKs 8geeks_geeks 9 10// شناسه‌های نامعتبر 11 12212geeks 13if 14default در زبان گو یکسری شناسه‌ها از قبل برای برخی از بخش های کد تعیین شده است که در زیر می‌توانید ببینید :\n1// Constant (ثابت ها) 2 3true, false, iota, nil 4 5// Types (تایپ ها) 6 7int, int8, int16, int32, int64, uint, 8uint8, uint16, uint32, uint64, uintptr, 9float32, float64, complex128, complex64, 10bool, byte, rune, string, error 11 12// Functions (توابع) 13 14make, len, cap, new, append, copy, close, 15delete, complex, real, imag, panic, recover "},{"id":8,"href":"/chapter-1/go-basic-types/","title":"1.3 تایپ های پایه","section":"فصل اول: آشنایی با مفاهیم گو","content":" تایپ چیست؟ # یک تایپ مشخص کننده نوع داده است، که به کامپایلر می‌گوید قرار است چه نوع داده ای داخل یک متغییر ذخیره گردد. زبان ها انواع تایپ های مختلفی به صورت پیشفرض دارند که می‌توان از آن‌ها داخل برنامه خود استفاده کرد. ما می‌توانیم تایپ ها را به دو دسته کلی تعریف کنیم.\nتایپ ایستا (Static Type) # زبانی مثل زبان گو یک زبان تایپ ایستا است، یعنی وقتی ما یک داده ای از نوع عددی داخل یک متغیر تعریف می‌کنیم داخل همان متغیر امکان اضافه کردن داده ای غیر داده عددی وجود ندارد.\nتایپ پویا (Dynamic Type) # زبان‌هایی مثل PHP، JavaScript و \u0026hellip; جزو زبان‌های تایپ پویا هستند. یعنی وقتی یک متغیری از نوع عددی تعریف می‌کنیم می‌توانیم به همان متغیر مقادیر دیگه‌ای مثل مقادیر رشته‌ای اضافه کنیم.\nبرای اطلاعات بیشتر می‌توان تایپ سیستم را داخل ویکی‌پدیا مطالعه کنید.\nتایپ‌ها در زبان گو # زبان گو مثل سایر زبان‌ها یکسری تایپ‌های پایه دارد که در هر بخش از کد گو می‌توانید استفاده کنید. در ادامه ما این تایپ ها را با مقادیر پیش فرض‌شان معرفی می کنیم.\nتایپ محدوده مقدار پیش فرض یا مقدار صفر حجم استفاده از حافظه int بستگی به معماری سیستم عامل که ۳۲ بیت یا ۶۴ بیت باشد 0 ۴ یا 8 بایت int8 128- تا 127 0 ۱ بایت int16 32768- تا 32767 0 ۲ بایت int32 2147483648- تا 2147483647 0 ۴ بایت int64 9223372036854775808- تا 9223372036854775807 0 8 بایت uint بستگی به معماری سیستم عامل که ۳۲ بیت یا ۶۴ بیت باشد 0 ۴ یا 8 بایت uint8 0 تا 255 0 ۱ بایت uint16 0 تا 65535 0 ۲ بایت uint32 0 تا 6294967295 0 ۴ بایت uint64 0 تا 18446744073709551615 0 8 بایت uintptr عدد خیلی بزرگ 0 ۸ بایت float32 IEEE-754 0 ۴ بایت float64 IEEE-754 0 ۸ بایت complex64 - 0+0i ۸ بایت complex128 - 0+0i ۱۶ بایت bool - false ۱ بایت string - \u0026quot; \u0026quot; ۸ بایت زبان گو بطور پیش فرض از دو نوع تایپ با نام مستعار پشتیبانی می کند :\nتایپ byte این تایپ نام مستعار برای تایپ uint8 می باشد. تایپ rune این تایپ نام مستعار برای تایپ int32 می باشد. سفارشی‌سازی تایپ‌(ها) # نام‌گذاری جدید : برای تایپ‌های رشته‌ای، عددی و بول، می‌توان نام سفارشی جدید انتخاب و در پروژه استفاده کرد: 1 2/* type alias */ 3 4// bul and bool define the same type. 5type bul = bool 6// content and string define the same type. 7type content = string 8// UI8, uint8 and byte define the same type. 9type UI8 = uint8 10// Word, rune and int32 define the same type. 11type Word = rune ایجاد تایپ جدید معادل یک تایپ موجود : همچنین می‌توان از تایپ‌های موجود، یک نمونه جدید ایجاد کرد: 1/* type definition */ 2 3// state and bool are two different types. 4type state bool 5// str and string are two different types. 6type str string 7// ID and uint64 are two different types. 8type ID uint64 9// decimal and float32 are two different types. 10type decimal float32 مقدار پیش فرض تایپ ها # هر یک از تایپ ها در زبان گو دارای مقدار پیش فرضی می باشد که به شرح زیر است :\nتایپ بولین مقدار پیش فرضش false می باشد. تمامی تایپ اعداد (int, uint, float) مقدار پیش فرضش صفر می باشد. تایپ استرینگ مقدار پیش فرضش \u0026quot; \u0026quot; می باشد. انواع مقادیر تایپ ها # در زبان گو تایپ ها یکسری مقادیر مختلفی را دریافت می کنند که در زیر به این مقادیر می پردازیم.\nتایپ بولین # تایپ بولین فقط true و false را به عنوان مقدار دریافت می کند.\nتایپ Integer # تایپ اعداد ۴ نوع مقدار مختلف دریافت می کند که به ترتیب Decimal (پایه ۱۰), Octal (پایه ۸), Hex (پایه ۱۶) و Binrary (پایه ۲ یا دودویی) می باشد.\n10xF // the hex form (starts with a \u0026#34;0x\u0026#34; or \u0026#34;0X\u0026#34;) 20XF 3 4017 // the octal form (starts with a \u0026#34;0\u0026#34;, \u0026#34;0o\u0026#34; or \u0026#34;0O\u0026#34;) 50o17 60O17 7 80b1111 // the binary form (starts with a \u0026#34;0b\u0026#34; or \u0026#34;0B\u0026#34;) 90B1111 10 1115 // the decimal form (starts without a \u0026#34;0\u0026#34;) 1package main 2 3func main() { 4\tprintln(15 == 017) // true 5\tprintln(15 == 0xF) // true 6} تایپ Float # تایپ Float چند نوع مقدار را دریافت می کند که به ترتیب مقدار ممیز شناور اعشاری ممکن است شامل یک قسمت صحیح اعشاری، یک نقطه اعشاری، یک قسمت کسری اعشاری، و یک قسمت توانی عدد صحیح (مبتنی بر 10) باشد.\n11.23 201.23 // == 1.23 3.23 41. 5// An \u0026#34;e\u0026#34; or \u0026#34;E\u0026#34; starts the exponent part (10-based). 61.23e2 // == 123.0 7123E2 // == 12300.0 8123.E+2 // == 12300.0 91e-1 // == 0.1 10.1e0 // == 0.1 110010e-2 // == 0.1 120e+5 // == 0.0 تایپ rune # تایپ rune یک تایپ با نام مستعار int32 می باشد که از تایپ های اعداد صحیح خاصی هستند. در rune برای ذخیره نقطه یونیکد یا حروف خاص استفاده می شود که زیر به عنوان نمونه قرار دادیم.\n1\u0026#39;a\u0026#39; // an English character 2\u0026#39;π\u0026#39; 3\u0026#39;众\u0026#39; // a Chinese character 1// 141 is the octal representation of decimal number 97. 2\u0026#39;\\141\u0026#39; 3// 61 is the hex representation of decimal number 97. 4\u0026#39;\\x61\u0026#39; 5\u0026#39;\\u0061\u0026#39; 6\u0026#39;\\U00000061\u0026#39; 1package main 2 3func main() { 4\tprintln(\u0026#39;a\u0026#39; == 97) 5\tprintln(\u0026#39;a\u0026#39; == \u0026#39;\\141\u0026#39;) 6\tprintln(\u0026#39;a\u0026#39; == \u0026#39;\\x61\u0026#39;) 7\tprintln(\u0026#39;a\u0026#39; == \u0026#39;\\u0061\u0026#39;) 8\tprintln(\u0026#39;a\u0026#39; == \u0026#39;\\U00000061\u0026#39;) 9\tprintln(0x61 == \u0026#39;\\x61\u0026#39;) 10\tprintln(\u0026#39;\\u4f17\u0026#39; == \u0026#39;众\u0026#39;) 11} تایپ رشته (string) # در زبان گو مقدار تایپ رشته بطور پیش فرض از نوع یونیکد UTF-8 می باشد.\n1// The interpreted form. 2\u0026#34;Hello\\nworld!\\n\\\u0026#34;你好世界\\\u0026#34;\u0026#34; 3 4// The raw form. 5`Hello 6world! 7\u0026#34;你好世界\u0026#34;` همچنین رشته از کارکترهای خاص یونیکد مانند 0x0D پشتیبانی می کند.\nخوانایی بهتر اعداد با _ # در زبان گو شما می توانید برای خوانایی بهتر اعداد چند رقمی از _ برای جداسازی استفاده کنید.\n1// Legal ones: 26_9 // == 69 30_33_77_22 // == 0337722 40x_Bad_Face // == 0xBadFace 50X_1F_FFP-16 // == 0X1FFFP-16 60b1011_0111 + 0xA_B.Fp2i 7 8// Illegal ones: 9_69 // _ can\u0026#39;t appear as the first character 1069_ // _ can\u0026#39;t appear as the last character 116__9 // one side of _ is a illegal character 120_xBadFace // \u0026#34;x\u0026#34; is not a legal octal digit 131_.5 // \u0026#34;.\u0026#34; is not a legal octal digit 141._5 // \u0026#34;.\u0026#34; is not a legal octal digit "},{"id":9,"href":"/chapter-1/go-operators/","title":"1.4 عملگرها","section":"فصل اول: آشنایی با مفاهیم گو","content":"زبان گو هم مثل سایر زبان ها دارای یکسری عملگرها مانند: عملگرهای حسابی, عملگرهای مقایسه ای, عملگرهای منطقی و عملگرهای بیتی می باشد.\nعملگرهای حسابی # زبان گو دارای ۵ تا عملگر حسابی می باشد که به ترتیب :\nعملگر نام + جمع - تفریق * ضرب / تقسیم % باقی مانده این ۵ تا عملگر اغلب به ترتیب مجموع, تفاوت, حاصلضرب و ضریب نیز نامیده می شوند.\n1 a := 1 2 b := 2 3 4 c := a + b // 3 5 d := a - b // -1 6 e := a * b // 2 7 f := a / b // 0 8 g := a % b // 1 در کد نمونه بالا ما := که متغیر کوتاه است استفاده کردیم که در بخش 1.5 متغیرها و ثابت ها معرفی خواهیم کرد. عملگرهای مقایسه ای # زبان گو دارای ۶ عملگر مقایسه ای می باشد که به ترتیب :\nعملگر نام == مساوی بودن =! مساوی نبودن با \u0026gt; کمتر از =\u0026gt; کمتر یا مساوی \u0026lt; بزرگتر =\u0026lt; بزرگتر یا مساوی نتیجه این استفاده از این عملگرهای مقایسه فوق یک نوع untyped بولین است یعنی حاصل این مقایسه ها در واقع true یا false است.\n1 a := 1 2 b := 2 3 c := 1 4 5 println(a == b) // false 6 println(a == c) // true 7 println(a \u0026lt; b) // true 8 println(b \u0026gt; c) // true 9 println(c \u0026lt;= a) // true 10 println(c \u0026gt;= b) // false 11 println(b != a) // true 12 println(c != a) // false عملگرهای منطقی # زبان گو دارای ۳ نوع عملگر منطقی می باشد که در زیر به ترتیب :\n\u0026amp;\u0026amp; بولین untyped و (دودویی) مشروط و || بولین untyped یا (دودویی) مشروط یا ! بولین از نوع وضعیت مخالف 1 a := true 2 b := true 3 c := false 4 5 if a \u0026amp;\u0026amp; b {} // توضیحات شماره یک 6 if a || b {} // توضیحات شماره دو 7 if !c {} // توضیحات شماره سه 8 if !(a == b) {} // توضیحات شماره چهار زمانیکه شما از عملگر \u0026amp;\u0026amp; استفاده می کنید دارید اعلام میکنید ۲ تا عملوند باید هر دو یک مقدار از یک نوع بولین untyped باشند. زمانیکه شما از عملگر || استفاده می کنید دارید اعلام می کنید یکی از ۲ تا عملوند باید true شود. زمانیکه شما از عملگر ! استفاده می کنید معکوس نتیجه عملوند را نیاز دارید (به عنوان مثال شماره سه مقدار متغیر c از نوع بولین false می باشد و وقتی ! گذاشتید نتیجه معکوس را نیاز دارید یعنی true). شماره چهار ما در ابتدا نتیجه a == b را که true هست را میگیریم و در نهایت معکوس آن را نیاز داریم. 1 // x y x \u0026amp;\u0026amp; y x || y !x !y 2 true true true true false false 3 true false false true false true 4 false true false true true false 5 false false false false true true عملگرهای بیتی # زبان گو ۶ تا عملگرد بیتی می باشد که به ترتیب :\n\u0026lt;\u0026lt; SHIFT (LEFT) این عملگر دقیقا مانند عملگر SHIFT RIGHT است اما برخلاف shift به راست, از سمت چپ بیت ها را بر میدارد و به سمت راست بیت های صفر اضافه می کند \u0026gt;\u0026gt; SHIFT (RIGHT) عملوند مقدار که عملیات shift بر روی آن انجام میشود. عملوند سمت راست این نقش را ایفا میکند. عملوند تعداد که عمل shift با استفاده از آن بر روی عملوند ۱ انجام میشود. عملوند سمت راست این نقش را ایفا میکند. \u0026amp; AND درست مانند معنی لغوی AND, یعنی ‘و’, بدین معنی است که هر دو طرف باید ۱ باشند | OR خروجی این عملگر در صورتی ۱ خواهد بود که هر دو یا یکی از طرفین ۱ باشند ^ XOR خروجی این عملگر در صورتی یک خواهد بود که تنها یکی از طرفین ۱ باشد 1 const N = 2 2 // A is an untyped value (default type as int). 3 const A = 3.0 \u0026lt;\u0026lt; N // A == 12 4 // B is typed value (type is int8). 5 const B = int8(3.0) \u0026lt;\u0026lt; N // B == 12 6 7 var m = uint(32) 8 // The following three lines are equivalent to 9 // each other. In the following two lines, the 10 // types of the two \u0026#34;1\u0026#34; are both deduced as 11 // int64, instead of int. 12 var x int64 = 1 \u0026lt;\u0026lt; m 13 var y = int64(1 \u0026lt;\u0026lt; m) 14 var z = int64(1) \u0026lt;\u0026lt; m 15 16 // The following line fails to compile. 17 /* 18 var _ = 1.23 \u0026lt;\u0026lt; m // error: shift of type float64 19 */ اولویت عملگرها # در زبان گو ما یکسری اولویت ها برای عملگرها داریم و همچنین در زبان گو مثل سایر زبان ها پرانتز () ترویج دهنده اولویت ها می باشد.\n1 * / % \u0026lt;\u0026lt; \u0026gt;\u0026gt; \u0026amp; \u0026amp;^ 2 + - | ^ 3 == != \u0026lt; \u0026lt;= \u0026gt; \u0026gt;= 4 \u0026amp;\u0026amp; 5 || توجه در زبان گو اولویت \u0026lt;\u0026lt; و \u0026gt;\u0026gt; بیشتر از + و - می باشد. "},{"id":10,"href":"/chapter-1/go-variables-and-consts/","title":"1.5 متغیرها و constant","section":"فصل اول: آشنایی با مفاهیم گو","content":" متغیر (Variable) # در برنامه‌نویسی رایانه، یک متغیر یک مکان در حافظه (آدرس حافظه) است که دارای یک نام نمادین با عنوان می‌باشد و می‌تواند حاوی اطلاعات یا یک مقدار معلوم یا مجهول که به آن ارزش یا مقدار گفته می‌شود باشد. به زبان دیگر، متغیر در برنامه‌نویسی به فضایی که برای ذخیره داده‌ها کنار گذاشته شده‌است می‌گویند (به نقل از سایت ویکی پدیا)\nتعریف یک متغیر رشته # 1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7func main() { 8\tvar s string = \u0026#34;Hello World\u0026#34; 9\tfmt.Println(s) 10} 1$ go run main.go 2Hello World یک متغیر با استفاده از کلید واژه var ایجاد کردیم. نام متغیر را s گذاشتیم تایپ متغیر را از نوع string تعیین کردیم سپس با عملگر = مقدار متغیر را مشخص از نوع رشته تعیین کردیم. رشته \u0026quot;Hello World\u0026quot; به عنوان مقدار متغیر s می باشد و این مقدار در خانه مشخصی از حافظه قرار گرفته از پکیج استاندارد fmt برای چاپ مقدار متغیر s استفاده کردیم که این پکیج یکسری توابع جهت انجام عملیات های مختلفی نظیر چاپ مقادیر را دارند که در کد بالا ما از تابع Println استفاده کردیم. اختصاص مقدار جدید به متغیر از قبل ایجاد شده # در کد زیر ما یک متغیر از قبل تعریف کردیم و مقدار جدید را در خط ۹ به متغیر اختصاص دادیم.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7func main() { 8\tvar s string 9\ts = \u0026#34;Hello World\u0026#34; 10\tfmt.Println(s) 11} زمانیکه شما یک متغیر بصورت var s string تعریف می کنید مقدار پیش فرض \u0026quot;\u0026quot; برای متغیر تعیین می شود. اختصاص مقدار رشته به تایپ اشتباه # 1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7func main() { 8\tvar i int 9\ti = \u0026#34;One\u0026#34; 10\tfmt.Println(i) 11} 1$ go run main.go 2./main.go:cannot use \u0026#34;One\u0026#34; (type string) as type int in assignment در کد بالا ما یک متغیر از نوع int تعریف کردیم و در خط ۹ مقدار \u0026quot;One\u0026quot; را به آن تخصیص دادیم و پس از اجرا با خطای cannot use \u0026quot;One\u0026quot; (type string) as type int in assignment اینکه شما یک مقدار رشته را به تایپ اشتباه اختصاص دادید مواجه خواهید شد.\nتعریف متغیر کوتاه # زبان گو علاوه بر اینکه از کلید واژه var برای تعریف متغیر پشتیبانی می کند, از =: می توانید یک متغیر تعریف کنید و نیازی به مشخص کردن تایپ متغیر نمی باشد چون زبان گو بر اساس مقدار تعیین شده تایپ متغیر را تشخیص می دهد.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\ts := \u0026#34;Hello World\u0026#34; 7\tfmt.Println(s) 8} توجه کنید شما متغیر کوتاه را فقط داخل تابع می توانید تعریف کنید و جهت تعریف متغیر بصورت عمومی باید از var استفاده کنید.\nبهتر است برای تعریف متغیر داخل تابع از متغیر کوتاه استفاده کنید و متغیر با var بصورت عمومی در بدنه کد باشد.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7var s string = \u0026#34;Hello World\u0026#34; 8 9func main() { 10\tfmt.Println(s) 11} تعریف چند متغیر در یک خط # در زبان گو شما می توانید همزمان چند متغیر را در یک خط تعریف کنید که در زیر یک نمونه کد مثال زدیم :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\ta, b, c := \u0026#34;hello\u0026#34;, 1, 1.5 7\tvar d, e, f = \u0026#34;world\u0026#34;, 13, 24 8\tfmt.Println(a, b, c, d, e, f) 9} 1$ go run main.go 2hello 1 1.5 world 13 24 تعریف متغیر با مقدار پیش فرض # در کد زیر ما یکسری متغیر با تایپ های مختلف تعریف کردیم که با مقدار پیش فرض ایجاد شده اند.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7func main() { 8\tvar i int 9\tvar f float 10\tvar b bool 11\tvar s string 12\tfmt.Printf(\u0026#34;%v %v %v %q\\n\u0026#34;, i, f, b, s) 13} مقدار ثابت (Constant) # constant همانند متغیر ها با کلید واژه const تعریف می شوند و مقدار بصورت const a string = \u0026quot;hello world\u0026quot; می گیرند و با این تفاوت که constant در طول اجرای کد مقدارشان غیرقابل تغییر هست و این تضمین را به شما می کنند هیچ چیزی در طول اجرا باعث تاثیر در تغییر مقدار constant نشود.\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5) 6 7const s string = \u0026#34;Hello World\u0026#34; 8 9func main() { 10\tfmt.Println(s) 11} 1$ go run main.go 2Hello World همانطور که در فوق گفتیم شما نمی توانید Constant را مجدد مقدار دهی کنید و در زیر خطایی که رخ می دهد در زمان اجرا را قرار دادیم :\n1package main 2 3func main() { 4 const a int = 8 5 a = 9 6} 1$ go run main.go 2main.go:5:cannot assign to a تعریف Constant بدون نیاز به تعیین تایپ # در constant شما همانند متغییر می توانید یک const به تعیین تایپ تعریف کنید و زبان گو در زمان اجرا با توجه به مقدارتان تایپ را تشخیص می دهد.\n1const a = 1 //Default hidden type is int 2const b = \u0026#34;circle\u0026#34; //Default hidden type is string 3const c = 5.4 //Default hidden type is float64 4const d = true //Default hidden type is bool 5const e = \u0026#39;a\u0026#39; //Default hidden type is rune 6const f = 3+5i //Default hidden type is complex128 نحوه مشاهده تایپ متغیر یا Constant # در زیر ما با استفاده یکی از توابع پکیج fmt نوع و مقدار متغیر یا constant ها را چاپ کردیم.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5// Named untyped constant 6const a = 123 //Default hidden type is int 7const b = \u0026#34;circle\u0026#34; //Default hidden type is string 8const c = 5.6 //Default hidden type is float64 9const d = true //Default hidden type is bool 10const e = \u0026#39;a\u0026#39; //Default hidden type is rune 11const f = 3 + 5i //Default hidden type is complex8 12 13var u = 123 //Default hidden type is int 14var v = \u0026#34;circle\u0026#34; //Default hidden type is string 15var w = 5.6 //Default hidden type is float64 16var x = true //Default hidden type is bool 17var y = \u0026#39;a\u0026#39; //Default hidden type is rune 18var z = 3 + 5i //Default hidden type is complex128 19 20func main() { 21\tfmt.Println(\u0026#34;\u0026#34;) 22\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, a, a) 23\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, b, b) 24\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, c, c) 25\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, d, d) 26\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, e, e) 27\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, f, f) 28 29\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, u, u) 30\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, v, v) 31\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, w, w) 32\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, x, x) 33\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, y, y) 34\tfmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, z, z) 35} استفاده از iota در constant # شناسه iota فقط با constant قابل استفاده اس که با آن می توانید برای ایجاد اعداد auto increment استفاده کنید.\nایجاد auto increment بدون iota :\n1const ( 2 a = 0 3 b = 1 4 c = 2 5) ایجاد auto increment با iota :\n1const ( 2 a = iota // 0 3 b // 1 4 c // 2 5) توجه کنید مقدار پیش فرض با iota صفر می باشد و constant از نوع int می باشد. نحوه ایجاد enum # از iota و constant برای ایجاد enum استفاده می شود که در زیر یک نمونه کد برای ایجاد enum قرار دادیم.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type Size uint8 6 7const ( 8\tsmall Size = iota 9\tmedium 10\tlarge 11\textraLarge 12) 13 14func main() { 15\tfmt.Println(small) 16\tfmt.Println(medium) 17\tfmt.Println(large) 18\tfmt.Println(extraLarge) 19} 1$ go run main.go 20 31 42 53 قوانین نام گذاری متغیر و constant # در زیر ما یکسری قوانین جهت نام گذاری متغیر و constant تعریف کردیم :\nنام متغیر یا constant فقط با یک حرف انگلیسی یا _ شروع می شود. نام ها می تواند ترکیبی از اعداد و حروف انگلیسی یا _ باشد. زبان گو به حروف بزرگ و کوچک در نام ها حساس است و اگر شما hello یا Hello تعریف کنید ۲ تا متغیر یا constant متفاوت محسوب می شوند. محدودیتی در تعداد حروف نام ها وجود ندارد ولی بهتر است از یک تعداد مطلوب و مشخصی برای نام ها استفاده کنید. "},{"id":11,"href":"/chapter-1/go-function/","title":"1.6 تابع (function)","section":"فصل اول: آشنایی با مفاهیم گو","content":" تابع چیست؟ # در برنامه‌نویسی، تابع به تکه کدهایی سازمان یافته گفته می شود که برای انجام عملی خاص استفاده می شوند. به کمک توابع می توانیم تکه کدهارو از یکدیگر جدا کنیم و از تکرار کدهای تکراری جلوگیری کینم و به برنامه مون نظم بیشتری بدیم.\nهمانند شکل زیر تابع مانند یک جعبه (یا قطعه کد) می باشد. که یک مقدار ورودی گرفته و روی آن پردازش هایی انجام می دهد و یک خروجی تولید می کند. در برنامه نویسی تابع می تواند یک یا چند ورودی و خروجی داشته باشد. و ممکن است یک تابع هیچ ورودی نداشته باشد و خروجی داشته باشد یا بلعکس.\nچرا از توابع در برنامه نویسی استفاده می کنیم؟ # با استفاده از توابع، می توانیم یک قطعه کد را یک بار بنویسیم و چندین بار از آن در برنامه استفاده کنیم. با استفاده از توابع، حجم کدنویسی ما کم تر میشه و سرعت توسعه نرم افزار بیشتر می شود. توابع به ما کمک می کنند تا کد خود را به تکه هایی تقسیم کنیم تا برنامه ما خوانا و قابل درک باشد. همچنین نگهداری و اشکال زدایی کد را آسان تر می کند. توابع در زبان گولنگ # توابع یکی از قابلیت های مهم هر زبانی محسوب می شود. توابع در زبان برنامه نویسی گولنگ داری سینتکس ساده ای هستند.\nتعریف یک تابع # 1func function_name( [parameter list] ) [return_types] { 2 3 // body of the function 4 5} Func - با این کلید واژه یک تابع تعریف می کنیم Function Name - نام تابع باید یکتا و در طول برنامه منحصر به فرد باشد. همچنین معمولاً نمی‌توان تابعی با نام توابع از پیش تعریف شده داشت Parameters - پارامترهای ورودی در این قسمت تعریف می‌شوند. پارامترها اختیاری هستند یعنی ممکن است یک تابع هیچ پارامتری نداشته باشد. Return Type - نوع داده های بازگشتی را در این قسمت مشخص می کنیم و در برخی توابع عملیات موردنظر را بدون بازگرداندن مقداری انجام می دهند در این توابع نیازی به تعیین return_type نمی باشد. Function Body - این قسمت شامل کدهایی است که نشان می دهد تابع چه کارهایی انجام می دهد مثال # 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func plus(a int, b int) int { 6\treturn a + b 7} 8 9func main() { 10\tfmt.Println(plus(4, 13)) 11} 1$ go run func.go 217 در اینجا یک تابع یا نام plus تعریف کردیم که دو پارامتر a, b را با نوع داده int را دریافت می کند و جمع دو عدد را حساب می کند. توجه کنید که همیشه باید نوع داده را مشخص کنیم. بعد از تعریف پارامترهای ورودی و قبل از قرار دادن کد داخل براکت int را می بینید که نوع خروجی داده را مشخص می کند و باید از نوع int باشد. برای صدا زدن توابع از کلیدواژه name(args) استفاده می کنیم. در صورتی که نوع پارامترهای ورودی از یک نوع باشند بجای تعریف تک تک نوع داده ها می توانیم نوع داده را در آخر همه پارامترهای هم نوع مشخص کنیم.\n1func plus(a, b int) 2// or 3func name(a string, b,c int) الگو دیگر تعریف تابع: # 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tplus := func (a int, b int) int { 7\treturn a + b 8\t} 9\tfmt.Println(plus(3, 4)) 10} 1$ go run main.go 27 قوانین نام گذاری تابع در گولنگ # نام تابع باید با یک حرف شروع شود. نام تابع فقط می تواند شامل حروف-عدد و underscores باشد. (A-z, 0-9, _ ) نام توابع به حروف کوچک و بزرگ حساس می باشد. در نام گذاری توابع از فاصله نمی توانیم استفاده کنیم. ‬ چند بازگشتی مقادیر در گولنگ (Multiple results) # همچنین در گولنگ توابع می توانند چندین مقادیر را برگردانند.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func vals() (int, int) { 6 return 3, 7 7} 8 9func main() { 10 11 a, b := vals() 12 fmt.Println(a) 13 fmt.Println(b) 14 15 _, c := vals() 16 fmt.Println(c) 17} 1$ go run main.go 23 37 47 در کد بالا تابعی ساختیم با اسم vals که دو خروجی از نوع int دارد بنابراین نوع تعریف توابع چندبازگشتی متفاوت است و بصورت (data-type, data-type, \u0026hellip; ) می باشد. در مثال اول ما با کمک دو متغیر a,b دو خروجی تابع vals را دریافت کردیم. در مثال دوم ما با استفاده از _ blank identifier از دریافت یا استخراج خروجی اول صرف نظر کردیم و فقط خروجی دوم با متغیر c را دریافت کردیم. در توابع چند بازگشتی خروجی آنها را باید با , از هم جدا کرد مقادیر بازگشتی نام گذاری شده (Named Return Values) # در گولنگ می توانیم مقدار بازگشتی یک تابع را نامگذاری کنیم. به مثال زیر توجه کنید.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func split(sum int) (x, y int) { 6\tx = sum * 4 / 9 7\ty = sum - x 8\treturn 9} 10 11func main() { 12\tfmt.Println(split(17)) 13} 1$ go run main.go 27 10 ما در این تابع مقدار بازگشتی را x, y از نوع int نام گذاری می کنیم. در اینجا یک دستور return بدون تعیین آرگومان بازگشتی، مقادیر نام گذاری شده را باز می گرداند. که به عنوان Naked return شناخته می شود. از naked return باید در توابع کوتاه مانند مثال بالا استفاده شود. استفاده آن در تابع طولانی منجر به کاهش خوانایی کد می شود. توابع متنوع در گولنگ (Variadic Functions) # یکی از قابلیت های گو وجود توابع متنوع هاست که به شما اجازه می دهد هر چقدر پارامتر نیاز دارید بدون تعریف وارد تابع کنید همانند parameter-Rest ها در JavaScript. ‍‍\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func sum(nums ...int) { 6 fmt.Print(nums, \u0026#34; \u0026#34;) 7 total := 0 8 9 for _, num := range nums { 10 total += num 11 } 12 fmt.Println(total) 13} 14 15func main() { 16 17 sum(1, 2) 18 sum(1, 2, 3) 19 20 nums := []int{1, 2, 3, 4} 21 sum(nums...) 22} 1$ go run variadic-functions.go 2[1 2] 3 3[1 2 3] 6 4[1 2 3 4] 10 در اینجا تابعی تعریف کردیم که تعداد دلخواهی از آرگومان ها از نوع int را به کمک \u0026hellip; که قبل از نوع داده قرار گرفته به داخل تابع منتقل می کند. برای صدا زدن این توابع میتوان به روش sum(num1, num2, \u0026hellip;) عمل کرد. اگر شما داده ای با نوع slice دارید می توانید آن را به کمک اپراتور \u0026hellip; به صورت sum(nums\u0026hellip;) به داخل تابع انتقال بدید. توابع نانشناس در گولنگ (Anonymous Functions) # در زبان گولنگ می توانیم تابع بدون نام تعریف کنیم. که به عنوان توابع ناشناس شناخته می شوند.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 7 // anonymous function 8 var sum = func(n1, n2 int) int { 9 sum := n1 + n2 10 11 return sum 12 } 13 14 // function call 15 result := sum(5, 3) 16 17 fmt.Println(\u0026#34;Sum is:\u0026#34;, result) 18 19} 1$ go run main.go 2Sum is: 8 از آنجایی که توابع ناشناس نامی ندارد ما معمولا آن ها را به یک متغیر اختصاص می دهیم سپس از نام متغیر برای فراخوانی تابع استفاده می کنیم. در این مثال می بینید که ما از sum برای فراخوانی تابع استفاده می کنیم. مانند توابع معمولی ما میتونیم برای تابع ناشناس پارامتر تعریف کنیم و همچنین مقداری را از تابع برگردانیم در این مثال تابع دو مقدار با نوع داده int دریافت میکنید و یک خروجی با نوع int دارد. تابع ناشناس را می توان برای عملکردهایی که نیازی به نامگذاری ندارند و معمولا برای استفاده کوتاه مدت هست، استفاده کرد. توابع از پیش تعریف شده (Built-in Function) # در گولنگ علاوه بر تابع هایی که توسط کابر تعریف میشه. یکسری توابع وجود دارد که از قبل تعریف شده اند که طراحان این زبان برای سهولت کار برنامه نویسان این توابع را نوشته اند و آن را همراه زبان گولنگ ارائه می دهند. https://pkg.go.dev/builtin\n"},{"id":12,"href":"/chapter-1/go-array/","title":"1.7 آرایه و slice","section":"فصل اول: آشنایی با مفاهیم گو","content":"آرایه و slice دو نوع تایپ با یک وجه اشتراک در زبان گو می باشند ولی این دو نوع تایپ یکسری تفاوت هایی با هم دارند که در ادامه به این دو تایپ می پردازیم.\nتعریف آرایه # آرایه یکی از عمومی ترین تایپ ها در زبان های برنامه نویسی می باشد که برای نگه داری گروهی مقادیر از یک نوع تایپ استفاده می شود. برای دسترسی به هرکدام از مقادیر درون آرایه باید از اندیس استفاده کرد. معمولا برای آرایه شما تعداد مشخص و ثابتی را برای تعداد خانه های آرایه مشخص کنید که این آرایه قرار است چندتا مقدار نگه داری کند.\nدر زیر یک نمونه کد در خصوص آرایه قرار دادیم :\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tarrayInts := [5]int{1, 25, 12354, 654, 32} 7\tfmt.Println(arrayInts) 8} 1$ go run array.go 2[1 25 12354 654 32] یک متغیر کوتاه از نوع آرایه با نام arrayInts تعریف کردیم. ظرفیت آرایه را با عدد ۵ تعیین کردیم (یعنی این آرایه فقط ۵ تا مقدار بیشتر نگه داری نمی کند) سپس تایپ آرایه را از نوع int مشخص کردیم. در نهایت در همانجا آرایه را مقدار دهی کردیم. مفهوم اندازه و ظرفیت (size, capacity) # در آرایه ما ۲ تا مفهوم داریم اندازه و ظرفیت که از عنوان این مفهوم مشخص است آرایه دارای یک اندازه و ظرفیت مشخصی می باشد و اگر شما بیشتر از ظرفیت و اندازه تعیین شده مقدار دهی کنید با خطا مواجه خواهید شد.\nدر آرایه ظرفیت به نسبت اندازه تعیین می شود. 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tarrayString := [3]string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;} 7\tfmt.Println(arrayString) 8} 1$ go run array.go 2./prog.go:6:42: index 3 is out of bounds (\u0026gt;= 3) در کد فوق ما یک آرایه با اندازه ۳ تعریف کردیم و ۴ تا مقدار قرار دادیم و پس اجرا با خطای تعداد مقادیر بیشتر از اندازه و ظرفیت می باشد مواجه شدیم.\nتابع len و cap # برای آرایه و slice ما ۲ تا تابع داریم که می توانیم اندازه و ظرفیت یک آرایه یا slice را بگیریم.\nتابع len یکی از توابعی می باشد خیلی کاربردی و پراستفاده هنگام کار با آرایه یا slice می باشد که می توانید اندازه آرایه یا slice را بگیرید. تابع cap ظرفیت آرایه و slice را نمایش می دهد. 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tarrayString := [3]string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;} 7\tfmt.Printf(\u0026#34;array %v, len %d, cap %d\u0026#34;, arrayString, len(arrayString), cap(arrayString)) 8} 1$ go run main.go 2array [a b c], len 3, cap 3 تعریف آرایه و مقدارهی # در زیر ما یک آرایه با مقدار پیش فرض و اندازه مشخص تعریف کردیم و قصد داریم در ادامه کد مقداردهی کنیم.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tnums := [5]int{} 7\tfmt.Printf(\u0026#34;array nums values %v, len %d, cap %d\u0026#34;, nums, len(nums), cap(nums)) 8 9\tnums[0] = 1 10\tnums[1] = 2 11\tnums[2] = 10 12\tnums[4] = 999 13\t14\tfmt.Println(\u0026#34;\u0026#34;) 15\tfmt.Printf(\u0026#34;array nums values %v, len %d, cap %d\u0026#34;, nums, len(nums), cap(nums)) 16} 1$ go run main.go 2array nums values [0 0 0 0 0], len 5, cap 5 3array nums values [1 2 10 0 999], len 5, cap 5 در کد فوق در ابتدا ما یک آرایه بدون مقدار تعریف کردیم. سپس با استفاده از اندیس مقدار را خانه مشخص قرار دادیم. تعریف آرایه با اندازه تعیین شده توسط کامپایلر # شما در زبان گو می توانید با استفاده از ... یک آرایه با اندازه مشخص شده توسط کامپایلر تعریف کنید.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tnums := [...]int{1, 25, 45, 8797, 78, 879, 541, 11} 7\tfmt.Printf(\u0026#34;array nums values %v, len %d, cap %d\u0026#34;, nums, len(nums), cap(nums)) 8} 1$ go run main.go 2array nums values [1 25 45 8797 78 879 541 11], len 8, cap 8 توجه کنید زمانیکه ... برای تعریف آرایه استفاده می کنید فقط در همان لحظه تعریف می توانید مقدار دهی کنید. تعریف آرایه دوبعدی یا چندبعدی # در زبان گو همانند سایر زبان ها می توانید آرایه دوبعدی یا چند بعدی تعریف کنید که این برای پیاده سازی ماتریس یا یکسری سناریوهای توسعه کاربردی می باشد.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tnums := [2][2][2]int{{{1, 2}, {2, 3}}, {{4, 5}, {6, 7}}} 7\tfmt.Printf(\u0026#34;array nums values %v, len %d, cap %d\u0026#34;, nums, len(nums), cap(nums)) 8} 1$ go run main.go 2array nums values [[[1 2] [2 3]] [[4 5] [6 7]]], len 2, cap 2 مقایسه آرایه ها # در کد زیر ما یک نمونه مقایسه آرایه ها قرار دادیم که این مقایسه براساس تایپ, اندازه و مقادیر در نظر گرفته می شود.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tnums := [2]int{1, 2} 7\tnums2 := [2]int{1, 3} 8\tnums3 := [2]int{1, 2} 9\tnums4 := [3]int{1, 2, 3} 10\tchars := [2]string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;} 11 12\tfmt.Println(nums == nums2) // false 13\tfmt.Println(nums == nums3) // true 14\tfmt.Println(nums == nums4) // error: invalid operation: nums == nums4 (mismatched types [2]int and [3]int) 15\tfmt.Println(nums == chars) // error: invalid operation: nums == chars (mismatched types [2]int and [2]string) 16} "},{"id":13,"href":"/chapter-1/go-map/","title":"1.8 نقشه map","section":"فصل اول: آشنایی با مفاهیم گو","content":"عبارات \u0026hellip;\n"},{"id":14,"href":"/chapter-1/go-if-switch/","title":"1.9 شرط (if, switch)","section":"فصل اول: آشنایی با مفاهیم گو","content":"شرط \u0026hellip;\n"},{"id":15,"href":"/chapter-1/go-for/","title":"1.10 حلقه ها (for)","section":"فصل اول: آشنایی با مفاهیم گو","content":"حلقه ها \u0026hellip;\n"},{"id":16,"href":"/chapter-1/go-package/","title":"1.11 اضافه کردن پکیج در کد (package)","section":"فصل اول: آشنایی با مفاهیم گو","content":"زبان برنامه نویسی گو به شکلی طراحی شده است تا بتوانیم شیو‌ه های خوب مهندسی نرم افزار را به خوبی و ساده پیاده سازی کنیم. یکی از الگوهای مهم برای ارتقای کیفیت یک نرم افزار استفاده از DRY principle است. کلمه DRY مخفف Don’t Repeat Yourself است. که به صورت خیلی ساده یعنی کدی که خواهید نوشت را دوبار تکرار نکنید. تا جایی که امکان دارد باید از کدهای قبلی که نوشته اید بتوانید استفاده کنید. پکیج‌ها امکاناتی از جمله:\nقابلیت استفاده مجدد از کد را به ما میدهند. امکان ماژولار، و قابل نگهداری را فراهم می‌کنند. امکان مدیریت بهتر فایل‌ها را در یک واحد ایجاد می‌کنند. پکیج‌ها در زبان گو # پکیج در اصل یک یا مجموعه از سورس فایل های شما است که داخل یک فولدر قرار ممکن است قرار بگیرد. هر سورس فایلی که دارید در زبان گو متعلق به یک پکیج است. برای تعریف یک پکیج از دستور زیر استفاده میکنیم:\n1package \u0026lt;packagename\u0026gt; برای تعریف پکیج باید در اولین خط فایل آن را با کلید واژه package تعریف کنید. داخل این پکیج شما می‌توانید کد‌هایی که لازم دارید را بنویسید و تصمیم بگیرید کدام متغییر، فانکشن یا تایپ باید به صورت عمومی باشد یا باید به صورت خصوصی فقط داخل پکیج مورد استفاده قرار بگیرد.\nقطعا میدانیم بعد از نوشتن پکیج اگر بخواهیم از آن پکیج داخل پکیج‌های دیگر استفاده کنیم باید از کلید واژه import استفاده کنیم.\nاضافه کردن پکیج # برای اضافه کردن پکیج‌های مختلف ما از کلید واژه import استفاده می‌کنیم.\n1import \u0026#34;fmt\u0026#34; برای مثال در کد بالا ما از پکیج استاندارد هسته گو استفاده کریدم. این به این معنی است همراه با تعریف کلمه fmt میتوانیم از توابعی که داخل این پکیج استفاده شده است استفاده کنیم. در مثال زیر ما از تابع Println برای چاپ مقدارHello GoFarsi!‍ استفاده کردیم.\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6\tfmt.Println(\u0026#34;Hello GoFarsi!\u0026#34;) 7} تعریف کردن توابع به این شکل مزایای زیادی دارد از جمله:\nاگر اسم های مشابهی داشته باشید، داخل پکیج‌های مختلف می‌توانید از آن‌ها استفاده کنید و خوانایی برنامه افزایش پیدا میکند و باعث می‌شود از نام‌های طولانی استفاده نکنیم. مجموعه کدی که مربوط به هم هستن را در یک پکیج می‌توانیم قرار دهیم. و پیدا کردن و استفاده مجدد را برای ما راحتر می‌کند. فرایند تغییر و کامپایل را می‌تواند به حداقل برساند. اضافه کردن چندین پکیج # ما می‌توانیم برای اضافه کردن هر پکیج از کلید واژه import به شکل زیر استفاده کنیم :\n1import \u0026#34;fmt\u0026#34; 2import \u0026#34;time\u0026#34; 3import \u0026#34;math\u0026#34; 4import \u0026#34;math/rand\u0026#34; اما با تشکر از گو ما میتوانیم کلیدواژهایی که قرار است بیشتر از یک بار اجرا شوند را به شکل زیر نیز تعریف کنید:\n1import ( 2\t\u0026#34;fmt\u0026#34; 3\t\u0026#34;time\u0026#34; 4\t\u0026#34;math\u0026#34; 5 \u0026#34;math/rand\u0026#34; 6) یعنی یک بار از کلیدواژ import استفاده کنیم و بعد اسم پکیج ها را به ترتیب داخل آن بنویسیم.\nاسم های عمومی و خصوصی (Export و Unexport) # همه توابع، متغیر‌ها و تایپ ‌هایی که تعریف میکنید اگر اول حرف اسم‌ها را بزرگ بزارید به این منظور است که آن را به صورت عمومی تعریف کرده اید و خارج از پکیج آن تابع، متغیر یا تایپ قابل دسترسی است. و اگر شما حرف اول اسم توابع، متغیرها و تایپ‌هایی که تعریف کردید را کوچک بگذارید به این معنی است که فقط داخل این پکیج آن تابع، متغیر یا تایپ قابل تعریف و استفاده است و خارج از پکیج قابل استفاده نیست.\nبرای مثال کد زیر را مشاهده کنید:\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;math\u0026#34; 6) 7 8func main() { 9\tfmt.Println(math.MaxInt64) // result: 9223372036854775807 10} در کد بالا ما از دو پکیج fmt و math استفاده کردیم. تابع Println از پکیج fmt به دلیل اینکه اولین حرف آن بزرگ است ما می‌توانیم داخل پکیج main خود از آن تابع استفاده کنیم. و برای پکیج math دقیقا بخاطر آنکه اول حرف MaxInt64 بزرگ است می‌توانیم از آن استفاده کنیم.\nحالا فرض کنیم که داخل پکیج math ما می‌خواهیم عدد pi را برگردانیم و ممکن است این متغییر فقط داخل این پکیج تعریف شده باشد پس اگر کاراکتر اول را به صورت کوچک بذاریم با خطا مواجه خواهیم شد:\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;math\u0026#34; 6) 7 8func main() { 9\tfmt.Println(math.MaxInt64) 10\tfmt.Println(math.pi) 11} 12 13// result: 14./prog.go:10:19: undefined: math.pi 15Go build failed. برای حل خطای بالا کافی است pi را به Pi تغییر دهید.\nاضافه کردن پکیج‌های 3rd party # فرض کنید می‌خواهیم از پکیج Gin (github.com) می‌خواهیم استفاده کنیم برای اضافه کردن این پکیج ما ‌می‌توانیم به دو شکل زیر آن را اضافه کنیم.\nداخل پروژه خود از دستور زیر استفاده کنید:\n1$ go get -u github.com/gin-gonic/gin بعدا می‌توانید وارد پروژه خود شوید و با کلید واژه import از آن استفاده کنید به شکل زیر :\n1package main 2 3import ( 4 \u0026#34;net/http\u0026#34; 5 6 \u0026#34;github.com/gin-gonic/gin\u0026#34; 7) 8 9func main() { 10 r := gin.Default() 11 r.GET(\u0026#34;/ping\u0026#34;, func(c *gin.Context) { 12 c.JSON(http.StatusOK, gin.H{ 13 \u0026#34;message\u0026#34;: \u0026#34;pong\u0026#34;, 14 }) 15 }) 16 r.Run() // listen and serve on 0.0.0.0:8080 (for windows \u0026#34;localhost:8080\u0026#34;) 17} حالت دیگر استفاده از go mod tidy است به این شکل که ما از دستور go get استفاده نمیکنیم. و همان مستقیم داخل پروژه آدرس gin را داخل import وارد میکنیم.\nو همان ابتدا داخل کد یک فانکشن را با همان پکیج فراخوانی میکنیم (اینکار لازم است چون همانطور که می دانید خود go tool وقتی بداند شما پکجی را تعریف کردید و استفاده نکردید آن را اتوماتیک پاک میکند.)\nسپس از دستور زیر استفاده میکنیم:\n1$ go mod tidy این دستور کل کدهای شما را بررسی می‌کند و اگر ببینید پکیجی تعریف شده است و شما آن را ندارید سعی میکند آن پکیج را برای شما دانلود و به پروژه شما اضافه کند.\n"},{"id":17,"href":"/chapter-1/go-defer/","title":"1.12 defer, panic, recovery","section":"فصل اول: آشنایی با مفاهیم گو","content":"تعویق و panic و بازیابی \u0026hellip;\n"},{"id":18,"href":"/chapter-2/","title":"فصل دوم: مکانیزم های زبان","section":"صفحه اصلی","content":"در این فصل به مکانزیم های زبان گو میپردازیم\u0026hellip;\n"},{"id":19,"href":"/chapter-2/struct/","title":"2.1 ساختار (struct)","section":"فصل دوم: مکانیزم های زبان","content":"ساختار\u0026hellip;\n"},{"id":20,"href":"/chapter-2/type-embedding/","title":"2.2 جاسازی تایپ (type embedding)","section":"فصل دوم: مکانیزم های زبان","content":"جاسازی تایپ\u0026hellip;\n"},{"id":21,"href":"/chapter-2/pointer/","title":"2.3 اشاره گر (Pointer)","section":"فصل دوم: مکانیزم های زبان","content":"اشاره گر\u0026hellip;\n"},{"id":22,"href":"/chapter-2/method/","title":"2.4 متد (Method)","section":"فصل دوم: مکانیزم های زبان","content":"متد\u0026hellip;\n"},{"id":23,"href":"/chapter-2/interface/","title":"2.5 اینترفیس (Interface)","section":"فصل دوم: مکانیزم های زبان","content":"اینترفیس\u0026hellip;\n"},{"id":24,"href":"/chapter-2/error-handling/","title":"2.6 مدیریت خطاها","section":"فصل دوم: مکانیزم های زبان","content":"مدیریت خطاها\u0026hellip;\n"},{"id":25,"href":"/chapter-2/casting-vs-conversion/","title":"2.7 فرق casting با conversion","section":"فصل دوم: مکانیزم های زبان","content":"فرق casting با conversion\u0026hellip;\n"},{"id":26,"href":"/chapter-3/","title":"فصل سوم: همزمانی (concurrency)","section":"صفحه اصلی","content":"در این فصل به مباحث همزمانی در زبان گو میپردازیم\u0026hellip;\n"},{"id":27,"href":"/chapter-3/go-concurrency/","title":"3.1 آشنایی با همزمانی","section":"فصل سوم: همزمانی (concurrency)","content":"آشنایی با همزمانی\u0026hellip;\n"},{"id":28,"href":"/chapter-3/goroutine/","title":"3.2 گوروتین (goroutine)","section":"فصل سوم: همزمانی (concurrency)","content":"گوروتین (goroutine)\u0026hellip;\n"},{"id":29,"href":"/chapter-3/go-sync-package/","title":"3.3 پکیج sync","section":"فصل سوم: همزمانی (concurrency)","content":"پکیج sync\u0026hellip;\n"},{"id":30,"href":"/chapter-3/go-atomic/","title":"3.4 پکیج atomic","section":"فصل سوم: همزمانی (concurrency)","content":"پکیج atomic\u0026hellip;\n"},{"id":31,"href":"/chapter-3/goroutine-data-race/","title":"3.5 آموزش مقابله با data race","section":"فصل سوم: همزمانی (concurrency)","content":"آموزش مقابله با data race\u0026hellip;\n"},{"id":32,"href":"/chapter-3/go-channel/","title":"3.6 کانال (channel)","section":"فصل سوم: همزمانی (concurrency)","content":"کانال (channel)\u0026hellip;\n"},{"id":33,"href":"/chapter-3/go-select/","title":"3.7 آموزش استفاده از select","section":"فصل سوم: همزمانی (concurrency)","content":"آموزش استفاده از select\u0026hellip;\n"},{"id":34,"href":"/chapter-3/go-context/","title":"3.8 پکیج context","section":"فصل سوم: همزمانی (concurrency)","content":"پکیج context\u0026hellip;\n"},{"id":35,"href":"/chapter-3/go-concurrency-patterns/","title":"3.9 الگوهای همزمانی (concurrency patterns)","section":"فصل سوم: همزمانی (concurrency)","content":"الگوهای همزمانی (sconcurrency pattern)\u0026hellip;\n"},{"id":36,"href":"/chapter-3/go-channel-patterns/","title":"3.10 الگوهای کانال (channel patterns)","section":"فصل سوم: همزمانی (concurrency)","content":"الگوهای کانال (channel patterns)\u0026hellip;\n"},{"id":37,"href":"/chapter-3/go-concurrency-teqnique/","title":"3.11 تکنیک های همزمانی","section":"فصل سوم: همزمانی (concurrency)","content":"تکنیک های همزمانی\u0026hellip;\n"},{"id":38,"href":"/chapter-4/","title":"فصل چهارم: مباحث پیشرفته","section":"صفحه اصلی","content":"در این فصل به مباحث پیشرفته زبان گو میپردازیم\u0026hellip;\n"},{"id":39,"href":"/chapter-4/build-go-file/","title":"4.1 آموزش Build پروژه","section":"فصل چهارم: مباحث پیشرفته","content":"آموزش Build پروژه\u0026hellip;\n"},{"id":40,"href":"/chapter-4/debugging-go-code/","title":"4.2 آموزش کار با Debugging","section":"فصل چهارم: مباحث پیشرفته","content":"آموزش کار با Debugging\u0026hellip;\n"},{"id":41,"href":"/chapter-4/go-mod/","title":"4.3 آموزش کار با go mod","section":"فصل چهارم: مباحث پیشرفته","content":"آموزش کار با go mod\u0026hellip;\n"},{"id":42,"href":"/chapter-4/workspace/","title":"4.4 آموزش کار با workspace","section":"فصل چهارم: مباحث پیشرفته","content":"آموزش کار با workspace\u0026hellip;\n"},{"id":43,"href":"/chapter-4/command-line-go/","title":"4.5 آموزش نوشتن برنامه command line","section":"فصل چهارم: مباحث پیشرفته","content":"آموزش نوشتن برنامه command line\u0026hellip;\n"},{"id":44,"href":"/chapter-4/work-with-file-in-go/","title":"4.6 آموزش کار با فایل","section":"فصل چهارم: مباحث پیشرفته","content":"آموزش کار با فایل\u0026hellip;\n"},{"id":45,"href":"/chapter-4/workspace/","title":"4.7 آموزش کار با json","section":"فصل چهارم: مباحث پیشرفته","content":"آموزش کار با json\u0026hellip;\n"},{"id":46,"href":"/chapter-4/work-with-yaml-file-in-go/","title":"4.8 آموزش کار با yaml","section":"فصل چهارم: مباحث پیشرفته","content":"آموزش کار با yaml\u0026hellip;\n"},{"id":47,"href":"/chapter-4/work-with-toml-file-in-go/","title":"4.9 آموزش کار با toml","section":"فصل چهارم: مباحث پیشرفته","content":"آموزش کار با toml\u0026hellip;\n"},{"id":48,"href":"/chapter-4/work-with-csv-file-in-go/","title":"4.10 آموزش کار با csv","section":"فصل چهارم: مباحث پیشرفته","content":"آموزش کار با csv\u0026hellip;\n"},{"id":49,"href":"/chapter-4/work-with-ini-file-in-go/","title":"4.11 آموزش کار با ini","section":"فصل چهارم: مباحث پیشرفته","content":"آموزش کار با ini\u0026hellip;\n"},{"id":50,"href":"/chapter-4/work-with-environment-variable/","title":"4.12 آموزش کار با environment variable","section":"فصل چهارم: مباحث پیشرفته","content":"آموزش کار با environment variable\u0026hellip;\n"},{"id":51,"href":"/chapter-4/go-regular-expressions/","title":"4.13 آموزش کار با regexp","section":"فصل چهارم: مباحث پیشرفته","content":"آموزش کار با regexp\u0026hellip;\n"},{"id":52,"href":"/chapter-4/go-reflection/","title":"4.14 آموزش reflection","section":"فصل چهارم: مباحث پیشرفته","content":"آموزش reflection\u0026hellip;\n"},{"id":53,"href":"/chapter-4/go-generator/","title":"4.15 آموزش generator","section":"فصل چهارم: مباحث پیشرفته","content":"آموزش generator\u0026hellip;\n"},{"id":54,"href":"/chapter-4/go-stringer/","title":"4.16 آموزش stringer","section":"فصل چهارم: مباحث پیشرفته","content":"آموزش stringer\u0026hellip;\n"},{"id":55,"href":"/chapter-4/effective-go/","title":"4.17 تکنیک های کدنویسی زبان گو","section":"فصل چهارم: مباحث پیشرفته","content":"آموزش تکنیک های کدنویسی\u0026hellip;\n"},{"id":56,"href":"/chapter-4/go-code-rules/","title":"4.18 قوانین کدنویسی در گو","section":"فصل چهارم: مباحث پیشرفته","content":"قوانین کدنویسی در گو\u0026hellip;\n"},{"id":57,"href":"/chapter-4/go-garbage-collector/","title":"4.19 زباله جمع کن (garbage collector)","section":"فصل چهارم: مباحث پیشرفته","content":"زباله جمع کن (garbage collector)\u0026hellip;\n"},{"id":58,"href":"/chapter-5/","title":"فصل پنجم: برنامه نویسی شبکه با گو","section":"صفحه اصلی","content":"در این فصل به مباحث برنامه نویسی شبکه در زبان گو میپردازیم\u0026hellip;\n"},{"id":59,"href":"/chapter-5/go-http-server-begginer/","title":"5.1 کتابخانه http سمت سرور مقدماتی","section":"فصل پنجم: برنامه نویسی شبکه با گو","content":"آموزش کتابخانه http سمت سرور مقدماتی\u0026hellip;\n"},{"id":60,"href":"/chapter-5/go-http-server-advanced/","title":"5.2 کتابخانه http سمت سرور پیشرفته","section":"فصل پنجم: برنامه نویسی شبکه با گو","content":"آموزش کتابخانه http سمت سرور پیشرفته\u0026hellip;\n"},{"id":61,"href":"/chapter-5/go-http-client-begginer/","title":"5.3 کتابخانه http سمت کلاینت مقدماتی","section":"فصل پنجم: برنامه نویسی شبکه با گو","content":"آموزش کتابخانه http سمت کلاینت مقدماتی\u0026hellip;\n"},{"id":62,"href":"/chapter-5/go-http-client-advanced/","title":"5.4 کتابخانه http سمت کلاینت پیشرفته","section":"فصل پنجم: برنامه نویسی شبکه با گو","content":"آموزش کتابخانه http سمت کلاینت پیشرفته\u0026hellip;\n"},{"id":63,"href":"/chapter-6/","title":"فصل ششم: جنریک (Generics)","section":"صفحه اصلی","content":"در این فصل به مباحث جنریک در زبان گو میپردازیم\u0026hellip;\n"},{"id":64,"href":"/chapter-7/","title":"فصل هفتم: تست نویسی","section":"صفحه اصلی","content":"در این فصل به مباحث تست نویسی در زبان گو میپردازیم\u0026hellip;\n"},{"id":65,"href":"/chapter-8/","title":"فصل هشتم: پکیج های استاندارد","section":"صفحه اصلی","content":"در این فصل به مباحث پکیج های استاندارد در زبان گو میپردازیم\u0026hellip;\n"},{"id":66,"href":"/chapter-9/","title":"فصل نهم: الگوهای طراحی","section":"صفحه اصلی","content":"در این فصل به مباحث الگوهای طراحی در زبان گو میپردازیم\u0026hellip;\n"},{"id":67,"href":"/chapter-9/creational-patterns/","title":"الگوهای طراحی سازنده","section":"فصل نهم: الگوهای طراحی","content":"الگوهای طراحی سازنده\u0026hellip;\n"},{"id":68,"href":"/chapter-9/structural-patterns/","title":"الگوهای طراحی ساختاری","section":"فصل نهم: الگوهای طراحی","content":"الگوهای طراحی ساختاری\u0026hellip;\n"},{"id":69,"href":"/chapter-9/behavioral-patterns/","title":"الگوهای طراحی رفتاری","section":"فصل نهم: الگوهای طراحی","content":"الگوهای طراحی رفتاری\u0026hellip;\n"},{"id":70,"href":"/chapter-10/","title":"فصل دهم: الگوریتم و ساختار داده","section":"صفحه اصلی","content":"در این فصل به مباحث الگوریتم و ساختار داده در زبان گو میپردازیم\u0026hellip;\n"},{"id":71,"href":"/chapter-11/","title":"فصل یازدهم: معماری های نرم افزار","section":"صفحه اصلی","content":"در این فصل به مباحث معماری های نرم افزار در زبان گو میپردازیم\u0026hellip;\n"},{"id":72,"href":"/chapter-9/creational-patterns/go-singleton-pattern/","title":"9.1.1 الگو Singleton","section":"الگوهای طراحی سازنده","content":"الگو Singleton\u0026hellip;\n"},{"id":73,"href":"/chapter-9/creational-patterns/go-factory-method-pattern/","title":"9.1.2 الگو Factory Method","section":"الگوهای طراحی سازنده","content":"الگو Factory Method\u0026hellip;\n"},{"id":74,"href":"/chapter-9/creational-patterns/go-prototype-pattern/","title":"9.1.3 الگو Prototype","section":"الگوهای طراحی سازنده","content":"الگو Prototype\u0026hellip;\n"},{"id":75,"href":"/chapter-9/creational-patterns/go-abstract-factory-pattern/","title":"9.1.4 الگو Abstract Factory","section":"الگوهای طراحی سازنده","content":"الگو Abstract Factory\u0026hellip;\n"},{"id":76,"href":"/chapter-9/creational-patterns/go-builder-pattern/","title":"9.1.6 الگو Builder","section":"الگوهای طراحی سازنده","content":"الگو Builder\u0026hellip;\n"},{"id":77,"href":"/chapter-9/creational-patterns/go-object-pool-pattern/","title":"9.1.7 الگو Object Pool","section":"الگوهای طراحی سازنده","content":"الگو Object Pool\u0026hellip;\n"},{"id":78,"href":"/chapter-9/structural-patterns/go-adaptor-pattern/","title":"9.2.1 الگو Adaptor","section":"الگوهای طراحی ساختاری","content":"الگو Adaptor\u0026hellip;\n"},{"id":79,"href":"/chapter-9/structural-patterns/go-bridge-pattern/","title":"9.2.2 الگو Bridge","section":"الگوهای طراحی ساختاری","content":"الگو Bridge\u0026hellip;\n"},{"id":80,"href":"/chapter-9/structural-patterns/go-composite-pattern/","title":"9.2.3 الگو Composite","section":"الگوهای طراحی ساختاری","content":"الگو Composite\u0026hellip;\n"},{"id":81,"href":"/chapter-9/structural-patterns/go-decorator-pattern/","title":"9.2.1 الگو Decorator","section":"الگوهای طراحی ساختاری","content":"الگو Decorator\u0026hellip;\n"},{"id":82,"href":"/chapter-9/structural-patterns/go-facade-pattern/","title":"9.2.5 الگو Facade","section":"الگوهای طراحی ساختاری","content":"الگو Facade\u0026hellip;\n"},{"id":83,"href":"/chapter-9/structural-patterns/go-flyweight-pattern/","title":"9.2.6 الگو Flyweight","section":"الگوهای طراحی ساختاری","content":"الگو Flyweight\u0026hellip;\n"},{"id":84,"href":"/chapter-9/structural-patterns/go-proxy-pattern/","title":"9.2.7 الگو Proxy","section":"الگوهای طراحی ساختاری","content":"الگو Proxy\u0026hellip;\n"},{"id":85,"href":"/chapter-9/behavioral-patterns/go-chain-of-responsibility-pattern/","title":"5.3.1 الگو Chain Of Responsibility","section":"الگوهای طراحی رفتاری","content":"الگو Chain Of Responsibility\u0026hellip;\n"},{"id":86,"href":"/chapter-9/behavioral-patterns/go-command-pattern/","title":"9.3.2 الگو Command","section":"الگوهای طراحی رفتاری","content":"الگو Command\u0026hellip;\n"},{"id":87,"href":"/chapter-9/behavioral-patterns/go-iterator-pattern/","title":"9.3.3 الگو Iterator","section":"الگوهای طراحی رفتاری","content":"الگو Iterator\u0026hellip;\n"},{"id":88,"href":"/chapter-9/behavioral-patterns/go-mediator-pattern/","title":"9.3.4 الگو Mediator","section":"الگوهای طراحی رفتاری","content":"الگو Mediator\u0026hellip;\n"},{"id":89,"href":"/chapter-9/behavioral-patterns/go-memento-pattern/","title":"9.3.5 الگو Memento","section":"الگوهای طراحی رفتاری","content":"الگو Memento\u0026hellip;\n"},{"id":90,"href":"/chapter-9/behavioral-patterns/go-observer-pattern/","title":"9.3.6 الگو Observer","section":"الگوهای طراحی رفتاری","content":"الگو Observer\u0026hellip;\n"},{"id":91,"href":"/chapter-9/behavioral-patterns/go-state-pattern/","title":"9.3.7 الگو State","section":"الگوهای طراحی رفتاری","content":"الگو State\u0026hellip;\n"},{"id":92,"href":"/chapter-9/behavioral-patterns/go-strategy-pattern/","title":"9.3.8 الگو Strategy","section":"الگوهای طراحی رفتاری","content":"الگو Strategy\u0026hellip;\n"},{"id":93,"href":"/chapter-9/behavioral-patterns/go-template-method-pattern/","title":"9.3.9 الگو Template Method","section":"الگوهای طراحی رفتاری","content":"الگو Template Method\u0026hellip;\n"},{"id":94,"href":"/chapter-9/behavioral-patterns/go-visitor-pattern/","title":"9.3.10 الگو Visitor","section":"الگوهای طراحی رفتاری","content":"الگو Visitor\u0026hellip;\n"}]