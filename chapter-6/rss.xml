<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><author/><title>فصل ششم: ژنریک ها (Generics) on زبان گو فارسی</title><link>https://book.gofarsi.ir/chapter-6/</link><description>Recent content in فصل ششم: ژنریک ها (Generics) on زبان گو فارسی</description><generator>Hugo -- gohugo.io</generator><language>fa</language><copyright>2023 GoFarsi All rights reserved</copyright><atom:link href="https://book.gofarsi.ir/chapter-6/rss.xml" rel="self" type="application/rss+xml"/><item><author/><title>6.1 مقدمه و اهمیت ژنریک‌ها</title><link>https://book.gofarsi.ir/chapter-6/go-generics-basic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-6/go-generics-basic/</guid><description>&lt;p&gt;ایده ژنریک (Generics) به مفهوم &lt;strong&gt;برنامه‌نویسی پارامتری (Parametric Polymorphism)&lt;/strong&gt; برمی‌گردد؛ یعنی نوشتن توابع، کلاس‌ها یا انواعی که با انواع مختلف داده کار کنند بدون اینکه برای هر نوع داده، پیاده‌سازی مجزایی لازم باشد. این مفهوم در علوم کامپیوتر از دهه ۱۹۷۰ مطرح بود و به تدریج به زبان‌های اصلی برنامه‌نویسی راه یافت.&lt;/p&gt;
&lt;h4 id="نقش-کلیدی-david-r-musser-و-alexander-a-stepanov"&gt;
نقش کلیدی &lt;strong&gt;David R. Musser&lt;/strong&gt; و &lt;strong&gt;Alexander A. Stepanov&lt;/strong&gt;
&lt;a class="anchor" href="#%d9%86%d9%82%d8%b4-%da%a9%d9%84%db%8c%d8%af%db%8c-david-r-musser-%d9%88-alexander-a-stepanov"&gt;#&lt;/a&gt;
&lt;/h4&gt;
&lt;p&gt;دو نفر از پیشگامان و پژوهشگران مهم این حوزه، &lt;strong&gt;David R. Musser&lt;/strong&gt; و &lt;strong&gt;Alexander A. Stepanov&lt;/strong&gt; هستند. آن‌ها در دهه ۸۰ و ۹۰ میلادی پژوهش‌هایی درباره طراحی و پیاده‌سازی الگوریتم‌های ژنریک انجام دادند.&lt;br&gt;
یکی از مهم‌ترین مقالات آن‌ها:&lt;/p&gt;</description></item><item><author/><title>6.2 مبانی ژنریک‌ها در Go</title><link>https://book.gofarsi.ir/chapter-6/go-generics-fundamentals/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-6/go-generics-fundamentals/</guid><description>&lt;h3 id="۶۲۱-تعریف-ژنریک-generic-چیست"&gt;
۶.۲.۱ تعریف ژنریک (Generic) چیست؟
&lt;a class="anchor" href="#%db%b6%db%b2%db%b1-%d8%aa%d8%b9%d8%b1%db%8c%d9%81-%da%98%d9%86%d8%b1%db%8c%da%a9-generic-%da%86%db%8c%d8%b3%d8%aa"&gt;#&lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;ژنریک (Generic)&lt;/strong&gt; به معنی &amp;ldquo;کلی&amp;rdquo;، &amp;ldquo;عام&amp;rdquo; یا &amp;ldquo;نوع‌پذیر&amp;rdquo; است؛ مفهومی که به شما امکان می‌دهد یک تابع، نوع داده یا ساختار را به گونه‌ای بنویسید که با انواع مختلف داده‌ها کار کند، بدون اینکه برای هر نوع، پیاده‌سازی جداگانه لازم باشد.&lt;br&gt;
به بیان دیگر، ژنریک‌ها قابلیتی برای &lt;strong&gt;بازاستفاده امن و بهینه از کد&lt;/strong&gt; در سطح زبان برنامه‌نویسی هستند.&lt;/p&gt;
&lt;blockquote class="book-hint info"&gt;
&lt;p&gt;&lt;strong&gt;یه جمله ای از Ian lancer tailor هست:&lt;/strong&gt;&lt;/p&gt;</description></item><item><author/><title>6.3 سینتکس و ساختار ژنریک‌ها در Go</title><link>https://book.gofarsi.ir/chapter-6/go-generics-syntax-and-structure/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-6/go-generics-syntax-and-structure/</guid><description>&lt;h2 id="۶۳۱-تعریف-تابع-ژنریک-generic-functions"&gt;
۶.۳.۱ تعریف تابع ژنریک (Generic Functions)
&lt;a class="anchor" href="#%db%b6%db%b3%db%b1-%d8%aa%d8%b9%d8%b1%db%8c%d9%81-%d8%aa%d8%a7%d8%a8%d8%b9-%da%98%d9%86%d8%b1%db%8c%da%a9-generic-functions"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;در Go از نسخه ۱.۱۸، می‌توانید توابعی بنویسید که به‌جای نوع خاص، با نوع پارامتری کار می‌کنند. پارامترهای نوعی (type parameters) در کروشه &lt;code&gt;[]&lt;/code&gt; بعد از نام تابع قرار می‌گیرند.&lt;/p&gt;
&lt;h4 id="نمونه-سینتکس"&gt;
&lt;strong&gt;نمونه سینتکس:&lt;/strong&gt;
&lt;a class="anchor" href="#%d9%86%d9%85%d9%88%d9%86%d9%87-%d8%b3%db%8c%d9%86%d8%aa%da%a9%d8%b3"&gt;#&lt;/a&gt;
&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-go"&gt;func Swap[T any](a, b T) (T, T) {
return b, a
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;T&lt;/strong&gt; پارامتر نوعی است که می‌تواند هر نوعی را بپذیرد (در اینجا با constraint &lt;code&gt;any&lt;/code&gt;).&lt;/p&gt;</description></item><item><author/><title>6.4 Constraints و Type Sets</title><link>https://book.gofarsi.ir/chapter-6/go-generics-type-sets-and-constraints/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-6/go-generics-type-sets-and-constraints/</guid><description>&lt;h2 id="۶۴۱-مفهوم-constraint-و-نقش-آن-در-ژنریکها"&gt;
۶.۴.۱ مفهوم constraint و نقش آن در ژنریک‌ها
&lt;a class="anchor" href="#%db%b6%db%b4%db%b1-%d9%85%d9%81%d9%87%d9%88%d9%85-constraint-%d9%88-%d9%86%d9%82%d8%b4-%d8%a2%d9%86-%d8%af%d8%b1-%da%98%d9%86%d8%b1%db%8c%da%a9%d9%87%d8%a7"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Constraint&lt;/strong&gt; (قید یا محدودیت) در ژنریک‌های Go ابزاری است برای کنترل اینکه یک پارامتر نوعی (type parameter) باید چه ویژگی‌هایی داشته باشد.&lt;br&gt;
بدون constraint، هر نوعی می‌تواند جایگزین شود، اما با تعریف constraint، دایره‌ی مجاز را محدود می‌کنیم تا هم ایمنی نوعی بالا رود و هم امکانات بیشتری برای پیاده‌سازی داشته باشیم.&lt;/p&gt;
&lt;h4 id="نقش-constraint"&gt;
&lt;strong&gt;نقش constraint:&lt;/strong&gt;
&lt;a class="anchor" href="#%d9%86%d9%82%d8%b4-constraint"&gt;#&lt;/a&gt;
&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;جلوگیری از استفاده نادرست از ژنریک‌ها (مثلاً استفاده از عملیات غیرمجاز روی نوع پارامتری)&lt;/li&gt;
&lt;li&gt;افزایش قابلیت تشخیص خطا در زمان کامپایل&lt;/li&gt;
&lt;li&gt;امکان تعریف abstractionهای قوی‌تر&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;مثال ساده:&lt;/strong&gt;&lt;/p&gt;</description></item><item><author/><title>6.5 مثال‌ها و کاربردهای عملی ژنریک‌ها</title><link>https://book.gofarsi.ir/chapter-6/go-generics-examples-and-practical/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-6/go-generics-examples-and-practical/</guid><description>&lt;h2 id="۶۵۱-توابع-ژنریک-متداول-مانند-min-max-map-filter"&gt;
۶.۵.۱ توابع ژنریک متداول (مانند Min, Max, Map, Filter)
&lt;a class="anchor" href="#%db%b6%db%b5%db%b1-%d8%aa%d9%88%d8%a7%d8%a8%d8%b9-%da%98%d9%86%d8%b1%db%8c%da%a9-%d9%85%d8%aa%d8%af%d8%a7%d9%88%d9%84-%d9%85%d8%a7%d9%86%d9%86%d8%af-min-max-map-filter"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;h4 id="تابع-min-و-max"&gt;
تابع Min و Max
&lt;a class="anchor" href="#%d8%aa%d8%a7%d8%a8%d8%b9-min-%d9%88-max"&gt;#&lt;/a&gt;
&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-go"&gt;import &amp;quot;cmp&amp;quot; // از Go 1.21+
func Min[T cmp.Ordered](a, b T) T {
if a &amp;lt; b {
return a
}
return b
}
func Max[T cmp.Ordered](a, b T) T {
if a &amp;gt; b {
return a
}
return b
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;توضیح:&lt;/strong&gt;&lt;br&gt;
این دو تابع ژنریک به شما اجازه می‌دهند با هر نوع داده‌ای که قابل مقایسه با عملگرهای بزرگ‌تر/کوچک‌تر باشد (مثل int، float64، string و&amp;hellip;) بیشینه یا کمینه دو مقدار را به دست آورید. پارامتر نوعی &lt;code&gt;T&lt;/code&gt; باید قید &lt;code&gt;cmp.Ordered&lt;/code&gt; را داشته باشد تا عملیات مقایسه مجاز باشد. این ساختار به جای نوشتن نسخه‌های تکراری برای هر نوع داده، یک تابع عمومی و امن ایجاد می‌کند.&lt;/p&gt;</description></item><item><author/><title>6.6 مقایسه ژنریک‌ها با راهکارهای قبل از Go 1.18</title><link>https://book.gofarsi.ir/chapter-6/comparing-generics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-6/comparing-generics/</guid><description>&lt;h2 id="۶۶۱-استفاده-از-interface-و-reflect-قبل-از-ژنریکها"&gt;
۶.۶.۱ استفاده از interface{} و reflect قبل از ژنریک‌ها
&lt;a class="anchor" href="#%db%b6%db%b6%db%b1-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-interface-%d9%88-reflect-%d9%82%d8%a8%d9%84-%d8%a7%d8%b2-%da%98%d9%86%d8%b1%db%8c%da%a9%d9%87%d8%a7"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;پیش از Go 1.18، برای پیاده‌سازی توابع یا ساختارهای داده عمومی، معمولاً از نوع &lt;strong&gt;interface{}&lt;/strong&gt; (نوع همه‌کاره) استفاده می‌شد.
در موارد نیاز به عملیات خاص یا تبدیل نوع، ناچار به استفاده از &lt;strong&gt;reflect&lt;/strong&gt; یا type assertion بودیم. این روش‌ها معایب و ریسک‌های خاص خود را داشتند.&lt;/p&gt;
&lt;h4 id="مثال-تابع-max-با-interface-و-reflect"&gt;
&lt;strong&gt;مثال: تابع Max با interface{} و reflect&lt;/strong&gt;
&lt;a class="anchor" href="#%d9%85%d8%ab%d8%a7%d9%84-%d8%aa%d8%a7%d8%a8%d8%b9-max-%d8%a8%d8%a7-interface-%d9%88-reflect"&gt;#&lt;/a&gt;
&lt;/h4&gt;
&lt;p&gt;`&lt;div class="go-playground"&gt;
&lt;pre class="line-numbers"&gt;&lt;code class="language-go"&gt;import (
"fmt"
"reflect"
)
func Max(a, b interface{}) interface{} {
av := reflect.ValueOf(a)
bv := reflect.ValueOf(b)
if av.Kind() == reflect.Int &amp;&amp; bv.Kind() == reflect.Int {
if av.Int() &gt; bv.Int() {
return a
}
return b
}
// می‌توانید برای انواع دیگر هم کد بنویسید
return nil
}
func main() {
fmt.Println(Max(3, 7)) // خروجی: 7
}&lt;/code&gt;&lt;/pre&gt;
&lt;button class="run-code"&gt;▶ اجرای کد&lt;/button&gt;
&lt;button class="copy-code"&gt;کپی&lt;/button&gt;
&lt;button class="hide-output"&gt;✖ بستن خروجی&lt;/button&gt;
&lt;pre class="run-output hidden"&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/p&gt;</description></item><item><author/><title>6.7 محدودیت‌ها، خطاها و ضدالگوها در ژنریک‌ها</title><link>https://book.gofarsi.ir/chapter-6/limitations-errors-and-anti-patterns-in-generics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-6/limitations-errors-and-anti-patterns-in-generics/</guid><description>&lt;h2 id="۶۷۱-محدودیتهای-فعلی-ژنریکها-در-go-compile-time--runtime"&gt;
۶.۷.۱ محدودیت‌های فعلی ژنریک‌ها در Go (Compile-time &amp;amp; Runtime)
&lt;a class="anchor" href="#%db%b6%db%b7%db%b1-%d9%85%d8%ad%d8%af%d9%88%d8%af%db%8c%d8%aa%d9%87%d8%a7%db%8c-%d9%81%d8%b9%d9%84%db%8c-%da%98%d9%86%d8%b1%db%8c%da%a9%d9%87%d8%a7-%d8%af%d8%b1-go-compile-time--runtime"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;اگرچه ژنریک‌ها قابلیت فوق‌العاده‌ای به Go افزوده‌اند، اما هنوز با برخی محدودیت‌های فنی و زبانی روبه‌رو هستند که باید حتماً در پروژه‌های جدی مدنظر قرار گیرد:&lt;/p&gt;
&lt;h4 id="محدودیتهای-زمان-کامپایل-compile-time"&gt;
محدودیت‌های زمان کامپایل (Compile-time)
&lt;a class="anchor" href="#%d9%85%d8%ad%d8%af%d9%88%d8%af%db%8c%d8%aa%d9%87%d8%a7%db%8c-%d8%b2%d9%85%d8%a7%d9%86-%da%a9%d8%a7%d9%85%d9%be%d8%a7%db%8c%d9%84-compile-time"&gt;#&lt;/a&gt;
&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;عدم پشتیبانی از عملیات ریاضی یا منطقی روی هر نوع دلخواه:&lt;/strong&gt;&lt;br&gt;
فقط انواعی که قید مناسب (مانند &lt;code&gt;cmp.Ordered&lt;/code&gt; یا union خاص) دارند می‌توانند با عملگرهای مقایسه یا ریاضی استفاده شوند.&lt;/p&gt;</description></item><item><author/><title>6.8 بهترین شیوه‌های استفاده از ژنریک‌ها (Best Practices)</title><link>https://book.gofarsi.ir/chapter-6/generics-best-practice/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-6/generics-best-practice/</guid><description>&lt;p&gt;در این بخش، به‌صورت حرفه‌ای، کاربردی و تجربی، &lt;strong&gt;بهترین شیوه‌های استفاده از ژنریک‌ها&lt;/strong&gt; در پروژه‌های Go را همراه با نکات تولیدی و فنی ارائه می‌دهم.&lt;/p&gt;
&lt;h3 id="۶۸۱-راهنمای-تصمیمگیری-چه-زمانی-ژنریک-چه-زمانی-نه"&gt;
۶.۸.۱ راهنمای تصمیم‌گیری: چه زمانی ژنریک؟ چه زمانی نه؟
&lt;a class="anchor" href="#%db%b6%db%b8%db%b1-%d8%b1%d8%a7%d9%87%d9%86%d9%85%d8%a7%db%8c-%d8%aa%d8%b5%d9%85%db%8c%d9%85%da%af%db%8c%d8%b1%db%8c-%da%86%d9%87-%d8%b2%d9%85%d8%a7%d9%86%db%8c-%da%98%d9%86%d8%b1%db%8c%da%a9-%da%86%d9%87-%d8%b2%d9%85%d8%a7%d9%86%db%8c-%d9%86%d9%87"&gt;#&lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;ژنریک‌ها ابزار قدرتمندی هستند، اما استفاده درست و هوشمندانه از آن‌ها حیاتی است.&lt;/strong&gt;&lt;br&gt;
بهتر است ژنریک را فقط زمانی به کار ببرید که:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;یک منطق تکراری برای چندین نوع مختلف وجود دارد&lt;/strong&gt; و پیاده‌سازی جداگانه برای هر نوع باعث تکرار و دشواری نگهداری می‌شود.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;نیاز به abstraction و توسعه‌پذیری کد&lt;/strong&gt; برای آینده وجود دارد، مانند ساختار داده‌ها (Stack, Queue, Map)، یا توابع عمومی (Map, Filter, Reduce).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ایمنی نوعی (Type Safety)&lt;/strong&gt; برایتان مهم است و می‌خواهید خطاها را در زمان کامپایل متوجه شوید.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;چه زمانی ژنریک استفاده نکنیم؟&lt;/strong&gt;&lt;/p&gt;</description></item><item><author/><title>6.9 مثال‌های پیشرفته و نکات ویژه</title><link>https://book.gofarsi.ir/chapter-6/generics-advanced-examples-and-tips/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-6/generics-advanced-examples-and-tips/</guid><description>&lt;h2 id="۶۹۱-ساخت-کتابخانههای-عمومی-و-abstractionهای-حرفهای-با-ژنریکها"&gt;
۶.۹.۱ ساخت کتابخانه‌های عمومی و abstractionهای حرفه‌ای با ژنریک‌ها
&lt;a class="anchor" href="#%db%b6%db%b9%db%b1-%d8%b3%d8%a7%d8%ae%d8%aa-%da%a9%d8%aa%d8%a7%d8%a8%d8%ae%d8%a7%d9%86%d9%87%d9%87%d8%a7%db%8c-%d8%b9%d9%85%d9%88%d9%85%db%8c-%d9%88-abstraction%d9%87%d8%a7%db%8c-%d8%ad%d8%b1%d9%81%d9%87%d8%a7%db%8c-%d8%a8%d8%a7-%da%98%d9%86%d8%b1%db%8c%da%a9%d9%87%d8%a7"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;در پروژه‌های مدرن، معمولاً نیاز به abstraction و لایه‌بندی وجود دارد تا بتوانید کدهای reusable و توسعه‌پذیر بسازید. ژنریک‌ها در Go این کار را بسیار ساده و حرفه‌ای می‌کنند.&lt;/p&gt;
&lt;h4 id="مثال-کتابخانه-datastore-ژنریک"&gt;
&lt;strong&gt;مثال: کتابخانه DataStore ژنریک&lt;/strong&gt;
&lt;a class="anchor" href="#%d9%85%d8%ab%d8%a7%d9%84-%da%a9%d8%aa%d8%a7%d8%a8%d8%ae%d8%a7%d9%86%d9%87-datastore-%da%98%d9%86%d8%b1%db%8c%da%a9"&gt;#&lt;/a&gt;
&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-go"&gt;type DataStore[T any] interface {
Get(id string) (T, error)
Save(id string, data T) error
}
type MemoryStore[T any] struct {
data map[string]T
}
func NewMemoryStore[T any]() *MemoryStore[T] {
return &amp;amp;MemoryStore[T]{data: make(map[string]T)}
}
func (m *MemoryStore[T]) Get(id string) (T, error) {
v, ok := m.data[id]
if !ok {
var zero T
return zero, fmt.Errorf(&amp;quot;not found&amp;quot;)
}
return v, nil
}
func (m *MemoryStore[T]) Save(id string, data T) error {
m.data[id] = data
return nil
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;توضیح:&lt;/strong&gt;&lt;br&gt;
در این مثال یک abstraction برای ذخیره‌سازی داده‌ها پیاده‌سازی شده که می‌تواند برای هر نوع داده‌ای مورد استفاده قرار گیرد (مثلاً User, Order, Product و &amp;hellip;). این ساختار با پیاده‌سازی interface ژنریک، قابلیت توسعه و تست بسیار بالایی دارد و به راحتی می‌توانید MemoryStore را با نسخه DatabaseStore یا CacheStore جایگزین کنید.&lt;/p&gt;</description></item></channel></rss>