<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><author/><title>فصل ششم: ژنریک ها (Generics) on زبان گو فارسی</title><link>https://book.gofarsi.ir/chapter-6/</link><description>Recent content in فصل ششم: ژنریک ها (Generics) on زبان گو فارسی</description><generator>Hugo -- gohugo.io</generator><language>fa</language><copyright>2023 GoFarsi All rights reserved</copyright><atom:link href="https://book.gofarsi.ir/chapter-6/feed.xml" rel="self" type="application/rss+xml"/><item><author/><title>6.1 مقدمه و اهمیت ژنریک‌ها</title><link>https://book.gofarsi.ir/chapter-6/go-generics-basic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-6/go-generics-basic/</guid><description>&lt;p>ایده ژنریک (Generics) به مفهوم &lt;strong>برنامه‌نویسی پارامتری (Parametric Polymorphism)&lt;/strong> برمی‌گردد؛ یعنی نوشتن توابع، کلاس‌ها یا انواعی که با انواع مختلف داده کار کنند بدون اینکه برای هر نوع داده، پیاده‌سازی مجزایی لازم باشد. این مفهوم در علوم کامپیوتر از دهه ۱۹۷۰ مطرح بود و به تدریج به زبان‌های اصلی برنامه‌نویسی راه یافت.&lt;/p>
&lt;h4 id="نقش-کلیدی-david-r-musser-و-alexander-a-stepanov">
نقش کلیدی &lt;strong>David R. Musser&lt;/strong> و &lt;strong>Alexander A. Stepanov&lt;/strong>
&lt;a class="anchor" href="#%d9%86%d9%82%d8%b4-%da%a9%d9%84%db%8c%d8%af%db%8c-david-r-musser-%d9%88-alexander-a-stepanov">#&lt;/a>
&lt;/h4>
&lt;p>دو نفر از پیشگامان و پژوهشگران مهم این حوزه، &lt;strong>David R. Musser&lt;/strong> و &lt;strong>Alexander A. Stepanov&lt;/strong> هستند. آن‌ها در دهه ۸۰ و ۹۰ میلادی پژوهش‌هایی درباره طراحی و پیاده‌سازی الگوریتم‌های ژنریک انجام دادند.&lt;br>
یکی از مهم‌ترین مقالات آن‌ها:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>“Generic Programming”&lt;/strong>&lt;/li>
&lt;li>نوشته شده توسط Alexander Stepanov و David Musser&lt;/li>
&lt;li>منتشر شده در سال 1988، کتابچه International Seminar on Generic Programming&lt;/li>
&lt;li>&lt;a href="https://link.springer.com/chapter/10.1007/3-540-51084-2_2">لینک مقاله در Springer&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>در این مقاله، آن‌ها ایده &amp;ldquo;برنامه‌نویسی ژنریک&amp;rdquo; را فراتر از الگوهای تابعی (functional patterns) و شی‌گرا معرفی کردند و تأثیر زیادی بر طراحی استانداردهای زبان‌های بعدی داشتند.&lt;br>
&lt;strong>Stepanov&lt;/strong> بعداً به عنوان طراح اصلی STL (Standard Template Library) در ++C شناخته شد که یکی از اولین پیاده‌سازی‌های موفق و پرکاربرد ژنریک در سطح صنعتی بود.&lt;/p>
&lt;h2 id="۶۱۱-چرا-ژنریکها-مشکلات-توسعه-بدون-ژنریک">
۶.۱.۱ چرا ژنریک‌ها؟ (مشکلات توسعه بدون ژنریک)
&lt;a class="anchor" href="#%db%b6%db%b1%db%b1-%da%86%d8%b1%d8%a7-%da%98%d9%86%d8%b1%db%8c%da%a9%d9%87%d8%a7-%d9%85%d8%b4%da%a9%d9%84%d8%a7%d8%aa-%d8%aa%d9%88%d8%b3%d8%b9%d9%87-%d8%a8%d8%af%d9%88%d9%86-%da%98%d9%86%d8%b1%db%8c%da%a9">#&lt;/a>
&lt;/h2>
&lt;p>در برنامه‌نویسی، بارها نیاز پیدا می‌کنیم یک الگوریتم یا ساختار داده را برای انواع مختلف داده بنویسیم؛ مثلاً مرتب‌سازی یک لیست از اعداد صحیح، لیست رشته‌ها یا هر نوع دیگری.&lt;br>
در زبان‌هایی که &lt;strong>ژنریک (Generic)&lt;/strong> ندارند یا قبل از اضافه شدن ژنریک به Go، این نیاز به چند روش رفع می‌شد که هر کدام معایب و مشکلات جدی داشتند:&lt;/p>
&lt;h4 id="الف-کپیبرداری-و-تکرار-کد">
الف) کپی‌برداری و تکرار کد
&lt;a class="anchor" href="#%d8%a7%d9%84%d9%81-%da%a9%d9%be%db%8c%d8%a8%d8%b1%d8%af%d8%a7%d8%b1%db%8c-%d9%88-%d8%aa%da%a9%d8%b1%d8%a7%d8%b1-%da%a9%d8%af">#&lt;/a>
&lt;/h4>
&lt;p>برای هر نوع داده یک نسخه جداگانه از کد می‌نوشتیم.&lt;br>
مثلاً یک تابع برای &lt;code>[]int&lt;/code>، یکی برای &lt;code>[]string&lt;/code> و&amp;hellip;&lt;br>
این کار باعث می‌شد:&lt;/p>
&lt;ul>
&lt;li>حجم کد زیاد شود (Boilerplate)&lt;/li>
&lt;li>نگهداری سخت شود (هر تغییری باید در چند جا انجام شود)&lt;/li>
&lt;li>احتمال بروز باگ بیشتر شود&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>مثال:&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">func MaxInt(a, b int) int {
if a &amp;gt; b {
return a
}
return b
}
func MaxFloat64(a, b float64) float64 {
if a &amp;gt; b {
return a
}
return b
}
&lt;/code>&lt;/pre>
&lt;h4 id="ب-استفاده-از-interface-و-بازتاب-reflect">
ب) استفاده از interface{} و بازتاب (Reflect)
&lt;a class="anchor" href="#%d8%a8-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-interface-%d9%88-%d8%a8%d8%a7%d8%b2%d8%aa%d8%a7%d8%a8-reflect">#&lt;/a>
&lt;/h4>
&lt;p>راه دوم، استفاده از نوع همه‌کاره‌ی &lt;code>interface{}&lt;/code> و بازتاب (reflect) بود:&lt;/p>
&lt;pre>&lt;code class="language-go">func Max(a, b interface{}) interface{} {
// مقایسه به کمک reflect یا type assertion
// کد پیچیده و کند می‌شود
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>معایب:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>کاهش خوانایی و ایمنی کد (Type Safety)&lt;/li>
&lt;li>نبود هشدار کامپایلری برای ناسازگاری انواع&lt;/li>
&lt;li>کندی اجرا به دلیل استفاده از بازتاب&lt;/li>
&lt;/ul>
&lt;h4 id="ج-مشکل-type-safety-و-تولید-کد-ضعیف">
ج) مشکل Type Safety و تولید کد ضعیف
&lt;a class="anchor" href="#%d8%ac-%d9%85%d8%b4%da%a9%d9%84-type-safety-%d9%88-%d8%aa%d9%88%d9%84%db%8c%d8%af-%da%a9%d8%af-%d8%b6%d8%b9%db%8c%d9%81">#&lt;/a>
&lt;/h4>
&lt;p>کدهای مبتنی بر interface{} می‌توانند در اجرا دچار panic شوند و خطاهای type را فقط در runtime نشان دهند.&lt;/p>
&lt;hr>
&lt;h4 id="خلاصه-مشکلات-بدون-ژنریک">
&lt;strong>خلاصه مشکلات بدون ژنریک&lt;/strong>
&lt;a class="anchor" href="#%d8%ae%d9%84%d8%a7%d8%b5%d9%87-%d9%85%d8%b4%da%a9%d9%84%d8%a7%d8%aa-%d8%a8%d8%af%d9%88%d9%86-%da%98%d9%86%d8%b1%db%8c%da%a9">#&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>تکرار و افزونگی کد&lt;/li>
&lt;li>سختی نگهداری و توسعه&lt;/li>
&lt;li>کاهش ایمنی نوعی (type safety)&lt;/li>
&lt;li>افت کارایی (performance)&lt;/li>
&lt;li>بالا رفتن احتمال بروز باگ&lt;/li>
&lt;/ul>
&lt;h2 id="۶۱۲-تاریخچه-و-سیر-تکامل-ژنریکها-در-go">
۶.۱.۲ تاریخچه و سیر تکامل ژنریک‌ها در Go
&lt;a class="anchor" href="#%db%b6%db%b1%db%b2-%d8%aa%d8%a7%d8%b1%db%8c%d8%ae%da%86%d9%87-%d9%88-%d8%b3%db%8c%d8%b1-%d8%aa%da%a9%d8%a7%d9%85%d9%84-%da%98%d9%86%d8%b1%db%8c%da%a9%d9%87%d8%a7-%d8%af%d8%b1-go">#&lt;/a>
&lt;/h2>
&lt;p>از ابتدای طراحی زبان Go، توسعه‌دهندگان زیادی خواهان قابلیت ژنریک بودند تا بتوانند الگوریتم‌ها و ساختارهای داده را به صورت type-safe و بدون تکرار بنویسند.&lt;br>
اما تیم توسعه Go به دلایل مختلف (ساده نگه‌داشتن زبان، اجتناب از پیچیدگی‌های اضافی و دغدغه‌های کارایی) این قابلیت را تا مدت‌ها به تعویق انداخت.&lt;/p>
&lt;h4 id="مراحل-مهم-در-مسیر-ژنریک-در-go">
&lt;strong>مراحل مهم در مسیر ژنریک در Go:&lt;/strong>
&lt;a class="anchor" href="#%d9%85%d8%b1%d8%a7%d8%ad%d9%84-%d9%85%d9%87%d9%85-%d8%af%d8%b1-%d9%85%d8%b3%db%8c%d8%b1-%da%98%d9%86%d8%b1%db%8c%da%a9-%d8%af%d8%b1-go">#&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>قبل از Go 1.18:&lt;/strong>&lt;br>
هیچ پشتیبانی رسمی از ژنریک وجود نداشت؛ برنامه‌نویسان ناچار به استفاده از راه‌حل‌های غیراستاندارد بودند (تکرار کد، interface{}، بازتاب و &amp;hellip;).&lt;/li>
&lt;li>&lt;strong>پیشنهادهای اولیه:&lt;/strong>&lt;br>
از سال ۲۰۱۰ تا ۲۰۲۰، چندین طرح پیشنهادی برای اضافه‌کردن ژنریک مطرح شد که برخی به‌خاطر پیچیدگی یا ناسازگاری با فلسفه Go رد شدند.&lt;/li>
&lt;li>&lt;strong>Go 1.18 (مارس ۲۰۲۲):&lt;/strong>&lt;br>
&lt;strong>انقلاب بزرگ!&lt;/strong>&lt;br>
پشتیبانی رسمی از ژنریک اضافه شد:
&lt;ul>
&lt;li>معرفی type parameter&lt;/li>
&lt;li>تعریف constraint و type set&lt;/li>
&lt;li>امکان تعریف توابع و انواع ژنریک با سینتکس ساده و خوانا&lt;/li>
&lt;li>حفظ سرعت کامپایل و کارایی اجرایی&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Go 1.21 (۲۰۲۳):&lt;/strong>&lt;br>
اضافه شدن constraintهای جدید مثل &lt;code>cmp.Ordered&lt;/code>&lt;/li>
&lt;li>&lt;strong>Go 1.24 (۲۰۲۵):&lt;/strong>&lt;br>
اضافه‌شدن &lt;strong>Generic Type Alias&lt;/strong> (امکان alias برای نوع و constraint ژنریک)&lt;/li>
&lt;li>&lt;strong>Go 1.25 (۲۰۲۵):&lt;/strong>&lt;br>
حذف مفهوم core type و ساده‌تر شدن قواعد زبان برای genericها (طبق مستندات جدید و Go Blog).&lt;/li>
&lt;/ul>
&lt;h2 id="۶۱۳-کاربردهای-رایج-ژنریکها-در-برنامهنویسی-مدرن">
۶.۱.۳ کاربردهای رایج ژنریک‌ها در برنامه‌نویسی مدرن
&lt;a class="anchor" href="#%db%b6%db%b1%db%b3-%da%a9%d8%a7%d8%b1%d8%a8%d8%b1%d8%af%d9%87%d8%a7%db%8c-%d8%b1%d8%a7%db%8c%d8%ac-%da%98%d9%86%d8%b1%db%8c%da%a9%d9%87%d8%a7-%d8%af%d8%b1-%d8%a8%d8%b1%d9%86%d8%a7%d9%85%d9%87%d9%86%d9%88%db%8c%d8%b3%db%8c-%d9%85%d8%af%d8%b1%d9%86">#&lt;/a>
&lt;/h2>
&lt;p>ژنریک‌ها در عمل، برای حل مسائلی به کار می‌روند که نیاز به بازاستفاده کد و ایمنی نوعی بالا دارند. مهم‌ترین کاربردها:&lt;/p>
&lt;h4 id="الف-ساختارهای-دادهی-عمومی">
الف) &lt;strong>ساختارهای داده‌ی عمومی&lt;/strong>
&lt;a class="anchor" href="#%d8%a7%d9%84%d9%81-%d8%b3%d8%a7%d8%ae%d8%aa%d8%a7%d8%b1%d9%87%d8%a7%db%8c-%d8%af%d8%a7%d8%af%d9%87%db%8c-%d8%b9%d9%85%d9%88%d9%85%db%8c">#&lt;/a>
&lt;/h4>
&lt;p>مثل Stack, Queue, List, Map و&amp;hellip; که باید با انواع مختلف داده کار کنند:&lt;/p>
&lt;pre>&lt;code class="language-go">type Stack[T any] struct {
data []T
}
func (s *Stack[T]) Push(val T) { s.data = append(s.data, val) }
func (s *Stack[T]) Pop() T { /* ... */ }
&lt;/code>&lt;/pre>
&lt;p>این ساختار را می‌توانید برای هر نوعی (int, string, struct و &amp;hellip;) به کار ببرید:&lt;/p>
&lt;pre>&lt;code class="language-go">var intStack Stack[int]
var strStack Stack[string]
&lt;/code>&lt;/pre>
&lt;h4 id="ب-الگوریتمهای-عمومی">
ب) &lt;strong>الگوریتم‌های عمومی&lt;/strong>
&lt;a class="anchor" href="#%d8%a8-%d8%a7%d9%84%da%af%d9%88%d8%b1%db%8c%d8%aa%d9%85%d9%87%d8%a7%db%8c-%d8%b9%d9%85%d9%88%d9%85%db%8c">#&lt;/a>
&lt;/h4>
&lt;p>مانند مرتب‌سازی، جست‌وجو، فیلتر و &amp;hellip;&lt;/p>
&lt;pre>&lt;code class="language-go">func Filter[T any](list []T, f func(T) bool) []T {
var res []T
for _, v := range list {
if f(v) { res = append(res, v) }
}
return res
}
&lt;/code>&lt;/pre>
&lt;h4 id="ج-کتابخانههای-عمومی-و-بازمتن">
ج) &lt;strong>کتابخانه‌های عمومی و بازمتن&lt;/strong>
&lt;a class="anchor" href="#%d8%ac-%da%a9%d8%aa%d8%a7%d8%a8%d8%ae%d8%a7%d9%86%d9%87%d9%87%d8%a7%db%8c-%d8%b9%d9%85%d9%88%d9%85%db%8c-%d9%88-%d8%a8%d8%a7%d8%b2%d9%85%d8%aa%d9%86">#&lt;/a>
&lt;/h4>
&lt;p>توسعه کتابخانه‌هایی که کاربران مختلف با داده‌های دلخواه‌شان به سادگی از آن استفاده کنند (مانند &lt;code>slices&lt;/code>, &lt;code>maps&lt;/code> و &amp;hellip; در استاندارد Go).&lt;/p>
&lt;h4 id="د-ساخت-abstraction-و-معماری-ماژولار">
د) &lt;strong>ساخت abstraction و معماری ماژولار&lt;/strong>
&lt;a class="anchor" href="#%d8%af-%d8%b3%d8%a7%d8%ae%d8%aa-abstraction-%d9%88-%d9%85%d8%b9%d9%85%d8%a7%d8%b1%db%8c-%d9%85%d8%a7%da%98%d9%88%d9%84%d8%a7%d8%b1">#&lt;/a>
&lt;/h4>
&lt;p>امکان پیاده‌سازی اینترفیس‌ها و abstractionهای سطح بالا به صورت type-safe و قابل استفاده برای انواع مختلف.&lt;/p>
&lt;h4 id="ه-افزایش-خوانایی-و-نگهداری-کد">
ه) &lt;strong>افزایش خوانایی و نگهداری کد&lt;/strong>
&lt;a class="anchor" href="#%d9%87-%d8%a7%d9%81%d8%b2%d8%a7%db%8c%d8%b4-%d8%ae%d9%88%d8%a7%d9%86%d8%a7%db%8c%db%8c-%d9%88-%d9%86%da%af%d9%87%d8%af%d8%a7%d8%b1%db%8c-%da%a9%d8%af">#&lt;/a>
&lt;/h4>
&lt;p>ژنریک‌ها باعث می‌شوند کد کوتاه‌تر، خواناتر و تغییرپذیرتر شود و توسعه‌دهنده فقط یکبار کد را پیاده‌سازی و همه‌جا استفاده کند.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>نمونه واقعی از کتابخانه استاندارد Go:&lt;/strong>&lt;br>
کتابخانه &lt;code>slices&lt;/code> (از Go 1.21) دارای توابع ژنریک برای کار با انواع slice:&lt;/p>
&lt;pre>&lt;code class="language-go">import &amp;quot;slices&amp;quot;
ints := []int{1, 2, 3}
slices.Reverse(ints) // بدون نیاز به کپی کد
&lt;/code>&lt;/pre>
&lt;h2 id="۶۱4-مرور-تغییرات-عملکردی-ژنریکها-در-go">
۶.۱.4 مرور تغییرات عملکردی ژنریک‌ها در Go
&lt;a class="anchor" href="#%db%b6%db%b14-%d9%85%d8%b1%d9%88%d8%b1-%d8%aa%d8%ba%db%8c%db%8c%d8%b1%d8%a7%d8%aa-%d8%b9%d9%85%d9%84%da%a9%d8%b1%d8%af%db%8c-%da%98%d9%86%d8%b1%db%8c%da%a9%d9%87%d8%a7-%d8%af%d8%b1-go">#&lt;/a>
&lt;/h2>
&lt;p>از نسخه‌ی &lt;strong>Go 1.18&lt;/strong> تا نسخه‌ی کنونی، چند تغییر کلیدی در عملکرد (Performance) ژنریک‌ها رخ داده که در ادامه بررسی دقیق و مستند آن‌ها را ارائه می‌دهم:&lt;/p>
&lt;h3 id="-go-118--ورود-ژنریک-اثر-بر-سرعت-کامپایل-و-اجرا">
🔹 Go 1.18 – ورود ژنریک؛ اثر بر سرعت کامپایل و اجرا
&lt;a class="anchor" href="#-go-118--%d9%88%d8%b1%d9%88%d8%af-%da%98%d9%86%d8%b1%db%8c%da%a9-%d8%a7%d8%ab%d8%b1-%d8%a8%d8%b1-%d8%b3%d8%b1%d8%b9%d8%aa-%da%a9%d8%a7%d9%85%d9%be%d8%a7%db%8c%d9%84-%d9%88-%d8%a7%d8%ac%d8%b1%d8%a7">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>کند شدن کامپایل تا 15٪&lt;/strong> نسبت به Go 1.17 به دلیل اضافه‌شدن چک‌های نوعی ژنریک و type checker جدید (&lt;a href="https://tip.golang.org/doc/go1.18?utm_source=book.gofarsi.ir" title="Go 1.18 Release Notes - The Go Programming Language">tip.golang.org&lt;/a>, &lt;a href="https://www.infoq.com/news/2023/02/go-1-20-generics-performance/?utm_source=book.gofarsi.ir" title="Go 1.20 Improves Compiler Performance and Extends Coverage ...">InfoQ&lt;/a>).&lt;/li>
&lt;li>&lt;strong>عملکرد اجرا (runtime)&lt;/strong> بدون تغییر محسوسی باقی ماند، چون کد ژنریک از نوع monomorphization جزئی (dictionary-based) است و روی runtime overhead تاثیری نمی‌گذارد (&lt;a href="https://www.infoq.com/news/2022/04/go-generics-performance/?utm_source=book.gofarsi.ir" title="On Go&amp;#39;s Generics Implementation and Performance - InfoQ">InfoQ&lt;/a>).&lt;/li>
&lt;/ul>
&lt;h3 id="-go-119--بهبود-عملکرد-ژنریکها">
🔹 Go 1.19 – بهبود عملکرد ژنریک‌ها
&lt;a class="anchor" href="#-go-119--%d8%a8%d9%87%d8%a8%d9%88%d8%af-%d8%b9%d9%85%d9%84%da%a9%d8%b1%d8%af-%da%98%d9%86%d8%b1%db%8c%da%a9%d9%87%d8%a7">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>بروزرسانی‌های ابزار کامپایل، runtime و حافظه بهینه‌سازی شده.&lt;/li>
&lt;li>&lt;strong>تا 20٪ بهبود در سرعت برخی برنامه‌های ژنریک&lt;/strong> گزارش شده است .&lt;/li>
&lt;li>تیم Go تغییراتی در memory model انجام داد تا کارایی GC نیز بهبود یابد، که به‌ویژه در ترکیب با ژنریک‌ها مفید بود .&lt;/li>
&lt;/ul>
&lt;h3 id="-go-120--بهبود-سرعت-کامپایل-و-اجرا">
🔹 Go 1.20 – بهبود سرعت کامپایل و اجرا
&lt;a class="anchor" href="#-go-120--%d8%a8%d9%87%d8%a8%d9%88%d8%af-%d8%b3%d8%b1%d8%b9%d8%aa-%da%a9%d8%a7%d9%85%d9%be%d8%a7%db%8c%d9%84-%d9%88-%d8%a7%d8%ac%d8%b1%d8%a7">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>رفع regressions قبلی: سرعت build به سطح Go 1.17 بازگشت (تا 10٪ سریع‌تر نسبت به 1.19) (&lt;a href="https://tip.golang.org/doc/go1.20?utm_source=book.gofarsi.ir" title="Go 1.20 Release Notes - The Go Programming Language">tip.golang.org&lt;/a>).&lt;/li>
&lt;li>بهبود جزئی در &amp;ldquo;generated code performance&amp;rdquo; نسبت به 1.19 (&lt;a href="https://tip.golang.org/doc/go1.20?utm_source=book.gofarsi.ir" title="Go 1.20 Release Notes - The Go Programming Language">tip.golang.org&lt;/a>).&lt;/li>
&lt;li>امکان فعال‌سازی &lt;strong>Profile-Guided Optimization (PGO)&lt;/strong> برای بهینه‌سازی‌های inline در call-sites ارائه شد، که می‌تواند به اجرای سریع‌تر ژنریک‌ها منجر شود (&lt;a href="https://tip.golang.org/doc/go1.20?utm_source=book.gofarsi.ir" title="Go 1.20 Release Notes - The Go Programming Language">tip.golang.org&lt;/a>).&lt;/li>
&lt;/ul>
&lt;h3 id="بررسی-جنبههای-تاثیرگذار-بر-عملکرد">
بررسی جنبه‌های تاثیرگذار بر عملکرد
&lt;a class="anchor" href="#%d8%a8%d8%b1%d8%b1%d8%b3%db%8c-%d8%ac%d9%86%d8%a8%d9%87%d9%87%d8%a7%db%8c-%d8%aa%d8%a7%d8%ab%db%8c%d8%b1%da%af%d8%b0%d8%a7%d8%b1-%d8%a8%d8%b1-%d8%b9%d9%85%d9%84%da%a9%d8%b1%d8%af">#&lt;/a>
&lt;/h3>
&lt;h4 id="۱-قواعد-dictionary-based-مونومورفیسازی">
۱. قواعد Dictionary-based مونومورفی‌سازی
&lt;a class="anchor" href="#%db%b1-%d9%82%d9%88%d8%a7%d8%b9%d8%af-dictionary-based-%d9%85%d9%88%d9%86%d9%88%d9%85%d9%88%d8%b1%d9%81%db%8c%d8%b3%d8%a7%d8%b2%db%8c">#&lt;/a>
&lt;/h4>
&lt;p>Go از تکنیک &lt;strong>جزئی مونومورفی‌سازی به وسیله ‌GCShape و دیکشنری&lt;/strong> استفاده می‌کند. این روش مقداری overhead در سربار lookup برای methodها ایجاد می‌کند، به ویژه اگر پارامتر نوع، interface باشد .&lt;/p>
&lt;h4 id="۲-تأخیر-در-lookup-برای-methodهای-اینترفیسی">
۲. تأخیر در lookup برای methodهای اینترفیسی
&lt;a class="anchor" href="#%db%b2-%d8%aa%d8%a3%d8%ae%db%8c%d8%b1-%d8%af%d8%b1-lookup-%d8%a8%d8%b1%d8%a7%db%8c-method%d9%87%d8%a7%db%8c-%d8%a7%db%8c%d9%86%d8%aa%d8%b1%d9%81%db%8c%d8%b3%db%8c">#&lt;/a>
&lt;/h4>
&lt;p>مقایسه benchmarking‌ نشان داد:&lt;/p>
&lt;pre>&lt;code class="language-go">BenchmarkFooIFace: 5.38 ns/op
BenchmarkFooGeneric: 14.33 ns/op
&lt;/code>&lt;/pre>
&lt;p>یعنی استفاده از ژنریک ~2.6 برابر کندتر از فراخوانی مستقیم interface است (&lt;a href="https://deepsource.com/blog/go-1-18-generics-implementation?utm_source=book.gofarsi.ir" title="The generics implementation of Go 1.18 - DeepSource">deepsource.com&lt;/a>).&lt;/p>
&lt;h4 id="۳-تأثیر-بر-توسعهدهی-و-بهبودهای-آینده">
۳. تأثیر بر توسعه‌دهی و بهبودهای آینده
&lt;a class="anchor" href="#%db%b3-%d8%aa%d8%a3%d8%ab%db%8c%d8%b1-%d8%a8%d8%b1-%d8%aa%d9%88%d8%b3%d8%b9%d9%87%d8%af%d9%87%db%8c-%d9%88-%d8%a8%d9%87%d8%a8%d9%88%d8%af%d9%87%d8%a7%db%8c-%d8%a2%db%8c%d9%86%d8%af%d9%87">#&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>توسعه کامپایلر Go در نسخه‌های بعدی احتمالاً نرخ مونومورفی‌سازی و inlining را بهبود می‌دهد .&lt;/li>
&lt;li>به‌روزرسانی‌ها در Go 1.21+ و αισوب esperanza تعریف generic interfaces نیز چنین پیشرفت‌هایی را تسهیل می‌کنند.&lt;/li>
&lt;/ul></description></item><item><author/><title>6.2 مبانی ژنریک‌ها در Go</title><link>https://book.gofarsi.ir/chapter-6/go-generics-fundamentals/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-6/go-generics-fundamentals/</guid><description>&lt;h3 id="۶۲۱-تعریف-ژنریک-generic-چیست">
۶.۲.۱ تعریف ژنریک (Generic) چیست؟
&lt;a class="anchor" href="#%db%b6%db%b2%db%b1-%d8%aa%d8%b9%d8%b1%db%8c%d9%81-%da%98%d9%86%d8%b1%db%8c%da%a9-generic-%da%86%db%8c%d8%b3%d8%aa">#&lt;/a>
&lt;/h3>
&lt;p>&lt;strong>ژنریک (Generic)&lt;/strong> به معنی &amp;ldquo;کلی&amp;rdquo;، &amp;ldquo;عام&amp;rdquo; یا &amp;ldquo;نوع‌پذیر&amp;rdquo; است؛ مفهومی که به شما امکان می‌دهد یک تابع، نوع داده یا ساختار را به گونه‌ای بنویسید که با انواع مختلف داده‌ها کار کند، بدون اینکه برای هر نوع، پیاده‌سازی جداگانه لازم باشد.&lt;br>
به بیان دیگر، ژنریک‌ها قابلیتی برای &lt;strong>بازاستفاده امن و بهینه از کد&lt;/strong> در سطح زبان برنامه‌نویسی هستند.&lt;/p>
&lt;blockquote class="book-hint info">
&lt;p>&lt;strong>یه جمله ای از Ian lancer tailor هست:&lt;/strong>&lt;/p>
&lt;p>زمانی باید از جنریک استفاده کرد که کد شما بواسطه تغییر تایپ تکرار می شود یا اینکه برای کاهش assertion از جنریک استفاده کنیم.&lt;/p>
&lt;/blockquote>
&lt;h4 id="کاربرد-ژنریک">
&lt;strong>کاربرد ژنریک:&lt;/strong>
&lt;a class="anchor" href="#%da%a9%d8%a7%d8%b1%d8%a8%d8%b1%d8%af-%da%98%d9%86%d8%b1%db%8c%da%a9">#&lt;/a>
&lt;/h4>
&lt;p>فرض کنید می‌خواهید یک تابع برای پیدا کردن مقدار بیشینه در یک آرایه بنویسید.&lt;br>
در حالت عادی باید برای هر نوع داده (int، float64، string و &amp;hellip;) یک نسخه بنویسید یا از &lt;code>interface{}&lt;/code> استفاده کنید که معایب زیادی دارد.&lt;br>
ژنریک‌ها این محدودیت را برطرف می‌کنند و به شما اجازه می‌دهند که فقط یک بار منطق را بنویسید و برای هر نوع داده‌ای از آن استفاده کنید.&lt;/p>
&lt;p>&lt;strong>نمونه ساده:&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">// یک تابع ژنریک برای بازگرداندن بیشینه دو مقدار از هر نوع مرتب‌شونده
func Max[T cmp.Ordered](a, b T) T {
if a &amp;gt; b {
return a
}
return b
}
&lt;/code>&lt;/pre>
&lt;p>اینجا &lt;code>[T cmp.Ordered]&lt;/code> می‌گوید T می‌تواند هر نوعی باشد که قابلیت مقایسه داشته باشد (int، float64، string و &amp;hellip;).&lt;/p>
&lt;h4 id="ویژگی-اصلی-ژنریک">
&lt;strong>ویژگی اصلی ژنریک:&lt;/strong>
&lt;a class="anchor" href="#%d9%88%db%8c%da%98%da%af%db%8c-%d8%a7%d8%b5%d9%84%db%8c-%da%98%d9%86%d8%b1%db%8c%da%a9">#&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>تعریف توابع و ساختارهای عمومی (generic) که به صورت type-safe با انواع مختلف کار می‌کنند.&lt;/li>
&lt;li>کاهش چشمگیر تکرار کد (DRY)&lt;/li>
&lt;li>ارتقاء خوانایی و نگهداری کد&lt;/li>
&lt;li>بهبود کارایی نسبت به روش‌های مبتنی بر &lt;code>interface{}&lt;/code> و بازتاب (reflect)&lt;/li>
&lt;/ul>
&lt;h3 id="۶۲۲-واژگان-کلیدی-ژنریک-در-go">
۶.۲.۲ واژگان کلیدی ژنریک در Go
&lt;a class="anchor" href="#%db%b6%db%b2%db%b2-%d9%88%d8%a7%da%98%da%af%d8%a7%d9%86-%da%a9%d9%84%db%8c%d8%af%db%8c-%da%98%d9%86%d8%b1%db%8c%da%a9-%d8%af%d8%b1-go">#&lt;/a>
&lt;/h3>
&lt;p>درک مفاهیم کلیدی ژنریک در Go برای استفاده صحیح و حرفه‌ای ضروری است:&lt;/p>
&lt;h4 id="۱-type-parameter-پارامتر-نوع">
۱. &lt;strong>Type Parameter (پارامتر نوع)&lt;/strong>
&lt;a class="anchor" href="#%db%b1-type-parameter-%d9%be%d8%a7%d8%b1%d8%a7%d9%85%d8%aa%d8%b1-%d9%86%d9%88%d8%b9">#&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>متغیری است که نوع داده را به صورت پارامتریک مشخص می‌کند.&lt;/li>
&lt;li>در تعریف تابع یا نوع ژنریک درون کروشه قرار می‌گیرد.&lt;/li>
&lt;/ul>
&lt;p>مثال:&lt;/p>
&lt;pre>&lt;code class="language-go">func Print[T any](item T) {
fmt.Println(item)
}
&lt;/code>&lt;/pre>
&lt;h4 id="۲-constraint-قیدمحدودیت">
۲. &lt;strong>Constraint (قید/محدودیت)&lt;/strong>
&lt;a class="anchor" href="#%db%b2-constraint-%d9%82%db%8c%d8%af%d9%85%d8%ad%d8%af%d9%88%d8%af%db%8c%d8%aa">#&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>محدودیتی که مشخص می‌کند پارامتر نوع (T) باید چه ویژگی‌هایی داشته باشد.&lt;/li>
&lt;li>معمولاً یک اینترفیس است که نوع موردنظر باید آن را پیاده‌سازی کند یا عضو مجموعه‌ای از انواع باشد.&lt;/li>
&lt;/ul>
&lt;p>مثال:&lt;/p>
&lt;pre>&lt;code class="language-go"> func Sum[T Number](a, b T) T { ... }
type Number interface {
int | int64 | float64
}
&lt;/code>&lt;/pre>
&lt;h4 id="۳-type-set-مجموعه-نوع">
۳. &lt;strong>Type Set (مجموعه نوع)&lt;/strong>
&lt;a class="anchor" href="#%db%b3-type-set-%d9%85%d8%ac%d9%85%d9%88%d8%b9%d9%87-%d9%86%d9%88%d8%b9">#&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>مجموعه‌ای از انواع که یک constraint آن‌ها را مجاز می‌داند.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>در Go، type set معمولاً به صورت union تعریف می‌شود (مثلاً &lt;code>int | float64&lt;/code>)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>در constraintهای مبتنی بر اینترفیس می‌توانید ترکیبی از method و type را تعیین کنید:&lt;/p>
&lt;pre>&lt;code class="language-go">type Stringer interface {
String() string
}
type Numeric interface {
int | int64 | float64
}
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;h4 id="۴-type-inference-استنتاج-نوع">
۴. &lt;strong>Type Inference (استنتاج نوع)&lt;/strong>
&lt;a class="anchor" href="#%db%b4-type-inference-%d8%a7%d8%b3%d8%aa%d9%86%d8%aa%d8%a7%d8%ac-%d9%86%d9%88%d8%b9">#&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>فرآیندی که در آن کامپایلر Go می‌تواند پارامتر نوع را به صورت خودکار از روی ورودی‌های تابع یا نوع، حدس بزند.&lt;/li>
&lt;/ul>
&lt;p>مثال:&lt;/p>
&lt;pre>&lt;code class="language-go"> Max(10, 20) // T به طور خودکار int فرض می‌شود
Max(2.5, 3.8) // T به طور خودکار float64 فرض می‌شود
&lt;/code>&lt;/pre>
&lt;h4 id="۵-constraint-interface-اینترفیس-محدودکننده">
۵. &lt;strong>Constraint Interface (اینترفیس محدودکننده)&lt;/strong>
&lt;a class="anchor" href="#%db%b5-constraint-interface-%d8%a7%db%8c%d9%86%d8%aa%d8%b1%d9%81%db%8c%d8%b3-%d9%85%d8%ad%d8%af%d9%88%d8%af%da%a9%d9%86%d9%86%d8%af%d9%87">#&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>اینترفیس‌هایی که هم می‌توانند method داشته باشند هم مجموعه‌ای از انواع را مشخص کنند. مثال:&lt;/p>
&lt;pre>&lt;code class="language-go">type Constraint interface {
~[]byte | ~string
Hash() uint64
}
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;h4 id="۶-any-و-comparable">
۶. &lt;strong>any و comparable&lt;/strong>
&lt;a class="anchor" href="#%db%b6-any-%d9%88-comparable">#&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>any:&lt;/strong> معادل interface{}، یعنی هر نوعی را مجاز می‌داند.&lt;/li>
&lt;li>&lt;strong>comparable:&lt;/strong> فقط نوع‌هایی که قابل مقایسه با == و != هستند را می‌پذیرد (برای map key و غیره).&lt;/li>
&lt;/ul>
&lt;h3 id="۶۲۳-تفاوت-ژنریکهای-go-با-سایر-زبانها-java-c-rust-و-">
۶.۲.۳ تفاوت ژنریک‌های Go با سایر زبان‌ها (Java، C#، Rust و &amp;hellip;)
&lt;a class="anchor" href="#%db%b6%db%b2%db%b3-%d8%aa%d9%81%d8%a7%d9%88%d8%aa-%da%98%d9%86%d8%b1%db%8c%da%a9%d9%87%d8%a7%db%8c-go-%d8%a8%d8%a7-%d8%b3%d8%a7%db%8c%d8%b1-%d8%b2%d8%a8%d8%a7%d9%86%d9%87%d8%a7-java-c-rust-%d9%88-">#&lt;/a>
&lt;/h3>
&lt;p>ژنریک‌ها مفهومی جهانی هستند، اما نحوه پیاده‌سازی و امکانات آن‌ها در زبان‌های مختلف متفاوت است. در اینجا برخی تفاوت‌های کلیدی آورده شده است:&lt;/p>
&lt;h4 id="الف-سینتکس-و-سادگی">
الف) &lt;strong>سینتکس و سادگی&lt;/strong>
&lt;a class="anchor" href="#%d8%a7%d9%84%d9%81-%d8%b3%db%8c%d9%86%d8%aa%da%a9%d8%b3-%d9%88-%d8%b3%d8%a7%d8%af%da%af%db%8c">#&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>ژنریک‌های Go به صورت پارامتر نوع در کروشه &lt;code>[]&lt;/code> تعریف می‌شوند:&lt;/p>
&lt;pre>&lt;code class="language-go">func Swap[T any](a, b T) (T, T)
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>در Java و C#: پارامتر نوع با &amp;lt;&amp;gt; تعریف می‌شود:&lt;/p>
&lt;pre>&lt;code class="language-java">public &amp;lt;T&amp;gt; void swap(T a, T b)
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;h4 id="ب-type-constraint">
ب) &lt;strong>Type Constraint&lt;/strong>
&lt;a class="anchor" href="#%d8%a8-type-constraint">#&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>Go امکان تعریف محدودیت (constraint) به شکل بسیار قوی و صریح با اینترفیس یا مجموعه نوع دارد.&lt;/li>
&lt;li>در Java، فقط می‌توانید یک superclass یا interface به عنوان محدودیت تعریف کنید.&lt;/li>
&lt;li>در Rust، با trait bounds، و در C# با constraints (مثل where T: struct).&lt;/li>
&lt;/ul>
&lt;h4 id="ج-type-erasure-vs-monomorphization">
ج) &lt;strong>Type Erasure vs. Monomorphization&lt;/strong>
&lt;a class="anchor" href="#%d8%ac-type-erasure-vs-monomorphization">#&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>در &lt;strong>Java&lt;/strong>، پیاده‌سازی ژنریک‌ها با &lt;strong>Type Erasure&lt;/strong> است؛ یعنی اطلاعات نوع ژنریک در زمان اجرا حذف می‌شود و فقط در زمان کامپایل کنترل می‌شود.&lt;/li>
&lt;li>در &lt;strong>Go&lt;/strong> (و Rust و ++C)، ژنریک‌ها با &lt;strong>Monomorphization&lt;/strong> پیاده‌سازی می‌شوند؛ یعنی برای هر نوع داده، کد جداگانه‌ای در زمان کامپایل تولید می‌شود (به معنای ایمنی و کارایی بالاتر).&lt;/li>
&lt;li>&lt;strong>C#&lt;/strong> هم از رویکرد متفاوتی بهره می‌برد که در برخی موارد closer به monomorphization است.&lt;/li>
&lt;/ul>
&lt;h4 id="د-پشتیبانی-از-عملیات">
د) &lt;strong>پشتیبانی از عملیات&lt;/strong>
&lt;a class="anchor" href="#%d8%af-%d9%be%d8%b4%d8%aa%db%8c%d8%a8%d8%a7%d9%86%db%8c-%d8%a7%d8%b2-%d8%b9%d9%85%d9%84%db%8c%d8%a7%d8%aa">#&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>در Go می‌توانید union type تعریف کنید (مثلاً &lt;code>int | float64&lt;/code>)&lt;/li>
&lt;li>در Java این امکان وجود ندارد و باید فقط به یک superclass یا interface محدود کنید.&lt;/li>
&lt;/ul>
&lt;h4 id="ه-specialization-و-reflection">
ه) &lt;strong>Specialization و Reflection&lt;/strong>
&lt;a class="anchor" href="#%d9%87-specialization-%d9%88-reflection">#&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>Go ژنریک‌ها را به صورت type-safe و بدون بازتاب (reflect) اجرا می‌کند، در حالی که در زبان‌هایی مثل Python و حتی Java، بخشی از قدرت ژنریک‌ها وابسته به بازتاب است.&lt;/li>
&lt;li>Rust و ++C هم مانند Go، اجرا را type-safe و بدون reflect انجام می‌دهند.&lt;/li>
&lt;/ul>
&lt;h4 id="و-تفاوت-در-قابلیتها">
و) &lt;strong>تفاوت در قابلیت‌ها&lt;/strong>
&lt;a class="anchor" href="#%d9%88-%d8%aa%d9%81%d8%a7%d9%88%d8%aa-%d8%af%d8%b1-%d9%82%d8%a7%d8%a8%d9%84%db%8c%d8%aa%d9%87%d8%a7">#&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>در Go، ژنریک‌ها روی function, struct و interface قابل اعمال هستند.&lt;/li>
&lt;li>در Rust و ++C حتی macroها و traitهای پیچیده‌تر و specializationهای سطح پایین‌تر ممکن است.&lt;/li>
&lt;li>در Java و C#، برخی ویژگی‌ها مانند generic constructor یا wildcard support متفاوت‌اند.&lt;/li>
&lt;/ul></description></item><item><author/><title>6.3 سینتکس و ساختار ژنریک‌ها در Go</title><link>https://book.gofarsi.ir/chapter-6/go-generics-syntax-and-structure/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-6/go-generics-syntax-and-structure/</guid><description>&lt;h2 id="۶۳۱-تعریف-تابع-ژنریک-generic-functions">
۶.۳.۱ تعریف تابع ژنریک (Generic Functions)
&lt;a class="anchor" href="#%db%b6%db%b3%db%b1-%d8%aa%d8%b9%d8%b1%db%8c%d9%81-%d8%aa%d8%a7%d8%a8%d8%b9-%da%98%d9%86%d8%b1%db%8c%da%a9-generic-functions">#&lt;/a>
&lt;/h2>
&lt;p>در Go از نسخه ۱.۱۸، می‌توانید توابعی بنویسید که به‌جای نوع خاص، با نوع پارامتری کار می‌کنند. پارامترهای نوعی (type parameters) در کروشه &lt;code>[]&lt;/code> بعد از نام تابع قرار می‌گیرند.&lt;/p>
&lt;h4 id="نمونه-سینتکس">
&lt;strong>نمونه سینتکس:&lt;/strong>
&lt;a class="anchor" href="#%d9%86%d9%85%d9%88%d9%86%d9%87-%d8%b3%db%8c%d9%86%d8%aa%da%a9%d8%b3">#&lt;/a>
&lt;/h4>
&lt;pre>&lt;code class="language-go">func Swap[T any](a, b T) (T, T) {
return b, a
}
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>T&lt;/strong> پارامتر نوعی است که می‌تواند هر نوعی را بپذیرد (در اینجا با constraint &lt;code>any&lt;/code>).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>تابع بالا می‌تواند برای هر نوعی (&lt;code>int&lt;/code>، &lt;code>string&lt;/code>، ساختار دلخواه و &amp;hellip;) فراخوانی شود:&lt;/p>
&lt;pre>&lt;code class="language-go">a, b := Swap[int](1, 2) // خروجی: 2, 1
x, y := Swap[string](&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;) // خروجی: &amp;quot;b&amp;quot;, &amp;quot;a&amp;quot;
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Type Inference:&lt;/strong> معمولاً Go نوع را به طور خودکار تشخیص می‌دهد و نیازی به ذکر &lt;code>[int]&lt;/code> نیست:&lt;/p>
&lt;pre>&lt;code class="language-go">s, t := Swap(&amp;quot;hello&amp;quot;, &amp;quot;world&amp;quot;)
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;h4 id="با-constraint-محدودیت-نوع">
&lt;strong>با constraint (محدودیت نوع):&lt;/strong>
&lt;a class="anchor" href="#%d8%a8%d8%a7-constraint-%d9%85%d8%ad%d8%af%d9%88%d8%af%db%8c%d8%aa-%d9%86%d9%88%d8%b9">#&lt;/a>
&lt;/h4>
&lt;pre>&lt;code class="language-go">func Max[T cmp.Ordered](a, b T) T {
if a &amp;gt; b {
return a
}
return b
}
&lt;/code>&lt;/pre>
&lt;p>در اینجا فقط انواع مرتب‌شونده (&lt;code>int&lt;/code>, &lt;code>float64&lt;/code>, &lt;code>string&lt;/code>, &amp;hellip;) مجاز هستند.&lt;/p>
&lt;h2 id="۶۳۲-تعریف-نوع-type-ژنریک-generic-types">
۶.۳.۲ تعریف نوع (Type) ژنریک (Generic Types)
&lt;a class="anchor" href="#%db%b6%db%b3%db%b2-%d8%aa%d8%b9%d8%b1%db%8c%d9%81-%d9%86%d9%88%d8%b9-type-%da%98%d9%86%d8%b1%db%8c%da%a9-generic-types">#&lt;/a>
&lt;/h2>
&lt;p>شما می‌توانید struct، slice، map یا هر نوع داده دلخواه را به صورت ژنریک تعریف کنید تا برای انواع مختلف قابل استفاده باشد.&lt;/p>
&lt;h4 id="مثال-struct-ژنریک">
&lt;strong>مثال Struct ژنریک:&lt;/strong>
&lt;a class="anchor" href="#%d9%85%d8%ab%d8%a7%d9%84-struct-%da%98%d9%86%d8%b1%db%8c%da%a9">#&lt;/a>
&lt;/h4>
&lt;pre>&lt;code class="language-go">type Box[T any] struct {
Value T
}
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>
&lt;p>اکنون می‌توانید Box را برای هر نوعی استفاده کنید:&lt;/p>
&lt;pre>&lt;code class="language-go">var intBox Box[int]
intBox.Value = 42
var strBox Box[string]
strBox.Value = &amp;quot;Go!&amp;quot;
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;h4 id="مثال-عملی--stack-ژنریک">
&lt;strong>مثال عملی – Stack ژنریک:&lt;/strong>
&lt;a class="anchor" href="#%d9%85%d8%ab%d8%a7%d9%84-%d8%b9%d9%85%d9%84%db%8c--stack-%da%98%d9%86%d8%b1%db%8c%da%a9">#&lt;/a>
&lt;/h4>
&lt;pre>&lt;code class="language-go">type Stack[T any] struct {
items []T
}
func (s *Stack[T]) Push(item T) {
s.items = append(s.items, item)
}
func (s *Stack[T]) Pop() (T, bool) {
if len(s.items) == 0 {
var zero T
return zero, false
}
idx := len(s.items) - 1
item := s.items[idx]
s.items = s.items[:idx]
return item, true
}
&lt;/code>&lt;/pre>
&lt;p>این ساختار را می‌توانید برای &lt;code>int&lt;/code>، &lt;code>string&lt;/code>، struct دلخواه و &amp;hellip; به کار ببرید.&lt;/p>
&lt;h2 id="۶۳۳-تعریف-اینترفیس-ژنریک-generic-interfaces">
۶.۳.۳ تعریف اینترفیس ژنریک (Generic Interfaces)
&lt;a class="anchor" href="#%db%b6%db%b3%db%b3-%d8%aa%d8%b9%d8%b1%db%8c%d9%81-%d8%a7%db%8c%d9%86%d8%aa%d8%b1%d9%81%db%8c%d8%b3-%da%98%d9%86%d8%b1%db%8c%da%a9-generic-interfaces">#&lt;/a>
&lt;/h2>
&lt;p>از Go 1.18+، می‌توانید interfaceهایی با پارامتر نوع بنویسید. این امکان بسیار قدرتمند است و اجازه abstraction و تعریف constraintهای پیچیده را می‌دهد.&lt;/p>
&lt;h4 id="نمونه-سینتکس-1">
&lt;strong>نمونه سینتکس:&lt;/strong>
&lt;a class="anchor" href="#%d9%86%d9%85%d9%88%d9%86%d9%87-%d8%b3%db%8c%d9%86%d8%aa%da%a9%d8%b3-1">#&lt;/a>
&lt;/h4>
&lt;pre>&lt;code class="language-go">type Equaler[T any] interface {
Equal(T) bool
}
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>هر نوعی که متد &lt;code>Equal(T) bool&lt;/code> داشته باشد می‌تواند پیاده‌ساز این اینترفیس باشد.&lt;/li>
&lt;/ul>
&lt;h4 id="مثال--set-ژنریک">
&lt;strong>مثال – Set ژنریک:&lt;/strong>
&lt;a class="anchor" href="#%d9%85%d8%ab%d8%a7%d9%84--set-%da%98%d9%86%d8%b1%db%8c%da%a9">#&lt;/a>
&lt;/h4>
&lt;pre>&lt;code class="language-go">type Set[E any] interface {
Insert(E)
Delete(E)
Has(E) bool
}
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>اکنون می‌توانید انواع مختلف Set برای انواع داده متفاوت پیاده‌سازی کنید.&lt;/li>
&lt;/ul>
&lt;h4 id="constraint-ژنریک-مبتنی-بر-متد">
&lt;strong>Constraint ژنریک مبتنی بر متد:&lt;/strong>
&lt;a class="anchor" href="#constraint-%da%98%d9%86%d8%b1%db%8c%da%a9-%d9%85%d8%a8%d8%aa%d9%86%db%8c-%d8%a8%d8%b1-%d9%85%d8%aa%d8%af">#&lt;/a>
&lt;/h4>
&lt;pre>&lt;code class="language-go">type Comparer[T any] interface {
Compare(T) int
}
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>این الگو به شما اجازه می‌دهد فقط با انواعی کار کنید که متد &lt;code>Compare&lt;/code> دارند.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>نکته کاربردی:&lt;/strong> تعریف constraintها و abstractionهای پیشرفته با استفاده از generic interface در نسخه‌های جدید Go (به ویژه Go 1.21+ و Go 1.24) بسیار ساده و قدرتمند شده است.&lt;/p>
&lt;h2 id="۶۳۴-استفاده-همزمان-از-چند-پارامتر-نوع-multiple-type-parameters">
۶.۳.۴ استفاده همزمان از چند پارامتر نوع (Multiple Type Parameters)
&lt;a class="anchor" href="#%db%b6%db%b3%db%b4-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d9%87%d9%85%d8%b2%d9%85%d8%a7%d9%86-%d8%a7%d8%b2-%da%86%d9%86%d8%af-%d9%be%d8%a7%d8%b1%d8%a7%d9%85%d8%aa%d8%b1-%d9%86%d9%88%d8%b9-multiple-type-parameters">#&lt;/a>
&lt;/h2>
&lt;p>گاهی لازم است تابع یا نوعی بنویسید که با چند نوع مختلف سر و کار دارد.&lt;/p>
&lt;h4 id="نمونه-سینتکس-2">
&lt;strong>نمونه سینتکس:&lt;/strong>
&lt;a class="anchor" href="#%d9%86%d9%85%d9%88%d9%86%d9%87-%d8%b3%db%8c%d9%86%d8%aa%da%a9%d8%b3-2">#&lt;/a>
&lt;/h4>
&lt;pre>&lt;code class="language-go">func CopyMap[K comparable, V any](m map[K]V) map[K]V {
newMap := make(map[K]V)
for k, v := range m {
newMap[k] = v
}
return newMap
}
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>اینجا K کلیدهایی است که باید قابل مقایسه باشند (&lt;code>comparable&lt;/code>)، و V می‌تواند هر نوعی باشد.&lt;/li>
&lt;/ul>
&lt;h4 id="مثال-struct-با-چند-پارامتر-نوع">
&lt;strong>مثال Struct با چند پارامتر نوع:&lt;/strong>
&lt;a class="anchor" href="#%d9%85%d8%ab%d8%a7%d9%84-struct-%d8%a8%d8%a7-%da%86%d9%86%d8%af-%d9%be%d8%a7%d8%b1%d8%a7%d9%85%d8%aa%d8%b1-%d9%86%d9%88%d8%b9">#&lt;/a>
&lt;/h4>
&lt;pre>&lt;code class="language-go">type Pair[A, B any] struct {
First A
Second B
}
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>
&lt;p>می‌توانید انواع مختلف را جفت کنید:&lt;/p>
&lt;pre>&lt;code class="language-go">p := Pair[int, string]{First: 1, Second: &amp;quot;Go&amp;quot;}
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;h2 id="۶۳۵-معرفی-و-کاربرد-generic-type-alias-جدید-در-go-124">
۶.۳.۵ معرفی و کاربرد Generic Type Alias (جدید در Go 1.24)
&lt;a class="anchor" href="#%db%b6%db%b3%db%b5-%d9%85%d8%b9%d8%b1%d9%81%db%8c-%d9%88-%da%a9%d8%a7%d8%b1%d8%a8%d8%b1%d8%af-generic-type-alias-%d8%ac%d8%af%db%8c%d8%af-%d8%af%d8%b1-go-124">#&lt;/a>
&lt;/h2>
&lt;p>در نسخه ۱.۲۴ Go، امکان تعریف &lt;strong>type alias&lt;/strong> برای انواع ژنریک اضافه شد که نقش بسیار مهمی در خوانایی، بازاستفاده و ماژولار کردن کد دارد.&lt;/p>
&lt;h4 id="۶۳۵۱-تفاوت-type-alias-معمولی-و-ژنریک">
&lt;strong>۶.۳.۵.۱ تفاوت Type Alias معمولی و ژنریک&lt;/strong>
&lt;a class="anchor" href="#%db%b6%db%b3%db%b5%db%b1-%d8%aa%d9%81%d8%a7%d9%88%d8%aa-type-alias-%d9%85%d8%b9%d9%85%d9%88%d9%84%db%8c-%d9%88-%da%98%d9%86%d8%b1%db%8c%da%a9">#&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>تا قبل از Go 1.24، فقط می‌توانستید برای انواع غیرژنریک alias تعریف کنید:&lt;/p>
&lt;pre>&lt;code class="language-go">type MyInt = int
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>از Go 1.24، می‌توانید برای انواع ژنریک هم alias بسازید:&lt;/p>
&lt;pre>&lt;code class="language-go">type Box[T any] struct{ Value T }
type IntBox = Box[int] // نوع IntBox معادل Box[int] است
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;h4 id="۶۳۵۲-کاربردهای-عملی-generic-type-alias">
&lt;strong>۶.۳.۵.۲ کاربردهای عملی Generic Type Alias&lt;/strong>
&lt;a class="anchor" href="#%db%b6%db%b3%db%b5%db%b2-%da%a9%d8%a7%d8%b1%d8%a8%d8%b1%d8%af%d9%87%d8%a7%db%8c-%d8%b9%d9%85%d9%84%db%8c-generic-type-alias">#&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>کاهش تکرار کد و ساده‌تر شدن refactoring&lt;/p>
&lt;/li>
&lt;li>
&lt;p>تعریف alias برای توابع ژنریک، constraintها، و حتی mapها و channelهای ژنریک:&lt;/p>
&lt;pre>&lt;code class="language-go">type StringMap[V any] = map[string]V
type UserChan = chan User
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>تمیز و خواناتر شدن APIها و لایه abstraction:&lt;/p>
&lt;pre>&lt;code class="language-go">type ConfigMap = map[string]string
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;h4 id="۶۳۵۳-بهترین-شیوههای-نامگذاری-و-ضدالگوها">
&lt;strong>۶.۳.۵.۳ بهترین شیوه‌های نام‌گذاری و ضدالگوها&lt;/strong>
&lt;a class="anchor" href="#%db%b6%db%b3%db%b5%db%b3-%d8%a8%d9%87%d8%aa%d8%b1%db%8c%d9%86-%d8%b4%db%8c%d9%88%d9%87%d9%87%d8%a7%db%8c-%d9%86%d8%a7%d9%85%da%af%d8%b0%d8%a7%d8%b1%db%8c-%d9%88-%d8%b6%d8%af%d8%a7%d9%84%da%af%d9%88%d9%87%d8%a7">#&lt;/a>
&lt;/h4>
&lt;p>نام‌های گویا و معنادار انتخاب کنید؛&lt;/p>
&lt;p>❌ بد:&lt;/p>
&lt;pre>&lt;code class="language-go"> type X = Box[int]
&lt;/code>&lt;/pre>
&lt;p>✅ خوب:&lt;/p>
&lt;pre>&lt;code class="language-go">type UserIDBox = Box[int]
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>از aliasهای تو در تو و بیش از حد بپرهیزید؛&lt;/li>
&lt;li>فقط برای کدهایی که واقعاً تکرار می‌شوند و نیاز به abstraction دارند استفاده کنید.&lt;/li>
&lt;/ul>
&lt;h2 id="۶۳۶-حذف-core-type-در-go-125-و-تأثیر-آن-بر-ژنریکها">
۶.۳.۶ حذف Core Type در Go 1.25 و تأثیر آن بر ژنریک‌ها
&lt;a class="anchor" href="#%db%b6%db%b3%db%b6-%d8%ad%d8%b0%d9%81-core-type-%d8%af%d8%b1-go-125-%d9%88-%d8%aa%d8%a3%d8%ab%db%8c%d8%b1-%d8%a2%d9%86-%d8%a8%d8%b1-%da%98%d9%86%d8%b1%db%8c%da%a9%d9%87%d8%a7">#&lt;/a>
&lt;/h2>
&lt;p>در نسخه‌های اولیه ژنریک Go، مفهومی به نام &lt;strong>core type&lt;/strong> وجود داشت که تعیین می‌کرد یک type parameter در زمان compile-time به چه underlying type‌ای ارجاع داده می‌شود. این مفهوم باعث پیچیدگی و محدودیت در برخی عملیات‌ها (مانند index، slice و &amp;hellip;) شده بود.&lt;/p>
&lt;p>&lt;strong>از Go 1.25 به بعد:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>core type&lt;/strong> از استاندارد حذف شد و قواعد هر عملیات به صورت واضح‌تر و مستقل بیان شد.&lt;/li>
&lt;li>خوانایی و سادگی زبان افزایش یافت و پیام‌های خطا شفاف‌تر شدند.&lt;/li>
&lt;li>حالا فقط کافی است برای عملیات مورد نظر constraint درست تعریف شود (مثلاً اگر با map کار می‌کنید باید &lt;code>comparable&lt;/code> باشد).&lt;/li>
&lt;/ul></description></item><item><author/><title>6.4 Constraints و Type Sets</title><link>https://book.gofarsi.ir/chapter-6/go-generics-type-sets-and-constraints/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-6/go-generics-type-sets-and-constraints/</guid><description>&lt;h2 id="۶۴۱-مفهوم-constraint-و-نقش-آن-در-ژنریکها">
۶.۴.۱ مفهوم constraint و نقش آن در ژنریک‌ها
&lt;a class="anchor" href="#%db%b6%db%b4%db%b1-%d9%85%d9%81%d9%87%d9%88%d9%85-constraint-%d9%88-%d9%86%d9%82%d8%b4-%d8%a2%d9%86-%d8%af%d8%b1-%da%98%d9%86%d8%b1%db%8c%da%a9%d9%87%d8%a7">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>Constraint&lt;/strong> (قید یا محدودیت) در ژنریک‌های Go ابزاری است برای کنترل اینکه یک پارامتر نوعی (type parameter) باید چه ویژگی‌هایی داشته باشد.&lt;br>
بدون constraint، هر نوعی می‌تواند جایگزین شود، اما با تعریف constraint، دایره‌ی مجاز را محدود می‌کنیم تا هم ایمنی نوعی بالا رود و هم امکانات بیشتری برای پیاده‌سازی داشته باشیم.&lt;/p>
&lt;h4 id="نقش-constraint">
&lt;strong>نقش constraint:&lt;/strong>
&lt;a class="anchor" href="#%d9%86%d9%82%d8%b4-constraint">#&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>جلوگیری از استفاده نادرست از ژنریک‌ها (مثلاً استفاده از عملیات غیرمجاز روی نوع پارامتری)&lt;/li>
&lt;li>افزایش قابلیت تشخیص خطا در زمان کامپایل&lt;/li>
&lt;li>امکان تعریف abstractionهای قوی‌تر&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>مثال ساده:&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-go">func Sum[T Number](a, b T) T { return a + b }
type Number interface { int | float64 }
&lt;/code>&lt;/pre>
&lt;p>در این مثال، فقط انواعی که در constraint Number تعریف شده‌اند، مجاز هستند.&lt;/p>
&lt;hr>
&lt;h2 id="۶۴۲-interface-constraint-و-مثالهای-کاربردی">
۶.۴.۲ interface constraint و مثال‌های کاربردی
&lt;a class="anchor" href="#%db%b6%db%b4%db%b2-interface-constraint-%d9%88-%d9%85%d8%ab%d8%a7%d9%84%d9%87%d8%a7%db%8c-%da%a9%d8%a7%d8%b1%d8%a8%d8%b1%d8%af%db%8c">#&lt;/a>
&lt;/h2>
&lt;p>در Go، constraint معمولاً به صورت یک interface بیان می‌شود؛ این interface می‌تواند شامل متدها یا ترکیبی از انواع (type sets) باشد.&lt;/p>
&lt;h4 id="مثال-constraint-مبتنی-بر-متد">
&lt;strong>مثال: constraint مبتنی بر متد&lt;/strong>
&lt;a class="anchor" href="#%d9%85%d8%ab%d8%a7%d9%84-constraint-%d9%85%d8%a8%d8%aa%d9%86%db%8c-%d8%a8%d8%b1-%d9%85%d8%aa%d8%af">#&lt;/a>
&lt;/h4>
&lt;pre>&lt;code class="language-go">type Stringer interface {
String() string
}
func PrintString[T Stringer](v T) {
fmt.Println(v.String())
}
&lt;/code>&lt;/pre>
&lt;p>هر نوعی که متد &lt;code>String() string&lt;/code> را داشته باشد (مثلاً time.Time یا type خودتان)، می‌تواند برای این تابع استفاده شود.&lt;/p>
&lt;h4 id="مثال-constraint-مبتنی-بر-type-set-union">
&lt;strong>مثال: constraint مبتنی بر type set (union)&lt;/strong>
&lt;a class="anchor" href="#%d9%85%d8%ab%d8%a7%d9%84-constraint-%d9%85%d8%a8%d8%aa%d9%86%db%8c-%d8%a8%d8%b1-type-set-union">#&lt;/a>
&lt;/h4>
&lt;pre>&lt;code class="language-go">type Numeric interface { int | int64 | float64 }
func Max[T Numeric](a, b T) T {
if a &amp;gt; b {
return a
}
return b
}
&lt;/code>&lt;/pre>
&lt;p>فقط انواع عددی مجاز به استفاده از Max هستند.&lt;/p>
&lt;h4 id="مثال-ترکیبی">
&lt;strong>مثال: ترکیبی&lt;/strong>
&lt;a class="anchor" href="#%d9%85%d8%ab%d8%a7%d9%84-%d8%aa%d8%b1%da%a9%db%8c%d8%a8%db%8c">#&lt;/a>
&lt;/h4>
&lt;pre>&lt;code class="language-go">type ByteString interface {
~[]byte | ~string
}
func FirstChar[T ByteString](s T) byte {
return s[0]
}
&lt;/code>&lt;/pre>
&lt;p>هر نوعی که underlying آن &lt;code>[]byte&lt;/code> یا &lt;code>string&lt;/code> باشد، مجاز است.&lt;/p>
&lt;hr>
&lt;h2 id="۶۴۳-استفاده-از-کلیدواژههای-any-comparable-و-ordered">
۶.۴.۳ استفاده از کلیدواژه‌های any، comparable و Ordered
&lt;a class="anchor" href="#%db%b6%db%b4%db%b3-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-%da%a9%d9%84%db%8c%d8%af%d9%88%d8%a7%da%98%d9%87%d9%87%d8%a7%db%8c-any-comparable-%d9%88-ordered">#&lt;/a>
&lt;/h2>
&lt;p>Go چندین constraint از پیش تعریف‌شده دارد:&lt;/p>
&lt;h4 id="any">
&lt;strong>any&lt;/strong>
&lt;a class="anchor" href="#any">#&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>معادل interface{}، یعنی هیچ محدودیتی وجود ندارد:&lt;/p>
&lt;pre>&lt;code class="language-go">func Identity[T any](v T) T { return v }
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;h4 id="comparable">
&lt;strong>comparable&lt;/strong>
&lt;a class="anchor" href="#comparable">#&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>فقط نوع‌هایی که می‌توان با == یا != مقایسه کرد (برای map key یا مجموعه‌ها):&lt;/p>
&lt;pre>&lt;code class="language-go">func Contains[T comparable](slice []T, v T) bool {
for _, item := range slice {
if item == v {
return true
}
}
return false
}
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;h4 id="ordered-از-پکیج-cmp-go-121">
&lt;strong>Ordered&lt;/strong> (از پکیج cmp، Go 1.21+)
&lt;a class="anchor" href="#ordered-%d8%a7%d8%b2-%d9%be%da%a9%db%8c%d8%ac-cmp-go-121">#&lt;/a>
&lt;/h4>
&lt;p>برای انواعی که می‌توان از &amp;lt;, &amp;gt;, &amp;lt;=, &amp;gt;= استفاده کرد (int, float, string):&lt;/p>
&lt;pre>&lt;code class="language-go"> import &amp;quot;cmp&amp;quot;
func Min[T cmp.Ordered](a, b T) T {
if a &amp;lt; b {
return a
}
return b
}
&lt;/code>&lt;/pre>
&lt;h2 id="۶۴۴-ساخت-constraint-سفارشی-و-ترکیبی-union-constraints">
۶.۴.۴ ساخت constraint سفارشی و ترکیبی (union constraints)
&lt;a class="anchor" href="#%db%b6%db%b4%db%b4-%d8%b3%d8%a7%d8%ae%d8%aa-constraint-%d8%b3%d9%81%d8%a7%d8%b1%d8%b4%db%8c-%d9%88-%d8%aa%d8%b1%da%a9%db%8c%d8%a8%db%8c-union-constraints">#&lt;/a>
&lt;/h2>
&lt;p>شما می‌توانید constraint دلخواه بسازید و انواع مختلف را در یک مجموعه (type set) قرار دهید:&lt;/p>
&lt;h4 id="مثال">
&lt;strong>مثال:&lt;/strong>
&lt;a class="anchor" href="#%d9%85%d8%ab%d8%a7%d9%84">#&lt;/a>
&lt;/h4>
&lt;pre>&lt;code class="language-go">type IDType interface {
int | int64 | string
}
func ParseID[T IDType](v T) string {
return fmt.Sprintf(&amp;quot;%v&amp;quot;, v)
}
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>
&lt;p>می‌توانید متد هم به آن اضافه کنید:&lt;/p>
&lt;pre>&lt;code class="language-go">type ToStringer interface {
~string | ~[]byte
ToString() string
}
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;h4 id="نکته-مهم">
&lt;strong>نکته مهم:&lt;/strong>
&lt;a class="anchor" href="#%d9%86%da%a9%d8%aa%d9%87-%d9%85%d9%87%d9%85">#&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>علامت &lt;code>~&lt;/code> در Go به این معنی است که نوع مورد نظر باید &lt;strong>underlying type&lt;/strong> مشخص‌شده را داشته باشد (مثلاً نوع تعریف‌شده‌ای که underlying آن string باشد).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>در Go 1.24 به بعد می‌توانید حتی &lt;strong>constraint alias&lt;/strong> تعریف کنید:&lt;/p>
&lt;pre>&lt;code class="language-go">type Num = interface{ int | float64 }
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;h2 id="۶۴۵-generic-interfaces-و-قابلیتهای-جدید-بر-اساس-go-121-و-124">
۶.۴.۵ Generic Interfaces و قابلیت‌های جدید (بر اساس Go 1.21+ و 1.24)
&lt;a class="anchor" href="#%db%b6%db%b4%db%b5-generic-interfaces-%d9%88-%d9%82%d8%a7%d8%a8%d9%84%db%8c%d8%aa%d9%87%d8%a7%db%8c-%d8%ac%d8%af%db%8c%d8%af-%d8%a8%d8%b1-%d8%a7%d8%b3%d8%a7%d8%b3-go-121-%d9%88-124">#&lt;/a>
&lt;/h2>
&lt;p>ژنتریک اینترفیس‌ها (Generic Interfaces) از Go 1.18 امکان‌پذیر شد و در نسخه‌های جدید، قابلیت‌های قوی‌تری یافته است.&lt;/p>
&lt;h3 id="۶۴۵۱-پیادهسازی-الگوهای-abstraction-با-interface-ژنریک">
&lt;strong>۶.۴.۵.۱ پیاده‌سازی الگوهای abstraction با interface ژنریک&lt;/strong>
&lt;a class="anchor" href="#%db%b6%db%b4%db%b5%db%b1-%d9%be%db%8c%d8%a7%d8%af%d9%87%d8%b3%d8%a7%d8%b2%db%8c-%d8%a7%d9%84%da%af%d9%88%d9%87%d8%a7%db%8c-abstraction-%d8%a8%d8%a7-interface-%da%98%d9%86%d8%b1%db%8c%da%a9">#&lt;/a>
&lt;/h3>
&lt;p>می‌توانید abstractionهایی بسازید که به طور کلی روی انواع مختلف اعمال شوند:&lt;/p>
&lt;pre>&lt;code class="language-go">type Comparer[T any] interface {
Compare(T) int
}
type Sortable[T Comparer[T]] []T
func (s Sortable[T]) Sort() {
sort.Slice(s, func(i, j int) bool {
return s[i].Compare(s[j]) &amp;lt; 0
})
}
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>هر نوعی که متد &lt;code>Compare(T) int&lt;/code> را داشته باشد، قابل استفاده است.&lt;/li>
&lt;li>این قابلیت قدرت abstraction و توسعه کتابخانه‌های عمومی را به شدت افزایش داده است.&lt;/li>
&lt;/ul>
&lt;h3 id="۶۴۵۲-نکات-و-چالشهای-پیشرفته-مثلا-مسأله-pointer-receivers-و-type-inference">
&lt;strong>۶.۴.۵.۲ نکات و چالش‌های پیشرفته (مثلاً مسأله pointer receivers و type inference)&lt;/strong>
&lt;a class="anchor" href="#%db%b6%db%b4%db%b5%db%b2-%d9%86%da%a9%d8%a7%d8%aa-%d9%88-%da%86%d8%a7%d9%84%d8%b4%d9%87%d8%a7%db%8c-%d9%be%db%8c%d8%b4%d8%b1%d9%81%d8%aa%d9%87-%d9%85%d8%ab%d9%84%d8%a7-%d9%85%d8%b3%d8%a3%d9%84%d9%87-pointer-receivers-%d9%88-type-inference">#&lt;/a>
&lt;/h3>
&lt;p>&lt;strong>الف) pointer receivers:&lt;/strong>&lt;/p>
&lt;p>گاهی constraint روی اینترفیس باید به نوع pointer باشد تا متدهای دریافت‌کننده (receiver) به درستی کار کند.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>اگر متدها روی pointer تعریف شده باشند، باید pointer به عنوان نوع پارامتر بدهید:&lt;/p>
&lt;pre>&lt;code class="language-go">type Setter[T any] interface {
Set(T)
}
func Update[T any, S Setter[T]](s S, v T) { s.Set(v) }
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>ب) type inference در چند پارامتر:&lt;/strong>&lt;/p>
&lt;p>در برخی موارد که چندین type parameter وجود دارد (مثلاً برای abstractionهای پیچیده یا ترکیب چند constraint)، ممکن است inference نوع پیچیده شود و لازم باشد type parameters را به صراحت مشخص کنید.&lt;/p>
&lt;p>&lt;strong>ج) مقایسه با زبان‌های دیگر:&lt;/strong>&lt;/p>
&lt;p>در Go سعی شده تا حد امکان inference ساده و شفاف باشد، اما در abstractionهای خیلی پیچیده (مانند ژنریک تو در تو، pointer receivers یا interface embedding) ممکن است خوانایی امضاها (signature) کمی سخت شود، به خصوص برای توسعه‌دهندگان تازه‌کار.&lt;/p>
&lt;p>&lt;strong>د) نکته تولیدی:&lt;/strong>&lt;/p>
&lt;p>تا حد امکان constraintها را ساده، گویا و خوانا نگه دارید. constraintهای ترکیبی و abstractionهای ژنریک را فقط زمانی به کار ببرید که واقعاً نیاز است و مستندسازی کافی داشته باشید.&lt;/p>
&lt;h2 id="۶۴۶-بررسی-عمیق-constraints-در-go">
۶.۴.۶ بررسی عمیق constraints در Go
&lt;a class="anchor" href="#%db%b6%db%b4%db%b6-%d8%a8%d8%b1%d8%b1%d8%b3%db%8c-%d8%b9%d9%85%db%8c%d9%82-constraints-%d8%af%d8%b1-go">#&lt;/a>
&lt;/h2>
&lt;p>در Go، هرچقدر آزادی در انتخاب نوع پارامتر بیشتر شود، قدرت استفاده از آن کمتر خواهد بود. بنابراین، از محدودیت‌های دقیق برای &lt;strong>افزایش قابلیت‌های ژنریک‌ها&lt;/strong> استفاده می‌کنیم. در واقع، به جای &lt;code>[T any]&lt;/code>، باید constraint مناسب انتخاب شود که کامپایلر بداند چه عملیاتی روی &lt;code>T&lt;/code> مجاز است.&lt;/p>
&lt;blockquote>
&lt;p>قاعده کلی: هرچه interface یا constraint بزرگ‌تر باشد، abstraction ضعیف‌تر است.&lt;/p>&lt;/blockquote>
&lt;h3 id="-چرا-t-any-محدودیت-دارد">
✅ چرا &lt;code>[T any]&lt;/code> محدودیت دارد؟
&lt;a class="anchor" href="#-%da%86%d8%b1%d8%a7-t-any-%d9%85%d8%ad%d8%af%d9%88%d8%af%db%8c%d8%aa-%d8%af%d8%a7%d8%b1%d8%af">#&lt;/a>
&lt;/h3>
&lt;p>با تعریف تابع ساده مثل:&lt;/p>
&lt;pre>&lt;code class="language-go">func Add[T any](a, b T) T {
return a + b
}
&lt;/code>&lt;/pre>
&lt;p>کامپایلر Go خطا می‌دهد چون از &lt;code>T any&lt;/code> نمی‌داند آیا &lt;code>T&lt;/code> قابلیت عملگر &lt;code>+&lt;/code> را دارد یا خیر. بنابراین نمی‌تواند کدی را که معتبر باشد تولید کند. این نشان می‌دهد که آزادی بیش از حد باعث حذف قابلیت‌های مهم می‌شود.&lt;/p>
&lt;h3 id="انواع-constraint-در-go">
انواع constraint در Go
&lt;a class="anchor" href="#%d8%a7%d9%86%d9%88%d8%a7%d8%b9-constraint-%d8%af%d8%b1-go">#&lt;/a>
&lt;/h3>
&lt;h4 id="۱-basic-interface-constraint-محدودیت-بر-پایه-متد">
۱. &lt;strong>Basic Interface Constraint&lt;/strong> (محدودیت بر پایه متد)
&lt;a class="anchor" href="#%db%b1-basic-interface-constraint-%d9%85%d8%ad%d8%af%d9%88%d8%af%db%8c%d8%aa-%d8%a8%d8%b1-%d9%be%d8%a7%db%8c%d9%87-%d9%85%d8%aa%d8%af">#&lt;/a>
&lt;/h4>
&lt;p>این نوع constraint شامل متدهایی است که باید توسط نوع پیاده‌سازی شود.&lt;/p>
&lt;p>مثال:&lt;/p>
&lt;pre>&lt;code class="language-go">func Stringify[T fmt.Stringer](v T) string {
return v.String()
}
&lt;/code>&lt;/pre>
&lt;p>اینجا کامپایلر می‌داند که &lt;code>v&lt;/code> متدی به نام &lt;code>String()&lt;/code> دارد، بنابراین می‌تواند آن را بدون خطا اجرا کند.&lt;/p>
&lt;h4 id="۲-type-set-constraint-محدودیت-لیستی-برای-عملگرها">
۲. &lt;strong>Type Set Constraint&lt;/strong> (محدودیت لیستی برای عملگرها)
&lt;a class="anchor" href="#%db%b2-type-set-constraint-%d9%85%d8%ad%d8%af%d9%88%d8%af%db%8c%d8%aa-%d9%84%db%8c%d8%b3%d8%aa%db%8c-%d8%a8%d8%b1%d8%a7%db%8c-%d8%b9%d9%85%d9%84%da%af%d8%b1%d9%87%d8%a7">#&lt;/a>
&lt;/h4>
&lt;p>برای استفاده از عملگرهایی مثل &lt;code>+&lt;/code>، باید &lt;code>T&lt;/code> را محدود کنیم تا مجموعه‌ای از انواع مشخص باشد:&lt;/p>
&lt;pre>&lt;code class="language-go">type Numeric interface { int | int64 | float64 }
func Add[T Numeric](a, b T) T {
return a + b
}
&lt;/code>&lt;/pre>
&lt;p>اکنون کامپایلر تضمین می‌دهد که &lt;code>T&lt;/code> حتماً یکی از انواع عددی است و عمل &lt;code>+&lt;/code> معتبر خواهد بود.&lt;/p>
&lt;p>همچنین برای اجازه استفاده از &lt;code>~&lt;/code> برای پذیرش زیرنوع‌ها:&lt;/p>
&lt;pre>&lt;code class="language-go">type Intish interface { ~int }
&lt;/code>&lt;/pre>
&lt;h4 id="۳-ترکیب-محدودیتها">
۳. &lt;strong>ترکیب محدودیت‌ها&lt;/strong>
&lt;a class="anchor" href="#%db%b3-%d8%aa%d8%b1%da%a9%db%8c%d8%a8-%d9%85%d8%ad%d8%af%d9%88%d8%af%db%8c%d8%aa%d9%87%d8%a7">#&lt;/a>
&lt;/h4>
&lt;p>می‌توان constraintهایی ساخت که چند محدودیت را همزمان اعمال کنند، مثلاً متد و عملگر:&lt;/p>
&lt;pre>&lt;code class="language-go">type ReadStringer interface {
fmt.Stringer
io.Reader
~[]byte | ~string
}
&lt;/code>&lt;/pre>
&lt;p>این محدودیت بیان می‌کند که &lt;code>T&lt;/code> باید هم &lt;code>String()&lt;/code> داشته باشد، هم &lt;code>Read()&lt;/code> اجرا کند، و نوع underlying آن &lt;code>[]byte&lt;/code> یا &lt;code>string&lt;/code> باشد.&lt;/p>
&lt;h3 id="-اهمیت-و-پیامدها">
🔑 اهمیت و پیامدها
&lt;a class="anchor" href="#-%d8%a7%d9%87%d9%85%db%8c%d8%aa-%d9%88-%d9%be%db%8c%d8%a7%d9%85%d8%af%d9%87%d8%a7">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>خوانایی و اطمینان بالا:&lt;/strong>&lt;br>
با محدود کردن دقیق &lt;code>T&lt;/code> تنها به انواعی که عملیات مورد نظر را دارند، از بروز خطا جلوگیری می‌کنید.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>کارایی بدون overhead:&lt;/strong>&lt;br>
چون کامپایلر می‌داند دقیقاً چه عملیاتی مجاز است، نیازی به reflect یا بررسی در runtime نیست.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>ارتقاء abstraction:&lt;/strong>&lt;br>
تعریف سلسله‌مراتبی از constraintها مانند &lt;code>Numeric&lt;/code>, &lt;code>Ordered&lt;/code>، یا &lt;code>ReadStringer&lt;/code> امکان reuse و خوانایی بالاتر کد را فراهم می‌کند.&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><author/><title>6.5 مثال‌ها و کاربردهای عملی ژنریک‌ها</title><link>https://book.gofarsi.ir/chapter-6/go-generics-examples-and-practical/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-6/go-generics-examples-and-practical/</guid><description>&lt;h2 id="۶۵۱-توابع-ژنریک-متداول-مانند-min-max-map-filter">
۶.۵.۱ توابع ژنریک متداول (مانند Min, Max, Map, Filter)
&lt;a class="anchor" href="#%db%b6%db%b5%db%b1-%d8%aa%d9%88%d8%a7%d8%a8%d8%b9-%da%98%d9%86%d8%b1%db%8c%da%a9-%d9%85%d8%aa%d8%af%d8%a7%d9%88%d9%84-%d9%85%d8%a7%d9%86%d9%86%d8%af-min-max-map-filter">#&lt;/a>
&lt;/h2>
&lt;h4 id="تابع-min-و-max">
تابع Min و Max
&lt;a class="anchor" href="#%d8%aa%d8%a7%d8%a8%d8%b9-min-%d9%88-max">#&lt;/a>
&lt;/h4>
&lt;pre>&lt;code class="language-go">import &amp;quot;cmp&amp;quot; // از Go 1.21+
func Min[T cmp.Ordered](a, b T) T {
if a &amp;lt; b {
return a
}
return b
}
func Max[T cmp.Ordered](a, b T) T {
if a &amp;gt; b {
return a
}
return b
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>توضیح:&lt;/strong>&lt;br>
این دو تابع ژنریک به شما اجازه می‌دهند با هر نوع داده‌ای که قابل مقایسه با عملگرهای بزرگ‌تر/کوچک‌تر باشد (مثل int، float64، string و&amp;hellip;) بیشینه یا کمینه دو مقدار را به دست آورید. پارامتر نوعی &lt;code>T&lt;/code> باید قید &lt;code>cmp.Ordered&lt;/code> را داشته باشد تا عملیات مقایسه مجاز باشد. این ساختار به جای نوشتن نسخه‌های تکراری برای هر نوع داده، یک تابع عمومی و امن ایجاد می‌کند.&lt;/p>
&lt;h4 id="تابع-map-اعمال-تابع-روی-عناصر-یک-لیست">
تابع Map (اعمال تابع روی عناصر یک لیست)
&lt;a class="anchor" href="#%d8%aa%d8%a7%d8%a8%d8%b9-map-%d8%a7%d8%b9%d9%85%d8%a7%d9%84-%d8%aa%d8%a7%d8%a8%d8%b9-%d8%b1%d9%88%db%8c-%d8%b9%d9%86%d8%a7%d8%b5%d8%b1-%db%8c%da%a9-%d9%84%db%8c%d8%b3%d8%aa">#&lt;/a>
&lt;/h4>
&lt;pre>&lt;code class="language-go">func Map[T any, R any](input []T, fn func(T) R) []R {
result := make([]R, len(input))
for i, v := range input {
result[i] = fn(v)
}
return result
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>توضیح:&lt;/strong>&lt;br>
این تابع یک لیست (&lt;code>input&lt;/code>) را می‌گیرد و یک تابع (&lt;code>fn&lt;/code>) را روی هر عنصر آن اجرا می‌کند و خروجی‌های تابع را به عنوان لیست جدید بازمی‌گرداند. نوع ورودی (&lt;code>T&lt;/code>) و خروجی (&lt;code>R&lt;/code>) کاملاً ژنریک هستند و می‌توانید هر تبدیل یا پردازشی را با این الگو روی لیست‌های خود انجام دهید، مثلاً مربع اعداد، تبدیل عدد به رشته و غیره.&lt;/p>
&lt;h4 id="تابع-filter-فیلتر-کردن-عناصر-یک-لیست">
تابع Filter (فیلتر کردن عناصر یک لیست)
&lt;a class="anchor" href="#%d8%aa%d8%a7%d8%a8%d8%b9-filter-%d9%81%db%8c%d9%84%d8%aa%d8%b1-%da%a9%d8%b1%d8%af%d9%86-%d8%b9%d9%86%d8%a7%d8%b5%d8%b1-%db%8c%da%a9-%d9%84%db%8c%d8%b3%d8%aa">#&lt;/a>
&lt;/h4>
&lt;pre>&lt;code class="language-go">func Filter[T any](input []T, pred func(T) bool) []T {
var result []T
for _, v := range input {
if pred(v) {
result = append(result, v)
}
}
return result
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>توضیح:&lt;/strong>&lt;br>
تابع Filter یک لیست و یک تابع شرطی (predicate) می‌گیرد و تنها عناصر لیست را که شرط روی آن‌ها برقرار است، انتخاب و در یک لیست جدید بازمی‌گرداند. این کار باعث می‌شود بدون تکرار کد برای هر نوع داده، فیلترهای قدرتمند و ایمن داشته باشید (مثلاً استخراج فقط اعداد زوج یا رشته‌هایی با طول خاص).&lt;/p>
&lt;h2 id="۶۵۲-ساختارهای-داده-ژنریک-stack-queue-list-و-">
۶.۵.۲ ساختارهای داده ژنریک (Stack، Queue، List و &amp;hellip;)
&lt;a class="anchor" href="#%db%b6%db%b5%db%b2-%d8%b3%d8%a7%d8%ae%d8%aa%d8%a7%d8%b1%d9%87%d8%a7%db%8c-%d8%af%d8%a7%d8%af%d9%87-%da%98%d9%86%d8%b1%db%8c%da%a9-stack-queue-list-%d9%88-">#&lt;/a>
&lt;/h2>
&lt;h4 id="stack-ژنریک">
Stack ژنریک
&lt;a class="anchor" href="#stack-%da%98%d9%86%d8%b1%db%8c%da%a9">#&lt;/a>
&lt;/h4>
&lt;pre>&lt;code class="language-go">type Stack[T any] struct {
data []T
}
func (s *Stack[T]) Push(val T) {
s.data = append(s.data, val)
}
func (s *Stack[T]) Pop() (T, bool) {
if len(s.data) == 0 {
var zero T
return zero, false
}
last := len(s.data) - 1
val := s.data[last]
s.data = s.data[:last]
return val, true
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>توضیح:&lt;/strong>&lt;br>
این کد یک ساختار داده پشته (Stack) را به صورت ژنریک پیاده‌سازی می‌کند؛ یعنی می‌توانید هر نوع داده‌ای را در پشته ذخیره کنید. متد &lt;code>Push&lt;/code> یک مقدار جدید به انتهای پشته اضافه می‌کند و &lt;code>Pop&lt;/code> مقدار آخر را حذف و بازمی‌گرداند. اگر پشته خالی باشد، مقدار صفر نوع داده (zero value) برگردانده می‌شود. این پیاده‌سازی قابلیت استفاده برای int، string یا حتی structهای پیچیده را دارد.&lt;/p>
&lt;h4 id="queue-ژنریک">
Queue ژنریک
&lt;a class="anchor" href="#queue-%da%98%d9%86%d8%b1%db%8c%da%a9">#&lt;/a>
&lt;/h4>
&lt;pre>&lt;code class="language-go">type Queue[T any] struct {
data []T
}
func (q *Queue[T]) Enqueue(val T) {
q.data = append(q.data, val)
}
func (q *Queue[T]) Dequeue() (T, bool) {
if len(q.data) == 0 {
var zero T
return zero, false
}
val := q.data[0]
q.data = q.data[1:]
return val, true
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>توضیح:&lt;/strong>&lt;br>
کد بالا یک صف (Queue) ژنریک را پیاده‌سازی می‌کند که برای هر نوع داده‌ای قابل استفاده است. متد &lt;code>Enqueue&lt;/code> عنصر جدیدی را به انتهای صف اضافه می‌کند و &lt;code>Dequeue&lt;/code> عنصر ابتدای صف را حذف و بازمی‌گرداند. اگر صف خالی باشد، مقدار صفر نوع داده برگردانده می‌شود. این الگو برای مدیریت صف درخواست‌ها یا پیام‌ها با هر نوع داده‌ای بسیار کاربردی است.&lt;/p>
&lt;h4 id="list-ژنریک">
List ژنریک
&lt;a class="anchor" href="#list-%da%98%d9%86%d8%b1%db%8c%da%a9">#&lt;/a>
&lt;/h4>
&lt;pre>&lt;code class="language-go">type List[T any] struct {
items []T
}
func (l *List[T]) Add(val T) {
l.items = append(l.items, val)
}
func (l *List[T]) Get(index int) (T, bool) {
if index &amp;lt; 0 || index &amp;gt;= len(l.items) {
var zero T
return zero, false
}
return l.items[index], true
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>توضیح:&lt;/strong>&lt;br>
این ساختار یک لیست ساده ژنریک است که می‌توانید هر نوع داده‌ای را به آن اضافه یا با اندیس بازیابی کنید. متد &lt;code>Add&lt;/code> برای افزودن و &lt;code>Get&lt;/code> برای دریافت مقدار در اندیس دلخواه (همراه با بررسی بازه ایمن) استفاده می‌شود. این ساختار می‌تواند پایه ساخت کلکسیون‌ها و آرایه‌های سفارشی در پروژه‌های بزرگ‌تر باشد.&lt;/p>
&lt;h2 id="۶۵۳-ترکیب-ژنریک-با-سایر-ویژگیهای-go-کانالها-مپها-و-اینترفیسها">
۶.۵.۳ ترکیب ژنریک با سایر ویژگی‌های Go (کانال‌ها، مپ‌ها و اینترفیس‌ها)
&lt;a class="anchor" href="#%db%b6%db%b5%db%b3-%d8%aa%d8%b1%da%a9%db%8c%d8%a8-%da%98%d9%86%d8%b1%db%8c%da%a9-%d8%a8%d8%a7-%d8%b3%d8%a7%db%8c%d8%b1-%d9%88%db%8c%da%98%da%af%db%8c%d9%87%d8%a7%db%8c-go-%da%a9%d8%a7%d9%86%d8%a7%d9%84%d9%87%d8%a7-%d9%85%d9%be%d9%87%d8%a7-%d9%88-%d8%a7%db%8c%d9%86%d8%aa%d8%b1%d9%81%db%8c%d8%b3%d9%87%d8%a7">#&lt;/a>
&lt;/h2>
&lt;h4 id="channel-ژنریک">
Channel ژنریک
&lt;a class="anchor" href="#channel-%da%98%d9%86%d8%b1%db%8c%da%a9">#&lt;/a>
&lt;/h4>
&lt;pre>&lt;code class="language-go">type Chan[T any] chan T
func Producer[T any](out Chan[T], vals ...T) {
for _, v := range vals {
out &amp;lt;- v
}
close(out)
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>توضیح:&lt;/strong>&lt;br>
در این مثال، نوع کانال (Channel) به صورت ژنریک تعریف شده است، یعنی می‌توانید کانال ارسال/دریافت داده برای هر نوعی بسازید. تابع &lt;code>Producer&lt;/code> داده‌های ورودی را به کانال می‌فرستد و در پایان آن را می‌بندد. این الگو برای پردازش موازی و همزمان داده‌ها در معماری‌های concurrent و pipeline بسیار مناسب است.&lt;/p>
&lt;h4 id="map-ژنریک-با-constraint">
Map ژنریک با constraint
&lt;a class="anchor" href="#map-%da%98%d9%86%d8%b1%db%8c%da%a9-%d8%a8%d8%a7-constraint">#&lt;/a>
&lt;/h4>
&lt;pre>&lt;code class="language-go">func Keys[K comparable, V any](m map[K]V) []K {
keys := make([]K, 0, len(m))
for k := range m {
keys = append(keys, k)
}
return keys
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>توضیح:&lt;/strong>&lt;br>
تابع Keys یک map را می‌گیرد و لیستی از کلیدهای آن را بازمی‌گرداند. نوع کلید باید قابل مقایسه باشد (comparable)، چون mapهای Go فقط با کلیدهای قابل مقایسه کار می‌کنند. این تابع برای استخراج سریع و type-safe کلیدهای هر map بسیار مفید است.&lt;/p>
&lt;h4 id="اینترفیس-ژنریک-و-abstraction">
اینترفیس ژنریک و abstraction
&lt;a class="anchor" href="#%d8%a7%db%8c%d9%86%d8%aa%d8%b1%d9%81%db%8c%d8%b3-%da%98%d9%86%d8%b1%db%8c%da%a9-%d9%88-abstraction">#&lt;/a>
&lt;/h4>
&lt;pre>&lt;code class="language-go">type Repository[T any] interface {
FindByID(id int) (T, error)
Save(entity T) error
}
type User struct{ Name string }
type UserRepo struct{ data map[int]User }
func (r *UserRepo) FindByID(id int) (User, error) {
u, ok := r.data[id]
if !ok {
return User{}, errors.New(&amp;quot;not found&amp;quot;)
}
return u, nil
}
func (r *UserRepo) Save(entity User) error {
r.data[len(r.data)] = entity
return nil
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>توضیح:&lt;/strong>&lt;br>
در این مثال، یک اینترفیس ژنریک برای مخزن داده (Repository) تعریف شده است که می‌تواند برای هر نوع داده (مثلاً User) پیاده‌سازی شود. متدهای &lt;code>FindByID&lt;/code> و &lt;code>Save&lt;/code> عملیات بازیابی و ذخیره را type-safe انجام می‌دهند. این الگو پایه معماری clean و قابل توسعه برای لایه داده در پروژه‌های تولیدی است.&lt;/p>
&lt;h2 id="۶۵۴-نمونههای-تولیدی-و-پروژهای-از-کدهای-واقعی-و-کاربردی">
۶.۵.۴ نمونه‌های تولیدی و پروژه‌ای (از کدهای واقعی و کاربردی)
&lt;a class="anchor" href="#%db%b6%db%b5%db%b4-%d9%86%d9%85%d9%88%d9%86%d9%87%d9%87%d8%a7%db%8c-%d8%aa%d9%88%d9%84%db%8c%d8%af%db%8c-%d9%88-%d9%be%d8%b1%d9%88%da%98%d9%87%d8%a7%db%8c-%d8%a7%d8%b2-%da%a9%d8%af%d9%87%d8%a7%db%8c-%d9%88%d8%a7%d9%82%d8%b9%db%8c-%d9%88-%da%a9%d8%a7%d8%b1%d8%a8%d8%b1%d8%af%db%8c">#&lt;/a>
&lt;/h2>
&lt;h4 id="سرویس-کش-ژنریک">
سرویس کش ژنریک
&lt;a class="anchor" href="#%d8%b3%d8%b1%d9%88%db%8c%d8%b3-%da%a9%d8%b4-%da%98%d9%86%d8%b1%db%8c%da%a9">#&lt;/a>
&lt;/h4>
&lt;pre>&lt;code class="language-go">type Cache[K comparable, V any] struct {
data map[K]V
}
func NewCache[K comparable, V any]() *Cache[K, V] {
return &amp;amp;Cache[K, V]{data: make(map[K]V)}
}
func (c *Cache[K, V]) Set(key K, value V) {
c.data[key] = value
}
func (c *Cache[K, V]) Get(key K) (V, bool) {
v, ok := c.data[key]
return v, ok
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>توضیح:&lt;/strong>&lt;br>
در اینجا یک سرویس کش (Cache) به صورت ژنریک پیاده‌سازی شده که برای هر نوع کلید (comparable) و هر نوع مقدار قابل استفاده است. با استفاده از این ساختار می‌توانید بدون تکرار کد برای انواع مختلف داده، کش‌های بهینه و امن بسازید که در پروژه‌های واقعی (مثلاً کش کاربر، تنظیمات یا داده‌های session) بسیار کاربردی است.&lt;/p>
&lt;h4 id="pipeline-ژنریک-برای-پردازش-دادهها">
Pipeline ژنریک برای پردازش داده‌ها
&lt;a class="anchor" href="#pipeline-%da%98%d9%86%d8%b1%db%8c%da%a9-%d8%a8%d8%b1%d8%a7%db%8c-%d9%be%d8%b1%d8%af%d8%a7%d8%b2%d8%b4-%d8%af%d8%a7%d8%af%d9%87%d9%87%d8%a7">#&lt;/a>
&lt;/h4>
&lt;pre>&lt;code class="language-go">func Pipeline[T any](data []T, stages ...func([]T) []T) []T {
for _, stage := range stages {
data = stage(data)
}
return data
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>توضیح:&lt;/strong>&lt;br>
تابع Pipeline به شما امکان می‌دهد زنجیره‌ای از مراحل پردازش (stages) را روی لیست داده اجرا کنید. هر مرحله یک تابع است که لیست را می‌گیرد و خروجی پردازش را بازمی‌گرداند. این الگو برای پردازش داده‌های بزرگ، تحلیل داده یا پیاده‌سازی الگوهای data pipeline در سیستم‌های تولیدی بسیار ارزشمند است.&lt;/p></description></item><item><author/><title>6.6 مقایسه ژنریک‌ها با راهکارهای قبل از Go 1.18</title><link>https://book.gofarsi.ir/chapter-6/comparing-generics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-6/comparing-generics/</guid><description>&lt;h2 id="۶۶۱-استفاده-از-interface-و-reflect-قبل-از-ژنریکها">
۶.۶.۱ استفاده از interface{} و reflect قبل از ژنریک‌ها
&lt;a class="anchor" href="#%db%b6%db%b6%db%b1-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-interface-%d9%88-reflect-%d9%82%d8%a8%d9%84-%d8%a7%d8%b2-%da%98%d9%86%d8%b1%db%8c%da%a9%d9%87%d8%a7">#&lt;/a>
&lt;/h2>
&lt;p>پیش از Go 1.18، برای پیاده‌سازی توابع یا ساختارهای داده عمومی، معمولاً از نوع &lt;strong>interface{}&lt;/strong> (نوع همه‌کاره) استفاده می‌شد.&lt;br>
در موارد نیاز به عملیات خاص یا تبدیل نوع، ناچار به استفاده از &lt;strong>reflect&lt;/strong> یا type assertion بودیم. این روش‌ها معایب و ریسک‌های خاص خود را داشتند.&lt;/p>
&lt;h4 id="مثال-تابع-max-با-interface-و-reflect">
&lt;strong>مثال: تابع Max با interface{} و reflect&lt;/strong>
&lt;a class="anchor" href="#%d9%85%d8%ab%d8%a7%d9%84-%d8%aa%d8%a7%d8%a8%d8%b9-max-%d8%a8%d8%a7-interface-%d9%88-reflect">#&lt;/a>
&lt;/h4>
&lt;pre>&lt;code class="language-go">import (
&amp;quot;fmt&amp;quot;
&amp;quot;reflect&amp;quot;
)
func Max(a, b interface{}) interface{} {
av := reflect.ValueOf(a)
bv := reflect.ValueOf(b)
if av.Kind() == reflect.Int &amp;amp;&amp;amp; bv.Kind() == reflect.Int {
if av.Int() &amp;gt; bv.Int() {
return a
}
return b
}
// می‌توانید برای انواع دیگر هم کد بنویسید
return nil
}
func main() {
fmt.Println(Max(3, 7)) // خروجی: 7
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>توضیح:&lt;/strong>&lt;br>
در این مثال تابع Max با هر نوعی که به آن بدهید کار می‌کند، اما باید به کمک reflect نوع مقدار را بررسی و مقایسه کنید. این کار هم کند است و هم ایمنی نوعی ندارد و در زمان اجرا ممکن است باعث panic یا رفتار ناخواسته شود.&lt;/p>
&lt;h2 id="۶۶۲-مزایا-و-معایب-هر-روش">
۶.۶.۲ مزایا و معایب هر روش
&lt;a class="anchor" href="#%db%b6%db%b6%db%b2-%d9%85%d8%b2%d8%a7%db%8c%d8%a7-%d9%88-%d9%85%d8%b9%d8%a7%db%8c%d8%a8-%d9%87%d8%b1-%d8%b1%d9%88%d8%b4">#&lt;/a>
&lt;/h2>
&lt;h4 id="interface-و-reflect-روش-قدیمی">
&lt;strong>interface{} و reflect (روش قدیمی)&lt;/strong>
&lt;a class="anchor" href="#interface-%d9%88-reflect-%d8%b1%d9%88%d8%b4-%d9%82%d8%af%db%8c%d9%85%db%8c">#&lt;/a>
&lt;/h4>
&lt;p>&lt;strong>مزایا:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>قابلیت انعطاف برای پذیرش هر نوع داده (generic ظاهر)&lt;/li>
&lt;li>قابل استفاده در زبان‌های قبل از Go 1.18&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>معایب:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>کاهش ایمنی نوعی (Type Safety):&lt;/strong> خطاهای نوع فقط در زمان اجرا کشف می‌شوند.&lt;/li>
&lt;li>&lt;strong>پیچیدگی و خوانایی پایین:&lt;/strong> بررسی نوع با reflect یا type assertion باعث طولانی و پیچیده شدن کد می‌شود.&lt;/li>
&lt;li>&lt;strong>افت کارایی:&lt;/strong> بازتاب (reflect) کند است و فراخوانی‌های زیاد باعث overhead می‌شود.&lt;/li>
&lt;li>&lt;strong>خطر panic:&lt;/strong> اگر نوع داده اشتباه ارسال شود، احتمال panic بالا می‌رود.&lt;/li>
&lt;li>&lt;strong>عدم هشدار کامپایلری:&lt;/strong> هیچ هشدار یا خطایی از سمت کامپایلر دریافت نمی‌کنید.&lt;/li>
&lt;li>&lt;strong>تست و نگهداری دشوار:&lt;/strong> تست و اشکال‌زدایی کدهایی که مبتنی بر interface{} و reflect هستند به مراتب سخت‌تر است.&lt;/li>
&lt;/ul>
&lt;h4 id="ژنریکهای-go-از-118-به-بعد">
&lt;strong>ژِنریک‌های Go (از 1.18 به بعد)&lt;/strong>
&lt;a class="anchor" href="#%da%98%d9%86%d8%b1%db%8c%da%a9%d9%87%d8%a7%db%8c-go-%d8%a7%d8%b2-118-%d8%a8%d9%87-%d8%a8%d8%b9%d8%af">#&lt;/a>
&lt;/h4>
&lt;p>&lt;strong>مزایا:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>ایمنی نوعی بالا:&lt;/strong> همه خطاهای نوع در زمان کامپایل مشخص می‌شوند.&lt;/li>
&lt;li>&lt;strong>کد کوتاه‌تر و خواناتر:&lt;/strong> نیاز به تکرار تابع برای هر نوع داده نیست و بازتاب حذف می‌شود.&lt;/li>
&lt;li>&lt;strong>کارایی بهتر:&lt;/strong> هیچ overhead ناشی از reflect یا type assertion وجود ندارد و کد تولیدشده شبیه کد دستی است.&lt;/li>
&lt;li>&lt;strong>نگهداری آسان‌تر:&lt;/strong> refactoring راحت‌تر و تست‌پذیری بالاتر&lt;/li>
&lt;li>&lt;strong>مستندسازی خودکار و بهتر:&lt;/strong> امضاهای توابع و structها واضح و قابل فهم برای توسعه‌دهندگان و ابزارهاست.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>معایب:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>نیاز به نسخه جدید Go:&lt;/strong> فقط در Go 1.18 به بعد قابل استفاده است.&lt;/li>
&lt;li>&lt;strong>درک اولیه برای توسعه‌دهندگان تازه‌کار ممکن است کمی زمان‌بر باشد.&lt;/strong>&lt;/li>
&lt;li>&lt;strong>در برخی موارد خاص (مانند ژنریک اینترفیس‌های خیلی پیچیده)، امضاها می‌تواند کمی پیچیده شود.&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h2 id="۶۶۳-مقایسه-کارایی-خوانایی-و-نگهداشت">
۶.۶.۳ مقایسه کارایی، خوانایی و نگهداشت
&lt;a class="anchor" href="#%db%b6%db%b6%db%b3-%d9%85%d9%82%d8%a7%db%8c%d8%b3%d9%87-%da%a9%d8%a7%d8%b1%d8%a7%db%8c%db%8c-%d8%ae%d9%88%d8%a7%d9%86%d8%a7%db%8c%db%8c-%d9%88-%d9%86%da%af%d9%87%d8%af%d8%a7%d8%b4%d8%aa">#&lt;/a>
&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>ویژگی&lt;/th>
&lt;th>interface{} و reflect (قدیمی)&lt;/th>
&lt;th>ژنریک‌های Go (جدید)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>ایمنی نوع&lt;/strong>&lt;/td>
&lt;td>بسیار پایین (خطر panic بالا)&lt;/td>
&lt;td>بسیار بالا (compile-time checked)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>خوانایی&lt;/strong>&lt;/td>
&lt;td>پایین و پیچیده (reflect و assert)&lt;/td>
&lt;td>بالا و شفاف (type-safe)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>کارایی&lt;/strong>&lt;/td>
&lt;td>کند (overhead بازتاب)&lt;/td>
&lt;td>سریع (مانند کد معمولی)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>نگهداری&lt;/strong>&lt;/td>
&lt;td>دشوار و پرخطا&lt;/td>
&lt;td>آسان و قابل refactor&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>تست‌پذیری&lt;/strong>&lt;/td>
&lt;td>سخت (خطاهای run-time)&lt;/td>
&lt;td>بسیار آسان (خطاهای compile-time)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>کد تکراری&lt;/strong>&lt;/td>
&lt;td>زیاد (اگر برای هر نوع دستی بنویسید)&lt;/td>
&lt;td>حداقل (یک بار برای همه انواع)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><author/><title>6.7 محدودیت‌ها، خطاها و ضدالگوها در ژنریک‌ها</title><link>https://book.gofarsi.ir/chapter-6/limitations-errors-and-anti-patterns-in-generics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-6/limitations-errors-and-anti-patterns-in-generics/</guid><description>&lt;h2 id="۶۷۱-محدودیتهای-فعلی-ژنریکها-در-go-compile-time--runtime">
۶.۷.۱ محدودیت‌های فعلی ژنریک‌ها در Go (Compile-time &amp;amp; Runtime)
&lt;a class="anchor" href="#%db%b6%db%b7%db%b1-%d9%85%d8%ad%d8%af%d9%88%d8%af%db%8c%d8%aa%d9%87%d8%a7%db%8c-%d9%81%d8%b9%d9%84%db%8c-%da%98%d9%86%d8%b1%db%8c%da%a9%d9%87%d8%a7-%d8%af%d8%b1-go-compile-time--runtime">#&lt;/a>
&lt;/h2>
&lt;p>اگرچه ژنریک‌ها قابلیت فوق‌العاده‌ای به Go افزوده‌اند، اما هنوز با برخی محدودیت‌های فنی و زبانی روبه‌رو هستند که باید حتماً در پروژه‌های جدی مدنظر قرار گیرد:&lt;/p>
&lt;h4 id="محدودیتهای-زمان-کامپایل-compile-time">
محدودیت‌های زمان کامپایل (Compile-time)
&lt;a class="anchor" href="#%d9%85%d8%ad%d8%af%d9%88%d8%af%db%8c%d8%aa%d9%87%d8%a7%db%8c-%d8%b2%d9%85%d8%a7%d9%86-%da%a9%d8%a7%d9%85%d9%be%d8%a7%db%8c%d9%84-compile-time">#&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>عدم پشتیبانی از عملیات ریاضی یا منطقی روی هر نوع دلخواه:&lt;/strong>&lt;br>
فقط انواعی که قید مناسب (مانند &lt;code>cmp.Ordered&lt;/code> یا union خاص) دارند می‌توانند با عملگرهای مقایسه یا ریاضی استفاده شوند.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>عدم امکان specialization:&lt;/strong>&lt;br>
برخلاف ++C یا Rust، نمی‌توانید نسخه خاصی از تابع یا struct برای نوعی خاص پیاده‌سازی کنید (Specialization).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>محدودیت روی method set:&lt;/strong>&lt;br>
اگر یک type parameter با interface constraint تعریف شود، فقط به متدهای آن constraint دسترسی دارید، حتی اگر نوع واقعی متدهای بیشتری داشته باشد.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>محدودیت در تعریف type embedding ژنریک:&lt;/strong>&lt;br>
هنوز نمی‌توانید یک struct ژنریک را به عنوان فیلد ناشناس (anonymous field) در struct دیگر embed کنید.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>عدم پشتیبانی از const type parameters:&lt;/strong>&lt;br>
مثل ++C و Rust، نمی‌توانید مقدار ثابت را به عنوان پارامتر ژنریک تعیین کنید (مثلاً سایز آرایه).&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h4 id="محدودیتهای-زمان-اجرا-runtime">
محدودیت‌های زمان اجرا (Runtime)
&lt;a class="anchor" href="#%d9%85%d8%ad%d8%af%d9%88%d8%af%db%8c%d8%aa%d9%87%d8%a7%db%8c-%d8%b2%d9%85%d8%a7%d9%86-%d8%a7%d8%ac%d8%b1%d8%a7-runtime">#&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>عدم دسترسی به اطلاعات نوع پارامتر در runtime:&lt;/strong>&lt;br>
پارامترهای نوع در زمان اجرا قابل شناسایی نیستند و امکان reflection مستقیم روی آن‌ها وجود ندارد.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>خطاهای مرتبط با nil و zero value:&lt;/strong>&lt;br>
بازگرداندن مقدار صفر (zero value) برای نوع پارامتریک ممکن است همیشه با منطق کسب‌وکار شما منطبق نباشد.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="۶۷۲-خطاها-و-پیامهای-رایج-در-استفاده-از-ژنریکها">
۶.۷.۲ خطاها و پیام‌های رایج در استفاده از ژنریک‌ها
&lt;a class="anchor" href="#%db%b6%db%b7%db%b2-%d8%ae%d8%b7%d8%a7%d9%87%d8%a7-%d9%88-%d9%be%db%8c%d8%a7%d9%85%d9%87%d8%a7%db%8c-%d8%b1%d8%a7%db%8c%d8%ac-%d8%af%d8%b1-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-%da%98%d9%86%d8%b1%db%8c%da%a9%d9%87%d8%a7">#&lt;/a>
&lt;/h2>
&lt;p>در استفاده از ژنریک‌های Go، با برخی پیام‌های خطا و اشکالات رایج مواجه خواهید شد:&lt;/p>
&lt;h4 id="پیامهای-متداول-کامپایلر">
پیام‌های متداول کامپایلر
&lt;a class="anchor" href="#%d9%be%db%8c%d8%a7%d9%85%d9%87%d8%a7%db%8c-%d9%85%d8%aa%d8%af%d8%a7%d9%88%d9%84-%da%a9%d8%a7%d9%85%d9%be%d8%a7%db%8c%d9%84%d8%b1">#&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>&amp;ldquo;type T does not satisfy constraint C&amp;rdquo;&lt;/strong>&lt;br>
یعنی نوع مورد استفاده تمام ویژگی‌های constraint را ندارد.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&amp;ldquo;invalid operation: operator X not defined for T&amp;rdquo;&lt;/strong>&lt;br>
عملگری روی نوع پارامتریک استفاده شده که constraint اجازه نمی‌دهد.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&amp;ldquo;cannot use T as type K in map: T does not implement comparable&amp;rdquo;&lt;/strong>&lt;br>
برای map، کلید باید حتماً &lt;code>comparable&lt;/code> باشد.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&amp;ldquo;cannot infer T&amp;rdquo; یا &amp;ldquo;type parameter T cannot be inferred&amp;rdquo;&lt;/strong>&lt;br>
کامپایلر قادر به استنتاج نوع پارامتر نیست و باید صراحتاً نوع را تعیین کنید.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&amp;ldquo;instantiation cycle&amp;rdquo;&lt;/strong>&lt;br>
ارجاع بازگشتی نادرست یا پیاده‌سازی ضدالگو در constraintها باعث این خطا می‌شود.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h4 id="مثال-واقعی-خطا">
مثال واقعی خطا:
&lt;a class="anchor" href="#%d9%85%d8%ab%d8%a7%d9%84-%d9%88%d8%a7%d9%82%d8%b9%db%8c-%d8%ae%d8%b7%d8%a7">#&lt;/a>
&lt;/h4>
&lt;pre>&lt;code class="language-go">func PrintMapKeys[K comparable, V any](m map[K]V) {
for k := range m {
fmt.Println(k)
}
}
PrintMapKeys(map[[]int]int{}) // error: []int does not implement comparable
&lt;/code>&lt;/pre>
&lt;hr>
&lt;h2 id="۶۷۳-ضدالگوها-anti-patterns-و-اشتباهات-متداول">
۶.۷.۳ ضدالگوها (Anti-patterns) و اشتباهات متداول
&lt;a class="anchor" href="#%db%b6%db%b7%db%b3-%d8%b6%d8%af%d8%a7%d9%84%da%af%d9%88%d9%87%d8%a7-anti-patterns-%d9%88-%d8%a7%d8%b4%d8%aa%d8%a8%d8%a7%d9%87%d8%a7%d8%aa-%d9%85%d8%aa%d8%af%d8%a7%d9%88%d9%84">#&lt;/a>
&lt;/h2>
&lt;p>برخی از رفتارها یا کدهای غلط که باید در استفاده از ژنریک‌ها از آن‌ها پرهیز کنید:&lt;/p>
&lt;h4 id="۱-استفاده-بیش-از-حد-از-any-یا-constraint-بسیار-کلی">
&lt;strong>۱. استفاده بیش از حد از any یا constraint بسیار کلی&lt;/strong>
&lt;a class="anchor" href="#%db%b1-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a8%db%8c%d8%b4-%d8%a7%d8%b2-%d8%ad%d8%af-%d8%a7%d8%b2-any-%db%8c%d8%a7-constraint-%d8%a8%d8%b3%db%8c%d8%a7%d8%b1-%da%a9%d9%84%db%8c">#&lt;/a>
&lt;/h4>
&lt;p>این کار ایمنی نوعی را کاهش می‌دهد و ژنریک عملاً مانند interface{} عمل می‌کند.&lt;/p>
&lt;pre>&lt;code class="language-go">func BadFunc[T any](v T) { /* ... */ } // تقریبا مثل استفاده از interface{}
&lt;/code>&lt;/pre>
&lt;h4 id="۲-پیادهسازی-تابع-یا-struct-ژنریک-بدون-نیاز-واقعی">
&lt;strong>۲. پیاده‌سازی تابع یا struct ژنریک بدون نیاز واقعی&lt;/strong>
&lt;a class="anchor" href="#%db%b2-%d9%be%db%8c%d8%a7%d8%af%d9%87%d8%b3%d8%a7%d8%b2%db%8c-%d8%aa%d8%a7%d8%a8%d8%b9-%db%8c%d8%a7-struct-%da%98%d9%86%d8%b1%db%8c%da%a9-%d8%a8%d8%af%d9%88%d9%86-%d9%86%db%8c%d8%a7%d8%b2-%d9%88%d8%a7%d9%82%d8%b9%db%8c">#&lt;/a>
&lt;/h4>
&lt;p>اگر فقط برای یک نوع خاص استفاده می‌کنید، نیاز به ژنریک ندارید و فقط پیچیدگی ایجاد کرده‌اید.&lt;/p>
&lt;h4 id="۳-بازگرداندن-zero-value-بهجای-error-handling">
&lt;strong>۳. بازگرداندن zero value به‌جای error handling&lt;/strong>
&lt;a class="anchor" href="#%db%b3-%d8%a8%d8%a7%d8%b2%da%af%d8%b1%d8%af%d8%a7%d9%86%d8%af%d9%86-zero-value-%d8%a8%d9%87%d8%ac%d8%a7%db%8c-error-handling">#&lt;/a>
&lt;/h4>
&lt;p>اگر pop روی stack ژنریک خالی انجام شود، صرف بازگرداندن zero value ممکن است باعث بروز باگ پنهان شود؛ بهتر است مقدار بولین یا error نیز بازگردانده شود.&lt;/p>
&lt;h4 id="۴-constraintهای-بسیار-پیچیده-یا-ناخوانا">
&lt;strong>۴. constraintهای بسیار پیچیده یا ناخوانا&lt;/strong>
&lt;a class="anchor" href="#%db%b4-constraint%d9%87%d8%a7%db%8c-%d8%a8%d8%b3%db%8c%d8%a7%d8%b1-%d9%be%db%8c%da%86%db%8c%d8%af%d9%87-%db%8c%d8%a7-%d9%86%d8%a7%d8%ae%d9%88%d8%a7%d9%86%d8%a7">#&lt;/a>
&lt;/h4>
&lt;p>استفاده از چندین interface یا unionهای تو در تو، امضای تابع را گیج‌کننده می‌کند و نگهداری را سخت می‌سازد.&lt;/p>
&lt;h4 id="۵-وابستگی-زیاد-به-type-assertion-یا-reflect">
&lt;strong>۵. وابستگی زیاد به type assertion یا reflect&lt;/strong>
&lt;a class="anchor" href="#%db%b5-%d9%88%d8%a7%d8%a8%d8%b3%d8%aa%da%af%db%8c-%d8%b2%db%8c%d8%a7%d8%af-%d8%a8%d9%87-type-assertion-%db%8c%d8%a7-reflect">#&lt;/a>
&lt;/h4>
&lt;p>اگر در کد ژنریک زیاد مجبور به type assertion شدید، نشانه این است که abstraction شما صحیح یا idiomatic نیست.&lt;/p>
&lt;h4 id="۶-تعریف-و-استفاده-از-type-alias-بیمعنا-یا-بیهدف">
&lt;strong>۶. تعریف و استفاده از type alias بی‌معنا یا بی‌هدف&lt;/strong>
&lt;a class="anchor" href="#%db%b6-%d8%aa%d8%b9%d8%b1%db%8c%d9%81-%d9%88-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-type-alias-%d8%a8%db%8c%d9%85%d8%b9%d9%86%d8%a7-%db%8c%d8%a7-%d8%a8%db%8c%d9%87%d8%af%d9%81">#&lt;/a>
&lt;/h4>
&lt;p>تعریف alias برای انواع ژنریک بدون هدف مشخص، باعث ابهام و پیچیدگی در پروژه می‌شود.&lt;/p>
&lt;h2 id="۶۷۴-نکات-مربوط-به-versionهای-جدید-مانند-مشکلات-migration-و-backward-compatibility">
۶.۷.۴ نکات مربوط به versionهای جدید (مانند مشکلات Migration و backward compatibility)
&lt;a class="anchor" href="#%db%b6%db%b7%db%b4-%d9%86%da%a9%d8%a7%d8%aa-%d9%85%d8%b1%d8%a8%d9%88%d8%b7-%d8%a8%d9%87-version%d9%87%d8%a7%db%8c-%d8%ac%d8%af%db%8c%d8%af-%d9%85%d8%a7%d9%86%d9%86%d8%af-%d9%85%d8%b4%da%a9%d9%84%d8%a7%d8%aa-migration-%d9%88-backward-compatibility">#&lt;/a>
&lt;/h2>
&lt;h4 id="مشکلات-مهاجرت-migration">
&lt;strong>مشکلات مهاجرت (Migration)&lt;/strong>
&lt;a class="anchor" href="#%d9%85%d8%b4%da%a9%d9%84%d8%a7%d8%aa-%d9%85%d9%87%d8%a7%d8%ac%d8%b1%d8%aa-migration">#&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>اگر کتابخانه یا کد قدیمی با interface{} نوشته شده باشد، مهاجرت به ژنریک نیازمند refactoring است.&lt;/li>
&lt;li>تغییر امضاهای توابع و structها ممکن است باعث شکستن سازگاری با کد قدیمی (backward compatibility) شود.&lt;/li>
&lt;li>برخی ابزارها و کتابخانه‌های شخص ثالث ممکن است از ژنریک به‌درستی پشتیبانی نکنند یا هنوز به نسخه‌های قدیمی Go محدود باشند.&lt;/li>
&lt;/ul>
&lt;h4 id="مسائل-سازگاری-نسخه-backward-compatibility">
&lt;strong>مسائل سازگاری نسخه (Backward Compatibility)&lt;/strong>
&lt;a class="anchor" href="#%d9%85%d8%b3%d8%a7%d8%a6%d9%84-%d8%b3%d8%a7%d8%b2%da%af%d8%a7%d8%b1%db%8c-%d9%86%d8%b3%d8%ae%d9%87-backward-compatibility">#&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>کدی که با ژنریک نوشته شده فقط روی Go 1.18+ اجرا می‌شود.&lt;/li>
&lt;li>در برخی نسخه‌های جدیدتر Go (مثلاً 1.24 یا 1.25)، امکانات بیشتری مثل generic type alias و بهبود constraintها اضافه شده که استفاده از آن‌ها ممکن است برای پروژه‌های multi-version مشکل‌ساز شود.&lt;/li>
&lt;li>برخی قابلیت‌ها (مانند حذف core type در Go 1.25) باعث ساده‌تر شدن توسعه ولی تغییر در قواعد قدیمی شده‌اند.&lt;/li>
&lt;/ul>
&lt;h4 id="نکته-های-بیلد">
&lt;strong>نکته های بیلد:&lt;/strong>
&lt;a class="anchor" href="#%d9%86%da%a9%d8%aa%d9%87-%d9%87%d8%a7%db%8c-%d8%a8%db%8c%d9%84%d8%af">#&lt;/a>
&lt;/h4>
&lt;p>برای حفظ سازگاری نسخه و کاهش ریسک migration:&lt;/p>
&lt;ul>
&lt;li>امضاهای جدید را با مستندسازی مناسب تغییر دهید.&lt;/li>
&lt;li>در صورت نیاز از build tag یا نسخه‌بندی ماژول استفاده کنید.&lt;/li>
&lt;li>همیشه تست‌های unit و integration را قبل و بعد از migration اجرا کنید.&lt;/li>
&lt;/ul></description></item><item><author/><title>6.8 بهترین شیوه‌های استفاده از ژنریک‌ها (Best Practices)</title><link>https://book.gofarsi.ir/chapter-6/generics-best-practice/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-6/generics-best-practice/</guid><description>&lt;p>در این بخش، به‌صورت حرفه‌ای، کاربردی و تجربی، &lt;strong>بهترین شیوه‌های استفاده از ژنریک‌ها&lt;/strong> در پروژه‌های Go را همراه با نکات تولیدی و فنی ارائه می‌دهم.&lt;/p>
&lt;h3 id="۶۸۱-راهنمای-تصمیمگیری-چه-زمانی-ژنریک-چه-زمانی-نه">
۶.۸.۱ راهنمای تصمیم‌گیری: چه زمانی ژنریک؟ چه زمانی نه؟
&lt;a class="anchor" href="#%db%b6%db%b8%db%b1-%d8%b1%d8%a7%d9%87%d9%86%d9%85%d8%a7%db%8c-%d8%aa%d8%b5%d9%85%db%8c%d9%85%da%af%db%8c%d8%b1%db%8c-%da%86%d9%87-%d8%b2%d9%85%d8%a7%d9%86%db%8c-%da%98%d9%86%d8%b1%db%8c%da%a9-%da%86%d9%87-%d8%b2%d9%85%d8%a7%d9%86%db%8c-%d9%86%d9%87">#&lt;/a>
&lt;/h3>
&lt;p>&lt;strong>ژنریک‌ها ابزار قدرتمندی هستند، اما استفاده درست و هوشمندانه از آن‌ها حیاتی است.&lt;/strong>&lt;br>
بهتر است ژنریک را فقط زمانی به کار ببرید که:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>یک منطق تکراری برای چندین نوع مختلف وجود دارد&lt;/strong> و پیاده‌سازی جداگانه برای هر نوع باعث تکرار و دشواری نگهداری می‌شود.&lt;/li>
&lt;li>&lt;strong>نیاز به abstraction و توسعه‌پذیری کد&lt;/strong> برای آینده وجود دارد، مانند ساختار داده‌ها (Stack, Queue, Map)، یا توابع عمومی (Map, Filter, Reduce).&lt;/li>
&lt;li>&lt;strong>ایمنی نوعی (Type Safety)&lt;/strong> برایتان مهم است و می‌خواهید خطاها را در زمان کامپایل متوجه شوید.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>چه زمانی ژنریک استفاده نکنیم؟&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>زمانی که فقط برای یک یا دو نوع خاص کد می‌نویسید و abstraction عمومی نیاز ندارید.&lt;/li>
&lt;li>اگر استفاده از ژنریک خوانایی کد را پایین می‌آورد یا امضای تابع/ساختار بسیار پیچیده می‌شود.&lt;/li>
&lt;li>اگر abstraction شما منجر به over-engineering یا کد غیرضروری می‌شود.&lt;/li>
&lt;li>زمانی که عملکرد (performance) بسیار بحرانی است و بنچمارک‌ها نشان می‌دهند که نسخه معمولی سریع‌تر است.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>نکته:&lt;/strong>&lt;br>
همیشه قبل از ژنریک‌سازی، با کد ساده و معمولی شروع کنید و اگر نیاز به تعمیم و بازاستفاده پیش آمد، refactor به ژنریک انجام دهید.&lt;/p>
&lt;h3 id="۶۸۲-نکات-خوانایی-نگهداشتپذیری-و-توسعهپذیری">
۶.۸.۲ نکات خوانایی، نگهداشت‌پذیری و توسعه‌پذیری
&lt;a class="anchor" href="#%db%b6%db%b8%db%b2-%d9%86%da%a9%d8%a7%d8%aa-%d8%ae%d9%88%d8%a7%d9%86%d8%a7%db%8c%db%8c-%d9%86%da%af%d9%87%d8%af%d8%a7%d8%b4%d8%aa%d9%be%d8%b0%db%8c%d8%b1%db%8c-%d9%88-%d8%aa%d9%88%d8%b3%d8%b9%d9%87%d9%be%d8%b0%db%8c%d8%b1%db%8c">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>نام‌گذاری واضح برای پارامتر نوع:&lt;/strong>&lt;br>
از نام‌های معنادار (مثلاً &lt;code>T&lt;/code> برای Type، &lt;code>K&lt;/code> برای Key، &lt;code>V&lt;/code> برای Value) استفاده کنید و در موارد پیچیده‌تر، نام دقیق‌تر (مثلاً &lt;code>User&lt;/code>, &lt;code>IDType&lt;/code>) انتخاب کنید.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>constraintها را تا حد امکان ساده نگه دارید:&lt;/strong>&lt;br>
از any یا constraintهای بیش از حد کلی فقط زمانی استفاده کنید که واقعاً نیاز است.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>توابع و ساختارهای ژنریک را مستند کنید:&lt;/strong>&lt;br>
توضیح دهید که پارامتر نوع چه ویژگی‌هایی باید داشته باشد.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>امضای تابع/ساختار را پیچیده نکنید:&lt;/strong>&lt;br>
سعی کنید از چند پارامتر نوعی زیاد، یا constraintهای تو در تو فقط زمانی استفاده کنید که طراحی شما واقعاً به آن نیاز دارد.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>از aliasهای ژنریک فقط برای ساده‌سازی و افزایش خوانایی استفاده کنید:&lt;/strong>&lt;br>
از aliasهای نامفهوم و زنجیره‌ای بپرهیزید.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="۶۸۳-ترفندهای-تولیدی-و-حرفهای-برای-پروژههای-بزرگ-و-ماژولار">
۶.۸.۳ ترفندهای تولیدی و حرفه‌ای برای پروژه‌های بزرگ و ماژولار
&lt;a class="anchor" href="#%db%b6%db%b8%db%b3-%d8%aa%d8%b1%d9%81%d9%86%d8%af%d9%87%d8%a7%db%8c-%d8%aa%d9%88%d9%84%db%8c%d8%af%db%8c-%d9%88-%d8%ad%d8%b1%d9%81%d9%87%d8%a7%db%8c-%d8%a8%d8%b1%d8%a7%db%8c-%d9%be%d8%b1%d9%88%da%98%d9%87%d9%87%d8%a7%db%8c-%d8%a8%d8%b2%d8%b1%da%af-%d9%88-%d9%85%d8%a7%da%98%d9%88%d9%84%d8%a7%d8%b1">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>ساخت abstractionهای لایه‌ای:&lt;/strong>&lt;br>
ابتدا یک interface ژنریک تعریف کنید و سپس پیاده‌سازی‌های مختلف با constraintهای متفاوت بسازید (مثلاً یک interface برای ذخیره‌سازی و چند نوع backend مختلف).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>کتابخانه‌های داخلی و عمومی را ژنریک بنویسید:&lt;/strong>&lt;br>
هرجا می‌خواهید reusable library یا utility بسازید، ژنریک ابزار ایده‌آل است.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>ژِنریک را با تست و بنچمارک پوشش دهید:&lt;/strong>&lt;br>
همیشه انواع مختلف را تست کنید تا از عدم بروز خطاهای نوعی مطمئن شوید.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>در پروژه‌های بزرگ از constraint alias استفاده کنید:&lt;/strong>&lt;br>
constraintهای تکراری و ترکیبی را alias کنید تا خوانایی و نگهداری بهبود یابد.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>پشتیبانی از backward compatibility:&lt;/strong>&lt;br>
هنگام مهاجرت به ژنریک، بخش‌های پرکاربرد را تدریجی refactor کنید تا کاربران پروژه آسیب نبینند.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="۶۸۴-عملکرد-performance-compile-time-و-تاثیرات-بر-روی-debugging">
۶.۸.۴ عملکرد (Performance)، Compile-Time و تاثیرات بر روی Debugging
&lt;a class="anchor" href="#%db%b6%db%b8%db%b4-%d8%b9%d9%85%d9%84%da%a9%d8%b1%d8%af-performance-compile-time-%d9%88-%d8%aa%d8%a7%d8%ab%db%8c%d8%b1%d8%a7%d8%aa-%d8%a8%d8%b1-%d8%b1%d9%88%db%8c-debugging">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>بنچمارک قبل و بعد از ژنریک‌سازی:&lt;/strong>&lt;br>
در بخش‌هایی که performance بحرانی است، حتماً قبل و بعد از استفاده از ژنریک بنچمارک بگیرید. در اکثر موارد، کد ژنریک مثل نسخه دستی اجرا می‌شود، اما در برخی حالات خاص (مانند استفاده از اینترفیس یا constraintهای سنگین)، ممکن است کمی کندتر باشد.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>تاثیر بر زمان کامپایل:&lt;/strong>&lt;br>
با ژنریک، زمان کامپایل ممکن است کمی افزایش یابد (به ویژه در پروژه‌های بزرگ یا با constraintهای پیچیده)، اما با بهینه‌سازی نسخه‌های جدید Go این تاثیر حداقلی است.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Debugging و پیام‌های خطا:&lt;/strong>&lt;br>
پیام‌های خطا در ژنریک‌های پیچیده می‌تواند مبهم باشد. توصیه می‌شود با ساده‌سازی constraint و مستندسازی، کار دیباگ را راحت‌تر کنید.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>در تست‌ها از انواع مختلف استفاده کنید:&lt;/strong>&lt;br>
تست ژنریک با داده‌های متنوع به شما کمک می‌کند از ایمنی کد مطمئن شوید و خطاهای پنهان را بیابید.&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><author/><title>6.9 مثال‌های پیشرفته و نکات ویژه</title><link>https://book.gofarsi.ir/chapter-6/generics-advanced-examples-and-tips/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-6/generics-advanced-examples-and-tips/</guid><description>&lt;h2 id="۶۹۱-ساخت-کتابخانههای-عمومی-و-abstractionهای-حرفهای-با-ژنریکها">
۶.۹.۱ ساخت کتابخانه‌های عمومی و abstractionهای حرفه‌ای با ژنریک‌ها
&lt;a class="anchor" href="#%db%b6%db%b9%db%b1-%d8%b3%d8%a7%d8%ae%d8%aa-%da%a9%d8%aa%d8%a7%d8%a8%d8%ae%d8%a7%d9%86%d9%87%d9%87%d8%a7%db%8c-%d8%b9%d9%85%d9%88%d9%85%db%8c-%d9%88-abstraction%d9%87%d8%a7%db%8c-%d8%ad%d8%b1%d9%81%d9%87%d8%a7%db%8c-%d8%a8%d8%a7-%da%98%d9%86%d8%b1%db%8c%da%a9%d9%87%d8%a7">#&lt;/a>
&lt;/h2>
&lt;p>در پروژه‌های مدرن، معمولاً نیاز به abstraction و لایه‌بندی وجود دارد تا بتوانید کدهای reusable و توسعه‌پذیر بسازید. ژنریک‌ها در Go این کار را بسیار ساده و حرفه‌ای می‌کنند.&lt;/p>
&lt;h4 id="مثال-کتابخانه-datastore-ژنریک">
&lt;strong>مثال: کتابخانه DataStore ژنریک&lt;/strong>
&lt;a class="anchor" href="#%d9%85%d8%ab%d8%a7%d9%84-%da%a9%d8%aa%d8%a7%d8%a8%d8%ae%d8%a7%d9%86%d9%87-datastore-%da%98%d9%86%d8%b1%db%8c%da%a9">#&lt;/a>
&lt;/h4>
&lt;pre>&lt;code class="language-go">type DataStore[T any] interface {
Get(id string) (T, error)
Save(id string, data T) error
}
type MemoryStore[T any] struct {
data map[string]T
}
func NewMemoryStore[T any]() *MemoryStore[T] {
return &amp;amp;MemoryStore[T]{data: make(map[string]T)}
}
func (m *MemoryStore[T]) Get(id string) (T, error) {
v, ok := m.data[id]
if !ok {
var zero T
return zero, fmt.Errorf(&amp;quot;not found&amp;quot;)
}
return v, nil
}
func (m *MemoryStore[T]) Save(id string, data T) error {
m.data[id] = data
return nil
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>توضیح:&lt;/strong>&lt;br>
در این مثال یک abstraction برای ذخیره‌سازی داده‌ها پیاده‌سازی شده که می‌تواند برای هر نوع داده‌ای مورد استفاده قرار گیرد (مثلاً User, Order, Product و &amp;hellip;). این ساختار با پیاده‌سازی interface ژنریک، قابلیت توسعه و تست بسیار بالایی دارد و به راحتی می‌توانید MemoryStore را با نسخه DatabaseStore یا CacheStore جایگزین کنید.&lt;/p>
&lt;h2 id="۶۹۲-ترکیب-ژنریک-با-error-handling-و-context">
۶.۹.۲ ترکیب ژنریک با error handling و context
&lt;a class="anchor" href="#%db%b6%db%b9%db%b2-%d8%aa%d8%b1%da%a9%db%8c%d8%a8-%da%98%d9%86%d8%b1%db%8c%da%a9-%d8%a8%d8%a7-error-handling-%d9%88-context">#&lt;/a>
&lt;/h2>
&lt;p>ترکیب ژنریک با الگوهای حرفه‌ای مثل مدیریت خطا (error handling) و context در Go باعث ایجاد کدهایی ایمن، تمیز و مقیاس‌پذیر می‌شود.&lt;/p>
&lt;h4 id="مثال-سرویس-ژنریک-با-context-و-error">
&lt;strong>مثال: سرویس ژنریک با Context و Error&lt;/strong>
&lt;a class="anchor" href="#%d9%85%d8%ab%d8%a7%d9%84-%d8%b3%d8%b1%d9%88%db%8c%d8%b3-%da%98%d9%86%d8%b1%db%8c%da%a9-%d8%a8%d8%a7-context-%d9%88-error">#&lt;/a>
&lt;/h4>
&lt;pre>&lt;code class="language-go">type Service[T any] interface {
FindByID(ctx context.Context, id int) (T, error)
}
type User struct {
Name string
}
type UserService struct {
data map[int]User
}
func (u *UserService) FindByID(ctx context.Context, id int) (User, error) {
select {
case &amp;lt;-ctx.Done():
return User{}, ctx.Err()
default:
user, ok := u.data[id]
if !ok {
return User{}, fmt.Errorf(&amp;quot;not found&amp;quot;)
}
return user, nil
}
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>توضیح:&lt;/strong>&lt;br>
در این الگو، abstraction سرویس به صورت ژنریک تعریف شده و متدها از context و error استفاده می‌کنند. این الگو مناسب سرویس‌های REST, gRPC، کار با پایگاه داده و معماری‌های مدرن است.&lt;/p>
&lt;h2 id="۶۹۳-نکات-بهینهسازی-و-performance-در-کد-ژنریک">
۶.۹.۳ نکات بهینه‌سازی و Performance در کد ژنریک
&lt;a class="anchor" href="#%db%b6%db%b9%db%b3-%d9%86%da%a9%d8%a7%d8%aa-%d8%a8%d9%87%db%8c%d9%86%d9%87%d8%b3%d8%a7%d8%b2%db%8c-%d9%88-performance-%d8%af%d8%b1-%da%a9%d8%af-%da%98%d9%86%d8%b1%db%8c%da%a9">#&lt;/a>
&lt;/h2>
&lt;p>برای کدهای ژنریک، همواره باید کارایی و بهینه‌سازی را در نظر گرفت، مخصوصاً در ساختارهای داده و توابع پرتکرار.&lt;/p>
&lt;h4 id="نکات-مهم">
&lt;strong>نکات مهم:&lt;/strong>
&lt;a class="anchor" href="#%d9%86%da%a9%d8%a7%d8%aa-%d9%85%d9%87%d9%85">#&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>استفاده از constraintهای حداقلی:&lt;/strong>&lt;br>
constraintها را تا جای ممکن ساده نگه دارید تا کامپایلر بتواند بیشترین بهینه‌سازی را انجام دهد.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>اجتناب از reflect و type assertion:&lt;/strong>&lt;br>
هرجا می‌توانید منطق را با constraint و متدهای مستقیم حل کنید و از عملیات runtime اضافه بپرهیزید.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>بنچمارک عملی:&lt;/strong>&lt;br>
کدهای ژنریک را مثل سایر کدها با بنچمارک مقایسه کنید، به ویژه اگر در مسیر بحرانی اجرا قرار دارند.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>استفاده از slices و pre-allocation:&lt;/strong>&lt;br>
در ساختارهای داده، اندازه اولیه slice را تعیین کنید تا از افزایش هزینه reallocation جلوگیری شود.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>پروفایلینگ کد ژنریک:&lt;/strong>&lt;br>
با ابزارهایی مثل pprof، عملکرد توابع ژنریک را بررسی کنید تا نقاط bottleneck را شناسایی و رفع کنید.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h4 id="مثال-بنچمارک-ساده">
&lt;strong>مثال بنچمارک ساده:&lt;/strong>
&lt;a class="anchor" href="#%d9%85%d8%ab%d8%a7%d9%84-%d8%a8%d9%86%da%86%d9%85%d8%a7%d8%b1%da%a9-%d8%b3%d8%a7%d8%af%d9%87">#&lt;/a>
&lt;/h4>
&lt;pre>&lt;code class="language-go">func BenchmarkMaxInt(b *testing.B) {
for i := 0; i &amp;lt; b.N; i++ {
_ = Max(123, 456)
}
}
func BenchmarkMaxGeneric(b *testing.B) {
for i := 0; i &amp;lt; b.N; i++ {
_ = Max[int](123, 456)
}
}
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>توضیح:&lt;/strong>&lt;br>
این بنچمارک‌ها نشان می‌دهند که در عمل، تفاوت سرعت نسخه ژنریک و نسخه معمولی minimal است، اما باید همیشه در پروژه‌های واقعی تست شوند.&lt;/p></description></item></channel></rss>