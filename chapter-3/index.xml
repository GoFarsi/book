<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>فصل سوم: همزمانی (concurrency) on زبان گو فارسی</title><link>https://book.gofarsi.ir/chapter-3/</link><description>Recent content in فصل سوم: همزمانی (concurrency) on زبان گو فارسی</description><generator>Hugo -- gohugo.io</generator><language>fa-IR</language><atom:link href="https://book.gofarsi.ir/chapter-3/index.xml" rel="self" type="application/rss+xml"/><item><title>3.1 آشنایی با همزمانی</title><link>https://book.gofarsi.ir/chapter-3/go-concurrency/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-3/go-concurrency/</guid><description>نرم‌افزارهای بزرگ به منظور توسعه راحت‌تر و قابلیت نگهداری بیشتر و همچنین پرهیز از تکرار از ده‌ها زیر برنامه کوچک‌تر تشکیل می‌شوند که به آنها توابع می‌گوییم و تمامی این زیربرنامه‌های کوچک در کنار هم اما به صورت مستقل عملکرد کلی برنامه بزرگتر را شکل می‌دهند. به عنوان مثال یک وب سرور درخواست‌های ارسال شده از سمت مرورگرها را مدیریت می کند و در پاسخ صفحات وب HTML را آماده کرده و ارائه می‌دهد و هر در خواست از طریق فراخوانی چندین برنامه کوچک رسیدگی می شود تا نتیجه را به مرورگر برگردانده شود.</description></item><item><title>3.2 گوروتین (goroutine)</title><link>https://book.gofarsi.ir/chapter-3/goroutine/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-3/goroutine/</guid><description>گوروتین ها را می توان به عنوان یک thread سبک در نظر گرفت که بصورت مستقلانه می تواند همزمان با سایر گوروتین های دیگر کارها را انجام دهد. و همچنین گوروتین ها می توانند به واسطه کانال داده ها را بین هم اشتراک گذاری و منتقل کنند.
حداکثر اندازه stack یک گوروتین در زبان گو ۱ گیگابایت می باشد.
1var maxstacksize uintptr = 1 &amp;lt;&amp;lt; 20 // enough until runtime.main sets it for real 2 3 if newsize &amp;gt; maxstacksize || newsize &amp;gt; maxstackceiling { 4 if maxstacksize &amp;lt; maxstackceiling { 5 print(&amp;#34;runtime: goroutine stack exceeds &amp;#34;, maxstacksize, &amp;#34;-byte limit\n&amp;#34;) 6 } else { 7 print(&amp;#34;runtime: goroutine stack exceeds &amp;#34;, maxstackceiling, &amp;#34;-byte limit\n&amp;#34;) 8 } 9 print(&amp;#34;runtime: sp=&amp;#34;, hex(sp), &amp;#34; stack=[&amp;#34;, hex(gp.</description></item><item><title>3.3 پکیج sync</title><link>https://book.gofarsi.ir/chapter-3/go-sync-package/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-3/go-sync-package/</guid><description>پکیج sync یکی از کاربردی ترین پکیج ها در زمینه همزمانی می باشد و یکسری تایپ و توابع برایهمگام سازی و کنترل دسترسی همزمان به داده مشترک ارائه می دهد. که پرکاربردترین آن ها :
Mutex : با استفاده از این می توانید آن بخش از داده ای که گوروتین ها بطور همزمان قصد دارند دسترسی داشته باشند را می توانید قفل کنید. RWMutex : با استفاده از این می توانید به چندین گوروتین اجازه خواندن دهید ولی فقط یک گوروتین می تواند بنویسد در یک زمان.</description></item><item><title>3.4 پکیج atomic</title><link>https://book.gofarsi.ir/chapter-3/go-atomic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-3/go-atomic/</guid><description>پکیج atomic یک حافظه atomic سطح پایین برای پیاده سازی الگوریتم های همگام سازی شده است. از مواردی که خیلی قابل اهمیت است با این پکیج شما می توانید یکسری الگوهای همگام سازی را پیاده سازی کنید. سعی کنید با دقت بیشتری از این پکیج استفاده کنید چون کارکردش خارج از safe memory هست.
به مثال زیر توجه کنید :
1package main 2 3import ( 4 &amp;#34;fmt&amp;#34; 5 &amp;#34;sync&amp;#34; 6 &amp;#34;sync/atomic&amp;#34; 7) 8 9type Cache struct { 10 mu sync.</description></item><item><title>3.5 آموزش مقابله با data race</title><link>https://book.gofarsi.ir/chapter-3/goroutine-data-race/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-3/goroutine-data-race/</guid><description>معمولا تو بحث همزمانی یکی از اتفاقاتی که خیلی ممکن است رخ دهد بحث data race است و data race زمانی رخ می دهد که ۲ یا چند گوروتین قصد دارند به یک آدرس حافظه در یک زمان دسترسی داشته باشند. حال اگر ما جلوی data race را نگیریم ممکن است تغییرات نادرست برروی مقادیر داخل خانه حافظه صورت گیرد.
راه هایی برای مقابله با data race وجود دارد که به شرح زیر است :</description></item><item><title>3.6 کانال (channel)</title><link>https://book.gofarsi.ir/chapter-3/go-channel/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-3/go-channel/</guid><description>کانال یک نوع تایپ است که داده از نوع خاصی را نگه داری میکند و امکان برقراری ارتباط و همگام سازی داده بین گوروتین ها را فراهم می کند. شما می توانید کانال ها را به عنوان خط لوله های در نظر بگیرید که این خط لوله ها به گوروتین ها متصل می شود و باعث برقراری ارتباط بین گوروتین ها می شود. این ارتباط بین گوروتین ها به هیچ قفل صریحی نیاز ندارد (منظورم mutex و &amp;hellip;) چون کانال ها بصورت داخلی قفل ها را مدیریت میکند و در زمان های مناسب و مشخص Lock و UnLock می کند.</description></item><item><title>3.7 آموزش استفاده از select</title><link>https://book.gofarsi.ir/chapter-3/go-select/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-3/go-select/</guid><description>در زبان گو select همانند switch می باشد که دارای case و default هستش اما یک فرق کلی دارد که به عملکردش برمیگردد. case های select برای عملیات ارسال و دریافت از کانال منتظر می ماند. در کل شما با استفاده از select می توانید از کانال های مختلف اطلاعات ارسال و دریافت کنید و پس از آن برروی آن اطلاعات عملیات انجام دهید.
select تا زمانی که یکی از case ها آماده شود بلاک می شود.</description></item><item><title>3.8 پکیج context</title><link>https://book.gofarsi.ir/chapter-3/go-context/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-3/go-context/</guid><description>پکیج context که یک پکیج built-in هست یکی از پرکاربرد ترین پکیج ها می باشد. که اگر شما حتی نخواسته باشید سمت این پکیج بروید به مرور زمان وقتی که جلوتر بروید با این پکیج رو به رو خواهید شد و مجبور خواهید بود این پکیج را یاد بگیرید.
این پکیج چندان بزرگ نیست شاید بتوانید توابع و چیزهایی که داخلش هست را زود یادبگیرید اما دقت کنید یک روزی این پکیج میشه بنیادی ترین قسمت از کدهایتان که باهاش کار میکنید.</description></item><item><title>3.9 تکنیک های همزمانی</title><link>https://book.gofarsi.ir/chapter-3/go-concurrency-teqniques/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-3/go-concurrency-teqniques/</guid><description>3.9.1 ارسال سیگنال انجام شدن با کانال ساختار # شما می توانید با استفاده از کانال struct یک سیگنال تکمیل شدن انجام یک کار را بفرستید.
1package main 2 3import ( 4 &amp;#34;fmt&amp;#34; 5 &amp;#34;time&amp;#34; 6) 7 8func task1(done chan struct{}) { 9 // Do some work here 10 fmt.Println(&amp;#34;doing task 1&amp;#34;) 11 12 time.Sleep(2 * time.Second) 13 14 fmt.Println(&amp;#34;task 1 has been completed&amp;#34;) 15 done &amp;lt;- struct{}{} 16} 17 18func task2(done &amp;lt;-chan struct{}) { 19 select { 20 case &amp;lt;-done: 21 // Do some work here 22 fmt.</description></item><item><title>3.10 الگو های همزمانی</title><link>https://book.gofarsi.ir/chapter-3/go-concurrency-patterns/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-3/go-concurrency-patterns/</guid><description>الگو های همزمانی را در فصل ۹ در کنار سایر الگوهای طراحی قرار دادیم یک مرجع کامل از الگوهای طراحی برای زبان گو داشته باشیم. در این بخش فقط ما خلاصه توضیحی در خصوص الگوها قرار دادیم و شما را ارجاع می دهیم به صفحه الگو :
عنوان توضیحات وضعیت Wait For Result با استفاده از الگو Wait For Result می توانید یک عملیاتی را بصورت همزمانی انجام دهید و سپس منتظر نتیجه عملیات صورت گرفته بمانید.</description></item></channel></rss>