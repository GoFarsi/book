<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><author/><title>فصل سوم: همزمانی (concurrency) on زبان گو فارسی</title><link>https://book.gofarsi.ir/chapter-3/</link><description>Recent content in فصل سوم: همزمانی (concurrency) on زبان گو فارسی</description><generator>Hugo -- gohugo.io</generator><language>fa</language><copyright>2023 GoFarsi All rights reserved</copyright><atom:link href="https://book.gofarsi.ir/chapter-3/feed.xml" rel="self" type="application/rss+xml"/><item><author/><title>3.1 آشنایی با همزمانی</title><link>https://book.gofarsi.ir/chapter-3/go-concurrency/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-3/go-concurrency/</guid><description>&lt;p>&lt;img src="../../assets/img/content/chapter3/concurrency/1.png" alt="concurrency" />&lt;/p>
&lt;p>نرم‌افزارهای بزرگ به منظور توسعه راحت‌تر و &lt;span class="tooltip" data-tooltip="Maintainability" ontouchend="toggleTooltip(this)">قابلیت نگهداری&lt;/span>
بیشتر و همچنین &lt;span class="tooltip" data-tooltip="Reusibility" ontouchend="toggleTooltip(this)">پرهیز از تکرار&lt;/span>
از ده‌ها زیر برنامه کوچک‌تر تشکیل می‌شوند که به آنها توابع می‌گوییم و تمامی این زیربرنامه‌های کوچک در کنار هم اما به صورت مستقل عملکرد کلی برنامه بزرگتر را شکل می‌دهند. به عنوان مثال یک وب سرور درخواست‌های ارسال شده از سمت مرورگرها را مدیریت می کند و در پاسخ صفحات وب HTML را آماده کرده و ارائه می‌دهد و هر در خواست از طریق فراخوانی چندین برنامه کوچک رسیدگی می شود تا نتیجه را به مرورگر برگردانده شود.&lt;/p>
&lt;p>در طول آماده‌سازی نتیجه‌‌ی هر یک از این زیربرنامه‌ها، به دلایل گوناگون از جمله تاخیر(های) شبکه، IO و &amp;hellip; اجرای زیربرنامه‌ها برای مدتی هرچند کوتاه متوقف می‌شود و این وقفه‌ها، زمان پاسخگویی نرم‌افزارها را طولانی‌تر می‌کنند؛ گاهی‌اوقات اولویت ترتیب اجرا و وابستگی/استقلال زیربرنامه‌ها، به توسعه‌دهنده این اجازه را می‌دهد که اجرای بعضی از زیربرنامه‌ها را از حالت «صف/ترتیبی» به حالت «موازی» تغییر دهد، لذا به منظور استفاده بهینه‌ از منابع و افزایش &lt;strong>عملکرد کلی&lt;/strong> نرم‌افزار از مقوله‌ای به نام &lt;span class="tooltip" data-tooltip="concurrency" ontouchend="toggleTooltip(this)">همزمانی&lt;/span>
استفاده می کنند.&lt;/p>
&lt;p>یکی از نقاط قوت در زبان Go سهولت و امنیت استفاده از &lt;span class="tooltip" data-tooltip="concurrency" ontouchend="toggleTooltip(this)">همزمانی&lt;/span>
با کمک گوروتین و کانال‌هاست که در ادامه‌ی این فصل به‌طور جامع، مباحث مربوط به آن را بررسی کرده و روش پیاده‌سازی &lt;span class="tooltip" data-tooltip="concurrency" ontouchend="toggleTooltip(this)">همزمانی&lt;/span>
در برنامه‌های زبان Go را آموزش خواهیم داد.&lt;/p>
&lt;h2 id="۳۱۱-فرق-بین-همزمانی-concurrency-و-موازی-parallelism">
۳.۱.۱ فرق بین همزمانی (concurrency) و موازی (parallelism)
&lt;a class="anchor" href="#%db%b3%db%b1%db%b1-%d9%81%d8%b1%d9%82-%d8%a8%db%8c%d9%86-%d9%87%d9%85%d8%b2%d9%85%d8%a7%d9%86%db%8c-concurrency-%d9%88-%d9%85%d9%88%d8%a7%d8%b2%db%8c-parallelism">#&lt;/a>
&lt;/h2>
&lt;p>موازی‌سازی (parallelism) یعنی چندین فرآیند به‌طور همزمان توسط چند threads یا به طور دقیق‌تر هسته پردازشی انجام شود و این هسته‌ها می‌توانند از طریق حافظه اشتراکی با هم ارتباط برقرار کنند و در نهایت نتایج فرآیندها پس از پایان با هم ترکیب می‌شوند. لذا داشتن حداقل دو یا چند هسته پردازش فیزیکی از الزامات پیاده‌سازی موازی است.&lt;/p>
&lt;p>در مقابل برنامه‌های همزمان الزاماً به‌صورت موازی اجرا نمی‌شوند و بیشتر در مورد ساختار یک برنامه است تا شیوه دقیق اجرای آن برنامه یا زیربرنامه. همزمانی به گونه‌ای است که دو یا چند کار مختلف ممکن است به طور همزمان در حال پیشرفت و انجام باشند. و در نهایت این فرآیندهای همزمان به نتایج مختلفی ختم می شوند.&lt;/p>
&lt;p>حال می‌خواهیم با یک مثال ملموس این دو مبحث را باز کنیم تا به درکی دقیق‌تر از تفاوت این‌ دو برسیم.&lt;/p>
&lt;p>تصور کنید که برنامه بزرگ ما یک کافی‌شاپ است که صفی از مشتریان سفارش خود را داده و منتظر دریافت آن می‌شوند.&lt;/p>
&lt;p>&lt;img src="../../assets/img/content/chapter3/concurrency/3.jpg" alt="serial process" />&lt;/p>
&lt;p>همانطور که از تصویر بالا متوجه می‌شوید مشتری دوم تا پایان آماده‌سازی سفارش مشتری اول باید منتظر بماند لذا به منظور بالا بردن کارایی کلی سیستم می‌توان از پردازش موازی بهره برد به این منظور با استخدام یک فرد دیگر و یک دستگاه قهوه سازی دیگر پردازش مشتریان را به صورت موازی انجام خواهیم داد.&lt;/p>
&lt;p>&lt;img src="../../assets/img/content/chapter3/concurrency/4.jpg" alt="parallel process" />&lt;/p>
&lt;p>چنانچه پیشتر هم گفته شد ما با محدودیت منابع روبرو هستیم و برای بالا بردن تعداد پردازش‌های موازی نیازمند خرید دستگاه قهوه ساز جدید و استخدام نیروی جدید هستیم.
تا به اینجا هدف این بود که مشکل انتظار طولانی مدت مشتریان در صف را از طریق پردازش موازی حل کنیم اما این کار بسیار پرهزینه است راه حل دیگری هم وجود دارد که همان همزمانی است.
بدیهی است وقفه ایجاد شده برای آماده‌سازی سفارش تنها محدود به دستگاه قهوه‌ساز نیست و بخشی از آن مربوط به زمان سپری شده برای دریافت سفارش از مشتریان توسط باریستا و مراجعه به دستگاه برای آماده‌سازی آن می‌شود لذا می‌توان با استخدام یک نیروی جدید بدون خرید دستگاه قهوه‌ساز جدید سفارش مشتریان را به صورت جداگانه پردازش کرده و به‌جای صف سفارش یک صف انتظار آماده‌سازی تشکیل داد به این ترتیب مدت زمان انتظار افراد برای دریافت سفارش کوتاه تر شده و &lt;strong>عملکرد کلی&lt;/strong> سیستم افزایش می‌یابد.&lt;/p>
&lt;p>&lt;img src="../../assets/img/content/chapter3/concurrency/5.jpg" alt="concurrent process" />&lt;/p>
&lt;p>البته هیچ چیز ما را محدود به پردازش سریال در حالت همزمانی نمی‌کند یعنی در صورت تشکیل صف طولانی می توانیم عملکرد موازی را اینجا هم اعمال کنیم به تصویر پایین دقت کنید.&lt;/p>
&lt;p>&lt;img src="../../assets/img/content/chapter3/concurrency/6.jpg" alt="parallel concurrent process" />&lt;/p>
&lt;p>همانطور که مشاهده می‌شود در پردازش همزمان ما با تغییر ساختار به صورت موازی یا غیرموازی عملکرد کلی سیستم را افزایش داده‌ایم.&lt;/p>
&lt;p>نکته: تا به اینجا بارها برروی عملکرد کلی سیستم تأکید نموده‌ایم. این مسئله از آنجا حائز اهمیت است که خواننده باید به درکی درست از مقوله همزمانی برسد. ما در همزمانی سرعت پردازش یک درخواست را افزایش نمی‌دهیم در حقیقت به دلیل پیچیده‌تر شدن پیاده‌سازی و روند اجرا، زمان پردازش یک درخواست منحصر به فرد طولانی‌تر هم می‌شود اما آنچه در مبحث همزمانی بهبود می‌یابد عملکرد کلی سیستم است. لذا استفاده از همزمانی تنها در صورتی می‌تواند به بهبود کارایی یک سیستم نرم‌افزاری منجر شود که صفی از درخواست‌ها تشکیل شده باشد و تأخیرات مختلف مانع از پردازش بی‌درنگ درخواست‌ها در اکثر مواقع نشود لذا با استفاده از پیاده‌سازی همزمانی از منابع سیستم در زمان انتظار درخواست‌ها به صورت بهینه استفاده خواهد شد.&lt;/p>
&lt;p>در زبان Go با استفاده از &lt;span class="tooltip" data-tooltip="environment variable" ontouchend="toggleTooltip(this)">متغیرهای محیطی&lt;/span>
GOMAXPROCS در کنار همزمانی از موازی‌سازی (parallelism) هم استفاده می‌شود. هرچند بطور پیش فرض برنامه‌ای که با زبان گو نوشته می‌شود از تمامی هسته‌های CPU استفاده می‌کند ولی شما می‌توانید با &lt;strong>GOMAXPROCS&lt;/strong> تعداد هسته‌ها را محدود کنید. لازم به ذکر است که در زبان Go شما به طور مستقیم نمی‌توانید اجرای موازی زیربرنامه‌ای را به کامپایلر دیکته کنید و تصمیم‌گیری در این مورد به عهده Go Runtime Scheduler است.&lt;/p>
&lt;h2 id="۳۱۲-توضیح-مختصر-در-خصوص-go-runtime-scheduler">
۳.۱.۲ توضیح مختصر در خصوص Go Runtime Scheduler
&lt;a class="anchor" href="#%db%b3%db%b1%db%b2-%d8%aa%d9%88%d8%b6%db%8c%d8%ad-%d9%85%d8%ae%d8%aa%d8%b5%d8%b1-%d8%af%d8%b1-%d8%ae%d8%b5%d9%88%d8%b5-go-runtime-scheduler">#&lt;/a>
&lt;/h2>
&lt;p>در زبان گولنگ نحوه اجرا و مدیریت گوروتین ها در سطح زبان انجام می شود، بر خلاف برخی زبان ها که مدیریت و اجرای ترد ها بر عهده سیستم عامل است.&lt;/p>
&lt;p>نحوه اجرای گوروتین ها چگونه است؟ در قدم اول گوروتین ها وارد یک صف به اسم Global run queue می شوند. سپس Go run scheduler بر اساس تعداد هسته های لاجیکال، از سیستم عامل ترد می گیرد. سپس گوروتین ها‌را بین ترد های دریافت شده تقسیم می کند تا اجرا شوند.&lt;/p>
&lt;p>نکته: همانطور که گفته شد، شما می توانید تعداد هسته هایی که گولنگ می تواند استفاده کند را به‌صورت دستی تنظیم کنید. توجه داشته باشید خود گولنگ به‌صورت پیشفرض از قدرت تمامی هسته ها استفاده می کند.&lt;/p></description></item><item><author/><title>3.2 گوروتین (goroutine)</title><link>https://book.gofarsi.ir/chapter-3/goroutine/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-3/goroutine/</guid><description>&lt;p>گوروتین ها را می توان به عنوان یک thread سبک در نظر گرفت که بصورت مستقل می توانند همزمان با سایر گوروتین های دیگر کارها را انجام دهند. و همچنین گوروتین ها می توانند به واسطه کانال داده ها را بین هم به اشتراک گذاشته و منتقل کنند.&lt;/p>
&lt;blockquote class="book-hint info">
&lt;p>حداکثر اندازه stack یک گوروتین در زبان گو ۱ گیگابایت می باشد.&lt;/p>
&lt;pre>&lt;code class="language-go">var maxstacksize uintptr = 1 &amp;lt;&amp;lt; 20 // enough until runtime.main sets it for real
if newsize &amp;gt; maxstacksize || newsize &amp;gt; maxstackceiling {
if maxstacksize &amp;lt; maxstackceiling {
print(&amp;quot;runtime: goroutine stack exceeds &amp;quot;, maxstacksize, &amp;quot;-byte limit\n&amp;quot;)
} else {
print(&amp;quot;runtime: goroutine stack exceeds &amp;quot;, maxstackceiling, &amp;quot;-byte limit\n&amp;quot;)
}
print(&amp;quot;runtime: sp=&amp;quot;, hex(sp), &amp;quot; stack=[&amp;quot;, hex(gp.stack.lo), &amp;quot;, &amp;quot;, hex(gp.stack.hi), &amp;quot;]\n&amp;quot;)
throw(&amp;quot;stack overflow&amp;quot;)
}
&lt;/code>&lt;/pre>
&lt;/blockquote>
&lt;p>در زیر با استفاده از کلمه کلیدی &lt;code>go&lt;/code> یک نمونه گوروتین ایجاد کردیم و توجه کنید شما فقط توابع را می توانید به صورت همزمان اجرا کنید.&lt;/p>
&lt;pre>&lt;code class="language-go">go functionName(parameters)
&lt;/code>&lt;/pre>
&lt;p>به عنوان مثال :&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;fmt&amp;quot;
&amp;quot;time&amp;quot;
)
func main() {
go start()
fmt.Println(&amp;quot;Started&amp;quot;)
time.Sleep(1 * time.Second)
fmt.Println(&amp;quot;Finished&amp;quot;)
}
func start() {
fmt.Println(&amp;quot;In Goroutine&amp;quot;)
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-shell">$ go run main.go
Started
In Goroutine
Finished
&lt;/code>&lt;/pre>
&lt;p>در کد فوق ما تابع &lt;code>()start&lt;/code> را توسط کلمه کلیدی &lt;code>go&lt;/code> داخل گوروتین قرار دادیم و این تابع بصورت مستقل از تابع main اجرا شد. اما این وسط یک نکته ای وجود دارد. همانطور که گفتیم تابع اصلی جهت اجرا برنامه های زبان گو تابع main می باشد و اگر شما تابعی را توسط گوروتین از main جدا کنید ممکن است فرآیندهای داخل تابع main زود اتمام شود و شما خروجی تابعی که داخل گوروتین گذاشتید را نبینید.&lt;/p>
&lt;p>ما در کد بالا با استفاده از تابع Sleep پکیج time یک وقفه ۱ ثانیه گذاشتیم و این وقفه باعث شد تا عملیات داخل تابع ()start تمام شود و خروجی نمایش داده شود.&lt;/p>
&lt;p>خب حالا بزارید مثال فوق را بدون وقفه تست کنیم :&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;fmt&amp;quot;
)
func main() {
go start()
fmt.Println(&amp;quot;Started&amp;quot;)
fmt.Println(&amp;quot;Finished&amp;quot;)
}
func start() {
fmt.Println(&amp;quot;In Goroutine&amp;quot;)
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-shell">$ go run main.go
Started
Finished
&lt;/code>&lt;/pre>
&lt;p>در خروجی بالا هرگز پیغام داخل تابع ()start چاپ نمی شود.&lt;/p>
&lt;pre>&lt;code class="language-go">In Goroutine
&lt;/code>&lt;/pre>
&lt;p>علت اصلی این اتفاق این است که تابع main خودش داخل یک گوروتین اجرا می شود و زمانیکه شما یک تابع دیگری را داخل گوروتین قرار می دهید تا لحظه ای که تابع برای اجرا برنامه ریزی شود برنامه اتمام می شود.&lt;/p>
&lt;h2 id="321-گوروتین-تابع-main">
3.2.1 گوروتین تابع main
&lt;a class="anchor" href="#321-%da%af%d9%88%d8%b1%d9%88%d8%aa%db%8c%d9%86-%d8%aa%d8%a7%d8%a8%d8%b9-main">#&lt;/a>
&lt;/h2>
&lt;p>تابع main را وقتی می توانید ایجاد کنید که نام پکیج شما main و گوروتین اصلی شما main باشد. همه گوروتین ها از تابع main شروع می شوند و گوروتین ها بطور همزمان باز می توانند سایر گوروتین ها را اجرا کنند.&lt;/p>
&lt;p>زمانیکه شما تابع main را فراخوانی می کنید بخش اصلی و شروع برنامه شما است. و اگر تابع main شما به هر دلیلی متوقف شود یا اتمام شود سایر گوروتین ها از بین می روند.&lt;/p>
&lt;p>گوروتین ها چیزی به نام parent یا child ندارند. زمانیکه شما یک گوروتین را اجرا می کنید این گوروتین در کنار سایر گوروتین ها اجرا می شود و کارش را انجام می دهد. زمانی کار یک گوروتین تمام می شود که تابع بازگشت (return) داشته باشد.&lt;/p>
&lt;p>بزارید یک مثال بزنیم تا ببینید چیزی به نام parent یا child برای گوروتین نداریم :&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;fmt&amp;quot;
&amp;quot;time&amp;quot;
)
func main() {
go start()
fmt.Println(&amp;quot;Started&amp;quot;)
time.Sleep(1 * time.Second)
fmt.Println(&amp;quot;Finished&amp;quot;)
}
func start() {
go start2()
fmt.Println(&amp;quot;In Goroutine&amp;quot;)
}
func start2() {
fmt.Println(&amp;quot;In Goroutine2&amp;quot;)
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-shell">$ go run main.go
Started
In Goroutine
In Goroutine2
Finished
&lt;/code>&lt;/pre>
&lt;p>در کد بالا داخل تابع main ما تابع start را با گوروتین اجرا کردیم و داخل تابع start تابع start2 را با گوروتین اجرا کردیم. این ۲ تابع start و start2 در کنار هم اجرا می شود و در نهایت کارشان اتمام می شود و هیچ کدام منتظر دیگری نخواهد بود.&lt;/p>
&lt;h2 id="322-ایجاد-گوروتین-چندتایی">
3.2.2 ایجاد گوروتین چندتایی
&lt;a class="anchor" href="#322-%d8%a7%db%8c%d8%ac%d8%a7%d8%af-%da%af%d9%88%d8%b1%d9%88%d8%aa%db%8c%d9%86-%da%86%d9%86%d8%af%d8%aa%d8%a7%db%8c%db%8c">#&lt;/a>
&lt;/h2>
&lt;p>شما می توانید n تا گوروتین بطور همزمان در کنار هم اجرا کنید, در زیر یک مثال زدیم ببینید :&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;fmt&amp;quot;
&amp;quot;time&amp;quot;
)
func execute(id int) {
fmt.Printf(&amp;quot;id: %d\n&amp;quot;, id)
}
func main() {
fmt.Println(&amp;quot;Started&amp;quot;)
for i := 0; i &amp;lt; 10; i++ {
go execute(i)
}
time.Sleep(time.Second * 2)
fmt.Println(&amp;quot;Finished&amp;quot;)
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-shell">$ go run main.go
Started
id: 4
id: 9
id: 1
id: 0
id: 8
id: 2
id: 6
id: 3
id: 7
id: 5
Finished
&lt;/code>&lt;/pre>
&lt;p>در کد فوق ما یک حلقه قرار دادیم از i برابر ۰ تا ۱۰ که داخلش تابع execute را ۱۰ بار اجرا می کند. و هربار اجرا می شود خروجی های مختلفی دارد و ترتیبی درست نخواهید علت این اتفاق این است بطور همزمان اجرا می شوند در کنار هم و هرکدام از گوروتین ها زودتر کارش تمام شود خروجی را نمایش می دهد. به همین دلیل ترتیب درستی نخواهد داشت.&lt;/p>
&lt;h2 id="323-زمانبندی-گوروتین-ها">
3.2.3 زمانبندی گوروتین ها
&lt;a class="anchor" href="#323-%d8%b2%d9%85%d8%a7%d9%86%d8%a8%d9%86%d8%af%db%8c-%da%af%d9%88%d8%b1%d9%88%d8%aa%db%8c%d9%86-%d9%87%d8%a7">#&lt;/a>
&lt;/h2>
&lt;p>زمانیکه یک برنامه گو اجرا می شود. go runtime رشته های (threads) سیستم عامل را راه اندازی می کند که معادل تعداد CPU های logical قابل استفاده برای فرآیند فعلی است. هر یک از logical CPU ها یک هسته مجازی دارد.&lt;/p>
&lt;pre>&lt;code class="language-shell">virtual_cores = x*number_of_physical_cores
&lt;/code>&lt;/pre>
&lt;p>در کد بالا x برابر است با تعداد thread ها به ازای هر هسته از CPU&lt;/p>
&lt;p>در گو ما یک تابع به نام NumCPU داخل پکیج runtime داریم که می توانید تعداد logical Proccessors موجود برای برنامه گو را ببینید.&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;fmt&amp;quot;
&amp;quot;runtime&amp;quot;
)
func main() {
fmt.Println(runtime.NumCPU())
}
&lt;/code>&lt;/pre>
&lt;p>روی سیستم من عدد 8 را چاپ کرد یعنی سیستم من ۴ هسته که هر هسته دارای ۲ threads است. که قابل استفاده برای برنامه گو روی سیستم من می باشد.&lt;/p></description></item><item><author/><title>3.3 پکیج sync</title><link>https://book.gofarsi.ir/chapter-3/go-sync-package/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-3/go-sync-package/</guid><description>&lt;p>پکیج &lt;code>sync&lt;/code> یکی از کاربردی ترین پکیج ها در زمینه همزمانی می باشد و یکسری تایپ و توابع برای&lt;span class="tooltip" data-tooltip="synchronize" ontouchend="toggleTooltip(this)">همگام سازی&lt;/span>
و کنترل دسترسی همزمان به داده های مشترک ارائه می دهد. پرکاربرد ترین ویژگی های این پکیج شامل موارد زیر می شود :&lt;/p>
&lt;ul>
&lt;li>&lt;code>Mutex&lt;/code> : با استفاده از این تایپ می توانید آن بخش از داده ای که گوروتین ها بطور همزمان قصد دارند دسترسی داشته باشند را قفل کنید.&lt;/li>
&lt;li>&lt;code>RWMutex&lt;/code> : با استفاده از این تایپ می توانید به چندین گوروتین اجازه خواندن دهید اما فقط یک گوروتین قابلیت نوشتن در یک زمان مشخص را دارد.&lt;/li>
&lt;li>&lt;code>WaitGroup&lt;/code>: یک هماهنگ کننده گوروتین می باشد، برای اینکه ترتیب عملیات ها در هنگام همزمانی رعایت شود.&lt;/li>
&lt;li>&lt;code>Once&lt;/code>: این تایپ تضمین می کند که یک تابع فقط یک بار اجرا شود.&lt;/li>
&lt;li>&lt;code>Pool&lt;/code>: مجموعه‌ای از آبجکت های موقت که امکان ذخیره و دریافت دارند بدون اینکه بخشی از حافظه را اشغال کنند.&lt;/li>
&lt;li>&lt;code>Cond&lt;/code>:با استفاده از Cond می توانید چندین گوروتین ایجاد کنید و اجرای فرآیند آن ها را منتظر وقوع یک رویداد قرار دهید.&lt;/li>
&lt;/ul>
&lt;blockquote class="book-hint info">
توجه کنید که پکیج &lt;code>sync&lt;/code> فقط و فقط برای مدیریت و همگام سازی دسترسی های گوروتین ها به یک داده مشترک استفاده می شود.
&lt;/blockquote>
&lt;h2 id="331-mutex">
3.3.1 Mutex
&lt;a class="anchor" href="#331-mutex">#&lt;/a>
&lt;/h2>
&lt;p>در پکیج &lt;code>sync&lt;/code> یک تایپ به نام &lt;code>Mutex&lt;/code> وجود دارد که به شما این امکان را می دهد دسترسی به داده های مشترک را &lt;span class="tooltip" data-tooltip="synchronize" ontouchend="toggleTooltip(this)">همگام سازی&lt;/span>
کنید. با استفاده از این قابلیت در واقع منابع مشترک محافظت شده و این اطمینان به شما داده می شود که تنها یک گوروتین در یک زمان مشخص، به دیتای مشترک بین گوروتین ها دسترسی دارد.
تایپ Mutex شامل دو متد مهم Lock و Unlock است. وقتی Lock فراخوانی می شود فقط و فقط یک گوروتین می تواند برروی آن بخش از داده کار کند و تا زمانیکه شما Unlock نکنید سایر گوروتین ها نمی توانند به دیتای مورد نظر شما دسترسی داشته باشند و تا زمانیکه Unlock صورت گیرد سایر گوروتین هادر حالت انتظار باقی می مانند.&lt;/p>
&lt;p>به مثال زیر توجه کنید :&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;fmt&amp;quot;
&amp;quot;sync&amp;quot;
&amp;quot;time&amp;quot;
)
var count int
func main() {
mu := new(sync.Mutex)
go increment(mu)
go increment(mu)
go increment(mu)
go increment(mu)
time.Sleep(time.Second)
}
func increment(mu *sync.Mutex) {
mu.Lock()
defer mu.Unlock()
count++
fmt.Printf(&amp;quot;Incrementing: %d\n&amp;quot;, count)
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-shell">$ go run main.go
Incrementing: 1
Incrementing: 2
Incrementing: 3
Incrementing: 4
&lt;/code>&lt;/pre>
&lt;center>&lt;a href="#">
&lt;img src="../../assets/img/content/chapter3/sync/1.jpg" alt="sync mutex">
&lt;/a>&lt;/center>
&lt;p>در بالا ما یک تابع به نام increment ایجاد کردیم و به عنوان ورودی تایپ Mutex را بصورت پوینتر پاس دادیم. سپس با استفاده از توابع Lock و Unlock برای افزایش مقدار count یک قفل گذاشتیم.&lt;/p>
&lt;p>حال ۴ تا گوروتین داریم که قصد دارند همزمان روی بخش مشترک از حافظه عملیاتی را انجام دهند در اینجا ما با استفاده Mutex جلوی دسترسی همزمان گوروتین ها به حافظه را گرفتیم و فقط یک گوروتین می تواند عملیات انجام دهد و تا زمانیکه شما Unlock نکنید سایر گوروتین ها منتظر می مانند.&lt;/p>
&lt;h3 id="3311-سناریوهای-استفاده">
3.3.1.1 سناریوهای استفاده
&lt;a class="anchor" href="#3311-%d8%b3%d9%86%d8%a7%d8%b1%db%8c%d9%88%d9%87%d8%a7%db%8c-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87">#&lt;/a>
&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>همگام سازی دسترسی به متغیرهای مشترک:&lt;/strong> یک mutex می تواند برای همگام سازی دسترسی به متغیرهای مشترک بین چندین گوروتین استفاده شود. این می تواند در مواردی مفید باشد که چندین گوروتین نیاز به خواندن یا به روز رسانی یک متغیر به طور همزمان دارند.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>هماهنگی دسترسی به حالت مشترک:&lt;/strong> یک mutex می تواند برای هماهنگ کردن دسترسی به حالت مشترک بین چندین گوروتین استفاده شود. به عنوان مثال، ممکن است از یک mutex استفاده کنید تا اطمینان حاصل کنید که فقط یک گوروتین می تواند یک ساختار داده مشترک را در یک زمان تغییر دهد.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>پیاده سازی الگوهای تولیدکننده-مصرف کننده (producer-consumer):&lt;/strong> یک mutex می تواند برای پیاده سازی الگوهای تولیدکننده-مصرف کننده استفاده شود، که در آن یک یا چند گوروتین داده تولید می کنند و یک یا چند گوروتین آن را مصرف می کنند. mutex می تواند برای همگام سازی دسترسی به ساختار داده مشترک که داده ها را نگه می دارد استفاده شود.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;blockquote class="book-hint warning">
&lt;p>&lt;strong>۲ نکته خیلی مهم&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>سعی کنید پس از اینکه تابع Lock را فراخوانی میکنید تابع Unlock را داخل defer قرار دهید.&lt;/li>
&lt;li>زمانیکه قصد دارید Mutex را به عنوان پارامتر ورودی برای توابع تعریف کنید بهتر است از نوع &lt;span class="tooltip" data-tooltip="pointer" ontouchend="toggleTooltip(this)">اشاره گر&lt;/span>
باشد.&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;h2 id="332-rwmutex">
3.3.2 RWMutex
&lt;a class="anchor" href="#332-rwmutex">#&lt;/a>
&lt;/h2>
&lt;p>در پکیج &lt;code>sync&lt;/code> یک تایپ به نام &lt;code>RWMutex&lt;/code> وجود دارد که عملیات خواندن و نوشتن برروی یک داده مشترک را &lt;span class="tooltip" data-tooltip="synchronize" ontouchend="toggleTooltip(this)">همگام سازی&lt;/span>
می کند. شما می توانید به چندین گوروتین اجازه خواندن یک داده مشترک را بدهید ولی فقط یک گوروتین می تواند عملیات نوشتن را برروی آن داده مشترک انجام دهد.&lt;/p>
&lt;p>برخی مواقع ممکن است دسترسی به یک مقدار مشترک بین گوروتین ها‌را محدود کنیم اما بر اساس شرایط خاص. مثلا همه ی گورتونین ها بتوانند عملیات خواندن را انجام دهند، اما در آن واحد فقط یک گوروتین بتواند بنویسد.&lt;/p>
&lt;p>در زیر یک مثال قرار دادیم توجه کنید :&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;fmt&amp;quot;
&amp;quot;math/rand&amp;quot;
&amp;quot;strings&amp;quot;
&amp;quot;sync&amp;quot;
&amp;quot;time&amp;quot;
)
func init() {
rand.Seed(time.Now().Unix())
}
func sleep() {
time.Sleep(time.Duration(rand.Intn(1000))*time.Millisecond)
}
func reader(c chan int, m *sync.RWMutex, wg *sync.WaitGroup) {
sleep()
m.RLock()
c &amp;lt;- 1
sleep()
c &amp;lt;- -1
m.RUnlock()
wg.Done()
}
func writer(c chan int, m *sync.RWMutex, wg *sync.WaitGroup) {
sleep()
m.Lock()
c &amp;lt;- 1
sleep()
c &amp;lt;- -1
m.Unlock()
wg.Done()
}
func main() {
var m sync.RWMutex
var rs, ws int
rsCh := make(chan int)
wsCh := make(chan int)
go func() {
for {
select {
case n := &amp;lt;-rsCh:
rs += n
case n := &amp;lt;-wsCh:
ws += n
}
fmt.Printf(&amp;quot;%s%s\n&amp;quot;, strings.Repeat(&amp;quot;R&amp;quot;, rs),
strings.Repeat(&amp;quot;W&amp;quot;, ws))
}
}()
wg := sync.WaitGroup{}
for i := 0; i &amp;lt; 10; i++ {
wg.Add(1)
go reader(rsCh, &amp;amp;m, &amp;amp;wg)
}
for i := 0; i &amp;lt; 3; i++ {
wg.Add(1)
go writer(wsCh, &amp;amp;m, &amp;amp;wg)
}
wg.Wait()
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-shell">$ go run main.go
R
RR
R
RR
R
W
R
RR
RRR
RRRR
RRRRR
RRRRRR
RRRRRRR
RRRRRR
RRRRR
RRRR
RRR
RR
R
W
W
&lt;/code>&lt;/pre>
&lt;h2 id="333-waitgroup">
3.3.3 WaitGroup
&lt;a class="anchor" href="#333-waitgroup">#&lt;/a>
&lt;/h2>
&lt;p>یک ساختاری داخل پکیج &lt;code>sync&lt;/code> به نام &lt;code>WaitGroup&lt;/code> وجود دارد. معمولا برای منتظر ماندن برای پایان اجرای گروهی از گوروتین ها استفاده می شود. این ساختار ۳ متد دارد که به شرح زیر می باشد:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Add:&lt;/strong> این متد که به عنوان ورودی عدد می گیرد تعداد گوروتین هایی که قرار است منتظر بمانند را تعیین میکند.&lt;/li>
&lt;li>&lt;strong>Done:&lt;/strong> این تابع زمانی استفاده می شود که فرآیند داخل هریک از گوروتین ها به اتمام برسد.&lt;/li>
&lt;li>&lt;strong>Wait:&lt;/strong> این متد کد ما را بلاک می کند تا زمانیکه سیگنال Done از تمامی گوروتین ها دریافت کند.&lt;/li>
&lt;/ul>
&lt;p>بگذارید با یک مثال توضیح دهیم:&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;fmt&amp;quot;
&amp;quot;sync&amp;quot;
&amp;quot;time&amp;quot;
)
func main() {
var wg sync.WaitGroup
wg.Add(2)
go sleep(&amp;amp;wg, time.Second*1)
go sleep(&amp;amp;wg, time.Second*2)
wg.Wait()
fmt.Println(&amp;quot;All goroutines finished&amp;quot;)
}
func sleep(wg *sync.WaitGroup, t time.Duration) {
defer wg.Done()
time.Sleep(t)
fmt.Println(&amp;quot;Finished Execution&amp;quot;)
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-shell">$ go run main.go
Finished Execution
Finished Execution
All goroutines finished
&lt;/code>&lt;/pre>
&lt;p>در بالا ما یک متغیر از ساختار WaitGroup ایجاد کردیم و پس از ایجاد متد &lt;strong>Add&lt;/strong> را فراخوانی کردیم و تعداد گوروتین هایی که قرار است منتظر بماند را مشخص کردیم. سپس آدرس حافظه متغیر wg را به تابع sleep به عنوان ورودی پاس دادیم و در نهایت داخل تابع sleep با استفاده از &lt;strong>defer&lt;/strong> متد &lt;strong>Done&lt;/strong> را فراخوانی کردیم.&lt;/p>
&lt;p>زمانیکه عملیات تابع sleep اتمام می شود متد Done فراخوانی می شود و یک گوروتین از لیست گوروتین های آبجکت WaitGroup کم می شود.&lt;/p>
&lt;pre>&lt;code class="language-go">// Done decrements the WaitGroup counter by one.
func (wg *WaitGroup) Done() {
wg.Add(-1)
}
&lt;/code>&lt;/pre>
&lt;p>حال وقتی فرآیند ۲ تا گوروتین اتمام شود اون بخش از کد از حالت بلاک بودن خارج می شود.&lt;/p>
&lt;blockquote class="book-hint info">
&lt;p>&lt;strong>۳ نکته خیلی مهم&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>ساختار WaitGroup یکی از پرکاربرد ترین قابلیت ها برای بحث همزمانی می باشد و برخی اوقات برای جلوگیری از Data race و همچنین برای ترتیب دهی عملیات همزمانی هم می توان از این استفاده کرد.&lt;/li>
&lt;li>سعی کنید WaitGroup را بصورت اشاره گر به توابعی که داخل گوروتین قرار دارند پاس دهید.&lt;/li>
&lt;li>هیچوقت تعداد گوروتین را بیشتر یا کمتر از اون تعدادی که دارید به متد Add ‌ندهید چون با خطای Panic مواجه خواهید شد.&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;h2 id="334-once">
3.3.4 Once
&lt;a class="anchor" href="#334-once">#&lt;/a>
&lt;/h2>
&lt;p>در پکیج &lt;code>sync&lt;/code> ما یک تایپ داریم به نام &lt;code>Once&lt;/code> که برای اطمینان از اینکه یک تابع فقط یکبار فراخوانی می شود استفاده می شود. شما فرض کنید قصد دارید در طول برنامه از یک آبجکت فقط یک instance داشته باشید می توانید با استفاده از Once این کار را انجام دهید (شما با استفاده از Once می توانید الگو طراحی &lt;a href="https://book.gofarsi.ir/chapter-9/creational-patterns/go-singleton-pattern/">Singleton&lt;/a> را پیاده سازی کنید.)&lt;/p>
&lt;p>به مثال زیر توجه کنید:&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;fmt&amp;quot;
&amp;quot;sync&amp;quot;
)
type singleton struct {
data string
}
var instance *singleton
var once sync.Once
func GetInstance() *singleton {
once.Do(func() {
instance = &amp;amp;singleton{data: &amp;quot;some data&amp;quot;}
})
return instance
}
func main() {
s1 := GetInstance()
s2 := GetInstance()
if s1 == s2 {
fmt.Println(&amp;quot;Same instance&amp;quot;)
} else {
fmt.Println(&amp;quot;Different instances&amp;quot;)
}
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-shell">$ go run main.go
Same instance
&lt;/code>&lt;/pre>
&lt;p>در مثال فوق ما یک تابع داریم به نام GetInstance که به عنوان خروجی ساختار singleton را بصورت اشاره گر ارائه می دهد. قبل از تابع ۲ تا متغیر تعریف کردیم به نام once و instance که داخل تابع GetInstance از متد Do متغیر once یک تابع inline را قرار دادیم که فقط یک آبجکت از ساختار singleton می سازد و داخل متغیر instance قرار می دهد. در نهایت instance بازگشت داده می شود.&lt;/p>
&lt;h2 id="335-pool">
3.3.5 Pool
&lt;a class="anchor" href="#335-pool">#&lt;/a>
&lt;/h2>
&lt;p>در نسخه ۱.۳ زبان گو امکانی تایپی به نام Pool در پکیج sync که امکان ایجاد استخر آبجکت ها بطور موقت بدون اینکه بخواهد بخشی از حافظه را اشتغال کند اضافه شد. هر آبجکتی که در Pool ذخیره شود بطور خودکار در هرزمانی بدون اینکه اطلاع رسانی کند حذف می شود. امکان استفاده مجدد از آبجکت هایی که داخل استخر می گیرند وجود دارد و این باعث می شود سربار استفاده حافظه کاهش یابد.&lt;/p>
&lt;center>&lt;a href="#">
&lt;img src="../../assets/img/content/chapter3/sync/2.gif" alt="sync pool">
&lt;/a>&lt;/center>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;bytes&amp;quot;
&amp;quot;io&amp;quot;
&amp;quot;os&amp;quot;
&amp;quot;sync&amp;quot;
&amp;quot;time&amp;quot;
)
var bufPool = sync.Pool{
New: func() any {
// The Pool's New function should generally only return pointer
// types, since a pointer can be put into the return interface
// value without an allocation:
return new(bytes.Buffer)
},
}
// timeNow is a fake version of time.Now for tests.
func timeNow() time.Time {
return time.Unix(1136214245, 0)
}
func Log(w io.Writer, key, val string) {
b := bufPool.Get().(*bytes.Buffer)
b.Reset()
// Replace this with time.Now() in a real logger.
b.WriteString(timeNow().UTC().Format(time.RFC3339))
b.WriteByte(' ')
b.WriteString(key)
b.WriteByte('=')
b.WriteString(val)
w.Write(b.Bytes())
bufPool.Put(b)
}
func main() {
Log(os.Stdout, &amp;quot;path&amp;quot;, &amp;quot;/search?q=flowers&amp;quot;)
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-shell">$ go run main.go
2006-01-02T15:04:05Z path=/search?q=flowers
&lt;/code>&lt;/pre>
&lt;p>در بالا ما یک متغیر به نام bufPool ایجاد کردیم که یک آبجکت از نوع bytes.Buffer ایجاد می کند. سپس داخل تابع Log ما با استفاده از متد Get آبجکت مورد نظر را از Pool خارج و داخل متغیر b قرار دادیم و پس از آن عملیات لازم را برروی Buffer انجام و در نهایت با استفاده از متد Put آبجکت را به Pool اضافه کردیم. حالا اتفاقی که صورت گرفته ما عملیاتی که نیاز داشتیم را برروی آبجکت انجام دادیم بدون اینکه بخوایم بخشی از حافظه را درگیر کنیم.&lt;/p>
&lt;h3 id="3351-بنچمارک-در-خصوص-pool">
3.3.5.1 بنچمارک در خصوص Pool
&lt;a class="anchor" href="#3351-%d8%a8%d9%86%da%86%d9%85%d8%a7%d8%b1%da%a9-%d8%af%d8%b1-%d8%ae%d8%b5%d9%88%d8%b5-pool">#&lt;/a>
&lt;/h3>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;sync&amp;quot;
&amp;quot;testing&amp;quot;)
type Person struct {
Age int
}
var personPool = sync.Pool{
New: func() interface{} { return new(Person) },
}
func BenchmarkWithoutPool(b *testing.B) {
var p *Person
b.ReportAllocs()
b.ResetTimer()
for i := 0; i &amp;lt; b.N; i++ {
for j := 0; j &amp;lt; 10000; j++ {
p = new(Person)
p.Age = 23
}
}
}
func BenchmarkWithPool(b *testing.B) {
var p *Person
b.ReportAllocs()
b.ResetTimer()
for i := 0; i &amp;lt; b.N; i++ {
for j := 0; j &amp;lt; 10000; j++ {
p = personPool.Get().(*Person)
p.Age = 23
personPool.Put(p)
}
}
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-shell">$ go test -bench=. -benchmem
goos: linux
goarch: amd64
pkg: pool
cpu: Intel(R) Core(TM) i5-3570 CPU @ 3.40GHz
BenchmarkWithoutPool-4 5262 213177 ns/op 80000 B/op 10000 allocs/op
BenchmarkWithPool-4 7699 152788 ns/op 0 B/op 0 allocs/op
PASS
ok pool 2.343s
&lt;/code>&lt;/pre>
&lt;h3 id="3352-مثال-های-کاربردی">
3.3.5.2 مثال های کاربردی
&lt;a class="anchor" href="#3352-%d9%85%d8%ab%d8%a7%d9%84-%d9%87%d8%a7%db%8c-%da%a9%d8%a7%d8%b1%d8%a8%d8%b1%d8%af%db%8c">#&lt;/a>
&lt;/h3>
&lt;p>&lt;strong>مثال اول :&lt;/strong>&lt;/p>
&lt;p>فرض کنید شما می خواهید یک فایل csv را با کلی رکورد parse کنید. هر رکورد نیازمند این است که داخل یک ساختاری قرار بگیرد و ایجاد یک ساختار باعث می شود بخشی از حافظه اختصاص یابد به آن ساختار. حالا فکر کنید میلیون ها رکورد داشته باشید و این تخصیص حافظه می تواند باعث توقف برنامه شود.&lt;/p>
&lt;p>حالا برای اینکه بخواهیم جلوی این اتفاق را بگیریم و سربار را کاهش دهیم بهتر است ما از sync.Pool استفاده کنیم و ساختارها را داخل استخر قرار دهیم. و زمانیکه هرکدام از ساختارها مورد نیاز نباشد می توانند داخل استخر قرار گیرند و مجدد استفاده شوند. اینکار باعث می شود بطور خیلی قابل توجهی تعداد تخصیص حافظه کاهش یابد و عملکرد برنامه چند برابر شود.&lt;/p>
&lt;p>&lt;strong>مثال دوم :&lt;/strong>&lt;/p>
&lt;p>موارد استفاده دیگر از sync.Pool برای ذخیره کردن آبجکت های پرکاربرد نظیر کانکشن دیتابیس یا شبکه و همچنین آبجکت هایی که قصد داریم برروی آن عملیات serialize و deserialize انجام دهیم.&lt;/p>
&lt;h2 id="336-cond">
3.3.6 Cond
&lt;a class="anchor" href="#336-cond">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>پکیج &lt;code>sync.Cond&lt;/code>&lt;/strong> یکی از ابزارهای پیشرفته همزمانی در زبان Go است که امکان پیاده‌سازی الگوی &amp;ldquo;&lt;a href="../../chapter-9/concurrency-patterns/go-concurrency-pattern-monitor">مانیتور&lt;/a>&amp;rdquo; یا همان &lt;strong>شرط انتظاری (Condition Variable)&lt;/strong> را فراهم می‌کند. Cond به شما اجازه می‌دهد تا مجموعه‌ای از goroutineها را تا زمانی که یک شرط یا رویداد خاص برقرار نشده، به صورت امن و کارآمد (بدون busy-waiting یا مصرف بی‌مورد CPU) منتظر نگه دارید. زمانی که شرط مورد نظر برقرار شد، می‌توانید یک یا همه goroutineهای منتظر را بیدار کنید تا کارشان را ادامه دهند. این تکنیک، در بسیاری از الگوهای معروف concurrency مانند producer-consumer، صف انتظار، صف پیام و کنترل منابع محدود کاربرد اساسی دارد.&lt;/p>
&lt;h4 id="نحوه-کار-cond-و-نقش-قفل-mutex--rwmutex">
&lt;strong>نحوه کار Cond و نقش قفل (Mutex / RWMutex)&lt;/strong>
&lt;a class="anchor" href="#%d9%86%d8%ad%d9%88%d9%87-%da%a9%d8%a7%d8%b1-cond-%d9%88-%d9%86%d9%82%d8%b4-%d9%82%d9%81%d9%84-mutex--rwmutex">#&lt;/a>
&lt;/h4>
&lt;p>برای ساخت یک شیء Cond باید یک قفل (معمولاً از نوع &lt;code>*sync.Mutex&lt;/code> یا &lt;code>*sync.RWMutex&lt;/code>) به آن بدهید. این قفل به Cond اجازه می‌دهد تا وضعیت مشترک (shared state) را در میان چند goroutine به طور thread-safe بررسی و کنترل کند. قفل، تضمین می‌کند که هیچ دو goroutineای همزمان نتوانند وضعیت را تغییر دهند یا به متدهای Cond دسترسی پیدا کنند، که این برای جلوگیری از race condition کاملاً حیاتی است.&lt;/p>
&lt;pre>&lt;code class="language-go">lock := &amp;amp;sync.Mutex{}
cond := sync.NewCond(lock)
&lt;/code>&lt;/pre>
&lt;h4 id="عملکرد-متدها">
&lt;strong>عملکرد متدها&lt;/strong>
&lt;a class="anchor" href="#%d8%b9%d9%85%d9%84%da%a9%d8%b1%d8%af-%d9%85%d8%aa%d8%af%d9%87%d8%a7">#&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>Wait():&lt;/strong>&lt;br>
وقتی یک goroutine متد Wait را صدا می‌زند، دو اتفاق پشت‌سرهم رخ می‌دهد:&lt;/p>
&lt;ol>
&lt;li>قفل داده‌شده (مثلاً Mutex) به طور موقت آزاد می‌شود تا سایر goroutineها بتوانند وضعیت مشترک را تغییر دهند.&lt;/li>
&lt;li>goroutine تا زمان دریافت سیگنال (&lt;code>Signal&lt;/code> یا &lt;code>Broadcast&lt;/code>) به حالت تعلیق (sleep) می‌رود و هیچ پردازشی انجام نمی‌دهد (کاملاً غیرمسدودکننده).&lt;br>
پس از دریافت سیگنال و بیدار شدن، Wait دوباره به صورت اتمیک قفل را در اختیار می‌گیرد و اجرا از همان خط ادامه پیدا می‌کند.&lt;br>
معمولاً قبل از Wait باید شرط را داخل یک حلقه (for) بررسی کنید تا از &lt;strong>spurious wakeup&lt;/strong> و رقابت داده‌ای جلوگیری شود:&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-go">cond.L.Lock()
for !شرط_برقرار_است {
cond.Wait()
}
// ادامه منطق ...
cond.L.Unlock()
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Signal():&lt;/strong>&lt;br>
این متد تنها &lt;strong>یکی از goroutineهای منتظر&lt;/strong> را بیدار می‌کند (اگر کسی در صف انتظار باشد). انتخاب اینکه کدام goroutine بیدار شود به سیاست زمان‌بندی runtime وابسته است و تضمینی برای ترتیب خاصی وجود ندارد. Signal معمولاً زمانی به کار می‌رود که انتظار دارید فقط یک مصرف‌کننده با داده جدید یا تغییر وضعیت بیدار شود.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Broadcast():&lt;/strong>&lt;br>
این متد &lt;strong>همه goroutineهای منتظر روی آن Cond&lt;/strong> را بیدار می‌کند تا شرط را دوباره بررسی کنند. Broadcast زمانی کاربرد دارد که یک رویداد می‌تواند برای همه‌ی منتظرها مهم باشد (مثلاً اتمام کار یا آزاد شدن منبع برای همه مصرف‌کننده‌ها).&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>به مثال زیر توجه کنید :&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;fmt&amp;quot;
&amp;quot;sync&amp;quot;
)
var sharedResource = make(map[string]interface{})
func main() {
var wg sync.WaitGroup
wg.Add(2)
locker := sync.Mutex{}
condition := sync.NewCond(&amp;amp;locker)
go waitForResourceUpdate(&amp;amp;wg, condition, &amp;quot;rsc1&amp;quot;)
go waitForResourceUpdate(&amp;amp;wg, condition, &amp;quot;rsc2&amp;quot;)
// this one writes changes to sharedResource
condition.L.Lock()
sharedResource[&amp;quot;rsc1&amp;quot;] = &amp;quot;a string&amp;quot;
sharedResource[&amp;quot;rsc2&amp;quot;] = 123456
condition.Broadcast()
condition.L.Unlock()
wg.Wait()
}
// waitForResourceUpdate waits for a signal that a resource changed and prints it.
func waitForResourceUpdate(wg *sync.WaitGroup, cond *sync.Cond, key string) {
defer wg.Done()
cond.L.Lock()
for len(sharedResource) == 0 {
cond.Wait()
}
fmt.Println(&amp;quot;Resource&amp;quot;, key, &amp;quot;:&amp;quot;, sharedResource[key])
cond.L.Unlock()
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-shell">$ go run main.go
Resource rsc2 : 123456
Resource rsc1 : a string
&lt;/code>&lt;/pre></description></item><item><author/><title>3.4 پکیج atomic</title><link>https://book.gofarsi.ir/chapter-3/go-atomic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-3/go-atomic/</guid><description>&lt;p>&lt;strong>پکیج &lt;a href="https://pkg.go.dev/sync/atomic">sync/atomic&lt;/a>&lt;/strong> در زبان Go مجموعه‌ای از توابع سطح پایین (low-level) را برای انجام عملیات خواندن و نوشتن &lt;strong>اتمی (atomic)&lt;/strong> روی متغیرهای حافظه فراهم می‌کند. منظور از عملیات اتمیک، عملیاتی است که به طور کامل و یکپارچه توسط CPU انجام می‌شود؛ یعنی هیچ گوروتین، thread یا پردازش دیگری نمی‌تواند مقدار متغیر را بین شروع و پایان یک عملیات اتمیک مشاهده یا تغییر دهد. این ویژگی برای پیاده‌سازی &lt;strong>الگوهای همگام‌سازی سبک و بدون قفل (lock-free synchronization)&lt;/strong> و &lt;strong>متغیرهای اشتراکی با دسترسی سریع و ایمن&lt;/strong> ضروری است.&lt;/p>
&lt;h4 id="مهمترین-کاربردها-و-عملیات">
&lt;strong>مهم‌ترین کاربردها و عملیات:&lt;/strong>
&lt;a class="anchor" href="#%d9%85%d9%87%d9%85%d8%aa%d8%b1%db%8c%d9%86-%da%a9%d8%a7%d8%b1%d8%a8%d8%b1%d8%af%d9%87%d8%a7-%d9%88-%d8%b9%d9%85%d9%84%db%8c%d8%a7%d8%aa">#&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>پیاده‌سازی شمارنده‌های اتمیک (atomic counters):&lt;/strong>&lt;br>
مثلاً افزایش شمارنده تعداد درخواست، جمع یا کم کردن بدون نیاز به Mutex.&lt;/li>
&lt;li>&lt;strong>فلگ‌ها یا وضعیت‌های اشتراکی:&lt;/strong>&lt;br>
تنظیم و خواندن یک فلگ مشترک بین چند goroutine به شکلی که دچار race condition نشود.&lt;/li>
&lt;li>&lt;strong>ساخت primitiveهای همگام‌سازی سفارشی:&lt;/strong>&lt;br>
مثل اسپین‌لاک، قفل ساده، lock-free queue، semaphore سطح پایین و…&lt;/li>
&lt;/ul>
&lt;h4 id="متدهای-مهم-atomic">
&lt;strong>متدهای مهم atomic:&lt;/strong>
&lt;a class="anchor" href="#%d9%85%d8%aa%d8%af%d9%87%d8%a7%db%8c-%d9%85%d9%87%d9%85-atomic">#&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>&lt;code>atomic.AddInt32 / AddUint64&lt;/code> — جمع یا کم کردن مقدار به صورت اتمیک&lt;/li>
&lt;li>&lt;code>atomic.LoadInt32 / LoadPointer&lt;/code> — خواندن مقدار به شکل اتمیک&lt;/li>
&lt;li>&lt;code>atomic.StoreInt32 / StorePointer&lt;/code> — نوشتن مقدار به شکل اتمیک&lt;/li>
&lt;li>&lt;code>atomic.CompareAndSwapInt32&lt;/code> — عمل مقایسه و جایگزینی اتمیک (CAS)، قلب الگوریتم‌های lock-free&lt;/li>
&lt;li>&lt;code>atomic.Value&lt;/code> — یک ساختار wrapper برای نگهداری داده با خواندن و نوشتن اتمیک (ایده‌آل برای ساخت cacheهای ساده یا حافظه به اشتراک گذاشته شده)&lt;/li>
&lt;/ul>
&lt;p>به مثال زیر توجه کنید :&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;fmt&amp;quot;
&amp;quot;sync&amp;quot;
&amp;quot;sync/atomic&amp;quot;
)
type Cache struct {
mu sync.Mutex
data map[string]string
}
func (c *Cache) Set(key, value string) {
c.mu.Lock()
defer c.mu.Unlock()
c.data[key] = value
}
func (c *Cache) Get(key string) (value string, ok bool) {
c.mu.Lock()
defer c.mu.Unlock()
value, ok = c.data[key]
return
}
type AtomicCache struct {
mu sync.Mutex
data atomic.Value
}
func (c *AtomicCache) Set(key, value string) {
c.mu.Lock()
defer c.mu.Unlock()
c.data.Store(map[string]string{key: value})
}
func (c *AtomicCache) Get(key string) (value string, ok bool) {
data := c.data.Load().(map[string]string)
value, ok = data[key]
return
}
func main() {
cache := Cache{data: map[string]string{}}
cache.Set(&amp;quot;key&amp;quot;, &amp;quot;value&amp;quot;)
fmt.Println(cache.Get(&amp;quot;key&amp;quot;)) // Output: value, true
atomicCache := AtomicCache{data: atomic.Value{}}
atomicCache.Set(&amp;quot;key&amp;quot;, &amp;quot;value&amp;quot;)
fmt.Println(atomicCache.Get(&amp;quot;key&amp;quot;)) // Output: value, true
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-shell">$ go run main.go
value true
value true
&lt;/code>&lt;/pre>
&lt;p>در مثال فوق ما یک ساختار به نام Cache داریم که داخلش یک فیلد از نوع map داریم و قصد داریم یکسری اطلاعات را داخل کش بریزیم حال زمانیکه Set/Get می کنیم با استفاده از Mutex اون بخش از عملیات را لاک میکنیم تا جلوی عملیات نوشتن چندین گوروتین برروی یک آدرس حافظه را بگیریم. حال این عملیات رو ما با استفاده از atomic انجام دادیم و همگام سازی داده را بردیم تو سطح خیلی پایین تر در حافظه و با استفاده از atomic.Value که یک اینترفیس است این عملیات را انجام دادیم و این عملیات Set/Get حالت atomic پیدا کرده است.&lt;/p>
&lt;blockquote class="book-hint info">
&lt;p>&lt;strong>آیا استفاده از atomic نیازمند mutex می باشد یا خیر؟&lt;/strong>&lt;/p>
&lt;p>در این کد، mutex در متد Set برای جلوگیری از رخ دادن race condition یا داده‌های نامنظم استفاده شده است. بدون mutex، چندین گوروتین ممکن است همزمان به دسترسی و تغییر داده‌های map data بپردازند که موجب رفتار نامنظم و فساد داده می‌شود. با گرفتن mutex قبل از تغییر map data، متد Set اطمینان حاصل می‌کند که تنها یک گوروتین در هر زمان می‌تواند به داده‌ها دسترسی پیدا کند و تداخل داده‌ها را جلوگیری می‌کند.&lt;/p>
&lt;p>استفاده از mutex در متد Get نیز مهم است، زیرا این اطمینان را به ما می‌دهد که در هنگام دسترسی به map data، هیچ گوروتین دیگری دارای مجوز تغییر داده‌ها نیست. بدون mutex، یک race condition ممکن است ایجاد شود اگر یک گوروتین دیگر در حال تغییر داده‌های map باشد در حالی که یک گوروتین دیگر سعی در خواندن از آن دارد.&lt;/p>
&lt;p>در پیاده‌سازی AtomicCache، یک atomic.Value برای ذخیره map استفاده شده است که به انجام عملیات اتمی روی آن اجازه می‌دهد. با این حال، حتی با استفاده از یک مقدار اتمی، همچنان نیاز به mutex وجود دارد تا فقط یک گوروتین در هر زمان به map دسترسی داشته باشد و تداخل داده‌ها را جلوگیری کند.&lt;/p>
&lt;/blockquote>
&lt;h2 id="341-نکات-و-هشدارهای-تولیدی-production-caveats">
3.4.1 نکات و هشدارهای تولیدی (Production Caveats)
&lt;a class="anchor" href="#341-%d9%86%da%a9%d8%a7%d8%aa-%d9%88-%d9%87%d8%b4%d8%af%d8%a7%d8%b1%d9%87%d8%a7%db%8c-%d8%aa%d9%88%d9%84%db%8c%d8%af%db%8c-production-caveats">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>memory safety:&lt;/strong> پکیج atomic از ویژگی‌های سطح پایین CPU استفاده می‌کند و bypass کردن حافظه امن زبان Go را ممکن می‌سازد؛ یعنی اگر به درستی از آن استفاده نکنید، به‌راحتی دچار bugهای عجیب و غیرقابل ردیابی خواهید شد. استفاده اشتباه می‌تواند باعث بروز race condition، memory corruption و مشکلات شدید تولیدی شود.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>تراز حافظه (memory alignment):&lt;/strong> متغیرهایی که به صورت اتمیک تغییر می‌کنند باید به درستی روی حافظه align شوند (مثلاً در ساختار struct کنار سایر داده‌ها قرار نگیرند). بی‌توجهی به این نکته ممکن است باعث crash برنامه در معماری‌های خاص شود.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>مناسب برای عملیات ساده:&lt;/strong> atomic برای primitive data types (int32, int64, pointer, &amp;hellip;)، عملیات ساده و سناریوهایی با هماهنگی حداقلی طراحی شده است؛ اگر منطق پیچیده‌تر دارید یا باید چندین متغیر را همزمان به شکل اتمیک تغییر دهید، از &lt;strong>sync.Mutex&lt;/strong> یا سایر ابزارهای همزمانی ایمن Go استفاده کنید.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>کاملاً lock-free نیست:&lt;/strong> گرچه atomic سریع و سبک است، اما فقط برای primitiveها کاملاً lock-free است. برای کار با داده‌های پیچیده یا ساختارهای بزرگ، باید با احتیاط و دانش کافی عمل کنید.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>atomic.Value&lt;/strong> برای داده‌های ساختاری، اما فقط با خواندن و نوشتن کامل؛ عملیات mutate روی داده ذخیره‌شده (مثلاً map یا slice) اتمیک نیست مگر کل value جایگزین شود.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="342-برخی-از-کاربردهای-atomic">
3.4.2 برخی از کاربردهای atomic
&lt;a class="anchor" href="#342-%d8%a8%d8%b1%d8%ae%db%8c-%d8%a7%d8%b2-%da%a9%d8%a7%d8%b1%d8%a8%d8%b1%d8%af%d9%87%d8%a7%db%8c-atomic">#&lt;/a>
&lt;/h2>
&lt;p>در زیر چندتا use case برای استفاده از پکیج atomic معرفی کردیم :&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>پیاده سازی همگام سازی بدون مسدودیت :&lt;/strong> پکیج atomic توابع سطح پایینی را برای انجام عملیات حافظه اتمی فراهم می کند که می تواند برای پیاده سازی الگوریتم های همگام سازی غیرمسدود مانند مقایسه و تعویض (CAS) یا بارگذاری لینک/ذخیره شرطی استفاده شود. LL/SC).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>پیاده سازی ساختارهای داده با همزمانی سطح (high-concurrency) بالا :&lt;/strong> با پکیج atomic می توان برای پیاده سازی ساختارهای داده ای استفاده کرد که برای دسترسی همزمان و اصلاح توسط چندین گوروتین ایمن هستند. به عنوان مثال، می توانید از بسته اتمی برای پیاده سازی نقشه یا صف همزمان استفاده کنید.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>پیاده سازی شمارنده (counter) از نوع atomic :&lt;/strong> شما با استفاده از پکیج atomic می توانید برای افزایش و کاهش شمارنده ها به صورت اتمی که می تواند برای اجرای مواردی مانند شمارش مرجع یا محدود کردن ratelimit استفاده شود.&lt;/p>
&lt;/li>
&lt;/ol></description></item><item><author/><title>3.5 آموزش مقابله با data race</title><link>https://book.gofarsi.ir/chapter-3/goroutine-data-race/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-3/goroutine-data-race/</guid><description>&lt;p>معمولا تو بحث همزمانی یکی از اتفاقاتی که خیلی ممکن است رخ دهد بحث data race است و data race زمانی رخ می دهد که ۲ یا چند گوروتین قصد دارند به یک آدرس حافظه در یک زمان دسترسی داشته باشند. حال اگر ما جلوی data race را نگیریم ممکن است تغییرات نادرست برروی مقادیر داخل خانه حافظه صورت گیرد.&lt;/p>
&lt;p>راه هایی برای مقابله با data race وجود دارد که به شرح زیر است :&lt;/p>
&lt;ol>
&lt;li>استفاده از Mutex داخل پکیج sync برای قفل گذاشتن/برداشتن یک بخش دیتا.&lt;/li>
&lt;li>استفاده RWMutex داخل پکیج sync می توانید داده اشتراک گذاری شده را قفل کنید فقط یک گوروتین عملیات نوشتن داشته باشد.&lt;/li>
&lt;li>استفاده از پکیج atomic برای عملیات بصورت atomic برروی مقادیر.&lt;/li>
&lt;/ol>
&lt;h2 id="351-تشخیص-data-race">
3.5.1 تشخیص Data Race
&lt;a class="anchor" href="#351-%d8%aa%d8%b4%d8%ae%db%8c%d8%b5-data-race">#&lt;/a>
&lt;/h2>
&lt;p>به لطف امکان جانبی زبان گو شما می توانید خیلی راحت بخش هایی که data race رخ داده را تشخیص دهید. کافیه سوییچ &lt;code>race-&lt;/code> را هنگام build اضافه کنید تا در زمان data race ها را تشخیص دهید.&lt;/p>
&lt;pre>&lt;code class="language-shell">$ go run -race main.go
==================
WARNING: DATA RACE
Write at 0x00c000522c20 by goroutine 29:
git.ramooz.org/ramooz/golang-components/event-driven/rabbitmq.(*Connection).handleReconnect()
/home/user/Project/go/ramooz.org/medx/software-builder/vendor/git.ramooz.org/ramooz/golang-components/event-driven/rabbitmq/rabbit.go:86 +0x89
git.ramooz.org/ramooz/golang-components/event-driven/rabbitmq.NewConnection.func1()
/home/user/Project/go/ramooz.org/medx/software-builder/vendor/git.ramooz.org/ramooz/golang-components/event-driven/rabbitmq/rabbit.go:35 +0x58
Previous read at 0x00c000522c20 by main goroutine:
git.ramooz.org/ramooz/golang-components/event-driven/rabbitmq.NewConnection()
/home/user/Project/go/ramooz.org/medx/software-builder/vendor/git.ramooz.org/ramooz/golang-components/event-driven/rabbitmq/rabbit.go:37 +0x324
git.ramooz.org/ramooz/golang-components/logger.initializeRabbitMQ()
/home/user/Project/go/ramooz.org/medx/software-builder/vendor/git.ramooz.org/ramooz/golang-components/logger/rabbit.conn.go:11 +0x226
git.ramooz.org/ramooz/golang-components/logger.NewLogger()
/home/user/Project/go/ramooz.org/medx/software-builder/vendor/git.ramooz.org/ramooz/golang-components/logger/logger.go:37 +0x456
ramooz.org/ramooz/user-service/configs.initNewLogger()
/home/user/Project/go/ramooz.org/medx/software-builder/configs/configs.go:158 +0x938
ramooz.org/ramooz/user-service/configs.ConfigServer()
/home/user/Project/go/ramooz.org/medx/software-builder/configs/configs.go:54 +0x15a
main.main()
/home/user/Project/go/ramooz.org/medx/software-builder/main.go:17 +0x29
Goroutine 29 (running) created at:
git.ramooz.org/ramooz/golang-components/event-driven/rabbitmq.NewConnection()
/home/user/Project/go/ramooz.org/medx/software-builder/vendor/git.ramooz.org/ramooz/golang-components/event-driven/rabbitmq/rabbit.go:35 +0x2da
git.ramooz.org/ramooz/golang-components/logger.initializeRabbitMQ()
/home/user/Project/go/ramooz.org/medx/software-builder/vendor/git.ramooz.org/ramooz/golang-components/logger/rabbit.conn.go:11 +0x226
git.ramooz.org/ramooz/golang-components/logger.NewLogger()
/home/user/Project/go/ramooz.org/medx/software-builder/vendor/git.ramooz.org/ramooz/golang-components/logger/logger.go:37 +0x456
ramooz.org/ramooz/user-service/configs.initNewLogger()
/home/user/Project/go/ramooz.org/medx/software-builder/configs/configs.go:158 +0x938
ramooz.org/ramooz/user-service/configs.ConfigServer()
/home/user/Project/go/ramooz.org/medx/software-builder/configs/configs.go:54 +0x15a
main.main()
/home/user/Project/go/ramooz.org/medx/software-builder/main.go:17 +0x29
==================
&lt;/code>&lt;/pre>
&lt;p>در خروجی بالا یک هشدار data race داده است که در فلان خط کد شما فلان گوروتین ها در یک زمان دسترسی برروی یک داده را دارند. و شما با توجه به خروجی می توانید سناریو های جلوگیری را انجام دهید.&lt;/p></description></item><item><author/><title>3.6 کانال (channel)</title><link>https://book.gofarsi.ir/chapter-3/go-channel/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-3/go-channel/</guid><description>&lt;center>&lt;a href="#">
&lt;img src="../../assets/img/content/chapter3/channel/1.png" alt="channel">
&lt;/a>&lt;/center>
&lt;p>کانال یک نوع تایپ است که داده از نوع خاصی را نگه داری میکند و امکان برقراری ارتباط و همگام سازی داده بین گوروتین ها را فراهم می کند. شما می توانید کانال ها را به عنوان خط لوله هایی در نظر بگیرید که این خط لوله ها به گوروتین ها متصل می شوند و باعث برقراری ارتباط بین گوروتین ها می شوند. این ارتباط بین گوروتین ها به هیچ قفل صریحی نیاز ندارد (منظورم mutex و &amp;hellip;) چون کانال ها بصورت داخلی قفل ها را مدیریت میکنند و در زمان های مناسب و مشخص Lock و UnLock می کنند.&lt;/p>
&lt;blockquote>
&lt;p>به نقل از &lt;a href="https://en.wikipedia.org/wiki/Robert_Griesemer">رابرت گریزمر&lt;/a> که یکی از توسعه دهنده های اصلی زبان برنامه نویسی گو می باشد در خصوص کانال ها می گوید : با &lt;strong>برقراری ارتباط حافظه را به اشتراک بزارید&lt;/strong> ولی &lt;strong>با اشتراک گذاری حافظه ارتباط برقرار نکنید&lt;/strong>.&lt;/p>&lt;/blockquote>
&lt;p>منظور از نقل فوق این است شما برای اینکه بخوای بین گوروتین ها ارتباط برقرار کنی این کار را با اشتراک گذاری حافظه نکنید. بلکه باید بواسطه کانال ها حافظه را بین گوروتین ها به اشتراک بزارید.&lt;/p>
&lt;p>زبان گو برای بحث همزمانی ۲ تا مقوله خیلی مهم دارد که این دو با هم در ارتباط هستند :&lt;/p>
&lt;ol>
&lt;li>&lt;strong>گوروتین ها :&lt;/strong> یک thread مستقل و سبک وزن در زبان گو که قابلیت برنامه نویسی همزمان (concurrency) را فراهم می کند.&lt;/li>
&lt;li>&lt;strong>کانال ها :&lt;/strong> فراهم کننده ارتباط و همگام سازی داده ها بین گوروتین ها.&lt;/li>
&lt;/ol>
&lt;h2 id="361-تعریف-کانال-ها">
3.6.1 تعریف کانال ها
&lt;a class="anchor" href="#361-%d8%aa%d8%b9%d8%b1%db%8c%d9%81-%da%a9%d8%a7%d9%86%d8%a7%d9%84-%d9%87%d8%a7">#&lt;/a>
&lt;/h2>
&lt;p>همانطور که گفتیم کانال یک نوع تایپ است که داده از نوع خاصی را نگه داری میکند. برای استفاده از کانال ها، شما باید این تایپ را برای متغیری تعریف کنید تا بتوانید بواسطه آن متغیر از کانال استفاده کنید و بین گوروتین ها ارتباط برقرار کنید.&lt;/p>
&lt;pre>&lt;code class="language-go">var &amp;lt;variable_name&amp;gt; chan &amp;lt;type&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>به مثال زیر توجه کنید :&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import &amp;quot;fmt&amp;quot;
func main() {
var a chan int
fmt.Println(a)
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-shell">$ go run main.go
{nil}
&lt;/code>&lt;/pre>
&lt;p>در بالا ما یک متغیر با نام a تعریف کردیم که از نوع کانال با تایپ int می باشد و این کانال فقط انتقال داده از نوع int را انجام می دهد. و مقدار پیش فرض کانال nil می باشد که در خروجی می توانید ببینید.&lt;/p>
&lt;blockquote class="book-hint info">
توجه کنید همیشه سعی کنید کانال را با استفاده از تابع &lt;strong>make&lt;/strong> ایجاد کنید.
&lt;/blockquote>
&lt;pre>&lt;code class="language-go">package main
import &amp;quot;fmt&amp;quot;
func main() {
a := make(chan int)
fmt.Println(a)
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-shell">$ go run main.go
0xc0000240c0
&lt;/code>&lt;/pre>
&lt;p>در خروجی کد بالا همانطور که مشاهده می کنید به جای nil آدرس حافظه داده را نمایش می دهد.&lt;/p>
&lt;p>زمانیکه شما یک کانال را به واسطه make ایجاد می کنید در واقع دارید یک instance از ساختار hchan ایجاد می کنید و تمامی فیلدهای این ساختار مقدار پیش فرض میگیرند.&lt;/p>
&lt;pre>&lt;code class="language-go">type hchan struct {
qcount uint // total data in the queue
dataqsiz uint // size of the circular queue
buf unsafe.Pointer // points to an array of dataqsiz elements
elemsize uint16
closed uint32 // denotes weather channel is closed or not
elemtype *_type // element type
sendx uint // send index
recvx uint // receive index
recvq waitq // list of recv waiters
sendq waitq // list of send waiters
lock mutex
}
&lt;/code>&lt;/pre>
&lt;h2 id="362-عملیات-ها-برروی-کانال">
3.6.2 عملیات ها برروی کانال
&lt;a class="anchor" href="#362-%d8%b9%d9%85%d9%84%db%8c%d8%a7%d8%aa-%d9%87%d8%a7-%d8%a8%d8%b1%d8%b1%d9%88%db%8c-%da%a9%d8%a7%d9%86%d8%a7%d9%84">#&lt;/a>
&lt;/h2>
&lt;p>زمانیکه شما یک کانال ایجاد می کنید، دو عملیات اصلی بر روی کانال می توانید انجام دهید :&lt;/p>
&lt;ul>
&lt;li>&lt;strong>ارسال :&lt;/strong> ارسال داده به داخل کانال&lt;/li>
&lt;li>&lt;strong>دریافت :&lt;/strong> دریافت داده از کانال&lt;/li>
&lt;/ul>
&lt;h3 id="3621-عملیات-ارسال">
3.6.2.1 عملیات ارسال
&lt;a class="anchor" href="#3621-%d8%b9%d9%85%d9%84%db%8c%d8%a7%d8%aa-%d8%a7%d8%b1%d8%b3%d8%a7%d9%84">#&lt;/a>
&lt;/h3>
&lt;p>برای ارسال داده به داخل کانال یک اپراتور استاندارد وجود دارد که بهتر است همیشه به خاطر بسپارید :&lt;/p>
&lt;pre>&lt;code class="language-go">ch &amp;lt;- val
&lt;/code>&lt;/pre>
&lt;ol>
&lt;li>متغیر ch همان کانالی است که با استفاده از تایپ chan ساخته شده است.&lt;/li>
&lt;li>متغیر val هم مقداری است که توسط اپراتور &amp;lt;- به کانال ارسال شده است.&lt;/li>
&lt;/ol>
&lt;blockquote class="book-hint warning">
توجه کنید تایپ &lt;strong>val&lt;/strong> باید با تایپی که برای کانال مشخص کردید حتما یکی باشد.
&lt;/blockquote>
&lt;h3 id="3622-عملیات-دریافت">
3.6.2.2 عملیات دریافت
&lt;a class="anchor" href="#3622-%d8%b9%d9%85%d9%84%db%8c%d8%a7%d8%aa-%d8%af%d8%b1%db%8c%d8%a7%d9%81%d8%aa">#&lt;/a>
&lt;/h3>
&lt;p>عملیات دریافت در کانال صرفا جهت خواندن داده از طریق کانال می باشد که یک قالب استاندارد همانند عملیات ارسال دارد :&lt;/p>
&lt;pre>&lt;code class="language-go">val := &amp;lt;- ch
&lt;/code>&lt;/pre>
&lt;ol>
&lt;li>در اینجاهم ch همان متغیر کانال می باشد.&lt;/li>
&lt;li>متغیر val هم منتظر دریافت داده به واسطه &lt;code>&amp;gt;-&lt;/code> از طریق کانال ch می باشد.&lt;/li>
&lt;/ol>
&lt;h3 id="3623-مثال-عملیات-ارسال-و-دریافت">
3.6.2.3 مثال عملیات ارسال و دریافت
&lt;a class="anchor" href="#3623-%d9%85%d8%ab%d8%a7%d9%84-%d8%b9%d9%85%d9%84%db%8c%d8%a7%d8%aa-%d8%a7%d8%b1%d8%b3%d8%a7%d9%84-%d9%88-%d8%af%d8%b1%db%8c%d8%a7%d9%81%d8%aa">#&lt;/a>
&lt;/h3>
&lt;p>در زیر یک مثال میزنیم که داده ای را بواسطه کانال ارسال/دریافت می کنیم بین گوروتین ها.&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;fmt&amp;quot;
&amp;quot;time&amp;quot;
)
func main() {
ch := make(chan int)
fmt.Println(&amp;quot;Sending value to channel&amp;quot;)
go send(ch)
fmt.Println(&amp;quot;Receiving from channel&amp;quot;)
go receive(ch)
time.Sleep(time.Second * 1)
}
func send(ch chan int) {
ch &amp;lt;- 1
}
func receive(ch chan int) {
val := &amp;lt;-ch
fmt.Printf(&amp;quot;Value Received=%d in receive function\n&amp;quot;, val)
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-shell">$ go run main.go
Sending value to channel
Receiving from channel
Value Received=1 in receive function
&lt;/code>&lt;/pre>
&lt;p>در کد فوق ما یک کانال با نام ch از نوع int ایجاد کردیم. سپس ۲ تابع send و received را داخل گوروتین قرار دادیم که هر دو تابع به عنوان پارامتر ورودی تایپ int را بصورت کانال میگیرد. حال متغیر کانال ch را به هر دو تابع پاس دادیم. و در هر دو تابع ۲ تا عملیات صورت گرفته :&lt;/p>
&lt;ul>
&lt;li>تابع send مقدار عدد ۱ را به داخل کانال ارسال کرده&lt;/li>
&lt;li>تابع recived مقدار را از کانال ch دریافت کرده و داخل متغیر val قرار داده است و در نهایت متغیر val را چاپ کرده است.&lt;/li>
&lt;/ul>
&lt;p>در انتهای تابع main ما یک sleep به مدت ۱ ثانیه قرار دادیم که بتوانیم خروجی برنامه را ببینیم. اگر اینکار را نکنیم گوروتین main ممکن است سریع تر از اینکه دو گوروتین دیگر اجرا شوند و خروجی آنها را ببینیم، کارش به اتمام برسد و برنامه متوقف شود.&lt;/p>
&lt;p>یک نکته بسیار مهمی که در مورد کانال ها وجود دارد و باید به آن توجه کنید این است که یک مقدار زمانی که داخل کانال ارسال می شود، فقط یکبار قابل دریافت کردن است. همانطور که می بینید هیچ قفلی در گوروتین ها موقع ارسال و دریافت استفاده نشده است و قفل ها توسط خود کانال مدیریت می شوند و نیازی به استفاده از قفل ها در کد نیست.&lt;/p>
&lt;p>بزارید یک مثال ساده برای اینکه ببینید چطور کانال ها Lock و UnLock می شوند بزنیم :&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;fmt&amp;quot;
&amp;quot;time&amp;quot;
)
func main() {
ch := make(chan int)
go send(ch)
go receive(ch)
time.Sleep(time.Second * 2)
}
func send(ch chan int) {
time.Sleep(time.Second * 1)
fmt.Println(&amp;quot;Timeout finished&amp;quot;)
ch &amp;lt;- 1
}
func receive(ch chan int) {
val := &amp;lt;-ch
fmt.Printf(&amp;quot;Receiving Value from channel finished. Value received: %d\n&amp;quot;, val)
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-shell">$ go run main.go
Timeout finished
Receiving Value from channel finished. Value received: 1
&lt;/code>&lt;/pre>
&lt;p>در کد فوق ما داخل تابع send یک sleep به مدت ۱ ثانیه قرار دادیم. و پس از اینکه ۱ ثانیه تمام شد مقدار را داخل کانال ch ارسال کردیم و سپس مقدار داخل تابع recived دریافت شد.&lt;/p>
&lt;p>اتفاقی که در کد فوق رخداد زمانیکه شما عملیات دریافت را انجام می دهید تا زمانیکه مقداری از کانال دریافت نشود اون بخش از کد شما Lock می شود و پس از اینکه دریافت شد مقدار از کانال آن بخش Unlock خواهد شد.&lt;/p>
&lt;h2 id="363-ایجاد-کانال-بافر-شده">
3.6.3 ایجاد کانال بافر شده
&lt;a class="anchor" href="#363-%d8%a7%db%8c%d8%ac%d8%a7%d8%af-%da%a9%d8%a7%d9%86%d8%a7%d9%84-%d8%a8%d8%a7%d9%81%d8%b1-%d8%b4%d8%af%d9%87">#&lt;/a>
&lt;/h2>
&lt;p>تا اینجای کار ما از کانال های Un Buffered استفاده کردیم. در این نوع کانال ها تا زمانی که یک دریافت کننده نداشته باشیم نمی توانیم چیزی را در کانال ارسال کنیم و کد ما در آن خط لاک می شود تا دریافت کننده ای پیدا شود. برای درک کانال های Un Buffered بازی تنیس را درنظر بگیرید. فقط یک توپ داریم و یک شخص منتظر دریافت کردن توپ است و شخص دیگر در حال ارسال توپ.&lt;/p>
&lt;p>در زبان گو شما می توانید کانال های بافر شده ایجاد کنید. یک کانال بافر دارای ظرفیتی مشخص برای نگه داری داده است. در این صورت نیازی نیست حتما یک دریافت کننده منتظر دریافت داده باشد تا بتوانیم داخل کانال چیزی ارسال کنیم. بلکه تا زمانی که ظرفیت کانال پر نشده باشد، می توانیم داده ارسال کنیم.&lt;/p>
&lt;p>بزارید کمی ساده تر توضیح دهیم شما برای کانال همانند آرایه و slice می توانید یک ظرفیت مشخصی تعیین کنید که این کانال فقط می تواند این مقدار از داده را نگه داری کند و تا زمانیکه مقادیر از کانال خارج نشود ظرفیت کانال پرخواهد بود و مقدار جدیدی را نمی توانید به کانال ارسال کنید.&lt;/p>
&lt;p>برای ایجاد یک کانال بافر شده از روش زیر استفاده کنید :&lt;/p>
&lt;pre>&lt;code class="language-go">a := make(chan , capacity)
&lt;/code>&lt;/pre>
&lt;p>مقدار capacity که بصورت عدد هست تعداد بافر کانال را مشخص می کند که این کانال فقط می تواند این حجم از داده را داخل کانال نگه داری کند.&lt;/p>
&lt;p>به مثال زیر توجه کنید :&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;fmt&amp;quot;
)
func main() {
ch := make(chan int, 1)
ch &amp;lt;- 1
fmt.Println(&amp;quot;Sending value to channnel complete&amp;quot;)
val := &amp;lt;-ch
fmt.Printf(&amp;quot;Receiving Value from channel finished. Value received: %d\n&amp;quot;, val)
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-shell">$ go run main.go
Sending value to channnel complete
Receiving Value from channel finished. Value received: 1
&lt;/code>&lt;/pre>
&lt;p>در کد فوق ما یک کانال بافر شده با ظرفیت ۱ ایجاد کردیم و مقدار ۱ را به کانال ارسال کردیم و در ادامه این مقدار را از کانال دریافت کردیم.&lt;/p>
&lt;pre>&lt;code class="language-go">ch := make(chan int, 1)
&lt;/code>&lt;/pre>
&lt;h3 id="3631-ارسال-داده-برروی-کانال-با-ظرفیت-پر">
3.6.3.1 ارسال داده برروی کانال با ظرفیت پر
&lt;a class="anchor" href="#3631-%d8%a7%d8%b1%d8%b3%d8%a7%d9%84-%d8%af%d8%a7%d8%af%d9%87-%d8%a8%d8%b1%d8%b1%d9%88%db%8c-%da%a9%d8%a7%d9%86%d8%a7%d9%84-%d8%a8%d8%a7-%d8%b8%d8%b1%d9%81%db%8c%d8%aa-%d9%be%d8%b1">#&lt;/a>
&lt;/h3>
&lt;p>حالا فرض کنید می خواهیم به کانال بافر شده کد فوق یک مقدار دیگری را ارسال کنیم :&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;fmt&amp;quot;
)
func main() {
ch := make(chan int, 1)
ch &amp;lt;- 1
ch &amp;lt;- 2
fmt.Println(&amp;quot;Sending value to channnel complete&amp;quot;)
val := &amp;lt;-ch
fmt.Printf(&amp;quot;Receiving Value from channel finished. Value received: %d\n&amp;quot;, val)
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-shell">$ go run main.go
fatal error: all goroutines are asleep - deadlock!
goroutine 1 [chan send]:
main.main()
/tmp/sandbox2390960160/prog.go:10 +0x4b
&lt;/code>&lt;/pre>
&lt;p>در کد فوق اتفاقی که افتاد ما یک کانال بافر شده با ظرفیت ۱ ایجاد کردیم ولی به این کانال ۲ تا مقدار ارسال کردیم:&lt;/p>
&lt;pre>&lt;code class="language-go">ch &amp;lt;- 1
ch &amp;lt;- 2
&lt;/code>&lt;/pre>
&lt;p>در ادامه اتفاقی که صورت گرفت کانال ما به خاطر پر شدن ظرفیتش بلاک شده بود و داده دیگه ای را نمی توانست نگه داری کند. در نتیجه با خطای deadlock مواجه شد و برنامه کاملا متوقف شد :&lt;/p>
&lt;pre>&lt;code class="language-go">fatal error: all goroutines are asleep - deadlock!
&lt;/code>&lt;/pre>
&lt;h3 id="دریافت-مجدد-داده-از-کانال-خالی-شده">
دریافت مجدد داده از کانال خالی شده
&lt;a class="anchor" href="#%d8%af%d8%b1%db%8c%d8%a7%d9%81%d8%aa-%d9%85%d8%ac%d8%af%d8%af-%d8%af%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-%da%a9%d8%a7%d9%86%d8%a7%d9%84-%d8%ae%d8%a7%d9%84%db%8c-%d8%b4%d8%af%d9%87">#&lt;/a>
&lt;/h3>
&lt;p>به مثال زیر توجه کنید :&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;fmt&amp;quot;
)
func main() {
ch := make(chan int, 1)
ch &amp;lt;- 1
fmt.Println(&amp;quot;Sending value to channnel complete&amp;quot;)
val := &amp;lt;-ch
val = &amp;lt;-ch
fmt.Printf(&amp;quot;Receiving Value from channel finished. Value received: %d\n&amp;quot;, val)
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-shell">$ go run main.go
Sending value to channnel complete
fatal error: all goroutines are asleep - deadlock!
goroutine 1 [chan receive]:
main.main()
/tmp/sandbox3239418330/prog.go:12 +0xad
&lt;/code>&lt;/pre>
&lt;p>در کد فوق ما یک کانال بافر شده با ظرفیت ۱ ایجاد کردیم و یک مقدار را به کانال ارسال کردیم و در نهایت ۲ بار دریافت از کانال را فرخوانی کردیم. اما اتفاقی که افتاده بازم با خطای deadlock مواجه شدیم چون کانال خالی شده است و هیچ داده ای بیشتر از بافر اش ندارد.&lt;/p>
&lt;h2 id="364-جهت-های-کانال">
3.6.4 جهت های کانال
&lt;a class="anchor" href="#364-%d8%ac%d9%87%d8%aa-%d9%87%d8%a7%db%8c-%da%a9%d8%a7%d9%86%d8%a7%d9%84">#&lt;/a>
&lt;/h2>
&lt;p>شما می توانید کانال را با جهت های مختلفی تعریف کنید که به شرح زیر است :&lt;/p>
&lt;ul>
&lt;li>دو طرفه : کانال با جهت دوطرفه مانند مثال های قبلی می باشد که شما &lt;code>chan int&lt;/code> به این شکل تعریف می کنید.&lt;/li>
&lt;li>یک طرفه فقط ارسال : شما می توانید یک کانال ایجاد کنید که فقط عملیات ارسال &lt;code>chan&amp;lt;- int&lt;/code> را انجام می دهد.&lt;/li>
&lt;li>یک طرفه فقط دریافت : شما می توانید یک کانال ایجاد کنید که فقط عملیات دریافت &lt;code>&amp;lt;-chan int&lt;/code> را انجام می دهد.&lt;/li>
&lt;/ul>
&lt;p>حالا این سوال پیش می آید چرا باید ما یک کانال ایجاد کنیم که عملیات فقط ارسال یا عملیات فقط دریافت را انجام می دهد. این کار وقتی مفید است که شما بخواهید برای پارامترهای ورودی یا خروجی توابع خود را محدود به یک عملیات در کانال کنید.&lt;/p>
&lt;p>کانال حالت های مختلفی دارد که شما پارامترهای ورودی و خروجی تابع استفاده کنید :&lt;/p>
&lt;ul>
&lt;li>&lt;strong>chan&lt;/strong> کانال دوطرفه&lt;/li>
&lt;li>&lt;strong>chan &amp;lt;-&lt;/strong> کانال فقط ارسال&lt;/li>
&lt;li>&lt;strong>&amp;lt;-chan&lt;/strong> کانال فقط دریافت&lt;/li>
&lt;/ul>
&lt;h3 id="3641-کانال-فقط-ارسال">
3.6.4.1 کانال فقط ارسال
&lt;a class="anchor" href="#3641-%da%a9%d8%a7%d9%86%d8%a7%d9%84-%d9%81%d9%82%d8%b7-%d8%a7%d8%b1%d8%b3%d8%a7%d9%84">#&lt;/a>
&lt;/h3>
&lt;p>برای ایجاد کانال فقط ارسال شما می توانید به شکل زیر برای ورودی یا خروجی تابع تعریف کنید :&lt;/p>
&lt;pre>&lt;code class="language-go">func process(ch chan&amp;lt;- int){ doSomething }
&lt;/code>&lt;/pre>
&lt;p>زمانیکه شما تلاش کنید کانال با جهت های مختلف به پارامتر ورودی تابع فقط ارسال کانالی را پاس دهید با خطای زیر مواجه خواهید شد :&lt;/p>
&lt;pre>&lt;code class="language-go">invalid operation: &amp;lt;-ch (receive from send-only type chan&amp;lt;- int)
&lt;/code>&lt;/pre>
&lt;p>به مثال ساده زیر توجه کنید :&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import &amp;quot;fmt&amp;quot;
func main() {
ch := make(chan int, 3)
go process(ch)
fmt.Println(&amp;lt;-ch)
}
func process(ch chan&amp;lt;- int) {
ch &amp;lt;- 2
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-shell">$ go run main.go
2
&lt;/code>&lt;/pre>
&lt;p>در کد فوق ما یک تابع به نام process ایجاد کردیم که کانال فقط ارسال به عنوان پارامتر ورودی دارد و در ادامه ما کانال ch را که دو طرفه است به این تابع پاس دادیم و مقدار دریافتی را چاپ کردیم.&lt;/p>
&lt;h3 id="3642-کانال-فقط-دریافت">
3.6.4.2 کانال فقط دریافت
&lt;a class="anchor" href="#3642-%da%a9%d8%a7%d9%86%d8%a7%d9%84-%d9%81%d9%82%d8%b7-%d8%af%d8%b1%db%8c%d8%a7%d9%81%d8%aa">#&lt;/a>
&lt;/h3>
&lt;p>برای ایجاد کانال فقط دریافت شما می توانید به شکل زیر برای ورودی یا خروجی تابع تعریف کنید :&lt;/p>
&lt;pre>&lt;code class="language-go">func process(ch &amp;lt;-chan int){ doSomething }
&lt;/code>&lt;/pre>
&lt;p>زمانیکه شما تلاش کنید کانال با جهت های مختلف به پارامتر ورودی تابع فقط دریافت پاس دهید با خطای زیر مواجه خواهید شد :&lt;/p>
&lt;pre>&lt;code class="language-go">invalid operation: ch &amp;lt;- 2 (send to receive-only type &amp;lt;-chan int)
&lt;/code>&lt;/pre>
&lt;p>به مثال ساده زیر توجه کنید :&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import &amp;quot;fmt&amp;quot;
func main() {
ch := make(chan int, 3)
ch &amp;lt;- 2
process(ch)
}
func process(ch &amp;lt;-chan int) {
s := &amp;lt;-ch
fmt.Println(s)
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-shell">$ go run main.go
2
&lt;/code>&lt;/pre>
&lt;h2 id="365-گرفتن-ظرفیت-یک-کانال">
3.6.5 گرفتن ظرفیت یک کانال
&lt;a class="anchor" href="#365-%da%af%d8%b1%d9%81%d8%aa%d9%86-%d8%b8%d8%b1%d9%81%db%8c%d8%aa-%db%8c%da%a9-%da%a9%d8%a7%d9%86%d8%a7%d9%84">#&lt;/a>
&lt;/h2>
&lt;p>شما می توانید همانند slice یا آرایه ظرفیت یک کانال را با استفاده از تابع ()cap ببینید.&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import &amp;quot;fmt&amp;quot;
func main() {
ch := make(chan int, 3)
fmt.Printf(&amp;quot;Capacity: %d\n&amp;quot;, cap(ch))
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-shell">$ go run main.go
Capacity: 3
&lt;/code>&lt;/pre>
&lt;blockquote class="book-hint warning">
توجه کنید ظرفیت کانال بافر نشده همیشه صفر است.
&lt;/blockquote>
&lt;h2 id="366-گرفتن-طول-یک-کانال">
3.6.6 گرفتن طول یک کانال
&lt;a class="anchor" href="#366-%da%af%d8%b1%d9%81%d8%aa%d9%86-%d8%b7%d9%88%d9%84-%db%8c%da%a9-%da%a9%d8%a7%d9%86%d8%a7%d9%84">#&lt;/a>
&lt;/h2>
&lt;p>شما با استفاده از تابع ()len می توانید طول و اندازه یک کانال را بگیرید و ببینید چه مقدار داده داخل کانال قرار دارد.&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import &amp;quot;fmt&amp;quot;
func main() {
ch := make(chan int, 3)
ch &amp;lt;- 5
fmt.Printf(&amp;quot;Len: %d\n&amp;quot;, len(ch))
ch &amp;lt;- 6
fmt.Printf(&amp;quot;Len: %d\n&amp;quot;, len(ch))
ch &amp;lt;- 7
fmt.Printf(&amp;quot;Len: %d\n&amp;quot;, len(ch))
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-shell">$ go run main.go
Len: 1
Len: 2
Len: 3
&lt;/code>&lt;/pre>
&lt;h2 id="367-عملیات-بستن-close-یک-کانال">
3.6.7 عملیات بستن (close) یک کانال
&lt;a class="anchor" href="#367-%d8%b9%d9%85%d9%84%db%8c%d8%a7%d8%aa-%d8%a8%d8%b3%d8%aa%d9%86-close-%db%8c%da%a9-%da%a9%d8%a7%d9%86%d8%a7%d9%84">#&lt;/a>
&lt;/h2>
&lt;p>در زبان گو ما یک تابع Built-in به نام close داریم که می توانیم برای بستن یک کانال استفاده کنیم و زمانیکه که یک کانال بسته شود دیگر نمی توانیم داده ای را به آن کانال ارسال کنیم. کانال معمولا زمانی بسته می شود که همه داده ها ارسال شده است و داده دیگری برای ارسال نداریم و باید کانال را ببندیم.&lt;/p>
&lt;p>به مثال زیر توجه کنید :&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;fmt&amp;quot;
&amp;quot;time&amp;quot;
)
func main() {
ch := make(chan int)
go sum(ch, 3)
ch &amp;lt;- 2
ch &amp;lt;- 2
ch &amp;lt;- 2
close(ch)
time.Sleep(time.Second * 1)
}
func sum(ch chan int, len int) {
sum := 0
for i := 0; i &amp;lt; len; i++ {
sum += &amp;lt;-ch
}
fmt.Printf(&amp;quot;Sum: %d\n&amp;quot;, sum)
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-shell">$ go run main.go
Sum: 6
&lt;/code>&lt;/pre>
&lt;p>در کد فوق ما یک کانال بافر شده با ظرفیت ۳ ایجاد کردیم و سپس ۳ تا مقدار را به کانال ارسال کردیم و پس از آن کانال را با تابع close بستیم چون دیگر نمیخواهیم داده دیگری را ارسال کنیم.&lt;/p>
&lt;blockquote class="book-hint danger">
&lt;p>توجه کنید ارسال داده برروی کانال بسته شده ممکن است برنامه شما با خطای panic مواجه و کاملا متوقف شود.&lt;/p>
&lt;pre>&lt;code class="language-go">package main
func main() {
ch := make(chan int)
close(ch)
ch &amp;lt;- 2
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-shell">$ go run main.go
panic: send on closed channel
&lt;/code>&lt;/pre>
&lt;p>اما برای اینکه بتوانیم جلوی این panic رخ داده را بگیریم می توانیم زمانیکه داریم از کانال مقدار دریافت می کنیم assertion انجام دهیم تا متوجه بسته بودن کانال شویم :&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;fmt&amp;quot;
)
func main() {
ch := make(chan int, 1)
ch &amp;lt;- 2
val, ok := &amp;lt;-ch
fmt.Printf(&amp;quot;Val: %d OK: %t\n&amp;quot;, val, ok)
close(ch)
val, ok = &amp;lt;-ch
fmt.Printf(&amp;quot;Val: %d OK: %t\n&amp;quot;, val, ok)
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-shell">$ go run main.go
Val: 2 OK: true
Val: 0 OK: false
&lt;/code>&lt;/pre>
&lt;p>اگر مقدار ok از کانال دریافتی true باشد یعنی کانال بسته نشده است و اگر مقدار false دریافت کنیم یعنی کانال بسته شده است.&lt;/p>
&lt;/blockquote>
&lt;h2 id="368-استفاده-از-حلقه-for-range-برروی-کانال">
3.6.8 استفاده از حلقه for-range برروی کانال
&lt;a class="anchor" href="#368-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-%d8%ad%d9%84%d9%82%d9%87-for-range-%d8%a8%d8%b1%d8%b1%d9%88%db%8c-%da%a9%d8%a7%d9%86%d8%a7%d9%84">#&lt;/a>
&lt;/h2>
&lt;p>یکی از کاربردی ترین حالت های دریافت داده از کانال استفاده از حلقه for-range است که می توانید تا زمان بسته شدن کانال مقدار دریافت کنید.&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;fmt&amp;quot;
&amp;quot;time&amp;quot;
)
func main() {
ch := make(chan int, 3)
ch &amp;lt;- 2
ch &amp;lt;- 2
ch &amp;lt;- 2
close(ch)
go sum(ch)
time.Sleep(time.Second * 1)
}
func sum(ch chan int) {
sum := 0
for val := range ch {
sum += val
}
fmt.Printf(&amp;quot;Sum: %d\n&amp;quot;, sum)
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-shell">$ go run main.go
Sum: 6
&lt;/code>&lt;/pre>
&lt;p>در کد فوق ما یک کانال بافر شده با ظرفیت ۳ ایجاد کردیم سپس ۳ تا مقدار به کانال ارسال کردیم و داخل تابع sum مقادیر را با استفاده از حلقه for-range دریافت و پس از آن چاپ کردیم.&lt;/p>
&lt;p>حالا یک سوال پیش می آید آیا ما اگر کانال را در تابع main نبندیم چه اتفاقی می افتد؟ اگر شما کانال را نبندید بطور حتمی با خطا deadlock مواجه خواهید شد. حلقه ای که داخل تابع sum قرار دادید برای دریافت داده هیچوقت متوقف نخواهد شد.&lt;/p>
&lt;p>&lt;strong>پس سعی کنید همیشه و همه جا در جای درست بستن کانال را انجام دهید تا دچار مشکلات مختلف نشوید.&lt;/strong>&lt;/p>
&lt;h2 id="369-کانال-nil">
3.6.9 کانال nil
&lt;a class="anchor" href="#369-%da%a9%d8%a7%d9%86%d8%a7%d9%84-nil">#&lt;/a>
&lt;/h2>
&lt;p>همانطور که در اوایل این بخش گفتیم مقدار پیش فرض یک کانال nil است و زمانیکه ما یک کانال بدون تابع make تعریف می کنیم مقدار پیش فرضش nil خوهد بود.&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import &amp;quot;fmt&amp;quot;
func main() {
var a chan int
fmt.Print(&amp;quot;Default zero value of channel: &amp;quot;)
fmt.Println(a)
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-shell">$ go run main.go
Default zero value of channel: &amp;lt;nil&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>یکسری نکات در خصوص کانال nil وجود دارد :&lt;/p>
&lt;ul>
&lt;li>ارسال داده به یک کانالی که nil است باعث بلاک شدن همیشگی کد شما در آن خط خواهد شد.&lt;/li>
&lt;li>دریافت داده به یک کانالی که nil است باعث بلاک شدن همیشگی کد شما در آن خط خواهد شد.&lt;/li>
&lt;li>بستن یک کانالی که nil باشد باعث panic برنامه شما خواهد شد.&lt;/li>
&lt;/ul></description></item><item><author/><title>3.7 آموزش استفاده از select</title><link>https://book.gofarsi.ir/chapter-3/go-select/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-3/go-select/</guid><description>&lt;p>در زبان گو select همانند switch می باشد که دارای case و default هستش اما یک فرق کلی دارد که به عملکردش برمیگردد. case های select برای عملیات ارسال و دریافت از کانال منتظر می ماند. در کل شما با استفاده از select می توانید از کانال های مختلف اطلاعات ارسال و دریافت کنید و پس از آن برروی آن اطلاعات عملیات انجام دهید.&lt;/p>
&lt;ul>
&lt;li>select تا زمانی که یکی از case ها آماده شود بلاک می شود.&lt;/li>
&lt;li>اگر همزمان چندتا case برای انجام عملیات آماده شود select بصورت تصادفی یکی را انتخاب میکند تا عملیات تکمیل شود.&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-go">select {
case channel_send_or_receive:
//Dosomething
case channel_send_or_receive:
//Dosomething
default:
//Dosomething
}
&lt;/code>&lt;/pre>
&lt;p>select از بین case ها موردی را انتخاب می کند که در آن عملیات ارسال یا دریافت کانال بلاک نشده باشد و آماده اجرا باشد. اگر چند مورد از case ها آماده باشد یکی از آنها بصورت تصادفی انتخاب می شود تا فرآیند را تکمیل کند.&lt;/p>
&lt;p>بزارید یک مثال ساده بزنیم :&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import &amp;quot;fmt&amp;quot;
func main() {
ch1 := make(chan string)
ch2 := make(chan string)
go goOne(ch1)
go goTwo(ch2)
select {
case msg1 := &amp;lt;-ch1:
fmt.Println(msg1)
case msg2 := &amp;lt;-ch2:
fmt.Println(msg2)
}
}
func goOne(ch chan string) {
ch &amp;lt;- &amp;quot;From goOne goroutine&amp;quot;
}
func goTwo(ch chan string) {
ch &amp;lt;- &amp;quot;From goTwo goroutine&amp;quot;
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-shell">$ go run main.go
From goOne goroutine
&lt;/code>&lt;/pre>
&lt;p>در کد فوق ما ۲ تا کانال تعریف کردیم و کانال ها را به توابع goOne و goTwo پاس دادیم سپس داخل تابع به هرکدام از کانال مقداری ارسال شد. حالا در ادامه بدنه main یک select قرار دادیم که هر یک از case ها منتظر دریافت اطلاعات از کانال مشخص شده‌اش است.&lt;/p>
&lt;p>بلافاصله پس از‌اینکه یکی از کانال ها آماده ارسال داده شود، کیس آن اجرا می شود. اگر هر دوی کانال ها همزمان آماده ارسال داده شوند، به‌صورت تصادفی یکی از case ها انتخاب می شود تا عملیات را تکمیل کند.&lt;/p>
&lt;p>که در خروجی مقداری که از ch1 آمده را نمایش می دهد. اما اگر بخواهیم خروجی هر دو کانال را ببینیم می توانیم از حلقه استفاده کنیم. به مثال زیر توجه کنید :&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import &amp;quot;fmt&amp;quot;
func main() {
ch1 := make(chan string)
ch2 := make(chan string)
go goOne(ch1)
go goTwo(ch2)
for i := 0; i &amp;lt; 2; i++ {
select {
case msg1 := &amp;lt;-ch1:
fmt.Println(msg1)
case msg2 := &amp;lt;-ch2:
fmt.Println(msg2)
}
}
}
func goOne(ch chan string) {
ch &amp;lt;- &amp;quot;From goOne goroutine&amp;quot;
}
func goTwo(ch chan string) {
ch &amp;lt;- &amp;quot;From goTwo goroutine&amp;quot;
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-shell">$ go run main.go
From goOne goroutine
From goTwo goroutine
&lt;/code>&lt;/pre>
&lt;p>در کد فوق ما select را داخل یک حلقه for قرار دادیم و گفتیم اگر مقدار i کوچکتر از ۲ بود ++i شود. که در هر دو تایم مقدار دریافتی از کانال ها را توانستیم به عنوان خروجی چاپ کنیم.&lt;/p>
&lt;p>همانطور که قبلا گفتیم اگر شما داخل select یک case را بزارید که هیچ اطلاعات از کانال دریافت نکند ممکن است برنامه شما کاملا بلاک شود و با خطای deadlock مواجه شوید.&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import &amp;quot;fmt&amp;quot;
func main() {
ch1 := make(chan string)
select {
case msg := &amp;lt;-ch1:
fmt.Println(msg)
}
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-shell">$ go run main.go
fatal error: all goroutines are asleep - deadlock!
&lt;/code>&lt;/pre>
&lt;p>اتفاقی که در کد فوق رخ داد ما یک کانال ایجاد کردیم و سپس داخل select یک case قرار دادیم که منتظر دریافت داده از کانال می باشد. اما چون هیچ داده‌ای به کانال ارسال نمی شود برنامه بطور کلی در همان تیکه از کد بلاک می شود و در نهایت شما با این خطا مواجه خواهید شد.&lt;/p>
&lt;h2 id="371-نحوه-کنترل-عملیات-های-کانال-با-select">
3.7.1 نحوه کنترل عملیات های کانال با select
&lt;a class="anchor" href="#371-%d9%86%d8%ad%d9%88%d9%87-%da%a9%d9%86%d8%aa%d8%b1%d9%84-%d8%b9%d9%85%d9%84%db%8c%d8%a7%d8%aa-%d9%87%d8%a7%db%8c-%da%a9%d8%a7%d9%86%d8%a7%d9%84-%d8%a8%d8%a7-select">#&lt;/a>
&lt;/h2>
&lt;p>در بالا در خصوص select توضیح دادیم که چه کاربردی هایی دارد اما بذارید توضیحات را تکمیل کنیم. وقتی شما قصد دارید از گوروتین و کانال استفاده کنید در اینجا select نقش خیلی پررنگی در کنترل عملیات کانال ها دارد. اینجاست که بحث همزمانی در زبان گو خیلی زیبا می شود. select می تواند بطور همزمان داده را از کانال دریافت کند و برای اجرا سایر عملیات آماده کند. بنابراین select همراه با کانال و گوروتین خیلی ابزار قدرتمندی برای کنترل و مدیریت همگام سازی و همزمانی می باشد.&lt;/p>
&lt;h3 id="3711-عملیات-ارسال-با-select">
3.7.1.1 عملیات ارسال با select
&lt;a class="anchor" href="#3711-%d8%b9%d9%85%d9%84%db%8c%d8%a7%d8%aa-%d8%a7%d8%b1%d8%b3%d8%a7%d9%84-%d8%a8%d8%a7-select">#&lt;/a>
&lt;/h3>
&lt;p>در زیر یک مثالی زدیم که با استفاده از select داده ای را به کانال میریزیم و سپس آن داده را از کانال دیگر دریافت می کنیم :&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import &amp;quot;fmt&amp;quot;
func main() {
ch1 := make(chan string)
ch2 := make(chan string)
go goOne(ch1)
go goTwo(ch2)
select {
case msg1 := &amp;lt;-ch1:
fmt.Println(msg1)
case ch2 &amp;lt;- &amp;quot;To goTwo goroutine&amp;quot;:
}
}
func goOne(ch chan string) {
ch &amp;lt;- &amp;quot;From goOne goroutine&amp;quot;
}
func goTwo(ch chan string) {
msg := &amp;lt;-ch
fmt.Println(msg)
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-shell">$ go run main.go
To goTwo goroutine
&lt;/code>&lt;/pre>
&lt;p>در کد فوق ما با استفاده از یکی از case های select داده‌ای را داخل کانال ریختیم و آن داده را داخل گوروتین تابع goTwo دریافت کردیم و پس آن مقدار دریافتی را چاپ کردیم.&lt;/p>
&lt;h2 id="372-استفاده-از-default-در-select">
3.7.2 استفاده از default در select
&lt;a class="anchor" href="#372-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-default-%d8%af%d8%b1-select">#&lt;/a>
&lt;/h2>
&lt;p>در زبان گو switch و select می توانند یک default داشته باشند. در اینجا default مربوط select رفتارش همانند default داخل switch می باشد. حالا اگر هر یک از case ها عملیات دریافت یا ارسالی برای اجرا نداشته باشند می توانید با استفاده از default از بلاک شدن برای همیشه جلوگیری کنید. و خیلی مهمه که بدانید وقتی دارید داخل select از default استفاده می کنید select از نوع non-blocking می شود. اگر شما داخل select از default استفاده نکنید ممکن است آن بخش کد شما مسدود شود تا زمانیکه یکی از case ها از کانال داده ای را دریافت کند تا ادامه عملیات صورت گیرد.&lt;/p>
&lt;p>به مثال زیر توجه کنید :&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import &amp;quot;fmt&amp;quot;
func main() {
ch1 := make(chan string)
select {
case msg := &amp;lt;-ch1:
fmt.Println(msg)
default:
fmt.Println(&amp;quot;Default statement executed&amp;quot;)
}
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-shell">$ go run main.go
Default statement executed
&lt;/code>&lt;/pre>
&lt;p>در کد فوق ما یک کانال ایجاد کردیم و دریافت داده از کانال را داخل یکی از case های select قرار دادیم و پس از آن default را قرار دادیم که از مسدود شدن برنامه جلوگیری کند.&lt;/p>
&lt;h2 id="373-مسدود-سازی-select-با-استفاده-از-timeout">
3.7.3 مسدود سازی select با استفاده از timeout
&lt;a class="anchor" href="#373-%d9%85%d8%b3%d8%af%d9%88%d8%af-%d8%b3%d8%a7%d8%b2%db%8c-select-%d8%a8%d8%a7-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-timeout">#&lt;/a>
&lt;/h2>
&lt;p>شما می توانید یک select را با استفاده از timeout بطور موقت تا یک بازه زمانی مسدود کنید. که اینکار توسط تابع &lt;a href="https://pkg.go.dev/time#Time.After">After&lt;/a> داخل پکیج time صورت میگیرد.&lt;/p>
&lt;pre>&lt;code class="language-go">func After(d Duration) &amp;lt;-chan Time
&lt;/code>&lt;/pre>
&lt;p>تابع After یک مدت زمان میگیرد و سپس به عنوان خروجی یک کانال فقط دریافت از نوع Time برمیگرداند.&lt;/p>
&lt;p>به مثال زیر توجه کنید :&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;fmt&amp;quot;
&amp;quot;time&amp;quot;
)
func main() {
ch1 := make(chan string)
go goOne(ch1)
select {
case msg := &amp;lt;-ch1:
fmt.Println(msg)
case &amp;lt;-time.After(time.Second * 1):
fmt.Println(&amp;quot;Timeout&amp;quot;)
}
}
func goOne(ch chan string) {
time.Sleep(time.Second * 2)
ch &amp;lt;- &amp;quot;From goOne goroutine&amp;quot;
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-shell">$ go run main.go
Timeout
&lt;/code>&lt;/pre>
&lt;p>در کد فوق ما در یکی از case های select تابع After را به عنوان کانال دریافت کننده قرار دادیم و سپس مقدار ۱ ثانیه به تابع After پاس دادیم و پس از ۱ ثانیه select از مسدودی خارج شد.&lt;/p>
&lt;h2 id="374-select-خالی">
3.7.4 select خالی
&lt;a class="anchor" href="#374-select-%d8%ae%d8%a7%d9%84%db%8c">#&lt;/a>
&lt;/h2>
&lt;p>یک select خالی و بدون case می تواند برنامه شما را به‌طور کلی بلاک کند و باعث بروز خطای deadlock شود. اگر select خالی داخل یک گوروتین دیگری قرار گیرد آن گوروتین بطور کلی برای همیشه بلاک خواهد شد اما اگر داخل تابع main قرار دهید باعث بروز deadlock خواهد شد.&lt;/p>
&lt;pre>&lt;code class="language-go">package main
func main() {
select {}
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-shell">$ go run main.go
fatal error: all goroutines are asleep - deadlock!
&lt;/code>&lt;/pre>
&lt;h2 id="375-استفاده-از-select-در-حلقه-بینهایت">
3.7.5 استفاده از select در حلقه بینهایت
&lt;a class="anchor" href="#375-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-select-%d8%af%d8%b1-%d8%ad%d9%84%d9%82%d9%87-%d8%a8%db%8c%d9%86%d9%87%d8%a7%db%8c%d8%aa">#&lt;/a>
&lt;/h2>
&lt;p>ما می توانیم select را داخل یک حلقه بینهایت قرار دهیم تا برای همیشه از case ها چندتا داده را بواسطه کانال دریافت کنیم و عملیاتی را انجام دهیم. همچنین اگر قصد داریم که آنقدر کیس ها چک شوند تا یکی از کانال ها برای ارسال و یا دریافت داده آماده باشد، می توانیم از این روش استفاده کنیم و در نهایت با return کردن از حلقه بینهایت خارج شویم.&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;fmt&amp;quot;
&amp;quot;time&amp;quot;
)
func main() {
news := make(chan string)
go newsFeed(news)
printAllNews(news)
}
func printAllNews(news chan string) {
for {
select {
case n := &amp;lt;-news:
fmt.Println(n)
case &amp;lt;-time.After(time.Second * 1):
fmt.Println(&amp;quot;Timeout: News feed finished&amp;quot;)
return
}
}
}
func newsFeed(ch chan string) {
for i := 0; i &amp;lt; 2; i++ {
time.Sleep(time.Millisecond * 400)
ch &amp;lt;- fmt.Sprintf(&amp;quot;News: %d&amp;quot;, i+1)
}
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-shell">$ go run main.go
News: 1
News: 2
Timeout: News feed finished
&lt;/code>&lt;/pre>
&lt;p>در کد فوق ما یک کانال بافر نشده با نام news ایجاد کردیم و این کانال را داخل گوروتین newsFeed و تابع printAllNews قرار داده‌ایم. تابع newsFeed یک مقداری را به کانال ارسال می کند. و ما داخل تابع printAllNews بواسطه حلقه بینهایت و select دریافت می کنیم و یکی از case های select عملیات timeout را دارد که بعد ۱ ثانیه حلقه را کاملا متوقف کند.&lt;/p>
&lt;h2 id="376-select-با-یک-کانال-nil">
3.7.6 select با یک کانال nil
&lt;a class="anchor" href="#376-select-%d8%a8%d8%a7-%db%8c%da%a9-%da%a9%d8%a7%d9%86%d8%a7%d9%84-nil">#&lt;/a>
&lt;/h2>
&lt;p>معمولا اگر یک کانال nil را برای ارسال یا دریافت داخل case قرار دهید برنامه شما همیشه بلاک می شود. اگر شما داخل یکی از case ها بیاید پس از انجام عملیات مقدار یک کانال را nil بزارید case ای که مقدار داخل کانال را دریافت می کند غیرفعال می شود و به هیچ عنوان دیگر قابل استفاده نخواهد بود. و توسط select آن case کاملا نادیده گرفته خواهد شد و select منتظر دریافت و ارسال داده از سایر case ها خواهد بود.&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;fmt&amp;quot;
&amp;quot;time&amp;quot;
)
func main() {
news := make(chan string)
go newsFeed(news)
printAllNews(news)
}
func printAllNews(news chan string) {
for {
select {
case n := &amp;lt;-news:
fmt.Println(n)
news = nil
case &amp;lt;-time.After(time.Second * 1):
fmt.Println(&amp;quot;Timeout: News feed finished&amp;quot;)
return
}
}
}
func newsFeed(ch chan string) {
for i := 0; i &amp;lt; 2; i++ {
time.Sleep(time.Millisecond * 400)
ch &amp;lt;- fmt.Sprintf(&amp;quot;News: %d&amp;quot;, i+1)
}
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-shell">$ go run main.go
News: 1
Timeout: News feed finished
&lt;/code>&lt;/pre>
&lt;p>در کد فوق ما داخل &lt;code>case n := &amp;lt;-news&lt;/code> پس از اینکه مقدار دریافتی را چاپ کردیم اومدیم مقدار کانال news را برابر nil قرار دادیم. حالا اگر داده‌ای به اون کانال ارسال شود دیگر نمی توانیم دریافت کنیم و select آن case را بطور کلی نادیده میگیرد.&lt;/p>
&lt;pre>&lt;code class="language-go">case n := &amp;lt;-news:
fmt.Println(n)
news = nil
&lt;/code>&lt;/pre>
&lt;h2 id="377-استفاده-از-break-در-select">
3.7.7 استفاده از break در select
&lt;a class="anchor" href="#377-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-break-%d8%af%d8%b1-select">#&lt;/a>
&lt;/h2>
&lt;p>شما می توانید break را داخل هر یک از case های select استفاده کنید.&lt;/p>
&lt;pre>&lt;code class="language-go">import &amp;quot;fmt&amp;quot;
func main() {
ch := make(chan string, 1)
ch &amp;lt;- &amp;quot;Before break&amp;quot;
select {
case msg := &amp;lt;-ch:
fmt.Println(msg)
break
fmt.Println(&amp;quot;After break&amp;quot;)
default:
fmt.Println(&amp;quot;Default case&amp;quot;)
}
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-shell">$ go run main.go
Before break
&lt;/code>&lt;/pre>
&lt;p>در کد فوق ما با استفاده از break توانستیم select را کاملا متوقف کنیم و برنامه اتمام شود و اگر دقت کرده باشید بعد از break کلمات After break چاپ نشده.&lt;/p>
&lt;pre>&lt;code class="language-go">fmt.Println(&amp;quot;After break&amp;quot;)
&lt;/code>&lt;/pre></description></item><item><author/><title>3.8 پکیج context</title><link>https://book.gofarsi.ir/chapter-3/go-context/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-3/go-context/</guid><description>&lt;center>&lt;a href="#">
&lt;img src="../../assets/img/content/chapter3/context/1.png" alt="context">
&lt;/a>&lt;/center>
&lt;p>پکیج &lt;a href="https://pkg.go.dev/context">context&lt;/a> یک پکیج built-in است که یکی از پرکاربرد ترین پکیج های زبان گو می باشد. کار اصلی این پکیج فراهم کردن بستری است که بتوان به داده های مشترک دسترسی داشت و یا بتوان آنها را به اشتراک گذاشت و مدیریت کرد. حتی اگر شما نخواسته باشید سمت این پکیج بروید به مرور زمان که جلوتر می روید با این پکیج رو به رو خواهید شد و مجبور خواهید بود این پکیج را یاد بگیرید.&lt;/p>
&lt;p>این پکیج چندان بزرگ نیست و شاید بتوانید توابع و مفاهیم آن را خیلی زود یاد بگیرید اما حتما یک روزی این پکیج تبدیل به یکی از بنیادی ترین قسمت های کدتان خواهد شد.&lt;/p>
&lt;p>در این بخش از کتاب سعی خواهد شد مفاهیم context به صورت ساده و قابل درک، بیان شود.&lt;/p>
&lt;h2 id="381-context-چیست">
3.8.1 context چیست؟
&lt;a class="anchor" href="#381-context-%da%86%db%8c%d8%b3%d8%aa">#&lt;/a>
&lt;/h2>
&lt;p>در واقع context مانند یک درخت می باشد که کلی شاخه دارد و هر شاخه به شاخه های ریزتری تقسیم شده و در نهایت به برگ ها و میوه های درخت منتهی می شوند. حال شما می توانید در هر ناحیه شاخه والد را قطع کنید تا شاخه های فرزند از بین برود.
در زبان گو &lt;code>context&lt;/code> یک اینترفیس است که یکسری متد دارد که هریک از متدها می تواند عملیاتی را انجام دهد و این امکان را فراهم می کند هر وقت یک درخواست از سمت کلاینت به سرور می آید این درخواست می تواند در لایه های مختلف منتهی شود و داخل context می تواند یکسری key/value های مهم باشد که شما بتوانید در هر لایه، به آنها دسترسی داشته باشید و همچنین در صورت لزوم می توانید سیگنال cancel بفرستید که درخواستی که تا هرجا رفته است کنسل شود.&lt;/p>
&lt;p>در ادامه با طرح یک مثال ساده به درک بهتر این موضوع کمک می کنیم :&lt;/p>
&lt;center>&lt;a href="#">
&lt;img src="../../assets/img/content/chapter3/context/3.jpg" alt="context diagram">
&lt;/a>&lt;/center>
&lt;p>فرض کنید یک سرور http راه اندازی کردید (در فصل ۵ آشنا خواهید شد) که یکسری آدرس API دارد که کلاینت می تواند با استفاده از این آدرس ها با سرور شما ارتباط برقرار کند و عملیات مشخصی را انجام دهد. حال وقتی کلاینت درخواست می دهد. درخواست تا زمانیکه کامل شود و خروجی به کاربر نمایش داده شود می توانید این درخواست را بواسطه context در لایه های مختلف پروژه خود منتهی کنید و یکسری عملیات یا اطلاعات را در هر لایه از context بگیرید. اگر به دیاگرام فوق نگاه کنید اگر کلاینت درخواستش را لغو کند و درخواست کاربر به واسط context تا لایه Manager رفته باشد می تواند این درخواست در همان لایه متوقف شود و عملیات تکمیل نشود.&lt;/p>
&lt;blockquote class="book-hint info">
&lt;p>برای درک بهتر مثال فوق بهتره فایل صوتی زیر را گوش دهید تا بهتر بتوانید درک کنید :&lt;/p>
&lt;audio controls>
&lt;source src="../../assets/audio/chapter3/context/context.mp3" type="audio/mpeg">
&lt;/audio>
&lt;a href="https://book.gofarsi.ir/assets/audio/chapter3/context/context.mp3" target="_blank" rel="noopener" class="book-btn">
دانلود فایل صوت
&lt;/a>
&lt;/blockquote>
&lt;h3 id="3811-کاربردهای-context">
3.8.1.1 کاربردهای context
&lt;a class="anchor" href="#3811-%da%a9%d8%a7%d8%b1%d8%a8%d8%b1%d8%af%d9%87%d8%a7%db%8c-context">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>لغو یک درخواستی که منتهی شده به لایه های مختلف پروژه بواسطه تابع cancel در پکیج context&lt;/li>
&lt;li>انتقال داده های حساس به لایه های مختلف بواسطه تابع WithValue در پکیج context&lt;/li>
&lt;li>گذاشتن timeout برروی context جهت لغو درخواستی که خیلی باعث منتظر ماندن می شود بواسطه تابع WithTimeout در پکیج context&lt;/li>
&lt;/ul>
&lt;h3 id="3812-معرفی-اینترفیس-context">
3.8.1.2 معرفی اینترفیس context
&lt;a class="anchor" href="#3812-%d9%85%d8%b9%d8%b1%d9%81%db%8c-%d8%a7%db%8c%d9%86%d8%aa%d8%b1%d9%81%db%8c%d8%b3-context">#&lt;/a>
&lt;/h3>
&lt;p>بدنه اصلی یک context از اینترفیس تشکیل شده که یکسری متدها برای مدیریت یک درخواست برروی لایه های مختلف را دارد.&lt;/p>
&lt;pre>&lt;code class="language-go">type Context interface {
//It retures a channel when a context is cancelled, timesout (either when deadline is reached or timeout time has finished)
Done() &amp;lt;-chan struct{}
//Err will tell why this context was cancelled. A context is cancelled in three scenarios.
// 1. With explicit cancellation signal
// 2. Timeout is reached
// 3. Deadline is reached
Err() error
//Used for handling deallines and timeouts
Deadline() (deadline time.Time, ok bool)
//Used for passing request scope values
Value(key interface{}) interface{}
}
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>&lt;strong>متد Done :&lt;/strong> بواسطه این متد که یک کانال فقط دریافت است شما می توانید سیگنال توقف درخواست را دریافت کنید و خطا برگردانید.&lt;/li>
&lt;li>&lt;strong>متد Err :&lt;/strong> داخل این متد اینترفیس خطا وجود دارد که خطاهای مربوط به context را می توانید دریافت و مدیریت کنید.&lt;/li>
&lt;li>&lt;strong>متد Deadline :&lt;/strong> با استفاده از این متد می توانید context هایی که از نوع Deadline هستند را مدیریت کنید.&lt;/li>
&lt;li>&lt;strong>متد Value :&lt;/strong> با استفاده از این می توانید مقادیری که بصورت key/value داخل context ذخیره شده را دریافت کنید که بصورت اینترفیس یک key میگیرد و به صورت اینترفیس مقدار داخل key را برمیگرداند.&lt;/li>
&lt;/ul>
&lt;h2 id="382-ایجاد-یک-context">
3.8.2 ایجاد یک context
&lt;a class="anchor" href="#382-%d8%a7%db%8c%d8%ac%d8%a7%d8%af-%db%8c%da%a9-context">#&lt;/a>
&lt;/h2>
&lt;p>شما با استفاده از ۲ تابع داخل پکیج context می توانید اولین context خام را ایجاد کنید و در واقع این context ایجاد شده می تواند والد تمامی context هایی که در لایه مختلف ایجاد کردید باشد.&lt;/p>
&lt;p>برای ایجاد context گفتیم ۲ تابع وجود دارد که به شرح زیر می باشد :&lt;/p>
&lt;h4 id="contextbackground-">
context.Background() :
&lt;a class="anchor" href="#contextbackground-">#&lt;/a>
&lt;/h4>
&lt;p>داخل پکیج context ما یک تابع داریم به نام Background که اولین context خام و والد را میسازد و به شما یک اینترفیس از نوع Context می دهد.&lt;/p>
&lt;ol>
&lt;li>این context ایجاد شده هیچ مقداری داخلش ندارد.&lt;/li>
&lt;li>هیچ وقت نمی تواند کنسل شود.&lt;/li>
&lt;li>و هیچ deadline ندارد.&lt;/li>
&lt;/ol>
&lt;p>در هر صورت بدانید ریشه اصلی context شما با این تابع ایجاد می شود و نقطه شروع انتقال یک درخواست بین لایه هایتان با این context والد خواهد بود.&lt;/p>
&lt;pre>&lt;code class="language-go">func Background() Context
&lt;/code>&lt;/pre>
&lt;h4 id="contexttodo-">
context.ToDo() :
&lt;a class="anchor" href="#contexttodo-">#&lt;/a>
&lt;/h4>
&lt;p>داخل پکیج context ما یک تابع داریم به نام ToDo که یک context خالی ایجاد می کند و هدف از این context ایجاد شده با ToDo این است هنوز برایمان مشخص نیست چکار میخوایم انجام بدیم با context می توانیم از این تابع استفاده کنیم. و معمولا برای تست ها و اعتبارسنجی و آنالیز کد خیلی کاربردی هست.&lt;/p>
&lt;p>و دقت کنید در پایه اصلی پروژه اتون بهتره از Background همیشه استفاده کنید.&lt;/p>
&lt;pre>&lt;code class="language-go">func TODO() Context
&lt;/code>&lt;/pre>
&lt;h2 id="383-درخت-context">
3.8.3 درخت Context
&lt;a class="anchor" href="#383-%d8%af%d8%b1%d8%ae%d8%aa-context">#&lt;/a>
&lt;/h2>
&lt;p>در واقع context خام یا ریشه که بواسطه تابع Background یا ToDo ایجاد می شود همانند یک درخت است که قرار است این درخت به شاخه های ریزتری تقسیم شود و هر یک از شاخه ها عملیات مختلفی کنترل شود و به شاخه های دیگر منتقل شود.&lt;/p>
&lt;center>&lt;a href="#">
&lt;img src="../../assets/img/content/chapter3/context/2.png" alt="context diagram">
&lt;/a>&lt;/center>
&lt;h3 id="3831-ایجاد-یک-فرزند-برای-context">
3.8.3.1 ایجاد یک فرزند برای context
&lt;a class="anchor" href="#3831-%d8%a7%db%8c%d8%ac%d8%a7%d8%af-%db%8c%da%a9-%d9%81%d8%b1%d8%b2%d9%86%d8%af-%d8%a8%d8%b1%d8%a7%db%8c-context">#&lt;/a>
&lt;/h3>
&lt;p>شما خیلی ساده مانند کد زیر می توانید یک فرزند برای درخت خود ایجاد کنید :&lt;/p>
&lt;pre>&lt;code class="language-go">rootCtx := context.Background()
childCtx := context.WithValue(rootCtx, &amp;quot;key&amp;quot;, &amp;quot;value&amp;quot;)
&lt;/code>&lt;/pre>
&lt;p>در کد فوق ما یک rootCtx ایجاد کردیم که همان درخت است و سپس اومدیم با استفاده از تابع WithValue یک شاخه ایجاد کردیم که داخل این شاخه یک key/value قرار دارد. که این key/value در لایه های دیگر که منتقل می شود قرار دارد.&lt;/p>
&lt;h3 id="3832-ایجاد-دو-فرزند-برای-context">
3.8.3.2 ایجاد دو فرزند برای context
&lt;a class="anchor" href="#3832-%d8%a7%db%8c%d8%ac%d8%a7%d8%af-%d8%af%d9%88-%d9%81%d8%b1%d8%b2%d9%86%d8%af-%d8%a8%d8%b1%d8%a7%db%8c-context">#&lt;/a>
&lt;/h3>
&lt;pre>&lt;code class="language-go">rootCtx := context.Background()
childCtx := context.WithValue(rootCtx, &amp;quot;key&amp;quot;, &amp;quot;value&amp;quot;)
childOfChildCtx, cancelFunc := context.WithCancel(childCtx)
&lt;/code>&lt;/pre>
&lt;p>در کد فوق :&lt;/p>
&lt;ul>
&lt;li>&lt;strong>rootCtx&lt;/strong> درخت است&lt;/li>
&lt;li>&lt;strong>childCtx&lt;/strong> فرزند اول است که با استفاده از WithValue ایجاد شده و یک مقدار key/value را نگه داری می کند.&lt;/li>
&lt;li>&lt;strong>childOfChildCtx&lt;/strong> برای فرزند اول context ما یک فرزند دیگری ایجاد کردیم با استفاده از تابع WithCancel که این تابع به شما یک context و یک تابع از نوع cancelFunc برمیگرداند.&lt;/li>
&lt;/ul>
&lt;h3 id="3833-درخت-چند-سطحی">
3.8.3.3 درخت چند سطحی
&lt;a class="anchor" href="#3833-%d8%af%d8%b1%d8%ae%d8%aa-%da%86%d9%86%d8%af-%d8%b3%d8%b7%d8%ad%db%8c">#&lt;/a>
&lt;/h3>
&lt;pre>&lt;code class="language-go">rootCtx := context.Background()
childCtx1 := context.WithValue(rootCtx, &amp;quot;key1&amp;quot;, &amp;quot;value1&amp;quot;)
childCtx2, cancelFunc := context.WithCancel(childCtx1)
childCtx3 := context.WithValue(rootCtx, &amp;quot;user_id&amp;quot;, &amp;quot;some_user_id&amp;quot;)
&lt;/code>&lt;/pre>
&lt;p>در کد فوق :&lt;/p>
&lt;ul>
&lt;li>&lt;strong>rootCtx&lt;/strong> درخت است&lt;/li>
&lt;li>&lt;strong>childCtx1&lt;/strong> فرزند اول است که با استفاده از WithValue ایجاد شده و یک مقدار key/value را نگه داری می کند.&lt;/li>
&lt;li>&lt;strong>childCtx2&lt;/strong> برای فرزند اول context ما یک فرزند دیگری ایجاد کردیم با استفاده از تابع WithCancel که این تابع به شما یک context و یک تابع از نوع cancelFunc برمیگرداند.&lt;/li>
&lt;li>&lt;strong>childCtx3&lt;/strong> با استفاده از WithValue از rootCtx که درخت است تشکیل شده&lt;/li>
&lt;/ul>
&lt;center>&lt;a href="#">
&lt;img src="../../assets/img/content/chapter3/context/4.jpg" alt="context multi-level">
&lt;/a>&lt;/center>
&lt;p>حالا اگر ما برای childCtx1 بیایم یک فرزند دیگر با نام childCtx4 اضافه کنیم بصورت زیر خواهد شد :&lt;/p>
&lt;pre>&lt;code class="language-go">childCtx4 := context.WithValue(childCtx1, &amp;quot;current_time&amp;quot;, &amp;quot;some_time)
&lt;/code>&lt;/pre>
&lt;center>&lt;a href="#">
&lt;img src="../../assets/img/content/chapter3/context/5.jpg" alt="context multi-level">
&lt;/a>&lt;/center>
&lt;h2 id="384-تابع-contextwithvalue">
3.8.4 تابع context.WithValue
&lt;a class="anchor" href="#384-%d8%aa%d8%a7%d8%a8%d8%b9-contextwithvalue">#&lt;/a>
&lt;/h2>
&lt;p>همانطور که گفتیم شما با استفاده از تابع WithValue می توانید مقادیری را بصورت key/value به context اضافه کنید و سپس این مقادیر را با استفاده از context به لایه های مختلف منتقل کنید.&lt;/p>
&lt;pre>&lt;code class="language-go">withValue(parent Context, key, val interface{}) (ctx Context)
&lt;/code>&lt;/pre>
&lt;blockquote class="book-hint info">
دقت کنید شما می توانید بواسطه context.WithValue &lt;a href="https://go.dev/blog/context#:~:text=The%20set%20of%20goroutines%20working%20on%20a%20request%20typically%20needs%20access%20to%20request%2Dspecific%20values%20such%20as%20the%20identity%20of%20the%20end%20user%2C%20authorization%20tokens%2C%20and%20the%20request%E2%80%99s%20deadline">مقادیر خیلی مهم و حساس نظیر توکن ها و &amp;hellip;&lt;/a> را به لایه های مختلف خود منتقل کنید و این مورد خیلی قابل اهمیت است با استفاده از context انجام دهید.
&lt;/blockquote>
&lt;pre>&lt;code class="language-go">// Root Context
ctxRoot := context.Background()
// Below ctxChild has acess to only one pair {&amp;quot;a&amp;quot;:&amp;quot;x&amp;quot;}
ctxChild := context.WithValue(ctxRoot, &amp;quot;a&amp;quot;, &amp;quot;x&amp;quot;)
// Below ctxChildofChild has access to both pairs {&amp;quot;a&amp;quot;:&amp;quot;x&amp;quot;, &amp;quot;b&amp;quot;:&amp;quot;y&amp;quot;} as it is derived from ctxChild
ctxChildofChild := context.WithValue(ctxChild, &amp;quot;b&amp;quot;, &amp;quot;y&amp;quot;)
&lt;/code>&lt;/pre>
&lt;p>در بالا ما یک ctxRoot ایجاد کردیم و سپس یک فرزند با استفاده از تابع WithValue ایجاد کردیم که یک مقدار از نوع key/value با نام a را داخل context فرزند قرار دادیم. حالا برای context فرزند مجدد با استفاده از WithValue یک فرزند دیگری ایجاد کردیم که یک مقدار دیگر از نوع key/value با نام b قرار دادیم حالا اگر دقت کنید ctxChildofChild دارای ۲ مقدار a و b هستش.&lt;/p>
&lt;p>بزارید یک مثال ساده بزنیم :&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;context&amp;quot;
&amp;quot;fmt&amp;quot;
)
func main() {
ctx := context.WithValue(context.Background(), &amp;quot;language&amp;quot;, &amp;quot;Go&amp;quot;)
fmt.Println(manager(ctx, &amp;quot;language&amp;quot;))
}
func manager(ctx context.Context, key string) string {
if v := ctx.Value(key); v != nil {
return v.(string)
}
return &amp;quot;not found value&amp;quot;
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-shell">$ go run main.go
Go
&lt;/code>&lt;/pre>
&lt;p>در کد فوق ما یک context ایجاد کردیم و داخلش با استفاده از WithValue مقدار key/value قرار دادیم و سپس این context را تابع manager پاس دادیم و داخل تابع manager ما با استفاده از متد Value که داخل اینترفیس ctx هست مقدار کلید language را گرفتیم.&lt;/p>
&lt;blockquote class="book-hint info">
نکته کاربردی و مهم همیشه سعی کنید context را به عنوان اولین پارامتر برای توابع تعریف کنید. و بهتر است برای نام پارامتر ctx یا c بزارید.
&lt;/blockquote>
&lt;h2 id="385-تابع-contextwithcancel">
3.8.5 تابع context.WithCancel
&lt;a class="anchor" href="#385-%d8%aa%d8%a7%d8%a8%d8%b9-contextwithcancel">#&lt;/a>
&lt;/h2>
&lt;p>زمانیکه شما با استفاده از تابع WithCancel یک context فرزند ایجاد می کنید ۲ تا خروجی به شما می دهد اولی context و دومی تابع cancel می باشد. که شما می توانید تابع cancel را برای لغو درخواستی که از سمت کلاینت یا لایه های بالاتر اومده را انجام دهید.&lt;/p>
&lt;pre>&lt;code class="language-go">type CancelFunc func()
func WithCancel(parent Context) (ctx Context, cancel CancelFunc)
&lt;/code>&lt;/pre>
&lt;p>حالا با استفاده از مثال زیر میتوانید بحث لغو کردن را بهتر درک کنید :&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;context&amp;quot;
&amp;quot;fmt&amp;quot;
&amp;quot;time&amp;quot;
)
func main() {
ctx := context.Background()
cancelCtx, cancelFunc := context.WithCancel(ctx)
go task(cancelCtx)
time.Sleep(time.Second * 3)
cancelFunc()
time.Sleep(time.Second * 1)
}
func task(ctx context.Context) {
i := 1
for {
select {
case &amp;lt;-ctx.Done():
fmt.Println(&amp;quot;Gracefully exit&amp;quot;)
fmt.Println(ctx.Err())
return
default:
fmt.Println(i)
time.Sleep(time.Second * 1)
i++
}
}
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-shell">$ go run main.go
1
2
3
Gracefully exit
context canceled
&lt;/code>&lt;/pre>
&lt;p>در کد فوق ما یک context فرزند با استفاده از WithCancel ایجاد کردیم که به عنوان خروجی cancelCtx و cancelFunc را داد. سپس cancelCtx را به تابع task منتقل کردیم تا عملیاتی را انجام دهد. حال در ادامه کد تابع main ما یک Sleep در حد ۳ ثانیه گذاشتیم و گفتیم تابع cancelFunc اجرا شود. اگر دقت کنید پس ۳ ثانیه سیگنال لغو به تابع task ارسال شده و خطای Gracefully exit را چاپ کردیم و پس از آن خطای context چاپ کردیم.&lt;/p>
&lt;blockquote class="book-hint info">
&lt;p>نکته کاربردی و مهم همیشه سعی کنید تابع cancelFunc را پس از اینکه context فرزند را با WithCancel ایجاد کردید داخل defer قرار دهید.&lt;/p>
&lt;pre>&lt;code class="language-go">ctx := context.Background()
cancelCtx, cancelFunc := context.WithCancel(ctx)
defer cancelFunc()
&lt;/code>&lt;/pre>
&lt;/blockquote>
&lt;h2 id="386-تابع-contextwithtimeout">
3.8.6 تابع context.WithTimeout
&lt;a class="anchor" href="#386-%d8%aa%d8%a7%d8%a8%d8%b9-contextwithtimeout">#&lt;/a>
&lt;/h2>
&lt;p>تابع WithTimeout یکی از کاربردی ترین context ها را برای ما ایجاد میکند و باعث می شود جلوی طول کشیدن یک درخواست خارجی یا عملیاتی را بگیرد و درخواست را لغو کند. این تابع همانند تابع WithCancel به شما تابع cancelFunc را می دهد و در عوض از شما یک مدت زمان را میگیرد.&lt;/p>
&lt;pre>&lt;code class="language-go">func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)
&lt;/code>&lt;/pre>
&lt;p>بزارید یک مثال ساده بزنیم :&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;context&amp;quot;
&amp;quot;fmt&amp;quot;
&amp;quot;time&amp;quot;
)
func main() {
ctx := context.Background()
cancelCtx, cancel := context.WithTimeout(ctx, time.Second*3)
defer cancel()
go task1(cancelCtx)
time.Sleep(time.Second * 4)
}
func task1(ctx context.Context) {
i := 1
for {
select {
case &amp;lt;-ctx.Done():
fmt.Println(&amp;quot;Gracefully exit&amp;quot;)
fmt.Println(ctx.Err())
return
default:
fmt.Println(i)
time.Sleep(time.Second * 1)
i++
}
}
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-shell">$ go run main.go
1
2
3
Gracefully exit
context deadline exceeded
&lt;/code>&lt;/pre>
&lt;p>در کد فوق ما یک context فرزند با استفاده از تابع WithTimeout ایجاد کردیم و مدت زمان ۳ ثانیه به این تابع پاس دادیم و پس از آن context فرزند به همراه تابع cancelFunc دریافت کردیم. حالا تابع cancel را داخل defer قرار دادیم و cancelCtx را به تابع task1 که داخل گوروتین است پاس داده ایم سپس و یک Sleep به مدت ۴ ثانیه گذاشتیم تا، تابع main کارش تمام نشود. حال پس از اینکه ۳ ثانیه گذشت داخل select سیگنال cancel را دریافت کردیم و خطای context deadline exceeded که نشان دهنده اتمام شدن مدت زمان هست را چاپ کرده ایم. همانطور که متوجه شدید درخواست کلی ما لغو شده.&lt;/p>
&lt;h2 id="387-تابع-contextwithdeadline">
3.8.7 تابع context.WithDeadline
&lt;a class="anchor" href="#387-%d8%aa%d8%a7%d8%a8%d8%b9-contextwithdeadline">#&lt;/a>
&lt;/h2>
&lt;p>تابع WithDeadline تا حدی شبیه به WithTimeout است اما با این تفاوت که پارامتر زمانی که میگیرد از نوع time.Time است و مدت زمانی که میگیرد براساس تایم هست مثلا شما میگید ۵ ثانیه بعد از زمان الان درخواست را لغو کند در صورتیکه withTimeout مدت زمان میگیرد که درخواست ۵ ثانیه مهلت دارد کارش را انجام دهد.&lt;/p>
&lt;pre>&lt;code class="language-go">func WithDeadline(parent Context, d time.Time) (Context, CancelFunc)
&lt;/code>&lt;/pre>
&lt;p>به مثال زیر توجه کنید :&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;context&amp;quot;
&amp;quot;fmt&amp;quot;
&amp;quot;time&amp;quot;
)
func main() {
ctx := context.Background()
cancelCtx, cancel := context.WithDeadline(ctx, time.Now().Add(time.Second*5))
defer cancel()
go task(cancelCtx)
time.Sleep(time.Second * 6)
}
func task(ctx context.Context) {
i := 1
for {
select {
case &amp;lt;-ctx.Done():
fmt.Println(&amp;quot;Gracefully exit&amp;quot;)
fmt.Println(ctx.Err())
return
default:
fmt.Println(i)
time.Sleep(time.Second * 1)
i++
}
}
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-shell">$ go run main.go
1
2
3
4
5
Gracefully exit
context deadline exceeded
&lt;/code>&lt;/pre>
&lt;p>در کد فوق یک context فرزند با استفاده از تابع WithDeadline ایجاد کردیم و سپس با توجه به زمان فعلی مدت زمان ۵ ثانیه بعد را درنظر گرفتیم که مثلا اگر الان ساعت است 10:45:30 درخواست را در 10:45:35 لغو کند.&lt;/p>
&lt;h2 id="388-نکات-کاربردی">
3.8.8 نکات کاربردی
&lt;a class="anchor" href="#388-%d9%86%da%a9%d8%a7%d8%aa-%da%a9%d8%a7%d8%b1%d8%a8%d8%b1%d8%af%db%8c">#&lt;/a>
&lt;/h2>
&lt;ol>
&lt;li>هیچوقت سعی نکنید اینترفیس context را داخل یک ساختار ذخیره کنید اما می توانید embed کنید.&lt;/li>
&lt;li>همیشه context باید بین لایه‌های خود منتقل کنید تا بتوانید کنترل بهتری برروی درخواست ها داشته باشید.&lt;/li>
&lt;li>همیشه سعی کنید context را به عنوان اولین پارامتر توابع قرار دهید.&lt;/li>
&lt;li>نام context به عنوان پارامتر توابع بهتر است ctx یا c باشد.&lt;/li>
&lt;li>اگر هنوز مطمئن نیستید که با context چکاری میخواهید انجام دهید بهتر است context را با context.ToDo ایجاد کنید.&lt;/li>
&lt;li>توجه کنید فقط تابعی که context والد را ایجاد کرده می تواند درخواست را لغو کند پس سعی نکنید تابع cancelFunc را به توابع زیرین پاس دهید.&lt;/li>
&lt;/ol></description></item><item><author/><title>3.9 تکنیک های همزمانی</title><link>https://book.gofarsi.ir/chapter-3/go-concurrency-teqniques/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-3/go-concurrency-teqniques/</guid><description>&lt;h2 id="391-ارسال-سیگنال-انجام-شدن-با-کانال-ساختار">
3.9.1 ارسال سیگنال انجام شدن با کانال ساختار
&lt;a class="anchor" href="#391-%d8%a7%d8%b1%d8%b3%d8%a7%d9%84-%d8%b3%db%8c%da%af%d9%86%d8%a7%d9%84-%d8%a7%d9%86%d8%ac%d8%a7%d9%85-%d8%b4%d8%af%d9%86-%d8%a8%d8%a7-%da%a9%d8%a7%d9%86%d8%a7%d9%84-%d8%b3%d8%a7%d8%ae%d8%aa%d8%a7%d8%b1">#&lt;/a>
&lt;/h2>
&lt;p>شما می توانید با استفاده از کانال struct سیگنالی برای تکمیل شدن انجام یک کار را بفرستید.&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;fmt&amp;quot;
&amp;quot;time&amp;quot;
)
func task1(done chan struct{}) {
// Do some work here
fmt.Println(&amp;quot;doing task 1&amp;quot;)
time.Sleep(2 * time.Second)
fmt.Println(&amp;quot;task 1 has been completed&amp;quot;)
done &amp;lt;- struct{}{}
}
func task2(done &amp;lt;-chan struct{}) {
select {
case &amp;lt;-done:
// Do some work here
fmt.Println(&amp;quot;doing task 2&amp;quot;)
time.Sleep(2 * time.Second)
fmt.Println(&amp;quot;task 2 has been completed&amp;quot;)
}
}
func main() {
done := make(chan struct{})
go task1(done)
go task2(done)
time.Sleep(5 * time.Second)
fmt.Println(&amp;quot;all tasks has been completed&amp;quot;)
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-shell">$ go run main.go
doing task 1
task 1 has been completed
doing task 2
task 2 has been completed
all tasks has been completed
&lt;/code>&lt;/pre>
&lt;p>در کد فوق ما دو تابع به نام task1 و task2 داریم که داخل گوروتین هستند و به عنوان پارامتر ورودی یک کانال ساختار خالی میگیرد حال کانال ساختار را به هر دو تابع پاس دادیم در ابتدا task1 فرآیند خود را انجام می دهد و سپس سیگنال انجام شدن را می فرستد و در ادامه تابع task2 سیگنال را دریافت می کند و فرآیندهای خود را انجام می دهد.&lt;/p>
&lt;blockquote class="book-hint info">
در زبان گو شما وقتی یک struct کاملا خالی و بدون فیلد میسازید هیچ تخصیص حافظه‌ای برایش صورت نمیگیرد.
&lt;/blockquote>
&lt;h2 id="392-بررسی-یک-سرویس-یا-فرآیند-با-heartbeat">
3.9.2 بررسی یک سرویس یا فرآیند با heartbeat
&lt;a class="anchor" href="#392-%d8%a8%d8%b1%d8%b1%d8%b3%db%8c-%db%8c%da%a9-%d8%b3%d8%b1%d9%88%db%8c%d8%b3-%db%8c%d8%a7-%d9%81%d8%b1%d8%a2%db%8c%d9%86%d8%af-%d8%a8%d8%a7-heartbeat">#&lt;/a>
&lt;/h2>
&lt;p>شما با استفاده از همزمانی می توانید یک heartbeat پیاده سازی کنید تا یک سرویس یا فرآیند را بطور مداوم طی بازه زمانی مشخصی زیر نظر داشته باشد و از وضعیت آن سرویس یا فرآیند به شما اطلاع دهد.&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;fmt&amp;quot;
&amp;quot;time&amp;quot;
)
func heartbeat(interval time.Duration, c chan&amp;lt;- struct{}) {
ticker := time.NewTicker(interval)
for {
select {
case &amp;lt;-ticker.C:
c &amp;lt;- struct{}{}
}
}
}
func task() {
// Do some work here
fmt.Println(&amp;quot;Task running...&amp;quot;)
}
func main() {
c := make(chan struct{})
go heartbeat(1*time.Second, c)
for {
select {
case &amp;lt;-c:
task()
}
}
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-shell">$ go run main.go
Task running...
Task running...
Task running...
Task running...
&lt;/code>&lt;/pre>
&lt;p>در کد فوق ما یک تابع به نام heartbeat ایجاد کردیم که طی مدت زمانی یک سیگنال می فرستد تا تابع task اجرا شود که وضعیت فرآیند یا سرویس را گزارش دهد. ما مدت زمان را ۱ ثانیه گذاشتیم و یک کانال ساختار ایجاد کردیم و به تابع heartbeat که داخل یک گوروتین هست پاس دادیم سپس هر ۱ ثانیه از طریق کانال c ما سیگنال اجرای task برای بررسی وضعیت سرویس یا فرآیند را دریافت میکنیم.&lt;/p>
&lt;h2 id="393-ارسال-درخواستهای-تکراری-به-سرور-یا-سرویسی">
3.9.3 ارسال درخواست‌های تکراری به سرور یا سرویسی
&lt;a class="anchor" href="#393-%d8%a7%d8%b1%d8%b3%d8%a7%d9%84-%d8%af%d8%b1%d8%ae%d9%88%d8%a7%d8%b3%d8%aa%d9%87%d8%a7%db%8c-%d8%aa%da%a9%d8%b1%d8%a7%d8%b1%db%8c-%d8%a8%d9%87-%d8%b3%d8%b1%d9%88%d8%b1-%db%8c%d8%a7-%d8%b3%d8%b1%d9%88%db%8c%d8%b3%db%8c">#&lt;/a>
&lt;/h2>
&lt;p>فرض کنید شما نیاز دارید به یک سرور یا سرویسی چندین درخواست تکراری را بصورت موازی بفرستید که به اینکار replicated requests می گویند.&lt;/p>
&lt;p>به مثال زیر توجه کنید :&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;fmt&amp;quot;
&amp;quot;net/http&amp;quot;
)
func makeRequest(url string, c chan&amp;lt;- *http.Response) {
resp, err := http.Get(url)
if err != nil {
c &amp;lt;- nil
} else {
c &amp;lt;- resp
}
}
func main() {
urls := []string{&amp;quot;http://example.com&amp;quot;, &amp;quot;http://example.org&amp;quot;, &amp;quot;http://example.net&amp;quot;}
c := make(chan *http.Response)
defer close(c)
for _, url := range urls {
go makeRequest(url, c)
}
for i := 0; i &amp;lt; len(urls); i++ {
resp := &amp;lt;-c
if resp == nil {
fmt.Println(&amp;quot;Error making request&amp;quot;)
} else {
fmt.Println(resp.Status)
}
}
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-shell">$ go run main.go
200 OK
200 OK
200 OK
&lt;/code>&lt;/pre>
&lt;p>در کد فوق ما یک تابع makeRequest داریم که ۲ تا پارامتر ورودی دارد اولین پارامتر url میگیرد و دومین پارامتر یک کانال فقط ارسال از نوع http.Response* میگیرد. سپس یک ریکوئست با متد GET ایجاد میکند و خروجی را داخل کانال میفرستد. در تابع main ما یک لیست url داریم که قرار است بصورت موازی به این آدرس ها درخواست بفرستیم و خروجی را دریافت کنیم در اینجا یک کانال از نوع http.Response* ایجاد کردیم و سپس یک حلقه for-range قرار دادیم و به ازای هر یک از url ها تابع makeRequest را فراخوانی کرده‌ایم و سپس داخل گوروتین قرار داده‌ایم، در نهایت یک حلقه for-i داریم که به تعداد url ها شمارش میکند و از طریق کانال ریسپانس را دریافت می کند.&lt;/p>
&lt;h2 id="394-بازیابی-سلامتی-یک-گوروتین">
3.9.4 بازیابی سلامتی یک گوروتین
&lt;a class="anchor" href="#394-%d8%a8%d8%a7%d8%b2%db%8c%d8%a7%d8%a8%db%8c-%d8%b3%d9%84%d8%a7%d9%85%d8%aa%db%8c-%db%8c%da%a9-%da%af%d9%88%d8%b1%d9%88%d8%aa%db%8c%d9%86">#&lt;/a>
&lt;/h2>
&lt;p>در برنامه نویسی همزمانی خیلی مهم است شما به سلامتی یک گوروتین رسیدگی کنید که اگر گوروتین قادر به انجام کاری نیست مجدد بتوانید سلامتی گوروتین را بازیابی کنید. در زبان گو شما می توانید با استفاده از پکیج context گوروتین هایی که وضعیت سالمی ندارد را با راه اندازی مجدد سلامتی آنها را بازیابی کنید.&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;context&amp;quot;
&amp;quot;fmt&amp;quot;
&amp;quot;time&amp;quot;
)
func unhealthyGoroutine(ctx context.Context) {
for {
select {
case &amp;lt;-ctx.Done():
fmt.Println(&amp;quot;Goroutine is unhealthy, exiting&amp;quot;)
return
default:
// Do some work here
fmt.Println(&amp;quot;Goroutine running...&amp;quot;)
time.Sleep(500 * time.Millisecond)
}
}
}
func main() {
ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
defer cancel()
for {
go unhealthyGoroutine(ctx)
&amp;lt;-time.After(4 * time.Second)
}
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-shell">$ go run main.go
Goroutine running...
Goroutine running...
Goroutine running...
Goroutine running...
Goroutine running...
Goroutine running...
Goroutine is unhealthy, exiting
Goroutine is unhealthy, exiting
Goroutine is unhealthy, exiting
Goroutine is unhealthy, exiting
Goroutine is unhealthy, exiting
Goroutine is unhealthy, exiting
&lt;/code>&lt;/pre>
&lt;p>در کد فوق ما یک تابع به نام unhealthyGoroutine داریم که بصورت جداگانه در گوروتین های مختلف اجرا می شود و کاری را انجام می دهد. داخل تابع ما یک select داریم که در یکی از case هایش context.Done را بررسی میکنیم آیا فرآیند لغو شده است یا خیر. داخل تابع main ما یک context از نوع Timeout با مدت زمان ۳ ثانیه‌ای ایجاد کردیم و در ادامه داخل یک حلقه بینهایت تابع unhealthyGoroutine داخل گوروتین قرار دادیم و هر ۴ ثانیه یک نمونه از این تابع داخل گوروتین های مختلف اجرا می شود.&lt;/p>
&lt;p>در اینجا کارهای داخل تابع unhealthyGoroutine انجام شود پس از ۳ ثانیه بواسطه context فرآیندها لغو می شود و از گوروتین خارج می شود. حال ما داخل تابع main اجازه دادیم یک گوروتین جدید و سالم را اجرا کند و جایگزین گوروتین ناسالم شود.&lt;/p>
&lt;h2 id="395-پیاده-سازی-الگوریتم-فیبوناچی-با-همزمانی">
3.9.5 پیاده سازی الگوریتم فیبوناچی با همزمانی
&lt;a class="anchor" href="#395-%d9%be%db%8c%d8%a7%d8%af%d9%87-%d8%b3%d8%a7%d8%b2%db%8c-%d8%a7%d9%84%da%af%d9%88%d8%b1%db%8c%d8%aa%d9%85-%d9%81%db%8c%d8%a8%d9%88%d9%86%d8%a7%da%86%db%8c-%d8%a8%d8%a7-%d9%87%d9%85%d8%b2%d9%85%d8%a7%d9%86%db%8c">#&lt;/a>
&lt;/h2>
&lt;p>دنباله فیبوناچی مجموعه‌ای از اعداد است که در آن هر عدد حاصل جمع دو عدد قبلی است که معمولا با 0 و 1 شروع می شود. ، 55، 89، 144 و غیره. دنباله فیبوناچی به نام ریاضیدان ایتالیایی، لئوناردو پیزا، که به فیبوناچی نیز معروف بود، نامگذاری شده است.
الگوریتم فیبوناچی روشی برای محاسبه عدد n در دنباله فیبوناچی است. روش‌های مختلفی برای پیاده‌سازی الگوریتم فیبوناچی وجود دارد، اما رایج‌ترین روش استفاده از بازگشت است.&lt;/p>
&lt;p>در علوم و مهندسی کامپیوتر، از دنباله فیبوناچی برای تحلیل عملکرد الگوریتم هایی مانند برج هانوی و تکنیک جستجوی فیبوناچی استفاده می شود.&lt;/p>
&lt;p>در زیر ما برای اینکه بتوانید در سریعترین حالت ممکن محاسبات را انجام دهیم خیلی ساده می توانیم از همزمانی و کانال استفاده کنیم و در کسری از ثانیه محاسبه کنیم.&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import (
&amp;quot;fmt&amp;quot;
)
func fibo(n int) &amp;lt;-chan int {
result := make(chan int)
go func() {
defer close(result)
if n &amp;lt;= 2 {
result &amp;lt;- 1
return
}
result &amp;lt;- &amp;lt;-fibo(n-1) + &amp;lt;-fibo(n-2)
}()
return result
}
func main() {
fmt.Println(&amp;lt;-fibo(25))
}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-shell">$ go run main.go
75025
&lt;/code>&lt;/pre></description></item><item><author/><title>3.10 الگو های همزمانی</title><link>https://book.gofarsi.ir/chapter-3/go-concurrency-patterns/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.gofarsi.ir/chapter-3/go-concurrency-patterns/</guid><description>&lt;p>الگو های همزمانی را در فصل ۹ در کنار سایر الگوهای طراحی قرار دادیم یک مرجع کامل از الگوهای طراحی برای زبان گو داشته باشیم. در این بخش فقط ما خلاصه توضیحی در خصوص الگوها قرار دادیم و شما را ارجاع می دهیم به صفحه الگو :&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>عنوان&lt;/th>
&lt;th>توضیحات&lt;/th>
&lt;th>وضعیت&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;a href="../../chapter-9/concurrency-patterns/go-concurrency-pattern-wait-for-result">Wait For Result&lt;/a>&lt;/td>
&lt;td>با استفاده از الگو Wait For Result می توانید یک عملیاتی را بصورت همزمانی انجام دهید و سپس منتظر نتیجه عملیات صورت گرفته بمانید. برای اینکار از کانال استفاده می شود.&lt;/td>
&lt;td>✅&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="../../chapter-9/concurrency-patterns/go-concurrency-pattern-fan-out-in">Fan Out/In&lt;/a>&lt;/td>
&lt;td>الگو Fan Out/In یک تکنیک همزمانی در زبان گو می باشد که به شما اجازه می دهد چندین کار را با گوروتین همزمان انجام دهید و در نتیجه خروجی این کارها را با هم ترکیب کنید و به عنوان نتیجه نهایی دریافت کنید.&lt;/td>
&lt;td>✅&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="../../chapter-9/concurrency-patterns/go-concurrency-pattern-wait-for-task">Wait For Task&lt;/a>&lt;/td>
&lt;td>الگو wait for task یکی از الگوهای رایج در زبان گو می باشد و انتظار برای تکمیل یک تسک یا فرآیند استفاده می شود. یک تسک با استفاده از گوروتین اجرا می شود و پس اتمامش کار تسک از طریق کانال سیگنال انجام می فرستد.&lt;/td>
&lt;td>✅&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="../../chapter-9/concurrency-patterns/go-concurrency-pattern-drop">Drop&lt;/a>&lt;/td>
&lt;td>الگو Drop یک الگو مهم برای انجام خدمات سنگین می باشد. خدماتی که مواقعی باعث می شود حجم درخواست هایش بیش از ظرفیت موجود باشد و این درخواست ها بواسطه این الگو می تواند Drop شود. به عنوان مثال سرویس های DNS باید از این الگو استفاده کنند.&lt;/td>
&lt;td>✅&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="../../chapter-9/concurrency-patterns/go-concurrency-pattern-cancellation">Context Cancellation Pattern&lt;/a>&lt;/td>
&lt;td>الگو cancellation که حرکت تکنیکی هست برای ارسال سینگال به گوروتین ها استفاده می شود که باید اجرای کاری را متوقف کند و ایده اصلی این کار با استفاده بستن کانال صورت میگیرد.&lt;/td>
&lt;td>✅&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="../../chapter-9/concurrency-patterns/go-concurrency-pattern-semaphore">Semaphore&lt;/a>&lt;/td>
&lt;td>الگو Semaphore برای مدیریت کنترل دسترسی به منابع مشترک در همزمانی استفاده می شود. فرض کنید بصورت موازی ۱۰۰ درخواست HTTP سمت سرور میاد و I/O شبکه برای پردازش همزمان این ۱۰۰ درخواست درگیر میشود و به مرور عملکرد کاهش می یابد. حال اگر ما بیایم این ۱۰۰ درخواست موازی را تقسیم کنیم به ۵ دسته ۲۰ تایی که بصورت همزمانی انجام شود باعث می شود I/O شبکه کاهش یابد و عملکرد بهتری را خواهیم داشت.&lt;/td>
&lt;td>✅&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="../../chapter-9/concurrency-patterns/go-concurrency-pattern-worker-pool">Worker Pool&lt;/a>&lt;/td>
&lt;td>با استفاده از الگو Bounded Work Pooling امکان محدود سازی تعداد گوروتین ها را براساس کار مشخصی دارید و گوروتین ها را محدود به تعداد دفعات کار مشخص شده محدود می شود. این الگو برای وقت مفید است که شما می خواهید منابع را به یک کار خاص محدود کنید.&lt;/td>
&lt;td>✅&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="../../chapter-9/concurrency-patterns/go-concurrency-pattern-retry-timeout">Retry Timeout&lt;/a>&lt;/td>
&lt;td>شما از الگو Retry Timeout برای تلاش مجدد یکسری عملیات استفاده کنید. برای اینکار شما می توانید از حلقه و تابع After در پکیج time کمک بگیرید و برای هرتلاش یک timeout مشخص کنید.&lt;/td>
&lt;td>✅&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="../../chapter-9/concurrency-patterns/go-concurrency-pattern-channel-cancellation">Channel Cancellation&lt;/a>&lt;/td>
&lt;td>از کانال ها برای ارتباط بین گوروتین ها و هماهنگ کردن اجرا استفاده می شود. حال گاهی اوقات نیاز است که ما یکسری فرآیند را داخل گوروتین لغو کنیم. در اینجا می توانیم با استفاده از کانال سیگنال لغو کردن بفرستید تا عملیات هایی که گوروتین مورد نظر انجام می داد لغو شود.&lt;/td>
&lt;td>✅&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="../../chapter-9/concurrency-patterns/go-concurrency-pattern-producer-consumer">Producer-Consumer&lt;/a>&lt;/td>
&lt;td>الگو producer-consumer یکی از کاربردی ترین الگوها در زبان گو می باشد که با استفاده از الگو می توانید بطور همزمان یکسری اطلاعات تولید کنید و بفرستید داخل کانال و این اطلاعات توسط مصرف کننده بواسطه کانال دریافت شود.&lt;/td>
&lt;td>✅&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="../../chapter-9/concurrency-patterns/go-concurrency-pattern-monitor">Monitor&lt;/a>&lt;/td>
&lt;td>الگوی مانیتور به گروتین‌ ها اجازه می‌دهد هنگام ورود به حالت خواب بدون مسدود کردن اجرا یا مصرف منابع، منتظر شرایط خاصی باشند.&lt;/td>
&lt;td>✅&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="../../chapter-9/concurrency-patterns/go-concurrency-pattern-future">Future&lt;/a>&lt;/td>
&lt;td>در زبان گو الگو Future راهی برای نمایش نتیجه یک عملیات ناهمزمان (asynchronous) است که ممکن است آن عملیات هنوز تکمیل نشده باشد اما این الگو به شما این امکان را می دهد کدی بنویسید که طوری رفتار کند که گویی نتیجه یک عملیات فورا در دسترس است. حتی اگر عملیات در پس زمینه در حال اجرا باشد.&lt;/td>
&lt;td>✅&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="../../chapter-9/concurrency-patterns/go-concurrency-pattern-pipeline">Pipeline&lt;/a>&lt;/td>
&lt;td>الگو خط لوله (Pipeline) یکی از پرکاربردی ترین الگوها در همزمانی می باشد شما با استفاده از این الگو می توانید تسک های بزرگ را به تسک های کوچکتر و مستقل تقسیم کنید که می توانند بطور همزمان کار کنند. هر stage داخل یک گوروتین انجام می شود و بواسطه کانال داده ها بین stage های مختلف منتقل می شود.&lt;/td>
&lt;td>✅&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="../../chapter-9/concurrency-patterns/go-concurrency-pattern-subscription">Subscription&lt;/a>&lt;/td>
&lt;td>الگو Subscription یکی از الگوهای کاربردی برای پیاده سازی consumer می باشد که به یک آدرسی مشترک شوید و در بازده زمانی مختلف درخواست دهید و یکسری اطلاعات دریافت کنید.&lt;/td>
&lt;td>✅&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="../../chapter-9/concurrency-patterns/go-concurrency-pattern-brdige-channel">Bridge Channel&lt;/a>&lt;/td>
&lt;td>با استفاده از الگو Bridge Channel می توانید بین ۲ کانال داده ای را منتقل کنید فرض کنید یک داده را به کانال input میفرستید و از دریافت داده آن را می توانید به کانال دیگری منتقل کنید و عملا شما یک پل برای انتقال داده ایجاد کردید.&lt;/td>
&lt;td>✅&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="../../chapter-9/concurrency-patterns/go-concurrency-pattern-queuing">Queuing&lt;/a>&lt;/td>
&lt;td>الگوی &amp;ldquo;صف&amp;rdquo; در زبان گو الگویی است که در آن از یک گوروتین برای بافر کردن و مدیریت ترتیب مقادیر ارسال شده و دریافت شده از یک کانال استفاده می شود.&lt;/td>
&lt;td>✅&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="../../chapter-9/concurrency-patterns/go-concurrency-pattern-ratelimit">Rate limit&lt;/a>&lt;/td>
&lt;td>الگوی &lt;strong>Rate Limiting&lt;/strong> برای کنترل تعداد درخواست‌ها یا وظایف همزمان در یک بازه زمانی مشخص استفاده می‌شود. این الگو با استفاده از یک &lt;code>time.Ticker&lt;/code> یا روش‌های مشابه، اجرای گوروتین‌ها یا پردازش داده‌ها را محدود می‌کند.&lt;/td>
&lt;td>✅&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="../../chapter-9/concurrency-patterns/go-concurrency-pattern-deadlock-recovery">Deadlock Recovery&lt;/a>&lt;/td>
&lt;td>الگوی &lt;strong>بازیابی از بن‌بست&lt;/strong> (Deadlock Recovery) برای شناسایی و بازیابی از وضعیت‌های بن‌بست استفاده می‌شود، جایی که چندین گوروتین به طور نامحدود منتظر منابعی هستند که توسط یکدیگر نگه داشته شده‌اند. بن‌بست می‌تواند به دلیل همگام‌سازی نادرست یا رقابت برای منابع در برنامه‌های همزمان رخ دهد.&lt;/td>
&lt;td>✅&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="../../chapter-9/concurrency-patterns/go-concurrency-pattern-lock-free-synchronization">Lock-free synchronization&lt;/a>&lt;/td>
&lt;td>&lt;strong>همگام‌سازی بدون قفل (lock-free synchronization)&lt;/strong> به مجموعه‌ای از تکنیک‌ها و الگوهای برنامه‌نویسی گفته می‌شود که به چندین thread یا goroutine اجازه می‌دهد به طور همزمان و ایمن به داده‌های مشترک دسترسی پیدا کنند، بدون اینکه از primitiveهایی مثل Mutex یا قفل‌های سنتی استفاده شود. هدف اصلی این الگوها افزایش &lt;strong>بازدهی (throughput)&lt;/strong>، کاهش &lt;strong>زمان انتظار (latency)&lt;/strong> و جلوگیری از مشکلات رایج قفل‌گذاری (مثل deadlock، priority inversion و contention) است. الگوریتم‌های lock-free تضمین می‌کنند که حتی اگر برخی از threadها متوقف شوند یا دچار کندی شوند، باقی سیستم همچنان قادر به پیشرفت خواهد بود (&lt;strong>progress guarantee&lt;/strong>).&lt;/td>
&lt;td>✅&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item></channel></rss>