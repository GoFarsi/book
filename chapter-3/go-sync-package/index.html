<!doctype html><html lang=fa dir=rtl><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="پکیج sync توی گو مثل یک جعبه‌ابزار تخصصی برای همگام‌سازی (synchronize) و مدیریت دسترسی چندتا goroutine به داده یا منبع مشترکه.
وقتی چند goroutine همزمان به یک داده دسترسی پیدا می‌کنن، بدون هماهنگی ممکنه داده خراب بشه یا رفتار برنامه غیرقابل پیش‌بینی بشه (Data Race).
sync دقیقا برای جلوگیری از این اتفاق ساخته شده و ابزارهایی رو ارائه می‌ده که اجازه می‌ده دسترسی همزمان رو کنترل کنید.
ابزارهای اصلی sync:"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://book.gofarsi.ir/chapter-3/go-sync-package/"><meta property="og:site_name" content="زبان گو فارسی"><meta property="og:title" content="3.3 پکیج sync"><meta property="og:description" content="پکیج sync توی گو مثل یک جعبه‌ابزار تخصصی برای همگام‌سازی (synchronize) و مدیریت دسترسی چندتا goroutine به داده یا منبع مشترکه.
وقتی چند goroutine همزمان به یک داده دسترسی پیدا می‌کنن، بدون هماهنگی ممکنه داده خراب بشه یا رفتار برنامه غیرقابل پیش‌بینی بشه (Data Race).
sync دقیقا برای جلوگیری از این اتفاق ساخته شده و ابزارهایی رو ارائه می‌ده که اجازه می‌ده دسترسی همزمان رو کنترل کنید.
ابزارهای اصلی sync:"><meta property="og:locale" content="fa"><meta property="og:type" content="article"><meta property="article:section" content="chapter-3"><title>3.3 پکیج sync | زبان گو فارسی</title><link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://book.gofarsi.ir/chapter-3/go-sync-package/><link rel=stylesheet href=/book.min.cd8f8bc9e4ca964b4dc52c33addd5868719653b7f329734859463db32feac679.css integrity="sha256-zY+LyeTKlktNxSwzrd1YaHGWU7fzKXNIWUY9sy/qxnk=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/fa.search.min.7570f7b76a175cf1e686fee9cbe62b2ec763cb323fdd32390a6d9602d4af738a.js integrity="sha256-dXD3t2oXXPHmhv7py+YrLsdjyzI/3TI5Cm2WAtSvc4o=" crossorigin=anonymous></script><link rel=preconnect href=https://cdn.jsdelivr.net crossorigin><link rel=stylesheet href=prism.css><meta name=keywords content><link href=https://cdn.jsdelivr.net/gh/rastikerdar/vazir-font@v30.1.0/dist/font-face.css rel=stylesheet type=text/css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.0/css/all.min.css crossorigin=anonymous><link rel=alternate type=application/rss+xml href=https://book.gofarsi.ir//feed.xml title="زبان گو فارسی"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/prism-themes@1.9.0/themes/prism-one-dark.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/line-numbers/prism-line-numbers.min.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZE44Q8PZDW"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZE44Q8PZDW")</script><script>var html=document.documentElement;localStorage.getItem("themeMode")=="dark"&&html.setAttribute("data-theme","dark"),localStorage.getItem("themeMode")=="light"&&html.setAttribute("data-theme","light")</script></head><body dir=rtl><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><img src=/favicon.png alt=Logo class=book-icon><span>زبان گو فارسی</span></a></h2><div class=magic><div class=book-search><input type=text id=book-search-input placeholder=جستجو aria-label=جستجو maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><div class=js-toggle-wrapper><div class=js-toggle><div class=js-toggle-track><div class=js-toggle-track-check><img src="data:image/png;base64,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" role=presentation style=pointer-events:none width=23 height=23></div><div class=js-toggle-track-x><img src=data:image/png;base64,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 role=presentation style=pointer-events:none width=23 height=23></div></div><div class=js-toggle-thumb><img src=data:image/png;base64,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 role=presentation style=pointer-events:none width=46 height=46></div><input class=js-toggle-screenreader-only type=checkbox aria-label="تغییر تم بین روشن و تاریک"></div></div></div><ul><li><a href=/preface/>پیشگفتار</a></li><li><a href=/history/>تاریخچه</a></li><li><a href=/why-go/>چرا زبان Go؟</a></li><li><a href=/installation/>آموزش نصب</a></li><li><a href=/toolchain/>ابزارها, دستورات گو و معرفی IDE</a></li><li><a href=/roadmap/>نقشه یادگیری زبان گو</a></li><li><a href=/interview/>نمونه سوالات مصاحبه</a></li><li><input type=checkbox id=section-c0c35ea61c635f6152f0c00d6a15569e class=toggle>
<label for=section-c0c35ea61c635f6152f0c00d6a15569e class=flex><a href=/chapter-1/ class=flex-auto>فصل اول: آشنایی با مفاهیم گو</a></label><ul><li><a href=/chapter-1/structure-of-go-code/>1.1 ساختار کد گو</a></li><li><a href=/chapter-1/go-built-in-keywords-identifiers/>1.2 کلید واژه و شناسه‌ها</a></li><li><a href=/chapter-1/go-basic-types/>1.3 تایپ‌های پایه</a></li><li><a href=/chapter-1/go-operators/>1.4 عملگرها</a></li><li><a href=/chapter-1/go-variables-and-consts/>1.5 متغیرها و constant</a></li><li><a href=/chapter-1/go-zero-values/>1.6 مقادیر صفر تایپ‌ها (zero values)</a></li><li><a href=/chapter-1/go-function/>1.7 تابع (function)</a></li><li><a href=/chapter-1/go-array/>1.8 آرایه و slice</a></li><li><a href=/chapter-1/go-for/>1.9 حلقه‌ها (for)</a></li><li><a href=/chapter-1/go-map/>1.10 نقشه map</a></li><li><a href=/chapter-1/go-if-switch/>1.11 شرط (if, switch)</a></li><li><a href=/chapter-1/go-package/>1.12 اضافه کردن پکیج در کد (package)</a></li><li><a href=/chapter-1/go-defer-panic-recovery/>1.13 defer, panic, recovery</a></li><li><a href=/chapter-1/go-builtins/>1.14 لیست تایپ‌ها و توابع Builtin</a></li><li><a href=/chapter-1/go-string-formatting/>1.15 قالب بندی رشته‌ها</a></li></ul></li><li><input type=checkbox id=section-ce9b5b1ec927bacdb2712b9c215a3ca1 class=toggle>
<label for=section-ce9b5b1ec927bacdb2712b9c215a3ca1 class=flex><a href=/chapter-2/ class=flex-auto>فصل دوم: مکانیزم‌های زبان</a></label><ul><li><a href=/chapter-2/pointer/>2.1 اشاره‌گر (Pointer)</a></li><li><a href=/chapter-2/struct/>2.2 ساختار (struct)</a></li><li><a href=/chapter-2/method/>2.3 متد (Method)</a></li><li><a href=/chapter-2/interface/>2.4 اینترفیس (Interface)</a></li><li><a href=/chapter-2/type-embedding/>2.5 جاسازی تایپ (type embedding)</a></li><li><a href=/chapter-2/error-handling/>2.6 مدیریت خطاها</a></li><li><a href=/chapter-2/casting-vs-conversion/>2.7 فرق casting با conversion</a></li></ul></li><li><input type=checkbox id=section-0691270142e95f82c4d2eb637f234afd class=toggle checked>
<label for=section-0691270142e95f82c4d2eb637f234afd class=flex><a href=/chapter-3/ class=flex-auto>فصل سوم: همزمانی (concurrency)</a></label><ul><li><a href=/chapter-3/go-concurrency/>3.1 آشنایی با همزمانی</a></li><li><a href=/chapter-3/goroutine/>3.2 گوروتین (goroutine)</a></li><li><a href=/chapter-3/go-sync-package/ class=active>3.3 پکیج sync</a></li><li><a href=/chapter-3/go-atomic/>3.4 پکیج atomic</a></li><li><a href=/chapter-3/goroutine-data-race/>3.5 آموزش مقابله با data race</a></li><li><a href=/chapter-3/go-channel/>3.6 کانال (channel)</a></li><li><a href=/chapter-3/go-select/>3.7 آموزش استفاده از select</a></li><li><a href=/chapter-3/go-context/>3.8 پکیج context</a></li><li><a href=/chapter-3/go-concurrency-teqniques/>3.9 تکنیک های همزمانی</a></li><li><a href=/chapter-3/go-concurrency-patterns/>3.10 الگو های همزمانی</a></li></ul></li><li><input type=checkbox id=section-59efe912b32b5b1290d5ec2dac84f441 class=toggle>
<label for=section-59efe912b32b5b1290d5ec2dac84f441 class=flex><a href=/chapter-4/ class=flex-auto>فصل چهارم: مباحث پیشرفته</a></label><ul><li><a href=/chapter-4/build-go-file/>4.1 آموزش Build پروژه</a></li><li><a href=/chapter-4/debugging-go-code/>4.2 آموزش کار با Debugging</a></li><li><a href=/chapter-4/go-mod/>4.3 آموزش کار با go mod</a></li><li><a href=/chapter-4/workspace/>4.4 آموزش کار با workspace</a></li><li><a href=/chapter-4/vendor/>4.5 آموزش کار با Vendor</a></li><li><a href=/chapter-4/command-line-go/>4.6 آموزش نوشتن برنامه command line</a></li><li><a href=/chapter-4/work-with-file-in-go/>4.7 آموزش کار با فایل</a></li><li><a href=/chapter-4/work-with-json-file-in-go/>4.8 آموزش کار با json</a></li><li><a href=/chapter-4/work-with-toml-file-in-go/>4.9 آموزش کار با toml</a></li><li><a href=/chapter-4/work-with-yaml-file-in-go/>4.10 آموزش کار با yaml</a></li><li><a href=/chapter-4/work-with-csv-file-in-go/>4.11 آموزش کار با csv</a></li><li><a href=/chapter-4/work-with-ini-file-in-go/>4.12 آموزش کار با ini</a></li><li><a href=/chapter-4/work-with-environment-variable/>4.13 آموزش کار با environment variable</a></li><li><a href=/chapter-4/go-regular-expressions/>4.14 آموزش کار با regexp</a></li><li><a href=/chapter-4/go-reflection/>4.15 آموزش reflection</a></li><li><a href=/chapter-4/go-generator/>4.16 آموزش generator</a></li><li><a href=/chapter-4/go-stringer/>4.17 آموزش stringer</a></li><li><a href=/chapter-4/effective-go/>4.18 تکنیک های کدنویسی زبان گو</a></li><li><a href=/chapter-4/go-commentry/>4.19 اصول کامنت نویسی</a></li><li><a href=/chapter-4/go-code-rules/>4.20 قوانین کدنویسی در گو</a></li><li><a href=/chapter-4/go-garbage-collector/>4.21 زباله جمع کن (garbage collector)</a></li><li><a href=/chapter-4/go-plugin/>4.22 کتابخانه Plugin</a></li><li><input type=checkbox id=section-687c92e06ed3c05242e60a3a1a266aa4 class=toggle>
<label for=section-687c92e06ed3c05242e60a3a1a266aa4 class=flex><a href=/chapter-4/oop/ class=flex-auto>4.23 شی گرایی در زبان گو</a></label><ul><li><a href=/chapter-4/oop/go-encapsulation/>4.23.1 کپسوله سازی (Encapsulation)</a></li><li><a href=/chapter-4/oop/go-inheritance/>4.22.2 ارث بری</a></li><li><a href=/chapter-4/oop/go-polymorphism/>4.23.3 پلی مورفیسم (Polymorphism)</a></li><li><a href=/chapter-4/oop/go-overriding/>4.23.4 overriding</a></li><li><a href=/chapter-4/oop/go-abstraction/>4.23.5 abstraction</a></li></ul></li><li><a href=/chapter-4/tracing/>4.24 آموزش tracing</a></li><li><a href=/chapter-4/profiling/>4.25 آموزش profiling</a></li><li><a href=/chapter-4/go-project-layout/>4.26 ساختار پروژه</a></li><li><a href=/chapter-4/go-io-package/>4.27 آموزش کار با پکیج io</a></li></ul></li><li><input type=checkbox id=section-134502b5358f6cf5c83ad497f832087a class=toggle>
<label for=section-134502b5358f6cf5c83ad497f832087a class=flex><a href=/chapter-5/ class=flex-auto>فصل پنجم: برنامه نویسی شبکه با گو</a></label><ul><li><a href=/chapter-5/network-basic/>5.1 شبکه چیست</a></li><li><a href=/chapter-5/go-tcp-server-begginer/>5.2 سرور tcp مقدماتی</a></li><li><a href=/chapter-5/go-tcp-server-advanced/>5.3 سرور tcp پیشرفته</a></li><li><a href=/chapter-5/go-udp-server-begginer/>5.4 سرور udp مقدماتی</a></li><li><a href=/chapter-5/go-udp-server-advanced/>5.5 سرور udp پیشرفته</a></li><li><a href=/chapter-5/go-http-server-begginer/>5.6 کتابخانه http سمت سرور مقدماتی</a></li><li><a href=/chapter-5/go-http-server-advanced/>5.7 کتابخانه http سمت سرور پیشرفته</a></li><li><a href=/chapter-5/go-http-client-begginer/>5.8 کتابخانه http سمت کلاینت مقدماتی</a></li><li><a href=/chapter-5/go-http-client-advanced/>5.9 کتابخانه http سمت کلاینت پیشرفته</a></li><li><a href=/chapter-5/go-quic-prtoocol/>5.10 پروتکل quic</a></li></ul></li><li><input type=checkbox id=section-6f78676abc6f42fefd423ea7de4e1c4d class=toggle>
<label for=section-6f78676abc6f42fefd423ea7de4e1c4d class=flex><a href=/chapter-6/ class=flex-auto>فصل ششم: ژنریک ها (Generics)</a></label><ul><li><a href=/chapter-6/go-generics-basic/>6.1 مقدمه و اهمیت ژنریک‌ها</a></li><li><a href=/chapter-6/go-generics-fundamentals/>6.2 مبانی ژنریک‌ها در Go</a></li><li><a href=/chapter-6/go-generics-syntax-and-structure/>6.3 سینتکس و ساختار ژنریک‌ها در Go</a></li><li><a href=/chapter-6/go-generics-type-sets-and-constraints/>6.4 Constraints و Type Sets</a></li><li><a href=/chapter-6/go-generics-examples-and-practical/>6.5 مثال‌ها و کاربردهای عملی ژنریک‌ها</a></li><li><a href=/chapter-6/comparing-generics/>6.6 مقایسه ژنریک‌ها با راهکارهای قبل از Go 1.18</a></li><li><a href=/chapter-6/limitations-errors-and-anti-patterns-in-generics/>6.7 محدودیت‌ها، خطاها و ضدالگوها در ژنریک‌ها</a></li><li><a href=/chapter-6/generics-best-practice/>6.8 بهترین شیوه‌های استفاده از ژنریک‌ها (Best Practices)</a></li><li><a href=/chapter-6/generics-advanced-examples-and-tips/>6.9 مثال‌های پیشرفته و نکات ویژه</a></li></ul></li><li><input type=checkbox id=section-8f5df719cb6867058bc4273b800e1879 class=toggle>
<label for=section-8f5df719cb6867058bc4273b800e1879 class=flex><a href=/chapter-7/ class=flex-auto>فصل هفتم: تست نویسی</a></label><ul><li><a href=/chapter-7/go-introduction-testing/>7.1 مقدمه‌ای بر تست در Go</a></li><li><a href=/chapter-7/go-unit-testing/>7.2 تست واحد (Unit Test)</a></li><li><a href=/chapter-7/go-table-driven-tests/>7.3 تست جدول‌محور (Table-Driven Test)</a></li><li><a href=/chapter-7/go-integration-testing/>7.4 تست یکپارچه (Integration Test)</a></li></ul></li><li><input type=checkbox id=section-46582e13a18a41adc7936c360b185ec8 class=toggle>
<label for=section-46582e13a18a41adc7936c360b185ec8 class=flex><a href=/chapter-8/ class=flex-auto>فصل هشتم: پکیج های استاندارد</a></label><ul></ul></li><li><input type=checkbox id=section-7b4fd75e0c8dddcfaf05d2809955458b class=toggle>
<label for=section-7b4fd75e0c8dddcfaf05d2809955458b class=flex><a href=/chapter-9/ class=flex-auto>فصل نهم: الگوهای طراحی</a></label><ul><li><input type=checkbox id=section-91fecfeb90059a6577f742161c3cc416 class=toggle>
<label for=section-91fecfeb90059a6577f742161c3cc416 class=flex><a href=/chapter-9/creational-patterns/ class=flex-auto>9.1 الگوهای طراحی سازنده</a></label><ul><li><a href=/chapter-9/creational-patterns/go-singleton-pattern/>9.1.1 الگو Singleton</a></li><li><a href=/chapter-9/creational-patterns/go-factory-method-pattern/>9.1.2 الگو Factory Method</a></li><li><a href=/chapter-9/creational-patterns/go-prototype-pattern/>9.1.3 الگو Prototype</a></li><li><a href=/chapter-9/creational-patterns/go-abstract-factory-pattern/>9.1.4 الگو Abstract Factory</a></li><li><a href=/chapter-9/creational-patterns/go-builder-pattern/>9.1.6 الگو Builder</a></li><li><a href=/chapter-9/creational-patterns/go-object-pool-pattern/>9.1.7 الگو Object Pool</a></li></ul></li><li><input type=checkbox id=section-0bf1b67244bd7a1b2067d73a9ac05c84 class=toggle>
<label for=section-0bf1b67244bd7a1b2067d73a9ac05c84 class=flex><a href=/chapter-9/structural-patterns/ class=flex-auto>9.2 الگوهای طراحی ساختاری</a></label><ul><li><a href=/chapter-9/structural-patterns/go-adaptor-pattern/>9.2.1 الگو Adaptor</a></li><li><a href=/chapter-9/structural-patterns/go-bridge-pattern/>9.2.2 الگو Bridge</a></li><li><a href=/chapter-9/structural-patterns/go-composite-pattern/>9.2.3 الگو Composite</a></li><li><a href=/chapter-9/structural-patterns/go-decorator-pattern/>9.2.1 الگو Decorator</a></li><li><a href=/chapter-9/structural-patterns/go-facade-pattern/>9.2.5 الگو Facade</a></li><li><a href=/chapter-9/structural-patterns/go-flyweight-pattern/>9.2.6 الگو Flyweight</a></li><li><a href=/chapter-9/structural-patterns/go-proxy-pattern/>9.2.7 الگو Proxy</a></li></ul></li><li><input type=checkbox id=section-67e202f99a50c1e49347339369c874b1 class=toggle>
<label for=section-67e202f99a50c1e49347339369c874b1 class=flex><a href=/chapter-9/behavioral-patterns/ class=flex-auto>9.3 الگوهای طراحی رفتاری</a></label><ul><li><a href=/chapter-9/behavioral-patterns/go-chain-of-responsibility-pattern/>9.3.1 الگو Chain Of Responsibility</a></li><li><a href=/chapter-9/behavioral-patterns/go-command-pattern/>9.3.2 الگو Command</a></li><li><a href=/chapter-9/behavioral-patterns/go-iterator-pattern/>9.3.3 الگو Iterator</a></li><li><a href=/chapter-9/behavioral-patterns/go-mediator-pattern/>9.3.4 الگو Mediator</a></li><li><a href=/chapter-9/behavioral-patterns/go-memento-pattern/>9.3.5 الگو Memento</a></li><li><a href=/chapter-9/behavioral-patterns/go-observer-pattern/>9.3.6 الگو Observer</a></li><li><a href=/chapter-9/behavioral-patterns/go-state-pattern/>9.3.7 الگو State</a></li><li><a href=/chapter-9/behavioral-patterns/go-strategy-pattern/>9.3.8 الگو Strategy</a></li><li><a href=/chapter-9/behavioral-patterns/go-template-method-pattern/>9.3.9 الگو Template Method</a></li><li><a href=/chapter-9/behavioral-patterns/go-visitor-pattern/>9.3.10 الگو Visitor</a></li></ul></li><li><input type=checkbox id=section-a8aa81f62696e9f9c69a81a3318a50eb class=toggle>
<label for=section-a8aa81f62696e9f9c69a81a3318a50eb class=flex><a href=/chapter-9/concurrency-patterns/ class=flex-auto>9.4 الگوهای همزمانی</a></label><ul><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-wait-for-result/>9.4.1 الگو Wait For Result</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-fan-out-in/>9.4.2 الگو Fan Out/In</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-wait-for-task/>9.4.3 الگو Wait For Task</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-worker-pool/>9.4.4 الگوی Worker Pool</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-drop/>9.4.5 الگو Drop</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-cancellation/>9.4.6 الگو Context Cancellation Pattern</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-semaphore/>9.4.7 الگو Semaphore</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-retry-timeout/>9.4.8 الگو Retry Timeout</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-producer-consumer/>9.4.9 الگو Producer-Consumer</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-monitor/>9.4.10 الگو Monitor</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-future/>9.4.11 الگو Future</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-pipeline/>9.4.12 الگو Pipeline</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-subscription/>9.4.13 الگو Subscription</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-brdige-channel/>9.4.14 الگو Bridge Channel</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-queuing/>9.4.15 الگو Queuing</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-ratelimit/>9.4.16 الگو Rate limit</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-deadlock-recovery/>9.4.17 الگو Deadlock Recovery</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-channel-cancellation/>9.4.18 الگو Channel Cancellation</a></li><li><a href=/chapter-9/concurrency-patterns/go-concurrency-pattern-lock-free-synchronization/>9.4.19 الگو Lock-free synchronization</a></li></ul></li><li><input type=checkbox id=section-d4428d0313ccb2e3380b00740324e064 class=toggle>
<label for=section-d4428d0313ccb2e3380b00740324e064 class=flex><a href=/chapter-9/cloud-native-patterns/ class=flex-auto>9.5 الگوهای Cloud Native</a></label><ul><li><a href=/chapter-9/cloud-native-patterns/go-cloud-native-circuit-breaker-pattern/>9.5.1 الگو Circuit Breaker</a></li><li><a href=/chapter-9/cloud-native-patterns/go-cloud-native-debounce-pattern/>9.5.2 الگو Debounce</a></li><li><a href=/chapter-9/cloud-native-patterns/go-cloud-native-retry-pattern/>9.5.3 الگو Retry</a></li><li><a href=/chapter-9/cloud-native-patterns/go-cloud-native-throttle-pattern/>9.5.4 الگو Throttle</a></li><li><a href=/chapter-9/cloud-native-patterns/go-cloud-native-timeout-pattern/>9.5.5 الگو Timeout</a></li></ul></li><li><input type=checkbox id=section-d2db70ad636838c12fc76435099656ac class=toggle>
<label for=section-d2db70ad636838c12fc76435099656ac class=flex><a href=/chapter-9/anti-pattern/ class=flex-auto>9.6 ضد الگوها (Anti-Patterns)</a></label><ul><li><a href=/chapter-9/anti-pattern/go-anti-patterns-in-syntax/>9.6.1 ضد الگو سینتکسی</a></li></ul></li><li><a href=/chapter-9/solid-principle-in-golang/>9.7 اصول SOLID</a></li></ul></li><li><input type=checkbox id=section-109a423730eebb4b9e804ab6e8dc6af0 class=toggle>
<label for=section-109a423730eebb4b9e804ab6e8dc6af0 class=flex><a href=/chapter-10/ class=flex-auto>فصل دهم: الگوریتم و ساختار داده</a></label><ul><li><a href=/chapter-10/10.1--data-structures-queue-stack-lists/>10.1 Data Structures (Queue Stack Lists)</a></li></ul></li><li><input type=checkbox id=section-0736842d303fef477d0a09e8de4a0d85 class=toggle>
<label for=section-0736842d303fef477d0a09e8de4a0d85 class=flex><a href=/chapter-11/ class=flex-auto>فصل یازدهم: معماری های نرم افزار</a></label><ul></ul></li><li><input type=checkbox id=section-efb5b19050ead65a76618516db266d2d class=toggle>
<label for=section-efb5b19050ead65a76618516db266d2d class=flex><a href=/chapter-12/ class=flex-auto>فصل دوازدهم: شبکه بلاکچین</a></label><ul><li><input type=checkbox id=section-ee81a41ef810f317eba2e67d447c0ec4 class=toggle>
<label for=section-ee81a41ef810f317eba2e67d447c0ec4 class=flex><a href=/chapter-12/blockchain/ class=flex-auto>12.1 بلاکچین</a></label><ul><li><a href=/chapter-12/blockchain/blockchain/>12.1.1 بلاکچین چیست</a></li><li><a href=/chapter-12/blockchain/blockchain-history/>12.1.2 تاریخچه بلاکچین</a></li><li><a href=/chapter-12/blockchain/blockchain-architecture/>12.1.3 معماری بلاکچین</a></li><li><a href=/chapter-12/blockchain/blockchain-type/>12.1.4 انواع بلاکچین</a></li><li><a href=/chapter-12/blockchain/blockchain-different-with-centerlized/>12.1.5 تفاوت سیستم متمرکز با غیرمتمرکز</a></li><li><a href=/chapter-12/blockchain/blockchain-scale/>12.1.6 مقیاس پذیری در بلاکچین</a></li><li><a href=/chapter-12/blockchain/blockchain-security/>12.1.7 امنیت در بلاکچین</a></li><li><a href=/chapter-12/blockchain/blockchain-cryptography/>12.1.8 مفاهیم رمزنگاری</a></li><li><a href=/chapter-12/blockchain/blockchain-consensus-algorithm/>12.1.10 الگوریتم اجماع (Consensus)</a></li><li><a href=/chapter-12/blockchain/blockchain-p2p-network/>12.1.11 ساختار و کاربرد شبکه P2P</a></li><li><a href=/chapter-12/blockchain/blockchain-data-management/>12.1.12 مدیریت داده در بلاکچین</a></li><li><a href=/chapter-12/blockchain/blockchain-network-testing/>12.1.13 تست پذیری شبکه</a></li><li><a href=/chapter-12/blockchain/blockchain-analyze-and-optimization/>12.1.14 ارزیابی و بهینه سازی شبکه</a></li><li><a href=/chapter-12/blockchain/blockchain-monitoring/>12.1.15 مانیتورینگ شبکه</a></li><li><a href=/chapter-12/blockchain/blockchain-forking/>12.1.16 استراتژی فورک ها</a></li><li><a href=/chapter-12/blockchain/blockchain-api-and-sdk/>12.1.17 پیاده سازی انواع API ها و SDK ها</a></li><li><a href=/chapter-12/blockchain/blockchain-keys-and-addresses/>12.1.18 کلیدها و آدرس ها</a></li><li><a href=/chapter-12/blockchain/blockchain-accounts/>12.1.19 اکانت ها</a></li><li><a href=/chapter-12/blockchain/blockchain-transactions-and-messages/>12.1.20 تراکنش ها و پیام ها</a></li><li><a href=/chapter-12/blockchain/blockchain-blocks/>12.1.21 بلوک ها (Blocks)</a></li><li><a href=/chapter-12/blockchain/blockchain-genesis/>12.1.22 جنسیس (Genesis)</a></li><li><a href=/chapter-12/blockchain/blockchain-smart-contracts/>12.1.23 قراردادهای هوشمند</a></li><li><a href=/chapter-12/blockchain/blockchain-privacy/>12.1.24 حریم خصوصی شبکه</a></li></ul></li><li><input type=checkbox id=section-3a22b13c7bb1ba964a59c01435868bd6 class=toggle>
<label for=section-3a22b13c7bb1ba964a59c01435868bd6 class=flex><a href=/chapter-12/bitcoin/ class=flex-auto>12.2 شبکه بیت کوین</a></label><ul><li><a href=/chapter-12/bitcoin/bitcoin/>12.2.1 معرفی بیت کوین</a></li><li><a href=/chapter-12/bitcoin/bitcoin-cryptography/>12.2.2 رمزنگاری در بیت کوین</a></li><li><a href=/chapter-12/bitcoin/bitcoin-addresses/>12.2.3 آدرس ها</a></li><li><a href=/chapter-12/bitcoin/bitcoin-transactions/>12.2.4 تراکنش ها</a></li><li><a href=/chapter-12/bitcoin/bitcoin-structure/>12.2.5 ساختار بلاکچین بیت کوین</a></li><li><a href=/chapter-12/bitcoin/bitcoin-consensus/>12.2.6 الگوریتم اجماع</a></li><li><a href=/chapter-12/bitcoin/bitcoin-miners/>12.2.7 ماینرها</a></li><li><a href=/chapter-12/bitcoin/bitcoin-network/>12.2.8 شبکه</a></li><li><a href=/chapter-12/bitcoin/bitcoin-wallets/>12.2.9 والت ها</a></li><li><a href=/chapter-12/bitcoin/bitcoin-in-real-world/>12.2.10 بیت کوین در دنیای واقعی</a></li><li><a href=/chapter-12/bitcoin/bitcoin-innovation/>12.2.11 نوآوری</a></li><li><a href=/chapter-12/bitcoin/bitcoin-clients/>12.2.12 کلاینت ها</a></li><li><a href=/chapter-12/bitcoin/bitcoin-programming/>12.2.13 برنامه نویسی در بیت کوین</a></li></ul></li><li><input type=checkbox id=section-b9f4acac44a727569ffab43028a36441 class=toggle>
<label for=section-b9f4acac44a727569ffab43028a36441 class=flex><a href=/chapter-12/ethereum/ class=flex-auto>12.3 شبکه اتریوم</a></label><ul><li><a href=/chapter-12/ethereum/ethereum/>12.3.1 معرفی اتریوم</a></li><li><a href=/chapter-12/ethereum/ethereum-cryptography/>12.3.2 رمزنگاری</a></li><li><a href=/chapter-12/ethereum/ethereum-keys-and-addresses/>12.3.3 آدرس ها و کلیدها</a></li><li><a href=/chapter-12/ethereum/ethereum-accounts/>12.3.4 اکانت ها</a></li><li><a href=/chapter-12/ethereum/ethereum-transactions-and-messages/>12.3.5 تراکنش ها و پیام ها</a></li><li><a href=/chapter-12/ethereum/ethereum-virtual-machine/>12.3.6 ماشین مجازی اتریوم</a></li><li><a href=/chapter-12/ethereum/ethereum-blocks/>12.3.7 بلاک ها</a></li><li><a href=/chapter-12/ethereum/ethereum-consensus/>12.3.8 الگوریتم اجماع</a></li><li><a href=/chapter-12/ethereum/ethereum-nodes-and-miners/>12.3.9 نودها و ماینرها</a></li><li><a href=/chapter-12/ethereum/ethereum-network/>12.3.10 شبکه</a></li><li><a href=/chapter-12/ethereum/ethereum-smart-contracts/>12.3.11 قراردادهای هوشمند</a></li><li><a href=/chapter-12/ethereum/ethereum-wallets-and-clients/>12.3.12 والت ها و کلاینت ها</a></li><li><a href=/chapter-12/ethereum/go-ethereum/>12.3.13 معرفی go-ethereum</a></li><li><a href=/chapter-12/ethereum/work-with-accounts/>12.3.14 کار با اکانت ها</a></li><li><a href=/chapter-12/ethereum/transactions-on-ethereum/>12.3.15 تراکنش برروی اتریوم</a></li><li><a href=/chapter-12/ethereum/read-write-in-smart-contracts/>12.3.16 نوشتن و ارتباط با قراردادهای هوشمند</a></li><li><a href=/chapter-12/ethereum/abi-and-bin-file/>12.3.17 آشنایی با فایل ABI و bytecode</a></li><li><a href=/chapter-12/ethereum/event-logs/>12.3.18 خواندن و دریافت لحظه ای لاگ های کانترکت ها</a></li><li><a href=/chapter-12/ethereum/signature/>12.3.19 ایجاد و تایید امضا</a></li><li><a href=/chapter-12/ethereum/geth/>12.3.20 کار با geth</a></li><li><a href=/chapter-12/ethereum/protocol-swarm-and-whisper/>12.3.21 کار با پروتکل whisper و swarm</a></li></ul></li><li><input type=checkbox id=section-71c1e946dcbe629ce566392c9ba8a5bd class=toggle>
<label for=section-71c1e946dcbe629ce566392c9ba8a5bd class=flex><a href=/chapter-12/pactus/ class=flex-auto>12.4 شبکه پکتوس</a></label><ul><li><a href=/chapter-12/pactus/pactus/>12.4.1 معرفی پکتوس</a></li><li><a href=/chapter-12/pactus/pactus-roadmap/>12.4.2 نقشه راه و اهداف</a></li><li><a href=/chapter-12/pactus/pactus-cryptography/>12.4.3 رمزنگاری</a></li><li><a href=/chapter-12/pactus/pactus-addresses-and-keys/>12.4.4 آدرس ها و کلیدها</a></li><li><a href=/chapter-12/pactus/pactus-accounts/>12.4.5 اکانت ها</a></li><li><a href=/chapter-12/pactus/pactus-transactions-and-messages/>12.4.6 تراکنش ها و پیغام ها</a></li><li><a href=/chapter-12/pactus/pactus-consensus/>12.4.7 الگوریتم اجماع</a></li><li><a href=/chapter-12/pactus/pactus-client/>12.4.8 کار با کلاینت</a></li><li><a href=/chapter-12/pactus/pactus-smart-contracts/>12.4.9 قراردادهای هوشمند (بزودی)</a></li></ul></li></ul></li></ul><a class="book-btn gray" href=https://github.com/GoFarsi/book>مخزن کتاب</a>
<a class=book-btn href=https://github.com/GoFarsi/book/blob/main/COUNTRIBUTING.md>مشارکت در کتاب زبان گو</a><center><p><img alt="GitHub Repo stars" src=https://img.shields.io/github/stars/GoFarsi/book> <img alt=GitHub src=https://img.shields.io/github/license/gofarsi/book> <img alt="GitHub contributors" src=https://img.shields.io/github/contributors/gofarsi/book></p></center></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>3.3 پکیج sync</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"></br><main><div class=wrapper><a href=https://t.me/GolangEngineers class="icon telegram" target=_blank><div class=tooltip>گروه تلگرامی مهندسین گولنگ</div><span><i class="fab fa-telegram"></i></span>
</a><a href=https://linkedin.com/in/Ja7ad class="icon linkedin" target=_blank><div class=tooltip>لینکدین نویسنده</div><span><i class="fab fa-linkedin"></i></span>
</a><a href=https://twitter.com/Ja7adR class="icon twitter" target=_blank><div class=tooltip>توییتر نویسنده</div><span><i class="fab fa-twitter"></i></span></a></div></main></br></br><nav id=TableOfContents><ul><li><ul><li><a href=#331-mutex--قفل-متقابل>3.3.1 Mutex — قفل متقابل</a><ul><li><a href=#مثال-تئوری--آشپزخانه-و-سیبزمینی-سرخکرده>مثال تئوری — آشپزخانه و سیب‌زمینی سرخ‌کرده</a></li><li><a href=#3111-ساختار-mutex-در-go>3.1.1.1 ساختار Mutex در Go</a></li><li><a href=#3112-مثال-ساده-mutex>3.1.1.2 مثال ساده Mutex</a></li><li><a href=#3113-نکات-کاربردی-و-تولیدی-mutex>3.1.1.3 نکات کاربردی و تولیدی Mutex</a></li><li><a href=#3114-مثال-پیشرفته-mutex-در-struct>3.1.1.4 مثال پیشرفته: Mutex در struct</a></li><li><a href=#3115-مزایا-و-معایب-mutex>3.1.1.5 مزایا و معایب Mutex</a></li><li><a href=#3316-سناریوهای-استفاده>3.3.1.6 سناریوهای استفاده</a></li></ul></li><li><a href=#332-rwmutex--قفل-خواندننوشتن>3.3.2 RWMutex — قفل خواندن/نوشتن</a><ul><li><a href=#3321-چرا-rwmutex>3.3.2.1 چرا RWMutex؟</a></li><li><a href=#3322-متدهای-اصلی-rwmutex>3.3.2.2 متدهای اصلی RWMutex</a></li><li><a href=#3323-مثال-ساده-rwmutex>3.3.2.3 مثال ساده RWMutex</a></li><li><a href=#3324-نکات-و-ترفندهای-استفاده-از-rwmutex>3.3.2.4 نکات و ترفندهای استفاده از RWMutex</a></li><li><a href=#3325-مثال-کاربردی--کش-خواندنینوشتنی>3.3.2.5 مثال کاربردی — کش خواندنی/نوشتنی</a></li></ul></li><li><a href=#333-waitgroup--هماهنگی-پایان-کار-goroutineها>3.3.3 WaitGroup — هماهنگی پایان کار goroutineها</a><ul><li><a href=#3331-متدهای-اصلی-waitgroup>3.3.3.1 متدهای اصلی WaitGroup</a></li><li><a href=#3332-مثال-ساده-waitgroup>3.3.3.2 مثال ساده WaitGroup</a></li><li><a href=#3333-مثال-کاربردی--دانلود-همزمان-فایلها>3.3.3.3 مثال کاربردی — دانلود همزمان فایل‌ها</a></li><li><a href=#3334-نکات-و-ترفندهای-استفاده-از-waitgroup>3.3.3.4 نکات و ترفندهای استفاده از WaitGroup</a></li><li><a href=#3335-اشتباه-رایج--add-داخل-goroutine>3.3.3.5 اشتباه رایج — Add داخل goroutine</a></li><li><a href=#3336-مثال-پیشرفته--پردازش-موازی-با-waitgroup-و-semaphore>3.3.3.6 مثال پیشرفته — پردازش موازی با WaitGroup و Semaphore</a></li></ul></li><li><a href=#334-once--اجرای-یک-کد-فقط-یکبار>3.3.4 Once — اجرای یک کد فقط یکبار</a><ul><li><a href=#3341-متد-اصلی-once>3.3.4.1 متد اصلی Once</a></li><li><a href=#3342-چرا-از-once-استفاده-کنیم>3.3.4.2 چرا از Once استفاده کنیم؟</a></li><li><a href=#3343-مثال-ساده-once>3.3.4.3 مثال ساده Once</a></li><li><a href=#3344-استفاده-از-once-برای-پیادهسازی-singleton>3.3.4.4 استفاده از Once برای پیاده‌سازی Singleton</a></li><li><a href=#3345-نکات-و-ترفندهای-استفاده-از-once>3.3.4.5 نکات و ترفندهای استفاده از Once</a></li></ul></li><li><a href=#335-pool>3.3.5 Pool</a><ul><li><a href=#3351-بنچمارک-در-خصوص-pool>3.3.5.1 بنچمارک در خصوص Pool</a></li><li><a href=#3352-مثال-های-کاربردی>3.3.5.2 مثال های کاربردی</a></li></ul></li><li><a href=#336-cond>3.3.6 Cond</a><ul><li></li></ul></li></ul></li></ul></nav></aside></header><h1>3.3 پکیج sync</h1><article class="markdown book-article"><p>پکیج <code>sync</code> توی گو مثل یک جعبه‌ابزار تخصصی برای <strong>همگام‌سازی (synchronize)</strong> و مدیریت دسترسی چندتا <strong>goroutine</strong> به داده یا منبع مشترکه.<br>وقتی چند goroutine همزمان به یک داده دسترسی پیدا می‌کنن، بدون هماهنگی ممکنه داده خراب بشه یا رفتار برنامه غیرقابل پیش‌بینی بشه (Data Race).</p><p><code>sync</code> دقیقا برای جلوگیری از این اتفاق ساخته شده و ابزارهایی رو ارائه می‌ده که اجازه می‌ده <strong>دسترسی همزمان رو کنترل کنید</strong>.</p><p>ابزارهای اصلی <code>sync</code>:</p><ul><li><strong><code>Mutex</code></strong> — قفل ساده برای جلوگیری از دسترسی همزمان به منبع مشترک.</li><li><strong><code>RWMutex</code></strong> — قفل خواندن/نوشتن: چند خواننده همزمان یا یک نویسنده در هر لحظه.</li><li><strong><code>WaitGroup</code></strong> — منتظر موندن تا همه goroutineها کارشون رو تموم کنن.</li><li><strong><code>Once</code></strong> — اجرای یک کد فقط یک بار حتی بین چند goroutine.</li><li><strong><code>Pool</code></strong> — نگه‌داری مجموعه‌ای از آبجکت‌های آماده برای استفاده مجدد.</li><li><strong><code>Cond</code></strong> — هماهنگی بر اساس شرط یا رویداد (Condition Variable).</li></ul><blockquote><p><strong>نکته:</strong> <code>sync</code> فقط برای <strong>هماهنگ‌کردن دسترسی به منابع مشترک</strong> ساخته شده، نه برای زمان‌بندی یا اجرای همزمان.</p></blockquote><blockquote class="book-hint info">توجه کنید که پکیج <code>sync</code> فقط و فقط برای مدیریت و همگام سازی دسترسی های گوروتین ها به یک داده مشترک استفاده می شود.</blockquote><h2 id=331-mutex--قفل-متقابل>3.3.1 Mutex — قفل متقابل
<a class=anchor href=#331-mutex--%d9%82%d9%81%d9%84-%d9%85%d8%aa%d9%82%d8%a7%d8%a8%d9%84>#</a></h2><p><code>Mutex</code> یا <strong>قفل متقابل</strong> یکی از اصلی‌ترین ابزارهای همگام‌سازی در زبان Go است که برای جلوگیری از <strong>دسترسی همزمان ناامن (Data Race)</strong> به داده‌های مشترک استفاده می‌شود. وقتی یک goroutine قفل را با <code>Lock()</code> می‌گیرد، سایر goroutineهایی که سعی کنند همان قفل را بگیرند، باید منتظر بمانند تا قفل با <code>Unlock()</code> آزاد شود. این مکانیزم تضمین می‌کند که در هر لحظه فقط یک goroutine می‌تواند بخش بحرانی (Critical Section) کد را اجرا کند. بخش بحرانی همان قسمتی از کد است که به داده‌ی مشترک دسترسی دارد و تغییر آن ممکن است باعث بروز خطا یا رفتار غیرقابل پیش‌بینی شود.</p><p>یکی از نکات کلیدی در استفاده از Mutex این است که <strong>قفل باید تا حد امکان کوتاه‌مدت نگه داشته شود</strong>. یعنی فقط همان بخش ضروری از کد را قفل کنید، چون قفل‌کردن طولانی می‌تواند باعث کاهش کارایی و ایجاد گلوگاه (Bottleneck) شود. همچنین هرگز نباید Mutex را کپی کنید، چون هر Mutex داخلی یک وضعیت دارد و کپی آن باعث می‌شود قفل‌ها به‌درستی عمل نکنند.</p><h3 id=مثال-تئوری--آشپزخانه-و-سیبزمینی-سرخکرده>مثال تئوری — آشپزخانه و سیب‌زمینی سرخ‌کرده
<a class=anchor href=#%d9%85%d8%ab%d8%a7%d9%84-%d8%aa%d8%a6%d9%88%d8%b1%db%8c--%d8%a2%d8%b4%d9%be%d8%b2%d8%ae%d8%a7%d9%86%d9%87-%d9%88-%d8%b3%db%8c%d8%a8%d8%b2%d9%85%db%8c%d9%86%db%8c-%d8%b3%d8%b1%d8%ae%da%a9%d8%b1%d8%af%d9%87>#</a></h3><p>فرض کنید مادرتان در آشپزخانه در حال سرخ کردن سیب‌زمینی خلالی است. برای اینکه کسی وسط کار مزاحم نشود و نظم کار به هم نخورد، درِ آشپزخانه را می‌بندد. حالا این در مثل یک <strong>Mutex</strong> عمل می‌کند:</p><ul><li>وقتی در بسته است (<strong>Lock</strong> شده)، فقط مادرتان داخل آشپزخانه است و می‌تواند روی سیب‌زمینی‌ها کار کند.</li><li>اگر کسی (مثلاً یکی از بچه‌ها) بخواهد وارد آشپزخانه شود، باید منتظر بماند تا مادرتان در را باز کند (<strong>Unlock</strong>).</li><li>وقتی مادرتان کارش را تمام کرد و در را باز کرد، نفر بعدی می‌تواند وارد شود و کاری انجام دهد.</li></ul><p>حالا فرض کنید در طول کار، یکی از بچه‌ها خیلی عجله دارد و بدون اجازه وارد می‌شود و یک مشت سیب‌زمینی برمی‌دارد. این همان <strong>Data Race</strong> است که بدون قفل اتفاق می‌افتد و می‌تواند باعث خراب شدن برنامه (یا در این مثال، کمتر شدن سیب‌زمینی‌ها 😄) شود. Mutex دقیقاً برای جلوگیری از این نوع تداخل ساخته شده است.</p><center><a href=#><img src=../../assets/img/content/chapter3/sync/1.jpg alt="sync mutex"></a></center><h3 id=3111-ساختار-mutex-در-go>3.1.1.1 ساختار Mutex در Go
<a class=anchor href=#3111-%d8%b3%d8%a7%d8%ae%d8%aa%d8%a7%d8%b1-mutex-%d8%af%d8%b1-go>#</a></h3><p><code>sync.Mutex</code> دو متد اصلی داره:</p><ol><li><strong><code>Lock()</code></strong><ul><li>وقتی یک goroutine این متد رو صدا بزنه، قفل رو می‌گیره.</li><li>اگه قفل قبلاً توسط goroutine دیگه گرفته شده باشه، این goroutine منتظر می‌مونه (مسدود می‌شه) تا قفل آزاد بشه.</li></ul></li><li><strong><code>Unlock()</code></strong><ul><li>قفل رو آزاد می‌کنه تا goroutineهای دیگه بتونن وارد بخش قفل‌شده بشن.</li></ul></li></ol><blockquote><p>⚡ <strong>نکته مهم تولیدی:</strong><br>بعد از هر <code>Lock()</code> بلافاصله <code>defer Unlock()</code> بنویسید تا حتی اگر وسط کار panic یا return اتفاق افتاد، قفل آزاد بشه:</p><pre><code class=language-go>mu.Lock()
defer mu.Unlock()
</code></pre></blockquote><h3 id=3112-مثال-ساده-mutex>3.1.1.2 مثال ساده Mutex
<a class=anchor href=#3112-%d9%85%d8%ab%d8%a7%d9%84-%d8%b3%d8%a7%d8%af%d9%87-mutex>#</a></h3><p>در این مثال، چهار goroutine می‌خوان همزمان مقدار یک متغیر مشترک (<code>count</code>) رو تغییر بدن:</p><div class=go-playground><pre class=line-numbers><code class=language-go>package main

import (
	"fmt"
	"sync"
	"time"
)

var count int // متغیر مشترک
var mu sync.Mutex

func main() {
	for i := 0; i < 4; i++ {
		go increment()
	}
	time.Sleep(time.Second)
}

func increment() {
	mu.Lock()           // گرفتن قفل
	defer mu.Unlock()   // آزاد کردن قفل بعد از اتمام کار
	count++
	fmt.Printf("Count: %d\n", count)
}</code></pre><button class=run-code>▶ اجرای کد</button>
<button class=copy-code>کپی</button>
<button class=hide-output>✖ بستن خروجی</button><pre class="run-output hidden"></pre></div><h3 id=3113-نکات-کاربردی-و-تولیدی-mutex>3.1.1.3 نکات کاربردی و تولیدی Mutex
<a class=anchor href=#3113-%d9%86%da%a9%d8%a7%d8%aa-%da%a9%d8%a7%d8%b1%d8%a8%d8%b1%d8%af%db%8c-%d9%88-%d8%aa%d9%88%d9%84%db%8c%d8%af%db%8c-mutex>#</a></h3><ol><li><strong>محدوده قفل رو کوچک نگه دارید</strong><br>قفل رو فقط برای بخشی از کد که نیاز به حفاظت داره بگیرید. قفل‌کردن بخش‌های بزرگ کد می‌تونه باعث افت کارایی بشه.</li><li><strong>از کپی Mutex خودداری کنید</strong><br>همیشه Mutex رو با اشاره‌گر (pointer) پاس بدید، چون کپی‌کردن Mutex می‌تونه باعث رفتار غیرقابل پیش‌بینی بشه.</li><li><strong>احتیاط در قفل‌های تو در تو (Nested Locks)</strong><br>گرفتن چند قفل به ترتیب اشتباه می‌تونه باعث Deadlock بشه. همیشه ترتیب قفل‌گیری رو یکسان نگه دارید.</li><li><strong>استفاده در ساختار داده‌ها</strong><br>می‌تونید Mutex رو به عنوان فیلد در یک struct بذارید تا عملیات روی داده‌های اون struct ایمن بشه.</li></ol><h3 id=3114-مثال-پیشرفته-mutex-در-struct>3.1.1.4 مثال پیشرفته: Mutex در struct
<a class=anchor href=#3114-%d9%85%d8%ab%d8%a7%d9%84-%d9%be%db%8c%d8%b4%d8%b1%d9%81%d8%aa%d9%87-mutex-%d8%af%d8%b1-struct>#</a></h3><div class=go-playground><pre class=line-numbers><code class=language-go>package main

import (
	"fmt"
	"sync"
)

type SafeCounter struct {
	mu    sync.Mutex
	value int
}

func (c *SafeCounter) Inc() {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.value++
}

func (c *SafeCounter) Value() int {
	c.mu.Lock()
	defer c.mu.Unlock()
	return c.value
}

func main() {
	counter := &SafeCounter{}
	var wg sync.WaitGroup

	for i := 0; i < 1000; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			counter.Inc()
		}()
	}

	wg.Wait()
	fmt.Println("Final Count:", counter.Value())
}</code></pre><button class=run-code>▶ اجرای کد</button>
<button class=copy-code>کپی</button>
<button class=hide-output>✖ بستن خروجی</button><pre class="run-output hidden"></pre></div><h3 id=3115-مزایا-و-معایب-mutex>3.1.1.5 مزایا و معایب Mutex
<a class=anchor href=#3115-%d9%85%d8%b2%d8%a7%db%8c%d8%a7-%d9%88-%d9%85%d8%b9%d8%a7%db%8c%d8%a8-mutex>#</a></h3><p><strong>مزایا:</strong></p><ul><li>پیاده‌سازی ساده و مستقیم.</li><li>بدون overhead اضافی برای مدیریت channel یا ساختار پیچیده.</li></ul><p><strong>معایب:</strong></p><ul><li>قفل‌گذاری بیش از حد می‌تونه باعث افت کارایی بشه.</li><li>اشتباه در مدیریت Lock/Unlock ممکنه باعث Deadlock یا Data Race بشه.</li></ul><h3 id=3316-سناریوهای-استفاده>3.3.1.6 سناریوهای استفاده
<a class=anchor href=#3316-%d8%b3%d9%86%d8%a7%d8%b1%db%8c%d9%88%d9%87%d8%a7%db%8c-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87>#</a></h3><ol><li><p><strong>همگام سازی دسترسی به متغیرهای مشترک:</strong> یک mutex می تواند برای همگام سازی دسترسی به متغیرهای مشترک بین چندین گوروتین استفاده شود. این می تواند در مواردی مفید باشد که چندین گوروتین نیاز به خواندن یا به روز رسانی یک متغیر به طور همزمان دارند.</p></li><li><p><strong>هماهنگی دسترسی به حالت مشترک:</strong> یک mutex می تواند برای هماهنگ کردن دسترسی به حالت مشترک بین چندین گوروتین استفاده شود. به عنوان مثال، ممکن است از یک mutex استفاده کنید تا اطمینان حاصل کنید که فقط یک گوروتین می تواند یک ساختار داده مشترک را در یک زمان تغییر دهد.</p></li><li><p><strong>پیاده سازی الگوهای تولیدکننده-مصرف کننده (producer-consumer):</strong> یک mutex می تواند برای پیاده سازی الگوهای تولیدکننده-مصرف کننده استفاده شود، که در آن یک یا چند گوروتین داده تولید می کنند و یک یا چند گوروتین آن را مصرف می کنند. mutex می تواند برای همگام سازی دسترسی به ساختار داده مشترک که داده ها را نگه می دارد استفاده شود.</p></li></ol><blockquote class="book-hint warning"><p><strong>۲ نکته خیلی مهم</strong></p><ol><li>سعی کنید پس از اینکه تابع Lock را فراخوانی میکنید تابع Unlock را داخل defer قرار دهید.</li><li>زمانیکه قصد دارید Mutex را به عنوان پارامتر ورودی برای توابع تعریف کنید بهتر است از نوع <span class=tooltip data-tooltip=pointer ontouchend=toggleTooltip(this)>اشاره گر</span>
باشد.</li></ol></blockquote><h2 id=332-rwmutex--قفل-خواندننوشتن>3.3.2 RWMutex — قفل خواندن/نوشتن
<a class=anchor href=#332-rwmutex--%d9%82%d9%81%d9%84-%d8%ae%d9%88%d8%a7%d9%86%d8%af%d9%86%d9%86%d9%88%d8%b4%d8%aa%d9%86>#</a></h2><p><code>RWMutex</code> مخفف <strong>Read-Write Mutex</strong> هست و درواقع نسخه‌ی پیشرفته‌تر <code>Mutex</code> محسوب می‌شه.<br>وظیفه‌اش همگام‌سازی دسترسی همزمان به یک داده یا منبع مشترکه، ولی با یک قابلیت اضافه: <strong>چند goroutine می‌تونن همزمان داده رو بخونن، ولی فقط یک goroutine می‌تونه بنویسه و وقتی در حال نوشتنه، هیچ‌کس حق خواندن نداره</strong>.</p><h3 id=3321-چرا-rwmutex>3.3.2.1 چرا RWMutex؟
<a class=anchor href=#3321-%da%86%d8%b1%d8%a7-rwmutex>#</a></h3><p>در خیلی از برنامه‌ها، تعداد عملیات <strong>خواندن (Read)</strong> روی داده‌ها خیلی بیشتر از <strong>نوشتن (Write)</strong> هست. مثلا:</p><ul><li>کش (Cache) که بیشتر وقت‌ها داده رو از حافظه می‌خونیم و فقط گاهی به‌روزرسانی می‌کنیم.</li><li>تنظیمات برنامه (Configuration) که بارها خونده می‌شه ولی به ندرت تغییر پیدا می‌کنه.</li></ul><p>در این مواقع، استفاده از یک <code>Mutex</code> ساده باعث می‌شه حتی وقتی چند goroutine فقط می‌خوان داده رو بخونن، مجبور بشن منتظر هم بمونن. اما <code>RWMutex</code> اجازه می‌ده چند خواننده همزمان کار کنن و فقط موقع نوشتن همه منتظر بمونن.</p><h3 id=3322-متدهای-اصلی-rwmutex>3.3.2.2 متدهای اصلی RWMutex
<a class=anchor href=#3322-%d9%85%d8%aa%d8%af%d9%87%d8%a7%db%8c-%d8%a7%d8%b5%d9%84%db%8c-rwmutex>#</a></h3><ul><li><strong><code>RLock()</code></strong> — گرفتن قفل خواندن. چند goroutine می‌تونن همزمان RLock بگیرن.</li><li><strong><code>RUnlock()</code></strong> — آزاد کردن قفل خواندن.</li><li><strong><code>Lock()</code></strong> — گرفتن قفل نوشتن. فقط یک goroutine می‌تونه همزمان Lock بگیره و تا زمانی که قفل نوشتن فعاله، هیچ‌کس نمی‌تونه بخونه یا بنویسه.</li><li><strong><code>Unlock()</code></strong> — آزاد کردن قفل نوشتن.</li></ul><h3 id=3323-مثال-ساده-rwmutex>3.3.2.3 مثال ساده RWMutex
<a class=anchor href=#3323-%d9%85%d8%ab%d8%a7%d9%84-%d8%b3%d8%a7%d8%af%d9%87-rwmutex>#</a></h3><div class=go-playground><pre class=line-numbers><code class=language-go>package main

import (
	"fmt"
	"sync"
	"time"
)

type SafeMap struct {
	mu   sync.RWMutex
	data map[string]string
}

func (s *SafeMap) Read(key string) string {
	s.mu.RLock()
	defer s.mu.RUnlock()
	return s.data[key]
}

func (s *SafeMap) Write(key, value string) {
	s.mu.Lock()
	defer s.mu.Unlock()
	s.data[key] = value
}

func main() {
	smap := SafeMap{data: make(map[string]string)}

	// نویسنده
	go func() {
		for i := 0; i < 5; i++ {
			smap.Write(fmt.Sprintf("book-%d", i), fmt.Sprintf("value-%d", i))
			fmt.Printf("Writer wrote %d\n", i)
			time.Sleep(200 * time.Millisecond)
		}
	}()

	// چند خواننده همزمان
	for i := 0; i < 3; i++ {
		go func(id int) {
			for j := 0; j < 5; j++ {
				fmt.Printf("Reader %d read %s\n", id, smap.Read(fmt.Sprintf("book-%d", j)))
				time.Sleep(500 * time.Millisecond)
			}
		}(i)
	}

	time.Sleep(3 * time.Second)
}</code></pre><button class=run-code>▶ اجرای کد</button>
<button class=copy-code>کپی</button>
<button class=hide-output>✖ بستن خروجی</button><pre class="run-output hidden"></pre></div><p>در این مثال، چند goroutine همزمان از متد <code>Read()</code> استفاده می‌کنن و چون <code>RLock()</code> استفاده شده، همه می‌تونن بدون منتظر موندن بخونن. ولی موقع نوشتن، قفل نوشتن (<code>Lock()</code>) همه رو متوقف می‌کنه تا عملیات امن انجام بشه.</p><h3 id=3324-نکات-و-ترفندهای-استفاده-از-rwmutex>3.3.2.4 نکات و ترفندهای استفاده از RWMutex
<a class=anchor href=#3324-%d9%86%da%a9%d8%a7%d8%aa-%d9%88-%d8%aa%d8%b1%d9%81%d9%86%d8%af%d9%87%d8%a7%db%8c-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-rwmutex>#</a></h3><ol><li><strong>وقتی بیشتر خواندن داریم، از RWMutex استفاده کنید</strong><br>اگر نسبت خواندن به نوشتن پایین باشه (یعنی نوشتن زیاد باشه)، استفاده از RWMutex ممکنه حتی کندتر از Mutex ساده باشه، چون مدیریت قفل‌های خواندن/نوشتن پیچیده‌تره.</li><li><strong>هرگز قفل خواندن و نوشتن را همزمان نگیرید</strong><br>گرفتن <code>RLock()</code> و سپس تلاش برای گرفتن <code>Lock()</code> در همان goroutine باعث Deadlock می‌شه.</li><li><strong>محدوده قفل را کوچک نگه دارید</strong><br>فقط همان بخش حساس به تغییر داده را قفل کنید. این کار باعث افزایش عملکرد و کاهش زمان انتظار می‌شود.</li><li><strong>قفل‌ها را جفت باز و بسته کنید</strong><br>هر <code>RLock()</code> باید با <code>RUnlock()</code> و هر <code>Lock()</code> باید با <code>Unlock()</code> جفت شود.</li></ol><h3 id=3325-مثال-کاربردی--کش-خواندنینوشتنی>3.3.2.5 مثال کاربردی — کش خواندنی/نوشتنی
<a class=anchor href=#3325-%d9%85%d8%ab%d8%a7%d9%84-%da%a9%d8%a7%d8%b1%d8%a8%d8%b1%d8%af%db%8c--%da%a9%d8%b4-%d8%ae%d9%88%d8%a7%d9%86%d8%af%d9%86%db%8c%d9%86%d9%88%d8%b4%d8%aa%d9%86%db%8c>#</a></h3><p>فرض کنید یک سیستم داریم که قیمت ارز را ذخیره می‌کند:</p><ul><li>ده‌ها goroutine در حال خواندن قیمت هستند.</li><li>فقط یک goroutine هر چند ثانیه یکبار قیمت را به‌روزرسانی می‌کند.</li></ul><p>در این سناریو RWMutex باعث می‌شود خواننده‌ها معطل همدیگر نشوند و فقط هنگام بروزرسانی، همه منتظر بمانند.</p><pre><code class=language-go>type PriceCache struct {
	mu    sync.RWMutex
	price float64
}

func (p *PriceCache) Get() float64 {
	p.mu.RLock()
	defer p.mu.RUnlock()
	return p.price
}

func (p *PriceCache) Set(val float64) {
	p.mu.Lock()
	defer p.mu.Unlock()
	p.price = val
}
</code></pre><h2 id=333-waitgroup--هماهنگی-پایان-کار-goroutineها>3.3.3 WaitGroup — هماهنگی پایان کار goroutineها
<a class=anchor href=#333-waitgroup--%d9%87%d9%85%d8%a7%d9%87%d9%86%da%af%db%8c-%d9%be%d8%a7%db%8c%d8%a7%d9%86-%da%a9%d8%a7%d8%b1-goroutine%d9%87%d8%a7>#</a></h2><p><code>WaitGroup</code> در پکیج <code>sync</code> یکی از پرکاربردترین ابزارها برای همگام‌سازی است که به شما اجازه می‌دهد <strong>منتظر بمانید تا گروهی از goroutineها کارشان را تمام کنند</strong>.<br>ایده‌اش ساده است: شما قبل از اجرای goroutineها به WaitGroup می‌گویید که چندتا کار قرار است انجام شود، هر goroutine بعد از اتمام کار به WaitGroup خبر می‌دهد، و وقتی همه کارها تمام شد، برنامه ادامه پیدا می‌کند.</p><h3 id=3331-متدهای-اصلی-waitgroup>3.3.3.1 متدهای اصلی WaitGroup
<a class=anchor href=#3331-%d9%85%d8%aa%d8%af%d9%87%d8%a7%db%8c-%d8%a7%d8%b5%d9%84%db%8c-waitgroup>#</a></h3><ol><li><strong><code>Add(delta int)</code></strong><ul><li>تعداد کارهایی که WaitGroup باید منتظرشان بماند را اضافه یا کم می‌کند.</li><li>معمولاً قبل از اجرای goroutineها استفاده می‌شود (<code>Add(n)</code> برای n تا goroutine).</li></ul></li><li><strong><code>Done()</code></strong><ul><li>نشان می‌دهد که یکی از کارها تمام شده است.</li><li>معادل <code>Add(-1)</code> است.</li><li>معمولاً در ابتدای goroutine با <code>defer</code> فراخوانی می‌شود.</li></ul></li><li><strong><code>Wait()</code></strong><ul><li>برنامه را تا زمانی که شمارش WaitGroup به صفر برسد مسدود می‌کند.</li></ul></li></ol><h3 id=3332-مثال-ساده-waitgroup>3.3.3.2 مثال ساده WaitGroup
<a class=anchor href=#3332-%d9%85%d8%ab%d8%a7%d9%84-%d8%b3%d8%a7%d8%af%d9%87-waitgroup>#</a></h3><div class=go-playground><pre class=line-numbers><code class=language-go>package main

import (
	"fmt"
	"sync"
	"time"
)

func main() {
	var wg sync.WaitGroup
	wg.Add(3) // انتظار برای 3 goroutine

	go worker("A", &wg)
	go worker("B", &wg)
	go worker("C", &wg)

	wg.Wait() // صبر تا پایان همه goroutineها
	fmt.Println("All workers finished!")
}

func worker(name string, wg *sync.WaitGroup) {
	defer wg.Done() // اعلام پایان کار
	fmt.Printf("Worker %s starting...\n", name)
	time.Sleep(time.Second)
	fmt.Printf("Worker %s done.\n", name)
}</code></pre><button class=run-code>▶ اجرای کد</button>
<button class=copy-code>کپی</button>
<button class=hide-output>✖ بستن خروجی</button><pre class="run-output hidden"></pre></div><h3 id=3333-مثال-کاربردی--دانلود-همزمان-فایلها>3.3.3.3 مثال کاربردی — دانلود همزمان فایل‌ها
<a class=anchor href=#3333-%d9%85%d8%ab%d8%a7%d9%84-%da%a9%d8%a7%d8%b1%d8%a8%d8%b1%d8%af%db%8c--%d8%af%d8%a7%d9%86%d9%84%d9%88%d8%af-%d9%87%d9%85%d8%b2%d9%85%d8%a7%d9%86-%d9%81%d8%a7%db%8c%d9%84%d9%87%d8%a7>#</a></h3><p>فرض کنید می‌خواهیم چند فایل را به صورت موازی دانلود کنیم و منتظر بمانیم تا همه دانلودها کامل شوند:</p><div class=go-playground><pre class=line-numbers><code class=language-go>package main

import (
	"fmt"
	"sync"
	"time"
)

func downloadFile(url string, wg *sync.WaitGroup) {
	defer wg.Done()
	fmt.Println("Downloading:", url)
	time.Sleep(2 * time.Second)
	fmt.Println("Downloaded:", url)
}

func main() {
	var wg sync.WaitGroup
	files := []string{"file1.zip", "file2.zip", "file3.zip"}

	wg.Add(len(files))
	for _, f := range files {
		go downloadFile(f, &wg)
	}

	wg.Wait()
	fmt.Println("All downloads complete!")
}</code></pre><button class=run-code>▶ اجرای کد</button>
<button class=copy-code>کپی</button>
<button class=hide-output>✖ بستن خروجی</button><pre class="run-output hidden"></pre></div><h3 id=3334-نکات-و-ترفندهای-استفاده-از-waitgroup>3.3.3.4 نکات و ترفندهای استفاده از WaitGroup
<a class=anchor href=#3334-%d9%86%da%a9%d8%a7%d8%aa-%d9%88-%d8%aa%d8%b1%d9%81%d9%86%d8%af%d9%87%d8%a7%db%8c-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-waitgroup>#</a></h3><ol><li><strong>همیشه <code>Add()</code> را قبل از شروع goroutineها انجام دهید</strong><br>اگر <code>Add()</code> را بعد از شروع goroutineها انجام دهید، ممکن است WaitGroup صفر شود و <code>Wait()</code> بلافاصله ادامه پیدا کند (Race Condition).</li><li><strong>از اشاره‌گر برای پاس دادن WaitGroup استفاده کنید</strong><br>WaitGroup را کپی نکنید، چون هر کپی شمارش خودش را دارد و هماهنگی از بین می‌رود.</li><li><strong>تعداد Add و Done باید دقیقاً برابر باشد</strong><br>اگر تعداد <code>Done()</code> کمتر از <code>Add()</code> باشد، <code>Wait()</code> برای همیشه مسدود می‌ماند.<br>اگر تعداد بیشتر باشد، Panic رخ می‌دهد.</li><li><strong>ترکیب با Channel برای نتایج</strong><br>می‌توانید WaitGroup را با Channel ترکیب کنید تا بعد از اتمام همه goroutineها، داده‌ها را پردازش کنید.</li></ol><h3 id=3335-اشتباه-رایج--add-داخل-goroutine>3.3.3.5 اشتباه رایج — Add داخل goroutine
<a class=anchor href=#3335-%d8%a7%d8%b4%d8%aa%d8%a8%d8%a7%d9%87-%d8%b1%d8%a7%db%8c%d8%ac--add-%d8%af%d8%a7%d8%ae%d9%84-goroutine>#</a></h3><p>اشتباه:</p><pre><code class=language-go>for _, task := range tasks {
	go func(t string) {
		wg.Add(1) // ❌ اشتباه
		doTask(t)
		wg.Done()
	}(task)
}
</code></pre><p><strong>چرا اشتباهه؟</strong></p><p>چون ممکنه goroutine هنوز Add نکرده باشه ولی main <code>Wait()</code> رو صدا بزنه و شمارش صفر بشه.</p><p>راه درست:</p><pre><code class=language-go>wg.Add(len(tasks))
for _, task := range tasks {
	go func(t string) {
		defer wg.Done()
		doTask(t)
	}(task)
}
</code></pre><h3 id=3336-مثال-پیشرفته--پردازش-موازی-با-waitgroup-و-semaphore>3.3.3.6 مثال پیشرفته — پردازش موازی با WaitGroup و Semaphore
<a class=anchor href=#3336-%d9%85%d8%ab%d8%a7%d9%84-%d9%be%db%8c%d8%b4%d8%b1%d9%81%d8%aa%d9%87--%d9%be%d8%b1%d8%af%d8%a7%d8%b2%d8%b4-%d9%85%d9%88%d8%a7%d8%b2%db%8c-%d8%a8%d8%a7-waitgroup-%d9%88-semaphore>#</a></h3><p>گاهی تعداد goroutineهای همزمان باید محدود شود. ترکیب WaitGroup با Channel به عنوان Semaphore می‌تواند این کار را انجام دهد:</p><blockquote class="book-hint info">اگر درخصوص پترن Semaphore بیشتر میخواید بدانید به <a href=../../chapter-9/concurrency-patterns/go-concurrency-pattern-semaphore>اینجا</a> مراجعه کنید.</blockquote><div class=go-playground><pre class=line-numbers><code class=language-go>package main

import (
	"fmt"
	"sync"
	"time"
)

func process(id int, wg *sync.WaitGroup, sem chan struct{}) {
	defer wg.Done()
	sem <- struct{}{} // گرفتن اسلات
	defer func() { <-sem }() // آزاد کردن اسلات (ایمن‌تر)
	fmt.Printf("Processing %d\n", id)
	time.Sleep(time.Second)
}

func main() {
	var wg sync.WaitGroup
	sem := make(chan struct{}, 3) // حداکثر 3 goroutine همزمان

	for i := 0; i < 10; i++ {
		wg.Add(1)
		go process(i, &wg, sem)
	}

	wg.Wait()
	fmt.Println("All processing complete!")
}</code></pre><button class=run-code>▶ اجرای کد</button>
<button class=copy-code>کپی</button>
<button class=hide-output>✖ بستن خروجی</button><pre class="run-output hidden"></pre></div><blockquote class="book-hint info"><p><strong>۳ نکته خیلی مهم</strong></p><ol><li>ساختار WaitGroup یکی از پرکاربرد ترین قابلیت ها برای بحث همزمانی می باشد و برخی اوقات برای جلوگیری از Data race و همچنین برای ترتیب دهی عملیات همزمانی هم می توان از این استفاده کرد.</li><li>سعی کنید WaitGroup را بصورت اشاره گر به توابعی که داخل گوروتین قرار دارند پاس دهید.</li><li>هیچوقت تعداد گوروتین را بیشتر یا کمتر از اون تعدادی که دارید به متد Add ‌ندهید چون با خطای Panic مواجه خواهید شد.</li></ol></blockquote><h2 id=334-once--اجرای-یک-کد-فقط-یکبار>3.3.4 Once — اجرای یک کد فقط یکبار
<a class=anchor href=#334-once--%d8%a7%d8%ac%d8%b1%d8%a7%db%8c-%db%8c%da%a9-%da%a9%d8%af-%d9%81%d9%82%d8%b7-%db%8c%da%a9%d8%a8%d8%a7%d8%b1>#</a></h2><p><code>sync.Once</code> یکی از ابزارهای پکیج <code>sync</code> هست که تضمین می‌کنه <strong>یک تکه کد فقط یکبار در کل طول اجرای برنامه اجرا بشه</strong>، حتی اگر چندین goroutine به طور همزمان اون رو صدا بزنن.</p><p>این ابزار معمولاً برای کارهایی مثل <strong>مقداردهی اولیه (Initialization)</strong> یا <strong>ساخت منابع مشترک</strong> استفاده می‌شه که نیازه فقط یکبار انجام بشن.</p><h3 id=3341-متد-اصلی-once>3.3.4.1 متد اصلی Once
<a class=anchor href=#3341-%d9%85%d8%aa%d8%af-%d8%a7%d8%b5%d9%84%db%8c-once>#</a></h3><ul><li><strong><code>Do(func())</code></strong><br>این متد یک تابع رو می‌گیره و فقط اولین باری که صدا زده بشه، اون تابع رو اجرا می‌کنه.<br>اگر چند goroutine همزمان <code>Do()</code> رو صدا بزنن، فقط یکی اجرا می‌شه و بقیه منتظر می‌مونن تا تابع اجرا بشه.</li></ul><h3 id=3342-چرا-از-once-استفاده-کنیم>3.3.4.2 چرا از Once استفاده کنیم؟
<a class=anchor href=#3342-%da%86%d8%b1%d8%a7-%d8%a7%d8%b2-once-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%da%a9%d9%86%db%8c%d9%85>#</a></h3><p>بدون <code>Once</code>، اگر بخواهیم کاری رو فقط یکبار انجام بدیم، مجبوریم از یک <code>Mutex</code> برای محافظت از کد استفاده کنیم و خودمون وضعیت (state) رو چک کنیم که آیا قبلاً اجرا شده یا نه. <code>Once</code> این کار رو به صورت thread-safe و بهینه انجام می‌ده، بدون اینکه نیاز باشه ما خودمون مدیریت کنیم.</p><h3 id=3343-مثال-ساده-once>3.3.4.3 مثال ساده Once
<a class=anchor href=#3343-%d9%85%d8%ab%d8%a7%d9%84-%d8%b3%d8%a7%d8%af%d9%87-once>#</a></h3><div class=go-playground><pre class=line-numbers><code class=language-go>package main

import (
	"fmt"
	"sync"
)

var once sync.Once

func initConfig() {
	fmt.Println("Config initialized")
}

func main() {
	for i := 0; i < 5; i++ {
		go once.Do(initConfig)
	}

	// کمی صبر می‌کنیم تا goroutineها اجرا بشن
	var wg sync.WaitGroup
	wg.Add(1)
	go func() {
		defer wg.Done()
	}()
	wg.Wait()
}</code></pre><button class=run-code>▶ اجرای کد</button>
<button class=copy-code>کپی</button>
<button class=hide-output>✖ بستن خروجی</button><pre class="run-output hidden"></pre></div><p>حتی با اجرای چندین goroutine، پیام فقط یکبار چاپ می‌شه.</p><h3 id=3344-استفاده-از-once-برای-پیادهسازی-singleton>3.3.4.4 استفاده از Once برای پیاده‌سازی Singleton
<a class=anchor href=#3344-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-once-%d8%a8%d8%b1%d8%a7%db%8c-%d9%be%db%8c%d8%a7%d8%af%d9%87%d8%b3%d8%a7%d8%b2%db%8c-singleton>#</a></h3><p><code>Once</code> یکی از بهترین راه‌ها برای پیاده‌سازی <strong>الگوی Singleton</strong> در Go هست، چون به صورت ایمن و همزمانی (thread-safe) تضمین می‌کنه که فقط یک instance ساخته می‌شه.</p><div class=go-playground><pre class=line-numbers><code class=language-go>package main

import (
	"fmt"
	"sync"
)

type singleton struct {
	data string
}

var (
	instance *singleton
	once     sync.Once
)

func GetInstance() *singleton {
	once.Do(func() {
		instance = &singleton{data: "my singleton data"}
	})
	return instance
}

func main() {
	s1 := GetInstance()
	s2 := GetInstance()
	if s1 == s2 {
		fmt.Println("Same instance")
	} else {
		fmt.Println("Not same")
	}
}</code></pre><button class=run-code>▶ اجرای کد</button>
<button class=copy-code>کپی</button>
<button class=hide-output>✖ بستن خروجی</button><pre class="run-output hidden"></pre></div><p><strong>مزیت:</strong> نیازی به نوشتن قفل‌های اضافه یا متغیر flag نیست، چون <code>Once</code> همه چیز رو مدیریت می‌کنه.</p><h3 id=3345-نکات-و-ترفندهای-استفاده-از-once>3.3.4.5 نکات و ترفندهای استفاده از Once
<a class=anchor href=#3345-%d9%86%da%a9%d8%a7%d8%aa-%d9%88-%d8%aa%d8%b1%d9%81%d9%86%d8%af%d9%87%d8%a7%db%8c-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-once>#</a></h3><ol><li><strong>حتماً از همان متغیر Once برای تمام دسترسی‌ها استفاده کنید</strong><br>اگر در جاهای مختلف متغیرهای Once جداگانه بسازید، هرکدوم تابع رو یکبار اجرا می‌کنن.</li><li><strong>تابع Do نباید nil باشه</strong><br>اگر nil بدید، Panic اتفاق می‌افته.</li><li><strong>Once برای reset کردن نیست</strong><br>وقتی تابعی با Once اجرا شد، دیگه نمی‌تونید اون رو دوباره اجرا کنید. اگر نیاز به reset دارید، باید ساختار جدیدی بسازید.</li><li><strong>بهینه و سبک</strong><br><code>Once</code> به صورت داخلی فقط در اولین اجرا قفل می‌گیره و بعد از اون بدون هزینه قفل، مستقیماً ادامه می‌ده.</li></ol><h2 id=335-pool>3.3.5 Pool
<a class=anchor href=#335-pool>#</a></h2><p>در نسخه ۱.۳ زبان گو امکانی تایپی به نام Pool در پکیج sync که امکان ایجاد استخر آبجکت ها بطور موقت بدون اینکه بخواهد بخشی از حافظه را اشتغال کند اضافه شد. هر آبجکتی که در Pool ذخیره شود بطور خودکار در هرزمانی بدون اینکه اطلاع رسانی کند حذف می شود. امکان استفاده مجدد از آبجکت هایی که داخل استخر می گیرند وجود دارد و این باعث می شود سربار استفاده حافظه کاهش یابد.</p><center><a href=#><img src=../../assets/img/content/chapter3/sync/2.gif alt="sync pool"></a></center><div class=go-playground><pre class=line-numbers><code class=language-go>package main

import (
	"bytes"
	"io"
	"os"
	"sync"
	"time"
)

var bufPool = sync.Pool{
	New: func() any {
		// The Pool's New function should generally only return pointer
		// types, since a pointer can be put into the return interface
		// value without an allocation:
		return new(bytes.Buffer)
	},
}

// timeNow is a fake version of time.Now for tests.
func timeNow() time.Time {
	return time.Unix(1136214245, 0)
}

func Log(w io.Writer, key, val string) {
	b := bufPool.Get().(*bytes.Buffer)
	b.Reset()
	// Replace this with time.Now() in a real logger.
	b.WriteString(timeNow().UTC().Format(time.RFC3339))
	b.WriteByte(' ')
	b.WriteString(key)
	b.WriteByte('=')
	b.WriteString(val)
	w.Write(b.Bytes())
	bufPool.Put(b)
}

func main() {
	Log(os.Stdout, "path", "/search?q=flowers")
}</code></pre><button class=run-code>▶ اجرای کد</button>
<button class=copy-code>کپی</button>
<button class=hide-output>✖ بستن خروجی</button><pre class="run-output hidden"></pre></div><p>در بالا ما یک متغیر به نام bufPool ایجاد کردیم که یک آبجکت از نوع bytes.Buffer ایجاد می کند. سپس داخل تابع Log ما با استفاده از متد Get آبجکت مورد نظر را از Pool خارج و داخل متغیر b قرار دادیم و پس از آن عملیات لازم را برروی Buffer انجام و در نهایت با استفاده از متد Put آبجکت را به Pool اضافه کردیم. حالا اتفاقی که صورت گرفته ما عملیاتی که نیاز داشتیم را برروی آبجکت انجام دادیم بدون اینکه بخوایم بخشی از حافظه را درگیر کنیم.</p><h3 id=3351-بنچمارک-در-خصوص-pool>3.3.5.1 بنچمارک در خصوص Pool
<a class=anchor href=#3351-%d8%a8%d9%86%da%86%d9%85%d8%a7%d8%b1%da%a9-%d8%af%d8%b1-%d8%ae%d8%b5%d9%88%d8%b5-pool>#</a></h3><div class=go-playground><pre class=line-numbers><code class=language-go>package main

import (
   "sync"
   "testing")

type Person struct {
   Age int
}

var personPool = sync.Pool{
   New: func() interface{} { return new(Person) },
}

func BenchmarkWithoutPool(b *testing.B) {
   var p *Person
   b.ReportAllocs()
   b.ResetTimer()
   for i := 0; i < b.N; i++ {
      for j := 0; j < 10000; j++ {
         p = new(Person)
         p.Age = 23
      }
   }
}

func BenchmarkWithPool(b *testing.B) {
   var p *Person
   b.ReportAllocs()
   b.ResetTimer()
   for i := 0; i < b.N; i++ {
      for j := 0; j < 10000; j++ {
         p = personPool.Get().(*Person)
         p.Age = 23
         personPool.Put(p)
      }
   }
}</code></pre><button class=run-code>▶ اجرای کد</button>
<button class=copy-code>کپی</button>
<button class=hide-output>✖ بستن خروجی</button><pre class="run-output hidden"></pre></div><h3 id=3352-مثال-های-کاربردی>3.3.5.2 مثال های کاربردی
<a class=anchor href=#3352-%d9%85%d8%ab%d8%a7%d9%84-%d9%87%d8%a7%db%8c-%da%a9%d8%a7%d8%b1%d8%a8%d8%b1%d8%af%db%8c>#</a></h3><p><strong>مثال اول :</strong></p><p>فرض کنید شما می خواهید یک فایل csv را با کلی رکورد parse کنید. هر رکورد نیازمند این است که داخل یک ساختاری قرار بگیرد و ایجاد یک ساختار باعث می شود بخشی از حافظه اختصاص یابد به آن ساختار. حالا فکر کنید میلیون ها رکورد داشته باشید و این تخصیص حافظه می تواند باعث توقف برنامه شود.</p><p>حالا برای اینکه بخواهیم جلوی این اتفاق را بگیریم و سربار را کاهش دهیم بهتر است ما از sync.Pool استفاده کنیم و ساختارها را داخل استخر قرار دهیم. و زمانیکه هرکدام از ساختارها مورد نیاز نباشد می توانند داخل استخر قرار گیرند و مجدد استفاده شوند. اینکار باعث می شود بطور خیلی قابل توجهی تعداد تخصیص حافظه کاهش یابد و عملکرد برنامه چند برابر شود.</p><p><strong>مثال دوم :</strong></p><p>موارد استفاده دیگر از sync.Pool برای ذخیره کردن آبجکت های پرکاربرد نظیر کانکشن دیتابیس یا شبکه و همچنین آبجکت هایی که قصد داریم برروی آن عملیات serialize و deserialize انجام دهیم.</p><h2 id=336-cond>3.3.6 Cond
<a class=anchor href=#336-cond>#</a></h2><p><strong>پکیج <code>sync.Cond</code></strong> یکی از ابزارهای پیشرفته همزمانی در زبان Go است که امکان پیاده‌سازی الگوی &ldquo;<a href=../../chapter-9/concurrency-patterns/go-concurrency-pattern-monitor>مانیتور</a>&rdquo; یا همان <strong>شرط انتظاری (Condition Variable)</strong> را فراهم می‌کند. Cond به شما اجازه می‌دهد تا مجموعه‌ای از goroutineها را تا زمانی که یک شرط یا رویداد خاص برقرار نشده، به صورت امن و کارآمد (بدون busy-waiting یا مصرف بی‌مورد CPU) منتظر نگه دارید. زمانی که شرط مورد نظر برقرار شد، می‌توانید یک یا همه goroutineهای منتظر را بیدار کنید تا کارشان را ادامه دهند. این تکنیک، در بسیاری از الگوهای معروف concurrency مانند producer-consumer، صف انتظار، صف پیام و کنترل منابع محدود کاربرد اساسی دارد.</p><h4 id=نحوه-کار-cond-و-نقش-قفل-mutex--rwmutex><strong>نحوه کار Cond و نقش قفل (Mutex / RWMutex)</strong>
<a class=anchor href=#%d9%86%d8%ad%d9%88%d9%87-%da%a9%d8%a7%d8%b1-cond-%d9%88-%d9%86%d9%82%d8%b4-%d9%82%d9%81%d9%84-mutex--rwmutex>#</a></h4><p>برای ساخت یک شیء Cond باید یک قفل (معمولاً از نوع <code>*sync.Mutex</code> یا <code>*sync.RWMutex</code>) به آن بدهید. این قفل به Cond اجازه می‌دهد تا وضعیت مشترک (shared state) را در میان چند goroutine به طور thread-safe بررسی و کنترل کند. قفل، تضمین می‌کند که هیچ دو goroutineای همزمان نتوانند وضعیت را تغییر دهند یا به متدهای Cond دسترسی پیدا کنند، که این برای جلوگیری از race condition کاملاً حیاتی است.</p><pre><code class=language-go>lock := &amp;sync.Mutex{}
cond := sync.NewCond(lock)
</code></pre><h4 id=عملکرد-متدها><strong>عملکرد متدها</strong>
<a class=anchor href=#%d8%b9%d9%85%d9%84%da%a9%d8%b1%d8%af-%d9%85%d8%aa%d8%af%d9%87%d8%a7>#</a></h4><ul><li><p><strong>Wait():</strong>
وقتی یک goroutine متد Wait را صدا می‌زند، دو اتفاق پشت‌سرهم رخ می‌دهد:</p><ol><li>قفل داده‌شده (مثلاً Mutex) به طور موقت آزاد می‌شود تا سایر goroutineها بتوانند وضعیت مشترک را تغییر دهند.</li><li>goroutine تا زمان دریافت سیگنال (<code>Signal</code> یا <code>Broadcast</code>) به حالت تعلیق (sleep) می‌رود و هیچ پردازشی انجام نمی‌دهد (کاملاً غیرمسدودکننده).
پس از دریافت سیگنال و بیدار شدن، Wait دوباره به صورت اتمیک قفل را در اختیار می‌گیرد و اجرا از همان خط ادامه پیدا می‌کند.
معمولاً قبل از Wait باید شرط را داخل یک حلقه (for) بررسی کنید تا از <strong>spurious wakeup</strong> و رقابت داده‌ای جلوگیری شود:</li></ol><pre><code class=language-go>cond.L.Lock()
for !شرط_برقرار_است {
    cond.Wait()
}
// ادامه منطق ...
cond.L.Unlock()
</code></pre></li><li><p><strong>Signal():</strong>
این متد تنها <strong>یکی از goroutineهای منتظر</strong> را بیدار می‌کند (اگر کسی در صف انتظار باشد). انتخاب اینکه کدام goroutine بیدار شود به سیاست زمان‌بندی runtime وابسته است و تضمینی برای ترتیب خاصی وجود ندارد. Signal معمولاً زمانی به کار می‌رود که انتظار دارید فقط یک مصرف‌کننده با داده جدید یا تغییر وضعیت بیدار شود.</p></li><li><p><strong>Broadcast():</strong>
این متد <strong>همه goroutineهای منتظر روی آن Cond</strong> را بیدار می‌کند تا شرط را دوباره بررسی کنند. Broadcast زمانی کاربرد دارد که یک رویداد می‌تواند برای همه‌ی منتظرها مهم باشد (مثلاً اتمام کار یا آزاد شدن منبع برای همه مصرف‌کننده‌ها).</p></li></ul><p>به مثال زیر توجه کنید :</p><div class=go-playground><pre class=line-numbers><code class=language-go>package main

import (
	"fmt"
	"sync"
)

var sharedResource = make(map[string]interface{})

func main() {
	var wg sync.WaitGroup
	wg.Add(2)
	locker := sync.Mutex{}
	condition := sync.NewCond(&locker)

	go waitForResourceUpdate(&wg, condition, "rsc1")
	go waitForResourceUpdate(&wg, condition, "rsc2")

	// this one writes changes to sharedResource
	condition.L.Lock()
	sharedResource["rsc1"] = "a string"
	sharedResource["rsc2"] = 123456
	condition.Broadcast()
	condition.L.Unlock()

	wg.Wait()
}

// waitForResourceUpdate waits for a signal that a resource changed and prints it.
func waitForResourceUpdate(wg *sync.WaitGroup, cond *sync.Cond, key string) {
	defer wg.Done()
	cond.L.Lock()
	for len(sharedResource) == 0 {
		cond.Wait()
	}
	fmt.Println("Resource", key, ":", sharedResource[key])
	cond.L.Unlock()
}</code></pre><button class=run-code>▶ اجرای کد</button>
<button class=copy-code>کپی</button>
<button class=hide-output>✖ بستن خروجی</button><pre class="run-output hidden"></pre></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/GoFarsi/book/edit/main/content/chapter%203/3.3-sync.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt>
<span>این صفحه را ویرایش کنید</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script><div class="text-left page-navigation"><a href=/chapter-3/go-atomic/>3.4 پکیج atomic ◀︎</a></div><script>function toggleTooltip(e){e.classList.toggle("active")}</script><div id=graphcomment></div><script type=text/javascript>var __semio__params={graphcommentId:"book",behaviour:{}};function __semio__onload(){__semio__gc_graphlogin(__semio__params)}(function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.onload=__semio__onload,e.defer=!0,e.src="https://integration.graphcomment.com/gc_graphlogin.js?"+Date.now(),(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content></br><main><div class=wrapper><a href=https://t.me/GolangEngineers class="icon telegram" target=_blank><div class=tooltip>گروه تلگرامی مهندسین گولنگ</div><span><i class="fab fa-telegram"></i></span>
</a><a href=https://linkedin.com/in/Ja7ad class="icon linkedin" target=_blank><div class=tooltip>لینکدین نویسنده</div><span><i class="fab fa-linkedin"></i></span>
</a><a href=https://twitter.com/Ja7adR class="icon twitter" target=_blank><div class=tooltip>توییتر نویسنده</div><span><i class="fab fa-twitter"></i></span></a></div></main></br></br><nav id=TableOfContents><ul><li><ul><li><a href=#331-mutex--قفل-متقابل>3.3.1 Mutex — قفل متقابل</a><ul><li><a href=#مثال-تئوری--آشپزخانه-و-سیبزمینی-سرخکرده>مثال تئوری — آشپزخانه و سیب‌زمینی سرخ‌کرده</a></li><li><a href=#3111-ساختار-mutex-در-go>3.1.1.1 ساختار Mutex در Go</a></li><li><a href=#3112-مثال-ساده-mutex>3.1.1.2 مثال ساده Mutex</a></li><li><a href=#3113-نکات-کاربردی-و-تولیدی-mutex>3.1.1.3 نکات کاربردی و تولیدی Mutex</a></li><li><a href=#3114-مثال-پیشرفته-mutex-در-struct>3.1.1.4 مثال پیشرفته: Mutex در struct</a></li><li><a href=#3115-مزایا-و-معایب-mutex>3.1.1.5 مزایا و معایب Mutex</a></li><li><a href=#3316-سناریوهای-استفاده>3.3.1.6 سناریوهای استفاده</a></li></ul></li><li><a href=#332-rwmutex--قفل-خواندننوشتن>3.3.2 RWMutex — قفل خواندن/نوشتن</a><ul><li><a href=#3321-چرا-rwmutex>3.3.2.1 چرا RWMutex؟</a></li><li><a href=#3322-متدهای-اصلی-rwmutex>3.3.2.2 متدهای اصلی RWMutex</a></li><li><a href=#3323-مثال-ساده-rwmutex>3.3.2.3 مثال ساده RWMutex</a></li><li><a href=#3324-نکات-و-ترفندهای-استفاده-از-rwmutex>3.3.2.4 نکات و ترفندهای استفاده از RWMutex</a></li><li><a href=#3325-مثال-کاربردی--کش-خواندنینوشتنی>3.3.2.5 مثال کاربردی — کش خواندنی/نوشتنی</a></li></ul></li><li><a href=#333-waitgroup--هماهنگی-پایان-کار-goroutineها>3.3.3 WaitGroup — هماهنگی پایان کار goroutineها</a><ul><li><a href=#3331-متدهای-اصلی-waitgroup>3.3.3.1 متدهای اصلی WaitGroup</a></li><li><a href=#3332-مثال-ساده-waitgroup>3.3.3.2 مثال ساده WaitGroup</a></li><li><a href=#3333-مثال-کاربردی--دانلود-همزمان-فایلها>3.3.3.3 مثال کاربردی — دانلود همزمان فایل‌ها</a></li><li><a href=#3334-نکات-و-ترفندهای-استفاده-از-waitgroup>3.3.3.4 نکات و ترفندهای استفاده از WaitGroup</a></li><li><a href=#3335-اشتباه-رایج--add-داخل-goroutine>3.3.3.5 اشتباه رایج — Add داخل goroutine</a></li><li><a href=#3336-مثال-پیشرفته--پردازش-موازی-با-waitgroup-و-semaphore>3.3.3.6 مثال پیشرفته — پردازش موازی با WaitGroup و Semaphore</a></li></ul></li><li><a href=#334-once--اجرای-یک-کد-فقط-یکبار>3.3.4 Once — اجرای یک کد فقط یکبار</a><ul><li><a href=#3341-متد-اصلی-once>3.3.4.1 متد اصلی Once</a></li><li><a href=#3342-چرا-از-once-استفاده-کنیم>3.3.4.2 چرا از Once استفاده کنیم؟</a></li><li><a href=#3343-مثال-ساده-once>3.3.4.3 مثال ساده Once</a></li><li><a href=#3344-استفاده-از-once-برای-پیادهسازی-singleton>3.3.4.4 استفاده از Once برای پیاده‌سازی Singleton</a></li><li><a href=#3345-نکات-و-ترفندهای-استفاده-از-once>3.3.4.5 نکات و ترفندهای استفاده از Once</a></li></ul></li><li><a href=#335-pool>3.3.5 Pool</a><ul><li><a href=#3351-بنچمارک-در-خصوص-pool>3.3.5.1 بنچمارک در خصوص Pool</a></li><li><a href=#3352-مثال-های-کاربردی>3.3.5.2 مثال های کاربردی</a></li></ul></li><li><a href=#336-cond>3.3.6 Cond</a><ul><li></li></ul></li></ul></li></ul></nav></div></aside></main><button onclick=topFunction() id=myBtn title="رفتن به بالا" class="fas fa-solid fa-arrow-up"></button>
<script src=prism.js defer></script><script>document.getElementById("currentsv").innerHTML=window.location.href</script><script async>var html=document.documentElement,switcher=document.getElementsByClassName("js-toggle")[0];typeof Storage!="undefined"&&((localStorage.getItem("themeMode")=="dark"||document.documentElement.getAttribute("data-theme")=="dark")&&switcher.classList.add("js-toggle--checked"),switcher.classList.add("js-toggle--focus")),switcher.addEventListener("click",function(){this.classList.toggle("js-toggle--checked"),this.classList.add("js-toggle--focus"),this.classList.contains("js-toggle--checked")?(html.setAttribute("data-theme","dark"),localStorage.setItem("themeMode","dark")):(html.setAttribute("data-theme","light"),localStorage.setItem("themeMode","light"))})</script><script>let mybutton=document.getElementById("myBtn");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?mybutton.style.display="block":mybutton.style.display="none"}function topFunction(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script src=/js/playground.js defer></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js defer></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-go.min.js defer></script><script src=https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/line-numbers/prism-line-numbers.min.js defer></script><script>"serviceWorker"in navigator&&window.addEventListener("DOMContentLoaded",function(){navigator.serviceWorker.register("/sw.js")})</script></body></html>